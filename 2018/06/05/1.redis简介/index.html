<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Eureka" />



<meta name="description" content="系统学习redis的第一篇，首先来基本感受一下redis是什么，为什么用他？">
<meta name="keywords" content="redis学习">
<meta property="og:type" content="article">
<meta property="og:title" content="1.redis简介">
<meta property="og:url" content="http://yoursite.com/2018/06/05/1.redis简介/index.html">
<meta property="og:site_name" content="Eureka-Home">
<meta property="og:description" content="系统学习redis的第一篇，首先来基本感受一下redis是什么，为什么用他？">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/redis%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86111.png-1000width">
<meta property="og:image" content="http://redisbook.com/_images/graphviz-f0d024ca2782cbbe20e2cd1e52540d92f64b3a37.png">
<meta property="og:image" content="http://redisbook.com/_images/graphviz-f4835e5b07c5a6ab04e09dc8d887d62a1854ac94.png">
<meta property="og:updated_time" content="2018-06-05T05:35:18.943Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="1.redis简介">
<meta name="twitter:description" content="系统学习redis的第一篇，首先来基本感受一下redis是什么，为什么用他？">
<meta name="twitter:image" content="http://p376695fl.bkt.clouddn.com/redis%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86111.png-1000width">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Eureka-Home" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>1.redis简介 | Eureka-Home</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Eureka</a></h1>
        </hgroup>

        

        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/随笔">随笔</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Eureka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Eureka</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/随笔">随笔</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-1.redis简介" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/05/1.redis简介/" class="article-date">
      <time datetime="2018-06-05T01:44:10.499Z" itemprop="datePublished">2018-06-05</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      1.redis简介
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/redis/">redis</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis学习/">redis学习</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>系统学习redis的第一篇，首先来基本感受一下redis是什么，为什么用他？<br><a id="more"></a></p>
<h2 id="1-redis是什么"><a href="#1-redis是什么" class="headerlink" title="1. redis是什么"></a>1. redis是什么</h2><p><code>Redis</code>是一个开源的使用ANSI <strong>C语言编写</strong>、支持网络、<strong>单进程单线程</strong>、<strong>可基于内存亦可持久化的日志型</strong>、一个<strong>高性能的<code>key-value</code>数据库</strong>。</p>
<h2 id="2-Redis与其他key-value存储有什么不同"><a href="#2-Redis与其他key-value存储有什么不同" class="headerlink" title="2. Redis与其他key-value存储有什么不同"></a>2. Redis与其他key-value存储有什么不同</h2><ul>
<li>多样的数据结构和原子性操作</li>
</ul>
<p><strong><code>Redis</code>有着更为复杂的数据结构并且提供对他们的原子性操作</strong>，这是一个不同于其他数据库的进化路径。<code>Redis</code>的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p>
<ul>
<li>运行于内存+持久化于磁盘</li>
</ul>
<p><code>Redis</code>运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， <strong>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样<code>Redis</code>可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</strong>。</p>
<h2 id="3-redis特点"><a href="#3-redis特点" class="headerlink" title="3. redis特点"></a>3. redis特点</h2><blockquote>
<p><strong>速度快</strong>：基于内存,这是快的最主要原因。</p>
</blockquote>
<blockquote>
<p><strong>持久化</strong>：异步保存到磁盘中</p>
</blockquote>
<blockquote>
<p><strong>多种数据结构</strong>：除了五种基本数据类型，还支持位图、<code>HyperLogLog</code>，<code>GEO</code>等</p>
</blockquote>
<blockquote>
<p><strong>支持多种编程语言</strong>：<code>java</code>，<code>python</code>，<code>ruby</code>，<code>php</code>，<code>Lua</code>，<code>nodejs</code>…</p>
</blockquote>
<blockquote>
<p><strong>功能丰富</strong>：可以实现发布-订阅，支持事务、<code>Lua</code>脚本</p>
</blockquote>
<blockquote>
<p><strong>简单</strong>：不依赖与外部库、单线程模型</p>
</blockquote>
<blockquote>
<p><strong>主从复制</strong>：主服务器同步数据到从服务器，是高可用的基础</p>
</blockquote>
<blockquote>
<p><strong>高可用、分布式</strong>：高可用：<code>redis-Sentinel</code>(v2.8版本)；分布式：<code>redis-cluster</code>(v3.0版本)</p>
</blockquote>
<h2 id="4-redis典型应用场景"><a href="#4-redis典型应用场景" class="headerlink" title="4. redis典型应用场景"></a>4. redis典型应用场景</h2><blockquote>
<p><strong>缓存系统</strong>：这个就不多说了，<code>redis</code>作为高速缓存是其主要存在价值。</p>
</blockquote>
<blockquote>
<p><strong>计数器</strong>：因为是原子操作+单线程，作为计数器永远不会出错</p>
</blockquote>
<blockquote>
<p><strong>消息队列系统</strong>：数据结构可以实现这种生产者-消费者模式的消息队列。</p>
</blockquote>
<blockquote>
<p><strong>排行榜</strong>：有序集合sorted set就可以实现</p>
</blockquote>
<blockquote>
<p><strong>社交网络</strong>：<code>redis</code>与社交网络就是一家，非常方便就能实现诸如共同好友这些功能。</p>
</blockquote>
<blockquote>
<p><strong>实时系统</strong>：如垃圾邮件处理系统</p>
</blockquote>
<h2 id="5-redis优势"><a href="#5-redis优势" class="headerlink" title="5. redis优势"></a>5. redis优势</h2><blockquote>
<p><strong>缓存管理</strong>：可以在必要时将无效的旧数据从内存中删除，为新数据腾出新的空间</p>
</blockquote>
<blockquote>
<p><strong>提供更大的灵活性</strong>：<code>redis</code>支持多种类型，并且采用<code>key-value</code> 的形式存储，<code>key</code>和<code>value</code>的大小限制都是512Mb,与编码无关，所以数据安全。但是<code>memcached</code>限制<code>key</code>最大为250字节，<code>value</code>为1MB，况且只支持<code>String</code>类型。</p>
</blockquote>
<blockquote>
<p><strong><code>redis</code>提供主从复制</strong>：实现高可用的<code>cache</code>系统，支持集群中多个服务器之间的数据同步。</p>
</blockquote>
<blockquote>
<p><strong>数据持久化</strong>：<code>redis</code>可以通过两种方式将数据进行持久化，一定程度上规避缓存中的数据不稳定的问题，也可以在重启服务器时最快的恢复缓存中所需的数据，提高了效率的同事减轻了主数据库系统的开销。</p>
</blockquote>
<p>与传统的<code>Memcached</code>相比，优势还是很大的，但是<code>Memcached</code>也有不可替代的适用场景：</p>
<blockquote>
<p>存储一些粒度比较小的静态数据，比如一些html片段，<code>Memcached</code>便是我们更好的选择。相对于<code>redis</code>而言，<code>Memcached</code>的元数据<code>metadata</code>更小些，所以相对来讲对于数据存储管理的性能更高，额外开销更小。</p>
</blockquote>
<blockquote>
<p><code>Memcached</code>的特点：<code>Memcached</code>唯一支持的数据类型是<code>String</code>,所以更适合存储只读数据，因为字符串并不会因为额外的处理造成额外的开销。毕竟<code>Memcached</code>每次更新一个对象时，都需要重复执行下面的操作：获取整个字符串-&gt;反序列化为对象-&gt;修改其中的值-&gt;再次序列化该对象-&gt;在缓存中将整个字符串替换为新字符串。这样一来，更新存储数据就会有更高的消耗，可能就不是我们的最佳选择了。 </p>
</blockquote>
<h2 id="6-redis快的原因总结"><a href="#6-redis快的原因总结" class="headerlink" title="6. redis快的原因总结"></a>6. redis快的原因总结</h2><blockquote>
<p>完全基于内存</p>
</blockquote>
<p><code>Redis</code>是纯内存数据库，相对于读写磁盘，读写内存的速度就不是几倍几十倍了，一般，<code>hash</code>查找可以达到每秒百万次的数量级。</p>
<blockquote>
<p>多路复用IO</p>
</blockquote>
<p>“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）。可以直接理解为：单线程的原子操作，避免上下文切换的时间和性能消耗；加上对内存中数据的处理速度，很自然的提高redis的吞吐量。</p>
<h4 id="6-1-Redis为什么是单线程的？"><a href="#6-1-Redis为什么是单线程的？" class="headerlink" title="6.1 Redis为什么是单线程的？"></a>6.1 Redis为什么是单线程的？</h4><p>因为CPU不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<h4 id="6-2-为什么-Redis-中要使用-I-O-多路复用这种技术呢？"><a href="#6-2-为什么-Redis-中要使用-I-O-多路复用这种技术呢？" class="headerlink" title="6.2 为什么 Redis 中要使用 I/O 多路复用这种技术呢？"></a>6.2 为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h4><p>首先，<code>Redis</code> 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p>
<blockquote>
<p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p>
<ol>
<li><p>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p>
</li>
<li><p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</p>
</li>
<li><p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 </p>
</li>
</ol>
<p>第三种就是IO复用模型，<code>Linux</code>下的<code>select</code>、<code>poll</code>和<code>epoll</code>就是干这个的。<strong>将用户<code>socket</code>对应的<code>fd</code>注册进<code>epoll</code>，然后<code>epoll</code>帮你监听哪些<code>socket</code>上有消息到达</strong>，这样就避免了大量的无用操作。此时的<code>socket</code>应该采用非阻塞模式。这样，整个过程只在调用<code>select</code>、<code>poll</code>、<code>epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的<code>reactor</code>模式。</p>
</blockquote>
<h4 id="6-3-redis的线程模型？"><a href="#6-3-redis的线程模型？" class="headerlink" title="6.3 redis的线程模型？"></a>6.3 redis的线程模型？</h4><p><code>Redis</code> 服务采用 <code>Reactor</code> 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p>
<p><img src="http://p376695fl.bkt.clouddn.com/redis%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86111.png-1000width" alt="image"></p>
<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p>
<p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 <code>Redis</code> 服务实现的简单。</p>
<p>上面简单理解就是：多个网络连接并发读写redis的时候，先将对应的fd注册到<code>epoll</code>上，I/O多路复用模块会监听这些网络请求的情况，一旦有一个网络连接产生了<code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件，I/O多路复用模块就会向文件事件分派器传送那些产生了事件的网络连接。</p>
<p><img src="http://redisbook.com/_images/graphviz-f0d024ca2782cbbe20e2cd1e52540d92f64b3a37.png" alt="image"></p>
<p>当然了，上面的文件事件可能会并发产生，这时的策略是，将所有产生事件的套接字（对应上面的网络连接）都入队到一个队列里面， 然后通过这个队列， 以有序（<code>sequentially</code>）、同步（<code>synchronously</code>）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。</p>
<p><img src="http://redisbook.com/_images/graphviz-f4835e5b07c5a6ab04e09dc8d887d62a1854ac94.png" alt="image"></p>
<p>文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。</p>
<p>服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。</p>
<p><strong>整个模块使 <code>Redis</code> 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。</strong></p>
<p>最后，为什么<code>redis</code>比较快大概思路通俗的说就是：<code>Redis</code>是纯内存数据库，读取快，瓶颈在于IO上，如果使用阻塞式IO，因为是单线程的缘故，就会停止等待。所以采用IO多路复用监听文件描述符的状态，将对<code>redis</code>的开关读写换成事件，加入队列进行相应的事件处理，采用非阻塞IO，吞吐量比较大。</p>
<h2 id="7-reids在linux下的安装"><a href="#7-reids在linux下的安装" class="headerlink" title="7. reids在linux下的安装"></a>7. reids在linux下的安装</h2><p><code>Redis</code>对于<code>Linux</code>是官方支持的，安装起来也非常地简单，直接编译源码然后进行安装即可。</p>
<p>这里以<code>centos</code>为例，大概说一下步骤：</p>
<blockquote>
<p>下载redis编译工具:<code>yum install gcc</code>和<code>yum install g++</code></p>
</blockquote>
<blockquote>
<p>解压<code>redis.tar.gz</code>文件，进去之后进行编译:<code>make</code></p>
</blockquote>
<blockquote>
<p>然后安装：<code>make install PREFIX=/usr/local/redis</code></p>
</blockquote>
<blockquote>
<p>安装成功之后进入<code>/usr/local/redis/bin</code>下启动<code>redis</code></p>
<p><code>./redis-server</code></p>
</blockquote>
<h2 id="8-redis在windows环境下的安装"><a href="#8-redis在windows环境下的安装" class="headerlink" title="8. redis在windows环境下的安装"></a>8. redis在windows环境下的安装</h2><p>解压就能使用。下载地址为：<a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/06/05/1.redis简介/">1.redis简介</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Eureka</a></p>
        <p><span>发布时间:</span>2018-06-05, 09:44:10</p>
        <p><span>最后更新:</span>2018-06-05, 13:35:18</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/06/05/1.redis简介/" title="1.redis简介">http://yoursite.com/2018/06/05/1.redis简介/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/06/05/1.redis简介/　　作者: Eureka" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/06/05/2.redis基本数据结构的入门/">
                    2.redis基本数据结构的入门
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/06/04/15.高并发处理之应用限流思路/">
                    15.高并发处理之应用限流思路
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-redis是什么"><span class="toc-number">1.</span> <span class="toc-text">1. redis是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis与其他key-value存储有什么不同"><span class="toc-number">2.</span> <span class="toc-text">2. Redis与其他key-value存储有什么不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-redis特点"><span class="toc-number">3.</span> <span class="toc-text">3. redis特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-redis典型应用场景"><span class="toc-number">4.</span> <span class="toc-text">4. redis典型应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-redis优势"><span class="toc-number">5.</span> <span class="toc-text">5. redis优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-redis快的原因总结"><span class="toc-number">6.</span> <span class="toc-text">6. redis快的原因总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-Redis为什么是单线程的？"><span class="toc-number">6.0.1.</span> <span class="toc-text">6.1 Redis为什么是单线程的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-为什么-Redis-中要使用-I-O-多路复用这种技术呢？"><span class="toc-number">6.0.2.</span> <span class="toc-text">6.2 为什么 Redis 中要使用 I/O 多路复用这种技术呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-redis的线程模型？"><span class="toc-number">6.0.3.</span> <span class="toc-text">6.3 redis的线程模型？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-reids在linux下的安装"><span class="toc-number">7.</span> <span class="toc-text">7. reids在linux下的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-redis在windows环境下的安装"><span class="toc-number">8.</span> <span class="toc-text">8. redis在windows环境下的安装</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"1.redis简介　| Eureka-Home　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/06/05/2.redis基本数据结构的入门/" title="上一篇: 2.redis基本数据结构的入门">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/06/04/15.高并发处理之应用限流思路/" title="下一篇: 15.高并发处理之应用限流思路">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/随笔1/">她</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/Java虚拟机总概览/">Java虚拟机总概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/Socket基础/">Socket基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/maven/">maven</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/计算机网络/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/计算机操作系统/">计算机操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/分布式问题分析/">分布式问题分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/分布式基础/">分布式基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/HTTP/">HTTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/Git/">Git</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/十二、Java并发总览/">十二、Java并发总览</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/十一、深入分析ThreadLocal内存泄漏问题/">十一、深入分析ThreadLocal内存泄漏问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/十、ThreadLocal详解/">十、ThreadLocal详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/9.缓存设计与优化/">9.缓存设计与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/8.redis cluster实践--淘淘商城的某一节/">8.redis cluster实践--淘淘商城的某一节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/7.redis cluster理论详解/">7.redis cluster理论详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/6.redis sentinel实现高可用读写分离/">6.redis sentinel实现高可用读写分离</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/5.redis主从复制/">5.redis主从复制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/4.redis持久化/">4.redis持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/3.redis其他的功能/">3.redis其他的功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/2.redis基本数据结构的入门/">2.redis基本数据结构的入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/1.redis简介/">1.redis简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/15.高并发处理之应用限流思路/">15.高并发处理之应用限流思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/14.高并发处理之应用拆分思路/">14.高并发处理之应用拆分思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/13.高并发处理之消息队列思路/">13.高并发处理之消息队列思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/12.高并发处理之缓存思路/">12.高并发处理之缓存思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/11.多线程并发拓展/">11.多线程并发拓展</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/10.线程池/">10.线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/9.JUC组件拓展-BlockingQueue/">9.JUC组件拓展-BlockingQueue</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/8.JUC组件拓展-ForkJoin简介/">8.JUC组件拓展-ForkJoin简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/7.JUC组件拓展-Callable、Future和FutureTask/">7.JUC组件拓展-Callable、Future和FutureTask</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/6.AQS以及同步组件/">6.AQS以及同步组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/5.线程安全策略/">5.线程安全策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/4.安全发布对象/">4.安全发布对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/3.线程安全性-synchronized/">3.线程安全性-synchronized</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/2.线程安全性-Atomic包/">2.线程安全性-Atomic包</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/1.基础介绍和线程安全性问题展示/">1.基础介绍和线程安全性问题展示</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/九、Lock接口简单体验/">九、Lock接口简单体验</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/八、JVM对synchronized的优化/">八、JVM对synchronized的优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/七、读写锁/">七、读写锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/六、volatile详解/">六、volatile详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/五、从卖票程序看synchronized特性/">五、从卖票程序看synchronized特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/四、Thread类方法详解/">四、Thread类方法详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/三、线程的创建和线程状态/">三、线程的创建和线程状态</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/二、基础概念/">二、基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/一、基础概念/">一、线程基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/13、HashMap死循环问题/">13、HashMap死循环问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/12、深入fail-fast/">12、深入fail-fast</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/11、LinkedHashSet源码解析/">11、LinkedHashSet源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/10、HashSet源码解析/">10、HashSet源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/9、Hashtable源码分析/">9、Hashtable源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/8、HashMap和LinkedHashMap遍历机制/">8、HashMap和LinkedHashMap遍历机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/7、LinkedHashMap源码分析/">7、LinkedHashMap源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/6、HashMap源码分析/">6、HashMap源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/5、hashcode和equals/">5、hashcode和equals</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/4、CopyOnWriteArrayList源码分析/">4、CopyOnWriteArrayList源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/3、LinkedList源码分析/">3、LinkedList源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/2、ArrayList源码分析/">2、ArrayList源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/1、Java容器概览/">1、Java容器概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/10.java字符串/">10.java字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/9.Java IO/">9.Java IO</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/8.java面向对象/">8.java面向对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/7.java克隆/">7.java克隆</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/6.java泛型/">6.java泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/5.java异常/">5.java异常</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/4.java注解/">4.java注解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/3.java动态代理/">3.java动态代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/2.java反射/">2.java反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/1.Java基础/">1.Java基础</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018 Eureka
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 2;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>