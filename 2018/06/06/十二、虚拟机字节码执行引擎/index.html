<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Eureka" />



<meta name="description" content="本章讲解虚拟机字节码执行引擎。">
<meta name="keywords" content="java虚拟机">
<meta property="og:type" content="article">
<meta property="og:title" content="十二、虚拟机字节码执行引擎">
<meta property="og:url" content="http://yoursite.com/2018/06/06/十二、虚拟机字节码执行引擎/index.html">
<meta property="og:site_name" content="Eureka-Home">
<meta property="og:description" content="本章讲解虚拟机字节码执行引擎。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201510/26/1445842104_1318.png">
<meta property="og:image" content="http://img.blog.csdn.net/20151227134135995">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201510/30/1446191292_5195.png">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201510/30/1446191500_9417.png">
<meta property="og:image" content="https://gavinzhang1.gitbooks.io/java-jvm-us/content/20141214124042156.png">
<meta property="og:image" content="http://img.blog.csdn.net/20151227141504402">
<meta property="og:image" content="http://img.blog.csdn.net/20151227151012844">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201510/27/1445926411_3990.png">
<meta property="og:image" content="http://img.blog.csdn.net/20151227160915577">
<meta property="og:image" content="http://img.blog.csdn.net/20151227162142480">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A41.png">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A42.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160103134811229">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E4%B8%BB%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E4%BB%A4.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160103193210732">
<meta property="og:image" content="http://img.blog.csdn.net/20160103185730474">
<meta property="og:updated_time" content="2018-06-13T13:10:19.851Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十二、虚拟机字节码执行引擎">
<meta name="twitter:description" content="本章讲解虚拟机字节码执行引擎。">
<meta name="twitter:image" content="http://img.my.csdn.net/uploads/201510/26/1445842104_1318.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Eureka-Home" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/avatar.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>十二、虚拟机字节码执行引擎 | Eureka-Home</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Eureka</a></h1>
        </hgroup>

        
        <p class="header-subtitle">学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</p>
        

        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/随笔">随笔</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/resume/">简历</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Eureka</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Eureka</a></h1>
            </hgroup>
            
            <p class="header-subtitle">学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/随笔">随笔</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/resume/">简历</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-十二、虚拟机字节码执行引擎" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/06/十二、虚拟机字节码执行引擎/" class="article-date">
      <time datetime="2018-06-06T09:31:56.278Z" itemprop="datePublished">2018-06-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      十二、虚拟机字节码执行引擎
    </h1>
  

        
      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java虚拟机/">java虚拟机</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本章讲解虚拟机字节码执行引擎。<br><a id="more"></a></p>
<p>我们都知道，在当前的Java中（1.0）之后，编译器讲源代码转成字节码，那么字节码如何被执行的呢？这就涉及到了JVM的字节码执行引擎，执行引擎负责具体的代码调用及执行过程。就目前而言，所有的执行引擎的基本一致：</p>
<blockquote>
<p>输入：字节码文件</p>
<p>处理：字节码解析</p>
<p>输出：执行结果</p>
</blockquote>
<p>物理机的执行引擎是由硬件实现的，和物理机的执行过程不同的是虚拟机的执行引擎由于自己实现的。</p>
<h2 id="1-运行时候的栈结构"><a href="#1-运行时候的栈结构" class="headerlink" title="1. 运行时候的栈结构"></a>1. 运行时候的栈结构</h2><p>每一个线程都有一个栈,也就是前文中提到的虚拟机栈，栈中的基本元素我们称之为栈帧。</p>
<p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。</p>
<p>每个栈帧都包括了一下几部分：局部变量表、操作数栈、动态连接、方法的返回地址 和一些额外的附加信息。</p>
<p>栈帧中需要多大的局部变量表和多深的操作数栈在编译代码的过程中已经完全确定，并写入到方法表的Code属性中。</p>
<p>在活动的线程中，位于当前栈顶的栈帧才是有效的，称之为当前帧，与这个栈帧相关联的方法称为当前方法。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>需要注意的是一个栈中能容纳的栈帧是受限，过深的方法调用可能会导致<code>StackOverFlowError</code>，当然，我们可以认为设置栈的大小。其模型示意图大体如下： </p>
<p><img src="http://img.my.csdn.net/uploads/201510/26/1445842104_1318.png" alt="image"></p>
<p>还有一张图不错：</p>
<p><img src="http://img.blog.csdn.net/20151227134135995" alt="image"></p>
<h3 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a>1.1 局部变量表</h3><p>是变量值的存储空间，由方法参数和方法内部定义的局部变量组成，其容量用<code>Slot</code>作为最小单位。</p>
<p>在编译期间，就在方法的<code>Code</code>属性的<code>max_locals</code>数据项中确定了该方法所需要分配的局部变量表的最大容量。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p>
<p>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</p>
<p>如果是实例方法，那局部变量表第0位索引的<code>Slot</code>存储的是方法所属对象实例的引用，因此在方法内可以通过关键字<code>this</code>来访问到这个隐含的参数。其余的参数按照参数表顺序排列，参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    call(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    ...</span><br><span class="line">    call2(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call2</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时<code>call()</code>所对应的栈帧中的局部变量表大体如下： </p>
<p><img src="http://img.my.csdn.net/uploads/201510/30/1446191292_5195.png" alt="image"></p>
<p>而call2()所对应的栈帧的局部变量表大体如下：</p>
<p><img src="http://img.my.csdn.net/uploads/201510/30/1446191500_9417.png" alt="image"></p>
<p>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，重叠过程如下图：</p>
<p><img src="https://gavinzhang1.gitbooks.io/java-jvm-us/content/20141214124042156.png" alt="image"></p>
<h3 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a>1.2 操作数栈</h3><p>后入先出栈，由字节码指令往栈中存数据和取数据，栈中的任何一个元素都是可以任意的Java数据类型。</p>
<p>和局部变量类似，操作数栈的最大深度也在编译的时候写入到Code属性的<code>max_stacks</code>数据项中。</p>
<p>当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
<p>另外我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<h3 id="1-3-动态连接"><a href="#1-3-动态连接" class="headerlink" title="1.3 动态连接"></a>1.3 动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有该引用是为了支持方法调用过程中的动态连接。</p>
<h3 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a>1.4 方法返回地址</h3><p>存放调用该方法的pc计数器的值。</p>
<p>当一个方法开始之后，只有两种方式可以退出这个方法：</p>
<ul>
<li>执行引擎遇到任意一个方法返回的字节码指令，也就是所谓的正常完成出口。</li>
<li>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种方式成为异常完成出口。</li>
</ul>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 </p>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置，方法正常退出时，调用者的pc计数器的值作为返回地址，而通过异常退出的，返回地址是要通过异常处理器表来确定，栈帧中一般不会保存这部分信息。本质上，方法的退出就是当前栈帧出栈的过程。</p>
<h2 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h2><p>方法调用的主要任务就是确定被调用方法的版本（即调用哪一个方法），该过程不涉及方法具体的运行过程。按照调用方式共分为两类：</p>
<ul>
<li>解析调用是静态的过程，在编译期间就完全确定目标方法。</li>
<li>分派调用即可能是静态，也可能是动态的，根据分派标准可以分为单分派和多分派。两两组合有形成了静态单分派、静态多分派、动态单分派、动态多分派</li>
</ul>
<h3 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h3><p>在Class文件中，所有方法调用中的目标方法都是常量池中的符号引用，在类加载的解析阶段，会将一部分符号引用转为直接引用，也就是在编译阶段就能够确定唯一的目标方法，这类方法的调用称为解析调用。</p>
<p>此类方法主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可访问，因此决定了他们都不可能通过继承或者别的方式重写该方法，符合这两类的方法主要有以下几种：静态方法、私有方法、实例构造器、父类方法。虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li><code>invokestatic</code>：调用静态方法，解析阶段确定唯一方法版本</li>
<li><code>invokespecial</code>：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li><code>invokevirtual</code>：调用所有虚方法</li>
<li><code>invokeinterface</code>：调用接口方法</li>
<li><code>invokedynamic</code>：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而<code>invokedynamic</code>指令则支持由用户确定方法版本。其中<code>invokestatic</code>指令和<code>invokespecial</code>指令调用的方法称为非虚方法，其余的（<code>final</code>修饰的除外）称为虚方法。</p>
<h3 id="2-2-分派"><a href="#2-2-分派" class="headerlink" title="2.2 分派"></a>2.2 分派</h3><p>分派调用更多的体现在多态上。</p>
<ul>
<li>静态分派：所有依赖静态类型来定位方法执行版本的分派成为静态分派，发生在编译阶段，典型应用是方法重载。</li>
<li>动态分派：在运行期间根据实际类型来确定方法执行版本的分派成为动态分派，发生在程序运行期间，典型的应用是方法的重写。</li>
<li>单分派：根据一个宗量对目标方法进行选择。</li>
<li>多分派：根据多于一个宗量对目标方法进行选择。</li>
</ul>
<p><strong>静态分派</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"hello guy..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"hello man..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"hello woman..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">        StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();  </span><br><span class="line">        sd.sayHello(man); </span><br><span class="line">        sd.sayHello((Man)man); </span><br><span class="line">        sd.sayHello(woman); </span><br><span class="line">        sd.sayHello((Woman)woman);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello guy...</span><br><span class="line">hello man...</span><br><span class="line">hello guy...</span><br><span class="line">hello woman...</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>但为什么会选择执行参数为<code>Human</code>的重载呢？在这之前，先按如下代码定义两个重要的概念：<code>Human man = new Man()</code>;</p>
<p>上面代码中的<code>Human</code>称为变量的静态类型(<code>Static Type</code>)或者外观类型(<code>Apparent Type</code>)，后面的“Man”则称为变量的实际类型(<code>Actual Type</code>)，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译期可知的；而实际类型变化的结果在运行期才可确定，编译期在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际类型变化  </span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">man = <span class="keyword">new</span> Woman();  </span><br><span class="line"><span class="comment">//静态类型变化  </span></span><br><span class="line">sd.sayHello((Man)man);  </span><br><span class="line">sd.sayHello((Woman)man);</span><br></pre></td></tr></table></figure>
<p>即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">    Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">    StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();  </span><br><span class="line">    sd.sayHello(man);  <span class="comment">//man</span></span><br><span class="line">    sd.sayHello((Woman)woman);  <span class="comment">//woman</span></span><br><span class="line">    </span><br><span class="line">    man = <span class="keyword">new</span> Woman();<span class="comment">//实际类型发生变化</span></span><br><span class="line">    <span class="comment">//sd.sayHello((Man)man);报错 ：Woman cannot be cast to chapter12.StaticDispatch$Man</span></span><br><span class="line">    sd.sayHello((Woman)man); <span class="comment">//woman</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main()</code>里面的两次<code>sayHello()</code>方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数和数据类型。代码中刻意定义了两个静态类型相同，实际类型不同的变量，但<strong>虚拟机(准确地说是编译器)在重载时是通过参数的静态类型而不是实际类型作为判定依据的</strong>。并且静态类型在编译期是可知的，所以在编译阶段，Javac编译器就根据参数的静态类型决定使用哪个重载版本，所以选择了<code>sayHello(Human)</code>作为调用目标，并把这个方法的符号引用写到<code>main()</code>方法的两条<code>invokevirual</code>指令的参数中。</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动力实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但是很多情况下，这个重载版本并不是“唯一的”，往往只能确定一个“更适合的”版本。这种模糊的结论在0和1构成的计算机世界中算是个比较“稀罕”的事件，产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。</p>
<p><strong>动态分派</strong></p>
<p>动态分派与重写(<code>Override</code>)有着很密切的关联。如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtayfjpk.jvm.chapter8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">        man.sayHello();  </span><br><span class="line">        woman.sayHello();  </span><br><span class="line">        man = <span class="keyword">new</span> Woman();  </span><br><span class="line">        man.sayHello();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里显示不可能是根据静态类型来决定的，因为静态类型都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时执行了不同的行为，并且变量<code>man</code>在两次调用中执行了不同的方法。导致这个现象的原是是这两个变量的实际类型不同。那么Java虚拟机是如何根据实际类型来分派方法执行版本的呢，我们使用javap命令输出这段代码的字节码，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;  </span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC  </span><br><span class="line">  Code:  </span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span>  </span><br><span class="line">       0: new           #16                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Man  </span><br><span class="line">       <span class="number">3</span>: dup  </span><br><span class="line">       4: invokespecial #18                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Man."&lt;init&gt;":()V  </span><br><span class="line">       <span class="number">7</span>: astore_1  </span><br><span class="line">       8: new           #19                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman  </span><br><span class="line">      <span class="number">11</span>: dup  </span><br><span class="line">      12: invokespecial #21                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman."&lt;init&gt;":()V  </span><br><span class="line">      <span class="number">15</span>: astore_2  </span><br><span class="line">      <span class="number">16</span>: aload_1  </span><br><span class="line">      17: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      <span class="number">20</span>: aload_2  </span><br><span class="line">      21: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      24: new           #19                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman  </span><br><span class="line">      <span class="number">27</span>: dup  </span><br><span class="line">      28: invokespecial #21                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman."&lt;init&gt;":()V  </span><br><span class="line">      <span class="number">31</span>: astore_1  </span><br><span class="line">      <span class="number">32</span>: aload_1  </span><br><span class="line">      33: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      <span class="number">36</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>0-15行的字节码是准备动作，作用是建立<code>man</code>和<code>woman</code>的内存空间，调用Man和Woman类的实例构造器，将这两个实例的引用存放在第1和第2个局部变量表Slot之中，这个动作对应了代码中这两句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>
<p>接下来的第16-21行是关键部分，第16和第20两行分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将执行的<code>sayHello()</code>方法的所有者，称为接收者(<code>Receiver</code>)。</p>
<p>第17和第21两行是方法调用指令，单从字节码的角度来看，这两条调用指令无论是指令(都是<code>invokevirtual</code>)还是参数(都是常量池中<code>Human.sayHello()</code>的符号引用)都完全一样，但是这两条指令最终执行的目标方法并不相同，其原因需要从<code>invokevirutal</code>指令的多态查找过程开始说起，<code>invokevirtual</code>指令的运行时解析过程大致分为以下步骤：</p>
<ul>
<li>找到操作数栈顶的第一个元素所指向的对象实际类型，记作C。</li>
<li>如果在类型C中找到与常量中描述符和简单名称都相同的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找结束；不通过则返回<code>java.lang.IllegalAccessError</code>错误。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索与校验过程。</li>
<li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>错误。</li>
</ul>
<p>由于<code>invokevirtual</code>指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>
<p><strong>单分派与多分派</strong></p>
<p>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派与多分派两种。单分派是根据一个宗量来对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。<br>在编译期的静态分派过程选择目标方法的依据有两点：一是静态类型；二是方法参数，所以Java语言的静态分派属于多分派类型。在运行阶段虚拟机的动态分派过程只能接收者的实际类型一个宗量作为目标方法选择依据，所以Java语言的动态分派属于单分派类型。<strong>所以Java语言是一门静态多分派，动态单分派语言</strong>。</p>
<h3 id="2-3-JVM实现动态分派"><a href="#2-3-JVM实现动态分派" class="headerlink" title="2.3 JVM实现动态分派"></a>2.3 JVM实现动态分派</h3><p>动态分派在Java中被大量使用，使用频率及其高，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此JVM在类的方法区中建立虚方法表（virtual method table）来提高性能。每个类中都有一个虚方法表，表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表中该方法的地址入口和父类该方法的地址入口一样，即子类的方法入口指向父类的方法入口。如果子类重写父类的方法，那么子类的虚方法表中该方法的实际入口将会被替换为指向子类实现版本的入口地址。<br>那么虚方法表什么时候被创建？虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
<p>由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要在运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真的进行如此频繁的搜索。面对这种情况，最常用的优化手段就是在类的方法区中建立一个虚方法表(<code>Virtual Method Table</code>，也称<code>vtable</code>，与此对应，在<code>invokeinterface</code>执行时也会用到接口方法表，<code>Interface Method Table</code>，也称<code>itabl</code>e)，使用虚方法表索引来代替元数据据查找以提高性能。</p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会被替换为指向子类实现版本的地址入口。</p>
<h3 id="2-4-以例子来说明方法调用过程"><a href="#2-4-以例子来说明方法调用过程" class="headerlink" title="2.4 以例子来说明方法调用过程"></a>2.4 以例子来说明方法调用过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.louis.jvm.codeset;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * JVM 原理简单用例 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> louis </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        String name = <span class="string">"Louis"</span>;  </span><br><span class="line">        greeting(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Hello,"</span>+name);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们将<code>Bootstrap.java</code> 编译成<code>Bootstrap.class</code> 并运行这段程序的时候，在JVM复杂的运行逻辑中，会有以下几步：</p>
<blockquote>
<ol>
<li>首先JVM会先将这个<code>Bootstrap.class</code> 信息加载到 内存中的方法区(Method Area)中。Bootstrap.class 中包含了常量池信息，方法的定义 以及编译后的方法实现的二进制形式的机器指令，所有的线程共享一个方法区，从中读取方法定义和方法的指令集。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>接着，JVM会在Heap堆上为<code>Bootstrap.class</code> 创建一个<code>Class&lt;Bootstrap&gt;</code>实例用来表示<code>Bootstrap.class</code> 的 类实例。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>JVM开始执行<code>main</code>方法，这时会为<code>main</code>方法创建一个栈帧，以表示main方法的整个执行过程（我会在后面章节中详细展开这个过程）；</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li><code>main</code>方法在执行的过程之中，调用了<code>greeting</code>静态方法，则JVM会为<code>greeting</code>方法创建一个栈帧，推到虚拟机栈顶（我会在后面章节中详细展开这个过程）。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>当<code>greeting</code>方法运行完成后，则<code>greeting</code>方法出栈，<code>main</code>方法继续运行；</li>
</ol>
</blockquote>
<p><img src="http://img.blog.csdn.net/20151227141504402" alt="image"></p>
<p>JVM方法调用的过程是通过栈帧来实现的，那么，方法的指令是如何运行的呢？弄清楚这个之前，我们要先了解对于JVM而言，方法的结构是什么样的。</p>
<p>我们知道，class 文件是 JVM能够识别的二进制文件，其中通过特定的结构描述了每个方法的定义。</p>
<p>JVM在编译<code>Bootstrap.java</code> 的过程中，在将源代码编译成二进制机器码的同时，会判断其中的每一个方法的三个信息：</p>
<ul>
<li>1 ).  在运行时会使用到的局部变量的数量（作用是：当JVM为方法创建栈帧的时候，在栈帧中为该方法创建一个局部变量表，来存储方法指令在运算时的局部变量值）</li>
<li>2 ).  其机器指令执行时所需要的最大的操作数栈的大小（当JVM为方法创建栈帧的时候，在栈帧中为方法创建一个操作数栈，保证方法内指令可以完成工作）</li>
<li>3 ).  方法的参数的数量</li>
</ul>
<p>经过编译之后，我们可以得到<code>main</code>方法和<code>greeting</code>方法的信息如下：</p>
<p><img src="http://img.blog.csdn.net/20151227151012844" alt="image"></p>
<h2 id="3-方法的执行"><a href="#3-方法的执行" class="headerlink" title="3. 方法的执行"></a>3. 方法的执行</h2><h3 id="3-1-解释执行"><a href="#3-1-解释执行" class="headerlink" title="3.1 解释执行"></a>3.1 解释执行</h3><p>在jdk 1.0时代，Java虚拟机完全是解释执行的，随着技术的发展，现在主流的虚拟机中大都包含了即时编译器(JIT)。因此，虚拟机在执行代码过程中，到底是解释执行还是编译执行，只有它自己才能准确判断了，但是无论什么虚拟机，其原理基本符合现代经典的编译原理，如下图所示： </p>
<p><img src="http://img.my.csdn.net/uploads/201510/27/1445926411_3990.png" alt="image"></p>
<p>在Java中，javac编译器完成了词法分析、语法分析以及抽象语法树的过程，最终遍历语法树生成线性字节码指令流的过程，此过程发生在虚拟机外部。</p>
<h3 id="3-2-基于栈的指令集与基于寄存器的指令集"><a href="#3-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="3.2 基于栈的指令集与基于寄存器的指令集"></a>3.2 基于栈的指令集与基于寄存器的指令集</h3><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。</p>
<p>另外一种指令集架构则是基于寄存器的指令集架构，典型的应用是x86的二进制指令集，比如传统的PC以及Android的Davlik虚拟机。</p>
<p>两者之间最直接的区别是，基于栈的指令集架构不需要硬件的支持，而基于寄存器的指令集架构则完全依赖硬件，这意味基于寄存器的指令集架构执行效率更高，单可移植性差，而基于栈的指令集架构的移植性更高，但执行效率相对较慢，初次之外，相同的操作，基于栈的指令集往往需要更多的指令，比如同样执行2+3这种逻辑操作，其指令分别如下： </p>
<p>基于栈的计算流程（以Java虚拟机为例）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2  </span><br><span class="line">istore_1  </span><br><span class="line">iconst_3  </span><br><span class="line">istore_2  </span><br><span class="line">iload_1   </span><br><span class="line">iload_2   </span><br><span class="line">iadd      </span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>
<p>而基于寄存器的计算流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2  //将eax寄存器的值设为1</span><br><span class="line">add eax,3  //使eax寄存器的值加3</span><br></pre></td></tr></table></figure>
<h3 id="3-3-基于栈的代码执行示例"><a href="#3-3-基于栈的代码执行示例" class="headerlink" title="3.3 基于栈的代码执行示例"></a>3.3 基于栈的代码执行示例</h3><p>下面我们用简单的案例来解释一下JVM代码执行的过程，代码实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> result =(i+j)*c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MainTest.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap指令查看字节码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public MainTest();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public static int add();</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=0     //栈深度2，局部变量4个，参数0个</span><br><span class="line">         0: iconst_0  //对应result=0,0入栈</span><br><span class="line">         1: istore_0  //取出栈顶元素0，将其存放在第0个局部变量solt中</span><br><span class="line">         2: iconst_2  //对应i=2,2入栈</span><br><span class="line">         3: istore_1  //取出栈顶元素2，将其存放在第1个局部变量solt中</span><br><span class="line">         4: iconst_3  //对应 j=3，3入栈</span><br><span class="line">         5: istore_2  //取出栈顶元素3，将其存放在第2个局部变量solt中</span><br><span class="line">         6: iconst_5  //对应c=5，5入栈</span><br><span class="line">         7: istore_3  //取出栈顶元素，将其存放在第3个局部变量solt中</span><br><span class="line">         8: iload_1   //将局部变量表的第一个slot中的数值2复制到栈顶</span><br><span class="line">         9: iload_2   //将局部变量表中的第二个slot中的数值3复制到栈顶</span><br><span class="line">        10: iadd      //两个栈顶元素2,3出栈，执行相加，将结果5重新入栈</span><br><span class="line">        11: iload_3   //将局部变量表中的第三个slot中的数字5复制到栈顶</span><br><span class="line">        12: imul      //两个栈顶元素出栈5,5出栈，执行相乘，然后入栈</span><br><span class="line">        13: dup       //复制栈顶元素25，并将复制值压入栈顶.</span><br><span class="line">        14: istore_0  //取出栈顶元素25，将其存放在第0个局部变量solt中</span><br><span class="line">        15: ireturn   //将栈顶元素25返回给它的调用者</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 5: 2</span><br><span class="line">        line 6: 4</span><br><span class="line">        line 7: 6</span><br><span class="line">        line 8: 8</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: invokestatic  #2                  // Method add:()I</span><br><span class="line">         3: pop</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-继续以上面个例子来说明方法执行过程"><a href="#3-4-继续以上面个例子来说明方法执行过程" class="headerlink" title="3.4 继续以上面个例子来说明方法执行过程"></a>3.4 继续以上面个例子来说明方法执行过程</h3><h5 id="3-4-1-为main方法创建栈帧"><a href="#3-4-1-为main方法创建栈帧" class="headerlink" title="3.4.1 为main方法创建栈帧"></a>3.4.1 为main方法创建栈帧</h5><p>JVM解析main方法，发现其 局部变量的数量为 2，操作数栈的数量为1， 则会为main方法创建一个栈帧（VM Stack），并将其加入虚拟机栈中：</p>
<p><img src="http://img.blog.csdn.net/20151227160915577" alt="image"></p>
<h5 id="3-4-2-完成栈帧初始化"><a href="#3-4-2-完成栈帧初始化" class="headerlink" title="3.4.2 完成栈帧初始化"></a>3.4.2 完成栈帧初始化</h5><p>main栈帧创建完成后，会将栈帧push 到虚拟机栈中，现在有两步重要的事情要做：</p>
<p>a). 计算PC值。PC 是指令计数器，其内部的值决定了JVM虚拟机下一步应该执行哪一个机器指令，而机器指令存放在方法区，我们需要让PC的值指向方法区的main方法上；</p>
<p>初始化 PC = main方法在方法区指令的地址+0；</p>
<p>b). 局部变量的初始化。main方法有个入参(String[] args) ，JVM已经在main所在的栈帧的局部变量表中为其空出来了一个slot ，我们需要将 args 的引用值初始化到局部点亮表中；</p>
<p><img src="http://img.blog.csdn.net/20151227162142480" alt="image"></p>
<p>接着JVM开始读取PC指向的机器指令。如上图所示，main方法的指令序列：12 10 4c 2b b8 20 12 b1 ，通过JVM虚拟机指令集规范，可以将这个指令序列解析成以下Java汇编语言:</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A41.png" alt="image"><br><img src="http://p376695fl.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A42.png" alt="image"></p>
<p>当main方法调用greeting()时， JVM会为greeting方法创建一个栈帧，用以表示对greeting方法的调用，具体栈帧信息如下：</p>
<p><img src="http://img.blog.csdn.net/20160103134811229" alt="image"></p>
<p>具体的greeting方法的机器码表示的含义如下所示：</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E4%B8%BB%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E4%BB%A4.png" alt="image"></p>
<p><strong>总结：</strong></p>
<blockquote>
<p>由于JVM的指令是基于栈的，即大部分的指令的执行，都伴随着操作数的出栈和入栈。所以在学习JVM的机器指令的时候，一定要铭记一点：</p>
<p>每个机器指令的执行，对操作数栈和局部变量产生影响。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160103193210732" alt="image"></p>
<p><strong>机器指令的格式</strong></p>
<p><img src="http://img.blog.csdn.net/20160103185730474" alt="image"></p>
<ul>
<li><p>a).  如上图所示JVM虚拟机的操作码是由一个字节组成的，也就是说对于JVM虚拟机而言，其指令的数量最多为 2^8,即 256个;</p>
</li>
<li><p>b). 上图中的操作码如:b2,bb,59….等等都是表示某一特定的机器指令，为了方便我们识别，其分别有相应的助记符：getstatic,new,dup…. 这样方便我们理解。</p>
</li>
</ul>
<p>参考：</p>
<p><a href="http://blog.csdn.net/dd864140130/article/details/49515403" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/49515403</a></p>
<p><a href="http://blog.csdn.net/luanlouis/article/details/50412126" target="_blank" rel="noopener">http://blog.csdn.net/luanlouis/article/details/50412126</a></p>
<p>注：</p>
<ol>
<li><p><code>slot</code>也称为容量槽，虚拟规范中并没有规定一个Slot应该占据多大的内存空间。 ↩</p>
</li>
<li><p>这里的严格匹配指的是字节码操作的栈中的实际元素类型必须要字节码规定的元素类型一致。比如iadd指令规定操作两个整形数据，那么在操作栈中的实际元素的时候，栈中的两个元素也必须是整形。 ↩</p>
</li>
<li><code>Animal dog=new Dog();</code>其中的<code>Animal</code>我们称之为静态类型，而<code>Dog</code>称之为动态类型。两者都可以发生变化，区别在于静态类型只在使用时发生变化，变量本身的静态类型不会被改变，最终的静态类型是在编译期间可知的，而实际类型则是在运行期才可确定。 ↩</li>
<li>宗量：方法的接受者与方法的参数称为方法的宗量。<br>举个例子： </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatcher</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">int</span> result=<span class="keyword">this</span>.execute(<span class="number">8</span>,<span class="number">9</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> pointX,pointY)</span></span>&#123; </span><br><span class="line"><span class="comment">//TODO </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>dispatcher()</code>方法中调用了<code>execute(8,9)</code>，那此时的方法接受者为当前this指向的对象，8、9为方法的参数，this对象和参数就是我们所说的宗量。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/06/06/十二、虚拟机字节码执行引擎/">十二、虚拟机字节码执行引擎</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Eureka</a></p>
        <p><span>发布时间:</span>2018-06-06, 17:31:56</p>
        <p><span>最后更新:</span>2018-06-13, 21:10:19</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/06/06/十二、虚拟机字节码执行引擎/" title="十二、虚拟机字节码执行引擎">http://yoursite.com/2018/06/06/十二、虚拟机字节码执行引擎/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/06/06/十二、虚拟机字节码执行引擎/　　作者: Eureka" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/06/06/SQL必知必会/">
                    SQL必知必会
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/06/06/十一、类加载器和双亲委派机制/">
                    十一、类加载器和双亲委派机制
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-运行时候的栈结构"><span class="toc-number">1.</span> <span class="toc-text">1. 运行时候的栈结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-局部变量表"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 局部变量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-操作数栈"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 操作数栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-动态连接"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 动态连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-方法返回地址"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 方法返回地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-方法调用"><span class="toc-number">2.</span> <span class="toc-text">2. 方法调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-解析"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-分派"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 分派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-JVM实现动态分派"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 JVM实现动态分派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-以例子来说明方法调用过程"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 以例子来说明方法调用过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-方法的执行"><span class="toc-number">3.</span> <span class="toc-text">3. 方法的执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-解释执行"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 解释执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-基于栈的指令集与基于寄存器的指令集"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 基于栈的指令集与基于寄存器的指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-基于栈的代码执行示例"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 基于栈的代码执行示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-继续以上面个例子来说明方法执行过程"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 继续以上面个例子来说明方法执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-为main方法创建栈帧"><span class="toc-number">3.4.0.1.</span> <span class="toc-text">3.4.1 为main方法创建栈帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-完成栈帧初始化"><span class="toc-number">3.4.0.2.</span> <span class="toc-text">3.4.2 完成栈帧初始化</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"十二、虚拟机字节码执行引擎　| Eureka-Home　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <!--PC和WAP自适应版-->
<div id="SOHUCS"></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cytEFcz7H'; 
var conf = 'prod_cb84c9187d5b3e228aa6cf3a7e32be61'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/06/06/SQL必知必会/" title="上一篇: SQL必知必会">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/06/06/十一、类加载器和双亲委派机制/" title="下一篇: 十一、类加载器和双亲委派机制">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/2.Mybatis面试问题集锦/">2.Mybatis面试问题集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/1.Spring知识点提炼/">1.Spring知识点提炼</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/26、前端在windows本地下的部署/">26、前端在windows本地下的部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/25、Redisson实现redis分布式锁/">25、Redisson实现redis分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/24、spring schedule定时任务/">24、spring schedule定时任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/23、springmvc拦截器/">23、springmvc拦截器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/22、springMVC全局异常+spring包扫描包隔离+spring事务传播/">22、springMVC全局异常+spring包扫描包隔离+spring事务传播</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/21、springSession实现单点登录/">21、springSession实现单点登录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/20、Redis分布式/">20、Redis分布式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/19、redis+cookie+jackson+filter实现单点登录/">19、redis+cookie+jackson+filter实现单点登录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/18、二期进阶-redis快速入门/">18、二期进阶-redis快速入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/17、二期进阶-tomcat集群（单机多服务器）/">17、二期进阶-tomcat集群（单机多服务器）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/16、二期进阶-maven环境隔离/">16、二期进阶-maven环境隔离</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/15、阿里云centos7.3部署本项目（后端+前端）/">15、阿里云centos7.3部署本项目（后端+前端）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/14、订单模块开发/">14、订单模块开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/13、支付模块开发/">13、支付模块开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/12、支付宝开发/">12、支付宝开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/11、支付宝demo测试/">11、支付宝demo测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/10、收货地址管理模块/">10、收货地址管理模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/9、购物车管理模块/">9、购物车管理模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/8、商品管理模块/">8、商品管理模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/7、分类管理模块/">7、分类管理模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/6、用户管理模块/">6、用户管理模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/5、项目初始化/">5、项目初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/4、idea初始化/">4、idea初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/3、mysql+git安装/">3、mysql+git安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/2、基于virtualbox+centos6.9的服务器搭建（一）/">2、基于virtualbox+centos6.9的服务器搭建（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/1、VirtualBox+Centos6.9下载、安装、网络配置/">1、VirtualBox+Centos6.9下载、安装、网络配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/十五、骑行轨迹/">十五、骑行轨迹</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/十四、锁车/">十四、锁车</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/十三、整合百度云推送--开锁/">十三、整合百度云推送--开锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/十二、整合mongodb获取附近单车以及距离/">十二、整合mongodb获取附近单车以及距离</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/十一、整合完成编号连续递增/">十一、整合完成编号连续递增</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/十、MongoDB入门下/">十、MongoDB入门下</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/九、MongoDB入门上/">九、MongoDB入门上</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/八、整合云存储/">八、整合云存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/七、整合发送短信/">七、整合发送短信</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/六、整合springSecurity/">六、整合springSecurity</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/五、整合昵称修改功能/">五、整合昵称修改功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/四、整合用户登录功能/">四、整合用户登录功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/三、整合加密/">三、整合加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/二、整合fastJson、整合logback、lombok插件、单元测试/">二、整合fastJson、整合logback、lombok插件、单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/一、整合ssm/">一、整合ssm</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/7.安全防护--图形验证码及恶意防刷/">7.安全防护--图形验证码及恶意防刷</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/6.服务级高并发秒杀优化（RabbitMQ+接口优化）/">6.服务级高并发秒杀优化（RabbitMQ+接口优化）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/5.页面级高并发秒杀优化（Redis缓存+静态化分离）/">5.页面级高并发秒杀优化（Redis缓存+静态化分离）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/4.JMeter压测/">4.JMeter压测</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/3.秒杀功能实现/">3.秒杀功能实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/2.整合redis/">2.整合redis</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/1. 登录功能/">1. 登录功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/7、二分搜索树（下）/">7、二分搜索树（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/6、二分搜索树（上）/">6、二分搜索树（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/5、几种排序算法的对比/">5、几种排序算法的对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/4、堆排序和优先队列/">4、堆排序和优先队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/3、快速排序及优化/">3、快速排序及优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/2、归并排序/">2、归并排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/1、初级排序算法的实现和性能测试/">1、初级排序算法的实现和性能测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/算法总概览/">算法总概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/数据库索引的实现原理/">数据库索引的实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/mysql面试高频理论知识/">mysql面试高频理论知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/mysql最基础知识小结/">mysql最基础知识小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/复杂查询训练/">复杂查询训练</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/mysql复杂查询基础/">mysql复杂查询基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/MySQL重要知识点/">MySQL重要知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/SQL必知必会/">SQL必知必会</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/十二、虚拟机字节码执行引擎/">十二、虚拟机字节码执行引擎</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/十一、类加载器和双亲委派机制/">十一、类加载器和双亲委派机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/十、虚拟机类加载机制/">十、虚拟机类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/九、Class文件中的方法表集合--method方法在class文件中是怎样组织的/">九、Class文件中的方法表集合--method方法在class文件中是怎样组织的</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/八、Class文件中的字段表集合--field字段在class文件中是怎样组织的/">八、Class文件中的字段表集合--field字段在class文件中是怎样组织的</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/七、Class文件中的访问标志、类索引、父类索引、接口索引集合/">七、Class文件中的访问标志、类索引、父类索引、接口索引集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/六、Class文件中的常量池/">六、Class文件中的常量池</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/五、Class类文件结构/">五、Class类文件结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/四、内存分配和回收策略/">四、内存分配和回收策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/三、七种垃圾回收器/">三、七种垃圾回收器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/二、垃圾回收/">二、垃圾回收</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/一、java内存区域/">一、java内存区域</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/随笔1/">我们的重量</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/Java虚拟机总概览/">Java虚拟机总概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/Socket基础/">Socket基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/maven/">maven</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/计算机网络/">计算机网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/计算机操作系统/">计算机操作系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/分布式问题分析/">分布式问题分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/分布式基础/">分布式基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/HTTP/">HTTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/Git/">Git</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/十二、Java并发总览/">十二、Java并发总览</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/十一、深入分析ThreadLocal内存泄漏问题/">十一、深入分析ThreadLocal内存泄漏问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/十、ThreadLocal详解/">十、ThreadLocal详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/9.缓存设计与优化/">9.缓存设计与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/8.redis cluster实践--淘淘商城的某一节/">8.redis cluster实践--淘淘商城的某一节</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/7.redis cluster理论详解/">7.redis cluster理论详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/6.redis sentinel实现高可用读写分离/">6.redis sentinel实现高可用读写分离</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/5.redis主从复制/">5.redis主从复制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/4.redis持久化/">4.redis持久化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/3.redis其他的功能/">3.redis其他的功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/2.redis基本数据结构的入门/">2.redis基本数据结构的入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/1.redis简介/">1.redis简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/15.高并发处理之应用限流思路/">15.高并发处理之应用限流思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/14.高并发处理之应用拆分思路/">14.高并发处理之应用拆分思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/13.高并发处理之消息队列思路/">13.高并发处理之消息队列思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/12.高并发处理之缓存思路/">12.高并发处理之缓存思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/11.多线程并发拓展/">11.多线程并发拓展</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/10.线程池/">10.线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/9.JUC组件拓展-BlockingQueue/">9.JUC组件拓展-BlockingQueue</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/8.JUC组件拓展-ForkJoin简介/">8.JUC组件拓展-ForkJoin简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/7.JUC组件拓展-Callable、Future和FutureTask/">7.JUC组件拓展-Callable、Future和FutureTask</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/6.AQS以及同步组件/">6.AQS以及同步组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/5.线程安全策略/">5.线程安全策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/4.安全发布对象/">4.安全发布对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/3.线程安全性-synchronized/">3.线程安全性-synchronized</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/2.线程安全性-Atomic包/">2.线程安全性-Atomic包</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/1.基础介绍和线程安全性问题展示/">1.基础介绍和线程安全性问题展示</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/九、Lock接口简单体验/">九、Lock接口简单体验</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/八、JVM对synchronized的优化/">八、JVM对synchronized的优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/七、读写锁/">七、读写锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/六、volatile详解/">六、volatile详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/五、从卖票程序看synchronized特性/">五、从卖票程序看synchronized特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/四、Thread类方法详解/">四、Thread类方法详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/三、线程的创建和线程状态/">三、线程的创建和线程状态</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/二、基础概念/">二、基础概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/一、基础概念/">一、线程基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/13、HashMap死循环问题/">13、HashMap死循环问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/12、深入fail-fast/">12、深入fail-fast</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/11、LinkedHashSet源码解析/">11、LinkedHashSet源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/10、HashSet源码解析/">10、HashSet源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/9、Hashtable源码分析/">9、Hashtable源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/8、HashMap和LinkedHashMap遍历机制/">8、HashMap和LinkedHashMap遍历机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/7、LinkedHashMap源码分析/">7、LinkedHashMap源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/6、HashMap源码分析/">6、HashMap源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/5、hashcode和equals/">5、hashcode和equals</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/4、CopyOnWriteArrayList源码分析/">4、CopyOnWriteArrayList源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/3、LinkedList源码分析/">3、LinkedList源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/2、ArrayList源码分析/">2、ArrayList源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/1、Java容器概览/">1、Java容器概览</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/10.java字符串/">10.java字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/9.Java IO/">9.Java IO</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/8.java面向对象/">8.java面向对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/7.java克隆/">7.java克隆</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/6.java泛型/">6.java泛型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/04/5.java异常/">5.java异常</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/4.java注解/">4.java注解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/3.java动态代理/">3.java动态代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/2.java反射/">2.java反射</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/31/1.Java基础/">1.Java基础</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018 Eureka
            </div>
            <div class="footer-right">
                共147篇文章 <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 2;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>