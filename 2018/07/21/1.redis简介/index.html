<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 1.redis简介 · Eureka-Home</title><meta name="description" content="1.redis简介 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">1.redis简介</h1><div class="post-info">Jul 21, 2018</div><div class="post-content"><p>系统学习redis的第一篇，首先来基本感受一下redis是什么，为什么用他？<br><a id="more"></a></p>
<h2 id="1-redis是什么"><a href="#1-redis是什么" class="headerlink" title="1. redis是什么"></a>1. redis是什么</h2><p><code>Redis</code>是一个开源的使用ANSI <strong>C语言编写</strong>、支持网络、<strong>单进程单线程</strong>、<strong>可基于内存亦可持久化的日志型</strong>、一个<strong>高性能的<code>key-value</code>数据库</strong>。</p>
<h2 id="2-Redis与其他key-value存储有什么不同"><a href="#2-Redis与其他key-value存储有什么不同" class="headerlink" title="2. Redis与其他key-value存储有什么不同"></a>2. Redis与其他key-value存储有什么不同</h2><ul>
<li>多样的数据结构和原子性操作</li>
</ul>
<p><strong><code>Redis</code>有着更为复杂的数据结构并且提供对他们的原子性操作</strong>，这是一个不同于其他数据库的进化路径。<code>Redis</code>的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p>
<ul>
<li>运行于内存+持久化于磁盘</li>
</ul>
<p><code>Redis</code>运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， <strong>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样<code>Redis</code>可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</strong>。</p>
<h2 id="3-redis特点"><a href="#3-redis特点" class="headerlink" title="3. redis特点"></a>3. redis特点</h2><blockquote>
<p><strong>速度快</strong>：基于内存,这是快的最主要原因。</p>
</blockquote>
<blockquote>
<p><strong>持久化</strong>：异步保存到磁盘中</p>
</blockquote>
<blockquote>
<p><strong>多种数据结构</strong>：除了五种基本数据类型，还支持位图、<code>HyperLogLog</code>，<code>GEO</code>等</p>
</blockquote>
<blockquote>
<p><strong>支持多种编程语言</strong>：<code>java</code>，<code>python</code>，<code>ruby</code>，<code>php</code>，<code>Lua</code>，<code>nodejs</code>…</p>
</blockquote>
<blockquote>
<p><strong>功能丰富</strong>：可以实现发布-订阅，支持事务、<code>Lua</code>脚本</p>
</blockquote>
<blockquote>
<p><strong>简单</strong>：不依赖与外部库、单线程模型</p>
</blockquote>
<blockquote>
<p><strong>主从复制</strong>：主服务器同步数据到从服务器，是高可用的基础</p>
</blockquote>
<blockquote>
<p><strong>高可用、分布式</strong>：高可用：<code>redis-Sentinel</code>(v2.8版本)；分布式：<code>redis-cluster</code>(v3.0版本)</p>
</blockquote>
<h2 id="4-redis典型应用场景"><a href="#4-redis典型应用场景" class="headerlink" title="4. redis典型应用场景"></a>4. redis典型应用场景</h2><blockquote>
<p><strong>缓存系统</strong>：这个就不多说了，<code>redis</code>作为高速缓存是其主要存在价值。</p>
</blockquote>
<blockquote>
<p><strong>计数器</strong>：因为是原子操作+单线程，作为计数器永远不会出错</p>
</blockquote>
<blockquote>
<p><strong>消息队列系统</strong>：数据结构可以实现这种生产者-消费者模式的消息队列。</p>
</blockquote>
<blockquote>
<p><strong>排行榜</strong>：有序集合sorted set就可以实现</p>
</blockquote>
<blockquote>
<p><strong>社交网络</strong>：<code>redis</code>与社交网络就是一家，非常方便就能实现诸如共同好友这些功能。</p>
</blockquote>
<blockquote>
<p><strong>实时系统</strong>：如垃圾邮件处理系统</p>
</blockquote>
<h2 id="5-redis优势"><a href="#5-redis优势" class="headerlink" title="5. redis优势"></a>5. redis优势</h2><blockquote>
<p><strong>缓存管理</strong>：可以在必要时将无效的旧数据从内存中删除，为新数据腾出新的空间</p>
</blockquote>
<blockquote>
<p><strong>提供更大的灵活性</strong>：<code>redis</code>支持多种类型，并且采用<code>key-value</code> 的形式存储，<code>key</code>和<code>value</code>的大小限制都是512Mb,与编码无关，所以数据安全。但是<code>memcached</code>限制<code>key</code>最大为250字节，<code>value</code>为1MB，况且只支持<code>String</code>类型。</p>
</blockquote>
<blockquote>
<p><strong><code>redis</code>提供主从复制</strong>：实现高可用的<code>cache</code>系统，支持集群中多个服务器之间的数据同步。</p>
</blockquote>
<blockquote>
<p><strong>数据持久化</strong>：<code>redis</code>可以通过两种方式将数据进行持久化，一定程度上规避缓存中的数据不稳定的问题，也可以在重启服务器时最快的恢复缓存中所需的数据，提高了效率的同时减轻了主数据库系统的开销。</p>
</blockquote>
<p>与传统的<code>Memcached</code>相比，优势还是很大的，但是<code>Memcached</code>也有不可替代的适用场景：</p>
<blockquote>
<p>存储一些粒度比较小的静态数据，比如一些html片段，<code>Memcached</code>便是我们更好的选择。相对于<code>redis</code>而言，<code>Memcached</code>的元数据<code>metadata</code>更小些，所以相对来讲对于数据存储管理的性能更高，额外开销更小。</p>
</blockquote>
<blockquote>
<p><code>Memcached</code>的特点：<code>Memcached</code>唯一支持的数据类型是<code>String</code>,所以更适合存储只读数据，因为字符串并不会因为额外的处理造成额外的开销。毕竟<code>Memcached</code>每次更新一个对象时，都需要重复执行下面的操作：获取整个字符串-&gt;反序列化为对象-&gt;修改其中的值-&gt;再次序列化该对象-&gt;在缓存中将整个字符串替换为新字符串。这样一来，更新存储数据就会有更高的消耗，可能就不是我们的最佳选择了。 </p>
</blockquote>
<h2 id="6-redis快的原因总结"><a href="#6-redis快的原因总结" class="headerlink" title="6. redis快的原因总结"></a>6. redis快的原因总结</h2><blockquote>
<p>完全基于内存</p>
</blockquote>
<p><code>Redis</code>是纯内存数据库，相对于读写磁盘，读写内存的速度就不是几倍几十倍了，一般，<code>hash</code>查找可以达到每秒百万次的数量级。</p>
<blockquote>
<p>多路复用IO</p>
</blockquote>
<p>“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）。可以直接理解为：单线程的原子操作，避免上下文切换的时间和性能消耗；加上对内存中数据的处理速度，很自然的提高redis的吞吐量。</p>
<h4 id="6-1-Redis为什么是单线程的？"><a href="#6-1-Redis为什么是单线程的？" class="headerlink" title="6.1 Redis为什么是单线程的？"></a>6.1 Redis为什么是单线程的？</h4><p>因为CPU不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<h4 id="6-2-为什么-Redis-中要使用-I-O-多路复用这种技术呢？"><a href="#6-2-为什么-Redis-中要使用-I-O-多路复用这种技术呢？" class="headerlink" title="6.2 为什么 Redis 中要使用 I/O 多路复用这种技术呢？"></a>6.2 为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h4><p>首先，<code>Redis</code> 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p>
<blockquote>
<p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p>
<ol>
<li><p>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p>
</li>
<li><p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</p>
</li>
<li><p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 </p>
</li>
</ol>
<p>第三种就是IO复用模型，<code>Linux</code>下的<code>select</code>、<code>poll</code>和<code>epoll</code>就是干这个的。<strong>将用户<code>socket</code>对应的<code>fd</code>注册进<code>epoll</code>，然后<code>epoll</code>帮你监听哪些<code>socket</code>上有消息到达</strong>，这样就避免了大量的无用操作。此时的<code>socket</code>应该采用非阻塞模式。这样，整个过程只在调用<code>select</code>、<code>poll</code>、<code>epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的<code>reactor</code>模式。</p>
</blockquote>
<h4 id="6-3-redis的线程模型？"><a href="#6-3-redis的线程模型？" class="headerlink" title="6.3 redis的线程模型？"></a>6.3 redis的线程模型？</h4><p><code>Redis</code> 服务采用 <code>Reactor</code> 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p>
<p><img src="http://bloghello.oursnail.cn/redis%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86111.png-1000width" alt="image"></p>
<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p>
<p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 <code>Redis</code> 服务实现的简单。</p>
<p>上面简单理解就是：多个网络连接并发读写redis的时候，先将对应的fd注册到<code>epoll</code>上，I/O多路复用模块会监听这些网络请求的情况，一旦有一个网络连接产生了<code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件，I/O多路复用模块就会向文件事件分派器传送那些产生了事件的网络连接。</p>
<p><img src="http://redisbook.com/_images/graphviz-f0d024ca2782cbbe20e2cd1e52540d92f64b3a37.png" alt="image"></p>
<p>当然了，上面的文件事件可能会并发产生，这时的策略是，将所有产生事件的套接字（对应上面的网络连接）都入队到一个队列里面， 然后通过这个队列， 以有序（<code>sequentially</code>）、同步（<code>synchronously</code>）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。</p>
<p><img src="http://redisbook.com/_images/graphviz-f4835e5b07c5a6ab04e09dc8d887d62a1854ac94.png" alt="image"></p>
<p>文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。</p>
<p>服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。</p>
<p><strong>整个模块使 <code>Redis</code> 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。</strong></p>
<p>最后，为什么<code>redis</code>比较快大概思路通俗的说就是：<code>Redis</code>是纯内存数据库，读取快，瓶颈在于IO上，如果使用阻塞式IO，因为是单线程的缘故，就会停止等待。所以采用IO多路复用监听文件描述符的状态，将对<code>redis</code>的开关读写换成事件，加入队列进行相应的事件处理，采用非阻塞IO，吞吐量比较大。</p>
<h2 id="7-reids在linux下的安装"><a href="#7-reids在linux下的安装" class="headerlink" title="7. reids在linux下的安装"></a>7. reids在linux下的安装</h2><p><code>Redis</code>对于<code>Linux</code>是官方支持的，安装起来也非常地简单，直接编译源码然后进行安装即可。</p>
<p>这里以<code>centos</code>为例，大概说一下步骤：</p>
<blockquote>
<p>下载redis编译工具:<code>yum install gcc</code>和<code>yum install g++</code></p>
</blockquote>
<blockquote>
<p>解压<code>redis.tar.gz</code>文件，进去之后进行编译:<code>make</code></p>
</blockquote>
<blockquote>
<p>然后安装：<code>make install PREFIX=/usr/local/redis</code></p>
</blockquote>
<blockquote>
<p>安装成功之后进入<code>/usr/local/redis/bin</code>下启动<code>redis</code></p>
<p><code>./redis-server</code></p>
</blockquote>
<h2 id="8-redis在windows环境下的安装"><a href="#8-redis在windows环境下的安装" class="headerlink" title="8. redis在windows环境下的安装"></a>8. redis在windows环境下的安装</h2><p>解压就能使用。下载地址为：<a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/1.Spring知识点提炼/" class="prev">PREV</a><a href="/2018/07/21/1.Java基础/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>