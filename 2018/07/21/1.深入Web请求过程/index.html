<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 1.深入Web请求过程 · Eureka-Home</title><meta name="description" content="1.深入Web请求过程 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">1.深入Web请求过程</h1><div class="post-info">Jul 21, 2018</div><div class="post-content"><p>《深入分析Java Web技术内幕》第一章读书笔记。<br><a id="more"></a></p>
<h3 id="B-S网络架构概述"><a href="#B-S网络架构概述" class="headerlink" title="B/S网络架构概述"></a>B/S网络架构概述</h3><p><code>B/S</code> 网络架构从前端到后端都得到了简化，都基于统一的应用层协议 <code>HTTP</code> 来交互数据，与大多数传统的 <code>C/S</code> 互联网应用程序采用的长连接的交互模式不同， <code>HTTP</code> 采用无状态的短连接的通信方式。通常情况下，一次请求就完成了一次数据交互，通常也对应一个业务逻辑，然后这次通信连接就断开了。采用这种方式是为了能够同时服务更多的用户，因为当前互联网应用每天都会处理上亿的请求，不可能每个用户访问一次后就一直保持这个连接。</p>
<h3 id="如何发起一个请求"><a href="#如何发起一个请求" class="headerlink" title="如何发起一个请求"></a>如何发起一个请求</h3><p>如何发起一个 <code>HTTP</code> 请求和如何建立一个 <code>Socket</code> 连接区别不大，只不过 <code>outputStream.write</code> 写的二进制字节数据格式要符合 <code>HTTP</code> 。</p>
<p>浏览器在建立 <code>Socket</code> 连接之前，必须根据地址栏里输入的 <code>URL</code> 的域名 <code>DNS</code> 解析出 <code>IP</code> 地址，再根据这个 <code>IP</code> 地址和默认的80端口与远程服务器建立 <code>Socket</code> 连接，然后浏览器根据这个 <code>URL</code> 组装成一个 <code>get</code> 类型的 <code>HTTP</code> 请求头，通过 <code>outputStream.write</code> 发送到目标服务器，服务器等待 <code>inputStream.read</code> 返回数据，最后断开这个连接。</p>
<p>一句话：发起一个 <code>HTTP</code> 请求的过程就是建立一个 <code>Socket</code> 通信的过程。</p>
<h3 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h3><ol>
<li>浏览器检查缓存中有没有这个域名对应的解析过的<code>IP</code>地址，这个缓存有大小和时间的限制</li>
<li>如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的<code>DNS</code>解析结果。比如<code>windows</code>下的<code>hosts</code>文件地址解析。</li>
<li>前面两步都是在本机完成的，如果还是无法解析，就会真正请求域名服务器来解析域名了。那么就要知道域名服务器在哪，其实我们主机的网络配置中会有一项信息是“DNS服务器地址”，操作系统会把域名发送给这个<code>LDNS</code>，也就是本地区的域名服务器，这个<code>DNS</code>通常会提供给你本地互联网接入的一个<code>DNS</code>解析服务。假如你在学校接入互联网，那么<code>DNS</code>服务器一定在你的学校。</li>
<li>如果<code>LDNS</code>仍然无法命中，就直接到<code>Root Server</code>域名服务器请求解析。</li>
<li>根域名服务器会返回给本地域名服务器一个所查询的主域名服务器(<code>gTLD Server</code>)地址。<code>gTLD</code>是国际顶级域名服务器，如<code>.com</code>,<code>.cn</code>,<code>.org</code>等</li>
<li>本地域名服务器(<code>Local DNS Server</code>)再向上一步返回的<code>gTLD</code>服务器发送请求</li>
<li>接受请求的<code>gTLD</code>服务器查找并返回此域名对应的<code>Name Server</code>域名服务器的地址，这个<code>Name Server</code>通常就是你注册的域名服务器，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就是由这个域名提供商的服务器来完成。</li>
<li><code>Name Server</code>域名服务器会查询存储的域名和<code>IP</code>的映射关系表，在正常情况下丢根据域名得到目标<code>IP</code>记录，联通一个<code>TTL</code>值返回给<code>DNS Server</code>域名服务器。</li>
<li>返回给该域名对应的<code>IP</code>和<code>TTL</code>值，<code>Local DNS Server</code>会缓存这个域名和IP的对应关系，缓存的时间由<code>TTL</code>值控制。</li>
<li>把解析的结果返回给用户，用户根据<code>TTL</code>值缓存在本地系统缓存中，域名解析过程结束。</li>
</ol>
<p>实际可能比这个过程更加复杂。</p>
<h3 id="CDN工作机制"><a href="#CDN工作机制" class="headerlink" title="CDN工作机制"></a>CDN工作机制</h3><p>CDN就是内容分布网络(Content Delivery Network),他是构筑在现有网络上的一种先进的流量分配网络。</p>
<p>目的是将网站的内容发布在最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的相应速度。</p>
<p>目前CND都以缓存网站中的静态数据为主，如CSS，JS，图片和静态页面等数据。用户在从主站服务器请求到动态内容后，再从CDN上下载这些静态数据，从而加速网页数据内容的下载速度。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul>
<li>链路负载均衡：也就是前面提到的通过DNS解析成不同的IP，然后用户根据这个IP来访问不同的目标服务器。这种方式是由DNS得解析完成，那么就是由Global DNS Server来动态解析域名服务，优点是速度快，不需要经过其他的代理服务器，缺点是由于缓存的原因，当一台服务器挂了之后无更新，造成无法访问的问题。</li>
<li>集群负载均衡：分为硬件负载均衡和软件负载均衡。其中硬件负载均衡是一般使用一台专门的硬件设备来转发请求，优点是性能好，缺点是设备昂贵，不方便动态扩容。软件负载均衡是一种比较普遍的负载方式，他的特点是使用成本特别低，直接使用廉价的PC即可，缺点是一般一次访问请求要经过多次代理服务器，会增加网络延时。比如用两台四层负载均衡的LVS，利用IP地址进行地址转发；下面用三台HAProxy进行七层负载，可以根据用户的HTTP请求头进行负载均衡。</li>
<li>操作系统负载均衡：利用操作系统级别的软中断或者硬件中断来达到负载均衡。</li>
</ul>
<h3 id="几种负载均衡的算法介绍"><a href="#几种负载均衡的算法介绍" class="headerlink" title="几种负载均衡的算法介绍"></a>几种负载均衡的算法介绍</h3><ul>
<li>轮询（默认）</li>
</ul>
<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<ul>
<li>weight</li>
</ul>
<p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<ul>
<li>ip_hash</li>
</ul>
<p>每个请求按访问ip的hash结果分配，这样每个访客固定访问同一个后端服务器，可以解决session的问题。但是不能解决宕机问题。<br>前三种是nginx自带的，直接在配置文件中配置即可使用。</p>
<ul>
<li>fair（第三方）</li>
</ul>
<p>按后端服务器的相应时间来分配请求，相应时间短的优先分配。</p>
<ul>
<li>url_hash（第三方）</li>
</ul>
<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/1.数据库设计和基础环境搭建/" class="prev">上一篇</a><a href="/2018/07/21/1.基础介绍和线程安全性问题展示/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>