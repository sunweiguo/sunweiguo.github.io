<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 10.线程池 · Eureka-Home</title><meta name="description" content="10.线程池 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">10.线程池</h1><div class="post-info">Jul 21, 2018</div><div class="post-content"><p>线程池的原理是面试的重灾区。本篇将完整分析线程池的原理。<br><a id="more"></a></p>
<h2 id="1-初步认识线程池"><a href="#1-初步认识线程池" class="headerlink" title="1. 初步认识线程池"></a>1. 初步认识线程池</h2><h4 id="1-1-new-thread弊端"><a href="#1-1-new-thread弊端" class="headerlink" title="1.1 new thread弊端"></a>1.1 new thread弊端</h4><p>从学习java多线程开始，我们就学习了用<code>new thread</code>来创建线程。但是他有一定的弊端：</p>
<ul>
<li>每次<code>new Thread</code>新建对象，性能差</li>
<li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM</li>
<li>缺少更多功能，如更多执行、定期执行、线程中断</li>
</ul>
<h4 id="1-2-线程池好处"><a href="#1-2-线程池好处" class="headerlink" title="1.2 线程池好处"></a>1.2 线程池好处</h4><ul>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li>
<li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>
<h4 id="1-3-线程池相关参数"><a href="#1-3-线程池相关参数" class="headerlink" title="1.3 线程池相关参数"></a>1.3 线程池相关参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>corePoolSize</code>:核心线程数量</li>
</ul>
<blockquote>
<p>默认情况下，在创建了线程池后，线程池中的线程数为0，<br>（除非调用<code>prestartAllCoreThreads()</code>和<code>prestartCoreThread()</code>方法，从方法名字可以看出，是预创建线程的意思，即在没有任务到来之前，就创建<code>corePoolSize</code>个线程或1个线程）当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中；</p>
<p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p>
</blockquote>
<ul>
<li><code>maximumPoolSize</code>:线程最大线程数</li>
</ul>
<blockquote>
<p>线程池中的最大线程数，表示线程池中最多能创建多少个线程。</p>
<p>超过就<code>reject</code>:如果队列满了,并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务</p>
</blockquote>
<ul>
<li><code>workQueue</code>:阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响，一般有以下几种选择：</li>
</ul>
<blockquote>
<p><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序；</p>
<p><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于<code>ArrayBlockingQueue</code>。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列；</p>
<p><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列；</p>
<p><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列；底层用<code>DelayedWorkQueue</code>实现。</p>
</blockquote>
<ul>
<li><code>keepAliveTime</code>：线程没有任务执行时最多保持多久时间终止</li>
</ul>
<blockquote>
<p>当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。（但是如果调用了<code>allowCoreThreadTimeOut(boolean value)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0；）</p>
</blockquote>
<ul>
<li><code>unit</code>:<code>keepAliveTime</code>的时间单位</li>
<li><code>threadFactory</code>：线程工厂，用来创建线程</li>
</ul>
<blockquote>
<p><code>threadFactory</code>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</p>
</blockquote>
<ul>
<li><code>handler</code>:饱和策略</li>
</ul>
<blockquote>
<p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。</p>
</blockquote>
<h4 id="1-4-线程池工作原理"><a href="#1-4-线程池工作原理" class="headerlink" title="1.4 线程池工作原理"></a>1.4 线程池工作原理</h4><p>提交一个任务到线程池中，线程池的处理流程如下：</p>
<ul>
<li>判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ul>
<p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B111.png" alt="image"></p>
<h4 id="1-5-饱和策略"><a href="#1-5-饱和策略" class="headerlink" title="1.5 饱和策略"></a>1.5 饱和策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</span><br></pre></td></tr></table></figure>
<ol>
<li><code>AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常</li>
<li><code>CallerRunsPolicy</code>：只用调用所在的线程运行任务</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li><code>DiscardPolicy</code>：不处理，丢弃掉,不抛出异常。</li>
</ol>
<h2 id="2-线程池的源码解读"><a href="#2-线程池的源码解读" class="headerlink" title="2. 线程池的源码解读"></a>2. 线程池的源码解读</h2><p>程序中要声明线程池，是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">exec.excute(Runnable command);</span><br></pre></td></tr></table></figure>
<p>先来看看<code>ExecutorService</code>其中的奥秘。</p>
<h4 id="2-1-ExecutorService和Executor的关系"><a href="#2-1-ExecutorService和Executor的关系" class="headerlink" title="2.1 ExecutorService和Executor的关系"></a>2.1 ExecutorService和Executor的关系</h4><p><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为<code>void</code>，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p>
<ul>
<li><code>execute()</code><br><code>execute()</code>方法实际上是<code>Executor</code>中声明的方法，在<code>ThreadPoolExecutor</code>进行了具体的实现，这个方法是<code>ThreadPoolExecutor</code>的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li>
<li><code>submit()</code><br><code>submit()</code>方法是在<code>ExecutorService</code>中声明的方法,这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code>方法不同，它能够返回任务执行的结果，去看<code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了<code>Future</code>来获取任务执行结果。</li>
<li><p><code>shutdown()</code><br>将线程池状态置为<code>SHUTDOWN</code>,并不会立即停止：</p>
<p>  停止接收外部submit的任务<br>  内部正在跑的任务和队列里等待的任务，会执行完<br>  等到第二步完成后，才真正停止</p>
</li>
<li><p><code>shutdownNow()</code><br>将线程池状态置为<code>STOP</code>。企图立即停止，事实上不一定：</p>
<p>  跟shutdown()一样，先停止接收外部提交的任务<br>  忽略队列里等待的任务<br>  尝试将正在跑的任务interrupt中断<br>  返回未执行的任务列表</p>
</li>
</ul>
<p>它试图终止线程的方法是通过调用<code>Thread.interrupt()</code>方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有<code>sleep</code> 、<code>wait</code>、<code>Condition</code>、定时锁等应用, <code>interrupt()</code>方法是无法中断当前的线程的。所以，<code>ShutdownNow()</code>并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。</p>
<p>但是大多数时候是能立即退出的</p>
<ul>
<li><code>awaitTermination(long timeOut, TimeUnit unit)</code></li>
</ul>
<blockquote>
<p>当前线程阻塞，直到</p>
</blockquote>
<pre><code>等所有已提交的任务（包括正在跑的和队列中等待的）执行完
或者等超时时间到
或者线程被中断，抛出InterruptedException
</code></pre><blockquote>
<p>然后返回true（<code>shutdown</code>请求后所有任务执行完毕）或false（已超时）</p>
<p><code>shuntdown()</code>和<code>awaitTermination()</code>效果差不多，方法执行之后，都要等到提交的任务全部执行完才停。</p>
<p> <code>shutdown()</code>后，不能再提交新的任务进去；但是<code>awaitTermination()</code>后，可以继续提交。</p>
<p><code>awaitTermination()</code>是阻塞的，返回结果是线程池是否已停止（true/false）；<code>shutdown()</code>不阻塞。</p>
</blockquote>
<h4 id="2-2-Executors生成线程池"><a href="#2-2-Executors生成线程池" class="headerlink" title="2.2 Executors生成线程池"></a>2.2 Executors生成线程池</h4><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>Executors</code>类里面提供了一些静态工厂，生成一些常用的线程池。</p>
<p><strong>其实都是通过调用<code>ThreadPoolExecutor</code>来完成的，最后返回<code>ExecutorService</code>。</strong></p>
<ul>
<li><code>newSingleThreadExecutor</code><blockquote>
<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为1的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                               threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:10,index:1</span><br><span class="line">task:10,index:2</span><br><span class="line">task:10,index:3</span><br><span class="line">task:10,index:4</span><br><span class="line">task:10,index:5</span><br><span class="line">task:10,index:6</span><br><span class="line">task:10,index:7</span><br><span class="line">task:10,index:8</span><br><span class="line">task:10,index:9</span><br></pre></td></tr></table></figure>
<p>运行结果分析：单线程+有序。</p>
<ul>
<li><code>newFixedThreadPool</code><blockquote>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为nThreads的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用自定义线程创建工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:11,index:1</span><br><span class="line">task:11,index:3</span><br><span class="line">task:11,index:4</span><br><span class="line">task:11,index:5</span><br><span class="line">task:11,index:6</span><br><span class="line">task:11,index:7</span><br><span class="line">task:11,index:8</span><br><span class="line">task:11,index:9</span><br><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br></pre></td></tr></table></figure>
<p>结果分析：只创建了三个线程来执行。</p>
<ul>
<li><code>newCachedThreadPool</code><blockquote>
<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个按需创建线程的线程池，初始线程个数为0，最多线程个数为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为同步队列</span></span><br><span class="line"><span class="comment">//keeyAliveTime=60说明只要当前线程60s内空闲则回收</span></span><br><span class="line"><span class="comment">//特殊在于加入到同步队列的任务会被马上被执行，同步队列里面最多只有一个任务，并且存在后马上会拿出执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自定义的线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br><span class="line">task:14,index:4</span><br><span class="line">task:16,index:6</span><br><span class="line">task:18,index:8</span><br><span class="line">task:11,index:1</span><br><span class="line">task:13,index:3</span><br><span class="line">task:15,index:5</span><br><span class="line">task:17,index:7</span><br><span class="line">task:19,index:9</span><br></pre></td></tr></table></figure>
<p>结果分析：按需创建线程，几乎一次循环就创建了一个新的线程来执行。</p>
<ul>
<li><code>newScheduledThreadPool</code></li>
</ul>
<blockquote>
<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多长时间之后执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时执行，这里是每隔3秒执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);<span class="comment">//一开始延迟1秒执行任务，之后每隔3秒执行一次任务，不适合调用exec.shutdown();，因为会被关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>newSingleThreadScheduledExecutor</code></li>
</ul>
<blockquote>
<p>创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize为1，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同上。demo不再赘述。</p>
<h4 id="2-3-线程池实现原理–线程池状态"><a href="#2-3-线程池实现原理–线程池状态" class="headerlink" title="2.3  线程池实现原理–线程池状态"></a>2.3  线程池实现原理–线程池状态</h4><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt="image"></p>
<ul>
<li><code>static final int RUNNING = 0;</code></li>
</ul>
<blockquote>
<p>当创建线程池后，初始时，线程池处于RUNNING状态；</p>
</blockquote>
<ul>
<li><code>static final int SHUTDOWN = 1;</code></li>
</ul>
<blockquote>
<p>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p>
</blockquote>
<ul>
<li><code>static final int STOP = 2;</code></li>
</ul>
<blockquote>
<p>如果调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p>
</blockquote>
<ul>
<li><code>static final int TERMINATED = 3;</code></li>
</ul>
<blockquote>
<p>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</p>
</blockquote>
<h4 id="2-4-线程池实现原理–任务的执行"><a href="#2-4-线程池实现原理–任务的执行" class="headerlink" title="2.4  线程池实现原理–任务的执行"></a>2.4  线程池实现原理–任务的执行</h4><p><code>corePoolSize</code>在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：</p>
<blockquote>
<p>假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p>
<p>因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p>
<p>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p>
<p>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p>
<p>然后就将任务也分配给这4个临时工人做；</p>
<p>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p>
<p>当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p>
</blockquote>
<p>这个例子中的<code>corePoolSize</code>就是10，而<code>maximumPoolSize</code>就是14（10+4）。</p>
<p>也就是说<code>corePoolSize</code>就是线程池大小，<code>maximumPoolSize</code>在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p>
<p>不过为了方便理解，在本文后面还是将<code>corePoolSize</code>翻译成核心池大小。</p>
<p>在<code>ThreadPoolExecutor</code>类中，最核心的任务提交方法是<code>execute()</code>方法，虽然通过<code>submit</code>也可以提交任务，但是实际上<code>submit</code>方法里面最终调用的还是<code>execute()</code>方法，所以我们只需要研究<code>execute()</code>方法的实现原理即可：</p>
<p>注：<code>execute()</code>方法和<code>submit()</code>方法已经在前面讲过区别了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">     <span class="comment">// Proceed in 3 steps:</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 1. </span></span><br><span class="line">     <span class="comment">// 判断当前的线程数是否小于corePoolSize,如果是，使用入参任务通过addWord方法创建一个新的线程，</span></span><br><span class="line">     <span class="comment">// 如果能完成新线程创建exexute方法结束，成功提交任务</span></span><br><span class="line">     <span class="comment">// 2. </span></span><br><span class="line">     <span class="comment">// 在第一步没有完成任务提交；状态为运行并且能够成功加入任务到工作队列后，再进行一次check，如果状态</span></span><br><span class="line">     <span class="comment">// 在任务加入队列后变为了非运行（有可能是在执行到这里线程池shutdown了），非运行状态下当然是需要</span></span><br><span class="line">     <span class="comment">// reject；然后再判断当前线程数是否为0（有可能这个时候线程数变为了0），如是，新增一个线程；</span></span><br><span class="line">     <span class="comment">// 3. </span></span><br><span class="line">     <span class="comment">// 如果不能加入任务到工作队列，将尝试使用任务新增一个线程，如果失败，则是线程池已经shutdown或者线程池</span></span><br><span class="line">     <span class="comment">// 已经达到饱和状态，所以reject这个任务</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果工作线程数大于等于核心线程数</span></span><br><span class="line">    <span class="comment">// 线程的的状态为RUNNING并且队列notfull</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查线程的运行状态，如果不是RUNNING直接从队列中移除</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 移除成功，拒绝该非运行的任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">            <span class="comment">// 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列满了或者是非运行的任务都拒绝执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码体现了上面提到的线程池工作原理，这里再强调一下过程：</p>
<p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86111.png" alt="image"></p>
<ul>
<li>1.如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。 </li>
<li>2.如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li>
<li>3.如果无法将任务加入<code>BlockingQueue</code>（队列已满），则在非<code>corePool</code>中创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。 </li>
<li>4.如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。 </li>
</ul>
<blockquote>
<p><code>ThreadPoolExecutor</code>采取上述步骤的总体设计思路，是为了在执行<code>execute()</code>方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。<strong>在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤2</strong>，而步骤2不需要获取全局锁。</p>
</blockquote>
<h2 id="3-线程池合理配置"><a href="#3-线程池合理配置" class="headerlink" title="3. 线程池合理配置"></a>3. 线程池合理配置</h2><ul>
<li>任务性质：CPU密集型，IO密集型，混合型。<blockquote>
<p>CPU密集型应配置尽可能小的线程，如N(CPU) + 1；IO密集型任务应配置尽可能多的线程，如2 * N(CPU)；</p>
</blockquote>
</li>
<li>任务优先级：高，中，低。<blockquote>
<p>可使用优先级队列。</p>
</blockquote>
</li>
<li>任务执行时间：长，中，短。<blockquote>
<p>可用不同规模的线程池处理。</p>
</blockquote>
</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。<blockquote>
<p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，CPU空闲较多，线程数应设置大些。</p>
</blockquote>
</li>
<li>建议使用有界队列,增加系统稳定性和预警能力。</li>
<li>线程池的监控<blockquote>
<p><code>taskCount</code> 返回过去任务的大概总数(包含<code>queue size</code>)。</p>
<p><code>completedTaskCount</code> 已完成任务数量，<code>&lt;= taskCount</code></p>
<p><code>largestPoolSize</code> 曾创建过的最大线程数</p>
<p><code>getPoolSize</code> 线程池的线程数量</p>
<p><code>getActiveCount</code> 活动线程数</p>
</blockquote>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/11.缓存更新/" class="prev">上一篇</a><a href="/2018/07/21/10.redis事务/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>