<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 15.高并发处理之应用限流思路 · Eureka-Home</title><meta name="description" content="15.高并发处理之应用限流思路 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">15.高并发处理之应用限流思路</h1><div class="post-info">Jul 21, 2018</div><div class="post-content"><p>这里简单介绍几种限流算法，提供一种应对高并发的解决思路。<br><a id="more"></a></p>
<p>为什么要进行限流？</p>
<p><img src="http://bloghello.oursnail.cn/%E5%BA%94%E7%94%A8%E9%99%90%E6%B5%81.png" alt="image"></p>
<h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><h4 id="计数器法"><a href="#计数器法" class="headerlink" title="计数器法"></a>计数器法</h4><p>有时我们还会使用计数器来进行限流，主要用来限制一定时间内的总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流，是一种简单粗暴的总数量限流，而不是平均速率限流。<br><img src="http://bloghello.oursnail.cn/%E8%AE%A1%E6%95%B0%E5%99%A8%E6%B3%95.png" alt="image"></p>
<p>算法思想很简单，但是有一个致命的问题：临界问题</p>
<p><img src="http://bloghello.oursnail.cn/%E8%AE%A1%E6%95%B0%E5%99%A8%E6%B3%95%E7%9A%84%E5%BC%8A%E7%AB%AF.png" alt="image"></p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p><img src="http://bloghello.oursnail.cn/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="image"></p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>漏桶一个固定容量的漏桶，按照固定常量速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝。漏桶可以看做是一个具有固定容量、固定流出速率的队列，漏桶限制的是请求的流出速率。漏桶中装的是请求。<br><img src="http://bloghello.oursnail.cn/%E6%BC%8F%E6%A1%B6%E6%B3%95.png" alt="image"></p>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌桶是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌，填满了就丢弃令牌，请求是否被处理要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求。令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌。令牌桶中装的是令牌。<br><img src="http://bloghello.oursnail.cn/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png" alt="image"></p>
<p>其主要思想是：每隔固定时间往令牌桶里放令牌，突发请求来的时候，令牌桶里的数量够的话，就删除对应请求个数的令牌；令牌桶的数量不够的话，那么则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</p>
<p><img src="http://bloghello.oursnail.cn/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%952.png" alt="image"></p>
<h4 id="计数器算法VS滑动窗口"><a href="#计数器算法VS滑动窗口" class="headerlink" title="计数器算法VS滑动窗口"></a>计数器算法VS滑动窗口</h4><p>计数器算法可以看作是滑动窗口的低精度的实现，滑动窗口精度高，但是需要的存储空间更大，因为每一个格子都需要一个计数器。</p>
<h4 id="漏桶算法VS令牌桶算法"><a href="#漏桶算法VS令牌桶算法" class="headerlink" title="漏桶算法VS令牌桶算法"></a>漏桶算法VS令牌桶算法</h4><blockquote>
<p>令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；</p>
</blockquote>
<blockquote>
<p>漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；</p>
</blockquote>
<blockquote>
<p>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量；</p>
</blockquote>
<blockquote>
<p>漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2），从而平滑突发流入速率；</p>
</blockquote>
<blockquote>
<p>令牌桶允许一定程度的突发，而漏桶主要目的是平滑流入速率；</p>
</blockquote>
<blockquote>
<p>两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。</p>
</blockquote>
<p>可以参考：<a href="http://jinnianshilongnian.iteye.com/blog/2305117" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/2305117</a></p>
<hr>
<p>还有一些其他的高可用的思路：</p>
<h2 id="高并发处理之服务降级与服务熔断思路"><a href="#高并发处理之服务降级与服务熔断思路" class="headerlink" title="高并发处理之服务降级与服务熔断思路"></a>高并发处理之服务降级与服务熔断思路</h2><h4 id="服务降级分类"><a href="#服务降级分类" class="headerlink" title="服务降级分类"></a>服务降级分类</h4><p>自动降级：超时、失败次数、故障、限流</p>
<p>人工降级：秒杀，双11大促</p>
<h2 id="数据库切库分库分表思路"><a href="#数据库切库分库分表思路" class="headerlink" title="数据库切库分库分表思路"></a>数据库切库分库分表思路</h2><p>数据量大的时候，数据库分库分表</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/15.@PropertySource加载外部配置文件/" class="prev">上一篇</a><a href="/2018/07/21/14、订单模块开发/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>