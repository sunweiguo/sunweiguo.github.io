<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 23.SpringAop--动态代理模式 · Eureka-Home</title><meta name="description" content="23.SpringAop--动态代理模式 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">23.SpringAop--动态代理模式</h1><div class="post-info">Jul 21, 2018</div><div class="post-content"><p>spring aop中用到了两大主流的动态代理模式。<br><a id="more"></a></p>
<h2 id="jdk代理"><a href="#jdk代理" class="headerlink" title="jdk代理"></a>jdk代理</h2><p>在java基础中已经对其进行了详细的说明，略过。</p>
<h2 id="cglib实现原理"><a href="#cglib实现原理" class="headerlink" title="cglib实现原理"></a>cglib实现原理</h2><h4 id="什么是CGLIB"><a href="#什么是CGLIB" class="headerlink" title="什么是CGLIB?"></a>什么是CGLIB?</h4><p><code>CGLIB</code>是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为<code>JDK</code>的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，<code>CGLIB</code>是一个好的选择。</p>
<h4 id="CGLIB原理"><a href="#CGLIB原理" class="headerlink" title="CGLIB原理"></a>CGLIB原理</h4><p><code>CGLIB</code>原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是<code>final</code>的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。</p>
<p><code>CGLIB</code>底层：使用字节码处理框架<code>ASM</code>，来转换字节码并生成新的类。不鼓励直接使用<code>ASM</code>，因为它要求你必须对<code>JVM</code>内部结构包括<code>class</code>文件的格式和指令集都很熟悉。</p>
<p><code>CGLIB</code>缺点：对于<code>final</code>方法，无法进行代理。</p>
<h4 id="CGLIB的应用"><a href="#CGLIB的应用" class="headerlink" title="CGLIB的应用"></a>CGLIB的应用</h4><p>广泛的被许多AOP的框架使用，例如<code>Spring AOP</code>和<code>dynaop</code>。<code>Hibernate</code>使用<code>CGLIB</code>来代理单端<code>single-ended</code>(多对一和一对一)关联。</p>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>定义一个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is realSubject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义一个拦截器。在调用目标方法时，<code>CGLib</code>会回调<code>MethodInterceptor</code>接口方法拦截，来实现你自己的代理逻辑，类似于JDK中的<code>InvocationHandler</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before in cglib"</span>);</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = methodProxy.invokeSuper(obj,args);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"after in cglib"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Object</code>为目标对象</li>
<li><code>Method</code>为上文中实体类所调用的被代理的方法引用</li>
<li><code>Object[]</code>为参数值列表</li>
<li><code>MethodProxy</code>为生成的代理类对方法的代理引用。</li>
</ul>
<p>生成动态代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Enhancer实例</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//通过setSuperclass方法来设置目标类</span></span><br><span class="line">        enhancer.setSuperclass(RealSubject.class);</span><br><span class="line">        <span class="comment">//通过setCallback 方法来设置拦截对象</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> DemoMethodInterceptor());</span><br><span class="line">        <span class="comment">//create方法生成Target的代理类，并返回代理类的实例</span></span><br><span class="line">        RealSubject subject = (RealSubject) enhancer.create();</span><br><span class="line">        subject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>Enhancer</code>类是<code>CGLib</code>中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展，以后会经常看到它。</p>
<p>首先将被代理类<code>TargetObject</code>设置成父类，然后设置拦截器<code>TargetInterceptor</code>，最后执行<code>enhancer.create()</code>动态生成一个代理类，并从<code>Object</code>强制转型成父类型<code>RealSubject</code>。</p>
<p>最后，在代理类上调用方法.</p>
<h2 id="jdk和cglib代理对比"><a href="#jdk和cglib代理对比" class="headerlink" title="jdk和cglib代理对比"></a>jdk和cglib代理对比</h2><ul>
<li><code>JDK</code>只能针对有接口的类的的接口方法进行动态代理</li>
<li><code>Cglib</code>基于继承来实现代理，无法对<code>static</code>，<code>final</code>类进行代理</li>
<li><code>Cglib</code>基于继承来实现代理，无法对<code>private</code>，<code>static</code>方法进行代理</li>
</ul>
<h2 id="spring如何创建aop代理类"><a href="#spring如何创建aop代理类" class="headerlink" title="spring如何创建aop代理类"></a>spring如何创建aop代理类</h2><ul>
<li>如果目标对象实现了接口，则默认采用 JDK 动态代理</li>
<li>如果目标对象没有实现接口，则采用 Cglib 进行动态代理</li>
<li>如果目标对象实现了接口，且强制 Cglib 代理，则使用 Cglib 代理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制使用cglib代理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass =  <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/22、springMVC全局异常+spring包扫描包隔离+spring事务传播/" class="prev">PREV</a><a href="/2018/07/21/22.SpringAop--基本使用和切点表达式/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>