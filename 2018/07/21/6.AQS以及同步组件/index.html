<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 6.AQS以及同步组件 · Eureka-Home</title><meta name="description" content="6.AQS以及同步组件 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">6.AQS以及同步组件</h1><div class="post-info">Jul 21, 2018</div><div class="post-content"><p>AQS以及同步组件.<br><a id="more"></a></p>
<h2 id="1-AQS介绍"><a href="#1-AQS介绍" class="headerlink" title="1. AQS介绍"></a>1. AQS介绍</h2><p><code>AQS</code>是<code>JUC</code>的核心。而<code>JUC</code>大大提高了JAVA并发性能。</p>
<ul>
<li><p>底层数据结构是一个<code>FIFO</code>队列。</p>
</li>
<li><p>使用<code>Node</code>实现<code>FIFO</code>队列，可以用于构建锁或者其他同步装置的基础框架。</p>
</li>
<li><p>利用了一个int类型表示状态。</p>
</li>
<li><p>使用方法是继承：子类通过继承并通过实现它的方法管理其状态。</p>
</li>
<li><p>可以同时实现排他锁和共享锁模式。在使用者的角度, <code>AQS</code> 的功能分为两类, 独占功能 和共享功能. 它的所有子类中要么实现并使用了它的独占功能API , 要么使用了共享锁的功能 , 不会同时使用两套API</p>
</li>
</ul>
<blockquote>
<p>它底层使用的是双向列表 ,是队列的一种实现 , 因此也可以将它当成一种队列 . 其中 <code>Sync queue</code> 是同步列表 ,它是双向列表 , 包括 <code>head</code> ,<code>tail</code> 节点. 其中head 节点主要用来后续的调度 ; <code>Condition queue</code> 是单向链表 , 不是必须的 , 只有当程序中需要<code>Condition</code> 的时候 ,才会存在这个 单向链表 , 并且可能会有多个 <code>Condition queue</code></p>
</blockquote>
<p><img src="http://bloghello.oursnail.cn/AQS.png" alt="image"></p>
<blockquote>
<p><code>AQS</code>实现的大致思路：首先 <code>AQS</code> 内部维护了一个 CLH队列来管理锁 , 线程首先会尝试获取锁 , 如果失败, 就将当前线程及等待状态等信息包成一个<code>NODE</code> 节点 加入到 同步队列 (<code>Sync queue</code>)里 , 接着会不断循环尝试获取锁, 它的条件是当前节点为<code>head</code> 的直接后继才会尝试 , 如果失败就会阻塞自己, 直到自己被唤醒,而当持有锁的线程释放锁的时候会唤醒队列中的后继线程 .</p>
</blockquote>
<h2 id="2-AQS同步组件"><a href="#2-AQS同步组件" class="headerlink" title="2. AQS同步组件"></a>2. AQS同步组件</h2><h4 id="2-1-CountDownLatch"><a href="#2-1-CountDownLatch" class="headerlink" title="2.1 CountDownLatch"></a>2.1 CountDownLatch</h4><p>计数器减到0，处于等待的线程才会继续执行。只能用一次，不能重置。</p>
<p>比如有一个运算量很大的任务，我们可以将它拆分为多个子任务，等所有子任务全部完成之后，再执行最后的汇总工作。<br><img src="http://bloghello.oursnail.cn/CountDownLatch.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;threadCount;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    log.error(<span class="string">"exection"</span>,e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"finish ..."</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>,threadNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果，截取了最后一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">16:34:36.385 [pool-1-thread-90] INFO com.njupt.swg.threadstudyjimin.item07.CountdownLatchTest - 89</span><br><span class="line">16:34:36.385 [pool-1-thread-84] INFO com.njupt.swg.threadstudyjimin.item07.CountdownLatchTest - 83</span><br><span class="line">16:34:36.385 [pool-1-thread-92] INFO com.njupt.swg.threadstudyjimin.item07.CountdownLatchTest - 91</span><br><span class="line">16:34:36.385 [pool-1-thread-94] INFO com.njupt.swg.threadstudyjimin.item07.CountdownLatchTest - 93</span><br><span class="line">16:34:36.385 [pool-1-thread-96] INFO com.njupt.swg.threadstudyjimin.item07.CountdownLatchTest - 95</span><br><span class="line">16:34:36.385 [pool-1-thread-98] INFO com.njupt.swg.threadstudyjimin.item07.CountdownLatchTest - 97</span><br><span class="line">16:34:36.386 [pool-1-thread-100] INFO com.njupt.swg.threadstudyjimin.item07.CountdownLatchTest - 99</span><br><span class="line">16:34:36.516 [main] INFO com.njupt.swg.threadstudyjimin.item07.CountdownLatchTest - finish ...</span><br></pre></td></tr></table></figure>
<p>那如果是这种场景呢：计算若干个子任务，给定一个时间，超过这个时间的话，就把这个任务放弃掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<h4 id="2-2-Semaphore"><a href="#2-2-Semaphore" class="headerlink" title="2.2 Semaphore"></a>2.2 Semaphore</h4><p>能控制同一时间并发线程的数目</p>
<blockquote>
<p><code>Semaphore</code>实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造<code>Semaphore</code>对象时传入的参数选项。单个信号量的<code>Semaphore</code>对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。</p>
</blockquote>
<p><img src="http://bloghello.oursnail.cn/18-5-14/16690827.jpg" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;threadCount;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//获取一个许可</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release();<span class="comment">//释放一个许可</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    log.error(<span class="string">"exection"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"finish ..."</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>,threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果是：每秒执行三个线程。这里是一个线程获取一个许可，那么同一时间，可以有三个线程进来一起工作。那如果我改成一个线程获取三个许可呢？就像一个人同时占三个坑位，那么只有等这个人拉完了才能轮到下一个人了，那么此时就变成跟单线程一样了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">3</span>);</span><br><span class="line">test(threadNum);</span><br><span class="line">semaphore.release(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>考虑这个场景：并发太高了，就算是控制线程数量，也比较棘手；一个厕所三个坑位，外面人太多了，让三个人进来，其他的都给轰走。如何做到呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(semaphore.tryAcquire())&#123;<span class="comment">//尝试获取一个许可</span></span><br><span class="line">    test(threadNum);</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：只有三条信息打印出来，其他的线程就都被丢弃了。</p>
<p>也可以给他一个超时时间，这里是5000毫秒。每个命令需要运行1000毫秒，那么程序等1000毫秒之后会打印三条；然后再等1000毫秒，又可以拿到新的三个许可，再打印三条；直到5000毫秒用完。可能会打印3*5条记录。剩下的5条记录由于已经超时，全部被放弃掉。</p>
<p>上厕所例子：一共三个坑，我给定一个小时，先进来三个人，好了，他们都在10分钟内解决(这里假设最后一个人是正好用了10分钟)，那么这三个坑又可以继续用了，下一批三个人进来用，假设又恰好用了10分钟；那么直到一个小时，有多少人可以上厕所呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(semaphore.tryAcquire(<span class="number">5000</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">    test(threadNum);</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-CyclicBarrier"><a href="#2-3-CyclicBarrier" class="headerlink" title="2.3 CyclicBarrier"></a>2.3 CyclicBarrier</h4><blockquote>
<p><code>CyclicBarrier</code>也是一个同步辅助类 , 它允许一组线程相互等待 , 直到到达某个公共的屏障点 , 通过它可以完成多个线程之间相互等待 ,只有当每个线程都准备好之后, 才能各自继续往下执行后续的操作, 和 <code>CountDownLatch</code>相似的地方就是, 它也是通过计数器来实现的. 当某个线程调用了 <code>await()</code>方法之后, 该线程就进入了等待状态 . 而且计数器就进行 -1 操作 , 当计数器的值达到了我们设置的初始值0的时候 , 之前调用了<code>await()</code> 方法而进入等待状态的线程会被唤醒继续执行后续的操作. 因为 <code>CyclicBarrier</code>释放线程之后可以重用, 所以又称之为循环屏障 . <code>CyclicBarrier</code> 使用场景和  <code>CountDownLatch</code> 很相似 , 可以用于多线程计算数据, 最后合并计算结果的应用场景 .</p>
</blockquote>
<p><img src="http://bloghello.oursnail.cn/18-5-14/65784628.jpg" alt="image"></p>
<p>两者的区别：</p>
<ul>
<li><p><code>CountDownLatch</code>的计数器只能使用一次 , 而 <code>CyclicBarrier</code> 的计数器可以使用 <code>reset</code>重置 循环使用</p>
</li>
<li><p><code>CountDownLatch</code> 主要是 1 个 或者 n 个线程需要等待其它线程完成某项操作之后才能继续往下执行 , 其描述的是 1 个 或者 n 个线程与其它线程的关系 ; CyclicBarrier 主要是实现了 1 个或者多个线程之间相互等待,直到所有的线程都满足条件之后, 才执行后续的操作 , 其描述的是内部各个线程相互等待的关系 .</p>
</li>
</ul>
<p><code>CyclicBarrier</code> 假如有 5 个线程都调用了 <code>await()</code> 方法 , 那这个 5 个线程就等着 , 当这 5 个线程都准备好之后, 它们有各自往下继续执行 , 如果这 5 个线程在后续有一个计算发生错误了 , 这里可以重置计数器 , 并让这 5 个线程再执行一遍 .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> );</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    race();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"ready..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"continue..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：先每隔一秒执行race方法打印出ready,等3个线程打印完毕，立即都将阻塞的log.info(“continue…”);全部打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-1] INFO ready...</span><br><span class="line">[pool-1-thread-2] INFO ready...</span><br><span class="line">[pool-1-thread-3] INFO ready...</span><br><span class="line">[pool-1-thread-1] INFO continue...</span><br><span class="line">[pool-1-thread-2] INFO continue...</span><br><span class="line">[pool-1-thread-3] INFO continue...</span><br><span class="line">[pool-1-thread-4] INFO ready...</span><br><span class="line">[pool-1-thread-2] INFO ready...</span><br><span class="line">[pool-1-thread-3] INFO ready...</span><br><span class="line">[pool-1-thread-4] INFO continue...</span><br><span class="line">[pool-1-thread-2] INFO continue...</span><br><span class="line">[pool-1-thread-3] INFO continue...</span><br></pre></td></tr></table></figure>
<p>也可以设定超时时间，超过时间了就不等了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.info(<span class="string">"ready..."</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cyclicBarrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">"exception"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"continue..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在大家已经都准备好了的时候，先做一件事情，可以在声明<code>CyclicBarrier</code>后面增加一个线程来执行。</p>
<p>就像开会，人都到齐了之后，我们喊一声，人都到齐，我们现在开始开会了啊。下面就开始正式开会。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>,() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"callback is running..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="3-ReentrantLock与锁"><a href="#3-ReentrantLock与锁" class="headerlink" title="3. ReentrantLock与锁"></a>3. ReentrantLock与锁</h2><h4 id="3-1-ReentrantLock与synchronized区别"><a href="#3-1-ReentrantLock与synchronized区别" class="headerlink" title="3.1 ReentrantLock与synchronized区别"></a>3.1 ReentrantLock与synchronized区别</h4><ul>
<li>都是可重入锁</li>
<li><code>synchronized</code>是JVM实现的，<code>ReentrantLock</code>是jdk实现的。前者是操作系统来实现，后者是敲代码实现。</li>
<li><code>synchronized</code>以前性能很烂，在优化之后，两者差不多。</li>
<li><code>synchronized</code>比较方便，<code>ReentrantLock</code>需要手工加锁和释放锁。但是<code>ReentrantLock</code>更加灵活。</li>
</ul>
<h4 id="3-2-ReentrantLock优点"><a href="#3-2-ReentrantLock优点" class="headerlink" title="3.2 ReentrantLock优点"></a>3.2 ReentrantLock优点</h4><ul>
<li>可以指定公平锁和非公平锁，但是<code>synchronized</code>只能是非公平锁</li>
<li>提供了一个<code>Condition</code>类，可以分组唤醒需要唤醒的线程；而<code>synchronized</code>要么是随机唤醒一个线程，要么是唤醒所有线程</li>
<li>提供能够中断等待锁的线程的机制，<code>lock.lockInterruptibly()</code></li>
<li><code>ReentrantLock</code>依靠自旋锁实现，通过循环调用CAS操作来实现加锁，性能比较好是因为避免了线程进入内核态的阻塞状态</li>
</ul>
<p>其中，<code>ReentrantReadWriteLock</code>是一个在没有读写锁的情况下，才可以有写入锁。读多写少，可能会导致写进程饥饿。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/6.java泛型/" class="prev">上一篇</a><a href="/2018/07/21/6.AOP、异常、整合mybatis/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>