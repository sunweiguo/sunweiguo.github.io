<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>7、二分搜索树（下） | Eureka-Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="二分搜索树（下）">
<meta name="keywords" content="数据结构与算法">
<meta property="og:type" content="article">
<meta property="og:title" content="7、二分搜索树（下）">
<meta property="og:url" content="http://yoursite.com/2018/07/21/7、二分搜索树（下）/index.html">
<meta property="og:site_name" content="Eureka-Home">
<meta property="og:description" content="二分搜索树（下）">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.gif">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E5%92%8C%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.gif">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9%E5%92%8C%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9.png">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E7%90%86%E8%A7%A3ceil%E5%92%8Cfloor.png">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B1%80%E9%99%90.png">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E7%BA%A2%E9%BB%91%E6%A0%91.png">
<meta property="og:updated_time" content="2018-06-07T04:42:56.932Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7、二分搜索树（下）">
<meta name="twitter:description" content="二分搜索树（下）">
<meta name="twitter:image" content="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.gif">
  
    <link rel="alternate" href="/atom.xml" title="Eureka-Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Eureka-Home</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-7、二分搜索树（下）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/7、二分搜索树（下）/" class="article-date">
  <time datetime="2018-07-21T03:56:21.618Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      7、二分搜索树（下）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>二分搜索树（下）<br><a id="more"></a></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>上一篇讲的是二分查找算法和二分搜索树的基本操作，如插入、查找、深度优先遍历。本篇介绍二分搜索树的广度优先遍历、顺序性、局限性以及删除节点问题。</p>
<h3 id="二、层序遍历（广度优先遍历）"><a href="#二、层序遍历（广度优先遍历）" class="headerlink" title="二、层序遍历（广度优先遍历）"></a>二、层序遍历（广度优先遍历）</h3><ol>
<li>算法思想</li>
</ol>
<p>在此需要引入两个概念：深度优先遍历和广度优先遍历，而以上讲解的前序、中序、后序遍历都属于深度优先遍历，遍历一开始首先会走到最深，再回溯到开始遍历整棵树。而广度优先遍历则是层序遍历，一层一层地向下遍历，查看以下动画：</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.gif" alt="image"></p>
<p>查看以上动画，实现其过程需要引入先进先出的“队列”数据结构，首先将28入队，第一层遍历完毕，可进行操作，将28出队并打印。遍历第二层16、30依次入队，再出队进行打印操作，依次类推。</p>
<ol start="2">
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们使用LinkedList来作为我们的队列</span></span><br><span class="line">    LinkedList&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span>( !q.isEmpty() )&#123;</span><br><span class="line"></span><br><span class="line">        Node node = q.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(node.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node.left != <span class="keyword">null</span> )</span><br><span class="line">            q.add( node.left );</span><br><span class="line">        <span class="keyword">if</span>( node.right != <span class="keyword">null</span> )</span><br><span class="line">            q.add( node.right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>不论是二分搜索树的深度优先遍历还是广度优先遍历，性能都是很高效的，为O(n)，基本上是最小的了，毕竟“遍历”至少需要每个节点遍历一次。在很多实际运用中可能不需要显示地构建出一棵树，但是需要遍历一次树中节点。</p>
<p>而之前学过的排序算法例如归并排序、快速排序本质上是一棵二叉树的深度优先遍历过程，此二分搜索树也是通过递归等基本内容构造的一棵复杂的数结构，可见算法与数据结构之间的互相依赖。</p>
<p>三. 二分搜索树的删除</p>
<ol>
<li>删除二分搜索树的最小值和最大值</li>
</ol>
<h5 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h5><p>首先来了解最简单的情况—–删除二分搜索树的最小值和最大值，其实此过程根据搜索树的特征很容易解决，从根节点开始遍历其左孩子，直至最后节点无左孩子，那么此节点就是最小值；最大值同理，遍历其右孩子即可。 </p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E5%92%8C%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png" alt="image"></p>
<h5 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h5><p>在删除节点时，需要将其左孩子或右孩子代替其删除节点，来保持二分搜索树的特征。</p>
<p>举个例子，需要删除下图二分搜索树的最小值22，删除22后，22必然没有左孩子，因为它已经是最小值，将其右孩子33代替22的位置，返回节点33。删除最大值同理。</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B1.png" alt="image"></p>
<p>删完22这个最小节点之后应该是这样的：</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E7%A4%BA%E4%BE%8B.png" width="500" height="300"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>公有函数，供外层调用：</p>
<blockquote>
<p>minimum()：寻找二分搜索树的最小的键值</p>
</blockquote>
<blockquote>
<p>maximum()：寻找二分搜索树的最大的键值</p>
</blockquote>
<blockquote>
<p>removeMin()：从二分搜索树中删除最小值所在节点</p>
</blockquote>
<blockquote>
<p>removeMax()：从二分搜索树中删除最大值所在节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找二分搜索树的最小的键值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">minimum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> count != <span class="number">0</span>;</span><br><span class="line">    Node minNode = minimum( root );</span><br><span class="line">    <span class="keyword">return</span> minNode.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找二分搜索树的最大的键值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">maximum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> count != <span class="number">0</span>;</span><br><span class="line">    Node maxNode = maximum(root);</span><br><span class="line">    <span class="keyword">return</span> maxNode.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二分搜索树中删除最小值所在节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( root != <span class="keyword">null</span> )</span><br><span class="line">        root = removeMin( root );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二分搜索树中删除最大值所在节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( root != <span class="keyword">null</span> )</span><br><span class="line">        root = removeMax( root );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回以node为根的二分搜索树的最小键值所在的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node.left == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回以node为根的二分搜索树的最大键值所在的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( node.right == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node.left == <span class="keyword">null</span> )&#123;</span><br><span class="line"></span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        count --;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以node为根的二分搜索树中的最大节点</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node.right == <span class="keyword">null</span> )&#123;</span><br><span class="line"></span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        count --;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.right = removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>删除节点</li>
</ol>
<p>以上是删除节点的特殊情况，可以确定待删除节点只有1个孩子或者没有，所以在删除此节点之后，其孩子可以顶替，这样仍维护了二分搜索树的特征。但是要删除同时拥有两个子节点的节点该怎么办呢？</p>
<p>算法被称为<code>Hubbard Deletion</code>，在之前的讨论中，若待删除节点只有一个孩子，则用此孩子替代待删除节点；若有两个孩子，其思想也是类似，找到一个合适的节点来替代，而<code>Hubbard Deletion</code>算法则认为此替代节点是右子树的最小节点！</p>
<p>因此，需要代替58的节点是59，注意二分搜索树的特征，59的所有右孩子都比58要大，所以右孩子子树中的最小值59代替其58后，此二分搜索树的特征仍然成立！</p>
<p>因此，整个过程可以总结为首先寻找待删除节点的后继节点（右子树中的最小值），由后继节点代替待删除节点即可。</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.gif" alt="image"></p>
<p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二分搜索树中删除键值为key的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">    root = remove(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以node为根的二分搜索树中键值为key的节点, 递归算法</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function">Node <span class="title">remove</span><span class="params">(Node node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        node.left = remove( node.left , key );</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key.compareTo(node.key) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        node.right = remove( node.right, key );</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">// key == node-&gt;key</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>( node.left == <span class="keyword">null</span> )&#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>( node.right == <span class="keyword">null</span> )&#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">        <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line">        Node successor = <span class="keyword">new</span> Node(minimum(node.right));</span><br><span class="line">        count ++;</span><br><span class="line"></span><br><span class="line">        successor.right = removeMin(node.right);</span><br><span class="line">        successor.left = node.left;</span><br><span class="line"></span><br><span class="line">        node.left = node.right = <span class="keyword">null</span>;</span><br><span class="line">        count --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：以上过程可完成二分搜索树的节点删除过程，其重点就是当待删除节点同时拥有左、右子树时，寻找右子树中的最小值进行代替。其实同理而言，另外一个思路也可实现：寻找左子树的最大值进行代替，如下图所示，这种特性来源于二分搜索树的特征，可自行实现。</p>
<h3 id="四、二分搜索树的顺序性"><a href="#四、二分搜索树的顺序性" class="headerlink" title="四、二分搜索树的顺序性"></a>四、二分搜索树的顺序性</h3><p>注意二分搜索树还有一个重要的特征：顺序性，也就是说不仅可以在二分搜索树中定位一个元素，还可以回答其顺序性相关的问题：</p>
<blockquote>
<p>minimum , maximum：已经实现，非常容易可在一组数据中找到最小、大值。</p>
</blockquote>
<blockquote>
<p>successor , predecessor：待实现，可找到一个元素的前驱节点和后继节点。</p>
</blockquote>
<blockquote>
<p>floor , ceil：待实现</p>
</blockquote>
<h4 id="1-前驱节点和后继节点"><a href="#1-前驱节点和后继节点" class="headerlink" title="1. 前驱节点和后继节点"></a>1. 前驱节点和后继节点</h4><p>举个例子，下图中 41的前驱节点是 37，后继节点是42。</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9%E5%92%8C%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9.png" alt="image"></p>
<p>因此，规律也自然而然得出：</p>
<p>一个节点的前驱节点是其左子树中的最大值，若无左子树，其前驱节点在从根节点到key的路径上，比key小的最大值。</p>
<p>一个节点的后继节点是右子树的最小值，若无右子树，其后继节点在从根节点到key的路径上，比key大的最小值。</p>
<p>主要逻辑：</p>
<blockquote>
<p>如果key所在的节点不存在，则key没有前驱, 返回NULL</p>
</blockquote>
<blockquote>
<p>如果key所在的节点左子树不为空，则其左子树的最大值为key的前驱</p>
</blockquote>
<blockquote>
<p>否则，key的前驱在从根节点到key的路径上，在这个路径上寻找到比key小的最大值， 即为key的前驱</p>
</blockquote>
<h4 id="2-floor-ceil"><a href="#2-floor-ceil" class="headerlink" title="2. floor , ceil"></a>2. floor , ceil</h4><p>寻找floor , ceil不同于上部分所讲的，寻找一个节点的前驱节点和后继节点首先有个前提就是要保证此节点一定存在，但是寻找floor , ceil无需保证。</p>
<h6 id="若key值存在，那么floor-ceil就是key值自身。"><a href="#若key值存在，那么floor-ceil就是key值自身。" class="headerlink" title="若key值存在，那么floor , ceil就是key值自身。"></a>若key值存在，那么floor , ceil就是key值自身。</h6><h6 id="若key值不存在："><a href="#若key值不存在：" class="headerlink" title="若key值不存在："></a>若key值不存在：</h6><pre><code>floor：是最接近key值且**小于**key的节点
ceil：是最接近key值且**大于**key的节点
</code></pre><h6 id="例如下图，举几个例子来了解："><a href="#例如下图，举几个例子来了解：" class="headerlink" title="例如下图，举几个例子来了解："></a>例如下图，举几个例子来了解：</h6><blockquote>
<p>节点41的floor , ceil是41；</p>
</blockquote>
<blockquote>
<p>45的floor是42，ceil是50；</p>
</blockquote>
<blockquote>
<p>64无ceil，floor是63；</p>
</blockquote>
<blockquote>
<p>11无floor，ceil是13。</p>
</blockquote>
<p><img src="http://p376695fl.bkt.clouddn.com/%E7%90%86%E8%A7%A3ceil%E5%92%8Cfloor.png" alt="image"></p>
<h6 id="代码实现逻辑"><a href="#代码实现逻辑" class="headerlink" title="代码实现逻辑"></a>代码实现逻辑</h6><p>这里寻找floor 或 ceil 的逻辑主要分为3个步骤（这里只列出寻找floor 的步骤，ceil 同理，在此不赘述）：</p>
<blockquote>
<p>如果node的key值和要寻找的key值相等：则node本身就是key的floor节点。</p>
</blockquote>
<blockquote>
<p>如果node的key值比要寻找的key值大：则要寻找的key的floor节点一定在node的左子树中。</p>
</blockquote>
<blockquote>
<p>如果node的key值比要寻找的key值小：则node有可能是key的floor节点,也有可能不是(存在比node-&gt;key大但是小于key的其余节点)，需要尝试向node的右子树寻找一下。</p>
</blockquote>
<h6 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找法, 在有序数组arr中, 查找target</span></span><br><span class="line"><span class="comment">// 如果找到target, 返回第一个target相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target, 返回比target小的最大值相应的索引, 如果这个最大值有多个, 返回最大索引</span></span><br><span class="line"><span class="comment">// 如果这个target比整个数组的最小元素值还要小, 则不存在这个target的floor值, 返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">floor</span><span class="params">(Comparable[] arr, Comparable target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找比target小的最大索引</span></span><br><span class="line">    <span class="keyword">int</span> l = -<span class="number">1</span>, r = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l &lt; r )&#123;</span><br><span class="line">        <span class="comment">// 使用向上取整避免死循环</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( arr[mid].compareTo(target) &gt;= <span class="number">0</span> )</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> l == r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该索引+1就是target本身, 该索引+1即为返回值</span></span><br><span class="line">    <span class="keyword">if</span>( l + <span class="number">1</span> &lt; arr.length &amp;&amp; arr[l+<span class="number">1</span>] == target )</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则, 该索引即为返回值</span></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找法, 在有序数组arr中, 查找target</span></span><br><span class="line"><span class="comment">// 如果找到target, 返回最后一个target相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target, 返回比target大的最小值相应的索引, 如果这个最小值有多个, 返回最小的索引</span></span><br><span class="line"><span class="comment">// 如果这个target比整个数组的最大元素值还要大, 则不存在这个target的ceil值, 返回整个数组元素个数n</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ceil</span><span class="params">(Comparable[] arr, Comparable target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找比target大的最小索引值</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length;</span><br><span class="line">    <span class="keyword">while</span>( l &lt; r )&#123;</span><br><span class="line">        <span class="comment">// 使用普通的向下取整即可避免死循环</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( arr[mid].compareTo(target) &lt;= <span class="number">0</span> )</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// arr[mid] &gt; target</span></span><br><span class="line">            r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> l == r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该索引-1就是target本身, 该索引+1即为返回值</span></span><br><span class="line">    <span class="keyword">if</span>( r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[r-<span class="number">1</span>] == target )</span><br><span class="line">        <span class="keyword">return</span> r-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则, 该索引即为返回值</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、局限性来源"><a href="#五、局限性来源" class="headerlink" title="五、局限性来源"></a>五、局限性来源</h3><p>它的局限性来源于哪？注意其二分搜索树的创建，如下图所示，同样的数据，可以对应不同的二分搜索树。</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B1%80%E9%99%90.png" alt="image"></p>
<p>如上图，第一种创建情况可能是大部分人心中设想，但是第二种情况也是符合二分搜索树的特征，如此一来，二分搜索树可能退化成链表。二分搜索树的查找过程是与其高度相关，此时高度为n，时间复杂度为O(n^2)。</p>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>其实二分搜索树的性能总体而言还是十分优异的，它所有的有关操作时间复杂度为O(n)，出现以上情况的概率很小，但如果创建时其数据都是有序的，那么就会令人担忧了。也许你会想到快速排序中也有此问题，不过它通过随机获取标志点的方法解决了此问题。</p>
<p>所以类似以上解决办法，将其顺序打乱再插入到二分搜索树即可？这是一个解决办法，但是需要一开始获取所有数据，其实这些数据是慢慢流入系统的，所以在创建其过程中才会发现数据是否几乎有序。</p>
<p>为了解决此问题，可以改造二叉树的实现，使得其无法退化成链表—–平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 logn 级别的，此概念的经典实现就是红黑树。</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="image"></p>
<p><a href="https://github.com/liuyubobobo/Play-with-Algorithms" target="_blank" rel="noopener">所有以上解决算法详细代码请查看liuyubo老师的github </a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/7、二分搜索树（下）/" data-id="cjoocveib007fg4w6xmq3m4wt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/21/7、分类管理模块/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          7、分类管理模块
        
      </div>
    </a>
  
  
    <a href="/2018/07/21/7、LinkedHashMap源码分析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">7、LinkedHashMap源码分析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础/">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java容器/">java容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发基础/">java并发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发进阶/">java并发进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java虚拟机/">java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql多数据源/">mysql多数据源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis学习/">redis学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring学习/">spring学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剑指Offer/">剑指Offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单车后台系统实战/">单车后台系统实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信点餐系统/">微信点餐系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术短文杂记/">技术短文杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入分析Java-Web技术内幕/">深入分析Java Web技术内幕</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电商项目实战/">电商项目实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/秒杀系统实战/">秒杀系统实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络及其他/">计算机网络及其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 14px;">Mysql</a> <a href="/tags/java基础/" style="font-size: 16.67px;">java基础</a> <a href="/tags/java容器/" style="font-size: 16.67px;">java容器</a> <a href="/tags/java并发基础/" style="font-size: 16px;">java并发基础</a> <a href="/tags/java并发进阶/" style="font-size: 17.33px;">java并发进阶</a> <a href="/tags/java虚拟机/" style="font-size: 16.67px;">java虚拟机</a> <a href="/tags/leetcode/" style="font-size: 15.33px;">leetcode</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql多数据源/" style="font-size: 10px;">mysql多数据源</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/redis学习/" style="font-size: 15.33px;">redis学习</a> <a href="/tags/spring学习/" style="font-size: 19.33px;">spring学习</a> <a href="/tags/剑指Offer/" style="font-size: 20px;">剑指Offer</a> <a href="/tags/单车后台系统实战/" style="font-size: 18px;">单车后台系统实战</a> <a href="/tags/微信点餐系统/" style="font-size: 14.67px;">微信点餐系统</a> <a href="/tags/技术短文杂记/" style="font-size: 11.33px;">技术短文杂记</a> <a href="/tags/数据结构与算法/" style="font-size: 13.33px;">数据结构与算法</a> <a href="/tags/深入分析Java-Web技术内幕/" style="font-size: 10px;">深入分析Java Web技术内幕</a> <a href="/tags/电商项目实战/" style="font-size: 18.67px;">电商项目实战</a> <a href="/tags/秒杀系统实战/" style="font-size: 13.33px;">秒杀系统实战</a> <a href="/tags/计算机网络及其他/" style="font-size: 13.33px;">计算机网络及其他</a> <a href="/tags/设计模式/" style="font-size: 12px;">设计模式</a> <a href="/tags/随笔/" style="font-size: 10.67px;">随笔</a> <a href="/tags/面试/" style="font-size: 12.67px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/21/spring多数据源实现读写分离/">spring多数据源实现读写分离</a>
          </li>
        
          <li>
            <a href="/2018/10/19/navicate新建查询报错问题记录/">navicate新建查询报错问题记录</a>
          </li>
        
          <li>
            <a href="/2018/09/24/对于工厂模式的理解/">对于工厂模式的理解</a>
          </li>
        
          <li>
            <a href="/2018/09/24/三、设计模式-抽象工厂模式/">三、设计模式-抽象工厂模式</a>
          </li>
        
          <li>
            <a href="/2018/09/24/二、设计模式-工厂方法模式/">二、设计模式-工厂方法模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Eureka<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>