<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 八、JVM对synchronized的优化 · Eureka-Home</title><meta name="description" content="八、JVM对synchronized的优化 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">八、JVM对synchronized的优化</h1><div class="post-info">Jul 21, 2018</div><div class="post-content"><p>聊一聊JVM对synchronized的优化。<br><a id="more"></a></p>
<h2 id="1）锁消除"><a href="#1）锁消除" class="headerlink" title="1）锁消除"></a>1）锁消除</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>JVM在JIT编译(即时编译)时，通过对运行上下文的扫描，去除掉那些不可能发生共享资源竞争的锁，从而节省了线程请求这些锁的时间。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><blockquote>
<p><code>StringBuffer</code>的<code>append</code>方法是一个同步方法，如果<code>StringBuffer</code>类型的变量是一个局部变量，<br>则该变量就不会被其它线程所使用，即对局部变量的操作是不会发生线程不安全的问题。<br>在这种情景下，JVM会在JIT编译时自动将<code>append</code>方法上的锁去掉。</p>
</blockquote>
<h2 id="2）锁粗化"><a href="#2）锁粗化" class="headerlink" title="2）锁粗化"></a>2）锁粗化</h2><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，即将加锁的粒度放大。</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>在for循环里的加锁/解锁操作，一般需要放到for循环外。</p>
<h2 id="3）自旋锁"><a href="#3）自旋锁" class="headerlink" title="3）自旋锁"></a>3）自旋锁</h2><ul>
<li>背景：互斥同步对性能最大的影响是阻塞，挂起和恢复线程都需要转入内核态中完成；并且通常情况下，共享数据的锁定状态只持续很短的一段时间，为了这很短的一段时间进行上下文切换并不值得。</li>
<li>原理：当一条线程需要请求一把已经被占用的锁时，并不会进入阻塞状态，而是继续持有CPU执行权等待一段时间，该过程称为『自旋』。</li>
<li>优点：由于自旋等待锁的过程线程并不会引起上下文切换，因此比较高效；</li>
<li>缺点：自旋等待过程线程一直占用CPU执行权但不处理任何任务，因此若该过程过长，那就会造成CPU资源的浪费。</li>
<li>自适应自旋：自适应自旋可以根据以往自旋等待时间的经验，计算出一个较为合理的本次自旋等待时间。</li>
</ul>
<h2 id="4）使用偏向锁和轻量级锁"><a href="#4）使用偏向锁和轻量级锁" class="headerlink" title="4）使用偏向锁和轻量级锁"></a>4）使用偏向锁和轻量级锁</h2><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>1)java6为了减少获取锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。</p>
<p>2)锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁、轻量级锁、重量级锁。</p>
<p>3)锁的状态会随着竞争情况逐渐升级，并且只可以升级而不能降级。    </p>
<h4 id="【轻量级锁】"><a href="#【轻量级锁】" class="headerlink" title="【轻量级锁】"></a>【轻量级锁】</h4><ul>
<li>本质：使用CAS取代互斥同步。</li>
<li>背景：『轻量级锁』是相对于『重量级锁』而言的，而重量级锁就是传统的锁。</li>
<li>轻量级锁与重量级锁的比较：<ul>
<li>重量级锁是一种悲观锁，它认为总是有多条线程要竞争锁，所以它每次处理共享数据时，不管当前系统中是否真的有线程在竞争锁，它都会使用互斥同步来保证线程的安全；</li>
<li>而轻量级锁是一种乐观锁，它认为锁存在竞争的概率比较小，所以它不使用互斥同步，而是使用CAS操作来获得锁，这样能减少互斥同步所使用的『互斥量』带来的性能开销。</li>
</ul>
</li>
<li>实现原理：<ul>
<li>对象头称为『Mark Word』，虚拟机为了节约对象的存储空间，对象处于不同的状态下，Mark Word中存储的信息也所有不同</li>
<li>Mark Word中有个标志位用来表示当前对象所处的状态</li>
<li>当线程请求锁时，若该锁对象的Mark Word中标志位为01（未锁定状态），则在该线程的栈帧中创建一块名为『锁记录』的空间，然后将锁对象的Mark Word拷贝至该空间；最后通过CAS操作将锁对象的Mark Word指向该锁记录；</li>
<li>若CAS操作成功，则轻量级锁的上锁过程成功；</li>
<li>若CAS操作失败，再判断当前线程是否已经持有了该轻量级锁；若已经持有，则直接进入同步块；若尚未持有，则表示该锁已经被其他线程占用，此时轻量级锁就要膨胀成重量级锁。</li>
</ul>
</li>
<li>使用前提:<ul>
<li>轻量级锁比重量级锁性能更高的前提是，在轻量级锁被占用的整个同步周期内，不存在其他线程的竞争。若在该过程中一旦有其他线程竞争，那么就会膨胀成重量级锁，从而除了使用互斥量以外，还额外发生了CAS操作，因此更慢！</li>
</ul>
</li>
<li>优点：在没有多线程竞争的前提下，减少传统的重量级锁带来的性能损耗。  </li>
<li>缺点：竞争的线程如果始终得不到锁，自旋会消耗cpu。  </li>
<li>应用：追求响应时间，同步块执行速度非常快。</li>
</ul>
<h4 id="【偏向锁】"><a href="#【偏向锁】" class="headerlink" title="【偏向锁】"></a>【偏向锁】</h4><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换<code>ThreadID</code>的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p>
<p>1)背景：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>2)概念：核心思想就是锁会偏向第一个获取它的线程，如果在接下来的执行过程中没有其它的线程获取该锁，则持有偏向锁的线程永远不需要同步。</p>
<p>3)目的：偏向锁实际上是一种优化锁，其目的是为了减少数据在无竞争情况下的性能损耗。</p>
<p>4)原理：</p>
<blockquote>
<p>如果偏向锁的标识位为0，说明此时是处于无锁状态，则当前线程通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；并且将偏向标识位设为1。</p>
<p>如果是偏向锁，则判断Mark Word中的偏向线程ID是否指向当前线程，如果偏向线程ID指向当前线程，则表明当前线程已经获取到了锁；</p>
<p>如果偏向线程ID并未指向当前线程，则通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；</p>
<p>如果CAS获取偏向锁失败，则表示有竞争。获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</p>
</blockquote>
<p>4)偏向锁的释放:</p>
<blockquote>
<p>当其它的线程尝试获取偏向锁时，持有偏向锁的线程才会释放偏向锁。</p>
<p>释放偏向锁需要等待全局安全点(在这个时间点上没有正在执行的字节码)。 </p>
<p>首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，</p>
<p>如果线程还活着，说明此时发生了竞争，则偏向锁升级为轻量级锁，然后刚刚被暂停的线程会继续往下执行同步代码。</p>
</blockquote>
<p><img src="http://cmsblogs.qiniudn.com/wp-content/uploads/2017/02/22222222222222-1.png" alt="image"></p>
<h4 id="【重量级锁】"><a href="#【重量级锁】" class="headerlink" title="【重量级锁】"></a>【重量级锁】</h4><p><code>Synchronized</code>是通过对象内部的一个叫做监视器锁（<code>monitor</code>）来实现的。但是监视器锁本质又是依赖于底层的操作系统的<code>Mutex Lock</code>来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么<code>Synchronized</code>效率低的原因。因此，这种依赖于操作系统<code>Mutex Lock</code>所实现的锁我们称之为“重量级锁”。JDK中对<code>Synchronized</code>做的种种优化，其核心都是为了减少这种重量级锁的使用。</p>
<p>说明：</p>
<ul>
<li>java6之前的<code>synchronized</code>属于重量级锁，效率低下，因为<code>monitor</code>是依赖操作系统的<code>Mutex Lock</code>(互斥量)来实现的。</li>
<li>操作系统实现线程之间的切换需要从用户态转换到核心态，这个状态之间的转换需要相对较长的时间，时间成本相对较高。</li>
<li>在互斥状态下，没有得到锁的线程会被挂起阻塞，而挂起线程和恢复线程的操作都需要从用户态转入内核态中完成。</li>
<li>优点：线程竞争不使用自旋，不会消耗cpu。</li>
<li>缺点：线程阻塞，响应时间缓慢。</li>
<li>应用：同步块执行速度较长</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/八、整合云存储/" class="prev">PREV</a><a href="/2018/07/21/八、Class文件中的字段表集合--field字段在class文件中是怎样组织的/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>