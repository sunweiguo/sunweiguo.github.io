<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>六、volatile详解 | Eureka-Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。">
<meta name="keywords" content="java并发基础">
<meta property="og:type" content="article">
<meta property="og:title" content="六、volatile详解">
<meta property="og:url" content="http://yoursite.com/2018/07/21/六、volatile详解/index.html">
<meta property="og:site_name" content="Eureka-Home">
<meta property="og:description" content="理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3985563-8a3d9a1b94b97e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png">
<meta property="og:image" content="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-4/zh/resources/1.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-4/zh/resources/2.png">
<meta property="og:image" content="https://res.infoq.com/articles/java-memory-model-4/zh/resources/3.png">
<meta property="og:updated_time" content="2018-07-09T11:48:33.071Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="六、volatile详解">
<meta name="twitter:description" content="理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/3985563-8a3d9a1b94b97e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Eureka-Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Eureka-Home</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-六、volatile详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/六、volatile详解/" class="article-date">
  <time datetime="2018-07-21T03:56:21.666Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      六、volatile详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>理解<code>volatile</code>特性的一个好方法是：把对<code>volatile</code>变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。<br><a id="more"></a></p>
<h2 id="1-什么是volatile"><a href="#1-什么是volatile" class="headerlink" title="1. 什么是volatile"></a>1. 什么是volatile</h2><p><code>volatile</code>关键字的目的是为了标记一个Java变量，使得其能够存储于主内存中。更加具体的说，是每次都会直接从电脑的主内存中读取这个变量，而不是从CPU的高速缓存里面。同样的，每次写入都会写入到主内存中，而不是cache里面。</p>
<p>事实上，从Java5开始，<code>volatile</code>关键字的作用就不只是保证变量只会从主存里面读写了，接下来就来阐述这一概念。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3985563-8a3d9a1b94b97e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="2-为什么要用volatile"><a href="#2-为什么要用volatile" class="headerlink" title="2. 为什么要用volatile"></a>2. 为什么要用volatile</h2><p><code>Volatile</code>变量修饰符如果使用恰当的话，它比<code>synchronized</code>的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被<code>volatile</code>修饰之后，那么就具备了两层语义：</p>
<p>1） 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>2） 禁止进行指令重排序。</p>
<h2 id="3-volatile的原理简介"><a href="#3-volatile的原理简介" class="headerlink" title="3. volatile的原理简介"></a>3. volatile的原理简介</h2><p><code>voliatile</code>关键字保证了在进程中变量的变化的可见性。</p>
<p>在多线程的应用里，如果线程操作了一个没有被<code>volatile</code>关键字标记的变量，那么每个线程都会在使用到这个变量时从主存里拷贝这个变量到CPU的cache里面（为了性能！）。如果你的电脑有多于一个CPU，那么每个线程都会在不同的CPU上面运行，这意味着每个线程都会把这个变量拷贝到不同的CPU cache里面，正如下图所示：</p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png" alt="image"></p>
<p>一个不带有<code>volatile</code>关键字的变量在JVM从主存里面读取数据到CPU cache或者从cache里面写入数据到主存时是没有保证的，这会导致一些问题，在接下来的章节中我们就来讨论这些问题。</p>
<p>想象这样一个场景，当一到两个线程允许去共享一个包含了一个计数变量的对象，这个计数变量如下所定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">//无关键字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，这线程一增加了<code>counter</code>变量的值，但是，但是同时线程一和线程二都有可能随时读取这个<code>counter</code>变量。</p>
<p>如果这个<code>counter</code>变量未曾使用<code>volatile</code>声明，那么我们就无法保证这个变量在两个线程中所位于的CPU的cache和主存中的值是否保持一致了。示意图如下： </p>
<p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png" alt="image"></p>
<p>那么部分的线程就不能看到这个变量最新的样子，因为这个变量还没有被线程写回到主存中，这就是可视性的问题，这个线程更新的变量对于其他线程是不可视的。</p>
<p>在声明了<code>counter</code>变量的<code>volatile</code>关键字后，所有写入到<code>counter</code>变量的值会被立即写回到主存中。同时，所有读取这个变量的线程会直接从主存里面读取这个变量，下面的代码就是声明带<code>volatile</code>关键字的变量的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此声明这个变量就保证了这个变量对于其他写这个变量的线程的可视性。</p>
<p>总结：</p>
<p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了<code>Volatile</code>变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p>
<p><strong>简而言之，归纳为：</strong></p>
<blockquote>
<p>第一：使用<code>volatile</code>关键字会强制将修改的值立即写入主存；</p>
</blockquote>
<blockquote>
<p>第二：使用<code>volatile</code>关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
</blockquote>
<blockquote>
<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
</blockquote>
<h2 id="4-volatile的特性"><a href="#4-volatile的特性" class="headerlink" title="4. volatile的特性"></a>4. volatile的特性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>;  <span class="comment">//使用volatile声明64位的long型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        vl = l;   <span class="comment">//单个volatile变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        vl++;    <span class="comment">//复合（多个）volatile变量的读/写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vl;   <span class="comment">//单个volatile变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class VolatileFeaturesExample &#123;</span><br><span class="line">    long vl = 0L;               // 64位的long型普通变量</span><br><span class="line"></span><br><span class="line">    public synchronized void set(long l) &#123;     //对单个的普通 变量的写用同一个监视器同步</span><br><span class="line">        vl = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getAndIncrement () &#123; //普通方法调用</span><br><span class="line">        long temp = get();           //调用已同步的读方法</span><br><span class="line">        temp += 1L;                  //普通写操作</span><br><span class="line">        set(temp);                   //调用已同步的写方法</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized long get() &#123; </span><br><span class="line">    //对单个的普通变量的读用同一个监视器同步</span><br><span class="line">        return vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面示例程序所示，对一个<code>volatile</code>变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个监视器锁来同步，它们之间的执行效果相同。</p>
<p>监视器锁的<code>happens-before</code>规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个<code>volatile</code>变量的读，总是能看到（任意线程）对这个<code>volatile</code>变量最后的写入。</p>
<blockquote>
<p>监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的<code>long</code>型和<code>double</code>型变量，只要它是<code>volatile</code>变量，对该变量的读写就将具有原子性。如果是多个<code>volatile</code>操作或类似于<code>volatile++</code>这种复合操作，这些操作整体上不具有原子性。</p>
</blockquote>
<p><strong>简而言之，<code>volatile</code>变量自身具有下列特性：</strong></p>
<ul>
<li>可见性。对一个<code>volatile</code>变量的读，总是能看到（任意线程）对这个<code>volatile</code>变量最后的写入。</li>
<li>原子性：对任意单个<code>volatile</code>变量的读/写具有原子性，但类似于<code>volatile++</code>这种复合操作不具有原子性。</li>
<li>有序性：<code>happens-before</code> 原则，如果两个操作的执行次序无法从<code>happens-before</code>原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</li>
</ul>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过<code>synchronized</code>和<code>Lock</code>也能够保证可见性，<code>synchronized</code>和<code>Lock</code>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h2 id="5-原子性操作"><a href="#5-原子性操作" class="headerlink" title="5. 原子性操作"></a>5. 原子性操作</h2><p>请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>
<p>咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，<code>x++</code>和 <code>x = x+1</code>包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过<code>synchronized</code>和<code>Lock</code>来实现。由于<code>synchronized</code>和<code>Lock</code>能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h2 id="6-volatile-对于happens-before的保证"><a href="#6-volatile-对于happens-before的保证" class="headerlink" title="6. volatile 对于happens-before的保证"></a>6. volatile 对于happens-before的保证</h2><p>什么是<code>happens-before</code>？</p>
<p>多线程有两个基本的问题，就是原子性和可见性，而<code>happens-before</code>规则就是用来解决可见性（我还是比较喜欢称之为可视性）的。</p>
<p>如:</p>
<blockquote>
<p>在时间上，动作A发生在动作B之前，能不能<strong>保证</strong>B可以看见A？如果可以保证的话，那么就可以说hb(A,B)</p>
</blockquote>
<p><strong>JVM保证了一下的几条法则</strong>： </p>
<ul>
<li>如果A和B是同一个线程的，那么<code>hb(A, B)</code> </li>
<li>如果A是对锁的<code>unlock</code>，而B是对同一个锁的<code>lock</code>，那么<code>hb(A, B</code>)(即写优于读)</li>
<li>如果A是对<code>volatile</code>变量的写操作，B是对同一个变量的读操作，那么<code>hb(A, B)</code> </li>
<li>传递性：如果<code>hb(A, B)</code> 且 <code>hb(B, C)</code>，那么<code>hb(A, C)</code></li>
</ul>
<p>如果有两个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread1                 thread2</span><br><span class="line">----------------------------------</span><br><span class="line">x = 1    (A)</span><br><span class="line">M.unlock (B)</span><br><span class="line">x = 2    (C)</span><br><span class="line">                       M.lock (D)</span><br><span class="line">                       y = x  (E)</span><br></pre></td></tr></table></figure>
<p>那么执行到E的时候，E能不能保证看到C步呢？ </p>
<p>由法则1，hb(D,E) </p>
<p>由法则2，hb(B,D) 由法则1, hb(A,B) 综上可以推出，hb(A, E)，但是推不出hb(C, E) </p>
<p>所以，E不一定能看见C，但是E一定能看见A</p>
<p>所以执行E的时候，有可能thread2看到的x的值还是1</p>
<blockquote>
<p>补充：从内存语义的角度来说，<code>volatile</code>与监视器锁有相同的效果：<code>volatile</code>写和监视器的释放有相同的内存语义；<code>volatile</code>读与监视器的获取有相同的内存语义。</p>
</blockquote>
<p>不懂？再来个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设线程A执行<code>writer()</code>方法之后，线程B执行<code>reader()</code>方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p>
<ul>
<li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li>
<li>根据volatile规则，2 happens before 3。</li>
<li>根据happens before 的传递性规则，1 happens before 4。</li>
</ul>
<p>上述<code>happens before</code> 关系的图形化表现形式如下：</p>
<p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/1.png" alt="image"></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个<code>happens before</code> 关系。黑色箭头表示程序顺序规则；橙色箭头表示<code>volatile</code>规则；蓝色箭头表示组合这些规则后提供的<code>happens before</code>保证。</p>
<p>这里A线程写一个<code>volatile</code>变量后，B线程读同一个<code>volatile</code>变量。A线程在写<code>volatile</code>变量之前所有可见的共享变量，在B线程读同一个<code>volatile</code>变量后，将立即变得对B线程可见。</p>
<h2 id="7-volatile写-读的内存语义"><a href="#7-volatile写-读的内存语义" class="headerlink" title="7. volatile写-读的内存语义"></a>7. volatile写-读的内存语义</h2><p><strong>volatile写的内存语义如下</strong>：</p>
<blockquote>
<p>当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</p>
</blockquote>
<p>以上面示例程序<code>VolatileExample</code>为例，假设线程A首先执行<code>writer()</code>方法，随后线程B执行<code>reader()</code>方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行<code>volatile</code>写后，共享变量的状态示意图：</p>
<p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/2.png" alt="image"></p>
<p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p>
<p><strong>volatile读的内存语义如下</strong>：</p>
<blockquote>
<p>当读一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
</blockquote>
<p><img src="https://res.infoq.com/articles/java-memory-model-4/zh/resources/3.png" alt="image"></p>
<p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p>
<p>如果我们把<code>volatile</code>写和<code>volatile</code>读这两个步骤综合起来看的话，在读线程B读一个<code>volatile</code>变量后，写线程A在写这个<code>volatile</code>变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p>
<p>下面对<code>volatile</code>写和<code>volatile</code>读的内存语义做个总结：</p>
<ul>
<li>线程A写一个<code>volatile</code>变量，实质上是线程A向接下来将要读这个<code>volatile</code>变量的某个线程发出了（其对共享变量所在修改的）消息。</li>
<li>线程B读一个<code>volatile</code>变量，实质上是线程B接收了之前某个线程发出的（在写这个<code>volatile</code>变量之前对共享变量所做修改的）消息。</li>
<li>线程A写一个<code>volatile</code>变量，随后线程B读这个<code>volatile</code>变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<h2 id="8-volatile不能确保原子性"><a href="#8-volatile不能确保原子性" class="headerlink" title="8. volatile不能确保原子性"></a>8. volatile不能确保原子性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完，自旋等待</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于<code>volatile</code>保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，<code>volatile</code>关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是<code>volatile</code>没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>解决方案：可以通过<code>synchronized</code>或<code>lock</code>，进行加锁，来保证操作的原子性。也可以通过<code>AtomicInteger</code>。</p>
<h2 id="9-volatile的应用场景"><a href="#9-volatile的应用场景" class="headerlink" title="9. volatile的应用场景"></a>9. volatile的应用场景</h2><blockquote>
<p><code>volatile</code>关键字只能对32位和64位的变量使用</p>
</blockquote>
<p><code>synchronized</code>关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而<code>volatile</code>关键字在某些情况下性能要优于<code>synchronized</code>，但是要注意<code>volatile</code>关键字是无法替代<code>synchronized</code>关键字的，因为<code>volatile</code>关键字无法保证操作的原子性。通常来说，使用<code>volatile</code>必须具备以下2个条件：</p>
<blockquote>
<p>1）对变量的写操作不依赖于当前值</p>
</blockquote>
<blockquote>
<p>2）该变量没有包含在具有其他变量的不变式中</p>
</blockquote>
<p>下面列举几个Java中使用<code>volatile</code>的几个场景。</p>
<p>①.状态标记量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>②.单例模式中的<code>double check</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>instance = new Singleton();</code>//非原子操作</p>
</blockquote>
<p>执行这一句，JVM发生了如下事情：</p>
<ol>
<li><p>给 <code>instance</code> 分配内存</p>
</li>
<li><p>调用 <code>Singleton</code> 的构造函数来初始化成员变量</p>
</li>
<li><p>将<code>instance</code>对象指向分配的内存空间（执行完这步 <code>instance</code> 就为非 <code>null</code> 了）</p>
</li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 <code>instance</code> 已经是非 <code>null</code> 了（但却没有初始化），所以线程二会直接返回 <code>instance</code>，然后使用，然后顺理成章地报错。</p>
<p>有一篇文章讲的特别好：<a href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72772461</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/六、volatile详解/" data-id="cjoocvepg00f9g4w6mof6cj8z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java并发基础/">java并发基础</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/21/六、Class文件中的常量池/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          六、Class文件中的常量池
        
      </div>
    </a>
  
  
    <a href="/2018/07/21/八、整合云存储/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">八、整合云存储</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础/">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java容器/">java容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发基础/">java并发基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发进阶/">java并发进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java虚拟机/">java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql多数据源/">mysql多数据源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis学习/">redis学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring学习/">spring学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剑指Offer/">剑指Offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单车后台系统实战/">单车后台系统实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信点餐系统/">微信点餐系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术短文杂记/">技术短文杂记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深入分析Java-Web技术内幕/">深入分析Java Web技术内幕</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电商项目实战/">电商项目实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/秒杀系统实战/">秒杀系统实战</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络及其他/">计算机网络及其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 14px;">Mysql</a> <a href="/tags/java基础/" style="font-size: 16.67px;">java基础</a> <a href="/tags/java容器/" style="font-size: 16.67px;">java容器</a> <a href="/tags/java并发基础/" style="font-size: 16px;">java并发基础</a> <a href="/tags/java并发进阶/" style="font-size: 17.33px;">java并发进阶</a> <a href="/tags/java虚拟机/" style="font-size: 16.67px;">java虚拟机</a> <a href="/tags/leetcode/" style="font-size: 15.33px;">leetcode</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql多数据源/" style="font-size: 10px;">mysql多数据源</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/redis学习/" style="font-size: 15.33px;">redis学习</a> <a href="/tags/spring学习/" style="font-size: 19.33px;">spring学习</a> <a href="/tags/剑指Offer/" style="font-size: 20px;">剑指Offer</a> <a href="/tags/单车后台系统实战/" style="font-size: 18px;">单车后台系统实战</a> <a href="/tags/微信点餐系统/" style="font-size: 14.67px;">微信点餐系统</a> <a href="/tags/技术短文杂记/" style="font-size: 11.33px;">技术短文杂记</a> <a href="/tags/数据结构与算法/" style="font-size: 13.33px;">数据结构与算法</a> <a href="/tags/深入分析Java-Web技术内幕/" style="font-size: 10px;">深入分析Java Web技术内幕</a> <a href="/tags/电商项目实战/" style="font-size: 18.67px;">电商项目实战</a> <a href="/tags/秒杀系统实战/" style="font-size: 13.33px;">秒杀系统实战</a> <a href="/tags/计算机网络及其他/" style="font-size: 13.33px;">计算机网络及其他</a> <a href="/tags/设计模式/" style="font-size: 12px;">设计模式</a> <a href="/tags/随笔/" style="font-size: 10.67px;">随笔</a> <a href="/tags/面试/" style="font-size: 12.67px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/21/spring多数据源实现读写分离/">spring多数据源实现读写分离</a>
          </li>
        
          <li>
            <a href="/2018/10/19/navicate新建查询报错问题记录/">navicate新建查询报错问题记录</a>
          </li>
        
          <li>
            <a href="/2018/09/24/对于工厂模式的理解/">对于工厂模式的理解</a>
          </li>
        
          <li>
            <a href="/2018/09/24/三、设计模式-抽象工厂模式/">三、设计模式-抽象工厂模式</a>
          </li>
        
          <li>
            <a href="/2018/09/24/二、设计模式-工厂方法模式/">二、设计模式-工厂方法模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Eureka<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>