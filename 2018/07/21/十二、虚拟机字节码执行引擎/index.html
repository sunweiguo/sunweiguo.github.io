<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本章讲解虚拟机字节码执行引擎。">
<meta name="keywords" content="java虚拟机">
<meta property="og:type" content="article">
<meta property="og:title" content="十二、虚拟机字节码执行引擎">
<meta property="og:url" content="http://yoursite.com/2018/07/21/十二、虚拟机字节码执行引擎/index.html">
<meta property="og:site_name" content="Eureka-Home">
<meta property="og:description" content="本章讲解虚拟机字节码执行引擎。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%842.png">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%843.png">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%844.png">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B11">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B12">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C.png">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E4%B8%BAmain%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E6%A0%88%E5%B8%A7">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E5%AE%8C%E6%88%90%E6%A0%88%E5%B8%A7%E5%88%9D%E5%A7%8B%E5%8C%96">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A41.png">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A42.png">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E4%B8%BAgretting%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E6%A0%88%E5%B8%A7">
<meta property="og:image" content="http://p376695fl.bkt.clouddn.com/%E4%B8%BB%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E4%BB%A4.png">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/JVM%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5">
<meta property="og:image" content="http://pc65dngt9.bkt.clouddn.com/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F">
<meta property="og:updated_time" content="2018-07-21T02:35:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十二、虚拟机字节码执行引擎">
<meta name="twitter:description" content="本章讲解虚拟机字节码执行引擎。">
<meta name="twitter:image" content="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%84.png">






  <link rel="canonical" href="http://yoursite.com/2018/07/21/十二、虚拟机字节码执行引擎/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>十二、虚拟机字节码执行引擎 | Eureka-Home</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eureka-Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archiv</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/21/十二、虚拟机字节码执行引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eureka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eureka-Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">十二、虚拟机字节码执行引擎
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-07-21 11:56:21 / Updated at: 10:35:00" itemprop="dateCreated datePublished" datetime="2018-07-21T11:56:21+08:00">2018-07-21</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本章讲解虚拟机字节码执行引擎。<br><a id="more"></a></p>
<p>我们都知道，在当前的Java中（1.0）之后，编译器讲源代码转成字节码，那么字节码如何被执行的呢？这就涉及到了JVM的字节码执行引擎，执行引擎负责具体的代码调用及执行过程。就目前而言，所有的执行引擎的基本一致：</p>
<blockquote>
<p>输入：字节码文件</p>
<p>处理：字节码解析</p>
<p>输出：执行结果</p>
</blockquote>
<p>物理机的执行引擎是由硬件实现的，和物理机的执行过程不同的是虚拟机的执行引擎由于自己实现的。</p>
<h2 id="1-运行时候的栈结构"><a href="#1-运行时候的栈结构" class="headerlink" title="1. 运行时候的栈结构"></a>1. 运行时候的栈结构</h2><p>每一个线程都有一个栈,也就是前文中提到的虚拟机栈，栈中的基本元素我们称之为栈帧。</p>
<p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。</p>
<p>每个栈帧都包括了一下几部分：局部变量表、操作数栈、动态连接、方法的返回地址 和一些额外的附加信息。</p>
<p>栈帧中需要多大的局部变量表和多深的操作数栈在编译代码的过程中已经完全确定，并写入到方法表的Code属性中。</p>
<p>在活动的线程中，位于当前栈顶的栈帧才是有效的，称之为当前帧，与这个栈帧相关联的方法称为当前方法。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>需要注意的是一个栈中能容纳的栈帧是受限，过深的方法调用可能会导致StackOverFlowError，当然，我们可以认为设置栈的大小。其模型示意图大体如下： </p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%84.png" alt="image"></p>
<h3 id="1-1-局部变量表"><a href="#1-1-局部变量表" class="headerlink" title="1.1 局部变量表"></a>1.1 局部变量表</h3><p>是变量值的存储空间，由方法参数和方法内部定义的局部变量组成，其容量用Slot作为最小单位。</p>
<p>在编译期间，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p>
<p>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</p>
<p>如果是实例方法，那局部变量表第0位索引的Slot存储的是方法所属对象实例的引用，因此在方法内可以通过关键字this来访问到这个隐含的参数。其余的参数按照参数表顺序排列，参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    call(2,3);</span><br><span class="line">    ...</span><br><span class="line">    call2(2,3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void call(int i,int j)&#123;</span><br><span class="line">    int b=2;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void call2(int i,int j)&#123;</span><br><span class="line">    int b=2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时call()所对应的栈帧中的局部变量表大体如下： </p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%842.png" alt="image"></p>
<p>而call2()所对应的栈帧的局部变量表大体如下：</p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%843.png" alt="image"></p>
<p>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，重叠过程如下图：</p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%80%99%E7%9A%84%E6%A0%88%E7%BB%93%E6%9E%844.png" alt="image"></p>
<h3 id="1-2-操作数栈"><a href="#1-2-操作数栈" class="headerlink" title="1.2 操作数栈"></a>1.2 操作数栈</h3><p>后入先出栈，由字节码指令往栈中存数据和取数据，栈中的任何一个元素都是可以任意的Java数据类型。</p>
<p>和局部变量类似，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。</p>
<p>当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
<p>另外我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<h3 id="1-3-动态连接"><a href="#1-3-动态连接" class="headerlink" title="1.3 动态连接"></a>1.3 动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有该引用是为了支持方法调用过程中的动态连接。</p>
<h3 id="1-4-方法返回地址"><a href="#1-4-方法返回地址" class="headerlink" title="1.4 方法返回地址"></a>1.4 方法返回地址</h3><p>存放调用该方法的pc计数器的值。</p>
<p>当一个方法开始之后，只有两种方式可以退出这个方法：</p>
<pre><code>1、执行引擎遇到任意一个方法返回的字节码指令，也就是所谓的正常完成出口。

2、在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，
也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种方式成为异常完成出口。
</code></pre><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 </p>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置，方法正常退出时，调用者的pc计数器的值作为返回地址，而通过异常退出的，返回地址是要通过异常处理器表来确定，栈帧中一般不会保存这部分信息。本质上，方法的退出就是当前栈帧出栈的过程。</p>
<h2 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2. 方法调用"></a>2. 方法调用</h2><p>方法调用的主要任务就是确定被调用方法的版本（即调用哪一个方法），该过程不涉及方法具体的运行过程。按照调用方式共分为两类：</p>
<pre><code>解析调用是静态的过程，在编译期间就完全确定目标方法。

分派调用即可能是静态，也可能是动态的，根据分派标准可以分为单分派和多分派。两两组合有形成了静态单分派、静态多分派、动态单分派、动态多分派
</code></pre><h3 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h3><p>在Class文件中，所有方法调用中的目标方法都是常量池中的符号引用，在类加载的解析阶段，会将一部分符号引用转为直接引用，也就是在编译阶段就能够确定唯一的目标方法，这类方法的调用成为解析调用。</p>
<p>此类方法主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可访问，因此决定了他们都不可能通过继承或者别的方式重写该方法，符合这两类的方法主要有以下几种：静态方法、私有方法、实例构造器、父类方法。虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本</init></li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可认为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外[^footnote4]）称为虚方法。</p>
<h3 id="2-2-分派"><a href="#2-2-分派" class="headerlink" title="2.2 分派"></a>2.2 分派</h3><p>分派调用更多的体现在多态上。</p>
<ul>
<li>静态分派：所有依赖静态类型来定位方法执行版本的分派成为静态分派，发生在编译阶段，典型应用是方法重载。</li>
<li>动态分派：在运行期间根据实际类型来确定方法执行版本的分派成为动态分派，发生在程序运行期间，典型的应用是方法的重写。</li>
<li>单分派：根据一个宗量对目标方法进行选择。</li>
<li>多分派：根据多于一个宗量对目标方法进行选择。</li>
</ul>
<p><strong>静态分派</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"hello guy..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"hello man..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"hello woman..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">        StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();  </span><br><span class="line">        sd.sayHello(man); </span><br><span class="line">        sd.sayHello((Man)man); </span><br><span class="line">        sd.sayHello(woman); </span><br><span class="line">        sd.sayHello((Woman)woman);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello guy...</span><br><span class="line">hello man...</span><br><span class="line">hello guy...</span><br><span class="line">hello woman...</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>但为什么会选择执行参数为Human的重载呢？在这之前，先按如下代码定义两个重要的概念：Human man = new Man();</p>
<p>上面代码中的“Human”称为变量的静态类型(Static Type)或者外观类型(Apparent Type)，后面的“Man”则称为变量的实际类型(Actual Type)，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译期可知的；而实际类型变化的结果在运行期才可确定，编译期在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际类型变化  </span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">man = <span class="keyword">new</span> Woman();  </span><br><span class="line"><span class="comment">//静态类型变化  </span></span><br><span class="line">sd.sayHello((Man)man);  </span><br><span class="line">sd.sayHello((Woman)man);</span><br></pre></td></tr></table></figure>
<p>即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">    Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">    StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();  </span><br><span class="line">    sd.sayHello(man);  <span class="comment">//man</span></span><br><span class="line">    sd.sayHello((Woman)woman);  <span class="comment">//woman</span></span><br><span class="line">    </span><br><span class="line">    man = <span class="keyword">new</span> Woman();<span class="comment">//实际类型发生变化</span></span><br><span class="line">    <span class="comment">//sd.sayHello((Man)man);报错 ：Woman cannot be cast to chapter12.StaticDispatch$Man</span></span><br><span class="line">    sd.sayHello((Woman)man); <span class="comment">//woman</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数和数据类型。代码中刻意定义了两个静态类型相同，实际类型不同的变量，但<strong>虚拟机(准确地说是编译器)在重载时是通过参数的静态类型而不是实际类型作为判定依据的</strong>。并且静态类型在编译期是可知的，所以在编译阶段，Javac编译器就根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法的两条invokevirual指令的参数中。</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动力实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但是很多情况下，这个重载版本并不是“唯一的”，往往只能确定一个“更适合的”版本。这种模糊的结论在0和1构成的计算机世界中算是个比较“稀罕”的事件，产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。</p>
<p><strong>动态分派</strong></p>
<p>动态分派与重写(Override)有着很密切的关联。如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtayfjpk.jvm.chapter8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">        man.sayHello();  </span><br><span class="line">        woman.sayHello();  </span><br><span class="line">        man = <span class="keyword">new</span> Woman();  </span><br><span class="line">        man.sayHello();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里显示不可能是根据静态类型来决定的，因为静态类型都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原是是这两个变量的实际类型不同。那么Java虚拟机是如何根据实际类型来分派方法执行版本的呢，我们使用javap命令输出这段代码的字节码，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;  </span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC  </span><br><span class="line">  Code:  </span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span>  </span><br><span class="line">       0: new           #16                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Man  </span><br><span class="line">       <span class="number">3</span>: dup  </span><br><span class="line">       4: invokespecial #18                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Man."&lt;init&gt;":()V  </span><br><span class="line">       <span class="number">7</span>: astore_1  </span><br><span class="line">       8: new           #19                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman  </span><br><span class="line">      <span class="number">11</span>: dup  </span><br><span class="line">      12: invokespecial #21                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman."&lt;init&gt;":()V  </span><br><span class="line">      <span class="number">15</span>: astore_2  </span><br><span class="line">      <span class="number">16</span>: aload_1  </span><br><span class="line">      17: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      <span class="number">20</span>: aload_2  </span><br><span class="line">      21: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      24: new           #19                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman  </span><br><span class="line">      <span class="number">27</span>: dup  </span><br><span class="line">      28: invokespecial #21                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman."&lt;init&gt;":()V  </span><br><span class="line">      <span class="number">31</span>: astore_1  </span><br><span class="line">      <span class="number">32</span>: aload_1  </span><br><span class="line">      33: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      <span class="number">36</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>0-15行的字节码是准备动作，作用是建立man和woman的内存空间，调用Man和Woman类的实例构造器，将这两个实例的引用存放在第1和第2个局部变量表Slot之中，这个动作对应了代码中这两句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>
<p>接下来的第16-21行是关键部分，第16和第20两行分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将执行的sayHello()方法的所有者，称为接收者(Receiver)。</p>
<p>第17和第21两行是方法调用指令，单从字节码的角度来看，这两条调用指令无论是指令(都是invokevirtual)还是参数(都是常量池中Human.sayHello()的符号引用)都完全一样，但是这两条指令最终执行的目标方法并不相同，其原因需要从invokevirutal指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下步骤：</p>
<pre><code>a.找到操作数栈顶的第一个元素所指向的对象实际类型，记作C。
b.如果在类型C中找到与常量中描述符和简单名称都相同的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找结束；不通过则返回java.lang.IllegalAccessError错误。
c.否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索与校验过程。
d.如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError错误。
</code></pre><p>由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>
<p><strong>单分派与多分派</strong></p>
<p>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派与多分派两种。单分派是根据一个宗量来对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。<br>在编译期的静态分派过程选择目标方法的依据有两点：一是静态类型；二是方法参数，所以Java语言的静态分派属于多分派类型。在运行阶段虚拟机的动态分派过程只能接收者的实际类型一个宗量作为目标方法选择依据，所以Java语言的动态分派属于单分派类型。<strong>所以Java语言是一门静态多分派，动态单分派语言</strong>。</p>
<h3 id="2-3-JVM实现动态分派"><a href="#2-3-JVM实现动态分派" class="headerlink" title="2.3 JVM实现动态分派"></a>2.3 JVM实现动态分派</h3><p>动态分派在Java中被大量使用，使用频率及其高，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此JVM在类的方法区中建立虚方法表（virtual method table）来提高性能。每个类中都有一个虚方法表，表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表中该方法的地址入口和父类该方法的地址入口一样，即子类的方法入口指向父类的方法入口。如果子类重写父类的方法，那么子类的虚方法表中该方法的实际入口将会被替换为指向子类实现版本的入口地址。<br>那么虚方法表什么时候被创建？虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
<p>由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要在运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真的进行如此频繁的搜索。面对这种情况，最常用的优化手段就是在类的方法区中建立一个虚方法表(Virtual Method Table，也称vtable，与此对应，在invokeinterface执行时也会用到接口方法表，Interface Method Table，也称itable)，使用虚方法表索引来代替元数据据查找以提高性能。</p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会被替换为指向子类实现版本的地址入口。</p>
<h3 id="2-4-以例子来说明方法调用过程"><a href="#2-4-以例子来说明方法调用过程" class="headerlink" title="2.4 以例子来说明方法调用过程"></a>2.4 以例子来说明方法调用过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.louis.jvm.codeset;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * JVM 原理简单用例 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> louis </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        String name = <span class="string">"Louis"</span>;  </span><br><span class="line">        greeting(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Hello,"</span>+name);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们将Bootstrap.java 编译成Bootstrap.class 并运行这段程序的时候，在JVM复杂的运行逻辑中，会有以下几步：</p>
<blockquote>
<ol>
<li>首先JVM会先将这个Bootstrap.class 信息加载到 内存中的方法区(Method Area)中。Bootstrap.class 中包含了常量池信息，方法的定义 以及编译后的方法实现的二进制形式的机器指令，所有的线程共享一个方法区，从中读取方法定义和方法的指令集。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>接着，JVM会在Heap堆上为Bootstrap.class 创建一个Class<bootstrap>实例用来表示Bootstrap.class 的 类实例。</bootstrap></li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>JVM开始执行main方法，这时会为main方法创建一个栈帧，以表示main方法的整个执行过程（我会在后面章节中详细展开这个过程）；</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>main方法在执行的过程之中，调用了greeting静态方法，则JVM会为greeting方法创建一个栈帧，推到虚拟机栈顶（我会在后面章节中详细展开这个过程）。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>当greeting方法运行完成后，则greeting方法出栈，main方法继续运行；</li>
</ol>
</blockquote>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B11" alt="image"></p>
<p>JVM方法调用的过程是通过栈帧来实现的，那么，方法的指令是如何运行的呢？弄清楚这个之前，我们要先了解对于JVM而言，方法的结构是什么样的。</p>
<p>我们知道，class 文件是 JVM能够识别的二进制文件，其中通过特定的结构描述了每个方法的定义。</p>
<p>JVM在编译Bootstrap.java 的过程中，在将源代码编译成二进制机器码的同时，会判断其中的每一个方法的三个信息：</p>
<ul>
<li><p>1 ).  在运行时会使用到的局部变量的数量（作用是：当JVM为方法创建栈帧的时候，在栈帧中为该方法创建一个局部变量表，来存储方法指令在运算时的局部变量值）</p>
</li>
<li><p>2 ).  其机器指令执行时所需要的最大的操作数栈的大小（当JVM为方法创建栈帧的时候，在栈帧中为方法创建一个操作数栈，保证方法内指令可以完成工作）</p>
</li>
<li><p>3 ).  方法的参数的数量</p>
</li>
</ul>
<p>经过编译之后，我们可以得到main方法和greeting方法的信息如下：</p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B12" alt="image"></p>
<h2 id="3-方法的执行"><a href="#3-方法的执行" class="headerlink" title="3. 方法的执行"></a>3. 方法的执行</h2><h3 id="3-1-解释执行"><a href="#3-1-解释执行" class="headerlink" title="3.1 解释执行"></a>3.1 解释执行</h3><p>在jdk 1.0时代，Java虚拟机完全是解释执行的，随着技术的发展，现在主流的虚拟机中大都包含了即时编译器(JIT)。因此，虚拟机在执行代码过程中，到底是解释执行还是编译执行，只有它自己才能准确判断了，但是无论什么虚拟机，其原理基本符合现代经典的编译原理，如下图所示： </p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C.png" alt="image"></p>
<p>在Java中，javac编译器完成了词法分析、语法分析以及抽象语法树的过程，最终遍历语法树生成线性字节码指令流的过程，此过程发生在虚拟机外部。</p>
<h3 id="3-2-基于栈的指令集与基于寄存器的指令集"><a href="#3-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="3.2 基于栈的指令集与基于寄存器的指令集"></a>3.2 基于栈的指令集与基于寄存器的指令集</h3><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。</p>
<p>另外一种指令集架构则是基于寄存器的指令集架构，典型的应用是x86的二进制指令集，比如传统的PC以及Android的Davlik虚拟机。</p>
<p>两者之间最直接的区别是，基于栈的指令集架构不需要硬件的支持，而基于寄存器的指令集架构则完全依赖硬件，这意味基于寄存器的指令集架构执行效率更高，单可移植性差，而基于栈的指令集架构的移植性更高，但执行效率相对较慢，初次之外，相同的操作，基于栈的指令集往往需要更多的指令，比如同样执行2+3这种逻辑操作，其指令分别如下： </p>
<p>基于栈的计算流程（以Java虚拟机为例）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2  </span><br><span class="line">istore_1  </span><br><span class="line">iconst_3  </span><br><span class="line">istore_2  </span><br><span class="line">iload_1   </span><br><span class="line">iload_2   </span><br><span class="line">iadd      </span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>
<p>而基于寄存器的计算流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,2  //将eax寄存器的值设为1</span><br><span class="line">add eax,3  //使eax寄存器的值加3</span><br></pre></td></tr></table></figure>
<h3 id="3-3-基于栈的代码执行示例"><a href="#3-3-基于栈的代码执行示例" class="headerlink" title="3.3 基于栈的代码执行示例"></a>3.3 基于栈的代码执行示例</h3><p>下面我们用简单的案例来解释一下JVM代码执行的过程，代码实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> result =(i+j)*c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MainTest.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap指令查看字节码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public MainTest();</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public static int add();</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=0     //栈深度2，局部变量4个，参数0个</span><br><span class="line">         0: iconst_0  //对应result=0,0入栈</span><br><span class="line">         1: istore_0  //取出栈顶元素0，将其存放在第0个局部变量solt中</span><br><span class="line">         2: iconst_2  //对应i=2,2入栈</span><br><span class="line">         3: istore_1  //取出栈顶元素2，将其存放在第1个局部变量solt中</span><br><span class="line">         4: iconst_3  //对应 j=3，3入栈</span><br><span class="line">         5: istore_2  //取出栈顶元素3，将其存放在第2个局部变量solt中</span><br><span class="line">         6: iconst_5  //对应c=5，5入栈</span><br><span class="line">         7: istore_3  //取出栈顶元素，将其存放在第3个局部变量solt中</span><br><span class="line">         8: iload_1   //将局部变量表的第一个slot中的数值2复制到栈顶</span><br><span class="line">         9: iload_2   //将局部变量表中的第二个slot中的数值3复制到栈顶</span><br><span class="line">        10: iadd      //两个栈顶元素2,3出栈，执行相加，将结果5重新入栈</span><br><span class="line">        11: iload_3   //将局部变量表中的第三个slot中的数字5复制到栈顶</span><br><span class="line">        12: imul      //两个栈顶元素出栈5,5出栈，执行相乘，然后入栈</span><br><span class="line">        13: dup       //复制栈顶元素25，并将复制值压入栈顶.</span><br><span class="line">        14: istore_0  //取出栈顶元素25，将其存放在第0个局部变量solt中</span><br><span class="line">        15: ireturn   //将栈顶元素25返回给它的调用者</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 5: 2</span><br><span class="line">        line 6: 4</span><br><span class="line">        line 7: 6</span><br><span class="line">        line 8: 8</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: invokestatic  #2                  // Method add:()I</span><br><span class="line">         3: pop</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-继续以上面个例子来说明方法执行过程"><a href="#3-4-继续以上面个例子来说明方法执行过程" class="headerlink" title="3.4 继续以上面个例子来说明方法执行过程"></a>3.4 继续以上面个例子来说明方法执行过程</h3><h5 id="3-4-1-为main方法创建栈帧"><a href="#3-4-1-为main方法创建栈帧" class="headerlink" title="3.4.1 为main方法创建栈帧"></a>3.4.1 为main方法创建栈帧</h5><p>JVM解析main方法，发现其 局部变量的数量为 2，操作数栈的数量为1， 则会为main方法创建一个栈帧（VM Stack），并将其加入虚拟机栈中：</p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E4%B8%BAmain%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E6%A0%88%E5%B8%A7" alt="image"></p>
<h5 id="3-4-2-完成栈帧初始化"><a href="#3-4-2-完成栈帧初始化" class="headerlink" title="3.4.2 完成栈帧初始化"></a>3.4.2 完成栈帧初始化</h5><p>main栈帧创建完成后，会将栈帧push 到虚拟机栈中，现在有两步重要的事情要做：</p>
<p>a). 计算PC值。PC 是指令计数器，其内部的值决定了JVM虚拟机下一步应该执行哪一个机器指令，而机器指令存放在方法区，我们需要让PC的值指向方法区的main方法上；</p>
<p>初始化 PC = main方法在方法区指令的地址+0；</p>
<p>b). 局部变量的初始化。main方法有个入参(String[] args) ，JVM已经在main所在的栈帧的局部变量表中为其空出来了一个slot ，我们需要将 args 的引用值初始化到局部点亮表中；</p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E5%AE%8C%E6%88%90%E6%A0%88%E5%B8%A7%E5%88%9D%E5%A7%8B%E5%8C%96" alt="image"></p>
<p>接着JVM开始读取PC指向的机器指令。如上图所示，main方法的指令序列：12 10 4c 2b b8 20 12 b1 ，通过JVM虚拟机指令集规范，可以将这个指令序列解析成以下Java汇编语言:</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A41.png" alt="image"><br><img src="http://p376695fl.bkt.clouddn.com/%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A42.png" alt="image"></p>
<p>当main方法调用greeting()时， JVM会为greeting方法创建一个栈帧，用以表示对greeting方法的调用，具体栈帧信息如下：</p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E4%B8%BAgretting%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E6%A0%88%E5%B8%A7" alt="image"></p>
<p>具体的greeting方法的机器码表示的含义如下所示：</p>
<p><img src="http://p376695fl.bkt.clouddn.com/%E4%B8%BB%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E4%BB%A4.png" alt="image"></p>
<p><strong>总结：</strong></p>
<blockquote>
<p>由于JVM的指令是基于栈的，即大部分的指令的执行，都伴随着操作数的出栈和入栈。所以在学习JVM的机器指令的时候，一定要铭记一点：</p>
<p>每个机器指令的执行，对操作数栈和局部变量产生影响。</p>
</blockquote>
<p><img src="http://pc65dngt9.bkt.clouddn.com/JVM%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5" alt="image"></p>
<p><strong>机器指令的格式</strong></p>
<p><img src="http://pc65dngt9.bkt.clouddn.com/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F" alt="image"></p>
<ul>
<li><p>a).  如上图所示JVM虚拟机的操作码是由一个字节组成的，也就是说对于JVM虚拟机而言，其指令的数量最多为 2^8,即 256个;</p>
</li>
<li><p>b). 上图中的操作码如:b2,bb,59….等等都是表示某一特定的机器指令，为了方便我们识别，其分别有相应的助记符：getstatic,new,dup…. 这样方便我们理解。</p>
</li>
</ul>
<p>参考：</p>
<p><a href="http://blog.csdn.net/dd864140130/article/details/49515403" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/49515403</a></p>
<p><a href="http://blog.csdn.net/luanlouis/article/details/50412126" target="_blank" rel="noopener">http://blog.csdn.net/luanlouis/article/details/50412126</a></p>
<p>注：</p>
<ol>
<li><p>slot也称为容量槽，虚拟规范中并没有规定一个Slot应该占据多大的内存空间。 ↩</p>
</li>
<li><p>这里的严格匹配指的是字节码操作的栈中的实际元素类型必须要字节码规定的元素类型一致。比如iadd指令规定操作两个整形数据，那么在操作栈中的实际元素的时候，栈中的两个元素也必须是整形。 ↩</p>
</li>
<li>Animal dog=new Dog();其中的Animal我们称之为静态类型，而Dog称之为动态类型。两者都可以发生变化，区别在于静态类型只在使用时发生变化，变量本身的静态类型不会被改变，最终的静态类型是在编译期间可知的，而实际类型则是在运行期才可确定。 ↩</li>
<li>Animal dog=new Dog();其中的Animal我们称之为静态类型，而Dog称之为动态类型。两者都可以发生变化，区别在于静态类型只在使用时发生变化，变量本身的静态类型不会被改变，最终的静态类型是在编译期间可知的，而实际类型则是在运行期才可确定。 ↩</li>
<li>宗量：方法的接受者与方法的参数称为方法的宗量。<br>举个例子： </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatcher</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">int</span> result=<span class="keyword">this</span>.execute(<span class="number">8</span>,<span class="number">9</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> pointX,pointY)</span></span>&#123; </span><br><span class="line"><span class="comment">//TODO </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在dispatcher()方法中调用了execute(8,9)，那此时的方法接受者为当前this指向的对象，8、9为方法的参数，this对象和参数就是我们所说的宗量。</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java虚拟机/" rel="tag"># java虚拟机</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/21/十二、整合mongodb获取附近单车以及距离/" rel="next" title="十二、整合mongodb获取附近单车以及距离">
                <i class="fa fa-chevron-left"></i> 十二、整合mongodb获取附近单车以及距离
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/21/十五、骑行轨迹/" rel="prev" title="十五、骑行轨迹">
                十五、骑行轨迹 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Eureka</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">288</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">Kategorien</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">Tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-运行时候的栈结构"><span class="nav-number">1.</span> <span class="nav-text">1. 运行时候的栈结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-局部变量表"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 局部变量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-操作数栈"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 操作数栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-动态连接"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 动态连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-方法返回地址"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 方法返回地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-方法调用"><span class="nav-number">2.</span> <span class="nav-text">2. 方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-解析"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-分派"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 分派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-JVM实现动态分派"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 JVM实现动态分派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-以例子来说明方法调用过程"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 以例子来说明方法调用过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-方法的执行"><span class="nav-number">3.</span> <span class="nav-text">3. 方法的执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-解释执行"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 解释执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-基于栈的指令集与基于寄存器的指令集"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 基于栈的指令集与基于寄存器的指令集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-基于栈的代码执行示例"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 基于栈的代码执行示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-继续以上面个例子来说明方法执行过程"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 继续以上面个例子来说明方法执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-1-为main方法创建栈帧"><span class="nav-number">3.4.0.1.</span> <span class="nav-text">3.4.1 为main方法创建栈帧</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-2-完成栈帧初始化"><span class="nav-number">3.4.0.2.</span> <span class="nav-text">3.4.2 完成栈帧初始化</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eureka</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
