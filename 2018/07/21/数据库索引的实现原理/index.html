<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数据库索引的实现原理 · Eureka-Home</title><meta name="description" content="数据库索引的实现原理 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">数据库索引的实现原理</h1><div class="post-info">Jul 21, 2018</div><div class="post-content"><p>mysql最后的一篇我着重来看看索引的原理。<br><a id="more"></a></p>
<h2 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h2><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p><img src="http://my.csdn.net/uploads/201205/03/1336034967_9324.png" alt="image"></p>
<p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快<code>Col2</code>的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在<code>O(log2n)</code>的复杂度内获取到相应数据。</p>
<h2 id="2-索引的优势"><a href="#2-索引的优势" class="headerlink" title="2. 索引的优势"></a>2. 索引的优势</h2><ul>
<li>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </li>
</ul>
<h2 id="3-索引的问题"><a href="#3-索引的问题" class="headerlink" title="3. 索引的问题"></a>3. 索引的问题</h2><ul>
<li>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ul>
<h2 id="4-哪些情况适合用索引"><a href="#4-哪些情况适合用索引" class="headerlink" title="4. 哪些情况适合用索引"></a>4. 哪些情况适合用索引</h2><ul>
<li>在经常需要搜索的列上，可以加快搜索的速度；</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ul>
<h2 id="5-不应该创建索引的的这些列具有下列特点"><a href="#5-不应该创建索引的的这些列具有下列特点" class="headerlink" title="5. 不应该创建索引的的这些列具有下列特点"></a>5. 不应该创建索引的的这些列具有下列特点</h2><ul>
<li>第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>
<li>第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>
<li>第三，对于那些定义为<code>text</code>, <code>image</code>和<code>bit</code>数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li>
<li>第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>
</ul>
<h2 id="6-索引的分类"><a href="#6-索引的分类" class="headerlink" title="6. 索引的分类"></a>6. 索引的分类</h2><p><strong>惟一索引</strong></p>
<p>唯一索引是不允许其中任何两行具有相同索引值的索引。</p>
<p><strong>主键索引</strong></p>
<p>数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。</p>
<p>为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>
<p><strong>聚集索引</strong></p>
<p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p>
<p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>
<h2 id="7-局部性原理与磁盘预读"><a href="#7-局部性原理与磁盘预读" class="headerlink" title="7. 局部性原理与磁盘预读"></a>7. 局部性原理与磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此<strong>为了提高效率，要尽量减少磁盘I/O</strong>。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会<strong>预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。<strong>这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（<code>page</code>）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h2 id="8-B树-B-树"><a href="#8-B树-B-树" class="headerlink" title="8.B树/B+树"></a>8.B树/B+树</h2><p>想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是<code>B tree</code>或者 <code>B+ tree</code>，重要的事情说三遍：“<strong>平衡树，平衡树，平衡树</strong>”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。</p>
<p>我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 </p>
<p>事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。</p>
<p><strong>如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引</strong>。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。 </p>
<p><strong>这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置</strong>。</p>
<p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9521.png" alt="image"></p>
<p>上图就是带有主键的表（聚集索引）的结构图。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句：</p>
<blockquote>
<p>select * from table where id = 1256;</p>
</blockquote>
<p>首先根据索引定位到1256这个值所在的叶结点，然后再通过叶结点取到id等于1256的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图</p>
<p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%9522.jpg" alt="image"></p>
<h2 id="9-索引"><a href="#9-索引" class="headerlink" title="9. 索引"></a>9. 索引</h2><p><strong><code>MyISAM</code>引擎使用<code>B+Tree</code>作为索引结构，叶节点的<code>data</code>域存放的是数据记录的地址</strong>。因此，<code>MyISAM</code>中索引检索的算法为首先按照<code>B+Tree</code>搜索算法搜索索引，如果指定的Key存在，则取出其<code>data</code>域的值，然后以<code>data</code>域的值为地址，读取相应数据记录。</p>
<p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9523.png" alt="image"></p>
<p><code>InnoDB</code>也使用<code>B+Tree</code>作为索引结构。<code>InnoDB</code>的数据文件本身就是索引文件。<code>MyISAM</code>索引文件和数据文件是分离的，索引文件仅保存数据记录的地址（这一点可以通过在<code>data</code>目录下查看数据库文件验证。<code>Innodb</code>每一个数据库只有一个数据文件，而<code>Myisam</code>则有三个（数据文件、索引文件、表结构文件））。而在<code>InnoDB</code>中，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的<code>key</code>是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。</p>
<p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9524.png" alt="image"></p>
<p>上图是<code>InnoDB</code>主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为<code>InnoDB</code>的数据文件本身要按主键聚集，所以<code>InnoDB</code>要求表必须有主键（<code>MyISAM</code>可以没有），如果没有显式指定，则<code>MySQL</code>系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则<code>MySQL</code>自动为<code>InnoDB</code>表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形</p>
<p>第二个与<code>MyISAM</code>索引的不同是<code>InnoDB</code>的辅助索引<code>data</code>域存储相应记录主键的值而不是地址。换句话说，<code>InnoDB</code>的所有辅助索引都引用主键作为<code>data</code>域。例如，图11为定义在<code>Col3</code>上的一个辅助索引：这里以英文字符的<code>ASCII</code>码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了<code>InnoDB</code>的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在<code>InnoDB</code>中不是个好主意，因为<code>InnoDB</code>数据文件本身是一颗<code>B+Tree</code>，非单调的主键会造成在插入新记录时数据文件为了维持<code>B+Tree</code>的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/21/算法总概览/" class="prev">PREV</a><a href="/2018/07/21/电信子公司的实习/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>