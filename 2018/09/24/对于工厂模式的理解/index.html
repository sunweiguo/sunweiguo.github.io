<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 对于工厂模式的理解 · Eureka-Home</title><meta name="description" content="对于工厂模式的理解 - Eureka"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Eureka-Home"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">对于工厂模式的理解</h1><div class="post-info">Sep 24, 2018</div><div class="post-content"><p>面试常问工厂模式。<br><a id="more"></a></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>一直都没有系统地去学习设计模式，但是又是面试中常问的问题，比如问：说一说你对工厂模式的理解(vivo面试)，我的回答一般是：工厂模式类似于一个工厂去生产产品，你需要什么产品，不要自己去new，而是通过工厂来获取，达到对象的创建与使用解耦的目的。但是，总感觉是感性上的认知，所以把工厂模式拿出来再好好理理。</p>
<h2 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h2><p>传送门—&gt;<a href="http://swg_.coding.me/2018/09/24/%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">简单工厂模式介绍</a></p>
<p>定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。</p>
<p><img src="http://xiaozhao.oursnail.cn/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82UML%E5%9B%BE.jpg" alt="image"></p>
<h2 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h2><p>传送门—&gt;<a href="http://swg_.coding.me/2018/09/24/%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">工厂方法模式介绍</a></p>
<p>对于简单工厂的进一步封装，因为对于简单工厂模式而言，需要新添产品的时候，需要在工厂类中添加对应的判断和new，不符合开闭原则。</p>
<p>这里是对于每一个产品用一个单独的工厂来生产。而不是单独一个工厂统一生产所有产品。</p>
<p><img src="http://xiaozhao.oursnail.cn/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95UML.png" alt="image"></p>
<h2 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4. 抽象工厂模式"></a>4. 抽象工厂模式</h2><p>传送门—&gt;<a href="http://swg_.coding.me/2018/09/24/%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">抽象工厂模式介绍</a></p>
<p>抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。</p>
<p><img src="http://xiaozhao.oursnail.cn/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82UML.png" alt="image"></p>
<h2 id="5-对于工厂模式的一些思考"><a href="#5-对于工厂模式的一些思考" class="headerlink" title="5. 对于工厂模式的一些思考"></a>5. 对于工厂模式的一些思考</h2><ul>
<li>工厂模式是为了解耦</li>
<li>工厂模式可以降低代码重复</li>
<li>由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。</li>
</ul>
<p>有的时候觉得工厂模式没啥用，尤其是抽象工厂模式跟我们好像没啥关系。还是那句话，这些设计模式随着系统越来越大，将产生越来越深远的影响。一开始代码比较少，所以可能用new的方式处理也不算麻烦，但是随着系统越来越庞大，越来越复杂，牵一发而动全身甚至会容易产生扩展错误时，就应该好好想想，这里是不是应该用到设计模式，比如典型的工厂模式。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/10/19/navicate新建查询报错问题记录/" class="prev">PREV</a><a href="/2018/09/24/三、设计模式-抽象工厂模式/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">Eureka</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>