<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LinkedHashMap · fossi</title><meta name="description" content="LinkedHashMap - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="https://sunweiguo.github.io/tags/" target="_blank" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">LinkedHashMap</h1><div class="post-meta"><span class="post-time">Jan 20, 2019</span></div><div class="post-content"><p>大多数情况下，只要不涉及线程安全问题， Map 基本都可以使用 HashMap ，不过 HashMap 有一个问题，就是迭代 HashMap 的顺序并不是 HashMap 放置的顺序，也就是无序。 HashMap 的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的 Map。</p>
<a id="more"></a>
<div class="tip">
篇幅有点长，但是在理解了HashMap之后就比较简单了。
</div>
<p>这个时候，<code>LinkedHashMap</code>就闪亮登场了，它虽然增加了时间和空间上的开销，但是可以解决有排序需求的场景。</p>
<p>它的底层是继承于 <code>HashMap</code> 实现的，由一个<strong>双向循环链表</strong>所构成。</p>
<p><code>LinkedHashMap</code> 的排序方式有两种：</p>
<ul>
<li>根据写入顺序排序。</li>
<li>根据访问顺序排序。</li>
</ul>
<p>其中根据访问顺序排序时，每次 <code>get</code> 都会将访问的值移动到链表末尾，这样重复操作就能得到一个按照访问顺序排序的链表。</p>
<h2>一、LinkedHashMap数据结构</h2>
<p><img src="http://bloghello.oursnail.cn/collection7-1.jpg" alt="image"></p>
<p><code>LinkedHashMap</code>是通过哈希表和双向循环链表实现的，它通过维护一个双向循环链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。</p>
<p>我们可以看出，遍历所有元素只需要从header开始遍历即可，一直遍历到下一个元素是header结束。</p>
<p>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说，假设你插入的键的顺序为1、2、3、4，后来再次插入2，迭代时的顺序还是1、2、3、4，而不会因为后来插入的2变成1、3、4、2。（但其实我们可以改变它的规则，使它变成1、3、4、2）</p>
<p><code>LinkedHashMap</code>的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希表部分继承了<code>HashMap</code>，拥有了<code>HashMap</code>那一套高效的操作，所以我们要看的就是<code>LinkedHashMap</code>中链表的部分，了解它是如何来维护有序性的。</p>
<h2>二、demo示例</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap插入数据，遍历输出无序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------HashMap插入数据--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iter = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap插入数据，遍历，默认以插入顺序为序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------LinkedHashMap插入数据,按照插入顺序进行排序--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    linkedHashMap.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = linkedHashMap.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap插入数据，设置accessOrder=true实现使得其遍历顺序按照访问的顺序输出，这里先用get方法来演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------LinkedHashMap插入数据,accessOrder=true:按照访问顺序进行排序--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; linkedHashMap2 = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"apple"</span>, <span class="string">"aa"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"banana"</span>, <span class="string">"cc"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"peach"</span>, <span class="string">"dd"</span>);</span><br><span class="line"></span><br><span class="line">    linkedHashMap2.get(<span class="string">"banana"</span>);<span class="comment">//banana移动到了内部的链表末尾</span></span><br><span class="line">    linkedHashMap2.get(<span class="string">"apple"</span>);<span class="comment">//apple移动到了内部的链表末尾</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    Iterator iter2 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter2.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap的put方法在accessOrder=true的情况下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);<span class="comment">//watermelon移动到了内部的链表末尾</span></span><br><span class="line">    linkedHashMap2.put(<span class="string">"stawbarrey"</span>, <span class="string">"ee"</span>);<span class="comment">//末尾插入新元素stawbarrey</span></span><br><span class="line">    linkedHashMap2.put(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//插入新的节点 null</span></span><br><span class="line">    Iterator iter3 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter3.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----------HashMap插入数据--------</span><br><span class="line">banana=c</span><br><span class="line">apple=a</span><br><span class="line">peach=d</span><br><span class="line">watermelon=b</span><br><span class="line">----------LinkedHashMap插入数据,按照插入顺序进行排序--------</span><br><span class="line">apple=a</span><br><span class="line">watermelon=b</span><br><span class="line">banana=c</span><br><span class="line">peach=d</span><br><span class="line">----------LinkedHashMap插入数据,按照访问顺序进行排序--------</span><br><span class="line">watermelon=bb</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc<span class="comment">//banana到了末尾</span></span><br><span class="line">apple=aa<span class="comment">//apple到了末尾</span></span><br><span class="line">-----------</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc</span><br><span class="line">apple=aa</span><br><span class="line">watermelon=bb<span class="comment">//watermelon到了链表末尾</span></span><br><span class="line">stawbarrey=ee<span class="comment">//新插入的放在末尾</span></span><br><span class="line"><span class="keyword">null</span>=<span class="keyword">null</span><span class="comment">//新插入的放在末尾</span></span><br></pre></td></tr></table></figure>
<h2>三、属性</h2>
<p><code>LinkedHashMap</code>可以认为是<code>HashMap+LinkedList</code>，即它既使用<code>HashMap</code>操作数据结构，又使用<code>LinkedList</code>维护插入元素的先后顺序</p>
<h5>3.1 继承关系</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，自然<code>LinkedHashMap</code>也就继承了<code>HashMap</code>中所有非private的方法。所以它已经从 <code>HashMap</code> 那里继承了与哈希表相关的操作了，那么在<code>LinkedHashMap</code>中，它可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p>
<h5>3.2 属性介绍</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap的链表节点继承了HashMap的节点，而且每个节点都包含了前指针和后指针，所以这里可以看出它是一个双向链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认为false。当为true时，表示链表中键值对的顺序与每个键的插入顺序一致，也就是说重复插入键，也会更新顺序</span></span><br><span class="line"><span class="comment">//简单来说，为false时，就是上面所指的1、2、3、4的情况；为true时，就是1、3、4、2的情况</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<h2>五、构造方法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是调用的 <code>HashMap</code> 的构造方法:</p>
<p><code>HashMap</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//HashMap 只是定义了改方法，具体实现交给了 LinkedHashMap</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到里面有一个空的 <code>init()</code>，具体是由 <code>LinkedHashMap</code> 来实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也就是对 <code>header</code> 进行了初始化。</p>
<h2>六、添加元素</h2>
<p><img src="http://bloghello.oursnail.cn/collection7-2.jpg" alt="image"></p>
<p><code>LinkedHashMap</code>并没有重写任何<code>put</code>方法。但是其重写了构建新节点的<code>newNode()</code>方法.</p>
<p><code>newNode()</code> 会在<code>HashMap</code>的<code>putVal()</code> 方法里被调用，<code>putVal()</code> 方法会在批量插入数据<code>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</code> 或者插入单个数据<code>public V put(K key, V value)</code>时被调用。</p>
<p><code>LinkedHashMap</code>重写<code>了newNode()</code>,在每次构建新节点时，通过<code>linkNodeLast(p);</code>将新节点链接在内部双向链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`.</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将新增的节点，连接在链表的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">//集合之前是空的</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//将新节点连接在链表的尾部</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及<code>HashMap</code>专门预留给<code>LinkedHashMap</code>的<code>afterNodeAccess()</code> 、<code>afterNodeInsertion()</code> 、<code>afterNodeRemoval()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>如果你没有注意到注释的解释的话，你可能会很奇怪为什么会有三个空方法，而且有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点之后，进行一些处理，它们在<code>LinkedHashMap</code>有各自的实现。<code>LinkedHashMap</code>正是通过重写这三个方法来保证链表的插入、删除的有序性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数，新节点插入之后回调,判断是否需要删除最老插入的节点。</span></span><br><span class="line"><span class="comment">//如果实现LruCache会用到这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">//LinkedHashMap 默认返回false 则不删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap 默认返回false 则不删除节点。 </span></span><br><span class="line"><span class="comment">//返回true 代表要删除最早的节点。</span></span><br><span class="line"><span class="comment">//通常构建一个LruCache会在达到Cache的上限是返回true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>void afterNodeInsertion(boolean evict)</code>以及<code>boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code> 是构建LruCache需要的回调，在这可以忽略它们。</p>
<h2>七、删除元素</h2>
<p><code>LinkedHashMap</code>也没有重写<code>remove()</code> 方法，因为它的删除逻辑和<code>HashMap</code>并无区别。<br>
但它重写了<code>afterNodeRemoval()</code> 这个回调方法。该方法会在<code>Node&lt;K,V&gt; removeNode(int hash, Object key</code>, <code>Object value</code>,<br>
<code>boolean matchValue, boolean movable)</code> 方法中回调，<code>removeNode()</code> 会在所有涉及到删除节点的方法中被调用，上文分析过，是删除节点操作的真正执行者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在删除节点e时，同步将e从双向链表上删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">//待删除节点 p 的前置后置节点都置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果前置节点是null，则现在的头结点应该是后置节点a</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则将前置节点b的后置节点指向a</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">//同理如果后置节点时null ，则尾节点应是b</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则更新后置节点a的前置节点为b</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>八、查询元素</h2>
<p><code>LinkedHashMap</code>重写了<code>get()</code>和<code>getOrDefault()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比<code>HashMap</code>中的实现,<code>LinkedHashMap</code>只是增加了在成员变量(构造函数时赋值)<code>accessOrder</code>为true的情况下，要去回调<code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>afterNodeAccess()</code> 函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;<span class="comment">//原尾节点</span></span><br><span class="line">    <span class="comment">//如果accessOrder 是true ，且原尾节点不等于e</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">//节点e强转成双向链表节点p</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">//p现在是尾节点， 后置节点一定是null</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果p的前置节点是null，则p以前是头结点，所以更新现在的头结点是p的后置节点a</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则更新p的前直接点b的后置节点为 a</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">//如果p的后置节点不是null，则更新后置节点a的前置节点为b</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果原本p的后置节点是null，则p就是尾节点。 此时 更新last的引用为 p的前置节点b</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//原本尾节点是null  则，链表中就一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点的引用赋值成p</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">//修改modCount。</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示(注意这个图，1和6也应该是连在一起的，因为是双向循环链表，所以视为一个小错误)：</p>
<p><img src="http://hashmap.oursnail.cn/afterNodeAccess.png" alt="image"></p>
<p>说明：从图中可以看到，结点3链接到了尾结点后面。</p>
<p><strong>值得注意的是，<code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</strong></p>
<h2>九、判断元素是否存在</h2>
<p>它重写了该方法，相比<code>HashMap</code>的实现，更为高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历一遍链表，去比较有没有value相等的节点，并返回</span></span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比<code>HashMap</code>，是用两个<code>for</code>循环遍历，相对低效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>十、替换某个元素</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用dst替换src</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = dst;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://hashmap.oursnail.cn/transferLinks.png" alt="image"></p>
<h2>十二、总结</h2>
<p><code>LinkedHashMap</code>相对于<code>HashMap</code>的源码比，是很简单的。因为大树底下好乘凉。它继承了<code>HashMap</code>，仅重写了几个方法，以改变它迭代遍历时的顺序。这也是其与<code>HashMap</code>相比最大的不同。<br>
在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。</p>
<ul>
<li>
<p><code>accessOrder</code>默认是<code>false</code>，则迭代时输出的顺序是插入节点的顺序。若为<code>true</code>，则输出的顺序是按照访问节点的顺序。为<code>true</code>时，可以在这基础之上构建一个<code>LruCache</code>.</p>
</li>
<li>
<p><code>LinkedHashMap</code>并没有重写任何put方法。但是其重写了构建新节点的<code>newNode()</code>方法.在每次构建新节点时，将新节点链接在内部双向链表的尾部</p>
</li>
<li>
<p><code>accessOrder=true</code>的模式下,在<code>afterNodeAccess()</code>函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。值得注意的是，<code>afterNodeAccess()</code>函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</p>
</li>
<li>
<p><code>nextNode()</code> 就是迭代器里的<code>next()</code>方法 。该方法的实现可以看出，迭代<code>LinkedHashMap</code>，就是从内部维护的双链表的表头开始循环输出。</p>
</li>
<li>
<p>而双链表节点的顺序在<code>LinkedHashMap</code>的增、删、改、查时都会更新。以满足按照插入顺序输出，还是访问顺序输出。</p>
</li>
<li>
<p>它与<code>HashMap</code>比，还有一个小小的优化，重写了<code>containsValue()</code>方法，直接遍历内部链表去比对<code>value</code>值是否相等。</p>
</li>
</ul>
<p>整理自：</p>
<ul>
<li><a href="http://blog.csdn.net/zxt0601/article/details/77429150" target="_blank" rel="noopener">http://blog.csdn.net/zxt0601/article/details/77429150</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html</a></li>
<li><a href="http://blog.csdn.net/u013124587/article/details/52659741" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52659741</a></li>
<li><a href="http://www.cnblogs.com/leesf456/p/5248868.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/5248868.html</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2019/01/20/java-collection/8.HashMap和LinkedHashMap遍历机制/" class="prev">上一篇</a><a href="/2019/01/20/java-collection/6.HashSet/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script><script>var gitment = new Gitment({
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'b0520b7f71d5d883e029133f06c3328e3d3168e1',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">fossi</a>,苏ICP备17064972号.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>