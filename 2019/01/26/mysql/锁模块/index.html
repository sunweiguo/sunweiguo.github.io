<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 锁模块 · FourColor</title><meta name="description" content="锁模块 - FourColor"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">锁模块</h1><div class="post-meta"><span class="post-time">Jan 26, 2019</span></div><div class="post-content"><p>本章对行锁表所、共享锁排他锁进行详细说明。这是数据库锁的核心知识。</p>
<a id="more"></a>
<h2>MyISAM和InnoDB关于锁方面的区别</h2>
<p>结论：</p>
<ul>
<li>MyISAM默认使用的是表级锁，不支持行级锁</li>
<li>InnoDB默认使用的是行级锁，也支持表级锁</li>
</ul>
<p>所谓表级锁，就是锁住整张表。开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<p><strong>MyISAM在执行select的时候会产生一个表共享读锁，当进行更新等操作的时候会产生表独占写锁（排他锁）</strong>。所以：</p>
<ul>
<li>myISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但会阻塞对同一个表的写请求。</li>
<li>myISAM表的写操作，会阻塞其他用户对同一个表的读和写操作。</li>
<li>myISAM表的读、写操作之间、以及写操作之间是串行的。</li>
</ul>
<blockquote>
<p>这里的读是共享锁，也可以将其变为排他锁，语法是select … for update</p>
</blockquote>
<p>上面说完了<code>MyISAM</code>的表锁，下面要说说<code>InnoDB</code>啦。<code>InnoDB</code>支持行级锁。</p>
<p>所谓行级锁，就是锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发性也最高。</p>
<h2>SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE</h2>
<p>如果你在查询数据，然后在同一个事务里插入或者修改相关的数据，常规的 <code>select</code> 语句不会提供足够的保护。其他的事务可以修改或者删除你正在查询的行。<code>InnoDB</code> 支持两种可以提供安全机制的读取锁：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code></li>
<li><code>SELECT ... FOR UPDATE</code></li>
</ul>
<p><code>SELECT … LOCK IN SHARE MODE</code> 在读取的行上设置一个共享锁，其他的<code>session</code>可以读这些行，但在你的事务提交之前不可以修改它们。如果这些行里有被其他的还没有提交的事务修改，你的查询会等到那个事务结束之后使用最新的值。</p>
<p>索引搜索遇到的记录，<code>SELECT … FOR UPDATE</code> 会锁住行及任何关联的索引条目，和你对那些行执行 <code>update</code> 语句相同。其他的事务会被阻塞在比如执行 <code>update</code> 操作，获取共享锁，或从某些事务隔离级别读取数据等操作。</p>
<p>使用 <code>SELECT FOR UPDATE</code> 为 <code>update</code> 操作锁定行，只适用于 <code>autocommit</code> 被禁用（当使用 <code>START TRANSACTION</code> 开始事务或者设置 <code>autocommit</code> 为0时）。如果 <code>autocommit</code> 已启用，符合规范的行不会被锁定。</p>
<p>以上是对官方文档的翻译解读。</p>
<hr>
<p><code>SELECT … LOCK IN SHARE MODE</code> ：<strong>共享锁</strong>(S锁, <code>share locks</code>)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。</p>
<p>如果事务对某行数据加上共享锁之后，可进行读写操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。</p>
<p><code>SELECT … FOR UPDATE</code>：<strong>排他锁</strong>(X锁, <code>exclusive locks</code>)。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。</p>
<p>注：普通 <code>select</code> 语句默认不加锁，而<code>CUD</code>操作默认加排他锁。</p>
<ul>
<li>当前事务获取共享锁后，可以读写，其他事务是否可以进行读写操作和获取共享锁：可以读，可以获取共享锁，不可以写</li>
<li>两个事务同时获取共享锁后，是否可以进行update操作：不可以</li>
<li>当前事务获取排他锁后，其他事务是否可以进行读写操作和获取共享锁：其他事务可以读，不可以获取共享锁，不可以写</li>
<li>是否可对一条数据加多个排他锁：不可以</li>
<li>行锁和索引的关系：查询字段未加索引（主键索引、普通索引等）时，使用表锁</li>
</ul>
<blockquote>
<p>注：InnoDB行级锁基于索引实现。</p>
</blockquote>
<blockquote>
<ul>
<li>
<p>未加索引时，两种行锁情况为（使用表锁）：</p>
<ul>
<li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的共享锁，不可以获取不同行数据的排他锁</li>
<li>事务1获取某行数据排他锁，其他事务不可以获取不同行数据的共享锁、排他锁</li>
</ul>
</li>
<li>
<p>加索引后，两种行锁为（使用行锁）：</p>
<ul>
<li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的排他锁</li>
<li>事务1获取某行数据排他锁，其他事务可以获取不同行数据的共享锁、排他锁</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</li>
</ul>
<h2>总结（很重要）</h2>
<ul>
<li>MyISAM默认使用的是表级锁，不支持行级锁
<ul>
<li>执行select的时候会产生一个表共享读锁</li>
<li>当进行更新等操作的时候会产生表独占写锁（排他锁）</li>
<li>读不会阻塞其他session的读以及获取表共享读锁</li>
<li>写会阻塞其他session读和写操作</li>
<li>写与读之间是串行的</li>
</ul>
</li>
<li>InnoDB默认使用的是行级锁，也支持表级锁
<ul>
<li>InnoDB 支持两种可以提供安全机制的读取锁：SELECT … LOCK IN SHARE MODE以及SELECT … FOR UPDATE</li>
<li>SELECT … LOCK IN SHARE MODE 在读取的行上设置一个共享锁</li>
<li>SELECT … FOR UPDATE：排他锁</li>
<li>一个session对某一行上共享锁，其他的session可以读这行，也可以获取共享锁，但是不允许写，更不允许获取写锁。对于其他行，可以读写其他行数据也可以上读写锁。</li>
<li>一个session对某一行上排他锁，其他的session则不能加任何锁，包括共享锁。允许读这一行，但是不能写。允许对其他行数据进行读写以及上读写锁。</li>
<li>InnoDB中行级锁基于索引实现，所以在不加索引的时候，这两者上的其实都是表锁；加上索引之后，使用行锁。</li>
</ul>
</li>
</ul>
<div class="tip">
<p>以上的内容都是从博客：<a href="https://blog.csdn.net/u012099869/article/details/52778728" target="_blank" rel="noopener">https://blog.csdn.net/u012099869/article/details/52778728</a> 中整理而来，具体的实验也在他的博客中进行了详细的展示。</p>
</div>
<h2>MyISAM适合场景</h2>
<ul>
<li>频繁执行全表count语句(MyISAM已经用一个表保存了行数)</li>
<li>对数据进行增删改的频率不高，查询非常频繁</li>
<li>没有事务</li>
</ul>
<h2>InnoDB适合场景</h2>
<ul>
<li>数据增删改查都相当频繁</li>
<li>可靠性要求比较高，要求支持事务</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2019/01/26/mysql/关于索引失效和联合索引/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Sat Jan 26 2019 23:35:48 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'fd1b1eff6dd6efc61b2a09650840be7aaab787fd',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 <a href="http://yoursite.com">FourColor</a>, <a href="https://github.com/sunweiguo">contact with me!</a>.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>