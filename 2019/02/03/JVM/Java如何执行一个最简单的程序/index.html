<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java如何执行一个最简单的程序 · FourColor</title><meta name="description" content="Java如何执行一个最简单的程序 - FourColor"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java如何执行一个最简单的程序</h1><div class="post-meta"><span class="post-time">Feb 3, 2019</span></div><div class="post-content"><p>本篇为学习JAVA虚拟机的第一篇文章，需要之前对JVM有一定了解的基础。我们都知道，JAVA号称：一次编译多处运行。这就离不开字节码文件和虚拟机啦！那么，虚拟机到底是如何去执行一个简单的程序的呢？理解了这个，我们就可以理解java时如何做到平台无关的了。下面我们来分析分析。</p>
<a id="more"></a>
<p>首先，写一个最简单的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">5</span>;</span><br><span class="line">        i++;</span><br><span class="line">        ++j;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后的结果想必就一目了然，我们就通过这个程序来分析分析到底是怎么执行这个程序额的。</p>
<p>首先呢，java程序的执行经历编译，编译成系统能识别的文件，这里的系统对应java语言就是JVM，即JAVA虚拟机。JVM在识别之后，再去与我们真正的操作系统进行交互和处理。</p>
<p>所以，我们要执行一个.java程序，必须要先进行编译。初学者都会学习一个指令叫做<code>javac</code>：</p>
<p><img src="http://bloghello.oursnail.cn/javabasic6-1.png" alt="image"></p>
<p>我们会发现路径下面就会多一个.class文件，这就是编译之后的文件。直接点开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> var1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> var2 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> var3 = var1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> var4 = var2 + <span class="number">1</span>;</span><br><span class="line">        System.out.println(var3);</span><br><span class="line">        System.out.println(var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看第一行注释，说的是编译后的文件已经自动被<code>IDEA</code>反编译了，所以我们还能看得懂。真正的文件是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">漱壕   4 </span><br><span class="line">  	  </span><br><span class="line">     &lt;init&gt; ()V Code LineNumberTable main ([Ljava/lang/String;)V </span><br><span class="line">SourceFile 	Main.java         Main java/lang/Object java/lang/System out Ljava/io/PrintStream; java/io/PrintStream println (I)V !                    *? ?    	        	 </span><br><span class="line">      E     &lt;=??? ? ? ? ?</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其实是一堆乱码，根本看不懂。而在执行的时候，class文件是一种8位字节的二进制流文件。放在<code>sublime</code>中可以看到二进制文件（以16进制显示，在JAVA虚拟机中将来了解这各文件的含义，我们可以看到第一个单词是cafe babe，表明这是一个class字节码文件）：</p>
<p><img src="http://bloghello.oursnail.cn/javabasic6-2.png" alt="image"></p>
<p>那么我们想看看.class中的信息，还是需要反编译，这个时候可以用<code>javap</code>指令来做。如果我们对其不熟悉，可以先执行<code>javap -help</code>来了解了解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure>
<p>我们注意到，有一个<code>-c</code>是进行反汇编，那么就用它试试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;javap -c Main.class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Compiled from &quot;Main.java&quot;</span><br><span class="line">public class Main &#123;</span><br><span class="line">  public Main();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_5</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iinc          1, 1</span><br><span class="line">       7: iinc          2, 1</span><br><span class="line">      10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      13: iload_1</span><br><span class="line">      14: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      17: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: iload_2</span><br><span class="line">      21: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      24: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这反汇编出来的东西是什么呢？这是一连串的指令，其实这些是加载class文件时真正执行的java虚拟机指令。</p>
<p>我们来看看它的含义吧！</p>
<p><img src="http://bloghello.oursnail.cn/javabasic6-3.png" alt="image"></p>
<p>仔细看看，其实发现并不神秘，一个函数的执行是一个入栈出栈的过程。ok，大体了解了字节码文件是什么以及里面的指令含义之后，我们对java如何执行它已经大体清楚了。下面执行一下：</p>
<p>那么如何运行呢？</p>
<p><img src="http://bloghello.oursnail.cn/javabasic6-4.png" alt="image"></p>
<p>其实这是废话，初学java其实是<code>java Main</code>运行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;java Main</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>这个时候，class文件可以移植到任何平台上去，比如直接上传到<code>linux</code>上，只要JDK或者JRE环境类似即可，就可以直接运行了，不需要编译，也不需要关心是什么系统。这就做到了一次编译到处运行。</p>
<p>下面总结一下：</p>
<p><img src="http://bloghello.oursnail.cn/javabasic6-5.png" alt="image"></p>
<p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，JAVA语言在不同平台上运行时不需要进行重新编译，JAVA虚拟机在执行字节码的时候，把字节码转换为具体平台上的机器指令，然后各种操作系统就可以正确识别了。这就是JAVA如何执行代码和平台无关性的原因。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/02/04/java-basic/彻底理解java反射/" class="prev">PRVE</a><a href="/2019/02/02/redis/关于Redis一些重要的面试点/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Sun Feb 03 2019 11:44:31 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'fd1b1eff6dd6efc61b2a09650840be7aaab787fd',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 <a href="http://yoursite.com">FourColor</a>, <a href="https://github.com/sunweiguo">contact with me!</a>.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>