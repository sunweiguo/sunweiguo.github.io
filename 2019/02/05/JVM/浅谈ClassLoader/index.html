<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈ClassLoader · FourColor</title><meta name="description" content="浅谈ClassLoader - FourColor"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅谈ClassLoader</h1><div class="post-meta"><span class="post-time">Feb 5, 2019</span></div><div class="post-content"><p>本篇为学习JAVA虚拟机的第二篇文章，上一篇文章初步提到了class文件，以及一个最简单程序执行的指令含义，我们提到，是由JAVA虚拟机先加载这些编译好的class文件，然后再去根据解析出来的指令去转换为具体平台上的机器指令执行，但是加载这个class文件时如何加载的呢？其实就涉及比较重要的东西：ClassLoader</p>
<a id="more"></a>
<p>有一个基本认识，从编译到实例化对象的过程可以概括为以下三个阶段：</p>
<ul>
<li>编译器将<code>xxx.java</code>源文件编译为<code>xxx.class</code>字节码文件</li>
<li><code>ClassLoader</code>将字节码转换为JVM种的<code>Class&lt;xxx&gt;</code>对象</li>
<li>JVM利用<code>Class&lt;xxx&gt;</code>对象实例化为<code>xxx</code>对象</li>
</ul>
<h2>一、JVM系统结构</h2>
<p><img src="http://bloghello.oursnail.cn/jvm2-1.png" alt="image"></p>
<ul>
<li><code>ClassLoader</code>：依据特定格式，加载class文件到内存</li>
<li><code>Execution Engine</code>：对命令进行解析</li>
<li><code>Native Interface</code>：融合不同开发语言的原生库为Java所用</li>
<li><code>Runtime Data Area</code>：JVM内存空间结构模型</li>
</ul>
<p>首先通过<code>ClassLoader</code>加载符合条件的字节码文件到内存中，然后通过<code>Execution Engine</code>解析字节码指令，交由操作系统去执行。</p>
<h2>二、什么是ClassLoader</h2>
<p><code>ClassLoader</code>在java中有着非常重要的作用，它主要工作在<code>Class</code>装载的加载阶段，其主要作用是从系统外部获得<code>Class</code>二进制数据流。他是JAVA的核心组件，所有的<code>Class</code>都是由<code>ClassLoader</code>进行加载的，<code>ClassLoader</code>负责通过将<code>Class</code>文件里的二进制数据流装载进系统，然后交给JAVA虚拟机进行连接、初始化等操作。</p>
<p>简而言之，就是加载字节码文件。</p>
<p>我们翻开<code>ClassLoader</code>源码看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>它是一个抽象类，下面我们再来说具体的实现类。</p>
<p>里面比较重要的是<code>loadClass()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是根据<code>name</code>来加载字节码文件，返回<code>Class</code>实例，加载不到则抛出<code>ClassNotFoundException</code>异常。</p>
<h2>三、ClassLoader的种类</h2>
<ul>
<li>启动类加载器（<code>Bootstrap ClassLoader</code>）：由<code>C++</code>语言实现（针对<code>HotSpot</code>）,加载核心库<code>java.*</code>。</li>
</ul>
<ul>
<li>扩展类加载器（<code>Extension ClassLoader</code>）：Java编写，加载扩展库<code>javax.*</code></li>
</ul>
<p>它扫描的是哪个路径呢？</p>
<p><img src="http://bloghello.oursnail.cn/jvm2-2.png" alt="image"></p>
<p>我们看到，它负责将 <code>&lt;JAVA_HOME &gt;/lib/ext</code>或者由系统变量<code>-Djava.ext.dir</code>指定位置中的类库 加载到内存中。</p>
<ul>
<li>应用程序类加载器（<code>Application ClassLoader</code>）：Java编写，加载程序所在目录</li>
</ul>
<p><img src="http://bloghello.oursnail.cn/jvm2-3.png" alt="image"></p>
<p>它负责将 用户类路径(<code>java -classpath</code>或<code>-Djava.class.path</code>变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，看截图的最后一行，显示的是当前项目路径。</p>
<ul>
<li>自定义<code>ClassLoader</code>：自定义</li>
</ul>
<h2>四、如何自定义ClassLoader</h2>
<p>要自己实现一个<code>ClassLoader</code>，其核心涉及两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先想一下为什么是这两个类？</p>
<p>其实答案在<code>loadClass()</code>这个方法里面。如果已经熟悉双亲委派模型的同学，都会知道加载<code>Class</code>对象是先委派给父亲，看父亲是否已经加载，如果没有加载过，则从最顶层父亲开始逐层往下进行加载，这一块详细在下一篇文章中解释，我们先走马观花看看这个的核心方法长啥样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们不去重写<code>findClass(name)</code>方法，默认是直接抛出找不到的异常，所以我们要对这个方法进行重写。</p>
<p>由于字节码文件是一堆二进制流，所以需要一个方法来根据这个二进制流来定义成一个类，即<code>defineClass()</code>这个方法来实现这个功能。</p>
<p>说的比较抽象，下面来真正实践一把！</p>
<h2>五、实践自定义ClassLoader</h2>
<p>首先写一个类：Robot.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello , i am a robot!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对<code>Robot.java</code>用<code>javac</code>编译之后形成<code>Robot.class</code>文件，就要删除本项目下的这个<code>Robot.java</code>文件，要不然就会被<code>AppClassLoader</code>类加载先加载了，而无法再被我们的自定义类加载器再去加载。这个<code>Robot.class</code>文件我就直接放到桌面去了。路径为<code>C:/Users/swg/Desktop/</code>.</p>
<p>然后定义一个自定义的<code>ClassLoader</code>，按照上面的理论，只要重写<code>findClass</code>就可以指定到某个地方获取class字节码文件，此时获取的是二进制流文件，转换为字节数组，最后借用<code>defineClass</code>获取真正的<code>Class</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行加载的class文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">//自定义类加载器的名字</span></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    MyClassLoader(String path,String classLoaderName)&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于寻找类文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于加载类文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        name = path + name + <span class="string">".class"</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in  = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后测试一下能不能用自定义类加载器去加载到<code>Robot</code>对应的Class对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\swg\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"Robot"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader@677327b6</span><br><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure>
<p>好了，学习了关于<code>ClassLoader</code>的分类以及如何自定义<code>ClassLoader</code>，我们知道了类加载器的基本实现，上面谈到了一个重要方法是<code>loadClass</code>，这就涉及了类加载器的双亲委派模型。下一节从代码层面好好来说说这个，其实很简单。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/02/05/JVM/双亲委派模型/" class="prev">上一篇</a><a href="/2019/02/05/suibi/2019年展望/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Tue Feb 05 2019 14:44:35 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'fd1b1eff6dd6efc61b2a09650840be7aaab787fd',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 <a href="http://yoursite.com">FourColor</a>, <a href="https://github.com/sunweiguo">contact with me!</a>.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>