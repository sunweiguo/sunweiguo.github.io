<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 补充阅读5-Class文件中的方法表集合--method方法在class文件中是怎样组织的 · fossi</title><meta name="description" content="补充阅读5-Class文件中的方法表集合--method方法在class文件中是怎样组织的 - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">补充阅读5-Class文件中的方法表集合--method方法在class文件中是怎样组织的</h1><div class="post-meta"><span class="post-time">Feb 9, 2019</span></div><div class="post-content"><p>继续讲class文件中的方法表集合。</p>
<a id="more"></a>
<h2>1. 方法表集合概述</h2>
<p>方法表集合是指由若干个方法表（method_info）组成的集合。对于在类中定义的若干个经过JVM编译成class文件后，会将相应的method方法信息组织到一个叫做方法表集合的结构中，字段表集合是一个类数组结构，如下图所示：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9591" alt="image"></p>
<h2>2. method方法的描述-方法表集合在class文件中的位置</h2>
<p>method方法的描述-方法表集合紧跟在字段表集合的后面，如下图所示：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9592" alt="image"></p>
<h2>3. 一个类中的method方法应该包含哪些信息？----method_info结构体的定义</h2>
<p>对于一个方法的表示，我们根据我们可以概括的信息如下所示：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9593" alt="image"></p>
<p>实际上JVM还会对method方法的描述添加其他信息，我们将在后面详细讨论。如上图中的method_info结构体的定义，该结构体的定义跟描述field字段 的field_info结构体的结构几乎完全一致,如下图所示。</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9594" alt="image"></p>
<p>方法表的结构体由：访问标志(access_flags)、名称索引(name_index)、描述索引(descriptor_index)、属性表(attribute_info)集合组成。</p>
<p><strong>访问标志(access_flags)：</strong></p>
<p>method_info结构体最前面的两个字节表示的访问标志（access_flags），记录这这个方法的作用域、静态or非静态、可变性、是否可同步、是否本地方法、是否抽象等信息，实际上不止这些信息，我们后面会详细介绍访问标志这两个字节的每一位具体表示什么意思。</p>
<p><strong>名称索引(name_index)：</strong></p>
<p>紧跟在访问标志（access_flags）后面的两个字节称为名称索引，这两个字节中的值指向了常量池中的某一个常量池项，这个方法的名称以UTF-8格式的字符串存储在这个常量池项中。如public void methodName(),很显然，“methodName”则表示着这个方法的名称，那么在常量池中会有一个CONSTANT_Utf8_info格式的常量池项，里面存储着“methodName”字符串，而mehodName()方法的方法表中的名称索引则指向了这个常量池项。</p>
<p><strong>描述索引(descriptor_index)：</strong></p>
<p>描述索引表示的是这个方法的特征或者说是签名，一个方法会有若干个参数和返回值，而若干个参数的数据类型和返回值的数据类型构成了这个方法的描述，其基本格式为：     (参数数据类型描述列表)返回值数据类型   。我们将在后面继续讨论。</p>
<p><strong>属性表(attribute_info)集合：</strong></p>
<p>这个属性表集合非常重要，方法的实现被JVM编译成JVM的机器码指令，机器码指令就存放在一个Code类型的属性表中；如果方法声明要抛出异常，那么异常信息会在一个Exceptions类型的属性表中予以展现。Code类型的属性表可以说是非常复杂的内容，也是本文最难的地方。</p>
<h2>4. 访问标志(access_flags)—记录着method方法的访问信息</h2>
<p>访问标志（access_flags）共占有2 个字节，分为 16 位，这 16位 表示的含义如下所示：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9595" alt="image"></p>
<p><strong>举例：某个类中定义了如下方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>greeting()方法的修饰符有：public、static、synchronized、final 这几个修饰符修饰，那么相对应地，greeting()方法的访问标志中的ACC_PUBLIC、ACC_STATIC、ACC_SYNCHRONIZED、ACC_FINAL标志位都应该是1，即：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9596" alt="image"></p>
<p>从上图中可以看出访问标志的值应该是二进制00000000 00111001,即十六进制0x0039。我们将在文章的最后一个例子中证实这点。</p>
<h2>5. 名称索引和描述符索引----一个方法的签名</h2>
<p>紧接着访问标志（access_flags）后面的两个字节，叫做<strong>名称索引(name_index)</strong>，这两个字节中的值是指向了常量池中某个常量池项的索引，该常量池项表示这这个方法名称的字符串。</p>
<p><strong>方法描述符索引</strong>(descrptor_index)是紧跟在名称索引后面的两个字节，这两个字节中的值跟名称索引中的值性质一样，都是指向了常量池中的某个常量池项。这两个字节中的指向的常量池项，是表示了方法描述符的字符串。</p>
<p><strong>所谓的方法描述符，实质上就是指用一个什么样的字符串来描述一个方法</strong>，方法描述符的组成如下图所示：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9597" alt="image"></p>
<p>举例：对于如下定义的的greeting()方法，我们来看一下对应的method_info结构体中的名称索引和描述符索引信息是怎样组织的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示,method_info结构体的名称索引中存储了一个索引值x，指向了常量池中的第x项，第 x项表示的是字符串&quot;greeting&quot;,即表示该方法名称是&quot;greeting&quot;；描述符索引中的y 值指向了常量池的第y项，该项表示字符串&quot;()V&quot;，即表示该方法没有参数，返回值是void类型。</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9598" alt="image"></p>
<h2>6. 属性表集合–记录方法的机器指令和抛出异常等信息</h2>
<p>属性表集合记录了某个方法的一些属性信息，这些信息包括：</p>
<blockquote>
<ol>
<li>这个方法的代码实现，即方法的可执行的机器指令</li>
<li>这个方法声明的要抛出的异常信息</li>
<li>这个方法是否被@deprecated注解表示</li>
<li>这个方法是否是编译器自动生成的</li>
</ol>
</blockquote>
<p>属性表（attribute_info）结构体的一般结构如下所示：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9599" alt="image"></p>
<p><ins>修正：属性长度为4个字节。</ins></p>
<h3>6.1 Code类型的属性表–method方法中的机器指令的信息</h3>
<p>Code类型的属性表(attribute_info)可以说是class文件中最为重要的部分，因为它包含的是JVM可以运行的机器码指令，JVM能够运行这个类，就是从这个属性中取出机器码的。除了要执行的机器码，它还包含了一些其他信息，如下所示：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95910" alt="image"></p>
<p><strong>Code属性表的组成部分</strong>：</p>
<blockquote>
<p>机器指令----code：</p>
</blockquote>
<p>目前的JVM使用一个字节表示机器操作码，即对JVM底层而言，它能表示的机器操作码不多于2的 8 次方，即 256个。class文件中的机器指令部分是class文件中最重要的部分，并且非常复杂，本文的重点不止介绍它</p>
<blockquote>
<p>异常处理跳转信息—exception_table：</p>
</blockquote>
<p>如果代码中出现了try{}catch{}块，那么try{}块内的机器指令的地址范围记录下来，并且记录对应的catch{}块中的起始机器指令地址，当运行时在try块中有异常抛出的话，JVM会将catch{}块对应懂得其实机器指令地址传递给PC寄存器，从而实现指令跳转；</p>
<blockquote>
<p>Java源码行号和机器指令的对应关系—LineNumberTable属性表：</p>
</blockquote>
<p>编译器在将java源码编译成class文件时，会将源码中的语句行号跟编译好的机器指令关联起来，这样的class文件加载到内存中并运行时，如果抛出异常，JVM可以根据这个对应关系，抛出异常信息，告诉我们我们的源码的多少行有问题，方便我们定位问题。这个信息不是运行时必不可少的信息，但是默认情况下，编译器会生成这一项信息，如果你项取消这一信息，你可以使用-g:none 或-g:lines来取消或者要求设置这一项信息。如果使用了-g:none来生成class文件，class文件中将不会有LineNumberTable属性表，造成的影响就是 将来如果代码报错，将无法定位错误信息报错的行，并且如果项调试代码，将不能在此类中打断点（因为没有指定行号。）</p>
<blockquote>
<p>局部变量表描述信息----LocalVariableTable属性表：</p>
</blockquote>
<p>局部变量表信息会记录栈帧局部变量表中的变量和java源码中定义的变量之间的关系，这个信息不是运行时必须的属性，默认情况下不会生成到class文件中。你可以根据javac指令的-g:none或者-g:vars选项来取消或者设置这一项信息。<br>
它有什么作用呢？  当我们使用IDE进行开发时，最喜欢的莫过于它们的代码提示功能了。如果在项目中引用到了第三方的jar包，而第三方的包中的class文件中有无LocalVariableTable属性表的区别如下所示：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95911" alt="image"></p>
<p><strong>Code属性表结构体的解释：</strong></p>
<ol>
<li>
<p>attribute_name_index,属性名称索引，占有2个字节，其内的值指向了常量池中的某一项，该项表示字符串“Code”;</p>
</li>
<li>
<p>attribute_length,属性长度，占有 4个字节，其内的值表示后面有多少个字节是属于此Code属性表的；</p>
</li>
<li>
<p>max_stack,操作数栈深度的最大值，占有 2 个字节，在方法执行的任意时刻，操作数栈都不应该超过这个值，虚拟机的运行的时候，会根据这个值来设置该方法对应的栈帧(Stack Frame)中的操作数栈的深度；</p>
</li>
<li>
<p>max_locals,最大局部变量数目，占有 2个字节，其内的值表示局部变量表所需要的存储空间大小；</p>
</li>
<li>
<p>code_length,机器指令长度，占有 4 个字节，表示跟在其后的多少个字节表示的是机器指令；</p>
</li>
<li>
<p>code,机器指令区域，该区域占有的字节数目由 code_length中的值决定。JVM最底层的要执行的机器指令就存储在这里；</p>
</li>
<li>
<p>exception_table_length,显式异常表长度，占有2个字节，如果在方法代码中出现了try{} catch()形式的结构，该值不会为空，紧跟其后会跟着若干个exception_table结构体，以表示异常捕获情况；</p>
</li>
<li>
<p>exception_table，显式异常表，占有8 个字节，start_pc,end_pc,handler_pc中的值都表示的是PC计数器中的指令地址。exception_table表示的意思是：如果字节码从第start_pc行到第end_pc行之间出现了catch_type所描述的异常类型，那么将跳转到handler_pc行继续处理。</p>
</li>
<li>
<p>attribute_count,属性计数器，占有 2 个字节，表示Code属性表的其他属性的数目</p>
</li>
<li>
<p>attribute_info,表示Code属性表具有的属性表，它主要分为两个类型的属性表：“LineNumberTable”类型和“LocalVariableTable”类型。<br>
“LineNumberTable”类型的属性表记录着Java源码和机器指令之间的对应关系<br>
“LocalVariableTable”类型的属性表记录着局部变量描述</p>
</li>
</ol>
<p><strong>举例：</strong></p>
<p>如下定义Simple类，使用javac -g:none Simple.java 编译出Simple.class 文件，并使用javap -v Simple &gt; Simple.txt 查看反编译的信息，然后看Simple.class文件中的方法表集合是怎样组织的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>1. Simple.class文件组织信息如下所示：</h4>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95912" alt="image"></p>
<p>如上所示，方法表集合使用了蓝色线段圈了起来。<br>
请注意：方法表集合的头两个字节，即方法表计数器（method_count）的值是0x0002，它表示该类中有2 个方法。细心的读者会注意到，我们的Simple.java中就定义了一个greeting()方法，为什么class文件中会显示有两个方法呢？？</p>
<blockquote>
<p>JVM为没有显式定义实例化构造方法的类，自动生成默认的实例化构造方法&quot;<init>()&quot;</init></p>
</blockquote>
<p>除了实例化构造方法，JVM还会在特殊的情况下生成一个叫类构造方法&quot;<cinit>()&quot;。如果我们在类中使用到了static修饰的代码块，那么，JVM会在class文件中生成一个“<cinit>()”构造方法。关于它们的具体细节，我将在后续的文章中详细讨论，在这里就不展开了。</cinit></cinit></p>
<blockquote>
<ol start="2">
<li>Simple.class 中的<init>() 方法:</init></li>
</ol>
</blockquote>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95913" alt="image"></p>
<p>解释：</p>
<ol>
<li>
<p>方法访问标志(access_flags)： 占有 2个字节，值为0x0001,即标志位的第 16 位为 1，所以该<init>()方法的修饰符是：ACC_PUBLIC;</init></p>
</li>
<li>
<p>名称索引(name_index)： 占有 2 个字节，值为 0x0004，指向常量池的第 4项，该项表示字符串“<init>”，即该方法的名称是“<init>”;</init></init></p>
</li>
<li>
<p>描述符索引(descriptor_index): 占有 2 个字节，值为0x0005,指向常量池的第 5 项，该项表示字符串“()V”，即表示该方法不带参数，并且无返回值（构造函数确实也没有返回值）；</p>
</li>
<li>
<p>属性计数器（attribute_count): 占有 2 个字节，值为0x0001,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；</p>
</li>
<li>
<p>属性表的名称索引(attribute_name_index)：占有 2 个字节，值为0x0006,指向常量池中的第6 项，该项表示字符串“Code”，表示这个属性表是Code类型的属性表；</p>
</li>
<li>
<p>属性长度（attribute_length）：占有4个字节，值为0x0000 0011，即十进制的 17，表明后续的 17 个字节可以表示这个Code属性表的属性信息；</p>
</li>
<li>
<p>操作数栈的最大深度（max_stack）：占有2个字节，值为0x0001,表示栈帧中操作数栈的最大深度是1；</p>
</li>
<li>
<p>局部变量表的最大容量（max_variable）：占有2个字节，值为0x0001, JVM在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；</p>
</li>
<li>
<p>机器指令数目(code_length)：占有4个字节，值为0x0000 0005,表示后续的5 个字节 0x2A 、0xB7、 0x00、0x01、0xB1表示机器指令;</p>
</li>
<li>
<p>机器指令集(code[code_length])：这里共有  5个字节，值为0x2A 、0xB7、 0x00、0x01、0xB1；</p>
</li>
<li>
<p>显式异常表集合（exception_table_count）： 占有2 个字节，值为0x0000,表示方法中没有需要处理的异常信息；</p>
</li>
<li>
<p>Code属性表的属性表集合（attribute_count）： 占有2 个字节，值为0x0000，表示它没有其他的属性表集合，因为我们使用了-g:none 禁止编译器生成Code属性表的 LineNumberTable 和LocalVariableTable;</p>
</li>
</ol>
<blockquote>
<p>B. Simple.class 中的greeting() 方法:</p>
</blockquote>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95914" alt="image"></p>
<p>解释：</p>
<ol>
<li>
<p>方法访问标志(access_flags)： 占有 2个字节，值为 0x0039 ,即二进制的00000000 00111001,即标志位的第11、12、13、16位为1，根据上面讲的方法标志位的表示，可以得到该greeting()方法的修饰符有：ACC_SYNCHRONIZED、ACC_FINAL、ACC_STATIC、ACC_PUBLIC;</p>
</li>
<li>
<p>名称索引(name_index)： 占有 2 个字节，值为 0x0007，指向常量池的第 7 项，该项表示字符串“greeting”，即该方法的名称是“greeting”;</p>
</li>
<li>
<p>描述符索引(descriptor_index): 占有 2 个字节，值为0x0005,指向常量池的第 5 项，该项表示字符串“()V”，即表示该方法不带参数，并且无返回值；</p>
</li>
<li>
<p>属性计数器（attribute_count): 占有 2 个字节，值为0x0001,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；</p>
</li>
<li>
<p>属性表的名称索引(attribute_name_index)：占有 2 个字节，值为0x0006,指向常量池中的第6 项，该项表示字符串“Code”，表示这个属性表是Code类型的属性表；</p>
</li>
<li>
<p>属性长度（attribute_length）：占有4个字节，值为0x0000 0010，即十进制的16，表明后续的16个字节可以表示这个Code属性表的属性信息；</p>
</li>
<li>
<p>操作数栈的最大深度（max_stack）：占有2个字节，值为0x0001,表示栈帧中操作数栈的最大深度是1；</p>
</li>
<li>
<p>局部变量表的最大容量（max_variable）：占有2个字节，值为0x0001, JVM在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；</p>
</li>
<li>
<p>机器指令数目(code_length)：占有4 个字节，值为0x0000 0004,表示后续的4个字节0x10、 0x0A、 0x3B、0xB1的是表示机器指令;</p>
</li>
<li>
<p>机器指令集(code[code_length])：这里共有4 个字节，值为0x10、 0x0A、 0x3B、0xB1 ；</p>
</li>
<li>
<p>显式异常表集合（exception_table_count）： 占有2 个字节，值为0x0000,表示方法中没有需要处理的异常信息；</p>
</li>
<li>
<p>Code属性表的属性表集合（attribute_count）： 占有2 个字节，值为0x0000，表示它没有其他的属性表集合，因为我们使用了-g:none 禁止编译器生成Code属性表的 LineNumberTable 和LocalVariableTable;</p>
</li>
</ol>
<h3>6.2 Exceptions类型的属性表----method方法声明的要抛出的异常信息</h3>
<p>有些方法在定义的时候，会声明该方法会抛出什么类型的异常，如下定义一个Interface接口，它声明了sayHello()方法，抛出Exception异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们看一下Exceptions类型的属性表(attribute_info)结构体是怎样组织的：</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95915" alt="image"></p>
<p>如上图所示，Exceptions类型的属性表(attribute_info)结构体由一下元素组成：</p>
<p>属性名称索引(attribute_name_index)：占有 2个字节，其中的值指向了常量池中的表示&quot;Exceptions&quot;字符串的常量池项；</p>
<p>属性长度(attribute_length)：它比较特殊，占有4个字节，它的值表示跟在其后面多少个字节表示异常信息；</p>
<p>异常数量(number_of_exceptions)：占有2 个字节，它的值表示方法声明抛出了多少个异常，即表示跟在其后有多少个异常名称索引；</p>
<p>异常名称索引(exceptions_index_table)：占有2个字节，它的值指向了常量池中的某一项，该项是一个CONSTANT_Class_info类型的项，表示这个异常的完全限定名称；</p>
<p><strong>Exceptions类型的属性表的长度计算</strong></p>
<p>如果某个方法定义中，没有声明抛出异常，那么，表示该方法的方法表(method_info)结构体中的属性表集合中不会有Exceptions类型的属性表；换句话说，如果方法声明了要抛出的异常，方法表(method_info)结构体中的属性表集合中必然会有Exceptions类型的属性表，并且该属性表中的异常数量不小于1。<br>
我们假设异常数量中的值为 N，那么后面的异常名称索引的数量就为N，它们总共占有的字节数为N*2，而异常数量占有2个字节，那么将有下面的这个关系式：</p>
<blockquote>
<p>属性长度(attribute_length)中的值= 2  + 2*异常数量(number_of_exceptions)中的值</p>
</blockquote>
<blockquote>
<p>Exceptions类型的属性表（attribute_info）的长度=2+4+属性长度(attribute_length)中的值</p>
</blockquote>
<p><strong>举例：</strong><br>
将上面定义的Interface接口类编译成class文件，然后我们查看Interface.class文件，找出方法表集合所在位置和相应的数据，并辅助javap -v  Inerface 查看</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95916" alt="image"></p>
<p>由于sayHello()方法是在的Interface接口类中声明的，它没有被实现，所以它对应的方法表(method_info)结构体中的属性表集合中没有Code类型的属性表。</p>
<ol>
<li>
<p>方法计数器（methods_count）中的值为0x0001，表明其后的方法表(method_info)就一个,即我们就定义了一个方法，其后会紧跟着一个方法表(method_info)结构体；</p>
</li>
<li>
<p>方法的访问标志（access_flags）的值是0x0401，二进制是00000100 00000001,第6位和第16位是1，对应上面的标志位信息，可以得出它的访问标志符有：ACC_ABSTRACT、ACC_PUBLIC。细心的读者可能会发现，在上面声明的sayHello()方法中并没有声明为abstract类型啊。确实如此，这是因为编译器对于接口内声明的方法自动加上ACC_ABSTRACT标志。</p>
</li>
<li>
<p>名称索引（name_index）中的值为0x0005，0x0005指向了常量池的第5项，第五项表示的字符串为“sayHello”，即表示的方法名称是sayHello</p>
</li>
<li>
<p>描述符索引(descriptor_index)中的值为0x0006,0x0006指向了常量池中的第6项，第6项表示的字符串为“()V” 表示这个方法的无入参，返回值为void类型</p>
</li>
<li>
<p>属性表计数器(attribute_count)中的值为0x0001,表示后面的属性表的个数就1个，后面紧跟着一个attribute_info结构体；</p>
</li>
<li>
<p>属性表（attribute_info）中的属性名称索引(attribute_name_index)中的值为0x0007，0x0007指向了常量池中的第7 项，第 7项指向字符串“Exceptions”，即表示该属性表表示的异常信息；</p>
</li>
<li>
<p>属性长度（attribute_length）中的值为：0x00000004,即后续的4个字节将会被解析成属性值；</p>
</li>
<li>
<p>异常数量（number_of_exceptions）中的值为0x0001,表示这个方法声明抛出的异常个数是1个；</p>
</li>
<li>
<p>异常名称索引(exception_index_table)中的值为0x0008,指向了常量池中的第8项，第8项表示的是CONSTANT_Class_info类型的常量池项，表示“java/lang/Exception”，即表示此方法抛出了java.lang.Exception异常。</p>
</li>
</ol>
<h2>7. IDE代码提示功能实现的基本原理</h2>
<p>每个IDE都提供了代码提示功能，它们实现的基本原理其实就是IDE针对它们项目下的包中所有的class文件进行建模，解析出它们的方法信息，当我们一定的条件时，IDE会自动地将合适条件的方法列表展示给开发者，供开发者使用。</p>
<p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95917" alt="image"></p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/02/09/JVM/类的初始化过程/" class="prev">PRVE</a><a href="/2019/02/09/JVM/补充阅读4-Class文件中的字段表集合--field字段在class文件中是怎样组织的/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Sat Feb 09 2019 19:40:07 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'fd1b1eff6dd6efc61b2a09650840be7aaab787fd',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 <a href="http://yoursite.com">fossi</a>,苏ICP备17064972号.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>