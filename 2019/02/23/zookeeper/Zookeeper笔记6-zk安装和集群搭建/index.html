<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Zookeeper笔记6-zk安装和集群搭建 · fossi</title><meta name="description" content="Zookeeper笔记6-zk安装和集群搭建 - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="fossi"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Zookeeper笔记6-zk安装和集群搭建</h1><div class="post-info">Feb 23, 2019</div><div class="post-content"><p>本章会回顾一下ZAB协议，然后介绍一下集群搭建的配置文件。</p>
<a id="more"></a>
<h2>前言</h2>
<p>回顾一下<code>ZAB</code>协议。<code>Zab</code>协议包括两个核心：</p>
<p><strong>第一，原子广播</strong></p>
<p>客户端提交事务请求时<code>Leader</code>节点为每一个请求生成一个事务<code>Proposal</code>，将其发送给集群中所有的<code>Follower</code>节点，收到过半<code>Follower</code>的反馈后开始对事务进行提交。</p>
<p>这也导致了<code>Leader</code>崩溃后可能会出现数据不一致的情况，ZAB使用了崩溃恢复来处理数字不一致问题；</p>
<p>消息广播使用了TCP协议进行通讯所有保证了接受和发送事务的顺序性。广播消息时<code>Leader</code>节点为每个事务<code>Proposal</code>分配一个全局递增的<code>ZXID</code>（事务ID），每个事务<code>Proposal</code>都按照<code>ZXID</code>顺序来处理；</p>
<p><code>Leader</code>节点为每一个<code>Follower</code>节点分配一个队列按事务<code>ZXID</code>顺序放入到队列中，且根据队列的规则FIFO来进行事务的发送。</p>
<p><code>Follower</code>节点收到事务<code>Proposal</code>后会将该事务以事务日志方式写入到本地磁盘中，成功后反馈<code>Ack</code>消息给<code>Leader</code>节点。</p>
<p>收到过半<code>ACK</code>反馈之后，同时向所有的<code>Follower</code>节点广播<code>Commit</code>消息，<code>Follower</code>节点收到<code>Commit</code>后开始对事务进行提交；</p>
<p><strong>第二，Master选举</strong></p>
<p>里面用的算法叫做：<code>Fast Leader Election</code>。</p>
<ul>
<li><code>epoch</code>：选举轮数,即周期，就是之前说的逻辑时钟<code>logicClock</code></li>
<li><code>Zxid</code>: <code>Zxid</code> 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，针对客户端每一个事务请求，计数器加 1；而高 32 位则代表 <code>Leader</code> 周期 <code>epoch</code> 的编号，每个当选产生一个新的 <code>Leader</code> 服务器，就会从这个 <code>Leader</code> 服务器上取出其本地日志中最大事务的<code>ZXID</code>，并从中读取 <code>epoch</code> 值，然后加 1，以此作为新的 <code>epoch</code>，并将低 32 位从 0 开始计数。</li>
</ul>
<p><strong>成为leader的条件</strong></p>
<ul>
<li>选<code>epoch</code>最大的</li>
<li><code>epoch</code>相等，选 <code>zxid</code> 最大的</li>
<li><code>epoch</code>和<code>zxid</code>都相等，选择<code>server id</code>最大的（就是我们配置<code>zoo.cfg</code>中的<code>myid</code>）</li>
</ul>
<p><strong>选举的基本步骤</strong></p>
<ol>
<li>每个从节点都向其他节点发送选自身为<code>Leader</code>的<code>Vote</code>投票请求，等待回复；</li>
<li>从节点接受到的<code>Vote</code>如果比自身的大（ZXID更新）时则投票，并更新自身的<code>Vote</code>，否则拒绝投票；</li>
<li>每个从节点中维护着一个投票记录表，当某个节点收到过半的投票时，结束投票并把该从节点选为<code>Leader</code>，投票结束；</li>
</ol>
<p>具体一点的步骤：</p>
<ul>
<li>1、发起一轮投票选举，推举自己作为<code>leader</code>，通知所有的服务器，等待接收外部选票。</li>
<li>2、只要当前服务器状态为<code>LOOKING</code>，进入循环，不断地读取其它<code>Server</code>发来的通知、进行比较、更新自己的投票、发送自己的投票、统计投票结果，直到<code>leader</code>选出或出错退出。具体做法：
<ul>
<li>2.1 如果发送过来的逻辑时钟大于目前的逻辑时钟，那么说明这是更新的一次选举投票，此时更新本机的逻辑时钟（<code>logicalclock</code>），清空投票箱（因为已经过期没有用了）调用<code>totalOrderPredicate</code>函数判断对方的投票是否优于当前的投票（见下面代码），是的话用对方推荐的<code>leader</code>更新下一次的投票，否则使用初始的投票（投自己），调用<code>sendNotifications()</code> 通知所有服务器我的选择，跳到2.4。</li>
<li>2.2 如果对方处于上轮投票，不予理睬，回到2。</li>
<li>2.3 如果对方也处于本轮投票，调用<code>totalOrderPredicate</code>函数判断对方的投票是否优于当前的投票，是的话更新当前的投票，否则使用初始的投票（投自己）并新生成<code>notification</code>消息放入发送队列。调用<code>sendNotifications()</code> 通知所有服务器我的选择。</li>
<li>2.4 将收到的投票放入自己的投票箱中。</li>
<li>2.5 调用计票器的<code>containsQuorum</code>函数，判断所推荐的leader是否得到集群多数人的同意，如果得到多数人同意，那么还需等待一段时间，看是否有比当前更优的提议，如果没有，则认为投票结束。根据投票结果修改自己的状态。以上任何一条不满足，则继续循环。</li>
</ul>
</li>
</ul>
<p>关于<code>totalOrderPredicate</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">totalOrderPredicate</span><span class="params">(<span class="keyword">long</span> newId, <span class="keyword">long</span> newZxid, <span class="keyword">long</span> newEpoch, <span class="keyword">long</span> curId, <span class="keyword">long</span> curZxid, <span class="keyword">long</span> curEpoch)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    LOG.debug(<span class="string">"id: "</span> + newId + <span class="string">", proposed id: "</span> + curId + <span class="string">", zxid: 0x"</span> +</span><br><span class="line">    </span><br><span class="line">            Long.toHexString(newZxid) + <span class="string">", proposed zxid: 0x"</span> + Long.toHexString(curZxid));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用计票器判断当前server的权重是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(self.getQuorumVerifier().getWeight(newId) == <span class="number">0</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Epoch、zxid、id来比较两个候选leader</span></span><br><span class="line">    <span class="keyword">return</span> ((newEpoch &gt; curEpoch) ||</span><br><span class="line">    </span><br><span class="line">            ((newEpoch == curEpoch) &amp;&amp;</span><br><span class="line">    </span><br><span class="line">            ((newZxid &gt; curZxid) || ((newZxid == curZxid) &amp;&amp; (newId &gt; curId)))));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结起来就是一句话：若干个节点，第一次都是投给自己；后面就是，尽量向数据最新的节点靠拢，可以理解为：每个节点贫富有差距，富有的节点让贫穷的节点投自己一票，那么贫穷的节点会接受，反之不行，那么最先拿到超过一半的贫穷的节点的投票，就成为leader。（贫穷与富有都是相对的，越富有越可能成为leader）。</strong></p>
<h2>zk集群搭建</h2>
<p>首先准备三份解压文件，每一份中都新建一个叫<code>data</code>的文件夹：里面新建一个叫做myid的文件，第一个写1，后面递增。</p>
<p>每一份中配置文件改为<code>zoo.cfg</code>。zk1对应的zoo.cfg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick 心跳检测时间</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line"># 集群启动后，相互连接，如果在initLimit*tickTime时间内没有连接成功，那么认为连接失败</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># Masrer和slave之间或者slave和slave之间的数据同步时间，在syncLimit*tickTime是按内没有返回一个ACk，则</span><br><span class="line"># 认为该节点宕机，如果是Master宕机了，就要重新选举了</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 数据存放的目录，这是我新建的</span><br><span class="line">dataDir=D:/zookeeper1-3.4.10/data</span><br><span class="line"># dataLogDir = xx</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># 客户端连接集群的端口号</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第一个端口是数据同步的端口号  第二个端口是选举的端口号</span><br><span class="line">server.1=127.0.0.1:2887:3887</span><br><span class="line">server.2=127.0.0.1:2888:3888</span><br><span class="line">server.3=127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure>
<p>后面一次递增这个<code>clientPort</code>和<code>data</code>文件夹位置。</p>
<p>依次启动即可。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/02/23/zookeeper/Zookeeper笔记7-ZK的基本操作以及权限控制/" class="prev">PREV</a><a href="/2019/02/23/zookeeper/Zookeeper笔记5-ZAB协议/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 <a href="http://yoursite.com">fossi</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script></body></html>