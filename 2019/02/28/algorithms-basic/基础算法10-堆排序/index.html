<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 基础算法10-堆排序 · FourColor</title><meta name="description" content="基础算法10-堆排序 - FourColor"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">基础算法10-堆排序</h1><div class="post-meta"><span class="post-time">Feb 28, 2019</span></div><div class="post-content"><h2>1. 前言</h2>
<p>在学习堆排序之前，有必要把一些数据结构方面的知识理一下，要不然会有点乱。</p>
<p>首先看一下一个大的分类：</p>
<p><img src="http://bloghello.oursnail.cn/suanfa10-1.png" alt="image"></p>
<p>因此堆是一种特殊的树，并且是特殊的完全二叉树。对于堆排序中的堆通常是指二叉堆。二叉堆分为大根堆和小根堆。其中每个节点的值小于等于其左、右孩子的值，这样的堆称为小根堆；其中每个节点的值大于等于其左、右孩子的值，这样的堆称为大根堆；</p>
<p>那么理清这个关系之后，我们知道了，我们主要的研究对象是二叉堆这个数据结构。</p>
<h2>2. 二叉堆的结构</h2>
<p>回顾一下完全二叉树的定义。</p>
<blockquote>
<p>如下图，每一层都是从左向右摆放节点，每个节点都是摆满两个子节点后才向右移动到下一个节点，一层摆满后向下移动一层，直到摆放完所有数字。这样得到的二叉树就是完全二叉树，中间有任何缺失的节点就不能称为完全二叉树。</p>
</blockquote>
<p><img src="http://bloghello.oursnail.cn/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89%E5%9B%BE.png" alt="image"></p>
<p>二叉堆是一种完全二叉树，他们的区别是：</p>
<p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%8F%89%E5%A0%86%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉堆与完全二叉树"></p>
<p>二叉堆是一颗完全二叉树，完全二叉树有一个非常重要的性质：即完全二叉树只用数组而不需要指针就可以表示。优势在于数组表示的话内存是紧凑排列的，不会有太多的内存碎片，并且数组对于随机访问是很快的，基于数组下标即可。</p>
<p><img src="http://bloghello.oursnail.cn/%E5%A0%86%E7%94%A8%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA.png" alt="堆用数组表示"></p>
<h2>3. 二叉堆与优先队列</h2>
<p>什么是优先队列，队列我们是比较熟悉的，是一种先进先出的数据结构，在优先队列中，出队的顺序与入队的顺序无关了，而是与优先级有关。即优先级越高，越早出队。</p>
<p>优先队列到底有什么实际应用呢？比如一个电商网站搞特卖或抢购，用户登录下单提交后，考虑这个时间段用户访问下单提交量很大，通常表单提交到服务器后端后，后端程序一般不直接进行扣库存处理，将请求放到队列列，异步消费处理，用普通队列是FIFO的，这里有个需求是，用户会员级别高的，可以优先抢购到商品，可能这个时间段的级别较高的会员用户下单时间在普通用户之后，这个时候使用优先队列代替普通队列，基本能满足我们的需求。</p>
<p>优先队列就是依靠二叉堆来实现的。优先队列需要支持两种操作：</p>
<ul>
<li>删除最小（最大）元素</li>
<li>插入元素</li>
</ul>
<p>为什么要用堆来实现优先队列？</p>
<ul>
<li>优先队列所需要实现的两种操作，不同于队列和栈，它需要一个有序的元素序列，但不要求全部有序，只需要从这些元素中找到最大（或最小）的一个元素。而堆刚好满足这个条件。</li>
<li>队列，栈都是用数组或者链表来实现的，针对优先队列，用数组和链表实现也是可以的，在队列较小，大量使用两种操作之一时，或者所操作的元素的顺序已知时，用数组和链表十分有用，但是，在最坏的情况下，优先队列用这两张方法实现所需的时间却是线性的。而用堆在最坏情况下的时间则是对数级别。</li>
</ul>
<p>由于我们比较关注的是立即拿到最大或者最小的元素，然后高效地删除和插入。这些都依赖于堆的内部算法实现，下面我们就来看看大顶堆为例的插入和删除操作原理。</p>
<h3>4. 堆的算法</h3>
<p>我们用N+1长度的数组来表示一个大小为N的堆，我们不会使用[0],堆元素会被保存于[1]-[N-1]中。</p>
<h5>4.1 大顶堆的插入(上浮)</h5>
<p><img src="http://bloghello.oursnail.cn/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * k:当前插入元素的位置，相应地k/2就是其父结点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(k&gt;<span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">		swap(k/<span class="number">2</span>,k);</span><br><span class="line">		k = k/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5>4.2 大顶堆的删除</h5>
<p><img src="http://bloghello.oursnail.cn/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">1. 获取根结点</span><br><span class="line">2. 将根结点与最后一个结点交换</span><br><span class="line">3. 恢复堆的有序性...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显然现在看来该二叉树虽然是一个完全二叉树，但是它并不符合最大堆的相关定义，我们的目的是要在删除完成之后，该完全二叉树依然是最大堆。因此就需要我们来做一些相关的操作！</p>
</blockquote>
<p><img src="http://bloghello.oursnail.cn/%E4%B8%8B%E6%B2%89%E5%9B%9E%E5%A4%8D%E5%A0%86%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * k:当前被删除元素的位置(若删除根节点,则k=1)，相应地2*k就是其左子结点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">2</span>*k &lt; N)&#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">		<span class="keyword">if</span>(j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>))</span><br><span class="line">			j++;</span><br><span class="line">		<span class="keyword">if</span>(!less(k,j))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		swap(k,j);</span><br><span class="line">		k = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>5. 堆排</h2>
<p>在了解了堆的基本操作之后，我们将目标先转到堆排序上，这才是本章研究的重点。</p>
<p>时间复杂度为<code>O(logN)</code>，额外空间复杂度为<code>O(1)</code>;</p>
<p>我们知道，数组可以对应到一个完全二叉树。</p>
<p>堆:大根堆和小根堆。堆就是一个完全二叉树。</p>
<p>大根堆：完全二叉树中任何一个子树的最大值就是其头部节点对应的值。</p>
<p>那么，数组已经是一个完全二叉树，而下面的任务就是：将一个数组变成大根堆。</p>
<p>构建一个大根堆的复杂度是log1+log2+…+logi = O(N)</p>
<p>第一次构建完大根堆之后，还不是有序的。堆排序的主要思路是：每次将最后一个数与第一个数交换，就是完全二叉树的最后一个数与根节点进行交换。由于根节点已经是最大的数，所以我们就可以不要再管它。我们再将0~n-1下标的所有数进行调整，也调整为大顶堆，然后重复上面的动作。这样，不停地把当前大顶堆的最大数调整到后面，一直到最后，整个数组就是有序的。</p>
<p><img src="http://bloghello.oursnail.cn/suanfa10-2.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            System.out.print(anArr + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次调整为大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            heapInsert(arr,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">        <span class="comment">//第一个数与最后一个数交换，最后一个数就是最大的值，前面的数再调整为新的大顶堆</span></span><br><span class="line">        <span class="comment">//这样每次都将当前最大的数从数组的后面依次往前排，排到最后整个数组升序</span></span><br><span class="line">        swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">        <span class="keyword">while</span>(heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            heapify(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">            swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前的值是大于父节点的，就与父节点交换，使得大的数上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[index] &gt; arr[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">            swap(arr,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次将最后一个数与第一个数交换后，我们要重新构建大顶堆，主要是将当前第一个数与自己的子节点进行比较，如果小于当前的子节点，则交换；否则不变，已经是大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">        <span class="comment">//拿到当前节点的左子节点</span></span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左子节点下标不能越界</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">            <span class="comment">//在右子节点也不越界的情况下，选出左右子节点中的较大者</span></span><br><span class="line">            <span class="keyword">int</span> largest = left+<span class="number">1</span> &lt; heapSize &amp;&amp; arr[left+<span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">//当前节点与左右子节点的最大者再比较</span></span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            <span class="comment">//如果最大值就是当前节点，说明当前节点的值是大于左右两个子节点的，不需要交换，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(largest == index)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个时候说明当前节点是小于某一个子节点的，那么就要进行交换，并且更新当前节点的坐标为子节点的而坐标，再更新左子节点，做下一次循环的比较</span></span><br><span class="line">            swap(arr,largest,index);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆这个数据结构是非常重要的，因为他的动态调整的时间复杂度为logN，是非常低的。比如经典问题：快速在一串数字流中快速找到中位数等。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/02/28/algorithms-basic/基础算法9-快速排序/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Thu Feb 28 2019 15:16:36 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'fd1b1eff6dd6efc61b2a09650840be7aaab787fd',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 <a href="http://yoursite.com">FourColor</a>, <a href="https://github.com/sunweiguo">contact with me!</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>