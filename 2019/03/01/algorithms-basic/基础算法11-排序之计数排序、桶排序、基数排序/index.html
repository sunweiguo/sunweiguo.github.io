<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 基础算法11-排序之计数排序、桶排序、基数排序 · fossi</title><meta name="description" content="基础算法11-排序之计数排序、桶排序、基数排序 - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/tags" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">基础算法11-排序之计数排序、桶排序、基数排序</h1><div class="post-meta"><span class="post-time">Mar 1, 2019</span></div><div class="post-content"><p>在之前我们介绍的都是比较排序算法，在结果中各元素的次序都基于输入元素间的比较。而任何比较排序算法在最坏情况下都要用 O(NlgN) 此比较来排序。而非基于比较的排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p>
<a id="more"></a>
<h2>计数排序</h2>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<p><img src="http://bloghello.oursnail.cn/suanfa11-1.gif" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//maxVal为传入的数组的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array,<span class="keyword">int</span> maxVal)&#123;</span><br><span class="line">    <span class="comment">// 1.根据最大值可以确定辅助数组的长度</span></span><br><span class="line">    <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[maxVal+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//2.遍历array数组，统计每个元素出现的次数，记录在辅助数组对应索引处</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        helper[array[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.遍历辅助数组，覆盖原数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxVal+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (helper[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            array[index++] = i;</span><br><span class="line">            helper[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>桶排序</h2>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (<code>Bucket sort</code>)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序.</p>
<ul>
<li>找出待排序数组中的最大值<code>max</code>、最小值<code>min</code></li>
<li>我们使用动态数组 <code>ArrayList</code> 作为桶，桶里放的元素也用 <code>ArrayList</code> 存储。桶的数量为<code>(max-min)/arr.length+1</code></li>
<li>遍历数组 <code>arr</code>，计算每个元素 <code>arr[i]</code> 放的桶</li>
<li>每个桶各自排序</li>
<li>遍历桶数组，把排序好的元素放进输出数组</li>
</ul>
<p><img src="http://bloghello.oursnail.cn/suanfa11-2.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="comment">//1.确定出数组的最大值和最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        max = Math.max(arr[i],max);</span><br><span class="line">        min = Math.min(arr[i],min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据最大值和最小值确定桶的数量，并且初始化每个桶</span></span><br><span class="line">    <span class="keyword">int</span> buctetSize = (max-min)%arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;&gt;(buctetSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        bucket.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.类似于hashmap，将其元素放到对应下标的桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min)%buctetSize;</span><br><span class="line">        bucket.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对每个桶中的元素都要进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        Collections.sort(bucket.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(bucket.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.遍历所有的桶，类似于计数排序一样覆盖原数组得到有序的序列</span></span><br><span class="line">    <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = bucket.get(i).size();</span><br><span class="line">        <span class="keyword">while</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[arrIndex++] = bucket.get(i).get(index++);</span><br><span class="line">            sum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>基数排序</h2>
<p>基数排序(<code>Radix Sort</code>)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p>通过基数排序对数组{53, 3, 542, 748, 14, 214, 154, 63, 616}，它的示意图如下：</p>
<p><img src="http://bloghello.oursnail.cn/suanfa11-3.jpg" alt="image"></p>
<p>在上图中，首先将所有待比较数值统一为统一位数长度，接着从最低位开始，依次进行排序。</p>
<ul>
<li>按照个位数进行排序。</li>
<li>按照十位数进行排序。</li>
<li>按照百位数进行排序。<br>
排序后，数列就变成了一个有序序列。</li>
</ul>
<p>在理解了基本的思想之后，下面以一个简单的例子辅助理解程序思想。</p>
<p>首先我们有以下这个数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrays = &#123;<span class="number">6</span>,  <span class="number">4322</span>, <span class="number">432</span>, <span class="number">344</span>, <span class="number">55</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>现在我们有10个桶子，每个桶子下能装载arrays.length个数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="http://bloghello.oursnail.cn/suanfa11-4.jpg" alt="image"></p>
<p>第一趟分配与回收:将数组的每个个位数进行分配到不同的桶子上</p>
<p><img src="http://bloghello.oursnail.cn/suanfa11-5.jpg" alt="image"></p>
<p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{4322,432,344,55,6}</p>
<p>第二趟分配与回收:将数组的每个十位数进行分配到不同的桶子上(像6这样的数，往前边补0)</p>
<p><img src="http://bloghello.oursnail.cn/suanfa11-6.jpg" alt="image"></p>
<p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,4322,432,344,55}</p>
<p>第三趟分配与回收:将数组的每个百位数进行分配到不同的桶子上(像6、55这样的数，往前边补0)</p>
<p><img src="http://bloghello.oursnail.cn/suanfa11-7.jpg" alt="image"></p>
<p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,55,4322,344,432}</p>
<p>第四趟分配与回收:将数组的每个百位数进行分配到不同的桶子上(像6、55，344，432这样的数，往前边补0)</p>
<p><img src="http://bloghello.oursnail.cn/suanfa11-8.jpg" alt="image"></p>
<p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,55,344,432,4322}</p>
<p>理解了上面，代码也就非常容易理解了：</p>
<p>获取这个数组的最大值，这里用递归来实现一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = arr[L];</span><br><span class="line">    <span class="keyword">int</span> b = getMax(arr,L+<span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基数排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//求得数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = getMax(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大数的位数就是我们要分配的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; max / i &gt; <span class="number">0</span> ; i *= <span class="number">10</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//构造arr.length行，10列的二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//求数组每个位，如个位，十位等，根据该位的数字放到对应的二维数组里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[j]/i)%<span class="number">10</span>;</span><br><span class="line">            buckets[j][num] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一次放完之后，就要回收起来放进原来的数组中，等待下一次的重新分配</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(buckets[j][k] != <span class="number">0</span>)&#123;</span><br><span class="line">                    arr[index++] = buckets[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基数排序要理解起来并不困难，不过值得注意的是：基数排序对有负数和0的数列难以进行排序</p>
<ul>
<li>因此，往往有0和负数的数组一般我们都不用基数来进行排序</li>
</ul>
<p>基数排序的要点就两个：</p>
<ul>
<li>分配：按照元素的大小来放入不同的桶子里</li>
<li>回收：将桶子里的元素按桶子顺序重新放到数组中</li>
<li>重复…两个步骤</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2019/03/01/algorithms-basic/基础算法12-排序总结/" class="prev">PRVE</a><a href="/2019/02/28/algorithms-basic/基础算法10-堆排序/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Fri Mar 01 2019 10:46:21 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'fd1b1eff6dd6efc61b2a09650840be7aaab787fd',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 <a href="http://yoursite.com">fossi</a>,苏ICP备17064972号.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>