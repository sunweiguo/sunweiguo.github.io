<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 单例模式(上) · fossi</title><meta name="description" content="单例模式(上) - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="https://sunweiguo.github.io/tags/" target="_blank" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">单例模式(上)</h1><div class="post-meta"><span class="post-time">Mar 12, 2019</span></div><div class="post-content"><p>单例模式看似十分简单，不就是唯一性嘛！但是当单例模式遇上多线程，遇上序列化，遇上反射的时候，一切就变得有点麻烦了，因为单例不仅要在生成的时候全局唯一，也要支持序列化反序列化后的唯一，还需要抵抗住反射的攻击。分为两截文章进行探讨，本文是上篇。</p>
<a id="more"></a>
<h2>一、定义</h2>
<ul>
<li>保证一个类只有一个实例，并提供一个全局访问点</li>
<li>创建型</li>
<li>对于单例的适用场景是不必多说了</li>
<li>单例模式的优点也是很明显的了：只有一个实例，减少内存开销</li>
<li>缺点也很明显：不易扩展</li>
<li>单例的关键词：私有构造器、线程安全、延迟加载、序列化和反序列化安全、防止反射攻击</li>
</ul>
<h2>二、懒汉式</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在线程安全的问题，解决方法是：<code>synchronized</code>，但是这种排队执行，是比较慢的。下面进行优化。</p>
<h2>三、双重锁检查–禁止指令重排序</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazyDoubleCheckSingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazyDoubleCheckSingleton();<span class="comment">//2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意要用<code>volatile</code>关键字，来防止指令重排序。因为<code>instance = new LazyDoubleCheckSingleton();</code>这一步可以分为三个步骤：</p>
<ul>
<li>第一步：分配内存给对象</li>
<li>第二步：初始化对象</li>
<li>第三步：设置instance指向刚刚分配的内存地址</li>
</ul>
<p>这个时候，第二步和第三步执行顺序可能会被颠倒。</p>
<p>比如第一个线程t1，进来了，执行new，即先指向内存，但是对象还没有初始化完成，这个时候instance已经不为null，但是还没有初始化成功。</p>
<p>此时假设恰好t1时间片执行结束，t2进来了，首先判断是否为Null，因为不为null，所以直接返回这个还没有初始化好的instance，这个时候，针对这个线程t2系统就要报异常了。</p>
<p>此时，t2线程不影响t1线程继续执行，再去初始化一下对象，返回初始化好的instance.</p>
<p>加上<code>volatile</code>关键字之后，每个线程就都可以看到这个共享内存中的最新状态了，保证了内存可见性。并且禁止指令重排序，不会出现上述指令排序出现的问题。</p>
<p>用<code>volatile</code>关键字修饰的共享变量，在进行写操作的时候，将当前缓存行的数据写回到系统内存（共享内存）中，这个写回系统内存的操作会使其他线程缓存的这个变量值失效，所以他们需要去系统内存去同步数据。</p>
<p>这样，既兼顾了性能，又兼顾了线程安全。</p>
<h2>四、允许重排序–禁止其他线程看到重排序</h2>
<p>采用静态内部类的方式。原理如下。</p>
<p>假设有一个类叫A：</p>
<ul>
<li>A类实例被创建</li>
<li>A类中声明的静态方法被调用</li>
<li>A类中声明的一个静态成员被赋值</li>
<li>A类中声明的一个静态成员被使用，并且这个成员不是常量成员</li>
<li>如果A类为顶级类，并且A类中有嵌套的断言语句（不常用）</li>
</ul>
<p>根据java语言规范，其中任何一种情况首次发生，这个类就会立即被初始化。</p>
<p>那么，我们执行<code>InnerClass.instance</code>这句话的时候，就是调用了这个内部类的静态成员，所以此时这个静态内部类立即被初始化。</p>
<p><img src="http://bloghello.oursnail.cn/patten13-1.png" alt="image"></p>
<p>JVM在类的初始化阶段（class加载后，线程使用前），这个阶段会执行类的初始化，<strong>JVM会先获取一个锁</strong>，这个锁可以同步多个线程对一个类的初始化，基于这个特性，可以实现基于静态内部类的延迟加载、线程安全的方案。</p>
<p>那么，由于存在一把初始化锁，只能有一个线程执行初始化，即使静态内部类中存在重排序，也不会有任何问题，因为其他线程压根看不到，进不来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassLazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassLazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassLazySingleton instance = <span class="keyword">new</span> StaticInnerClassLazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取这个单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassLazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>五、饿汉式</h2>
<p>类加载的时候就完成了初始化，没有延迟加载(final static修饰的变量会在JVM准备阶段就完全确定了)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将初始化对象放到静态块中，达到一样的效果。</p>
<h2>六、序列化和反序列化破坏单例模式及解决</h2>
<p>用上一个饿汉来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//获取单例对象</span></span><br><span class="line">    HungrySingleton instance = HungrySingleton.getGetInstance();</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singletonFile"</span>));</span><br><span class="line">    oos.writeObject(instance);</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"singletonFile"</span>);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">//获取反序列化后的对象</span></span><br><span class="line">    HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    System.out.println(instance);</span><br><span class="line">    System.out.println(newInstance);</span><br><span class="line">    System.out.println(instance == newInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@568db2f2</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>反序列化后就破坏了单例。<font color="red">原因是在<code>ObjectInputStream</code>中，有段逻辑判断这个类是不是<code>implements Serializable</code>，是的话就用反射构建的对象，是新的实例。</font></p>
<p>此时如果将<code>HungrySingleton</code>改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新增一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>为什么呢？在上面反序列化的反射过程中生成了一个新的对象obj之后，下面还有一个判断：</p>
<p><img src="http://bloghello.oursnail.cn/pattern13-2.png" alt="image"></p>
<p>这里<code>hasReadResolveMethod</code>这个方法，具体如下：</p>
<p><img src="http://bloghello.oursnail.cn/pattern13-3.png" alt="image"></p>
<p>就是说，加入这个类实现了序列化接口，并且有<code>readResolve()</code>这个方法，就返回true.</p>
<p>就会执行下面的<code>desc.invokeReadResolve(obj)</code>这句，这句其实就是利用反射去调用<code>HungrySingleton</code>类中的<code>readResolve()</code>方法，拿到了原来里面的对象实例。所以就解决了这个问题。</p>
<p>未完待续…</p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/03/12/design-pattern/单例模式(下)/" class="prev">上一篇</a><a href="/2019/03/12/剑指offer/【面试题45-扑克牌顺子】/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
    id: 'Tue Mar 12 2019 13:51:21 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'b0520b7f71d5d883e029133f06c3328e3d3168e1',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">fossi</a>,苏ICP备17064972号.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>