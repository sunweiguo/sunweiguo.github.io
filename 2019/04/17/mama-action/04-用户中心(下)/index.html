<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 04-用户中心(下) · fossi</title><meta name="description" content="04-用户中心(下) - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="https://sunweiguo.github.io/tags/" target="_blank" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">04-用户中心(下)</h1><div class="post-meta"><span class="post-time">Apr 17, 2019</span></div><div class="post-content"><p>用户的注册和登陆是一个系统最基本的功能，在单系统中，用户的session管理是非常简单的，但是延申到分布式系统中的时候，就不一样了，需要做一个分布式session的管理。在注册这一块，用了Curator封装的分布式锁来控制用户登陆可能出现的用户名重复等问题。</p>
<h2>用户登陆问题</h2>
<p>分库分表如果按照业务字段（手机号码或者邮箱或者其他），耦合性太强，不好扩展。</p>
<p><strong>这里是直接按照全局唯一的UUID</strong>【<ins>基于twitter开源的snowflake算法，但是snowflake算法的缺陷（强依赖时间，如果时钟回拨，就会生成重复的ID</ins>）】<strong>来进行划分的</strong>，有利于系统的扩展。但是，我这里比如按照邮箱登陆，如何确定去哪一张表中去查询呢？</p>
<p>解决方案：<ins>需要建立一个映射表（关系），可以再系统启动时预先加载到redis中去，首先根据email找到对应的UUID，然后再根据这个UUID来查询。</ins></p>
<p>登陆因为要记录用户session，这里直接用spring session+redis来管理:</p>
<p>第一步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span> <span class="comment">//(maxInactiveIntervalInSeconds = 604800)//session超时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpSessionStrategy <span class="title">httpSessionStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> HeaderHttpSessionStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisConnectionFactory connectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line"></span><br><span class="line">        String redisHost = parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> redisPort = Integer.valueOf(parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        connectionFactory.setTimeout(<span class="number">2000</span>);</span><br><span class="line">        connectionFactory.setHostName(redisHost);</span><br><span class="line">        connectionFactory.setPort(redisPort);</span><br><span class="line"><span class="comment">//        connectionFactory.setPassword(parameters.getRedisAuth());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，这样子其实就配置好了，一开始我也云里雾里的，这是啥玩意？</p>
<p>ok，来spring session的官网(<a href="https://spring.io/projects/spring-session" target="_blank" rel="noopener">https://spring.io/projects/spring-session</a>)来看看把，我们来看看1.3.4GA版本的文档(<a href="https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest</a>).</p>
<p>spring session可以存在很多介质中，比如我们的数据源，比如redis，甚至是mongodb等。但是我们常用的是存在redis中，结合redis的过期机制来做。</p>
<p>所以其实我们只要关心如何跟redis整合，以及restful接口。</p>
<p><img src="http://bloghello.oursnail.cn/mama4-1.png" alt="image"></p>
<p>那么我们就来看看文档吧！</p>
<p><img src="http://bloghello.oursnail.cn/mama4-2.png" alt="image"></p>
<p>好了，我们知道了它的基本原理，下面来看看是如何在restful接口中实现用户session的管理的：</p>
<p><img src="http://bloghello.oursnail.cn/mama4-3.png" alt="image"></p>
<p>也就是说要想在restful接口应用中用这种方式，直接告诉spring session:<code>return new HeaderHttpSessionStrategy();</code>即可。进入源码我们就会知道，它默认给这个header里面放置的一条类似于token的名字是<code>private String headerName = &quot;x-auth-token&quot;;</code>。</p>
<p>那么在用户登陆成功之后，到底存到是什么呢，先来看看响应数据的header里面是什么：</p>
<p><img src="http://bloghello.oursnail.cn/mama4-4.png" alt="image"></p>
<p>这一串数字正好可以跟redis中对应上，我们可以先来redis中看看到底在里面存储了啥玩意：</p>
<p><img src="http://bloghello.oursnail.cn/mama4-5.png" alt="image"></p>
<p>我们已经看到了想要看到的一串字符串，这里解释一下redis中存储的东西：</p>
<ul>
<li>spring:session是默认的Redis HttpSession前缀（redis中，我们常用’:’作为分割符）</li>
<li>每一个session都会有三个相关的key，第一个key(spring:session:sessions:37…)最为重要，它是一个HASH数据结构，将内存中的session信息序列化到了redis中。如本项目中用户信息,还有一些meta信息，如创建时间，最后访问时间等。</li>
<li>另外两个key，一个是<code>spring:session:expiration</code>，还有一个是<code>spring:session:sessions:expires</code>，前者是一个SET类型，后者是一个STRING类型，可能会有读者发出这样的疑问，redis自身就有过期时间的设置方式TTL，为什么要额外添加两个key来维持session过期的特性呢？redis清除过期key的行为是一个异步行为且是一个低优先级的行为，用文档中的原话来说便是，可能会导致session不被清除。于是引入了专门的expiresKey，来专门负责session的清除，包括我们自己在使用redis时也需要关注这一点。</li>
</ul>
<p>这样子，就可以用独立的redis来存储用户的信息，通过前端传来的header里面的token，就可以到redis拿出当前登陆用户的信息了。</p>
<p>OK，在解决了spring session的问题之后，下面就可以来实现登陆啦：</p>
<p>controller:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult <span class="title">login</span><span class="params">(@RequestBody @Valid User user, HttpSession session)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;UserElement&gt; result = <span class="keyword">new</span> ApiResult&lt;&gt;(Constants.RESP_STATUS_OK,<span class="string">"登录成功"</span>);</span><br><span class="line"></span><br><span class="line">    UserElement ue= userService.login(user);</span><br><span class="line">    <span class="keyword">if</span>(ue != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(Constants.REQUEST_USER_SESSION) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            session.setAttribute(Constants.REQUEST_USER_SESSION,ue);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setData(ue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就跟以前一样，将session直接存进去就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserElement <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    UserElement ue = <span class="keyword">null</span>;</span><br><span class="line">    User userExist = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">    <span class="keyword">if</span>(userExist != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//对密码与数据库密码进行校验</span></span><br><span class="line">        <span class="keyword">boolean</span> result = passwordEncoder.matches(user.getPassword(),userExist.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"密码错误"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//校验全部通过，登陆通过</span></span><br><span class="line">            ue = <span class="keyword">new</span> UserElement();</span><br><span class="line">            ue.setUserId(userExist.getId());</span><br><span class="line">            ue.setEmail(userExist.getEmail());</span><br><span class="line">            ue.setNickname(userExist.getNickname());</span><br><span class="line">            ue.setUuid(userExist.getUuid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>用户注册问题</h2>
<p>从技术角度出发，注册一个网站，再高并发的时候，有可能出现用户名重复这样的问题（虽然一般情况下不会出现这种问题），如何解决呢？</p>
<p>从数据库角度，对于单表，我可以用<code>select .. for update</code>悲观锁实现，或者用version这种乐观锁的思想。</p>
<p>更好的方法是将这个字段添加唯一索引，用数据库来保证不会重复。一旦插入重复，那么就会抛出异常，程序就可以捕获到。</p>
<p>但是，我们这里分表了，以上都是针对单表，第一种方案是锁表，不行，设置唯一索引是没有用。怎么办呢？</p>
<p>解决方案：用ZK做一个分布式锁。</p>
<p>首先准备一个ZK客户端，用的是Curator来连接我们的ZK：</p>
<p>具体啥意思，再ZK专题学习中已经详细描述过了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">getZkClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        CuratorFrameworkFactory.Builder builder= CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(parameters.getZkHost())</span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">        CuratorFramework framework = builder.build();</span><br><span class="line">        framework.start();</span><br><span class="line">        <span class="keyword">return</span> framework;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册用一个分布式锁来控制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    InterProcessLock lock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock = <span class="keyword">new</span> InterProcessMutex(zkClient, Constants.USER_REGISTER_DISTRIBUTE_LOCK_PATH);</span><br><span class="line">        <span class="keyword">boolean</span> retry = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">3000</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                <span class="comment">//查询重复用户</span></span><br><span class="line">                User repeatedUser = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">                <span class="keyword">if</span>(repeatedUser!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> MamaBuyException(<span class="string">"用户邮箱重复"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line">                user.setNickname(<span class="string">"码码购用户"</span>+user.getEmail());</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">                <span class="comment">//跳出循环</span></span><br><span class="line">                retry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可以适当休息一会...也可以设置重复次数，不要无限循环</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (retry);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">"用户注册异常"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span>  e;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lock != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">                log.info(user.getEmail()+Thread.currentThread().getName()+<span class="string">"释放锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路非常简单，就是先尝试上锁，即<code>acquire</code>，但是有可能失败，所以这里用一个超时时间，即<code>3000ms</code>之内上不了锁就失败，进入下一次循环。最后释放锁即可。</p>
<p>ok，这里要来说说ZK实现分布式锁了。这里用了开源客户端<code>Curator</code>，他对于实现分布式锁进行了封装，但是，我还是想了解一下它的实现原理：</p>
<p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p>
<p>也就是说，最小的那个节点就是Leader，进来判断是不是为那个节点，是的话就可以获取到锁，反之不行。</p>
<blockquote>
<p>为什么不能通过大家一起创建节点，如果谁成功了就算获取到了锁。 多个client创建一个同名的节点，如果节点谁创建成功那么表示获取到了锁，创建失败表示没有获取到锁。</p>
</blockquote>
<p>答：使用临时顺序节点可以保证获得锁的公平性，及谁先来谁就先得到锁，这种方式是随机获取锁，会造成无序和饥饿。</p>
<p>controller层：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult <span class="title">register</span> <span class="params">(@RequestBody @Valid User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    userService.registerUser(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"注册成功"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2019/04/17/mama-action/05-交易工程(上)/" class="prev">上一篇</a><a href="/2019/04/17/mama-action/03-用户中心(上)/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://www.wenjunjiang.win/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Wed Apr 17 2019 10:40:21 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'b0520b7f71d5d883e029133f06c3328e3d3168e1',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">fossi</a>,苏ICP备17064972号.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>