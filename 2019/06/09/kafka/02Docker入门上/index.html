<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Docker入门上 · fossi</title><meta name="description" content="Docker入门上 - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="https://sunweiguo.github.io/tags/" target="_blank" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Docker入门上</h1><div class="post-meta"><span class="post-time">Jun 9, 2019</span></div><div class="post-content"><p><img src="http://bloghello.oursnail.cn/kafka2-2.jpg" alt=""></p>
<p>很久之前就想玩一下docker，借学习kafka的机会，决定顺便将docker玩一下，即后续将kafka以docker的形式跑起来进行学习。由于docker也涉及一些基本的概念和入门的操作，需要提前熟悉一下。</p>
<a id="more"></a>
<h2>一、痛点问题</h2>
<p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p>
<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p>
<p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：“在我的机器可以跑啊”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>
<p>其实早就有所谓的解决方案，比如虚拟机。</p>
<h2>二、虚拟机VS容器技术</h2>
<p>虚拟机（virtual machine）就是带环境安装的一种解决方案。我们用的传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-3.jpg" alt=""></p>
<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>
<p><strong>（1）资源占用多</strong></p>
<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>
<p><strong>（2）冗余步骤多</strong></p>
<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>
<p><strong>（3）启动慢</strong></p>
<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>
<p>而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机 操作系统中，在用户空间以分离的进程运行。</p>
<p>简单来说： **容器不是模拟一个完整的操作系统，而是对进程进行隔离。**或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p><font color="red">容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</font></p>
<p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-4.jpg" alt=""></p>
<p>我们可以看到，容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<h2>三、Docker的优势</h2>
<p><img src="http://bloghello.oursnail.cn/kafka2-5.jpg" alt=""></p>
<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h2>四、Docker中的几个基本概念</h2>
<p>Docker 中包括三个基本的概念：</p>
<ul>
<li>Image（镜像）</li>
<li>Container（容器）</li>
<li>Repository（仓库）</li>
</ul>
<p>Docker 容器通过 Docker 镜像来创建，<strong>容器与镜像的关系类似于面向对象编程中的对象与类</strong>。仓库是存放镜像的场所，可见镜像更是 Docker 的核心。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名词</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Docker 镜像(Images)</td>
<td style="text-align:center">Docker 镜像是用于创建 Docker 容器的模板。</td>
</tr>
<tr>
<td style="text-align:center">Docker 容器(Container)</td>
<td style="text-align:center">容器是独立运行的一个或一组应用。</td>
</tr>
<tr>
<td style="text-align:center">Docker 客户端(Client)</td>
<td style="text-align:center">Docker 客户端通过命令行或者其他工具使用 Docker API与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td style="text-align:center">Docker 主机(Host)</td>
<td style="text-align:center">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td style="text-align:center">Docker 仓库(Registry)</td>
<td style="text-align:center">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td>
</tr>
<tr>
<td style="text-align:center">Docker Machine</td>
<td style="text-align:center">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker。</td>
</tr>
</tbody>
</table>
<h5>4.1 Image（镜像）</h5>
<p>我们知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，镜像（Image）就是一堆只读层（read-only layer）的统一视角，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-6.jpg" alt=""></p>
<p>从图中左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其他层都会有一个指针指向下一层。这些层是 Docker 内部的实现细节，并且能够在主机的文件系统上访问到。</p>
<p>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角。</p>
<p>这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p>
<h5>4.2 Container（容器）</h5>
<p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器（Container）的定义和镜像（Image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-7.jpg" alt=""></p>
<p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://yeasy.gitbooks.io/docker_practice/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h5>4.3 Repository（仓库）</h5>
<p>Docker 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行。</p>
<p>但是， 如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry（仓库注册服务器）就是这样的服务。</p>
<p>有时候会把仓库（Repository）和仓库注册服务器（Registry）混为一谈，并不严格区分。</p>
<p>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p>
<p>实际上，<strong>一个 Docker Registry 中可以包含多个仓库（Repository），每个仓库可以包含多个标签（Tag），每个标签对应着一个镜像。</strong></p>
<p>所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。</p>
<p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 Latest 作为默认标签。</p>
<p>仓库又可以分为两种形式：</p>
<ul>
<li>Public（公有仓库）</li>
<li>Private（私有仓库）</li>
</ul>
<p>Docker Registry 公有仓库是开放给用户使用、允许用户管理镜像的 Registry 服务。</p>
<p>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p>
<p>当用户创建了自己的镜像之后就可以使用 Push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 Pull 下来就可以了。</p>
<p>三者的关系可以用如下图来表示：</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-8.jpg" alt=""></p>
<p>其中，图中的Docker daemon到底是个什么东东呢？</p>
<p>Docker Daemon 是服务器组件，以 Linux 后台服务的方式运行，是 Docker 最核心的后台进程，我们也把它称为守护进程。</p>
<p>它负责响应来自 Docker Client 的请求，然后将这些请求翻译成系统调用完成容器管理操作。</p>
<p>该进程会在后台启动一个 API Server ，负责接收由 Docker Client 发送的请求，接收到的请求将通过 Docker Daemon 内部的一个路由分发调度，由具体的函数来执行请求。</p>
<p>默认配置下，Docker Daemon 只能响应来自本地 Host 的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开 TCP 监听。</p>
<p>Docker 使用 C/S 结构，即客户端/服务器体系结构。Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像，默认情况下 Docker 会在 Docker 中央仓库寻找镜像文件。更加清晰一点的docker架构为：</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-9.jpg" alt=""></p>
<p>Docker Registry 是存储 Docker Image 的仓库，它在 Docker 生态环境中的位置如下图所示：</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-10.jpg" alt=""></p>
<p>运行 docker push、docker pull、docker search 时，实际上是通过 Docker Daemon 与 Docker Registry 通信。</p>
<p>以上是docker的基础架构介绍，下面要进行实战一波了。</p>
<h2>五、小试牛刀</h2>
<p>环境准备：</p>
<ul>
<li>阿里云服务器（1 核 2G，1M 带宽）</li>
<li>CentOS 7.3 64 位</li>
</ul>
<p>Docker CE 的安装请参考官方文档：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">Centos</a></p>
<p>第一步—卸载掉旧版本的 Docker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<p>第二步—安装依赖包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
<p>Use the following command to set up the <strong>stable</strong> repository.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>第三步—安装最新CE版本的Docker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<p>当然也可以指定安装的版本，先列出所有的可用版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable</span><br></pre></td></tr></table></figure>
<p>然后就可用指定安装的版本了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>
<p>比如<code>docker-ce-18.09.1</code></p>
<p>第四步—确认Docker是否成功正确安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker version</span><br></pre></td></tr></table></figure>
<p><img src="http://bloghello.oursnail.cn/kafka2-11.jpg" alt=""></p>
<p>第五步—启动Docker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>第六步—可以执行一个demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>这个命令会去下载一个测试镜像并且在容器中启动它。当他跑起来的时候就会打印一句话：<code>Hello from Docker</code></p>
<p><img src="http://bloghello.oursnail.cn/kafka2-12.jpg" alt=""></p>
<p>如上图所示，整个容器启动过程如下：</p>
<ul>
<li>Docker 客户端执行 docker run 命令。</li>
<li>Docker Daemon 发现本地没有 hello-world 镜像。</li>
<li>Daemon 从 Docker Hub 下载镜像。</li>
<li>下载完成，镜像 hello-world 被保存到本地。</li>
<li>Docker Daemon 启动容器。</li>
</ul>
<p>我们可以通过<code>docker images</code>查看到 hello-world 已经下载到本地：</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-14.jpg" alt=""></p>
<p>输出这段提示以后，hello world 就会停止运行，容器自动终止。有些容器不会自动终止，因为提供的是服务，比如 MySQL 镜像等。</p>
<p>Docker 提供了一套简单实用的命令来创建和更新镜像，我们可以通过网络直接下载一个已经创建好了的应用镜像，并通过 Docker RUN 命令就可以直接使用。</p>
<p>当镜像通过 RUN 命令运行成功后，这个运行的镜像就是一个 Docker 容器啦。</p>
<p>容器可以理解为一个轻量级的沙箱，Docker 利用容器来运行和隔离应用，容器是可以被启动、停止、删除的，这并不会影响 Docker 镜像。</p>
<p><img src="http://bloghello.oursnail.cn/kafka2-13.jpg" alt=""></p>
<p>Docker 客户端是 Docker 用户与 Docker 交互的主要方式。当您使用 Docker 命令行运行命令时，Docker 客户端将这些命令发送给服务器端，服务端将执行这些命令。</p>
<p>Docker 命令使用 Docker API 。Docker 客户端可以与多个服务端进行通信。</p>
<p>我们再回过头来看看Docker Image。Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p>
<p><strong>镜像不包含任何动态数据，其内容在构建之后也不会被改变。我们可将 Docker 镜像看成只读模板，通过它可以创建 Docker 容器。</strong></p>
<p>镜像有多种生成方法：</p>
<ul>
<li>从无到有开始创建镜像</li>
<li>下载并使用别人创建好的现成的镜像</li>
<li>在现有镜像上创建新的镜像</li>
</ul>
<p>我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作 Dockerfile ，通过执行 <code>docker build &lt;docker-file&gt;</code>命令可以构建出 Docker 镜像。  下一篇继续说明 Dockerfile 以及客户端常用命令。</p>
<p>参考：</p>
<ul>
<li><a href="https://juejin.im/entry/5beacface51d4507a717765f" target="_blank" rel="noopener">这可能是最为详细的Docker入门总结</a></li>
<li><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener"> Docker 教程</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/basic_concept/repository.html" target="_blank" rel="noopener">Docker-从入门到实践</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2019/06/13/kafka/03windows下kafka的基本使用/" class="prev">PRVE</a><a href="/2019/06/08/kafka/01kafka入门/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Sun Jun 09 2019 21:48:55 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'fd1b1eff6dd6efc61b2a09650840be7aaab787fd',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 <a href="http://yoursite.com">fossi</a>,苏ICP备17064972号.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>