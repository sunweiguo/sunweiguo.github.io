<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> SpringTask的基本使用 · fossi</title><meta name="description" content="SpringTask的基本使用 - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="https://sunweiguo.github.io/tags/" target="_blank" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">SpringTask的基本使用</h1><div class="post-meta"><span class="post-time">Aug 10, 2019</span></div><div class="post-content"><p>工作中经常会用到定时任务，有的用<code>linux</code>的<code>crontab</code>来实现系统级别的定时调用，当然这种只能调用脚本，不能在我们的程序中实现高度灵活的配置。定时任务的实现有很多，我之前也做过一些笔记，因为在分布式应用中，定时需要小心处理，否则会很容易地出现数据错乱，因此出现了很多适用于分布式场景定时器。当然分布式不在本文讨论范围，这里只想聊聊简单的单机应用，而且是最简单的<code>Spring Task</code>。</p>
<img src="http://bloghello.oursnail.cn/suibi4-1.png" width="300">
<a id="more"></a>
<h2>一、基本使用</h2>
<p>使用起来十分简单，在ssm的工程中不需要额外引入其他的依赖即可使用。因为已经在<code>Spring-Context</code>中集成。</p>
<p><img src="http://bloghello.oursnail.cn/suibi4-2.png" alt="image"></p>
<p>第一步是配置文件中开启定时任务的注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入spring task定时任务--&gt;</span><br><span class="line">&lt;task:annotation-driven/&gt;</span><br></pre></td></tr></table></figure>
<p>在头部引入相应的DTD约束文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task=&quot;http://www.springframework.org/schema/task&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/task</span><br><span class="line">http://www.springframework.org/schema/task/spring-task-3.0.xsd</span><br></pre></td></tr></table></figure>
<p>配置方面就结束了。</p>
<p>下面写一个定时任务吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔一分钟从数据库读取一下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 0/1 * * * ? "</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIntervalFromDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一分钟执行一次~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这里的<code>cron</code>表达式，相信大家都知道了，按照一定的匹配规则即可实现比较复杂的定时场景。当然，可以使用可视化的页面来配置：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p>
<h2>二、另一种实现：Timer</h2>
<p>在这个最简单的应用中，就是实现每隔几分钟来做一些事情的简单场景，还可以使用JDK自带的<code>Timer</code>来实现。下面给出一个最简单的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// scheduledExecutionTime() 返回此任务最近开始执行的时间</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="keyword">this</span>.scheduledExecutionTime());</span><br><span class="line">        System.out.println(<span class="string">"timeTask run "</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从现在开始每间隔 1000 ms 计划执行一个任务</span></span><br><span class="line">timer.schedule(timerTask, <span class="number">0</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><code>Timer</code> 可以按计划执行重复的任务或者定时执行指定任务，这是因为 <code>Timer</code> 内部利用了一个后台线程 <code>TimerThread</code> 有计划地执行指定任务。</p>
<ul>
<li><code>Timer</code>：是一个实用工具类，该类用来调度一个线程(<code>schedule a thread</code>)，使它可以在将来某一时刻执行。 <code>Java</code> 的 <code>Timer</code> 类可以调度一个任务运行一次或定期循环运行。 <code>Timer tasks should complete quickly.</code> 即定时器中的操作要尽可能花费短的时间。</li>
<li><code>TimerTask</code>：一个抽象类，它实现了 <code>Runnable</code> 接口。我们需要扩展该类以便创建自己的 <code>TimerTask</code> ，这个 <code>TimerTask</code> 可以被 <code>Timer</code> 调度。</li>
</ul>
<p>内部的实现原理还是有点意思的，后面有时间来扒一扒它的实现原理。既然Timer这么简单为什么我不用呢？当然了，在这里我觉得<code>Spring Task</code>更简单。</p>
<h2>三、Timer存在的问题</h2>
<p>有一个显著问题是：<code>Timer</code>在执行定时任务时只会创建一个线程，所以如果存在多个任务（task1和task2），且任务时间过长，超过了两个任务的间隔时间，那么就不再那么准时了。因为只有一个线程，线程需要排队，前面一个线程未及时执行完毕，势必会影响后续的任务执行。</p>
<p>第二个问题是：如果<code>TimerTask</code>抛出<code>RuntimeException</code>，<code>Timer</code>会停止所有任务的运行。</p>
<p>如果不引入Spring如何解决上述问题呢？这个时候<code>ScheduledExecutorService</code>闪亮登场，利用线程池来调度任务，不会出现一个任务延迟导致第二个任务无法准时执行的问题，并且在<code>ScheduledExecutorService</code>调度两个任务的时候，其中一个任务抛出异常不影响第二个任务的正常执行。</p>
<p>具体的对比可以参见文章<a href="https://blog.csdn.net/lmj623565791/article/details/27109467" target="_blank" rel="noopener">Java 并发专题 ： Timer的缺陷 用ScheduledExecutorService替代</a></p>
<p>因此，尽量避免使用<code>Timer</code>要成为我们的共识啦。优秀的那么多，何必用这个呢？</p>
<p>当然，还有开源的定时器可以使用，功能更加强大，整合也不难。比如<code>quartz</code>和为分布式而生的<code>Elastic-Job</code>。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/08/05/kafka/03linux下玩kafka/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Sat Aug 10 2019 12:34:16 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'fd1b1eff6dd6efc61b2a09650840be7aaab787fd',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 <a href="http://yoursite.com">fossi</a>,苏ICP备17064972号.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>