<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 05kafka消费者-上 · fossi</title><meta name="description" content="05kafka消费者-上 - fossi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="https://sunweiguo.github.io/tags/" target="_blank" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="http://bloghello.oursnail.cn/test.html" target="_blank" class="nav-list-link">爱情</a></li><li class="nav-list-item"><a href="https://github.com/sunweiguo" target="_blank" class="nav-list-link">GIT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">05kafka消费者-上</h1><div class="post-meta"><span class="post-time">Sep 1, 2019</span></div><div class="post-content"><p><img src="http://bloghello.oursnail.cn/kafka1-15.jpg" alt="image"></p>
<p>学习完生产者，下面自然就是消费者。消费者要学习的内容比生产者要多，本篇主要聚焦于消费者/消费组的基本概念以及客户端的基本开发（包括如何订阅主题和分区、如何消费消息）。</p>
<a id="more"></a>
<h2>一、消费者和消费组</h2>
<p>在学习消费者消费消息之前，需要先了解消费者和消费组的关系。</p>
<p>消费者负责订阅<code>kafka</code>的主题，并且可以从订阅的主题上拉取消息。与其他一些消息中间件不同的是：在<code>kafka</code>的消费理念中还有一层消费组的概念，每个消费者都有一个对应的消费组。<strong>当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者</strong>。</p>
<p>消费者以组的名义订阅主题，主题有多个分区，消费者组中有多个消费者实例，那么消费者实例和分区之间的对应关系是怎样的呢？</p>
<p>换句话说，就是组中的每一个消费者负责那些分区，这个分配关系是如何确定的呢？如下图示例：</p>
<p><img src="http://bloghello.oursnail.cn/kafka6-1.png" alt="image"></p>
<p>这是<code>kafka</code>的默认规则，分配结果为消费组A的每个消费者分到两个分区，消费组B每一个消费者分到一个分区，两个消费组之间互不影响。</p>
<p>也就是说：消费者组订阅这个主题，意味着主题下的所有分区都会被组中的消费者消费到，如果按照从属关系来说的话就是，主题下的每个分区只从属于组中的一个消费者，不可能出现组中的两个消费者负责同一个分区。</p>
<p>话说回来，假设一个消费组内多个消费者负责同一个分区，那么会有什么问题呢？</p>
<p>我们知道，<code>Kafka</code>它在设计的时候就是要保证分区下消息的顺序，也就是说消息在一个分区中的顺序是怎样的，那么消费者在消费的时候看到的就是什么样的顺序，那么要做到这一点就首先要保证消息是由消费者主动拉取的（<code>pull</code>），其次还要保证一个分区只能由一个消费者负责。</p>
<p>倘若，一个消费组内两个消费者负责同一个分区，那么就意味着两个消费者同时读取分区的消息，会造成两个问题：</p>
<ul>
<li>重复消息处理：<code>C1</code>才读到2，<code>C1</code>还没处理完，<code>C2</code>又可能去读2去处理，则会造成很多浪费，因为这就相当于多线程读取同一个消息，会造成消息处理的重复</li>
<li>不能保证消息顺序：一个线程在处理1，还没处理完，另一个线程已经处理到3，此时1处理完了，那么消费的处理顺序就不对了</li>
</ul>
<p>下面我们看看当消费组内的消费者个数变化时对应的分区分配演变如下：（默认的<code>RangeAssinor</code>为例）</p>
<p><img src="http://bloghello.oursnail.cn/kafka6-2.png" alt="image"></p>
<p>我们可以看到，当增加消费者的时候，每个消费者分到的分区就会动态地减少，可以利用这个消费者-消费组模型来扩展消费能力。但是我们不能一味地增加消费者，如果消费者过多，出现了消费者个数大于分区个数的情况，就会有消费者分配不到任何分区。</p>
<p><img src="http://bloghello.oursnail.cn/kafka6-3.png" alt="image"></p>
<p>此外，<code>kafka</code>同时支持两种消息投递模式也是得益于消费者与消费组模型：点对点(<code>P2P</code>)模式和发布/订阅(<code>Pub</code>/<code>Sub</code>)模式。</p>
<p>简单介绍一下点对点模式：基于队列，消息生产者发送消息到队列，消息消费者从队列中接收消息。</p>
<p>下面简单介绍一下发布订阅模式：定义了如何向一个内容节点发布和订阅消息，这个内容节点成为主题，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息。主题使得消息的订阅者和发布者互相保持独立，不需要进行接触可保证消息的传递，发布订阅模式在消息的一对多广播时采用。</p>
<p>前面说了，<code>kafka</code>支持这两种模式：</p>
<ul>
<li>⭐<strong>如果所有消费者都隶属于同一个消费组</strong>，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，相当于点对点模式</li>
<li>⭐<strong>如果所有的消费者都隶属于不同的消费组</strong>，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，相当于发布/订阅模式的应用</li>
</ul>
<p>每一个消费者只隶属于一个消费组。消息发送时可指定消费者组， 消费者客户端通过<code>group.id</code>配置消费者组名称，默认为空字符串。</p>
<h2>二、消费者客户端开发</h2>
<p>注意<code>KafkaConsumer</code>是非线程安全的，以下为一个简单的消费者客户端的代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">"topic-demo"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String groupId = <span class="string">"group.demo"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean isRunning = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">        props.put(<span class="string">"group.id"</span>, groupId);</span><br><span class="line">        props.put(<span class="string">"client.id"</span>, <span class="string">"consumer.client.id.demo"</span>);</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = initConfig();</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">                        consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">                <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"topic = "</span> + record.topic()</span><br><span class="line">                            + <span class="string">", partition = "</span> + record.partition()</span><br><span class="line">                            + <span class="string">", offset = "</span> + record.offset());</span><br><span class="line">                    System.out.println(<span class="string">"key = "</span> + record.key()</span><br><span class="line">                            + <span class="string">", value = "</span> + record.value());</span><br><span class="line">                    <span class="comment">//do something to process record.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"occur exception "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Kafka</code>的消费逻辑</p>
<ul>
<li>配置消费者客户端参数及创建相应消费者实例</li>
<li>订阅主题</li>
<li>拉取消息并消费</li>
<li>提交消费位移（后面会讲）</li>
<li>关闭消费者实例</li>
</ul>
<p>以上的一些参数配置跟生产者端很类似，这里多一个<code>group.id</code>和<code>client.id</code>两个参数。前者为消费组，后者为标识客户端的<code>id</code>，如果不设置则默认生成一个非空字符串，内容形式如：<code>consumer-1</code>、<code>consumer-2</code>等。</p>
<h2>三、订阅主题和分区</h2>
<p>消费者可以订阅一个或多个主题，上述示例用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br></pre></td></tr></table></figure>
<p>来订阅了一个主题。如果前后两次订阅了不同的主题，那么消费者以最后一次的为准。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(topic1);</span><br><span class="line">consumer.subscribe(topic2);</span><br></pre></td></tr></table></figure>
<p>那么消费者最终订阅的是<code>topic2</code>，而不是<code>topic1</code>，也不是<code>topic1</code>和<code>topic2</code>的并集。</p>
<p>还可以用正则表达式的方式订阅，形如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Pattern.compile(<span class="string">"topic-.*"</span>));</span><br></pre></td></tr></table></figure>
<p>消费者不仅可以通过<code>KafkaConsumer.subscribe()</code>的方法订阅主题，还可以直接订阅某些主题的特定分区，在<code>KafkaConsumer</code>中提供了<code>assign()</code>方法来实现这些功能。此方法的具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法只接收一个参数<code>partitions</code>，用来指定需要订阅的分区集合。这个<code>TopicPartition</code>类定义的部分内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartition</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tipic;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TopicPartition</code>类中只有两个属性，分别代表分区所属的主题和自身的分区编号，这个类可以和我们通常说的主题-分区的概念映射起来。</p>
<p>具体的使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.assign(Arrays.asList(<span class="keyword">new</span> TopicPartition(<span class="string">"topic-demo"</span>,<span class="number">0</span>)));</span><br></pre></td></tr></table></figure>
<p>可能会有疑问：如果我们事先不知道主题中有多少个分区怎么办？<code>KafkaConsumer</code>中的<code>partitionsFor()</code>方法可以用来查询指定主题的元数据信息，<code>partitionsFor()</code>方法具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PartitionInfo&gt; <span class="title">partitionsFor</span><span class="params">(String topic)</span></span></span><br></pre></td></tr></table></figure>
<p><code>PartitionInfo</code>类型即为主题的分区元数据信息，此类的主要结构为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionInfo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;<span class="comment">//主题名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;<span class="comment">//分区编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> node leader;<span class="comment">//leader副本所在的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> node[] replicas;<span class="comment">//AR集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> node[] inSyncReplicas;<span class="comment">//ISR集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> node[] offlineReplicas;<span class="comment">//OSR集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过<code>partitionsFor()</code>方法可以订阅主题全部分区的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;PartitionInfo&gt; partitionInfos = consumer.partitionsFor(topic);</span><br><span class="line"><span class="keyword">if</span> (partitionInfos != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(PartitionInfo tpInfo : partitionInfos)&#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> TopicPartition(tpInfo.topic,tpInfo.partition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer.assign(partitions);</span><br></pre></td></tr></table></figure>
<p>上面介绍了三种订阅的方式：集合订阅的方式<code>subscribe(Collection)</code>、正则表达式订阅方式<code>subscribe(Pattern)</code>、<br>
指定分区的订阅方式<code>assign(Collection)</code>，分别代表了三种不同的订阅状态：<code>AUTO_TOPICS</code>、<code>AUTO_PATTERN</code>和<code>USER_ASSIGNED</code>（如果没有订阅则状态为<code>NONE</code>）。<strong>这三种状态是互斥的</strong>，在一个消费者中只能使用其中的一种，否则会报出<code>IllegalStateException</code>异常。</p>
<p>他们之间还有一个区别：<strong><code>subscribe</code>订阅主题时具有自动再平衡（后面会讲）的功能</strong>，在多个消费者的情况下可以根据分区策略来自动分配各个消费者与分区的关系，当消费组内的消费者增加或减少时，分区分配关系会自动调整，以实现消费负载均衡及故障自动转移；而<code>assign</code>不具备消费者自动均衡的功能。从源码可以看到<code>subscribe()</code>重载方法里有一个参数类型为<code>ConsumerRebalanceListener</code>，这个是用来设置相应的再均衡监听器的，后面还会再次说明。</p>
<h2>四、消息消费</h2>
<p><code>kafka</code>中的消费是基于拉模式的。</p>
<p>消息的消费一般有两种模式：推模式和拉模式。推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来拉取消息。</p>
<p>我们从第二节的代码可以看到，<code>kafka</code>的消息消费是一个不断轮询的过程，消费者所要做的就是重复调用<code>poll</code>方法，而<code>poll</code>方法返回的是订阅的主题或分区上的一组消息。</p>
<p>对于<code>poll</code>而言，如果某些分区中没有可供消费的消息，那么此分区对应的消息拉取的结果就为空；如果所有分区都没有可供消费的消息，那么<code>poll</code>返回空的消息集合。</p>
<p><code>poll()</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(Duration timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>timeout</code>参数是超时时间参数，用来控制<code>poll</code>的阻塞时间，在消费者的缓冲区中没有可用数据时会发生阻塞。注意参数类型为<code>Duration</code>，他是JDK8中新增的一个与时间有关的类型。可用利用<code>Duration</code>中的<code>ofMillis()</code>、<code>ofSeconds()</code>、<code>ofMinutes()</code>、<code>ofHours</code>等多种不同的方法指定不同的时间单位，灵活性更强。老的方式是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>明显时间单位只能用固定的毫秒，因此被标注为了<code>@Deprecated</code>，推荐用新的方式。</p>
<p><code>timeout</code>的设置取决于应用程序对响应速度的要求，比如需要在多长时间内将控制权移交给执行轮询的应用线程。可以直接将<code>timeout</code>设置为0，这样<code>poll</code>方法就会立刻返回，而不管是否已经拉取到消息。</p>
<p>再看在第二节一开始示例的代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(<span class="string">"topic = "</span> + record.topic()</span><br><span class="line">                + <span class="string">", partition = "</span> + record.partition()</span><br><span class="line">                + <span class="string">", offset = "</span> + record.offset());</span><br><span class="line">        System.out.println(<span class="string">"key = "</span> + record.key()</span><br><span class="line">                + <span class="string">", value = "</span> + record.value());</span><br><span class="line">        <span class="comment">//do something to process record.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实它是将订阅的主题中所有的消息都收到了，<strong>那么我们能不能以分区的维度进行消费呢</strong>？这一点很有用，在手动提交位移时尤为明显。关于提交位移下一节再详述。<code>ConsumerRecords</code>类提供了一个<code>records(TopicPartition)</code>方法来获取消息集中指定分区的消息，此方法的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ConsumerRecord&lt;K,V&gt;&gt; records(TopicPartition partition)</span><br></pre></td></tr></table></figure>
<p>下面为按照分区的维度对消息进行消费代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span>(TopicPartition tp : records.partitions())&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records.records(tp)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"partition = "</span> + record.partition()</span><br><span class="line">                + <span class="string">", value = "</span> + record.value());</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>records.partitions()</code>用来获取消息集中所有分区。<strong>那我们能不能以主题的维度进行消费呢</strong>？<code>ConsumerRecords</code>提供了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;ConsumerRecord&lt;K,V&gt;&gt; records(String topic)</span><br></pre></td></tr></table></figure>
<p>下面为按照主题的维度对消息进行消费代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; topicList = Arrays.asList(topic1,topic2);</span><br><span class="line">consumer.subscribe(Arrays.asList(topicList));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">                consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span>(String topic : topicList)&#123;</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records.records(topic)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"partition = "</span> + record.partition()</span><br><span class="line">                    + <span class="string">", value = "</span> + record.value());</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，可以简单认为<code>poll</code>方法只是拉取一下消息而已，不过内部逻辑并不简单，它涉及消费位移、消费者协调器、组协调器、消费者的选举、分区分配的分发、再均衡的逻辑、心跳等内容。下面的文章再去继续探讨。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/09/22/kafka/06kafka消费者中/" class="prev">PRVE</a><a href="/2019/08/27/kafka/04kafka生产者/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://www.wenjunjiang.win/js/gitment.js"></script><script>var gitment = new Gitment({
    id: 'Sun Sep 01 2019 19:32:53 GMT+0800',
    owner: 'sunweiguo',
    repo: 'sunweiguo.github.io',
    oauth: {
        client_id: '56c422eddebac740f021',
        client_secret: 'b0520b7f71d5d883e029133f06c3328e3d3168e1',
    },
})
gitment.render('container')</script><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">fossi</a>,苏ICP备17064972号.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-134836068-1",'auto');ga('send','pageview');</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>