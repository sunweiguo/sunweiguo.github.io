<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-19T13:13:43.114Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础之泛型下</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8B/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之泛型下/</id>
    <published>2019-02-19T13:12:22.961Z</published>
    <updated>2019-02-19T13:13:43.114Z</updated>
    
    <content type="html"><![CDATA[<p>本节继续讨论泛型相关的知识。</p><a id="more"></a><h2>6、泛型上下边界</h2><p>我们再来讨论讨论通配符。</p><p>通配符有2种：</p><ul><li>无边界通配符，用<code>&lt;?&gt;</code>表示。</li><li>有边界通配符，用<code>&lt;? extends Object&gt;</code>或者<code>&lt;? super Object&gt;</code>来表示。（<code>Object</code>仅仅是一个示例）</li></ul><h5>6.1 无边界</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 合法</span></span><br><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;?&gt;(); <span class="comment">// 不合法</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;?&gt;(); <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><p>对于带有通配符的引用变量，是不能调用具有与泛型参数有关的方法的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(1); // 编译不通过</span><br><span class="line">list.get(0); // 编译通过</span><br><span class="line">int size = list.size(); // 由于size()方法中不含泛型参数，所以可以在通配符变量中调用</span><br></pre></td></tr></table></figure><p>总结起来，无边界通配符主要用做引用，可以调用与泛型参数无关的方法，不能调用参数中包含泛型参数的方法。</p><h5>6.2 有边界</h5><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><ul><li>上边界通配，用&lt;? extends 类型&gt;表示。其语法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends 类型<span class="number">1</span>&gt; x = <span class="keyword">new</span> ArrayList&lt;类型<span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure><p>其中，类型2就只能是类型1或者是类型1的子类。下面代码验证合法性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; x = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//由于Integer是Number的子类，这是合法的</span></span><br><span class="line">List&lt;? extends Number&gt; x = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//由于String不是Number的子类，这是不合法的</span></span><br></pre></td></tr></table></figure><ul><li>下边界通配，用&lt;? super 类型&gt;表示。其语法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> 类型<span class="number">1</span>&gt; x = <span class="keyword">new</span> ArrayList&lt;类型<span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure><p>其中，类型2就只能是类型1或者是类型1的超类。下面代码有验证合法性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> ArrayList&lt;Number&gt;(); <span class="comment">//由于Number是Integer的超类，这是合法的</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//由于String不是Integer的超类，这是不合法的</span></span><br></pre></td></tr></table></figure><p>那么到底什么时候使用下边界通配，什么时候使用上边界通配呢？首先考虑一下怎样才能保证不会发生运行时异常，这是泛型要解决的首要问题，通过前面的内容可以看到，任何可能导致类型转换异常的操作都无法编译通过。</p><ul><li>⭐上边界通配：可以保证存放的实际对象至多是上边界指定的类型，那么在读取对象时，我们总是可以放心地将对象赋予上边界类型的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">List&lt;? extends Number&gt; list2 = list1;</span><br><span class="line">Number a = list2.get(<span class="number">0</span>); <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><ul><li>⭐下边界通配：可以保证存放的实际对象至少是下边界指定的类型，那么在存入对象时，我们总是可以放心地将下边界类型的对象存入泛型对象中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list3.add(<span class="number">1</span>);</span><br><span class="line">list3.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p></blockquote><ul><li>如果你想从一个数据类型里获取数据，使用 ? extends 通配符。</li><li>如果你想把对象写入一个数据结构里，使用 ? super 通配符。</li><li>如果你既想存，又想取，那就别用通配符。</li></ul><p>对于泛型方法添加上下边界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>7、泛型的原理</h2><h5>7.1 类型擦除</h5><p><font color="#ff0000">Java中的泛型是通过类型擦除来实现的</font>。<strong>所谓类型擦除，是指通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。</strong></p><p>下面通过两个例子来证明在编译时确实发生了类型擦除。</p><p>例1分别创建实际类型为<code>String</code>和<code>Integer</code>的<code>ArrayList</code>对象，通过<code>getClass()</code>方法获取两个实例的类，最后判断这个实例的类是相等的，证明两个实例共享同一个类。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-1.png" alt="image"></p><p>例2创建一个只能存储<code>Integer</code>的<code>ArrayList</code>对象，在<code>add</code>一个整型数值后，利用反射调用<code>add(Object o)</code> <code>add</code>一个<code>asd</code>字符串，此时运行代码不会报错，运行结果会打印出1和asd两个值。这时再里利用反射调用<code>add(Integer o)</code>方法，运行会抛出<code>codeNoSuchMethodException</code>异常。这充分证明了在编译后，擦除了<code>Integer</code>这个泛型信息，只保留了原始类型。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-2.png" alt="image"></p><h5>7.2 自动类型转换</h5><p>上一节上说到了类型擦除，Java编译器会擦除掉泛型信息。那么调用<code>ArrayList</code>的<code>get()</code>最终返回的必然会是一个<code>Object</code>对象，但是我们在源代码并没有写过<code>Object</code>转成<code>Integer</code>的代码，为什么就能“直接”将取出来的对象赋予一个<code>Integer</code>类型的变量呢（如下面的代码第12行）？</p><p><img src="http://bloghello.oursnail.cn/javabasic11-3.png" alt="image"></p><p><font color="#ff0000">实际上，Java的泛型除了类型擦除之外，还会自动生成<code>checkcast</code>指令进行强制类型转换</font>。上面的代码中的main方法编译后所对应的字节码如下。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-4.png" alt="image"></p><p>看到第26行代码就是将<code>Object</code>类型的对象强制转换为<code>Integer</code>的指令。我们完全可以将上面的代码转换为下面的代码，它所实现的效果跟上面的泛型是一模一样的。既然泛型也需要进行强制转换，所以泛型并不会提供运行时效率，不过可以大大降低编程时的出错概率。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-5.png" alt="image"></p><h2>8、简单总结</h2><h3>8.1 类型擦除(Type Erasure)</h3><ul><li>Java 的泛型是在编译器层次实现的。</li><li>在编译生成的字节码中不包含泛型中的类型参数，类型参数会在编译时去掉。</li><li>例如：<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在编译后都变成 <code>List</code>。</li><li>类型擦除的基本过程：将代码中的类型参数替换为具体的类，同时去掉 <code>&lt;&gt;</code> 的内容。</li></ul><h3>8.2 泛型的优势</h3><ul><li>编译时更强大的类型检测。</li></ul><p>例如如下代码：方法传入一个<code>String</code>对象，传出一个<code>String</code> 对象，并强制转换为<code>Integer</code>对象。这段代码编译可以通过，因为都是<code>Object</code>的子类，但是运行时会产生<code>ClassCastException</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-6.png" alt="image"></p><p>而如果通过泛型来实现，则会在编译时进行类型的检测。例如如下代码：会产生编译错误。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-7.png" alt="image"></p><ul><li>提供自动和隐式的类型转换</li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-8.png" alt="image"></p><h3>8.3 <code>&lt;T&gt;</code> VS <code>&lt;?&gt;</code></h3><p>不同点：</p><ul><li><code>&lt;T&gt;</code>用于泛型的定义，例如<code>class MyGeneric&lt;T&gt; {...}</code></li><li><code>&lt;?&gt;</code>用于泛型的声明，即泛型的使用，例如<code>MyGeneric&lt;?&gt; g = new MyGeneric&lt;&gt;()</code>;</li></ul><p>相同点：都可以指定上界和下界:</p><p><img src="http://bloghello.oursnail.cn/javabasic11-9.png" alt="image"></p><h3>8.4 <code>&lt;?&gt;</code>不同于<code>&lt;Object&gt;</code></h3><ul><li>指定未知类型，如<code>List&lt;?&gt;</code>。<code>List&lt;?&gt;</code>不等于<code>List&lt;Object&gt;</code></li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-10.png" alt="image"></p><p><code>String</code>是<code>Object</code>的子类，但是<code>List&lt;String&gt;</code>不是<code>List&lt;Object&gt;</code>的子类。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-11.png" alt="image"></p><p>如果将<code>List&lt;Object&gt;</code>换成<code>List&lt;?&gt;</code>，则可以编译通过。</p><p>注意：</p><ul><li>相同参数类型的泛型类的继承关系取决于泛型类自身的继承结构。<br>例如<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code>的子类</li><li>当类型声明中使用通配符<code>?</code>时，其子类型可以在两个维度上扩展。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如 Collection&lt;? extends Number&gt;</span><br><span class="line">在维度<span class="number">1</span>上扩展：List&lt;? extends Number&gt;</span><br><span class="line">在维度<span class="number">2</span>上扩展：Collection&lt;Integer&gt;</span><br></pre></td></tr></table></figure><h2>9、Java泛型中<code>List</code>、<code>List&lt;Object&gt;</code>、<code>List&lt;?&gt;</code>的区别</h2><ul><li><code>List</code>：原生态类型</li><li><code>List&lt;Object&gt;</code>：参数化的类型，表明<code>List</code>中可以<strong>容纳任意类型的对象</strong></li><li><code>List&lt;?&gt;</code>：无限定通配符类型，表示<strong>只能包含某一种未知对象类型</strong></li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-12.png" alt="image"></p><p>我们创建了一个<code>List&lt;String&gt;</code>类型的对象<code>strings</code>，再把它赋给原生态类型<code>List</code>，这是可以的。但是第5行中尝试把它传递给<code>List&lt;Object&gt;</code>时，出现了一个类型不相容错误，注意，这是一个编译期错误。</p><p>这是因为泛型有子类型化的规则：</p><p><code>List&lt;String&gt;</code>是原生态类型<code>List</code>的一个子类型。虽然<code>String</code>是<code>Object</code>的子类型，但是由于泛型是不可协变的，<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，所以这里的传递无法通过编译。</p><p><code>List&lt;Object&gt;</code>唯一特殊的地方只是<code>Object</code>是所有类型的超类，由于泛型的不可协变性，它只能表示<code>List</code>中可以容纳所有类型的对象，却不能表示任何参数类型的<code>List&lt;E&gt;</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-13.png" alt="image"></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">sss</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>List&lt;Object&gt;</code>:表示可用装载任意类型的对象，如上面最后一个例子，但是他不能接受<code>List&lt;String&gt;</code>的替换，因为不具有继承性，并且<code>List&lt;Object&gt;</code>如果可以被<code>List&lt;String&gt;</code>，就不符合原则了，因为<code>List&lt;String&gt;</code>只能接受String类型的对象。</li><li><code>List&lt;?&gt;</code>:解决上面表面有继承关系的List的赋值问题，还有就是，他是用作声明能接收一种未知对象类型，而不是大杂烩啥都能接收。</li><li><code>List</code>：原始类型，啥都没有限制。个人认为与<code>List&lt;Object&gt;</code>类似，但是又没有继承的限制。即啥类型都可以接收。</li></ul><h2>10、参考</h2><ul><li><a href="http://hinylover.space/2016/06/25/relearn-java-generic-1/" target="_blank" rel="noopener">http://hinylover.space/2016/06/25/relearn-java-generic-1/</a></li><li><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">https://blog.csdn.net/s10461/article/details/53941091</a></li><li><a href="https://www.cnblogs.com/rese-t/p/8158870.html" target="_blank" rel="noopener">https://www.cnblogs.com/rese-t/p/8158870.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节继续讨论泛型相关的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之泛型上</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8A/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之泛型上/</id>
    <published>2019-02-19T13:11:29.452Z</published>
    <updated>2019-02-19T13:13:56.474Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章全面介绍Java泛型中的基础及原理。本节主要介绍什么是泛型、泛型的核心特性、泛型与继承注意点、泛型与多态的原理以及泛型的使用。</p><a id="more"></a><h2>1、什么是泛型以及为什么用泛型</h2><p>直接上例子进行说明：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-1.png" alt="image"></p><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>为什么会出现这种问题呢？</p><ul><li>集合本身无法对其存放的对象类型进行限定，可以涵盖Java中的所有类型。缺口太大，导致各种蛇、蚁、虫、鼠通通都可以进来。</li></ul><ul><li>由于我们要使用的实际存放类型的方法，所以不可避免地要进行类型转换。小对象转大对象很容易，大对象转小对象则有很大的风险，因为在编译时，我们无从得知对象真正的类型。</li></ul><p>泛型就是为了解决这类问题而诞生的。</p><h2>2、泛型的特性</h2><h5>2.1 泛型只在编译阶段有效</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-2.png" alt="image"></p><p>输出结果：类型相同</p><blockquote><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。<font color="#ff0000"><strong>也就是说Java中的泛型，只在编译阶段有效</strong>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</font></p></blockquote><p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p><h5>2.2 泛型的兼容性</h5><p>Java编译器是向后兼容的，也就是低版本的源代码可以用高版本编译器进行编译。下面来看看那些兼容性代码。</p><blockquote><ol><li>引用和实例化都不包含泛型信息。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-3.png" alt="image"></p><p>上面的这段代码是可以通过编译的，这是JDK1.4之前的写法，所以可以验证JDK1.5之后的编译器是可以兼容JDK1.4之前的源代码的。不过，笔者在JDK1.8.x版本的编译器进行编译时，会抛出如下所示的警告信息。很显然，如果类被定义成泛型类，但是在实际使用时不使用泛型特性，这是不推荐的做法！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注: Compatibility.java使用了未经检查或不安全的操作。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>引用使用泛型，实例化不使用泛型。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-4.png" alt="image"></p><p>上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告。</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>引用不使用泛型，实例化使用泛型。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-5.png" alt="image"></p><p>上面的这段代码可以编译通过，其效果与1（不使用泛型）完全一致。结合2、3可以知道，编译时只能做引用的类型检查，而无法检查引用所指向对象的实际类型。</p><h2>3、泛型与继承</h2><p>在使用泛型时，引用的参数类型与实际对象的参数类型要保持一致（通配符除外），就算两个参数类型是继承关系也是不允许的。看看下面的2行代码，它们均不能通过编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); <span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>下面来探讨一下为什么不能这么做。</p><ul><li>第1种情况，如果这种代码可以通过编译，那么调用<code>get()</code>方法返回的对象应该是<code>String</code>，但它实际上可以存放任意<code>Object</code>类型的对象，这样在调用类型转换指令时会抛出<code>ClassCastException</code>。</li><li>第2种情况。虽然<code>String</code>类型的对象转换为<code>Object</code>不会有任何问题，但是这有什么意义呢？我们原本想要用<code>String</code>对象的方法，但最终将其赋予了一个<code>Object</code>类型的引用。如果需要使用<code>String</code>中的某些方法，必须将<code>Object</code>强制转换为<code>String</code>。这样不会抛出异常，但是却违背了泛型设计的初衷。</li></ul><h2>4、泛型与多态</h2><p>下面来考虑一下泛型中多态问题。普通类型的多态是通过继承并重写父类的方法来实现的，泛型也不例外，下面是一个泛型多态示例。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic10-7.png" alt="image"></p><p>上面定义了一个泛型父类和一个实际参数为<code>String</code>类型的子类，并“重写”了<code>set(T)</code>和<code>get()</code>方法。<code>Son</code>类中的<code>@Override</code>注解也清楚地显示这是一个重写方法，最终执行的结果如下，与想象中的结果完全一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am father, t=hello world</span><br><span class="line">I am son.</span><br></pre></td></tr></table></figure><p>真的这么简单么？虽然表面上（源代码层面）来看，泛型多态与普通类的多态并无二样，但是其内部的实时原理却大相径庭。</p><p>泛型类<code>Father</code>在编译后会擦除泛型信息，所有的泛型参数都会用<code>Object</code>类替代。实际上，<code>Father</code>编译后的字节码与下面的代码完全一致。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-8.png" alt="image"></p><p><code>Son</code>类的与最终会变为：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-9.png" alt="image"></p><p><code>Father</code>和<code>Son</code>类的<code>set()</code>方法的参数类型不一样，所以，这并不是方法重写，而是方法重载！但是，如果是重载，那么<code>Son</code>类就应该会继承<code>Father</code>类的<code>set(Object)</code>方法，也就是<code>Son</code>会同时包含<code>set(String)</code>和<code>set(Object)</code>，下面来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son son = <span class="keyword">new</span> Son();</span><br><span class="line">son.set(<span class="string">"test"</span>);</span><br><span class="line">son.set(<span class="keyword">new</span> Object()); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>当<code>set</code>一个<code>Object</code>对象时，编译无法通过。这就很奇怪了，感觉跟之前学到的知识是相悖的。我们原本想通过重写方法来实现多态，但由于泛型的类型擦除，却最终变成了重载，所以类型擦除与多态有了矛盾。那么Java是怎么解决这个问题的呢？还是从字节码中找答案吧。<code>Son</code>类最终的编译结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.String)</span></span>;         <span class="comment">// 我们重写的方法</span></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">get</span><span class="params">()</span></span>;              <span class="comment">// 我们重写的方法</span></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;              <span class="comment">// 编译器生成的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;          <span class="comment">// 编译器生成的方法</span></span><br><span class="line">    ...</span><br><span class="line">    2: checkcast     #39                 // class java/lang/String</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><font color="#ff0000">⭐这里面多了一个<code>Object get()</code>方法和<code>set(Object)</code>方法，这两个方法在<code>Son</code>类源代码里面并不存在，这是编译器为了解决泛型的多态问题而自动生成的方法，称为“桥方法”。这两个方法的签名与<code>Father</code>类中的两个方法的签名完全一致，这才是真正的方法重写。也就是说，子类真正重写的我们看不到的桥方法，啊，多么痛的领悟！！！<code>@Override</code>注解只是假象，让人误以为他们真的是重写方法。</font></p><p>再看看<code>set(Object)</code>桥方法的实现细节，先将<code>Object</code>对象强制转换为<code>String</code>对象，然后调用<code>Son</code>中的<code>set(String)</code>方法。饶了一个圈，最终才回到我们“重写”的方法。<code>main</code>方法中原本调用父类的<code>set(Object)</code>方法，由于子类通过桥方法重写了这个方法，所以最终的调用顺序是：<code>set(Object)</code> -&gt; <code>set(String)</code>。</p><p>与<code>set(Object)</code>桥方法的意义不同，<code>Object get()</code>并不仅仅解决泛型与重写的冲突，而更具有一般性。看看下面的代码，这是一个普通类的继承:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralFather</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralSon</span> <span class="keyword">extends</span> <span class="title">GeneralFather</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的返回类型是父类的返回类型的子类，这是允许的，这种特性叫做Java返回值的协变性。而协变性的实现方法就是上面所述的桥方法。</p><p>这里还会有疑惑，<code>set</code>方法可以通过参数类型来确定调用的方法。但是，参数一样而返回值不一样是不能重载的。如果我们在源代码中通过编写<code>String get()</code>和<code>Object get()</code>方法是无法通过编译的。虽然，编译器无法通过编译，但是JVM是可以编写这两种方法的，它调用方法时，将返回值也作为方法签名的一部分。有种只许州官放火，不许百姓点灯的感觉。可以看到，JVM做了不少我们认为不合法的事情，所以如果不深入研究底层原理，有些问题根本解释不了。</p><h2>5、泛型的使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法.</p><h5>5.1 泛型类</h5><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：<code>List</code>、<code>Set</code>、<code>Map</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-10.png" alt="image"></p><p>下面进行实例化：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-11.png" alt="image"></p><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 123456</span><br><span class="line">12-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-12.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/泛型测试: key is 111111</span><br><span class="line">D/泛型测试: key is 4444</span><br><span class="line">D/泛型测试: key is 55.55</span><br><span class="line">D/泛型测试: key is false</span><br></pre></td></tr></table></figure><h5>5.2 泛型接口</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-13.png" alt="image"></p><p>当实现泛型接口的类，未传入泛型实参时：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-14.png" alt="image"></p><p>当实现泛型接口的类，传入泛型实参时：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-15.png" alt="image"></p><h5>5.3 泛型通配符</h5><p><font color="#ff0000">我们知道<code>Ingeter</code>是<code>Number</code>的一个子类，同时我们也验证过<code>Generic&lt;Ingeter&gt;</code>与<code>Generic&lt;Number&gt;</code>实际上是相同的一种基本类型。那么问题来了，在使用<code>Generic&lt;Number&gt;</code>作为形参的方法中，能否使用<code>Generic&lt;Ingeter&gt;</code>的实例传入呢？在逻辑上类似于<code>Generic&lt;Number&gt;</code>和<code>Generic&lt;Ingeter&gt;</code>是否可以看成具有父子关系的泛型类型呢？</font></p><p>为了弄清楚这个问题，我们使用<code>Generic&lt;T&gt;</code>这个泛型类继续看下面的例子：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-16.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic10-17.png" alt="image"></p><p>通过提示信息我们可以看到<code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。由此可以看出:<font color="#ff0000"><strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong></font>。</p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理<code>Generic&lt;Integer&gt;</code>类型的类，这显然与java中的多态理念相违背。因此我们需要一个在逻辑上可以表示同时是<code>Generic&lt;Integer&gt;</code>和<code>Generic&lt;Number&gt;</code>父类的引用类型。由此类型通配符应运而生。</p><p>我们可以将上面的方法改一下：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-18.png" alt="image"></p><p>类型通配符一般是使用<code>'?'</code>代替具体的类型实参，注意，<font color="#ff0000"><strong>此处’?'是类型实参，而不是类型形参</strong></font> 。重要说三遍！此处<code>'?'</code>是类型实参，而不是类型形参 ！ 此处<code>'?'</code>是类型实参，而不是类型形参 ！再直白点的意思就是，此处的<code>'?'</code>和<code>Number</code>、<code>String</code>、<code>Integer</code>一样都是一种实际的类型，可以把<code>'?'</code>看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是<code>'?'</code>；当操作类型时，不需要使用类型的具体功能时，只使用<code>Object</code>类中的功能。那么可以用<code>'?'</code>通配符来表示未知类型。</p><h5>5.4 泛型方法</h5><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-19.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));</span><br></pre></td></tr></table></figure><p>再对泛型方法进行一个比较，加深理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = key；</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//必须要声明E才行</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">setKey</span><span class="params">(E key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = (T)key;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">    <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>5.5 泛型方法与可变参数</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-20.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure><h5>5.6 静态方法与泛型</h5><p><strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</strong></p><p><img src="http://bloghello.oursnail.cn/javabasic10-21.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章全面介绍Java泛型中的基础及原理。本节主要介绍什么是泛型、泛型的核心特性、泛型与继承注意点、泛型与多态的原理以及泛型的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之克隆</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%8B%E9%9A%86/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之克隆/</id>
    <published>2019-02-19T11:27:35.679Z</published>
    <updated>2019-02-19T11:27:45.482Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候可能会问到克隆相关的深拷贝和浅拷贝，至少我是被问过的，所以对它们的了解是必要的，本篇文章探讨Java克隆方面的知识。</p><a id="more"></a><h2>1. Java中对象创建的两种方式</h2><p><code>clone</code>顾名思义就是复制， 在<code>Java</code>语言中， <code>clone</code>方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在<code>java</code>语言中，有几种方式可以创建对象呢？</p><ul><li>使用new操作符创建一个对象</li><li>使用clone方法复制一个对象</li></ul><p>那么这两种方式有什么相同和不同呢？ <code>new</code>操作符的本意是分配内存。程序执行到<code>new</code>操作符时， 首先去看<code>new</code>操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p><p>而<code>clone</code>在第一步是和<code>new</code>相似的， 都是分配内存，调用<code>clone</code>方法时，分配的内存和源对象（即调用<code>clone</code>方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，<code>clone</code>方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p><h2>2. 复制对象 or 复制引用</h2><p>在Java中，以下类似的代码非常常见：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-1.png" alt="image"></p><p>当<code>Person p1 = p;</code>执行之后， 是创建了一个新的对象吗？ 首先看打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br></pre></td></tr></table></figure><p>可已看出，打印的地址值是相同的，既然地址都是相同的，那么肯定是同一个对象。p和p1只是引用而已，他们都指向了一个相同的对象<code>Person(23, &quot;zhang&quot;)</code> 。 可以把这种现象叫做引用的复制。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%95%E7%94%A8%E5%A4%8D%E5%88%B6.png" alt="image"></p><p>而下面的代码是真真正正的克隆了一个对象。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-2.png" alt="image"></p><p>从打印结果可以看出，两个对象的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br><span class="line">com.pansoft.zhangjg.testclone.Person@67f1fba0</span><br></pre></td></tr></table></figure><p>以上代码执行完成后， 内存中的情景如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1.png" alt="image"></p><h2>3. 深拷贝 or 浅拷贝</h2><p><img src="http://bloghello.oursnail.cn/javabasic9-3.png" alt="image"></p><ul><li><p><code>age</code>是基本数据类型，那么对它的拷贝没有什么疑议，直接将一个4字节的整数值拷贝过来就行。</p></li><li><p><code>name</code>是<code>String</code>类型的， 它只是一个引用， 指向一个真正的<code>String</code>对象，那么对它的拷贝有两种方式：</p><ul><li>直接将源对象中的<code>name</code>的引用值拷贝给新对象的<code>name</code>字段</li><li>或者是根据原<code>Person</code>对象中的<code>name</code>指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给新拷贝的<code>Person</code>对象的<code>name</code>字段。</li></ul></li><li><p>这两种拷贝方式分别叫做浅拷贝和深拷贝。深拷贝和浅拷贝的原理如下图所示：</p></li></ul><p><img src="http://xiaozhao.oursnail.cn/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="image"></p><p>下面通过代码进行验证。如果两个<code>Person</code>对象的<code>name</code>的地址值相同， 说明两个对象的<code>name</code>都指向同一个<code>String</code>对象， 也就是浅拷贝， 而如果两个对象的<code>name</code>的地址值不同， 那么就说明指向不同的<code>String</code>对象， 也就是在拷贝<code>Person</code>对象的时候， 同时拷贝了<code>name</code>引用的<code>String</code>对象， 也就是深拷贝。验证代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-4.png" alt="image"></p><p>覆盖<code>Object</code>中的<code>clone</code>方法， 实现深拷贝.假设<code>body</code>类里面组合了<code>head</code>类。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-5.png" alt="image"></p><p><code>Body</code>中组合了<code>Head</code>，重写了<code>Body</code>的<code>clone</code>方法，那么显然第一个输出为<code>false</code>；但是没有对<code>Head</code>进行重写<code>clone</code>方法，那么他们指向的是同一个内存空间。即，没有重写<code>clone的Head</code>类只是浅拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : <span class="keyword">false</span></span><br><span class="line">body.head == body1.head : <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>如果要使<code>Body</code>对象在<code>clone</code>时进行深拷贝， 那么就要在<code>Body</code>的<code>clone</code>方法中，将源对象引用的<code>Head</code>对象也<code>clone</code>一份。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-6.png" alt="image"></p><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br></pre></td></tr></table></figure><p>由此，我们得到一个结论：如果想要深拷贝一个对象， 这个对象必须要实现<code>Cloneable</code>接口，实现<code>clone</code>方法，并且在<code>clone</code>方法内部，把该对象引用的其他对象也要<code>clone</code>一份 ， 这就要求这个被引用的对象必须也要实现<code>Cloneable</code>接口并且实现<code>clone</code>方法。</p><p>那么，按照上面的结论， <code>Body</code>类组合了<code>Head</code>类， 而<code>Head</code>类组合了<code>Face</code>类，要想深拷贝<code>Body</code>类，必须在<code>Body</code>类的<code>clone</code>方法中将<code>Head</code>类也要拷贝一份，但是在拷贝<code>Head</code>类时，默认执行的是浅拷贝，也就是说<code>Head</code>中组合的<code>Face</code>对象并不会被拷贝。验证代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-7.png" alt="image"></p><p>输出结果符合预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br><span class="line">body.head.face == body1.head.face : true</span><br></pre></td></tr></table></figure><p>内存结构图如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A12.png" alt="image"></p><p>那么此时<code>Head</code>中组合的<code>Face</code>又是一个浅拷贝。那么到底如何实现彻底的深拷贝呢？</p><p>对于上面的例子来说，怎样才能保证两个<code>Body</code>对象完全独立呢？只要在拷贝<code>Head</code>对象的时候，也将<code>Face</code>对象拷贝一份就可以了。这需要让<code>Face</code>类也实现<code>Cloneable</code>接口，实现<code>clone</code>方法，并且在在<code>Head</code>对象的<code>clone</code>方法中，拷贝它所引用的<code>Face</code>对象。修改的部分代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-8.png" alt="image"></p><p>再次运行上面的示例，得到的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br><span class="line">body.head.face == body1.head.face : false</span><br></pre></td></tr></table></figure><p>这说名两个<code>Body</code>已经完全独立了，他们间接引用的<code>face</code>对象已经被拷贝，也就是引用了独立的<code>Face</code>对象。内存结构图如下：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A13.png" alt="image"></p><p>显然，对于复杂的对象而言，用这种方式实现深拷贝是十分困难的。这时我们可以用序列化的方式来实现对象的深克隆。</p><h2>4. 序列化解决多层克隆问题</h2><p>首先由一个外部类<code>Outer</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-9.png" alt="image"></p><p>再来一个被序列化的类<code>Inner</code>:</p><p><img src="http://bloghello.oursnail.cn/javabasic9-10.png" alt="image"></p><p>再对克隆的对象进行测试：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-11.png" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">outer的name值为：outer</span><br><span class="line">Inner的name值为：inner</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">Java提高篇——对象克隆（复制）</a></li><li><a href="https://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="noopener">详解Java中的clone方法 – 原型模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试的时候可能会问到克隆相关的深拷贝和浅拷贝，至少我是被问过的，所以对它们的了解是必要的，本篇文章探讨Java克隆方面的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之异常</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之异常/</id>
    <published>2019-02-19T08:04:37.413Z</published>
    <updated>2019-02-19T08:04:51.886Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，异常处理是一个不可绕开的话题，我们对于异常的处理已经非常熟练了，对于异常本身的概念、用法等不再赘述了，直接结合面试问题来加深对异常的理解吧。</p><a id="more"></a><p><code>Throwable</code> 可以用来表示任何可以作为异常抛出的类，分为两种： <code>Error</code> 和 <code>Exception</code>。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E6%A0%91.png" alt="image"></p><h2>1. 什么是Java异常</h2><p>异常是发生在程序执行过程中阻碍程序正常执行的错误事件。比如：用户输入错误数据、硬件故障、网络阻塞等都会导致出现异常。</p><p>只要在Java语句执行中产生了异常，<strong>一个异常对象就会被创建</strong>，JRE就会试图寻找异常处理程序来处理异常。如果有合适的异常处理程序，异常对象就会被异常处理程序接管，否则，将引发运行环境异常，JRE终止程序执行。</p><p>Java异常处理框架只能处理运行时错误，编译错误不在其考虑范围之内。</p><h2>2. Error和Exception的区别</h2><p>Error：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM出现的问题。</p><p>例如，Java虚拟机运行错误，当 JVM 不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机一般会选择线程终止。</p><h2>3. Java异常处理中有哪些关键字？</h2><ul><li><code>throw</code>:有时我们需要显式地创建并抛出异常对象来终止程序的正常执行。<code>throw</code>关键字用来抛出并处理运行时异常。</li><li><code>throws</code>:当我们抛出任何“被检查的异常(<code>checked exception</code>)”并不处理时，需要在方法签名中使用关键字<code>throws</code>来告知调用程序此方法可能会抛出的异常。调用方法可能会处理这些异常，或者同样用<code>throws</code>来将异常传给上一级调用方法。<code>throws</code>关键字后可接多个潜在异常，甚至是在<code>main()</code>中也可以使用<code>throws</code>。</li><li><code>try-catch</code>:我们在代码中用<code>try-catch</code>块处理异常。当然，一个<code>try</code>块之后可以有多个<code>catch</code>子句，<code>try-catch</code>块也能嵌套。每个<code>catch</code>块必须接受一个（且仅有一个）代表异常类型的参数。</li><li><code>finally</code>:<code>finally</code>块是可选的，并且只能配合<code>try-catch</code>一起使用。虽然异常终止了程序的执行，但是还有一些打开的资源没有被关闭，因此，我们能使用<code>finally</code>进行关闭。不管异常有没有出现，<code>finally</code>块总会被执行。</li></ul><h2>4. 描述一下异常的层级</h2><ul><li><code>Throwable</code>是所有异常的父类，它有两个直接子对象<code>Error</code>,<code>Exception</code>，其中<code>Exception</code>又被继续划分为“被检查的异常(<code>checked exception</code>)”和”运行时的异常（<code>runtime exception</code>,即不受检查的异常）”。 <code>Error</code>表示编译时和系统错误，通常不能预期和恢复，比如硬件故障、JVM崩溃、内存不足等。</li><li>被检查的异常（<code>Checked exception</code>）在程序中能预期，并要尝试修复，如<code>FileNotFoundException</code>。我们必须捕获此类异常，并为用户提供有用信息和合适日志来进行调试。<code>Exception</code>是所有被检查的异常的父类。</li><li>运行时异常（<code>Runtime Exception</code>）又称为不受检查异常，源于糟糕的编程。比如我们检索数组元素之前必须确认数组的长度，否则就可能会抛出<code>ArrayIndexOutOfBoundException</code>运行时异常。<code>RuntimeException</code>是所有运行时异常的父类。</li></ul><h2>5. 描述Java 7 ARM(Automatic Resource Management，自动资源管理)特征和多个catch块的使用</h2><p>如果一个<code>try</code>块中有多个异常要被捕获，<code>catch</code>块中的代码会变丑陋的同时还要用多余的代码来记录异常。有鉴于此，Java 7的一个新特征是：一个<code>catch</code>子句中可以捕获多个异常。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(IOException | SQLException | Exception ex)&#123;</span><br><span class="line">     logger.error(ex);</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> MyException(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况下，当忘记关闭资源或因资源耗尽出现运行时异常时，我们只是用<code>finally</code>子句来关闭资源。这些异常很难调试，我们需要深入到资源使用的每一步来确定是否已关闭。因此，Java 7用<code>try-with-resources</code>进行了改进：在<code>try</code>子句中能创建一个资源对象，当程序的执行完<code>try-catch</code>之后，运行环境自动关闭资源。</p><blockquote><p>利用Try-Catch-Finally管理资源（旧的代码风格）：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>);<span class="comment">//可能发生异常1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read();<span class="comment">//可能发生异常2</span></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">            input.close();<span class="comment">//可能发生异常3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<code>try</code>语句块抛出一个异常，然后<code>finally</code>语句块被执行。同样假设<code>finally</code>语句块也抛出了一个异常。那么哪个异常会根据调用栈往外传播？</p><p><font color="#ff0000">即使<code>try</code>语句块中抛出的异常与异常传播更相关，最终还是<code>finally</code>语句块中抛出的异常会根据调用栈向外传播。</font></p><blockquote><p>在java7中，对于上面的例子可以用try-with-resource 结构这样写：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#ff0000">当<code>try</code>语句块运行结束时，<code>FileInputStream</code> 会被自动关闭。这是因为<code>FileInputStream</code> 实现了java中的<code>java.lang.AutoCloseable</code>接口。所有实现了这个接口的类都可以在<code>try-with-resources</code>结构中使用。</font></p><p><strong>当<code>try-with-resources</code>结构中抛出一个异常，同时<code>FileInputStream</code>被关闭时（调用了其<code>close</code>方法）也抛出一个异常，<code>try-with-resources</code>结构中抛出的异常会向外传播，而<code>FileInputStream</code>被关闭时抛出的异常被抑制了</strong>。</p><blockquote><p>你可以在块中使用多个资源而且这些资源都能被自动地关闭。下面是例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(  FileInputStream     input         = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">          BufferedInputStream bufferedInput = <span class="keyword">new</span> BufferedInputStream(input)</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = bufferedInput.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">    data = bufferedInput.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些资源将按照他们被创建顺序的<strong>逆序</strong>来关闭。首先<code>BufferedInputStream</code> 会被关闭，然后<code>FileInputStream</code>会被关闭。</p><p>这个<code>try-with-resources</code>结构里不仅能够操作java内置的类。你也可以在自己的类中实现<code>java.lang.AutoCloseable</code>接口，然后在<code>try-with-resources</code>结构里使用这个类。</p><p><code>AutoClosable</code> 接口仅仅有一个方法，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoClosable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何实现了这个接口的方法都可以在<code>try-with-resources</code>结构中使用。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoClosable</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoClosable doing it!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoClosable closed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doIt()</code>是方法不是<code>AutoClosable</code> 接口中的一部分，之所以实现这个方法是因为我们想要这个类除了关闭方法外还能做点其他事。</p><p>下面是<code>MyAutoClosable</code> 在<code>try-with-resources</code>结构中使用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myAutoClosable</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(MyAutoClosable myAutoClosable = <span class="keyword">new</span> MyAutoClosable())&#123;</span><br><span class="line">        myAutoClosable.doIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyAutoClosable doing it!</span><br><span class="line">MyAutoClosable closed!</span><br></pre></td></tr></table></figure><p>通过上面这些你可以看到，不论<code>try-catch</code>中使用的资源是自己创造的还是java内置的类型，<code>try-with-resources</code>都是一个能够确保资源能被正确地关闭的强大方法。</p><h2>6. 在Java中throw与throws关键字之间的区别？</h2><p>throws用于在方法签名中声明此方法可能抛出的异常，而throw关键字则是中断程序的执行并移交异常对象到运行时进行处理。</p><h2>7. 在Java中怎么写自定义的异常？</h2><p>我们能继承Exception类或其任何子类来实现自己的自定义异常类。这自定义异常类可以有自己变量和方法来传递错误代码或其它异常相关信息来处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyBikeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code = ResponseEnum.ERROR.getCode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HappyBikeException</span><span class="params">(Integer code,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HappyBikeException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>8. Java中final,finally,finalize的区别？</h2><p>这是一个垃圾问题，很想删除掉，但是考虑到新手，还是保留一下吧，至少从单词上有那么一点点像。</p><p><code>final</code>和<code>finally</code>在Java中是关键字，而finalize则是一个方法。</p><p><code>final</code>关键字使得类变量不可变，避免类被其它类继承或方法被重写。<code>finally</code>跟<code>try-catch</code>块一起使用，即使是出现了异常，其子句总会被执行，通常，<code>finally</code>子句用来关闭相关资源。<code>finally</code>方法中的对象被销毁之前会被垃圾回收。</p><h2>9. 在main方法抛出异常时发生了什么？</h2><p>答：当<code>main</code>方法抛出异常时，Java运行时间终止并在控制台打印异常信息和栈轨迹。</p><h2>10. catch子句能为空吗？</h2><p><code>catch</code>后面括号里面不能为空。</p><p>答：可以有空的<code>catch</code>子句，但那是最糟糕的编程，因为那样的话，异常即使被捕获，我们也得不到任何的有用信息，对于调试来说会是个噩梦，因此，编程时永远不要有空的<code>catch</code>子句。<code>Catch</code>子句中至少要包含一个日志语句输出到控制台或保存到日志文件中。</p><h2>11. 提供一些Java异常处理的最佳实践。</h2><ul><li>使用具体的异常方便调试</li><li>程序中早点抛出异常</li><li>捕获异常后让调用者处理异常</li><li>使用Java 7 ARM功能确保资源关闭或者用finally子句正确地关闭它们</li><li>为了调试需要总是记录异常信息</li><li>用多个catch子句实现更完全的关闭</li><li>你自己的应用API中用自定义的异常来抛出单种类型异常</li><li>遵循命名规定，以异常结束</li><li>在Javadoc中用@throws来标注方法抛出的异常</li><li><strong>处理异常是有花销的，因此只有在必要时才抛出</strong>。否则，你会扑空或毫无收获。</li></ul><h2>12. try、catch、finally三个语句块应注意的问题</h2><ul><li>try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。</li><li>try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。</li><li>多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，并且匹配catch语句的顺序是由上到下。</li><li>无论程序是否有异常，并且无论之间try-catch是否顺利执行完毕，都会执行finally语句。在以下特殊情况下，finally块不会执行：在finally语句块中发生异常；在前面代码中使用了System.exit()退出程序；程序所在线程死亡；关闭cpu。</li><li><strong>⭐当程序执行try块，catch块时遇到return语句或者throw语句，这两个语句都会导致该方法立即结束，所以系统并不会立即执行这两个语句，而是去寻找该异常处理流程中的finally块，如果没有finally块，程序立即执行return语句或者throw语句，方法终止。如果有finally块，系统立即开始执行finally块，只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句，如果finally块里也使用了return或throw等导致方法终止的语句，则finally块已经终止了方法，不用再跳回去执行try块、catch块里的任何代码了。</strong></li></ul><h2>13. 解释Java中的异常处理流程</h2><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E5%B8%B8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="image"></p><h2>异常处理完成以后，Exception对象会发生什么变化？</h2><p>Exception对象会在下一个垃圾回收过程中被回收掉。</p><h2>请写出 5 种常见到的runtime exception。</h2><ul><li><code>NullPointerException</code>：当操作一个空引用时会出现此错误。</li><li><code>NumberFormatException</code>：数据格式转换出现问题时出现此异常。</li><li><code>ClassCastException</code>：强制类型转换类型不匹配时出现此异常。</li><li><code>ArrayIndexOutOfBoundsException</code>：数组下标越界，当使用一个不存在的数组下标时出现此异常。</li><li><code>ArithmeticException</code>：数学运行错误时出现此异常</li></ul><p>参考：</p><ul><li><a href="http://www.importnew.com/7383.html" target="_blank" rel="noopener">http://www.importnew.com/7383.html</a></li><li><a href="http://www.importnew.com/7541.html" target="_blank" rel="noopener">http://www.importnew.com/7541.html</a></li><li><a href="http://www.importnew.com/7820.html" target="_blank" rel="noopener">http://www.importnew.com/7820.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，异常处理是一个不可绕开的话题，我们对于异常的处理已经非常熟练了，对于异常本身的概念、用法等不再赘述了，直接结合面试问题来加深对异常的理解吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>自己实现一个简单的web服务器</title>
    <link href="http://yoursite.com/2019/02/18/thread/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2019/02/18/thread/自己实现一个简单的web服务器/</id>
    <published>2019-02-18T12:28:38.517Z</published>
    <updated>2019-02-18T12:40:30.144Z</updated>
    
    <content type="html"><![CDATA[<p>这里涉及网络编程的基本知识以及HTTP协议的基本认识，下面来一步一步实现一下最简单的一个web服务器。</p><a id="more"></a><h2>一、用户请求域名到底发送了什么信息来</h2><p>如果服务端都不知道客户端发来的是什么，那何谈对内容的解析呢？所以我们首先在服务端解析客户端的访问信息，比如我们比较关心的是请求的是什么路径：</p><p><img src="http://bloghello.oursnail.cn/thread17-1.png" alt="image"></p><p>此时我们访问地址： localhost:8888 打印出来的结果为：</p><p><img src="http://bloghello.oursnail.cn/thread17-2.png" alt="image"></p><p>其实对于我们这种比较简单的实现来说，红框的信息已经足够了。我们只要知道客户端要发来的资源名字是什么，我们根据这个名字取找响应的资源返回给客户端展示即可。由于我其实请求的是根路径，所以是<code>/</code>。如果我在这里请求 localhost:8888/index.html 那么就会显示 <code>GET /index.html HTTP/1.1</code>这样的信息。不再演示。</p><p>但是上面的写法是存在问题的，仅仅是演示而用，因为它会一直等待输入。</p><p>那么，不用<code>while</code>一直等待，而且只需要第一行即可，那么可以这样写：</p><p><img src="http://bloghello.oursnail.cn/thread17-3.png" alt="image"></p><p>好了，不能总之只接收吧，我们服务端要给客户端点什么。</p><h2>二、服务端如何响应资源给客户端展示</h2><p>首先我们得有资源才能展示，假设我们要展示<code>index.html</code>，我们将其暂时放在<code>F:/webrooot</code>下。</p><p>内容暂时为：</p><p><img src="http://bloghello.oursnail.cn/thread17-4.png" alt="image"></p><p>只是展示一下欢迎信息而已。服务端就需要读取这个文件，然后以流的形式发送给客户端的浏览器上，浏览器再解析展示。</p><p><img src="http://bloghello.oursnail.cn/thread17-5.png" alt="image"></p><p>此时再去访问页面，就会显示欢迎的信息啦！</p><p><img src="http://bloghello.oursnail.cn/thread17-6.png" alt="image"></p><p>这里没有关闭流，也没有关闭<code>socket</code>，不过下面都会关闭掉。这个不重要，重要的是，这玩意都是在主线程中做的，显然不如多线程来的快，并且全写在主线程里，肯定是不够好的。下面就用多线程来实现。</p><h2>三、普通的多线程实现方式</h2><p><img src="http://bloghello.oursnail.cn/thread17-7.png" alt="image"></p><p>就是在这个线程中处理数据和返回数据。</p><p><img src="http://bloghello.oursnail.cn/thread17-8.png" alt="image"></p><p>其很简单，但是如果我想显示一张图片呢？</p><p>比如我的根目录下有一张图片叫做：<code>hh.jpg</code></p><p><img src="http://bloghello.oursnail.cn/thread17-9.png" alt="image"></p><p>很显然现在还是无法展示的，原因是我这里写死了是以<code>text/html</code>的形式响应，但是图片正确的响应是<code>image/jpeg</code>这种格式。</p><p>所以我们不能无脑写死，要进行适当的判断才行。下面贴出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//根目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String webroot = <span class="string">"F:\\webroot\\"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket client;</span><br><span class="line">    InputStream ins;</span><br><span class="line">    OutputStream out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存放类型，比如jpg对应的是image/jpeg，这是http协议规定的每种类型的响应格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; contentMap =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        contentMap.put(<span class="string">"html"</span>,<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        contentMap.put(<span class="string">"jpg"</span>,<span class="string">"image/jpeg"</span>);</span><br><span class="line">        contentMap.put(<span class="string">"png"</span>,<span class="string">"image/jpeg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket client)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ins = client.getInputStream();</span><br><span class="line">            out = client.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            go();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求内容</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(ins));</span><br><span class="line">        <span class="comment">//获取到请求的资源名称</span></span><br><span class="line">        String line = reader.readLine().split(<span class="string">" "</span>)[<span class="number">1</span>].replace(<span class="string">"/"</span>,<span class="string">"\\"</span>);</span><br><span class="line">        <span class="keyword">if</span>(line.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">            line += <span class="string">"index.html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">        <span class="comment">//拼接起来就是资源的完整路径</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(webroot + line);</span><br><span class="line">        <span class="comment">//判断是否存在，存在则响应内容，不存在则告知不存在</span></span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="comment">//给用户响应</span></span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(out);</span><br><span class="line">            InputStream i = <span class="keyword">new</span> FileInputStream(webroot + line);</span><br><span class="line">            <span class="comment">//由于需要将图片也要传给前端，再用这个就不好办了，得用普通的文件输入流</span></span><br><span class="line"><span class="comment">//          BufferedReader fr = new BufferedReader(new InputStreamReader(i));</span></span><br><span class="line">            pw.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">            <span class="comment">//返回的类型是动态判断的，图片用图片的类型，文本用文本的类型</span></span><br><span class="line">            String s = contentMap.get(line.substring(line.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>,line.length()));</span><br><span class="line">            System.out.println(<span class="string">"返回的类型为："</span>+ s);</span><br><span class="line">            pw.println(<span class="string">"Content-Type: "</span> + s);</span><br><span class="line">            pw.println(<span class="string">"Content-Length:"</span> + i.available());</span><br><span class="line">            pw.println(<span class="string">"Server: hello-server"</span>);</span><br><span class="line">            pw.println(<span class="string">"Date:"</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">            pw.println(<span class="string">""</span>);</span><br><span class="line">            pw.flush();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写入输出流中通过PrintWriter发给浏览器</span></span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ( (len = i.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            pw.flush();</span><br><span class="line">            pw.close();</span><br><span class="line">            i.close();</span><br><span class="line">            reader.close();</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuffer error = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            error.append(<span class="string">"HTTP /1.1 400 file not found /r/n"</span>);</span><br><span class="line">            error.append(<span class="string">"Content-Type:text/html \r\n"</span>);</span><br><span class="line">            error.append(<span class="string">"Content-Length:20 \r\n"</span>).append(<span class="string">"\r\n"</span>);</span><br><span class="line">            error.append(<span class="string">"&lt;h1 &gt;File Not Found..&lt;/h1&gt;"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.write(error.toString().getBytes());</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,你会发现，我还添加了判断资源存在不存在的逻辑，这样显得更加健全一点。</p><p>当找得到资源得时候：</p><p><img src="http://bloghello.oursnail.cn/thread17-10.png" alt="image"></p><p>当找不到资源得时候：</p><p><img src="http://bloghello.oursnail.cn/thread17-11.png" alt="image"></p><h2>四、线程池方式</h2><p>其实很简单，线程池的优势以前也说过，不赘述，直接贴一下代码结束。</p><p><img src="http://bloghello.oursnail.cn/thread17-12.png" alt="image"></p><p>至此，我们完成了一个比较简单的web服务器的开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里涉及网络编程的基本知识以及HTTP协议的基本认识，下面来一步一步实现一下最简单的一个web服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础之JDK动态代理</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/java基础之JDK动态代理/</id>
    <published>2019-02-17T12:16:53.333Z</published>
    <updated>2019-02-17T12:27:22.698Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式可以说是经常面试被问的一个东西，因为spring aop的实现原理就是基于它，关于它，只要记住，它是运行时动态生成的一个代理类。在这个基础上，再去看看它底层源码，其实JDK已经帮我们最大程度上封装成简单的函数了，我们只需要传入几个参数就可以生成对应的代理对象。</p><a id="more"></a><h2>代理模式是什么</h2><p>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p><ul><li><code>RealSubject</code> 是原对象（本文把原对象称为&quot;委托对象&quot;），<code>Proxy</code> 是代理对象。</li><li><code>Subject</code> 是委托对象和代理对象都共同实现的接口。</li><li><code>Request()</code> 是委托对象和代理对象共同拥有的方法。</li></ul><h2>结合生活理解代理模式</h2><p>要理解代理模式很简单，其实生活当中就存在代理模式：</p><blockquote><p>我们购买火车票可以去火车站买，但是也可以去火车票代售处买，此处的火车票代售处就是火车站购票的代理，即我们在代售点发出买票请求，代售点会把请求发给火车站，火车站把购买成功响应发给代售点，代售点再告诉你。</p><p>但是代售点只能买票，不能退票，而火车站能买票也能退票，因此代理对象支持的操作可能和委托对象的操作有所不同。</p></blockquote><h2>Java实现静态代理示例</h2><p><img src="http://bloghello.oursnail.cn/javabasic8-1.png" alt="image"></p><p>代理的实现分为：</p><ul><li>静态代理</li></ul><p>代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 <code>class</code> 文件。</p><ul><li>动态代理</li></ul><p>代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 <code>class</code> 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p><h2>Java 实现动态代理</h2><h5>几个重要名词:</h5><ul><li>委托类和委托对象：委托类是一个类，委托对象是委托类的实例，即原类。</li><li>代理类和代理对象：代理类是一个类，代理对象是代理类的实例。</li></ul><h5>Java实现动态代理的大致步骤如下:</h5><ol><li>定义一个委托类和公共接口。</li><li>自己定义一个类（调用处理器类，即实现 <code>InvocationHandler</code> 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括<code>Preprocess</code>和<code>Postprocess</code>），即代理类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。</li><li>生成代理对象（当然也会生成代理类），需要为他指定(1)类加载器对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li></ol><h5>Java 实现动态代理主要涉及以下几个类:</h5><ul><li><code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 <code>Proxy</code> 类生成的代理类都继承了 <code>Proxy</code> 类，即 <code>DynamicProxyClass extends Proxy</code>。</li><li><code>java.lang.reflect.InvocationHandler</code>: 这里称他为&quot;调用处理器&quot;，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 <code>InvocationHandler</code> 接口。</li></ul><h5>Proxy 类主要方法为：</h5><p><img src="http://bloghello.oursnail.cn/javabasic8-2.png" alt="image"></p><ul><li>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区）</li><li>第二个参数是接口（表明你这个代理类需要实现哪些接口）</li><li>第三个参数是调用处理器类实例（指定代理类中具体要干什么）。</li><li>这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用<code>newProxyInstance()</code>时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：</li></ul><p><img src="http://bloghello.oursnail.cn/javabasic8-3.png" alt="image"></p><p><code>Proxy</code> 类还有一些静态方法，比如：</p><ul><li><code>InvocationHandler getInvocationHandler(Object proxy)</code>: 获得代理对象对应的调用处理器对象。</li><li><code>Class getProxyClass(ClassLoader loader, Class[] interfaces)</code>: 根据类加载器和实现的接口获得代理类。</li></ul><p><code>Proxy</code> 类中有一个映射表，映射关系为：(<code>&lt;ClassLoader&gt;</code>,(<code>&lt;Interfaces&gt;</code>,<code>&lt;ProxyClass&gt;</code>) )，可以看出一级key为类加载器，根据这个一级key获得二级映射表，二级key为接口数组，因此可以看出：一个类加载器对象和一个接口数组确定了一个代理类。</p><p>我们写一个简单的例子来阐述 Java 实现动态代理的整个过程：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-4.png" alt="image"></p><p><code>InvocationHandler</code> 接口中有方法：<code>invoke(Object proxy, Method method, Object[] args)</code></p><p>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，<strong>第一个参数是代理对象</strong>（表示哪个代理对象调用了method方法，传递来的是），<strong>第二个参数是 Method 对象</strong>（表示哪个方法被调用了），<strong>第三个参数是指定调用方法的参数</strong>。</p><p>动态生成的代理类具有几个特点：</p><ul><li>继承 <code>Proxy</code> 类，并实现了在<code>Proxy.newProxyInstance()</code>中提供的接口数组。</li><li><code>public final</code>。</li><li>命名方式为 <code>$ProxyN</code>，其中N会慢慢增加，一开始是 <code>$Proxy1</code>，接下来是<code>$Proxy2</code>…</li><li>有一个参数为 <code>InvocationHandler</code> 的构造函数。这个从 <code>Proxy.newProxyInstance()</code> 函数内部的<code>clazz.getConstructor(new Class[] { InvocationHandler.class })</code> 可以看出。</li></ul><p>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p><blockquote><p>不难发现，代理类的实现是有很多共性的（重复代码），动态代理的好处在于避免了这些重复代码，只需要关注操作。</p></blockquote><h2>小栗子</h2><p>假设模拟一个场景，买衣服，正常情况所有人买这件衣服要100块钱。</p><p>定义一个销售接口：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-5.png" alt="image"></p><p>一个具体的实现类：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-6.png" alt="image"></p><p>那么正常情况大家都要花100才能买这件衣服。但是现在对会员做活动，会员打5折。怎么做呢？正常思维是：增加一个接口，甚至更糟的想法是修改一下这个实现类，都是不好的，那么我们是否想过这样的方案：新建一个新的类，让这个代理类去做相应的逻辑呢？既不用修改原来的代码，而且还很简单就能实现。</p><p>现在写一个代理类：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-7.png" alt="image"></p><p>那么调用的时候，一个是会员，一个是普通用户，根据身份调不同的方法即可：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-8.png" alt="image"></p><h2>Java 动态代理的内部实现</h2><p>现在我们就会有一个问题： Java 是怎么保证代理对象调用的任何方法都会调用 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法的？</p><p>这就涉及到动态代理的内部实现。假设有一个接口 <code>Subject</code>，且里面有 <code>int request(int i)</code> 方法，则生成的代理类大致如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-9.png" alt="image"></p><p>通过上面的方法就成功调用了 <code>invoke()</code> 方法，所以这是代理类中已经注定要去执行 <code>invoke()</code> 方法了。</p><p>有一篇文章比较生动地阐述了动态代理的含义：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513926&amp;idx=1&amp;sn=1c43c5557ba18fed34f3d68bfed6b8bd&amp;chksm=80d67b85b7a1f2930ede2803d6b08925474090f4127eefbb267e647dff11793d380e09f222a8#rd" target="_blank" rel="noopener">Java帝国之动态代理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式可以说是经常面试被问的一个东西，因为spring aop的实现原理就是基于它，关于它，只要记住，它是运行时动态生成的一个代理类。在这个基础上，再去看看它底层源码，其实JDK已经帮我们最大程度上封装成简单的函数了，我们只需要传入几个参数就可以生成对应的代理对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之注解</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/java基础之注解/</id>
    <published>2019-02-17T11:44:28.868Z</published>
    <updated>2019-02-17T11:44:49.892Z</updated>
    
    <content type="html"><![CDATA[<p>注解是一系列元数据，它提供数据用来解释程序代码，注释是给人看的，注解是给编译器看的，因此注解只在编译器有效。注解的实现原理涉及反射和动态代理，关于反射已经在前面说过，动态代理还没说，留在下一节。</p><a id="more"></a><h2>注解语法</h2><p>相信有不少的人员会认为注解的地位不高。其实同 <code>classs</code> 和 <code>interface</code> 一样，注解也属于一种类型。它是在 Java SE 5.0 版本中开始引入的概念。</p><h2>注解的定义</h2><p>注解通过 <code>@interface</code> 关键字进行定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><p>你可以简单理解为创建了一张名字为 <code>TestAnnotation</code> 的标签。</p><h2>注解的使用</h2><p>上面创建了一个注解，那么注解的的使用方法是什么呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。</p><h2>什么是元注解</h2><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p><p>元标签有 <code>@Retention</code>、<code>@Documented</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Repeatable</code> 5 种。</p><blockquote><p>@Retention</p></blockquote><p><code>Retention</code> 的英文意为保留期的意思。当 <code>@Retention</code> 应用到一个注解上的时候，它解释说明了这个<strong>注解的的存活时间</strong>。</p><ul><li><code>RetentionPolicy.SOURCE</code> 注解只在<strong>源码阶段</strong>保留，在编译器进行<strong>编译时它将被丢弃</strong>忽视。</li><li><code>RetentionPolicy.CLASS</code> 注解<strong>只被保留到编译进行</strong>的时候，它并<strong>不会被加载到 JVM</strong> 中。</li><li><code>RetentionPolicy.RUNTIME</code> 注解可以<strong>保留到程序运行</strong>的时候，它<strong>会被加载进入到 JVM</strong> 中，所以在程序运行时可以获取到它们。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Documented</p></blockquote><p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 <code>Javadoc</code> 中去。</p><blockquote><p>@Target</p></blockquote><p><code>Target</code> 是目标的意思，<code>@Target</code> 指定了注解运用的地方。</p><ul><li><code>ElementType.ANNOTATION_TYPE</code> 可以给一个注解进行注解</li><li><code>ElementType.CONSTRUCTOR</code> 可以给构造方法进行注解</li><li><code>ElementType.FIELD</code> 可以给属性进行注解</li><li><code>ElementType.LOCAL_VARIABLE</code> 可以给局部变量进行注解</li><li><code>ElementType.METHOD</code> 可以给方法进行注解</li><li><code>ElementType.PACKAGE</code> 可以给一个包进行注解</li><li><code>ElementType.PARAMETER</code> 可以给一个方法内的参数进行注解</li><li><code>ElementType.TYPE</code> 可以给一个类型进行注解，比如类、接口、枚举</li></ul><blockquote><p>@Inherited</p></blockquote><p><code>Inherited</code> 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个<strong>超类被 <code>@Inherited</code> 注解过的注解进行注解</strong>的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个被@Inherited注解的注解@Test</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类被@Test注解，即上面说的被@Inherited 注解过的注解进行注解</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么class B也拥有@Test注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Repeatable</p></blockquote><p><code>Repeatable</code> 自然是可重复的意思。<code>@Repeatable</code> 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照规定，它里面必须要有一个 value 的属性</span></span><br><span class="line"><span class="comment">//属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。</span></span><br><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Repeatable 后面括号中的类相当于一个容器注解</span></span><br><span class="line"><span class="comment">//什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    <span class="function">String <span class="title">role</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有了上面两个注解，Persons相当于一个总标签</span></span><br><span class="line"><span class="comment">//他里面可以放任意多个子标签，这些子标签类型是Person</span></span><br><span class="line"><span class="comment">//并且是存放于这个总标签的Person类型的数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么既然有了总标签和放子标签的数组，那么，下面就可以定义子标签</span></span><br><span class="line"><span class="comment">//子标签的类型自然就是Person，里面这里假设定义role属性</span></span><br><span class="line"><span class="comment">//就是说这些子标签表示人的角色。</span></span><br><span class="line"><span class="comment">//自然也就支持多种角色，那么定义多次即可。如下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"artist"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"coder"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"PM"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>注解的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有默认值的时候，可以不执行属性</span></span><br><span class="line"><span class="meta">@TestAnnotation</span>(id=<span class="number">3</span>,msg=<span class="string">"hello annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些规则：</p><ul><li>修饰符只能是<code>public</code> 或默认(<code>default</code>)</li><li>参数成员只能用基本类型<code>byte</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>double</code>,<code>boolean</code>,<code>char</code>八种基本类型和<code>String</code>,<code>Enum</code>,<code>Class</code>,<code>annotations</code>及这些类型的数组</li><li>如果只有一个参数成员,最好将名称设为”value”</li><li>注解元素必须有确定的值,可以在注解中定义默认值,也可以使用注解时指定,非基本类型的值不可为null,常使用空字符串或0作默认值</li><li>在表现一个元素存在或缺失的状态时,定义一下特殊值来表示,如空字符串或负值</li></ul><h2>Java 预置的注解</h2><blockquote><p>@Deprecated</p></blockquote><p>这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。</p><blockquote><p>@Override</p></blockquote><p>这个大家应该很熟悉了，提示子类要复写父类中被 <code>@Override</code> 修饰的方法</p><blockquote><p>@SuppressWarnings</p></blockquote><p>阻止警告的意思。之前说过调用被 <code>@Deprecated</code> 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 <code>@SuppressWarnings</code> 达到目的。</p><blockquote><p>@SafeVarargs</p></blockquote><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 <code>unchecked</code> 这样的警告。</p><blockquote><p>@FunctionalInterface</p></blockquote><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。</p><p>函数式接口 (<code>Functional Interface</code>) 就是一个具有一个方法的普通接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行线程开发中常用的 <code>Runnable</code> 就是一个典型的函数式接口，上面源码可以看到它就被 <code>@FunctionalInterface</code> 注解。</p><p>可能有人会疑惑，函数式接口标记有什么用，这个原因是函数式接口可以很容易转换为 <code>Lambda</code> 表达式。</p><h2>注解与反射</h2><blockquote><p>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者是 getAnnotations() 方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里举个例子：</p><p>首先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个类，打上这个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再main函数中拿到注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断Test.class中是否存在TestAnnotation注解</span></span><br><span class="line">        <span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(hasAnnotation)&#123;</span><br><span class="line">            System.out.println(<span class="string">"注解存在..."</span>);</span><br><span class="line">            <span class="comment">//从Test类中拿出TestAnnotation注解</span></span><br><span class="line">            TestAnnotation annotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">            <span class="comment">//拿到注解之后，可以拿出注解中的属性对应的默认值</span></span><br><span class="line">            System.out.println(annotation.id());</span><br><span class="line">            System.out.println(annotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面演示的是从类上拿到注解，对于属性、方法同样都可以用反射拿到注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>(value=<span class="string">"hi"</span>)</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Perform</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*************拿到属性上的注解****************/</span></span><br><span class="line">            Field a = Test.class.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">            a.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//获取一个成员变量上的注解</span></span><br><span class="line">            Check check = a.getAnnotation(Check.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( check != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                System.out.println(<span class="string">"check value:"</span>+check.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************拿到方法上的注解****************/</span></span><br><span class="line">            Method testMethod = Test.class.getDeclaredMethod(<span class="string">"testMethod"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( testMethod != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// 获取方法中的注解</span></span><br><span class="line">                Annotation[] ans = testMethod.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.length;i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"method testMethod annotation:"</span>+ans[i].annotationType().getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>注解实现原理</h2><p>在上面获取注解时是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestAnnotation annotation = Test.class.getAnnotation(TestAnnotation.class);</span><br></pre></td></tr></table></figure><p>它是从<code>class</code>中获取出<code>TestAnnotation</code>注解的，所以肯定是在某个时候注解被加入到<code>class</code>结构中去了。</p><ul><li>首先，我们知道从<code>java</code>源码到<code>class</code>字节码是由编译器完成的，编译器会对<code>java</code>源码进行解析并生成<code>class</code>文件。</li><li>而注解也是在编译时由编译器进行处理，编译器会对注解符号处理并附加到<code>class</code>结构中</li><li>根据<code>jvm</code>规范，<code>class</code>文件结构是严格有序的格式，唯一可以附加信息到<code>class</code>结构中的方式就是保存到<code>class</code>结构的<code>attributes</code>属性中</li><li>我们知道对于类、字段、方法，在<code>class</code>结构中都有自己特定的表结构，而且各自都有自己的属性，而对于注解，作用的范围也可以不同，可以作用在类上，也可以作用在字段或方法上，这时编译器会对应将注解信息存放到类、字段、方法自己的属性上。</li><li>在我们的<code>Test</code>类被编译后，在对应的<code>Test.class</code>文件中会包含一个<code>RuntimeVisibleAnnotations</code>属性，由于这个注解是作用在类上，所以此属性被添加到类的属性集上。即<code>TestAnnotation</code>注解的键值对<code>value=test</code>会被记录起来。</li><li>而当<code>JVM</code>加载<code>Test.class</code>文件字节码时，就会将<code>RuntimeVisibleAnnotations</code>属性值保存到<code>Test</code>的<code>Class</code>对象中，于是就可以通过<code>Test.class.getAnnotation(TestAnnotation.class)</code>获取到<code>Test</code>注解对象，进而再通过<code>Test</code>注解对象获取到<code>Test</code>里面的属性值。</li><li><code>Test</code>注解对象是什么？其实注解被编译后的本质就是一个继承<code>Annotation</code>接口的接口。所以<code>@TestAnnotation</code>其实就是“public interface TestAnnotation extends Annotation”</li><li>当我们通过<code>Test.class.getAnnotation(TestAnnotation.class)</code>调用时，<code>JDK</code>会通过动态代理生成一个实现了<code>TestAnnotation</code>接口的对象，并把将<code>RuntimeVisibleAnnotations</code>属性值设置进此对象中，此对象即为<code>TestAnnotation</code>注解对象，通过它的<code>value()</code>方法就可以获取到注解值。</li></ul><h2>总结注解到底是什么以及注解到底有什么应用场景</h2><p>注释是给人看的，<strong>注解是给编译器看的</strong>，以<code>@Override</code>注解为例，他的作用是告诉编译器他所注解的方法是重写父类中的方法，这样编译器就会去检查父类是否存在这个方法，以及这个方法的签名与父类是否相同。</p><p><strong>注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用</strong>；</p><p>也就是说，注解只是描述java代码的代码，能被编译器解析，<strong>只有编译器或者虚拟机来主动解析他的时候，他才可能发挥作用</strong>。</p><p>注解分为三类，元注解，java自带的标准注解以及自定义注解。</p><p>注解的使用场景：</p><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><p>我觉得这些说的太空洞了，注解在<code>spring</code>中就是非常常用的技术，比如，我指定这个类是<code>@Controller</code>或者<code>@Service</code>之类，那么我配置包扫描将其类路径全部扫描到后，启动容器的时候，这些类就会自动被spring所管理，即自动向<code>spring</code>注册，以后要注入这些组件的时候，就直接从<code>spring</code>的<code>IOC</code>容器中取出来即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注解是一系列元数据，它提供数据用来解释程序代码，注释是给人看的，注解是给编译器看的，因此注解只在编译器有效。注解的实现原理涉及反射和动态代理，关于反射已经在前面说过，动态代理还没说，留在下一节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之冰川表面</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%B0%E5%B7%9D%E8%A1%A8%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/Java基础之冰川表面/</id>
    <published>2019-02-17T10:30:34.398Z</published>
    <updated>2019-02-17T10:30:59.111Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是罗列一些关于java基础的核心点，这些点是基础中的基础，也是重点中的重点。为什么本篇文章叫做冰川表面呢？我想表达的意思是，这些基础只是一个引子，背后牵扯出来的东西可能会很多，面试往往都是从基础的知识点慢慢深入挖掘的，所以千万不能忽视对于它们的复习。</p><a id="more"></a><h1>一、关键字</h1><h2>final</h2><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，<code>final</code> 使数值不变；</li><li>对于引用类型，<code>final</code> 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>2. 方法</strong></p><p>声明方法不能被子类覆盖。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是覆盖基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h2>static</h2><p><strong>1. 静态变量</strong></p><p>静态变量在内存中只存在一份，只在类初始化时赋值一次。</p><ul><li>静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;        <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（<code>abstract</code>）。</p><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><p><strong>4. 静态内部类</strong></p><p>内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure><p>在使用静态变量和方法时不用再指明 <code>ClassName</code>，从而简化代码，但可读性大大降低。</p><p><strong>6. 变量赋值顺序</strong></p><p>静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行，静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。</p><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h1>二、Object 通用方法</h1><h2>概览</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2>equals()</h2><p><strong>1. equals() 与 == 的区别</strong></p><ul><li>对于基本类型，<code>==</code> 判断两个值是否相等，基本类型没有 <code>equals()</code> 方法。</li><li>对于引用类型，<code>==</code> 判断两个实例是否引用同一个对象，而 <code>equals()</code> 判断引用的对象是否等价。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>默认情况下也就是从超类<code>Object</code>继承而来的<code>equals</code>方法与<code>==</code>是完全等价的，比较的都是对象的内存地址，但我们可以重写<code>equals</code>方法，使其按照我们的需求的方式进行比较，如<code>String</code>类重写了<code>equals</code>方法，使其比较的是字符的序列，而不再是内存地址。</p><p><strong>2. 等价关系</strong></p><p>（一）自反性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（二）对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（三）传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><p>（四）一致性</p><p>多次调用 <code>equals()</code> 方法结果不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（五）与 <code>null</code> 的比较</p><p>对任何不是 <code>null</code> 的对象 <code>x</code> 调用 <code>x.equals(null)</code> 结果都为 <code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.euqals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 <code>true</code>；</li><li>检查是否是同一个类型，如果不是，直接返回 <code>false</code>；</li><li>将 <code>Object</code> 实例进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>hashCode()</h2><p><code>hasCode()</code> 返回散列值，而 <code>equals()</code> 是用来判断两个实例是否等价。等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</p><p>在覆盖 <code>equals()</code> 方法时应当总是覆盖 <code>hashCode()</code> 方法，保证等价的两个实例散列值也相等。</p><p>下面的代码中，新建了两个等价的实例，并将它们添加到 <code>HashSet</code> 中。我们希望将这两个实例当成一样的，只在集合中添加一个实例，但是因为 <code>EqualExample</code> 没有实现 <code>hasCode()</code> 方法，因此这两个实例的散列值是不同的，最终导致集合添加了两个等价的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><blockquote><p>之所以选择31，是因为它是个奇素数，如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算。使用素数的好处并不是很明显，但是习惯上都使用素数来计算散列结果。31有个很好的特性，就是用移位和减法来代替乘法，可以得到更好的性能：31*i==(i&lt;&lt;5)-i。现在的VM可以自动完成这种优化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>clone()</h2><p><strong>1. cloneable</strong></p><p><code>clone()</code> 是 <code>Object</code> 的受保护方法，这意味着，如果一个类不显式去覆盖 <code>clone()</code> 就没有这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</span></span><br></pre></td></tr></table></figure><p>接下来覆盖 <code>Object</code> 的 <code>clone()</code> 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneTest</span><br></pre></td></tr></table></figure><p>以上抛出了 <code>CloneNotSupportedException</code>，这是因为 <code>CloneTest</code> 没有实现 <code>Cloneable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p><strong>2. 深拷贝与浅拷贝</strong></p><ul><li>浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；</li><li>深拷贝：拷贝实例和原始实例的引用类型引用不同对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用 <code>clone()</code> 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。<code>Effective Java</code> 书上讲到，最好不要去使用 <code>clone()</code>，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1>四、继承</h1><h2>访问权限</h2><p>Java 中有三个访问权限修饰符：<code>private</code>、<code>default</code>、<code>protected</code> 以及<code>public</code>，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>成员可见表示其它类可以用这个类的实例访问到该成员；</li><li>类可见表示其它类可以用这个类创建对象。</li></ul><p><code>protected</code> 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>如果子类的方法覆盖了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。可以使用公有的 <code>getter</code> 和 <code>setter</code> 方法来替换公有字段。</p><h2>抽象类与接口</h2><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 <code>abstract</code> 进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title">AbstractClassExample</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated</span></span><br><span class="line">AbstractClassExample ac2 = <span class="keyword">new</span> AbstractExtendClassExample();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员（字段 + 方法）默认都是 <code>public</code> 的，并且不允许定义为 <code>private</code> 或者<code>protected</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic7-1.png" alt="image"></p><p>接口的字段默认都是 <code>static</code> 和 <code>final</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;                // Variable 'y' might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> z = <span class="number">0</span>;       <span class="comment">// Modifier 'public' is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier 'private' not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier 'protected' not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier 'private' not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated</span></span><br><span class="line">InterfaceExample ie2 = <span class="keyword">new</span> InterfaceImplementExample();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 <code>static</code> 和 <code>final</code> 类型的，而抽象类的字段没有这种限制。</li><li>接口的方法只能是 <code>public</code> 的，而抽象类的方法可以由多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的方法和域的访问权限，而不是都为 <code>public</code>。</li><li>需要继承非静态（<code>non-static</code>）和非常量（<code>non-final</code>）字段。</li></ul><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 <code>Compareable</code> 接口中的 <code>compareTo()</code> 方法；</li><li>需要使用多重继承。</li></ul><p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h2>super</h2><ul><li>访问父类的构造函数：可以使用 <code>super()</code> 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 <code>super</code> 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><h2>覆盖与重载</h2><ul><li><p>覆盖（<code>Override</code>）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法；</p></li><li><p>重载（<code>Overload</code>）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。</p></li></ul><h1>五、String</h1><h2>String, StringBuffer and StringBuilder</h2><p><strong>1. 是否可变</strong></p><ul><li><code>String</code> 不可变</li><li><code>StringBuffer</code> 和 <code>StringBuilder</code> 可变</li></ul><p><strong>2. 是否线程安全</strong></p><ul><li><code>String</code> 不可变，因此是线程安全的</li><li><code>StringBuilder</code> 不是线程安全的</li><li><code>StringBuffer</code> 是线程安全的，内部使用 <code>synchronized</code> 来同步</li></ul><h2>String 不可变的原因</h2><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 <code>String</code> 的 <code>hash</code> 值经常被使用，例如 <code>String</code> 用做 <code>HashMap</code> 的 <code>key</code>。不可变的特性可以使得 <code>hash</code> 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 <code>String</code> 对象已经被创建过了，那么就会从 <code>String Pool</code> 中取得引用。只有 <code>String</code> 是不可变的，才可能使用 <code>String Pool</code>。</p><p><strong>3. 安全性</strong></p><p><code>String</code> 经常作为参数，<code>String</code> 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 <code>String</code> 是可变的，那么在网络连接过程中，<code>String</code> 被改变，改变 <code>String</code> 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p><code>String</code> 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><h2>String.intern()</h2><p>使用 <code>String.intern()</code> 可以保证相同内容的字符串实例引用相同的内存对象。</p><p>下面示例中，<code>s1</code> 和 <code>s2</code> 采用 <code>new String()</code> 的方式新建了两个不同对象，而 <code>s3</code> 是通过 <code>s1.intern()</code> 方法取得一个对象引用，这个方法首先把 <code>s1</code> 引用的对象放到 <code>String Poll</code>（字符串常量池）中，然后返回这个对象引用。因此 <code>s3</code> 和 <code>s1</code> 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">"bbb"</span>;</span><br><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p></blockquote><h1>六、基本类型与运算</h1><h2>包装类型</h2><p>八个基本类型：</p><ul><li>boolean/1</li><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><p><code>new Integer(123)</code> 与 <code>Integer.valueOf(123)</code> 的区别在于，<code>new Integer(123)</code> 每次都会新建一个对象，而 <code>Integer.valueOf(123)</code> 可能会使用缓存对象，因此多次使用 <code>Integer.valueOf(123)</code> 会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 <code>valueOf()</code> 方法，因此多个 <code>Integer</code> 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>valueOf()</code> 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，<code>Integer</code> 缓存池的大小默认为 -128~127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><blockquote><p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener">Differences between new Integer(123), Integer.valueOf(123) and just 123<br></a></p></blockquote><h2>switch</h2><p>从 Java 7 开始，可以在 <code>switch</code> 条件判断语句中使用 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 不支持 <code>long</code>，是因为 <code>swicth</code> 的设计初衷是为那些只需要对少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是罗列一些关于java基础的核心点，这些点是基础中的基础，也是重点中的重点。为什么本篇文章叫做冰川表面呢？我想表达的意思是，这些基础只是一个引子，背后牵扯出来的东西可能会很多，面试往往都是从基础的知识点慢慢深入挖掘的，所以千万不能忽视对于它们的复习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Condition详解</title>
    <link href="http://yoursite.com/2019/02/15/thread/Condition%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/15/thread/Condition详解/</id>
    <published>2019-02-15T03:44:10.048Z</published>
    <updated>2019-02-15T03:51:51.780Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://fourcolor.oursnail.cn/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">线程间通信方式总结</a>中有一个需求：轮流打印奇数和偶数，我们用wait和notify实现了一下，但是这种方式存在弊端，就是不能精确控制唤醒哪个线程，比如现在有一个需求是轮流打印ABC该怎么办呢？</p><a id="more"></a><p>首先准备三个线程，分别执行打印方法，是一个死循环，每次休息一秒。</p><p><img src="http://bloghello.oursnail.cn/thread16-1.jpg" alt="image"></p><h2>一、wait/notify实现轮流打印ABC三个字母</h2><p>如果是不加任何控制策略的话，必然是无法保证按照<code>A</code> <code>B</code> <code>C</code>的顺序依次循环执行的，比如：</p><p><img src="http://bloghello.oursnail.cn/thread16-2.jpg" alt="image"></p><p>执行结果是：</p><p>1694620367</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么如何保证按照我们这个顺序执行呢？如果还是沿用这个方法，只能这样写：</p><p><img src="http://bloghello.oursnail.cn/thread16-3.jpg" alt="image"></p><p>思想也很简单，就是搞一个变量，规定只有0的时候才打印<code>A</code>，只有1的时候才打印<code>B</code>，只有2的时候才打印<code>C</code>。那么，对于打印<code>A</code>的线程，只要不是0就<code>wait()</code>等待，一旦等于0就打印，并且加一；对于打印<code>B</code>的线程，只要不是1就<code>wait()</code>等待，一旦等于1就打印，并且加一。剩下同理。</p><p>这样，由于<code>signal</code>是一个成员变量，初始值为0.那么三个线程中<code>PrintB</code>和<code>PrintC</code>都等待，只有<code>PrintA</code>能执行打印，然后加为1，唤醒所有等待的线程来判断，此时打印<code>A</code>的线程和打印<code>C</code>的线程发现都不符合他们打印的条件，都进入了<code>while</code>中等待了，只有打印<code>B</code>的线程发现等于1，则不进入<code>while</code>循环，打印再加一。依次反复，可以得到顺序打印的<code>A</code>、<code>B</code>、<code>C</code>。</p><p>这种方式显然很不好，是靠<code>notifyAll</code>来唤醒所有线程来实现的，那么我们能不能唤醒指定的线程呢？这样处理起来更加优雅效率也会更高！</p><h2>二、Condition来实现</h2><p><img src="http://bloghello.oursnail.cn/thread16-4.jpg" alt="image"></p><p>达到了上面一样的效果。此时，我们发现它的强大之处在于我们可以指定哪个线程唤醒了，这看起来是一点点进步，但是我们学习多线程那么长时间了，在我看来，是很大的一个进步，因为之前用<code>notify</code>是随机唤醒一个，<code>notifyAll</code>是唤醒全部，总是不能受我们的完全控制，虽然说线程的执行本身就是不确定的，因此不确定性是他们的天生属性，但是在某些场景下我们确实需要一个高效并且优雅的实现可控的方式，所以是很重要的。</p><p>它这种功能可以给我们带来什么呢？下面用它实现一个有界队列。（关于生产者消费者模式，当然也可以用了，写法非常简单，就是对照上面的例子改一下即可。）</p><h2>三、Condition实现有界队列</h2><p>我们已经接触了线程池，它里面涉及队列，有很多种队列，最常见的是<code>ArrayBlockingQueue</code>以及<code>LinkedBlockingQueue</code>，他们的源码中其实也是靠<code>Condition</code>来实现阻塞塞值和阻塞取值的。现在我们也来实现一个比较简单的<code>ArrayBlockingQueue</code>吧！</p><p>首先明确一下队列是<code>FIFO</code>的，即先进先出，那么我们要保证先插入的要先弹出。其次要注意的是当没有元素的时候要阻塞，即等待有元素了才能获取；放入元素也是同理，要等有空位的才能重新放入。</p><p>如何实现以上这种数据结构呢？关于先进的先出来，我们可以用两个指针来实现，一个叫做<code>addIndex</code>，一个叫做<code>removeIndex</code>，初始都是指向第一个元素处。当塞进来一个元素，那么<code>addIndex</code>就自增，当自增到最后一个位置，这个时候数组不一定是满的，因为有可能前面的值已经被取出去了，所以还需要一个变量<code>count</code>来标志是否已经塞满，如果满了就阻塞，否则如果<code>addIndex</code>到最后一个位置，就重新置0.</p><p>对于<code>removeIndex</code>也是相同方向移除，假设最简单的情况，就是长度为5的数组，那么第一个元素放在0位置，第二个元素放在1位置，第三个元素放在2位置，此时要移除，那么第一个元素就是我们要的最先进来的元素，我们将其移除，并且<code>removeIndex</code>加一指向第二个元素。如此反复执行。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指向的是刚入队的元素的下角标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex;</span><br><span class="line">    <span class="comment">//指向的是刚出队的元素后面一个元素的下角标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> removeIndex;</span><br><span class="line">    <span class="comment">//实际元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition putCondition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition getCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化队列的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        myQueue = <span class="keyword">new</span> Object[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列的尾部放入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == myQueue.length)&#123;</span><br><span class="line">            <span class="comment">//说明队列已经满了，需要等待一下，那么放元素的线程就要阻塞住，即等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--队列已满，不能再塞值了，我要阻塞一会...."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                putCondition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明是可以放入元素的</span></span><br><span class="line">        myQueue[addIndex++] = object;</span><br><span class="line">        <span class="keyword">if</span>(addIndex == myQueue.length)&#123;</span><br><span class="line">            addIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素的数量要加一</span></span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功向队列放入一个元素，当前队列元素个数为---"</span>+count);</span><br><span class="line">        System.out.println();</span><br><span class="line">        getCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列的头部获取元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明队列已经满了，需要等待一下，那么取元素的线程就要阻塞住，即等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--队列已空，不能再取值了，我要阻塞一会...."</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getCondition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> removeValue = (<span class="keyword">int</span>) myQueue[removeIndex];</span><br><span class="line">        myQueue[removeIndex++] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (removeIndex == myQueue.length)&#123;</span><br><span class="line">            removeIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功从队列获取一个元素，当前队列的元素个数为---"</span>+count);</span><br><span class="line">        putCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">return</span> removeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue myQueue = <span class="keyword">new</span> MyQueue(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PutThread(myQueue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TakeThread(myQueue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TakeThread(myQueue)).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyQueue myQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(MyQueue myQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myQueue = myQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"成功放入一个元素，元素为："</span>+i);</span><br><span class="line">            myQueue.put(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TakeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyQueue myQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TakeThread</span><span class="params">(MyQueue myQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myQueue = myQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>) myQueue.get();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功放入一个元素，元素为："</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>四、Condition原理概述</h2><p>我们在上面的学习中看到，对于一个线程，我们就要准备一个<code>Condition</code>对象，并且还要用可重入锁<code>ReentrantLock</code>来实现加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">public</span> Condition cp = lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> Condition cc = lock.newCondition();</span><br></pre></td></tr></table></figure><p>它的原理是什么呢？</p><p>我们看到，创建一个<code>condition</code>对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会<code>new</code>出一个<code>ConditionObject</code>对象，该类是<code>AQS</code>的一个内部类.</p><p>我们知道在锁机制的实现上，<code>AQS</code>内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，<code>condition</code>内部也是使用同样的方式，内部维护了一个 等待队列，所有调用<code>condition.await</code>方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到<code>ConditionObject</code>中有两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><p>这样我们就可以看出来<code>ConditionObject</code>通过持有等待队列的头尾指针来管理等待队列。主要注意的是<code>Node</code>类复用了在<code>AQS</code>中的<code>Node</code>类。所以理解了<code>AQS</code>就简单了。但是这个队列有一点不同，他是一个单向链表，而<code>AQS</code>中的同步队列式一个双向链表。</p><p><img src="http://bloghello.oursnail.cn/thread16-5.jpg" alt="image"></p><p>同时还有一点需要注意的是：我们可以多次调用<code>lock.newCondition()</code>方法创建多个<code>condition</code>对象，也就是一个<code>lock</code>可以持有多个等待队列。而在之前利用<code>Object</code>的方式实际上是指在对象<code>Object</code>对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的<code>Lock</code>拥有一个同步队列和多个等待队列。示意图如下：</p><p><img src="http://bloghello.oursnail.cn/thread16-6.jpg" alt="image"></p><p>如图所示，<code>ConditionObject</code>是<code>AQS</code>的内部类，因此每个<code>ConditionObject</code>能够访问到<code>AQS</code>提供的方法，相当于每个<code>Condition</code>都拥有所属同步器的引用。</p><p>好了，至此我们已经知道多次调用<code>lock.newCondition()</code>方法创建多个<code>condition</code>对象，并且实际上这个对象就是<code>ConditionObject</code>。AQS维护的同步队列是一个双向链表结构，而这个<code>Condition</code>对象维护的是一个单项链表结构。</p><h2>五、await实现原理</h2><p>当调用<code>condition.await()</code>方法后会使得当前获取<code>lock</code>的线程进入到等待队列，如果该线程能够从<code>await()</code>方法返回的话一定是该线程获取了与<code>condition</code>相关联的<code>lock</code>。<code>await()</code>方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-7.jpg" alt="image"></p><p>在当前线程调用<code>condition.await()</code>方法后，会使得当前线程释放<code>lock</code>然后加入到等待队列中，直至被<code>signal</code>/<code>signalAll</code>后会使得当前线程从等待队列中移至到同步队列中去，直到获得了<code>lock</code>后才会从<code>await</code>方法返回(跳出<code>while</code>循环那就不用继续等待了呗)，或者在等待时被中断会做中断处理。</p><p>所以对于<code>await()</code>方法来说，它实现的功能为：将要等待的线程封装成节点尾插入到等待队列中，然后跟<code>wait</code>一样释放这个等待线程的锁。这些做完了之后还需要<code>while</code>循环判断是否已经在同步队列中，这个<code>isOnsyncQueue</code>是由下面说到的<code>signal</code>方法触发的，由于此时还没有<code>signal</code>所以陷在死循环中出不来，就调用<code>lockSupport.park</code>方法使他进入等待状态；当有<code>signal</code>或者有中断发生的时候，就跳出循环，继续执行，此时如果是<code>signal</code>触发的，就会进入下一个<code>if</code>,那就调用<code>acquireQueue</code>方法，这个方法在我们之前说的<code>AQS</code>中是提及的，主要思想是如果这个节点的前驱节点是<code>head</code>那么就自旋获取锁，否则可能会阻塞。这里已经从大体上说明了这个方法的整体思路，下面继续详细分析分析。</p><p>在这段代码中，我们将知道：</p><ul><li>是怎样将当前线程添加到等待队列中去的？</li><li>释放锁的过程？</li><li>怎样才能从<code>await</code>方法退出？</li></ul><p>第一个问题：是怎样将当前线程添加到等待队列中去的？</p><p><img src="http://bloghello.oursnail.cn/thread16-8.jpg" alt="image"></p><p>这段代码就很容易理解了，将当前节点包装成<code>Node</code>，如果等待队列的<code>firstWaiter</code>为<code>null</code>的话（等待队列为空队列），则将<code>firstWaiter</code>指向当前的<code>Node</code>,否则，更新<code>lastWaiter</code>(尾节点)即可。就是通过尾插入的方式将当前线程封装的<code>Node</code>插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前我们学习<code>AQS</code>时知道同步队列是一个带头结点的链式队列，这是两者的一个区别。将当前节点插入到等待队列之后，会使当前线程释放<code>lock</code>，由<code>fullyRelease</code>方法实现，<code>fullyRelease</code>源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-9.jpg" alt="image"></p><p>调用<code>AQS</code>的模板方法<code>release</code>方法释放<code>AQS</code>的同步状态(这样也说明了退出<code>await</code>方法必须是已经获得了<code>condition</code>引用（关联）的<code>lock</code>)并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题，怎样从<code>await</code>方法退出？现在回过头再来看<code>await</code>方法有这样一段逻辑：</p><p><img src="http://bloghello.oursnail.cn/thread16-10.jpg" alt="image"></p><p>很显然，当线程第一次调用<code>condition.await()</code>方法时，会进入到这个<code>while()</code>循环中，因为判断的条件是这个线程是否在同步队列中，我们这个刚进等待队列，咋可能在同步队列。</p><p>然后通过<code>LockSupport.park(this)</code>方法使得当前线程进入等待状态，那么要想退出这个<code>await</code>方法第一个前提条件自然而然的是要先退出这个<code>while</code>循环，出口就只剩下两个地方：</p><ol><li>逻辑走到<code>break</code>退出<code>while</code>循环；</li><li><code>while</code>循环中的逻辑判断为<code>false</code>。</li></ol><p>再看代码出现第1种情况的条件是当前等待的线程被中断后代码会走到<code>break</code>退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的<code>condition</code>的<code>signal</code>或者<code>signalAll</code>方法），<code>while</code>中逻辑判断为<code>false</code>后结束<code>while</code>循环。</p><p>总结下，就是当前线程被中断或者调用<code>condition.signal</code>/<code>condition.signalAll</code>方法当前节点移动到了同步队列后 ，这是当前线程退出<code>await</code>方法的前提条件。</p><p>当退出<code>while</code>循环后就会调用<code>acquireQueued(node, savedState)</code>，这个方法在介绍AQS的底层实现时说过了，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到<code>lock</code>）。</p><p><code>await</code>方法示意图如下图：</p><p><img src="http://bloghello.oursnail.cn/thread16-11.jpg" alt="image"></p><p>如图，调用<code>condition.await</code>方法的线程必须是已经获得了<code>lock</code>，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的<code>Node</code>尾插入到等待队列中。</p><p>此外，<code>await</code>也支持超时等待和不响应中断，这里不再赘述。</p><h2>六、signal/signalAll实现原理</h2><p>调用<code>condition</code>的<code>signal</code>或者<code>signalAll</code>方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得<code>lock</code>。按照等待队列是先进先出（<code>FIFO</code>）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用<code>condition</code>的<code>signal</code>方法是将头节点移动到同步队列中。</p><p><img src="http://bloghello.oursnail.cn/thread16-12.jpg" alt="image"></p><p><code>signal</code>方法首先会检测当前线程是否已经获取<code>lock</code>，如果没有获取<code>lock</code>会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的<code>doSignal</code>方法也是基于该节点。下面我们来看看<code>doSignal</code>方法做了些什么事情，<code>doSignal</code>方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-13.jpg" alt="image"></p><p>具体逻辑请看注释，真正对头节点做处理的逻辑在<code>transferForSignal</code>中，该方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-14.jpg" alt="image"></p><p>关键逻辑请看注释，这段代码主要做了两件事情1.将头结点的状态更改为<code>CONDITION</code>；2.调用<code>enq</code>方法，将该节点尾插入到同步队列中，关于<code>enq</code>方法请看<code>AQS</code>的底层实现这篇文章。现在我们可以得出结论：调用<code>condition</code>的<code>signal</code>的前提条件是当前线程已经获取了<code>lock</code>，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从<code>await</code>方法中的<code>LockSupport.park(this)</code>方法中返回，从而才有机会使得调用<code>await</code>方法的线程成功退出，此时就要回过头去再看看<code>await</code>方法的后续处理流程了。<code>signal</code>执行示意图如下图：</p><p><img src="http://bloghello.oursnail.cn/thread16-15.jpg" alt="image"></p><p><code>sigllAll</code>与<code>sigal</code>方法的区别体现在<code>doSignalAll</code>方法上，前面我们已经知道<code>doSignal</code>方法只会对等待队列的头节点进行操作，而<code>doSignalAll</code>只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用<code>condition.await()</code>方法的每一个线程。</p><p>整理自：<a href="https://juejin.im/post/5aeea5e951882506a36c67f0" target="_blank" rel="noopener">详解Condition的await和signal等待/通知机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线程间通信方式总结&lt;/a&gt;中有一个需求：轮流打印奇数和偶数，我们用wait和notify实现了一下，但是这种方式存在弊端，就是不能精确控制唤醒哪个线程，比如现在有一个需求是轮流打印ABC该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>实现生产者消费者模式</title>
    <link href="http://yoursite.com/2019/02/13/thread/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/02/13/thread/实现生产者消费者模式/</id>
    <published>2019-02-13T05:39:59.104Z</published>
    <updated>2019-02-13T09:12:03.707Z</updated>
    
    <content type="html"><![CDATA[<p>无论是面试还是工作中，生产者和消费者模式一直是一个比较常见的问题，今天，我们用各种方式来实现它。</p><a id="more"></a><h2>前言</h2><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p><p><img src="http://bloghello.oursnail.cn/thread11-1.jpg" alt="image"></p><h2>一、wait/notify/notifyAll实现</h2><p>有一个天猫小店专门负责生产商品，用户也可以去买商品：</p><p><img src="http://bloghello.oursnail.cn/thread15-1.jpg" alt="image"></p><p>一个生产者的线程：</p><p><img src="http://bloghello.oursnail.cn/thread15-2.jpg" alt="image"></p><p>同理，一个消费者的线程：</p><p><img src="http://bloghello.oursnail.cn/thread15-3.jpg" alt="image"></p><p>下面进行测试：</p><p><img src="http://bloghello.oursnail.cn/thread15-4.jpg" alt="image"></p><p>此时的结果为：</p><p><img src="http://bloghello.oursnail.cn/thread15-5.jpg" alt="image"></p><p>由于生产大于消费，造成产能过剩。</p><h2>二、阻塞队列实现</h2><p>这个的实现已经在<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/" target="_blank" rel="noopener">JUC组件拓展-BlockingQueue</a>中实现了。不再赘述。主要就是用到阻塞的<code>put()</code>和<code>take()</code>两个方法。</p><h2>三、condition+Lock实现</h2><p>这个也很简单，就是基于<code>wait</code>和<code>notify</code>的代码稍微改一下即可。</p><p><img src="http://bloghello.oursnail.cn/thread15-7.jpg" alt="image"></p><p>生产者改为：</p><p><img src="http://bloghello.oursnail.cn/thread15-8.jpg" alt="image"></p><p>消费者跟生产者一样的改法：</p><p><img src="http://bloghello.oursnail.cn/thread15-9.jpg" alt="image"></p><p>执行效果类似。关于<code>Condition</code>接口，在<a href="">Condition详解</a>这篇文章中进行了详细介绍。</p><p>其实还有一些其他的方式也可以实现生产者消费者模型，但是我觉得最核心的就是上面讲的三种，掌握这个就不慌了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是面试还是工作中，生产者和消费者模式一直是一个比较常见的问题，今天，我们用各种方式来实现它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信方式总结</title>
    <link href="http://yoursite.com/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/13/thread/线程间通信方式总结/</id>
    <published>2019-02-13T04:02:00.062Z</published>
    <updated>2019-02-13T09:12:31.105Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中已经介绍了wait和notify的基本知识，我们知道了他们都是Object这个基类中的方法，因此每个对象都天生拥有这两个方法，可见其重要性，在多线程的学习中，他们两兄弟可以实现线程之间的通信，当然了，还有许多其他的方式实现线程间通信，下面逐一击破。</p><a id="more"></a><h2>一、前言</h2><p>开发中不免会遇到需要所有子线程执行完毕通知主线程处理某些逻辑的场景。或者是线程 A 在执行到某个条件通知线程 B 执行某个操作。</p><h2>二、等待通知机制</h2><p>即用<code>wait</code>+<code>notify</code>来实现。</p><p>案例目标：两个线程交替打印奇偶数，一共100个。注意，这也是阿里的一道面试编程题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoThreadWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwoThreadWaitNotify twoThreadWaitNotify = <span class="keyword">new</span> TwoThreadWaitNotify();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintOdd(twoThreadWaitNotify)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintEven(twoThreadWaitNotify)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印奇数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOdd</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify twoThreadWaitNotify;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintOdd</span><span class="params">(TwoThreadWaitNotify twoThreadWaitNotify)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.twoThreadWaitNotify = twoThreadWaitNotify;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(twoThreadWaitNotify.count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!twoThreadWaitNotify.flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"奇数线程开始执行，打印："</span>+twoThreadWaitNotify.count);</span><br><span class="line">                        twoThreadWaitNotify.count++;</span><br><span class="line">                        twoThreadWaitNotify.flag = <span class="keyword">true</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印偶数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintEven</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify twoThreadWaitNotify;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintEven</span><span class="params">(TwoThreadWaitNotify twoThreadWaitNotify)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.twoThreadWaitNotify = twoThreadWaitNotify;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(twoThreadWaitNotify.count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(twoThreadWaitNotify.flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"偶数线程开始执行，打印："</span>+twoThreadWaitNotify.count);</span><br><span class="line">                        twoThreadWaitNotify.count++;</span><br><span class="line">                        twoThreadWaitNotify.flag = <span class="keyword">false</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果部分截图：</p><p><img src="http://bloghello.oursnail.cn/thread10-2.jpg" alt="image"></p><p>这里的线程 <code>A</code> 和线程 <code>B</code> 都对同一个对象 <code>TwoThreadWaitNotify.class</code> 获取锁，<code>A</code> 线程调用了同步对象的 <code>wait()</code> 方法释放了锁并进入 <code>WAITING</code> 状态。</p><p><code>B</code> 线程调用了 <code>notify()</code> 方法，这样 <code>A</code> 线程收到通知之后就可以从 <code>wait()</code> 方法中返回。</p><p>这里利用了 <code>TwoThreadWaitNotify.class</code> 对象完成了通信。</p><p>有一些需要注意:</p><ul><li><code>wait()</code> 、<code>notify()</code>、<code>notifyAll()</code> 调用的前提都是获得了对象的锁(也可称为对象监视器)。</li><li>调用 <code>wait()</code> 方法后线程会释放锁，进入<code>WAITING</code> 状态，该线程也会被移动到等待队列中。</li><li>调用 <code>notify()</code> 方法会将等待队列中的线程移动到同步队列中，线程状态也会更新为 <code>BLOCKED</code></li><li>从 <code>wait()</code> 方法返回的前提是调用 <code>notify()</code> 方法的线程释放锁，<code>wait()</code> 方法的线程获得锁。</li></ul><p><strong>⭐等待通知有着一个经典范式：</strong></p><p>线程 A 作为消费者：</p><ol><li>获取对象的锁。<br>2.进入 while(判断条件)，并调用 wait() 方法。</li><li>当条件满足跳出循环执行具体处理逻辑。</li></ol><p>线程 B 作为生产者:</p><ol><li>获取对象锁。</li><li>更改与线程 A 共用的判断条件。</li><li>调用 notify() 方法。</li></ol><p>伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Thread A</span><br><span class="line"></span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    while(条件)&#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Thread B</span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    条件=false;//改变条件</span><br><span class="line">    Object.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、Join方式</h2><p><img src="http://bloghello.oursnail.cn/thread14-1.jpg" alt="image"></p><p>这个之前也是提及过的，主要是可以打断主线程让子线程先执行完，但是缺点是粒度不够细腻，我不能控制子线程在某个点停一下让其他子线程执行。</p><p><img src="http://bloghello.oursnail.cn/thread14-2.jpg" alt="image"></p><p>核心逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>join</code> 线程完成后会调用 <code>notifyAll()</code> 方法，是在 <code>JVM</code> 实现中调用，所以这里看不出来。</p><h2>四、volatile 共享内存</h2><p>因为 Java 是采用共享内存的方式进行线程通信的，所以可以采用以下方式用主线程关闭 A 线程:</p><p><img src="http://bloghello.oursnail.cn/thread14-3.jpg" alt="image"></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A执行完毕</span><br></pre></td></tr></table></figure><p>这里的 <code>flag</code> 存放于主内存中，所以主线程和线程 <code>A</code> 都可以看到。<code>flag</code> 采用 <code>volatile</code> 修饰主要是为了内存可见性。</p><h2>五、CountDownLatch 并发工具</h2><p>在前面的<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">文章</a>中我们基本知道它的使用，但是很遗憾，没有找一个比较实际的场景来描述它的功能，下面我将以一个实际场景来用<code>CountDownLatch</code>来解决这个问题。</p><p>假设小明和小红是一对夫妻，他们两准备烧一个菜，就叫做青椒炒肉丝。我们知道，要想炒出青椒炒肉丝，需要切好青椒，然后切好肉丝，如果想要肉的质感爽嫩，需要用淀粉揉一揉，加点醋，加点料酒去去腥，并且弄好了之后需要先炒一下肉。最后两样都准备好之后：即切好的青椒和预热好的肉丝，那么就可以合在一起炒一下出锅了。</p><p>假设切青椒需要3分钟，准备好肉需要5分钟，这两个同时准备好之后就可以进行烧菜了。如何最大程度上提高效率呢？</p><p>显然，就是小明切青椒，小红搞肉丝，两个人并行。这个时候，我们可以用<code>CountDownLatch</code>来模拟这个场景。</p><p>切青椒线程：</p><p><img src="http://bloghello.oursnail.cn/thread14-4.jpg" alt="image"></p><p>准备肉丝的线程：</p><p><img src="http://bloghello.oursnail.cn/thread14-5.jpg" alt="image"></p><p>测试：</p><p><img src="http://bloghello.oursnail.cn/thread14-6.jpg" alt="image"></p><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小明开始切青椒...</span><br><span class="line">小红开始准备肉丝...</span><br><span class="line">小明切好青椒了...</span><br><span class="line">小红准备好肉丝了...</span><br><span class="line">over，食材全部准备好了，一起下锅 cost:5010</span><br></pre></td></tr></table></figure><p>这里突出的就是，主线程等待两个线程都执行完了才能继续执行。</p><p><code>CountDownLatch</code> 也是基于 <code>AQS</code>(<code>AbstractQueuedSynchronizer</code>) 实现的.</p><ul><li>初始化一个 <code>CountDownLatch</code> 时告诉并发的线程，然后在每个线程处理完毕之后调用 <code>countDown()</code> 方法。</li><li>该方法会将 <code>AQS</code> 内置的一个 <code>state</code> 状态 -1 。</li><li>最终在主线程调用 <code>await()</code> 方法，它会阻塞直到 <code>state == 0</code> 的时候返回。</li></ul><p>这个功能是不是很类似于上面的<code>join</code>，但是它比<code>join</code>灵活多了。</p><h2>六、CyclicBarrier 并发工具</h2><p>这个工具类从原理上来看与<code>CountDownLatch</code>非常类似，具体的使用可以看<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">AQS实现的一些同步组件介绍</a>。他们两是有区别的。该工具可以实现 <code>CountDownLatch</code> 同样的功能，但是要更加灵活。甚至可以调用 <code>reset()</code> 方法重置 <code>CyclicBarrier</code> (需要自行捕获 <code>BrokenBarrierException</code> 处理) 然后重新执行。就不再赘述了。</p><h2>七、线程响应中断</h2><p>这个我们之前也是提过的，就是<code>interrupt</code>来实现，线程方法里面用<code>while</code>不停地判断中断标志位从而达到自主中断的目的。</p><p><img src="http://bloghello.oursnail.cn/thread14-7.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread A运行中。。</span><br><span class="line">thread A运行中。。</span><br><span class="line">thread A退出。。</span><br></pre></td></tr></table></figure><p>可以采用中断线程的方式来通信，调用了 <code>thread.interrupt()</code> 方法其实就是将 <code>thread</code> 中的一个标志属性置为了 <code>true</code>。</p><p>并不是说调用了该方法就可以中断线程，如果不对这个标志进行响应其实是没有什么作用(这里对这个标志进行了判断)。</p><p>但是如果抛出了 <code>InterruptedException</code> 异常，该标志就会被 <code>JVM</code> 重置为 <code>false</code>。</p><h2>八、线程池 awaitTermination() 方法</h2><p>这个玩意与我们知道<code>shutdown</code>方法组合使用，我们知道，调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p><p>关于<code>awaitTermination()</code>方法，接收<code>timeout</code>和<code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回<code>true</code>，否则返回<code>false</code>.因此，在<code>shutdwon</code>之后，我们可以用<code>awaitTermination()</code>不断地监测剩下的线程的执行状态，执行完毕就可以执行主线程了。</p><p><img src="http://bloghello.oursnail.cn/thread14-8.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-2] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-1] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 20:18:02.273 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:03.278 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:04.278 [main] INFO  c.c.actual.ThreadCommunication - main over</span><br></pre></td></tr></table></figure><p>最后再强调一下：</p><p>使用这个 <code>awaitTermination()</code> 方法的前提需要关闭线程池，如调用了 <code>shutdown()</code> 方法。</p><p>调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p><h2>九、管道通信</h2><p>这个方式我见到的比较少，了解一下。</p><p><img src="http://bloghello.oursnail.cn/thread14-9.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2018-03-16 19:56:43.014 [Thread-0] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 19:56:43.014 [Thread-1] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 19:56:43.130 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=0</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=1</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=2</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=3</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=4</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=5</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=6</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=7</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=8</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=9</span><br></pre></td></tr></table></figure><p>Java 虽说是基于内存通信的，但也可以使用管道通信。</p><p>需要注意的是，输入流和输出流需要首先建立连接。这样线程 B 就可以收到线程 A 发出的消息了。</p><h2>十、总结</h2><p>实际开发中可以灵活根据需求选择最适合的线程通信方式。</p><p>整理自：<a href="https://crossoverjie.top/JCSprout/#/thread/thread-communication?id=%e7%ba%bf%e7%a8%8b%e6%b1%a0-awaittermination-%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">深入理解线程通信</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的文章中已经介绍了wait和notify的基本知识，我们知道了他们都是Object这个基类中的方法，因此每个对象都天生拥有这两个方法，可见其重要性，在多线程的学习中，他们两兄弟可以实现线程之间的通信，当然了，还有许多其他的方式实现线程间通信，下面逐一击破。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC组件拓展-BlockingQueue</title>
    <link href="http://yoursite.com/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/"/>
    <id>http://yoursite.com/2019/02/12/thread/JUC组件拓展-BlockingQueue/</id>
    <published>2019-02-12T09:37:24.293Z</published>
    <updated>2019-02-12T09:37:32.361Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的线程池原理介绍中，我们了解到在核心线程被全部占用并且没有空闲线程的时候，就会把后续的线程任务先放入一个队列结构中，然后按照队列的方式去消化任务。虽然队列有很多种，但是他们都有一个共同的名字叫做阻塞队列，本文来逐个击破揭开他们的面纱。</p><a id="more"></a><h2>一、BlockingQueue</h2><p>在Java中，<code>BlockingQueue</code>是一个接口，它的实现类有<code>ArrayBlockingQueue</code>、<code>DelayQueue</code>、 <code>LinkedBlockingDeque</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>、<code>SynchronousQueue</code>等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于<code>take</code>与<code>put</code>操作的原理，却是类似的。</p><p><img src="http://bloghello.oursnail.cn/BlockingQueue%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" alt="image"></p><p><code>BlockingQueue</code> 是一个先进先出的队列（<code>Queue</code>），为什么说是阻塞（<code>Blocking</code>）的呢？是因为 <code>BlockingQueue</code> 支持当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p><img src="http://bloghello.oursnail.cn/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="image"></p><ul><li><code>add(anObject)</code>:把<code>anObject</code>加到<code>BlockingQueue</code>里,即如果<code>BlockingQueue</code>可以容纳,则返回true,否则抛出异常</li><li><code>offer(anObject)</code>:表示如果可能的话,将<code>anObject</code>加到<code>BlockingQueue</code>里,即如果<code>BlockingQueue</code>可以容纳,则返回true,否则返回false.</li><li>⭐<code>put(anObject)</code>:把<code>anObject</code>加到<code>BlockingQueue</code>里,如果<code>BlockQueue</code>没有空间,则调用此方法的线程被阻断直到<code>BlockingQueue</code>里面有空间再继续.</li><li>⭐与<code>put</code>相对应的是<code>take()</code>:取走<code>BlockingQueue</code>里排在首位的对象,若<code>BlockingQueue</code>为空,阻断进入等待状态直到<code>Blocking</code>有新的对象被加入为止</li><li><code>poll(time)</code>:取走<code>BlockingQueue</code>里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null</li></ul><div class="tip">注意：BlockingQueue 不接受 null 元素。试图 add 、 put 或 offer 一个 null  元素时，某些实现会抛出 NullPointerException 。 null 被用作指示 poll  操作失败的警戒值。</div><blockquote><p><code>BlockingQueue</code> 的各个实现都遵循了这些规则，当然我们也不用死记这个表格，知道有这么回事，然后写代码的时候根据自己的需要去看方法的注释来选取合适的方法即可。</p></blockquote><blockquote><p>一个 <code>BlockingQueue</code> 可能是有界的，如果在插入的时候，发现队列满了，那么 <code>put</code> 操作将会阻塞。通常，在这里我们说的无界队列也不是说真正的无界，而是它的容量是 <code>Integer.MAX_VALUE</code>（21亿多）。</p></blockquote><blockquote><p><code>BlockingQueue</code> 实现主要用于生产者-消费者队列，但它另外还支持<code>Collection</code> 接口。因此，举例来说，使用<code>remove(x)</code> 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</p></blockquote><blockquote><p><code>BlockingQueue</code> 的实现都是线程安全的，但是批量的集合操作如 <code>addAll</code>, <code>containsAll</code>, <code>retainAll</code> 和 <code>removeAll</code> 不一定是原子操作。如 <code>addAll(c)</code> 有可能在添加了一些元素后中途抛出异常，此时 <code>BlockingQueue</code> 中已经添加了部分元素，这个是允许的，取决于具体的实现。</p></blockquote><p>下面来看看阻塞队列的各种具体的实现类。</p><h2>二、ArrayBlockingQueue</h2><ul><li>构造函数必须带一个int参数来指明其大小</li><li>一个由数组结构组成的有界阻塞队列.</li><li>此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序.</li><li>⭐其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</li><li>⭐如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。</li><li>⭐如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</li><li>支持公平锁和非公平锁。公平的获取锁，也就是当前等待时间最长的线程先获取锁</li></ul><h2>三、LinkedBlockingQueue</h2><ul><li>大小不定的<code>BlockingQueue</code></li><li>若其构造函数带一个规定大小的参数,生成的<code>BlockingQueue</code>有大小限制</li><li>若不带大小参数,所生成的BlockingQueue的大小由<code>Integer.MAX_VALUE</code>来决定</li><li>其所含的对象是以<code>FIFO</code>(先入先出)顺序排序的</li><li>⭐链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低</li><li>最新插入的数据在尾部，最新移除的对象在头部</li></ul><h2>四、PriorityBlockingQueue</h2><ul><li>⭐类似于<code>LinkedBlockQueue</code>,但其所含对象的排序不是<code>FIFO</code>,而是依据对象的自然排序顺序或者是构造函数的<code>Comparator</code>决定的顺序</li><li>一个无界的阻塞队列</li></ul><h2>五、SynchronousQueue</h2><ul><li>⭐它是一种阻塞队列，其中每个 <code>put</code> 必须等待一个 <code>take</code>，反之亦然。</li><li>⭐同步队列没有任何内部容量，甚至连一个队列的容量都没有。</li><li>它是线程安全的，是阻塞的。</li><li>不允许使用 <code>null</code> 元素。</li><li>公平排序策略是指调用 <code>put</code> 的线程之间，或 <code>take</code> 的线程之间。</li></ul><p>一个没有容量的并发队列有什么用了？或者说存在的意义是什么？</p><p>尽管元素在<code>SynchronousQueue</code> 内部不会“停留”，但是并不意味着<code>SynchronousQueue</code> 内部没有队列。实际上<code>SynchronousQueue</code> 维护着线程队列，也就是插入线程或者移除线程在不同时存在的时候就会有线程队列。既然有队列，同样就有公平性和非公平性特性，公平性保证正在等待的插入线 程或者移除线程以<code>FIFO</code>的顺序传递资源。</p><p>它模拟的功能类似于生活中一手交钱一手交货这种情形，像那种货到付款或者先付款后发货模型不适合使用<code>SynchronousQueue</code>。首先要知道<code>SynchronousQueue</code>没有容纳元素的能力，即它的<code>isEmpty()</code>方法总是返回true，但是给人的感觉却像是只能容纳一个元素。</p><h2>六、DelayQueue</h2><ul><li><code>DelayQueue</code> 对元素进行持有直到一个特定的延迟到期。注意其中的元素必须实现 <code>java.util.concurrent.Delayed</code> 接口。</li></ul><h2>七、生产者与消费者模式</h2><p>阻塞队列的最常使用的例子就是生产者消费者模式,也是各种实现生产者消费者模式方式中首选的方式。使用者不用关心什么阻塞生产，什么时候阻塞消费，使用非常方便。</p><p><code>LinkedBlockingQueue</code>来实现一个生产者与消费者模型：</p><p><img src="http://bloghello.oursnail.cn/thread13-1.png" alt="image"></p><p>运行效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">producer1 produce 95</span><br><span class="line">producer3 produce 36</span><br><span class="line">consumer0 consumer 95</span><br><span class="line">consumer2 consumer 36</span><br><span class="line">producer0 produce 27</span><br><span class="line">consumer4 consumer 27</span><br><span class="line">producer2 produce 75</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2>八、ArrayBlockingQueue和LinkedBlockingQueue的区别</h2><ul><li>队列中锁的实现不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；另外，可以指定是否为公平锁，默认是非公平锁。</p><p><code>LinkedBlockingQueue</code>实现的队列中的锁是分离的，在队头和队尾各持有一把锁，入队和出队之间不存在竞争。即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p></blockquote><ul><li>在生产或消费时操作不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；</p><p><code>LinkedBlockingQueue</code>实现的队列中在生产和消费的时候，需要把枚举对象转换为<code>Node&lt;E&gt;</code>进行插入或移出(会生成一个额外的<code>Node</code>对象，这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。)</p></blockquote><ul><li>队列大小初始化方式不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中必须指定队列的大小；</p><p><code>LinkedBlockingQueue</code>实现的队列中可以不指定队列的大小，但是默认是<code>Integer.MAX_VALUE</code></p></blockquote><ul><li>作为开发者，我们需要注意的是，如果构造一个<code>LinkedBlockingQueue</code>对象，而没有指定其容量大小，<code>LinkedBlockingQueue</code>会默认一个类似无限大小的容量（<code>Integer.MAX_VALUE</code>），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</li><li>在使用<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>分别对1000000个简单字符做入队操作时，<code>LinkedBlockingQueue</code>的消耗是<code>ArrayBlockingQueue</code>消耗的10倍左右，即<code>LinkedBlockingQueue</code>消耗在1500毫秒左右，而<code>ArrayBlockingQueue</code>只需150毫秒左右。</li><li>按照实现原理来分析，<code>ArrayBlockingQueue</code>完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。<code>Doug Lea</code>之所以没这样去做，也许是因为<code>ArrayBlockingQueue</code>的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的线程池原理介绍中，我们了解到在核心线程被全部占用并且没有空闲线程的时候，就会把后续的线程任务先放入一个队列结构中，然后按照队列的方式去消化任务。虽然队列有很多种，但是他们都有一个共同的名字叫做阻塞队列，本文来逐个击破揭开他们的面纱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC组件拓展-ForkJoin简介</title>
    <link href="http://yoursite.com/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-ForkJoin%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/02/12/thread/JUC组件拓展-ForkJoin简介/</id>
    <published>2019-02-12T09:03:06.685Z</published>
    <updated>2019-02-12T09:36:00.427Z</updated>
    
    <content type="html"><![CDATA[<p>JUC组件拓展-ForkJoin简介，本文只是初步认识认识一下ForkJoin是什么，不深究里面的原理。</p><a id="more"></a><h2>ForkJoin</h2><h4>什么是Fork/Join框架</h4><p><code>Fork/Join</code>框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>我们再通过<code>Fork</code>和<code>Join</code>这两个单词来理解下<code>Fork/Join</code>框架，<code>Fork</code>就是把一个大任务切分为若干子任务并行的执行，<code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+。。＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。</p><p><img src="http://bloghello.oursnail.cn/ForkJoin%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="image"></p><h4>工作窃取算法</h4><p>工作窃取（<code>work-stealing</code>）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="http://bloghello.oursnail.cn/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt="image"></p><ul><li>那么为什么需要使用工作窃取算法呢？</li></ul><blockquote><p>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></blockquote><ul><li><code>Fork/Join</code>框架如何实现工作窃取的？</li></ul><blockquote><p>这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p></blockquote><ul><li><code>Fork/Join</code>框架有没有什么缺点？</li></ul><blockquote><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></blockquote><ul><li>该如何设计一个<code>Fork/Join</code>框架?</li></ul><blockquote><p>第一步分割任务。首先我们需要有一个<code>fork</code>类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p><p>第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p></blockquote><p>这里就先简单介绍一下，如果有必要，以后再细谈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JUC组件拓展-ForkJoin简介，本文只是初步认识认识一下ForkJoin是什么，不深究里面的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS实现的一些并发工具类</title>
    <link href="http://yoursite.com/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/12/thread/AQS实现的一些并发工具类/</id>
    <published>2019-02-12T08:52:41.518Z</published>
    <updated>2019-02-15T08:27:44.200Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们已经深入了解了AQS原理，本节介绍几个常用的基于AQS实现的并发工具类。</p><a id="more"></a><h2>一、CountDownLatch</h2><p>计数器减到0，处于等待的线程才会继续执行。只能用一次，不能重置。</p><p>比如有一个运算量很大的任务，我们可以将它拆分为多个子任务，等所有子任务全部完成之后，再执行最后的汇总工作。</p><p><img src="http://bloghello.oursnail.cn/CountDownLatch.png" alt="image"></p><p>下面用一个实例来看看它是如何使用的：</p><p><img src="http://bloghello.oursnail.cn/thread12-1.jpg" alt="image"></p><p>运行结果，截取了最后一点：</p><p><img src="http://bloghello.oursnail.cn/thread12-2.jpg" alt="image"></p><p>我们可以看到，主程序等待所有的子程序执行完毕，再执行，它是通过<code>await()</code>阻塞等待，直到计数器的值减到0为止。</p><p>那如果是这种场景呢：计算若干个子任务，给定一个时间，超过这个时间的话，就把这个任务放弃掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h2>二、Semaphore</h2><p>能控制同一时间并发线程的数目</p><blockquote><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。很多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-14/16690827.jpg" alt="image"></p><p><code>Semaphore</code>可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用<code>Semaphore</code>来做流控，代码如下：</p><p><img src="http://bloghello.oursnail.cn/thread12-3.jpg" alt="image"></p><p>再来一个例子：</p><p><img src="http://bloghello.oursnail.cn/thread12-4.jpg" alt="image"></p><blockquote><p>这里是一个线程获取一个许可，那么同一时间，可以有三个线程进来一起工作。那如果我改成一个线程获取三个许可呢？就像一个人同时占三个坑位，那么只有等这个人拉完了才能轮到下一个人了，那么此时就变成跟单线程一样了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">3</span>);</span><br><span class="line">test(threadNum);</span><br><span class="line">semaphore.release(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>考虑这个场景：并发太高了，就算是控制线程数量，也比较棘手；一个厕所三个坑位，外面人太多了，让三个人进来，其他的都给轰走。如何做到呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(semaphore.tryAcquire())&#123;<span class="comment">//尝试获取一个许可</span></span><br><span class="line">    test(threadNum);</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：只有三条信息打印出来，其他的线程就都被丢弃了。</p><p>也可以给他一个超时时间，这里是5000毫秒。每个命令需要运行1000毫秒，那么程序等1000毫秒之后会打印三条；然后再等1000毫秒，又可以拿到新的三个许可，再打印三条；直到5000毫秒用完。可能会打印3*5条记录。剩下的5条记录由于已经超时，全部被放弃掉。</p><h2>三、CyclicBarrier</h2><blockquote><p><code>CyclicBarrier</code>也是一个同步辅助类 , 它允许一组线程相互等待 , 直到到达某个公共的屏障点 , 通过它可以完成多个线程之间相互等待 ,只有当每个线程都准备好之后, 才能各自继续往下执行后续的操作, 和 <code>CountDownLatch</code>相似的地方就是, 它也是通过计数器来实现的. 当某个线程调用了 <code>await()</code>方法之后, 该线程就进入了等待状态 . 而且计数器就进行 -1 操作 , 当计数器的值达到了我们设置的初始值0的时候 , 之前调用了<code>await()</code> 方法而进入等待状态的线程会被唤醒继续执行后续的操作. 因为 <code>CyclicBarrier</code>释放线程之后可以重用, 所以又称之为循环屏障 . <code>CyclicBarrier</code> 使用场景和  <code>CountDownLatch</code> 很相似 , 可以用于多线程计算数据, 最后合并计算结果的应用场景 .</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-14/65784628.jpg" alt="image"></p><p>两者的区别：</p><ul><li><p><code>CountDownLatch</code>的计数器只能使用一次 , 而 <code>CyclicBarrier</code> 的计数器可以使用 <code>reset</code>重置 循环使用</p></li><li><p><code>CountDownLatch</code> 主要是 1 个 或者 n 个线程需要等待其它线程完成某项操作之后才能继续往下执行 , 其描述的是 1 个 或者 n 个线程与其它线程的关系 ; CyclicBarrier 主要是实现了 1 个或者多个线程之间相互等待,直到所有的线程都满足条件之后, 才执行后续的操作 , 其描述的是内部各个线程相互等待的关系 .</p></li></ul><p><code>CyclicBarrier</code> 假如有 5 个线程都调用了 <code>await()</code> 方法 , 那这个 5 个线程就等着 , 当这 5 个线程都准备好之后, 它们有各自往下继续执行 , 如果这 5 个线程在后续有一个计算发生错误了 , 这里可以重置计数器 , 并让这 5 个线程再执行一遍 .</p><p><img src="http://bloghello.oursnail.cn/thread12-5.jpg" alt="image"></p><p>运行效果：先每隔一秒执行<code>race</code>方法打印出<code>ready</code>,等3个线程打印完毕，立即都将阻塞的<code>log.info(&quot;continue...&quot;);</code>全部打印出来。</p><p><img src="http://bloghello.oursnail.cn/thread12-6.jpg" alt="image"></p><p>也可以设定超时时间，超过时间了就不等了。</p><p><img src="http://bloghello.oursnail.cn/thread12-7.jpg" alt="image"></p><p>如果在大家已经都准备好了的时候，可以先做一件事情，即初始化执行一个线程，可以在声明<code>CyclicBarrier</code>后面增加一个线程来执行。</p><p>就像开会，人都到齐了之后，我们喊一声，人都到齐，我们现在开始开会了啊。下面就开始正式开会。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>,() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"callback is running..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2>四、Exchanger</h2><p><code>Exchanger</code> 类表示一种会合点，两个线程可以在这里交换对象。两个线程各自调用<code>exchange</code> 方法进行交换，当线程 <code>A</code> 调用 <code>Exchange</code> 对象的 <code>exchange</code> 方法后，它会陷入阻塞状态，直到线程 <code>B</code> 也调用了 <code>exchange</code> 方法，然后以线程安全的方式交换数据，之后线程 <code>A</code> 和 <code>B</code> 继续运行。</p><p><img src="http://bloghello.oursnail.cn/thread12-8.png" alt="image"></p><p><code>exchange</code> 方法有两个重载实现，在交换数据的时候还可以设置超时时间。如果一个线程在超时时间内没有其他线程与之交换数据，就会抛出 <code>TimeoutException</code> 超时异常。如果没有设置超时时间，则会一直等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换数据，并设置超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br><span class="line"><span class="function"><span class="comment">//交换数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>下面看一个小例子：</p><p><img src="http://bloghello.oursnail.cn/thread12-9.png" alt="image"></p><p>我们要注意，交换的时候两个线程要同时到达一个汇合点才会继续执行，即这里的a线程拿到b线程的值并且b拿到a的值，程序才会继续执行。</p><p><img src="http://bloghello.oursnail.cn/thread12-10.png" alt="image"></p><p>例子很简单，当两个线程都到达调用<code>exchange</code>方法的同步点的时候，两个线程就能交换彼此的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面我们已经深入了解了AQS原理，本节介绍几个常用的基于AQS实现的并发工具类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池原理详解</title>
    <link href="http://yoursite.com/2019/02/12/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/12/thread/线程池原理详解/</id>
    <published>2019-02-12T07:36:14.209Z</published>
    <updated>2019-02-13T03:52:57.801Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA帮助开发者封装了一些现成的线程池调用，但是每种线程池都有自己的使用场景，如果不了解里面的原理，那么很容易掉进坑里，线程池原理也是面试的重灾区，因此本问将完整分析线程池的原理。</p><a id="more"></a><h2>一、new thread弊端</h2><p>从学习java多线程开始，我们就学习了用<code>new thread</code>来创建线程。但是他有一定的弊端：</p><ul><li>每次<code>new Thread</code>新建对象，性能差</li><li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM</li><li>缺少更多功能，如更多执行、定期执行、线程中断</li></ul><h2>二、线程池好处</h2><ul><li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li><li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li><li>提供定时执行、定期执行、单线程、并发数控制等功能</li></ul><h2>三、线程池相关参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>:核心线程数量</li></ul><blockquote><p>默认情况下，在创建了线程池后，线程池中的线程数为0，<br>（除非调用<code>prestartAllCoreThreads()</code>和<code>prestartCoreThread()</code>方法，从方法名字可以看出，是预创建线程的意思，即在没有任务到来之前，就创建<code>corePoolSize</code>个线程或1个线程）当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中；</p><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p></blockquote><ul><li><code>maximumPoolSize</code>:线程最大线程数</li></ul><blockquote><p>线程池中的最大线程数，表示线程池中最多能创建多少个线程。</p><p>超过就执行<code>reject</code>策略:如果队列满了,并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务</p></blockquote><ul><li><code>workQueue</code>:阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响，一般有以下几种选择：</li></ul><blockquote><p><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序；</p><p><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于<code>ArrayBlockingQueue</code>。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列；</p><p><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列；</p><p><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列；底层用<code>DelayedWorkQueue</code>实现。</p></blockquote><ul><li><code>keepAliveTime</code>：线程没有任务执行时最多保持多久时间终止</li></ul><blockquote><p>当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。（但是如果调用了<code>allowCoreThreadTimeOut(boolean value)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0；）</p></blockquote><ul><li><code>unit</code>:<code>keepAliveTime</code>的时间单位</li><li><code>threadFactory</code>：线程工厂，用来创建线程</li></ul><blockquote><p><code>threadFactory</code>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</p></blockquote><ul><li><code>handler</code>:饱和策略</li></ul><blockquote><p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。</p></blockquote><p>这些参数全部传给<code>ThreadPoolExecutor</code>之后，<code>ThreadPoolExecutor</code>就可以为我们提供一个线程池，我们可以对这个线程池提交以及终止线程任务。</p><h2>四、饱和策略</h2><p>当线程池中已经到了完全没有办法再接收新的线程进来的时候，就会启动饱和策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</span><br></pre></td></tr></table></figure><ol><li><code>AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常（默认）</li><li><code>CallerRunsPolicy</code>：只用调用所在的线程运行任务</li><li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li><code>DiscardPolicy</code>：不处理，丢弃掉,不抛出异常。</li></ol><h2>五、线程池的源码解读</h2><p>程序中要声明线程池，是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">exec.excute(Runnable command);</span><br></pre></td></tr></table></figure><p>先来看看<code>ExecutorService</code>其中的奥秘。</p><h5>5.1 ExecutorService和Executor的关系</h5><p><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为<code>void</code>，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>ExecutorService</code>具备管理执行器和任务生命周期的方法，提交任务机制更加完善。<code>Executor</code>只是运行新任务的简单接口，目的是将任务提交和任务执行解耦。</p><h5>5.2 ThreadPoolExecutor重要方法</h5><p>我们知道，在执行<code>Executors.newCachedThreadPool()</code>的时候，内部是调用<code>ThreadPoolExecutor</code>的构造函数来生成<code>Exceutors</code>对象，即生成了线程池，因为继承关系是：<code>ThreadPoolExecutor extends AbstractExecutorService implements ExecutorService extends Executor</code>。构建好之后，就可以构建工作线程去执行任务。其中，流程是这样的：</p><p><img src="http://bloghello.oursnail.cn/thread11-2.jpg" alt="image"></p><p>所以，用于<code>execute()</code>或者<code>submit()</code>的线程任务都是被封装成<code>worker</code>去执行的。下面来看看<code>execute()</code>和<code>submit()</code>等核心方法。</p><p>在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p><ul><li><code>execute()</code></li></ul><blockquote><p><code>execute()</code>方法实际上是<code>Executor</code>中声明的方法，在<code>ThreadPoolExecutor</code>进行了具体的实现，这个方法是<code>ThreadPoolExecutor</code>的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p></blockquote><ul><li><code>submit()</code></li></ul><blockquote><p><code>submit()</code>方法是在<code>ExecutorService</code>中声明的方法,这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code>方法不同，它能够返回任务执行的结果，去看<code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了<code>Future</code>来获取任务执行结果。</p></blockquote><ul><li><code>shutdown()</code><br>将线程池状态置为<code>SHUTDOWN</code>,并不会立即停止：</li></ul><blockquote><p>停止接收外部<code>submit</code>的任务内部正在跑的任务和队列里等待的任务，会执行完等到第二步完成后，才真正停止</p></blockquote><ul><li><code>shutdownNow()</code><br>将线程池状态置为<code>STOP</code>。企图立即停止，事实上不一定：</li></ul><blockquote><p>跟<code>shutdown()</code>一样，先停止接收外部提交的任务忽略队列里等待的任务尝试将正在跑的任务<code>interrupt</code>中断返回未执行的任务列表</p><p>它试图终止线程的方法是通过调用<code>Thread.interrupt()</code>方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有<code>sleep</code> 、<code>wait</code>、<code>Condition</code>、定时锁等应用, <code>interrupt()</code>方法是无法中断当前的线程的。所以，<code>ShutdownNow()</code>并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。但是大多数时候是能立即退出的</p></blockquote><ul><li><code>awaitTermination(long timeOut, TimeUnit unit)</code></li></ul><blockquote><p>接收<code>timeout</code>和<code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回<code>true</code>，否则返回<code>false</code>。一般情况下会和<code>shutdown</code>方法组合使用。</p></blockquote><h5>5.3 Executors生成线程池</h5><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>Executors</code>类里面提供了一些静态工厂，生成一些常用的线程池。这个就涉及上面我们反复提及的核心类：<code>ThreadPoolExecutor</code>。</p><p>⭐其实都是通过调用<code>ThreadPoolExecutor</code>来完成的，最后可以返回<code>ExecutorService</code>对象，其实说白了都是<code>Excutor</code>对象。</p><p>下面来分别看看比较常用的线程池。</p><ul><li><code>newSingleThreadExecutor</code></li></ul><blockquote><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为1的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="comment">//线程由DefaultThreadFactory默认创建，有统一的命名规范，并且优先级是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                               threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:10,index:1</span><br><span class="line">task:10,index:2</span><br><span class="line">task:10,index:3</span><br><span class="line">task:10,index:4</span><br><span class="line">task:10,index:5</span><br><span class="line">task:10,index:6</span><br><span class="line">task:10,index:7</span><br><span class="line">task:10,index:8</span><br><span class="line">task:10,index:9</span><br></pre></td></tr></table></figure><p>运行结果分析：单线程+有序。</p><ul><li><code>newFixedThreadPool</code></li></ul><blockquote><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为nThreads的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:11,index:1</span><br><span class="line">task:11,index:3</span><br><span class="line">task:11,index:4</span><br><span class="line">task:11,index:5</span><br><span class="line">task:11,index:6</span><br><span class="line">task:11,index:7</span><br><span class="line">task:11,index:8</span><br><span class="line">task:11,index:9</span><br><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br></pre></td></tr></table></figure><p>结果分析：只创建了三个线程来执行。</p><ul><li><code>newCachedThreadPool</code></li></ul><blockquote><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个按需创建线程的线程池，初始线程个数为0，最多线程个数为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为同步队列</span></span><br><span class="line"><span class="comment">//keeyAliveTime=60说明只要当前线程60s内空闲则回收</span></span><br><span class="line"><span class="comment">//特殊在于加入到同步队列的任务会被马上被执行，同步队列里面最多只有一个任务，并且存在后马上会拿出执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br><span class="line">task:14,index:4</span><br><span class="line">task:16,index:6</span><br><span class="line">task:18,index:8</span><br><span class="line">task:11,index:1</span><br><span class="line">task:13,index:3</span><br><span class="line">task:15,index:5</span><br><span class="line">task:17,index:7</span><br><span class="line">task:19,index:9</span><br></pre></td></tr></table></figure><p>结果分析：按需创建线程，几乎一次循环就创建了一个新的线程来执行。</p><ul><li><code>newScheduledThreadPool</code></li></ul><blockquote><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多长时间之后执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时执行，这里是每隔3秒执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);<span class="comment">//一开始延迟1秒执行任务，之后每隔3秒执行一次任务，不适合调用exec.shutdown();，因为会被关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>newSingleThreadScheduledExecutor</code></li></ul><blockquote><p>创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize为1，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上。demo不再赘述。</p><h5>5.4  线程池实现原理–线程池状态</h5><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt="image"></p><ul><li><code>static final int RUNNING = 0;</code></li></ul><blockquote><p>当创建线程池后，初始时，线程池处于RUNNING状态；</p></blockquote><ul><li><code>static final int SHUTDOWN = 1;</code></li></ul><blockquote><p>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p></blockquote><ul><li><code>static final int STOP = 2;</code></li></ul><blockquote><p>如果调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p></blockquote><ul><li><code>static final int TERMINATED = 3;</code></li></ul><blockquote><p>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</p></blockquote><h5>6.5 线程池实现原理–任务的执行</h5><p><code>corePoolSize</code>与<code>maximumPoolSize</code>的关系举个简单的例子形象理解就是：</p><blockquote><p>假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p><p>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p><p>然后就将任务也分配给这4个临时工人做；</p><p>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p></blockquote><p>这个例子中的<code>corePoolSize</code>就是10，而<code>maximumPoolSize</code>就是14（10+4）。</p><p><code>maximumPoolSize</code>可以看作是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>在<code>ThreadPoolExecutor</code>类中，最核心的任务提交方法是<code>execute()</code>方法，虽然通过<code>submit</code>也可以提交任务，但是实际上<code>submit</code>方法里面最终调用的还是<code>execute()</code>方法，所以我们只需要研究<code>execute()</code>方法的实现原理即可：</p><p>注：<code>execute()</code>方法和<code>submit()</code>方法已经在前面讲过区别了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">     <span class="comment">// Proceed in 3 steps:</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 1. </span></span><br><span class="line">     <span class="comment">// 判断当前的线程数是否小于corePoolSize,如果是，使用入参任务通过addWord方法创建一个新的线程，</span></span><br><span class="line">     <span class="comment">// 如果能完成新线程创建exexute方法结束，成功提交任务</span></span><br><span class="line">     <span class="comment">// 2. </span></span><br><span class="line">     <span class="comment">// 在第一步没有完成任务提交；状态为运行并且能够成功加入任务到工作队列后，再进行一次check，如果状态</span></span><br><span class="line">     <span class="comment">// 在任务加入队列后变为了非运行（有可能是在执行到这里线程池shutdown了），非运行状态下当然是需要</span></span><br><span class="line">     <span class="comment">// reject；然后再判断当前线程数是否为0（有可能这个时候线程数变为了0），如是，新增一个线程；</span></span><br><span class="line">     <span class="comment">// 3. </span></span><br><span class="line">     <span class="comment">// 如果不能加入任务到工作队列，将尝试使用任务新增一个线程，如果失败，则是线程池已经shutdown或者线程池</span></span><br><span class="line">     <span class="comment">// 已经达到饱和状态，所以reject这个任务</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果工作线程数大于等于核心线程数</span></span><br><span class="line">    <span class="comment">// 线程的的状态为RUNNING并且队列notfull</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查线程的运行状态，如果不是RUNNING直接从队列中移除</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 移除成功，拒绝该非运行的任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">            <span class="comment">// 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列满了或者是非运行的任务都拒绝执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的程序流程图为：</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B111.png" alt="image"></p><p>为了理解更加得透彻，用下图配合文字总结一下：</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86111.png" alt="image"></p><ul><li>1.如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>2.如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>3.如果无法将任务加入<code>BlockingQueue</code>（队列已满），则在非<code>corePool</code>中创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li><li>4.如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ul><blockquote><p><code>ThreadPoolExecutor</code>采取上述步骤的总体设计思路，是为了在执行<code>execute()</code>方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JAVA帮助开发者封装了一些现成的线程池调用，但是每种线程池都有自己的使用场景，如果不了解里面的原理，那么很容易掉进坑里，线程池原理也是面试的重灾区，因此本问将完整分析线程池的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从CAS到Atomic包原理</title>
    <link href="http://yoursite.com/2019/02/12/thread/%E4%BB%8ECAS%E5%88%B0Atomic%E5%8C%85%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/12/thread/从CAS到Atomic包原理/</id>
    <published>2019-02-12T03:48:48.284Z</published>
    <updated>2019-02-12T03:54:21.871Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，volatile保证了可见性，但是不能保证原子性，在面对线程安全问题时，就显地力不从心，那么除了synchronized关键字外，还有什么方式可以实现线程安全更新呢？本文首先介绍CAS是什么，引出JUC下一个重要的包：Atomic包。</p><a id="more"></a><h2>一、CAS简介</h2><p><code>CAS</code>（<code>Compare and Swap</code>），即比较并替换，实现并发算法时常用到的一种技术，<code>Doug lea</code>大神在java同步器中大量使用了<code>CAS</code>技术，鬼斧神工的实现了多线程执行的安全性。</p><p><code>CAS</code>的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回<code>true</code>，否则什么都不做，并返回<code>false</code>。</p><h2>二、n++问题</h2><p><img src="http://bloghello.oursnail.cn/thread9-1.jpg" alt="image"></p><p>通过<code>javap -verbose Case</code>看看<code>add</code>方法的字节码指令：</p><p><img src="http://bloghello.oursnail.cn/thread9-2.jpg" alt="image"></p><p>我们可以看到，<code>n++</code>被拆分成了下面几个指令：</p><ul><li>执行<code>getfield</code>拿到原始<code>n</code>；</li><li>执行<code>iadd</code>进行加1操作；</li><li>执行<code>putfield</code>写把累加后的值写回<code>n</code>；</li></ul><p>通过<code>volatile</code>修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果，那么应该如何解决呢？</p><p>这里顺便提一下线程安全三个特性</p><ul><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程观察到。</li><li>有序性：一个线程观察其他线程中的指令的执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ul><p>可以看到原子性是线程安全的一大特性。</p><h2>三、解决方案一</h2><p>在<code>add</code>方法加上<code>synchronized</code>修饰解决。</p><p><img src="http://bloghello.oursnail.cn/thread9-3.jpg" alt="image"></p><p>这个方案当然可行，但是性能上差了点，还有其它方案么？</p><h2>四、解决方案二</h2><p>我们可不可以用一下乐观锁的思想呢？即不加锁，等真正要赋值的时候比较一下。</p><p><img src="http://bloghello.oursnail.cn/thread9-4.jpg" alt="image"></p><p>当然了，这段代码如果真的在并发下执行，肯定出问题，只有把这整个过程变成一个原子操作才行，即同一时刻只有一个线程才能修改变量<code>a</code>。</p><p>如何实现呢？</p><p>我们注意到JUC下有个好东西，以<code>Atomic</code>打头的一些类。就可以很好地帮助我们实现对一个数加一减一的原子性操作。比如我们要安全地对<code>n</code>加一，可以这样做：</p><p><img src="http://bloghello.oursnail.cn/thread9-5.jpg" alt="image"></p><p>下面就以<code>AtomicInteger</code>的实现为例，分析一下<code>CAS</code>是如何实现的。</p><p><img src="http://bloghello.oursnail.cn/thread9-6.jpg" alt="image"></p><ul><li><code>Unsafe</code>，是<code>CAS</code>的核心类，由于Java方法无法直接访问底层系统，需要通过本地（<code>native</code>）方法来访问，<code>Unsafe</code>相当于一个后门，基于该类可以直接操作特定内存的数据。</li><li>变量<code>valueOffset</code>，表示该变量值在内存中的偏移地址，因为<code>Unsafe</code>就是根据内存偏移地址获取数据的。</li><li>变量<code>value</code>用<code>volatile</code>修饰，保证了多线程之间的内存可见性。</li></ul><p>看看<code>AtomicInteger</code>如何实现并发下的累加操作：</p><p><img src="http://bloghello.oursnail.cn/thread9-7.jpg" alt="image"></p><p>假设线程<code>A</code>和线程<code>B</code>同时执行<code>getAndIncrement</code>操作（分别跑在不同CPU上）：</p><ul><li>假设<code>AtomicInteger</code>里面的<code>value</code>原始值为0，即主内存中<code>AtomicInteger</code>的<code>value</code>为0，根据Java内存模型，线程A和线程B各自持有一份<code>value</code>的副本，值为0。</li><li>线程A通过<code>getIntVolatile(var1, var2)</code>拿到<code>value</code>值0，这时线程A被挂起。</li><li>线程B也通过<code>getIntVolatile(var1, var2)</code>方法获取到<code>value</code>值0，运气好，线程B没有被挂起，并执行<code>compareAndSwapInt</code>方法比较内存值也为0，成功修改内存值为1。</li><li>这时线程A恢复，执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值(0)和内存的值(1)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li><li>重新获取<code>value</code>值，因为变量<code>value</code>被<code>volatile</code>修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功。</li></ul><p>整个过程中，利用<code>CAS</code>保证了对于<code>value</code>的修改的并发安全，继续深入看看<code>Unsafe</code>类中的<code>compareAndSwapInt</code>方法实现。</p><p><img src="http://bloghello.oursnail.cn/thread9-8.jpg" alt="image"></p><p>我们看到是一个本地方法，并且在每个操作系统的具体实现都是不大一样的，这里我们就不再深究了。只要知道它的比较和替换是一个原子操作即可。</p><h2>五、其他重要的Atomic类</h2><h5>5.1 LongAdder</h5><p>上面提到了<code>AtomicInteger</code>，那么必然也存在``AtomicLong`。用法和原理是一样的。</p><p>既然用<code>LongAddr</code>也可以，但是为什么不使用<code>AtomicLong</code>呢？换句话说，为什么<code>AtomicLong</code>可以实现，还要有<code>LongAddr</code>这个类呢？？？</p><p><code>LongAddr</code>优点：我们从<code>AtomicInteger</code>这个类的实现看到，他是在一个死循环内不停地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功的几率很高。否则修改失败的概率就会很高。在大量修改失败的时候，多次尝试，性能会受到一定的影响。</p><p>对于普通类型的<code>Long</code>和<code>Double</code>变量，JVM允许将64位的读操作和写操作拆成两个32位的操作。</p><blockquote><p>我们知道<code>JUC</code>下面提供的原子类都是基于<code>Unsafe</code>类实现的，并由<code>Unsafe</code>来提供<code>CAS</code>的能力。<code>CAS</code> (<code>compare-and-swap</code>)本质上是由现代<code>CPU</code>在硬件级实现的原子指令，允许进行无阻塞，多线程的数据操作同时兼顾了安全性以及效率。<code>getAndAddLong</code>方法会以<code>volatile</code>的语义去读需要自增的域的最新值，然后通过<code>CAS</code>去尝试更新，正常情况下会直接成功后返回，但是在高并发下可能会同时有很多线程同时尝试这个过程，也就是说线程A读到的最新值可能实际已经过期了，因此需要在<code>while</code>循环中不断的重试，造成很多不必要的开销。</p></blockquote><p>将<code>AtomicLong</code>核心数据<code>value</code>分离成一个数组，每个线程访问时，通过<code>hash</code>等算法，映射到其中一个数字进行计数。最终的计数结果则为这个数组的求和累加。其中热点数据<code>value</code>会被分离成多个单元的<code>cell</code>，每个<code>cell</code>独自维护内部的值，当前对象的实际值由<code>cell</code>累计合成。这样，热点就得到有效的分离并提高了并行度。 <code>LongAddr</code>在<code>AtomicLong</code>基础上将单点的更新压力分散到各个节点上。低并发时通过对<code>base</code>直接更新，得到与<code>AtomicLong</code>一样的性能。</p><div class="tip">缺陷：统计的时候，如果有并发更新，会有统计的误差，例如获取一个全局唯一的ID还是采用`AtomicLong`更好一点。</div><h5>5.2 AtomicReference</h5><p>这个其实很简单，用法如下：</p><p><img src="http://bloghello.oursnail.cn/thread9-9.jpg" alt="image"></p><p>其实这个方法实现的是对一个共享对象的原子性操作，保证对象更新的原子性。</p><h5>5.3 AtomicIntegerFieldUpdater</h5><p>假设现在有这样的一个场景： 一百个线程同时对一个int对象进行修改，要求只能有一个线程可以修改。</p><p>可能有的同学会这么写：</p><p><img src="http://bloghello.oursnail.cn/thread9-10.jpg" alt="image"></p><p>我们来分析一下，对于<code>volatile</code>变量，写的时候会将线程本地内存的数据刷新到主内存上，读的时候会将主内存的数据加载到本地内存里，所以可以保证可见行和单个读/写操作的原子性。</p><p>但是上例中先</p><ul><li>先判断:<code>!ischanged</code></li><li>再执行赋值操作：<code>ischanged=true</code></li></ul><p>该组合操作就不能保证原子性了，也就是说线程A A1-&gt;A2 , 线程B B1-&gt;B2 (第一个操作为<code>volatile</code>读或者第二个操作为<code>volatile</code>写的时候，编译器不会对两个语句重排序，所以最后的执行顺序满足顺序一致性模型的)，但是最后的执行结果可能是A1-&gt;B1-&gt;A2-&gt;B2。不满足需求.</p><p>这种情况下，<code>AtomicIntegerFieldUpdater</code>就可以派上用场了。</p><p><img src="http://bloghello.oursnail.cn/thread9-11.jpg" alt="image"></p><p>对于这个代码的理解可以用下面这个代码来：</p><p><img src="http://bloghello.oursnail.cn/thread9-12.jpg" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update success 1:200</span><br><span class="line">update fail</span><br></pre></td></tr></table></figure><p>用<code>AtomicIntegerFieldUpdater.newUpdater</code>指定类里面的属性。这里我们要更新<code>Test</code>类里面的<code>A</code>字段（必须是<code>volatile</code>且不是<code>static</code>对象）。<code>update.compareAndSet()</code>方法使用<code>cas</code>机制，每次提交的时候都比较下<code>test.a</code>是不是100，如果是，则更新。</p><p>注意，不能使用<code>final</code>变量，因为语义冲突。对于<code>AtomicIntegerFieldUpdater</code>和<code>AtomicLongFieldUpdater</code>只能修改<code>int</code>/<code>long</code>类型的字段，不能修改其包装类型（<code>Integer</code>/<code>Long</code>）。如果要修改包装类型就需要使用<code>AtomicReferenceFieldUpdater</code>。</p><h5>5.4 AtomicStampedReference</h5><p>对于上面说的<code>AtomicInteger</code>等存在一个问题就是ABA问题。</p><p>ABA问题：其他线程将A改为B，又重新改为了A，本线程用期望值A与之进行比较，发现是相等的，则进行下面的操作。因为这个值已经被改变过，这就是ABA问题。</p><p>解决：用个版本号来控制，来防止ABA问题。</p><h5>5.5 AtomicBoolean</h5><p>场景：若干个线程进来，但是这个方法只能执行一次。</p><p><img src="http://bloghello.oursnail.cn/thread9-13.jpg" alt="image"></p><p>好了，其实<code>Atomic</code>包最核心的思想就是用无阻塞的<code>CAS</code>来代替锁实现高性能操作，是实现线程安全的一种可行方法，理解了<code>CAS</code>原理和他们的基本用法和场景使用，基本就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，volatile保证了可见性，但是不能保证原子性，在面对线程安全问题时，就显地力不从心，那么除了synchronized关键字外，还有什么方式可以实现线程安全更新呢？本文首先介绍CAS是什么，引出JUC下一个重要的包：Atomic包。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile详解</title>
    <link href="http://yoursite.com/2019/02/11/thread/volatile%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/11/thread/volatile详解/</id>
    <published>2019-02-11T13:13:55.833Z</published>
    <updated>2019-02-11T13:16:10.932Z</updated>
    
    <content type="html"><![CDATA[<p>volatile是比较重要的关键字，它涉及JMM，我们需要对其进行深入了解。</p><a id="more"></a><h2>一、java内存模型JMM</h2><p>JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。</p><p>请务必区分HMM和JAVA内存区域，JMM描述的是一组规则，围绕原子性、有序性以及可见性展开。</p><p><img src="http://bloghello.oursnail.cn/thread8-1.png" alt="image"></p><p>大多数的变量是只能存储在主内存中的，线程也不能直接去主内存中读取数据，而是获取数据的副本，每个线程对这个副本进行修改后，会在某个时机刷新回主内存。每个线程之间的工作内存的值是互不透明的，因此不能互相访问，线程间的通信必须通过主内存来完成。</p><h2>二、JMM主内存和工作内存都放些什么</h2><ul><li>主内存<ul><li>存储JAVA实例对象</li><li>包括实例变量、类信息、常量、静态变量等</li><li>属于数据共享的区域，多线程并发操作时会引起线程安全问题</li></ul></li><li>工作内存<ul><li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见(方法里的基本数据类型会直接被存储在工作内存的栈帧结构中)</li><li>字节码行号指示器、Native方法信息</li><li>如果是引用类型，引用存储在工作内存中，实例存储在主内存中</li><li>属于线程私有数据区域，不存在线程安全问题</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/thread8-2.jpg" alt="image"></p><h2>三、指令重排序</h2><p>为了提高执行性能，JVM会进行一定的指令重排序，禁止方式就是加入内存屏障指令，下面会说。</p><p>当然了，指令重排序需要满足一定的条件：</p><ul><li>在单线程环境下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li></ul><p>无法通过<code>happend-before</code>原则推导出来的，才能进行指令的重排序。</p><h2>四、happend-before</h2><p>多线程有两个基本的问题，就是原子性和可见性，而<code>happens-before</code>规则就是用来解决可见性的。</p><p>即：在时间上，动作A发生在动作B之前，能不能<strong>保证</strong>B可以看见A？如果可以保证的话，那么就可以说<code>hb(A,B)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行<code>writer()</code>方法之后，线程B执行<code>reader()</code>方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p><ul><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据volatile规则，2 happens before 3。</li><li>根据happens before 的传递性规则，1 happens before 4。</li></ul><p>上述<code>happens before</code> 关系的图形化表现形式如下：</p><p><img src="http://bloghello.oursnail.cn/thread8-3.png" alt="image"></p><p>在上图中，每一个箭头链接的两个节点，代表了一个<code>happens before</code> 关系。黑色箭头表示程序顺序规则；橙色箭头表示<code>volatile</code>规则；蓝色箭头表示组合这些规则后提供的<code>happens before</code>保证。</p><p>这里A线程写一个<code>volatile</code>变量后，B线程读同一个<code>volatile</code>变量。A线程在写<code>volatile</code>变量之前所有可见的共享变量，在B线程读同一个<code>volatile</code>变量后，将立即变得对B线程可见。</p><p>说了那么多，java中是如何保证这种可见性的呢？<code>Volatile</code>闪亮登场。</p><h2>五、什么是volatile</h2><p><code>volatile</code>关键字的目的是保证被它修饰的共享变量对所有线程总是可见的。</p><h2>六、为什么要用volatile</h2><p><code>Volatile</code>变量修饰符如果使用恰当的话，它比<code>synchronized</code>的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</p><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被<code>volatile</code>修饰之后，那么就具备了两层语义：</p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ul><h2>七、volatile如何保证可见性</h2><p><code>voliatile</code>关键字保证了在进程中变量的变化的可见性。</p><p>在多线程的应用里，如果线程操作了一个没有被<code>volatile</code>关键字标记的变量，那么每个线程都会在使用到这个变量时从主存里拷贝这个变量到CPU的<code>cache</code>里面（为了性能！CPU缓存可比内存快多了）。如果你的电脑有多于一个CPU，那么每个线程都会在不同的CPU上面运行，这意味着每个线程都会把这个变量拷贝到不同的CPU <code>cache</code>里面，正如下图所示：</p><p><img src="http://bloghello.oursnail.cn/thread8-4.png" alt="image"></p><p>一个不带有<code>volatile</code>关键字的变量在JVM从主存里面读取数据到CPU cache或者从cache里面写入数据到主存时是没有保证的。</p><p>想象这样一个场景，当一到两个线程允许去共享一个包含了一个计数变量的对象，这个计数变量如下所定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">//无关键字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这线程一增加了<code>counter</code>变量的值，但是，但是同时线程一和线程二都有可能随时读取这个<code>counter</code>变量。</p><p>如果这个<code>counter</code>变量未曾使用<code>volatile</code>声明，那么我们就无法保证这个变量在两个线程中所位于的CPU的cache和主存中的值是否保持一致了。示意图如下：</p><p><img src="http://bloghello.oursnail.cn/thread8-5.png" alt="image"></p><p>那么部分的线程就不能看到这个变量最新的样子，因为这个变量还没有被线程写回到主存中，这就是可见性的问题，这个线程更新的变量对于其他线程是不可视的。</p><p>在声明了<code>counter</code>变量的<code>volatile</code>关键字后，所有写入到<code>counter</code>变量的值会被立即写回到主存中。同时，所有读取这个变量的线程会先把对应的工作内存置为无效，从主存里面读取这个变量，下面的代码就是声明带<code>volatile</code>关键字的变量的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此声明这个变量就保证了这个变量对于其他写这个变量的线程的可见性。</p><p>总结：</p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了<code>Volatile</code>变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><h2>八、来详细说说volatile写-读的内存语义</h2><p><strong>volatile写的内存语义如下</strong>：</p><blockquote><p>当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</p></blockquote><p>以上面示例程序<code>VolatileExample</code>为例，假设线程A首先执行<code>writer()</code>方法，随后线程B执行<code>reader()</code>方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行<code>volatile</code>写后，共享变量的状态示意图：</p><p><img src="http://bloghello.oursnail.cn/thread8-6.png" alt="image"></p><p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p><p><strong>volatile读的内存语义如下</strong>：</p><blockquote><p>当读一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></blockquote><p><img src="http://bloghello.oursnail.cn/thread8-7.png" alt="image"></p><p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把<code>volatile</code>写和<code>volatile</code>读这两个步骤综合起来看的话，在读线程B读一个<code>volatile</code>变量后，写线程A在写这个<code>volatile</code>变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p><p>下面对<code>volatile</code>写和<code>volatile</code>读的内存语义做个总结：</p><ul><li>线程A写一个<code>volatile</code>变量，实质上是线程A向接下来将要读这个<code>volatile</code>变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程B读一个<code>volatile</code>变量，实质上是线程B接收了之前某个线程发出的（在写这个<code>volatile</code>变量之前对共享变量所做修改的）消息。</li><li>线程A写一个<code>volatile</code>变量，随后线程B读这个<code>volatile</code>变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h2>九、volatile如何禁止指令重排序</h2><p>这就不得不提一个指令叫做：内存屏障了。</p><p>它可就厉害了，</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ul><p>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化。</p><p>这个指令对编译器和CPU的执行都是起作用的，可用强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><p>因此，从根本上来说，是内存屏障指令实现了<code>volatile</code>的可见性和禁止指令重排序的。</p><h2>十、volatile的应用场景</h2><blockquote><p><code>volatile</code>关键字只能对32位和64位的变量使用</p></blockquote><p><code>synchronized</code>关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而<code>volatile</code>关键字在某些情况下性能要优于<code>synchronized</code>，但是要注意<code>volatile</code>关键字是无法替代<code>synchronized</code>关键字的，因为<code>volatile</code>关键字无法保证操作的原子性。通常来说，使用<code>volatile</code>必须具备以下2个条件：</p><blockquote><p>1）对变量的写操作不依赖于当前值</p></blockquote><blockquote><p>2）该变量没有包含在具有其他变量的不变式中</p></blockquote><p>下面列举几个Java中使用<code>volatile</code>的几个场景。</p><p>①.状态标记量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②.单例模式中的<code>double check</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>instance = new Singleton();</code>//非原子操作</p></blockquote><p>执行这一句，JVM发生了如下事情：</p><ul><li>给 <code>instance</code> 分配内存</li><li>调用 <code>Singleton</code> 的构造函数来初始化成员变量</li><li>将<code>instance</code>对象指向分配的内存空间（执行完这步 <code>instance</code> 就为非 <code>null</code> 了）</li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 <code>instance</code> 已经是非 <code>null</code> 了（但却没有初始化），所以线程二会直接返回 <code>instance</code>，然后使用，然后顺理成章地出错了，不再是单例了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;volatile是比较重要的关键字，它涉及JMM，我们需要对其进行深入了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读写锁ReentrantReadWriteLock</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/"/>
    <id>http://yoursite.com/2019/02/11/thread/读写锁ReentrantReadWriteLock/</id>
    <published>2019-02-11T11:35:01.023Z</published>
    <updated>2019-02-11T11:38:36.811Z</updated>
    
    <content type="html"><![CDATA[<p>读写锁的出现是为了提高性能，思想是：读读不互斥，读写互斥，写写互斥。本文来了解一下读写锁的使用和锁降级的概念。</p><a id="more"></a><h2>1. 锁的分类</h2><ul><li>排他锁：在同一时刻只允许一个线程进行访问，其他线程等待；</li><li>读写锁：在同一时刻允许多个读线程访问，但是当写线程访问，所有的写线程和读线程均被阻塞。读写锁维护了一个读锁加一个写锁，通过读写锁分离的模式来保证线程安全，性能高于一般的排他锁。</li></ul><h2>2. 读写锁</h2><p>我们对数据的操作无非两种：“读”和“写”，试想一个这样的情景，当十个线程同时读取某个数据时，这个操作应不应该加同步。答案是没必要的。只有以下两种情况需要加同步：</p><ul><li>这十个线程对这个公共数据既有读又有写</li><li>这十个线程对公共数据进行写操作</li><li>以上两点归结起来就一点就是有对数据进行改变的操作就需要同步</li></ul><p>所以</p><p><strong>java5提供了读写锁这种锁支持多线程读操作不互斥，多线程读写互斥，多线程写互斥</strong>。读操作不互斥这样有助于性能的提高，这点在java5以前没有。</p><h2>3. java并发包提供的读写锁</h2><p>java并发包提供了读写锁的具体实现<code>ReentrantReadWriteLock</code>，它主要提供了一下特性：</p><ul><li>公平性选择：支持公平和非公平（默认）两种获取锁的方式，非公平锁的吞吐量优于公平锁；</li><li>可重入：支持可重入，读线程在获取读锁之后能够再次获取读锁，写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁；</li><li>锁降级：线程获取锁的顺序遵循获取写锁，获取读锁，释放写锁，写锁可以降级成为读锁。</li></ul><h2>4. 先看个小例子</h2><p><strong>读取数据和写入数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个map用来读取和存放数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化ReentrantReadWriteLock</span></span><br><span class="line"><span class="keyword">private</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据实例化对象分别获取读锁和写锁</span></span><br><span class="line"><span class="keyword">private</span> Lock r = rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上读锁</span></span><br><span class="line">r.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 读操作开始执行"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">System.out.println(map.get(key));</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解读锁</span></span><br><span class="line">r.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 读操作执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入数据，即写数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上写锁</span></span><br><span class="line">w.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 写操作开始执行"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">map.put(key, value);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//解写锁</span></span><br><span class="line">w.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 写操作执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main进行创建多线程测试：先来测试一下存在写的情况(只有写或者写读都有)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 写操作开始执行</span><br><span class="line">Thread-0 写操作执行完毕</span><br><span class="line">Thread-1 读操作开始执行</span><br><span class="line">value1</span><br><span class="line">Thread-1 读操作执行完毕</span><br><span class="line">Thread-2 写操作开始执行</span><br><span class="line">Thread-2 写操作执行完毕</span><br><span class="line">Thread-3 写操作开始执行</span><br><span class="line">Thread-3 写操作执行完毕</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>发现存在写的情况，那么就是一个同步等待的过程，即开始执行，然后等待3秒，执行完毕，符合第2个目录中提到的规则。</p><p><strong>对只有读操作的情形进行测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">demo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">demo.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">demo.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 读操作开始执行</span><br><span class="line">Thread-1 读操作开始执行</span><br><span class="line">Thread-2 读操作开始执行</span><br><span class="line">value1</span><br><span class="line">Thread-0 读操作执行完毕</span><br><span class="line">value2</span><br><span class="line">Thread-1 读操作执行完毕</span><br><span class="line">value3</span><br><span class="line">Thread-2 读操作执行完毕</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>在主线程中先<code>put</code>进去几个数用于读的测试，下面开辟三个读线程，我们可以从执行结果中发现，其中一个线程进去之后，另外的线程能够立即再次进入，即这三把锁不是互斥的。</p><h2>5. 锁降级</h2><p>锁降级是指写锁将为读锁。</p><p>锁降级：从写锁变成读锁；锁升级：从读锁变成写锁。读锁是可以被多线程共享的，写锁是单线程独占的。也就是说写锁的并发限制比读锁高，这可能就是升级/降级名称的来源。</p><p>如下代码会产生死锁，因为同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，<code>ReentrantReadWriteLock</code>是不支持的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line">rtLock.readLock().lock();  <span class="comment">//上读锁</span></span><br><span class="line">System.out.println(<span class="string">"get readLock."</span>);  </span><br><span class="line">rtLock.writeLock().lock();  <span class="comment">//读锁还没有释放，不允许上死锁</span></span><br><span class="line">System.out.println(<span class="string">"blocking"</span>);</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>支持锁降级，如下代码不会产生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line">rtLock.writeLock().lock();  <span class="comment">//上写锁</span></span><br><span class="line">System.out.println(<span class="string">"writeLock"</span>);  </span><br><span class="line">  </span><br><span class="line">rtLock.readLock().lock();  <span class="comment">//可以在写锁没有释放的时候立即上读锁</span></span><br><span class="line">System.out.println(<span class="string">"get read lock"</span>);</span><br></pre></td></tr></table></figure><p>利用这个机制：<strong>同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，<code>ReentrantReadWriteLock</code>是不支持的。</strong></p><p>在写锁没有释放的时候，先获取到读锁，然后再释放写锁，保证后面读到的数据的一致性。</p><p><img src="https://segmentfault.com/img/bVOGUM?w=1063&amp;h=246" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isUpdate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">r.lock();<span class="comment">//为了保证isUpdate能够拿到最新的值</span></span><br><span class="line"><span class="keyword">if</span>(isUpdate)&#123;</span><br><span class="line">r.unlock();</span><br><span class="line">w.lock();</span><br><span class="line">map.put(<span class="string">"xxx"</span>,<span class="string">"xxx"</span>);</span><br><span class="line">r.lock();<span class="comment">//写锁还没有释放，立即获取读锁，阻塞本线程，保证本线程下面读的一致性</span></span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">String value = map.get(<span class="string">"xxx"</span>); <span class="comment">//读到的数据是本线程自己更新的数据，不会被其他线程打扰</span></span><br><span class="line">System.out.println(value);</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读写锁的出现是为了提高性能，思想是：读读不互斥，读写互斥，写写互斥。本文来了解一下读写锁的使用和锁降级的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从ReentrantLock引出AQS的原理</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E4%BB%8EReentrantLock%E5%BC%95%E5%87%BAAQS%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/11/thread/从ReentrantLock引出AQS的原理/</id>
    <published>2019-02-11T10:45:59.507Z</published>
    <updated>2019-02-13T09:47:09.238Z</updated>
    
    <content type="html"><![CDATA[<p>如果对并发编程稍微熟悉的话，就不会对ReentrantLock陌生，也可能对一些组件比如CountDownLatch,FutureTask以及Semaphore等同步组件耳闻过，他们都是JUC包下的类或者工具，他们都有一个共同的基础：AQS，即AbstractQueuedSynchronizer，从今天开始，让我们记住它，并且尝试去理解它。</p><a id="more"></a><h2>一、ReentrantLock</h2><p>首先我们先来看看<code>ReentrantLock</code>这个可重入锁的性质和使用，因为它往往会在面试中被面试官拿来同<code>synchronized</code>相比较。如果这种基本的比较都不知道的话，那就没有后续深入的探讨了，面试可能也会结束了。</p><p>它的用法极其简单，如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-1.jpg" alt="image"></p><p>他们两兄弟的区别是：</p><ul><li><code>synchronized</code>是关键字，<code>ReentrantLock</code>是一个类</li><li><code>ReentrantLock</code>可以对获取锁的等待时间进行设置，避免死锁</li><li><code>ReentrantLock</code>可以获取各种锁的信息</li><li><code>ReentrantLock</code>可以灵活地实现多路通知</li><li>机制：<code>synchronized</code>操作<code>MarkWord</code>，<code>lock</code>调用<code>Unsafe</code>类的<code>park()</code>方法</li><li><code>ReentrantLock</code>可以设置锁的公平性</li><li><code>ReentrantLock</code>调用<code>lock()</code>之后必须调用<code>unlock()</code>释放锁</li><li>性能上<code>ReentrantLock</code>未必就比<code>synchronized</code>高，他们都是可重入的</li></ul><p>可以看出，<code>ReentrantLock</code>更加灵活，可以更加细腻度操作锁，而<code>synchronized</code>看起来则相对比较笨拙，但是笨拙的是简单的，不存在忘记释放锁的问题。可谓存在即合理嘛！</p><p>针对上文中提到的<code>Unsafe</code>类，其中最经典的一个方法是：<code>compareAndSwapXXX</code>这类<code>CAS</code>方法，它其实是JAVA留的一个后门，它可以直接操作内存，因此如果普通开发者拿来用的话，可能会出现各种问题，因此被成为不安全的类。</p><p>好了，关于区别已经说的差不多了，下面我们就要来真格的了，首先来翻翻源码。<strong>前方高能预警，请非战斗人员紧急撤离现场，老司机要开车了。</strong></p><p>首先呢，我们来看看<code>lock()</code>方法的实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里多了一个东西叫<code>Sync</code>，<code>Sync</code>为<code>ReentrantLock</code>里面的一个内部类，它继承<code>AQS</code>，它有两个子类：公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>。</p><p><code>ReentrantLock</code>里面大部分的功能都是委托给<code>Sync</code>来实现的，同时<code>Sync</code>内部定义了<code>lock()</code>抽象方法由其子类去实现，默认实现了<code>nonfairTryAcquire(int acquires)</code>方法，可以看出它是非公平锁的默认实现方式。</p><p><img src="http://bloghello.oursnail.cn/thread7-2.jpg" alt="image"></p><p>几乎每一个方法都是通过<code>sync.xxx</code>来实现的，而<code>Sync</code>这个内部类在<code>AQS</code>的基础上增加一些东西而已，所以本质上都是基于<code>AQS</code>来实现的。</p><p>不仅仅是这个，JUC包基本都是以<code>AQS</code>为基础构成，因此<code>AQS</code>可以理解为JUC的一个实现框架。既然<code>AQS</code>这么重要，下面有必要挖地三尺掘出它的原理。</p><h2>二、AQS简介</h2><p>java的内置锁一直都是备受争议的，在JDK 1.6之前，<code>synchronized</code>这个重量级锁性能一直都是较为低下，虽然在1.6后，进行大量的锁优化策略,但是与<code>Lock</code>相比<code>synchronized</code>还是存在一些缺陷的：虽然<code>synchronized</code>提供了便捷性的隐式获取锁释放锁机制（基于JVM机制），但是它却缺少了获取锁与释放锁的可操作性，可中断、超时获取锁，且它为独占式在高并发场景下性能大打折扣。</p><p>AQS：<code>AbstractQueuedSynchronizer</code>，即队列同步器。它是构建锁或者其他同步组件的基础框架（如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<br><code>Semaphore</code>等），JUC并发包的作者（<code>Doug Lea</code>）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。</p><p>AQS解决了在实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS使用一个<code>int</code>类型的成员变量<code>state</code>来表示同步状态，当<code>state&gt;0</code>时表示已经获取了锁，当<code>state = 0</code>时表示释放了锁。它提供了三个方法（<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect,int update)</code>）来对同步状态<code>state</code>进行操作，当然AQS可以确保对<code>state</code>的操作是安全的。</p><p>AQS通过内置的<code>FIFO</code>同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><h2>三、CLH同步队列</h2><p><code>CLH</code>同步队列是一个<code>FIFO</code>双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>在<code>CLH</code>同步队列中，一个节点表示一个线程，它保存着线程的引用（<code>thread</code>）、状态（<code>waitStatus</code>）、前驱节点（<code>prev</code>）、后继节点（<code>next</code>），<code>CLH</code>同步队列结构图如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-9.jpg" alt="image"></p><p>举例理解：假设目前有三个线程<code>Thread1</code>、<code>Thread2</code>、<code>Thread3</code>同时去竞争锁，如果结果是<code>Thread1</code>获取了锁，<code>Thread2</code>和<code>Thread3</code>进入了等待队列，那么他们的样子如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-10.jpg" alt="image"></p><p>AQS的等待队列基于一个双向链表实现的，<code>HEAD</code>节点不关联线程，后面两个节点分别关联<code>Thread2</code>和<code>Thread3</code>，他们将会按照先后顺序被串联在这个队列上。这个时候如果后面再有线程进来的话将会被当做队列的<code>TAIL</code>。</p><h2>四、入列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWaiter(Node node)</code>先通过快速尝试设置尾节点，如果失败，则调用<code>enq(Node node)</code>方法设置尾节点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多次尝试，直到成功为止 </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置为尾节点 </span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就很明了了，首先是尝试快速用<code>CAS</code>设置当前的节点为尾节点，但是可能存在并发问题设置不成功，下面用死循环的方式不断地尝试添加节点并且设置为尾节点，直到成功。</p><p>过程如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-4.jpg" alt="image"></p><h2>五、出列</h2><p>CLH同步队列遵循<code>FIFO</code>，首节点的线程释放同步状态后，将会唤醒它的后继节点（<code>next</code>），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的<code>next</code>和当前节点的<code>prev</code>即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。</p><p><img src="http://bloghello.oursnail.cn/thread7-5.jpg" alt="image"></p><p>其实这里按照源码的解释，是将第一个获取到同步状态的<code>node</code>作为新的<code>head</code>，然后将原来的<code>head</code>置空。</p><h2>六、同步状态的获取与释放</h2><p>在前面提到过，AQS是构建Java同步组件的基础，我们期待它能够成为实现大部分同步需求的基础。AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情况。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。</p><p><strong>下面具体来解释一下独占式和共享式的含义</strong></p><p>在具体分析之前，我们先解释两种同步的方式，独占模式和共享模式：</p><ul><li>独占模式：资源是独占的，一次只能一个线程获取。</li><li>共享模式：同时可以被多个线程获取，具体的资源的个数可以通过参数指定。</li></ul><p>如果我们自己实现一个同步器的框架，我们怎么设计呢？下面可能是我们想到的比较通用的设计方案（独占模式）:</p><ul><li>定义一个变量<code>int state=0</code>，使用这个变量表示被获取的资源的数量。</li><li>线程在获取资源前要先检查<code>state</code>的状态，如果为0，则修改为1，表示获取资源成功，否则表示资源已经被其他线程占用，此时线程要堵塞以等待其他线程释放资源。</li><li>为了能使得资源释放后找到那些为了等待资源而堵塞的线程，我们把这些线程保存在FIFO队列中。</li><li>当占有资源的线程释放掉资源后，可以从队列中唤醒一个堵塞的线程，由于此时资源已经释放，因此这个被唤醒的线程可以获取资源并且执行。</li></ul><p>这个<code>state</code>变量到底是什么呢？</p><ul><li>当<code>AQS</code>的子类实现独占功能时，如<code>ReentrantLock</code>，资源是否可以被访问被定义为：只要<code>AQS</code>的<code>state</code>变量不为0，并且持有锁的线程不是当前线程，那么代表资源不可访问。此时，<code>state</code>是用来表示当前线程获取锁的可重入次数；</li><li>当<code>AQS</code>的子类实现共享功能时，如<code>CountDownLatch</code>，资源是否可以被访问被定义为：只要<code>AQS</code>的<code>state</code>变量不为0，那么代表资源不可以为访问。此时，<code>state</code>用来表示当前计数器的值。</li></ul><h2>七、独占式-独占式同步状态获取</h2><p>独占式，同一时刻仅有一个线程持有同步状态。</p><p>独占式同步状态获取<code>acquire(int arg)</code>方法为AQS提供的模板方法，该方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire</code>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现(<code>ReentrantLock</code>中实现公平锁和非公平锁就是分别重写了这个方法实现的，下面看<code>ReentrantLock</code>的原理的时候就明白了)，该方法必须要保证线程安全的获取同步状态。</li><li><code>addWaiter</code>：如果<code>tryAcquire</code>返回<code>FALSE</code>（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li><code>acquireQueued</code>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt</code>：产生一个中断。</li></ul><p>对这里的<code>acquireQueued</code>有疑惑，下面来看看它做了什么。<code>acquireQueued</code>方法为一个自旋的过程，也就是说当前线程（<code>Node</code>）进入同步队列后，就会先进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点node的前驱结点p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果p确实是head，那说明当前节点node是可用的第一个线程</span></span><br><span class="line">            <span class="comment">//即为当前队列的第一个线程，则最先处理它</span></span><br><span class="line">            <span class="comment">//当前线程则尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//从这里可以看出，更新当前节点为头节点</span></span><br><span class="line">                <span class="comment">//将原来头节点的next引用置空以供JVM回收</span></span><br><span class="line">                <span class="comment">//具体见出列小标题下的示意图</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前驱节点不是头节点就继续阻塞继续等待呗</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p><ul><li>保持FIFO同步队列原则。</li><li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li></ul><p>对这个的理解简单来说就是：</p><blockquote><p>在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的队尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果当前节点的前驱节点就是头节点，则表明当前节点是当前队列中的第一个可用线程，则让其不断尝试获取同步状态，如果获取到，则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p></blockquote><p>继续，我们看到，如果发现前驱节点并不是<code>head</code>，那么就说明是比较靠后的节点了，这个时候，很有可能需要一段时间之后才会用到它，所以根本不需要再参与自旋浪费CPU的性能了，即下面一个if:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>通过这段代码我们可以看到，在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法，该方法主要靠前驱节点判断当前线程是否应该被阻塞，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//状态为signal，表示当前线程处于等待状态，直接放回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//前驱节点状态 &gt; 0 ，则为Cancelled,表明该节点已经超时或者被中断了，需要从同步队列中取消</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前驱节点状态为Condition、propagate</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要检查当前线程是否需要被阻塞，具体规则如下：</p><ul><li>如果当前线程的前驱节点状态为<code>SINNAL</code>，则表明当前线程需要被阻塞，调用<code>unpark()</code>方法唤醒，直接返回true，当前线程阻塞</li><li>如果当前线程的前驱节点状态为<code>CANCELLED（ws &gt; 0）</code>，则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li><li>如果前驱节点非<code>SINNAL</code>，非<code>CANCELLED</code>，则通过CAS的方式将其前驱节点设置为<code>SINNAL</code>，返回false</li></ul><p>针对<code>pred.waitStatus</code>的几种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法返回<code>true</code>，则调用<code>parkAndCheckInterrupt()</code>方法阻塞当前线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parkAndCheckInterrupt()</code> 方法主要是把当前线程挂起，从而阻塞住线程的调用栈，同时返回当前线程的中断状态。其内部则是调用<code>LockSupport</code>工具类的<code>park()</code>方法来阻塞该方法。</p><p>那么，此时，当第一个线程已经执行完毕，释放锁了，就需要唤醒队列中后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>unparkSuccessor(Node node)</code>唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//当前状态 &lt; 0 则设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从tail节点来找可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会存在当前线程的后继节点为<code>null</code>，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，但是为何是从<code>tail</code>尾节点开始，而不是从<code>node.next</code>开始呢？原因在于<code>node.next</code>仍然可能会存在<code>null</code>或者取消了，所以采用<code>tail</code>回溯办法找第一个可用的线程。最后调用<code>LockSupport</code>的<code>unpark(Thread thread)</code>方法唤醒该线程。</p><p>从上面我可以看到，当需要阻塞或者唤醒一个线程的时候，AQS都是使用LockSupport这个工具类来完成的。</p><p><code>LockSupport</code>定义了一系列以<code>park</code>开头的方法来阻塞当前线程，<code>unpark(Thread thread)</code>方法来唤醒一个被阻塞的线程。这些方法的实现都是通过<code>Unsafe</code>类调用<code>native</code>方法来实现的。</p><p>好了，至此就完完全全地搞明白了独占式同步状态获取<code>acquire(int arg)</code>方法的原理，特别是其中节点如何进出、队列第一个节点如何尝试获取同步状态、如何阻塞后继线程以及如何唤醒。</p><h2>八、独占式获取响应中断</h2><p><code>AQS</code>提供了<code>acquire(int arg)</code>方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于<code>CLH</code>同步队列中等待着获取同步状态。为了响应中断，<code>AQS</code>提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常<code>InterruptedException</code>。</p><p>具体原理就不深究了，其实源码跟上面个相差不大，只是不再是使用<code>interrupted</code>标志，而是直接抛出<code>InterruptedException</code>异常。再深究这博客没法继续写啦。</p><h2>九、独占式超时获取</h2><p><code>AQS</code>除了提供上面两个方法外，还提供了一个增强版的方法：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为<code>acquireInterruptibly</code>方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回<code>false</code>，否则返回<code>true</code>。</p><p>针对超时控制，程序首先记录唤醒时间<code>deadline</code> :<code>deadline</code> = <code>System.nanoTime()</code> +<code>nanosTimeout</code>（时间间隔）。</p><p>如果获取同步状态失败，则需要计算出需要休眠的时间间隔<code>nanosTimeout</code> = <code>deadline</code> - <code>System.nanoTime()</code>，如果<code>nanosTimeout</code> &lt;= 0 表示已经超时了，返回<code>false</code>;</p><p>如果大于<code>spinForTimeoutThreshold(1000L)</code>则需要休眠<code>nanosTimeout</code> ;</p><p>如果<code>nanosTimeout</code> &lt;= <code>spinForTimeoutThreshold</code> ，就不需要休眠了，直接进入快速自旋的过程。原因在于 <code>spinForTimeoutThreshold</code> 已经非常小了，非常短的时间等待无法做到十分精确，如果这时再次进行超时等待，相反会让<code>nanosTimeout</code> 的超时从整体上面表现得不是那么精确，所以在超时非常短的场景中，AQS会进行无条件的快速自旋。</p><p>流程图如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-8.jpg" alt="image"></p><h2>十、共享式-共享式同步状态获取</h2><p>共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p><p><code>AQS</code>提供<code>acquireShared(int arg)</code>方法共享式获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面程序可以看出，方法首先是调用<code>tryAcquireShared(int arg)</code>方法尝试获取同步状态，如果获取失败则调用<code>doAcquireShared(int arg)</code>自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。自旋方式获取同步状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且<code>tryAcquireShared(arg)</code>返回值大于等于0即能成功获得同步状态。</p><p><code>acquireShared(int arg)</code>方法不响应中断，与独占式相似，AQS也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，这里就不做解释了。</p><h2>十一、共享式同步状态释放</h2><p>获取同步状态后，需要调用<code>release(int arg)</code>方法释放同步状态，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</p><h2>十二、再回过头来看看ReentrantLock的原理</h2><p>在对AQS原理进行大概了梳理之后，再来理解<code>ReentrantLock</code>就比较容易了，因为大部分的事情都由AQS做完了，剩下的只要重写几个个性化的方法即可。</p><p>还是要看看最核心的方法：<code>lock()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看这个<code>lock()</code>，一点点进了抽象静态内部类<code>Sync</code>中去了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>上面说过，<code>ReentrantLock</code>里面大部分的功能都是委托给<code>Sync</code>来实现的，同时<code>Sync</code>内部定义了<code>lock()</code>抽象方法由其子类去实现的，所以这个<code>lock</code>方法的具体实现是在子类中完成的。<code>Sync</code>的子类有<code>NonfairSync</code>和<code>FairSync</code>这两个，一看就知道了，一个是非公平一个是公平。</p><h2>十三、非公平锁</h2><p>先来看看比较简单的非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，这个<code>lock()</code>方法里面首先用<code>CAS</code>尝试获取锁，获取不到则执行<code>acquire()</code>方法，这个方法就恰好是完全由<code>AQS</code>实现，那么就回到了上面介绍过的内容了。这里为了方便再贴一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是调用<code>tryAcquire()</code>这个方法，即尝试获取锁，这个方法上面也提过，是留给具体的类自己去实现的，所以我们还要回到<code>ReentrantLock</code>中来看看，果然，在上面贴的<code>NonfairSync</code>这个类中对这个方法进行了重写。即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的方法就是实现尝试获取锁的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//state == 0,表示该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取锁成功，设置为当前线程所有</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程重入</span></span><br><span class="line">    <span class="comment">//判断锁持有的线程是否为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就很简单了，值得注意的是，为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作。</p><p>另外需要注意的是，这是非公平锁，就是说，一个线程进来，可能是比先进来的线程先获取锁，就像在开车的时候，总是会由一些车插到你的前面一样。但是如果它没有获取锁，则入队。</p><p>那么尝试获取锁的逻辑我们知道了，那么释放锁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。</p><h2>十四、公平锁</h2><p>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足<code>FIFO</code>。<code>ReentrantLock</code>的构造方法无参时是构造非公平锁。</p><p>提供了有参构造函数，可传入一个<code>boolean</code>值，<code>true</code>时为公平锁，<code>false</code>时为非公平锁，源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面非公平锁获取时（<code>nonfairTryAcquire</code>方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑与<code>nonfairTryAcquire</code>基本上一致，唯一的不同在于增加了<code>hasQueuedPredecessors</code>的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。</p><h2>十五、公平锁 VS 非公平锁</h2><ul><li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。</li><li>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，<code>ReentrantLock</code>默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果对并发编程稍微熟悉的话，就不会对ReentrantLock陌生，也可能对一些组件比如CountDownLatch,FutureTask以及Semaphore等同步组件耳闻过，他们都是JUC包下的类或者工具，他们都有一个共同的基础：AQS，即AbstractQueuedSynchronizer，从今天开始，让我们记住它，并且尝试去理解它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从底层理解synchronized</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3synchronized/"/>
    <id>http://yoursite.com/2019/02/11/thread/从底层理解synchronized/</id>
    <published>2019-02-11T06:21:16.472Z</published>
    <updated>2019-02-11T06:21:44.186Z</updated>
    
    <content type="html"><![CDATA[<p>上一章了解了synchronized的基本使用方式之后，接下来我们来深入了解了解其底层原理，并且说明对它的优化。</p><a id="more"></a><h2>一、synchronized底层实现原理</h2><p>首先给出一个不是结论的结论，<code>synchronized</code>的实现基础是：<code>JAVA</code>对象头和<code>Monitor</code>，理解了这两者的作用就理解了<code>synchronized</code>的实现原理。下面进行详细讲解。</p><p>⭐然后在正式开始之前，先介绍一下锁的内存语义：</p><ul><li>当线程释放锁时，JAVA内存模型会把该线程对应额本地内存中的共享变量刷新到主内存中</li><li>当线程获取锁时，JAVA内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</li></ul><p>在<a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/" target="_blank" rel="noopener">JAVA内存模型-线程共享</a>这篇文章中介绍了对象头里面的基本构成。</p><p><img src="http://bloghello.oursnail.cn/thread6-1.jpg" alt="image"></p><p>我们着重看一下对象头，下面两个这里不需要关心。我们可以看到一个关键字：锁状态标志。因此<code>Mark Word</code>是实现锁的关键了。</p><p>我们也知道，<code>Mark Word</code>是一个可变的结构，可变的部分主要有如下：</p><p><img src="http://bloghello.oursnail.cn/thread6-2.jpg" alt="image"></p><p>其中，偏向所和轻量级锁是JDK1.6之后对<code>synchronized</code>优化所新加的，后文会探讨对<code>synchronized</code>的优化。</p><p>OK，到这里我们知道了每个对象区域的对象头这一块存储了关于锁的信息，即锁状态。仔细看表格，比如重量级锁，就是我们熟知的<code>synchronized</code>对象锁，它的说明是：指向重量级锁的指针。那这个锁是什么呢？指向的是什么位置呢？这个就不得不提及第二个关键字啦：<code>Monitor</code></p><p><code>Monitor</code>:每个对象打娘胎生下来就自带了一把看不见的锁，成为内部锁或者<code>Monitor</code>锁，也称为管程或者监视器锁。我们可以理解为一种同步工具，也可以理解为同步对象。</p><p>那么回到上面的问题上来，这个指针指向的就是<code>Monitor</code>对象的起始地址，因此，每个对象都会存在一个<code>Monitor</code>与之关联，当这个<code>Monitor</code>被一个线程持有时，它就会处于锁定状态。</p><p>在<code>Hotspot</code>虚拟机中，这个<code>Monitor</code>是由<code>ObjectMonitor</code>实现的，位于虚拟机源码中，用<code>C++</code>实现。我们一起来看看吧！</p><p>这个源码地址为：<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/76a9c9cf14f1/src/share/vm/runtime/objectMonitor.hpp" target="_blank" rel="noopener">objectMonitor.hpp</a></p><p><img src="http://bloghello.oursnail.cn/thread6-3.jpg" alt="image"></p><p>我们看到了几个比较重要的关键字，首先，每个等待获取锁的线程都会被封装为<code>ObjectWaiter</code>对象。<code>_WaitSet</code>就是之前说的所有<code>wait</code>状态的线程都会被放在这里等待唤醒再去竞争锁；<code>_EntryList</code>就是所有等待获取锁的线程对象存放的地方。<code>_owner</code>指向的是当前获取到锁的线程对象。<code>_count</code>为计数，这个就跟可重入相关了，线程进来一次就加一次，为0的时候就说明释放锁了，那么此时处于<code>_EntryList</code>池中的线程都可以去竞争这把锁了。</p><p>将上面文字转换为图来理解就是：</p><p><img src="http://bloghello.oursnail.cn/thread6-4.jpg" alt="image"></p><p>以上就是<code>Synchronized</code>实现锁的原理。</p><h2>二、synchronized在字节码层面的语义</h2><p>我们拿下面这段程序作为示例：</p><p><img src="http://bloghello.oursnail.cn/thread6-5.jpg" alt="image"></p><p>我们对这两个方法进行<code>javap</code>的分析，针对第一个同步代码块：</p><p><img src="http://bloghello.oursnail.cn/thread6-6.jpg" alt="image"></p><p>我们可以看出来，<code>synchronized</code>同步代码块实现同步的关键指令是<code>monitorenter</code>和<code>monitorexit</code>。这恰好与上面说的<code>monitor</code>锁对应上，即多个线程在<code>_EntryList</code>中竞争，看谁能拿到<code>monitor</code>锁的指向全，拿到了就可以进来，拿不到就阻塞在<code>monitorenter</code>处继续等待。知道这个锁被释放了为止。</p><p>那么对于<code>synchronized</code>修饰的方法呢？</p><p><img src="http://bloghello.oursnail.cn/thread6-7.jpg" alt="image"></p><p>如果是同步方法，在字节码层面的表示是略有不同的。我们注意到，是在某个标识位上给其打上<code>ACC_SYNCHRONIZED</code>标志，表示这是一个<code>synchronized</code>修饰的同步方法，那么下面对于锁竞争啥的都与上面一样，所以只是字节码层面的表示不同而已，原理都一样。</p><h2>三、对synchronized的优化</h2><p>对于<code>synchronized</code>的性能，在以前一直是嗤之以鼻的，这种观念从老一代的程序猿们口口相传到如今，可谓是根深蒂固，在以前的版本中，确实是很慢，原因如下：</p><ul><li>早期版本中，<code>synchronized</code>属于重量级锁，依赖于<code>Mutex Lock</code>实现</li><li>线程之间的切换需要从用户态转换到核心态，开销较大</li></ul><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h5>3.1 自旋锁</h5><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p>何谓自旋锁？</p><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p><p>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用<code>-XX:+UseSpinning</code>开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数<code>-XX:PreBlockSpin</code>来调整；</p><p>如果通过参数<code>-XX:preBlockSpin</code>来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h5>3.2 适应自旋锁</h5><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p><p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h5>3.3 锁消除</h5><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。</p><p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如<code>StringBuffer</code>、<code>Vector</code>、<code>HashTable</code>等，这个时候会存在隐形的加锁操作。比如<code>StringBuffer</code>的<code>append()</code>方法，<code>Vector</code>的<code>add()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM可以明显检测到变量<code>vector</code>没有逃逸出方法<code>vectorTest()</code>之外，所以JVM可以大胆地将<code>vector</code>内部的加锁操作消除。</p><h5>3.4 锁粗化</h5><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p><p>在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。</p><p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：<code>vector</code>每次add的时候都需要加锁操作，JVM检测到对同一个对象（<code>vector</code>）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到<code>for</code>循环之外。</p><h5>3.5 偏向锁</h5><p>在大多数情况下，锁不存在多线程竞争，总是由同一个线程多次获得。</p><blockquote><p>⭐⭐⭐核心的思想是：如果一个线程获得了锁，那么锁就会进入偏向模式，此时<code>Mark Word</code>的结构也变为偏向锁结构，当该结构再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查<code>Mark Word</code>的锁标记位位偏向锁以及当前线程ID等于<code>Mark Word</code>的<code>ThreadId</code>即可，这样省去了大量有关锁申请的操作。</p></blockquote><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换<code>ThreadID</code>的时候依赖一次<code>CAS</code>原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的<code>CAS</code>原子指令的性能消耗）。<strong>上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><p>它的思想可以理解为<code>CAS</code>，因此这种锁不适合于锁竞争比较激烈的多线程场合。</p><p>偏向锁的获取和释放：</p><blockquote><ul><li>访问 Mark Word 中偏向锁的标识位是否为1，如果是1，则确定为偏向锁。<ul><li>如果偏向锁的标识位为0，说明此时是处于无锁状态，则当前线程通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；并且将偏向标识位设为1。</li><li>如果偏向锁的标识位不为1，也不为0(此时偏向锁的标识位没有值)，说明发生了竞争，偏向锁已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁。</li></ul></li><li>如果是偏向锁，则判断 Mark Word 中的偏向线程ID是否指向当前线程，如果偏向线程ID指向当前线程，则表明当前线程已经获取到了锁；</li><li>如果偏向线程ID并未指向当前线程，则通过CAS操作尝试获取偏向锁，如果获取锁成功，则将 Mark Word 中的偏向线程ID设置为当前线程ID；</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时(在这个时间点上没有正在执行的字节码)，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>偏向锁的释放：<ul><li>当其它的线程尝试获取偏向锁时，持有偏向锁的线程才会释放偏向锁。</li><li>释放偏向锁需要等待全局安全点(在这个时间点上没有正在执行的字节码)。<ul><li>- 首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，</li><li>- 如果线程还活着，说明此时发生了竞争，则偏向锁升级为轻量级锁，然后刚刚被暂停的线程会继续往下执行同步代码。</li></ul></li></ul></li></ul></blockquote><h5>3.6 轻量级锁</h5><p>引入轻量级锁的主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p><p><strong>⭐轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><p>轻量级锁的加锁过程：</p><blockquote><p>1.当使用轻量级锁(锁标识位为00)时，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(注:锁记录中的标识字段称为Displaced Mark Word)。</p><p>2.将对象头中的MarkWord复制到栈桢中的锁记录中之后，虚拟机将尝试使用CAS将对象头中Mark Word替换为指向该线程虚拟机栈中锁记录的指针，此时如果没有线程占有锁或者没有线程竞争锁，则当前线程成功获取到锁，然后执行同步块中的代码。</p><p>3.如果在获取到锁的线程执行同步代码的过程中，另一个线程也完成了栈桢中锁记录的创建，并且已经将对象头中的MarkWord复制到了自己的锁记录中，然后尝试使用CAS将对象头中的MarkWord修改为指向自己的锁记录的指针，但是由于之前获取到锁的线程已经将对象头中的MarkWord修改过了(并且现在还在执行同步体中的代码,即仍然持有着锁)，所以此时对象头中的MarkWord与当前线程锁记录中MarkWord的值不同，导致CAS操作失败，然后该线程就会不停地循环使用CAS操作试图将对象头中的MarkWord替换为自己锁记录中MarkWord的值，(当循环次数或循环时间达到上限时停止循环)如果在循环结束之前CAS操作成功，那么该线程就可以成功获取到锁，如果循环结束之后依然获取不到锁，则锁获取失败，对象头中的MarkWord会被修改为指向重量级锁的指针，然后这个获取锁失败的线程就会被挂起，阻塞了。</p><p>4.当持有锁的那个线程执行完同步体之后，使用CAS操作将对象头中的MarkWord还原为最初的状态时(将对象头中指向锁记录的指针替换为Displaced Mark Word )，发现MarkWord已被修改为指向重量级锁的指针，因此CAS操作失败，该线程会释放锁并唤起阻塞等待的线程，开始新一轮夺锁之争，而此时，轻量级锁已经膨胀为重量级锁，所有竞争失败的线程都会阻塞，而不是自旋。</p></blockquote><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>试用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章了解了synchronized的基本使用方式之后，接下来我们来深入了解了解其底层原理，并且说明对它的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
