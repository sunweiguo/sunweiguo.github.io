<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-01T03:14:33.587Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础算法12-排序总结</title>
    <link href="http://yoursite.com/2019/03/01/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9512-%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/01/algorithms-basic/基础算法12-排序总结/</id>
    <published>2019-03-01T03:10:33.788Z</published>
    <updated>2019-03-01T03:14:33.587Z</updated>
    
    <content type="html"><![CDATA[<p>至此，经典的排序算法的原理全部过了一遍，其中没有说明希尔排序，不过这个并不是重点，我们重点掌握的应该是快排，其次是归并和堆排，最后是插入排序和冒泡排序，在后面就是非比较的排序。本文对它们的特性做一个简单的总结。算法复杂度已经说明，所以不再赘述。</p><a id="more"></a><h2>1.稳定性说明</h2><p>定义：相同的数字排序前后相对位置不变。</p><p><font color="red">1.冒泡排序</font>：<strong>可以做到稳定</strong>，因为冒泡排序的思想是每次将大的数往下沉。如果我们设置每次相等也交换，那么就不是稳定的；反之，我们就可以做到稳定。</p><p><font color="red">2.选择排序</font>：<strong>不可以</strong>，考虑下面这个数组：5，5，5，5，1；那么我们选择一个最小的与第0号元素交换。那么就变成：1，5，5，5，5；此时，第一个5越过后面所有的5跑到了最后面。</p><p><font color="red">3.插入排序</font>：<strong>可以做到稳定</strong>，插入排序的基本思想是前面已经排好序，后面个数与前面已排好序的比较，小于的话就交换。相等的时候是不需要交换的。</p><p><font color="red">4.归并排序</font>：<strong>可以做到稳定</strong>，因为主要思想是分治，在merge的时候，两边数组进行比较，凑成一个排序的数组。那么我们只要设置：相等的时候，一直先考虑左边(或者右边)就可以。</p><p><font color="red">5.快速排序</font>：<strong>一般不可以</strong>，这个就很明显了，我们以三路快排为例，partition的过程中，随机选择一个数，每次形成的数组是&lt;x =x &gt;x这三种，显然中间的x就会打乱顺序。</p><p><font color="red">6.堆排序</font>：<strong>很显然不可以</strong>。因为每次的建堆过程中，即heapInsert过程中，由于新加入的大的值要上浮，那么就可以调换其中的顺序。比如 6 4 4，此时插入一个5建堆，那么显然第一个4要跟5交换，那么第一个4就跑到了第二个4的后面。</p><h2>2.工程中的综合算法</h2><p>如果是很长的基本类型数组，考虑快排；如果是很长的自定义类型的数组，考虑归并排序；如果数组很短(&lt;60)，考虑插入排序，因为常数项小。</p><p>因为基本类型相等的是没有差异的，不需要注意原始顺序，所以直接用快排；</p><p>但是自定义类型的个体是有差异的，需要对自定义类型中的属性进行判断，关系到顺序。</p><h2>3.排序问题的补充</h2><ol><li>归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握。</li><li>快速排序可以做到稳定性问题，但是非常难，不需要掌握。</li><li>面试中碰到一个问题：奇数放在数组左边，偶数放在数组右边，<strong>还要求原始的相对次序是不变的</strong>。空间复杂度为O(1)，时间复杂度为O(N).</li></ol><p>针对这个问题，其实是很难的，因为一个数不是奇数就是偶数，属于01问题，那么就跟快排的partition过程是类似的，就是小于等于某个数放左边，大于某个数放右边，那么也是01问题，就是说，荷兰国旗问题是做不到稳定的。但是快速排序做到稳定性是很难的，所以这道题目其实是比较难做到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;至此，经典的排序算法的原理全部过了一遍，其中没有说明希尔排序，不过这个并不是重点，我们重点掌握的应该是快排，其次是归并和堆排，最后是插入排序和冒泡排序，在后面就是非比较的排序。本文对它们的特性做一个简单的总结。算法复杂度已经说明，所以不再赘述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法11-排序之计数排序、桶排序、基数排序</title>
    <link href="http://yoursite.com/2019/03/01/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9511-%E6%8E%92%E5%BA%8F%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/03/01/algorithms-basic/基础算法11-排序之计数排序、桶排序、基数排序/</id>
    <published>2019-03-01T02:46:21.477Z</published>
    <updated>2019-03-01T02:46:53.329Z</updated>
    
    <content type="html"><![CDATA[<p>在之前我们介绍的都是比较排序算法，在结果中各元素的次序都基于输入元素间的比较。而任何比较排序算法在最坏情况下都要用 O(NlgN) 此比较来排序。而非基于比较的排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p><a id="more"></a><h2>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><p><img src="http://bloghello.oursnail.cn/suanfa11-1.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//maxVal为传入的数组的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array,<span class="keyword">int</span> maxVal)&#123;</span><br><span class="line">    <span class="comment">// 1.根据最大值可以确定辅助数组的长度</span></span><br><span class="line">    <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[maxVal+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//2.遍历array数组，统计每个元素出现的次数，记录在辅助数组对应索引处</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        helper[array[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.遍历辅助数组，覆盖原数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxVal+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (helper[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            array[index++] = i;</span><br><span class="line">            helper[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (<code>Bucket sort</code>)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序.</p><ul><li>找出待排序数组中的最大值<code>max</code>、最小值<code>min</code></li><li>我们使用动态数组 <code>ArrayList</code> 作为桶，桶里放的元素也用 <code>ArrayList</code> 存储。桶的数量为<code>(max-min)/arr.length+1</code></li><li>遍历数组 <code>arr</code>，计算每个元素 <code>arr[i]</code> 放的桶</li><li>每个桶各自排序</li><li>遍历桶数组，把排序好的元素放进输出数组</li></ul><p><img src="http://bloghello.oursnail.cn/suanfa11-2.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="comment">//1.确定出数组的最大值和最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        max = Math.max(arr[i],max);</span><br><span class="line">        min = Math.min(arr[i],min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据最大值和最小值确定桶的数量，并且初始化每个桶</span></span><br><span class="line">    <span class="keyword">int</span> buctetSize = (max-min)%arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;&gt;(buctetSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        bucket.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.类似于hashmap，将其元素放到对应下标的桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min)%buctetSize;</span><br><span class="line">        bucket.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对每个桶中的元素都要进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        Collections.sort(bucket.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(bucket.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.遍历所有的桶，类似于计数排序一样覆盖原数组得到有序的序列</span></span><br><span class="line">    <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = bucket.get(i).size();</span><br><span class="line">        <span class="keyword">while</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[arrIndex++] = bucket.get(i).get(index++);</span><br><span class="line">            sum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>基数排序</h2><p>基数排序(<code>Radix Sort</code>)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p>通过基数排序对数组{53, 3, 542, 748, 14, 214, 154, 63, 616}，它的示意图如下：</p><p><img src="http://bloghello.oursnail.cn/suanfa11-3.jpg" alt="image"></p><p>在上图中，首先将所有待比较数值统一为统一位数长度，接着从最低位开始，依次进行排序。</p><ul><li>按照个位数进行排序。</li><li>按照十位数进行排序。</li><li>按照百位数进行排序。<br>排序后，数列就变成了一个有序序列。</li></ul><p>在理解了基本的思想之后，下面以一个简单的例子辅助理解程序思想。</p><p>首先我们有以下这个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrays = &#123;<span class="number">6</span>,  <span class="number">4322</span>, <span class="number">432</span>, <span class="number">344</span>, <span class="number">55</span> &#125;;</span><br></pre></td></tr></table></figure><p>现在我们有10个桶子，每个桶子下能装载arrays.length个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length][<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://bloghello.oursnail.cn/suanfa11-4.jpg" alt="image"></p><p>第一趟分配与回收:将数组的每个个位数进行分配到不同的桶子上</p><p><img src="http://bloghello.oursnail.cn/suanfa11-5.jpg" alt="image"></p><p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{4322,432,344,55,6}</p><p>第二趟分配与回收:将数组的每个十位数进行分配到不同的桶子上(像6这样的数，往前边补0)</p><p><img src="http://bloghello.oursnail.cn/suanfa11-6.jpg" alt="image"></p><p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,4322,432,344,55}</p><p>第三趟分配与回收:将数组的每个百位数进行分配到不同的桶子上(像6、55这样的数，往前边补0)</p><p><img src="http://bloghello.oursnail.cn/suanfa11-7.jpg" alt="image"></p><p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,55,4322,344,432}</p><p>第四趟分配与回收:将数组的每个百位数进行分配到不同的桶子上(像6、55，344，432这样的数，往前边补0)</p><p><img src="http://bloghello.oursnail.cn/suanfa11-8.jpg" alt="image"></p><p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,55,344,432,4322}</p><p>理解了上面，代码也就非常容易理解了：</p><p>获取这个数组的最大值，这里用递归来实现一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = arr[L];</span><br><span class="line">    <span class="keyword">int</span> b = getMax(arr,L+<span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基数排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//求得数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = getMax(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大数的位数就是我们要分配的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; max / i &gt; <span class="number">0</span> ; i *= <span class="number">10</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//构造arr.length行，10列的二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//求数组每个位，如个位，十位等，根据该位的数字放到对应的二维数组里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[j]/i)%<span class="number">10</span>;</span><br><span class="line">            buckets[j][num] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一次放完之后，就要回收起来放进原来的数组中，等待下一次的重新分配</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(buckets[j][k] != <span class="number">0</span>)&#123;</span><br><span class="line">                    arr[index++] = buckets[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基数排序要理解起来并不困难，不过值得注意的是：基数排序对有负数和0的数列难以进行排序</p><ul><li>因此，往往有0和负数的数组一般我们都不用基数来进行排序</li></ul><p>基数排序的要点就两个：</p><ul><li>分配：按照元素的大小来放入不同的桶子里</li><li>回收：将桶子里的元素按桶子顺序重新放到数组中</li><li>重复…两个步骤</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前我们介绍的都是比较排序算法，在结果中各元素的次序都基于输入元素间的比较。而任何比较排序算法在最坏情况下都要用 O(NlgN) 此比较来排序。而非基于比较的排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法10-堆排序</title>
    <link href="http://yoursite.com/2019/02/28/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9510-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/28/algorithms-basic/基础算法10-堆排序/</id>
    <published>2019-02-28T07:16:36.247Z</published>
    <updated>2019-02-28T08:30:11.174Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序的重要性在于它涉及到二叉堆这个数据结构，面试中曾经被问过堆这个数据结构，那么堆其实是一个完全二叉树，它里面含有好几种类型的堆，其中我们比较关注的是二叉堆，它分为大顶堆和小顶堆，是非常常用的一种数据结构。所以我觉得面试中问到堆这个数据结构的时候可以往二叉堆上进行靠拢，然后回答问题。</p><a id="more"></a><h2>1. 前言</h2><p>在学习堆排序之前，有必要把一些数据结构方面的知识理一下，要不然会有点乱。</p><p>首先看一下一个大的分类：</p><p><img src="http://bloghello.oursnail.cn/suanfa10-1.png" alt="image"></p><p>因此堆是一种特殊的树，并且是特殊的完全二叉树。对于堆排序中的堆通常是指二叉堆。二叉堆分为大根堆和小根堆。其中每个节点的值小于等于其左、右孩子的值，这样的堆称为小根堆；其中每个节点的值大于等于其左、右孩子的值，这样的堆称为大根堆；这里注意二叉堆和二叉搜索树的区别。</p><p>那么理清这个关系之后，我们知道了，我们主要的研究对象是二叉堆这个数据结构。</p><h2>2. 二叉堆的结构</h2><p>回顾一下完全二叉树的定义。</p><blockquote><p>如下图，每一层都是从左向右摆放节点，每个节点都是摆满两个子节点后才向右移动到下一个节点，一层摆满后向下移动一层，直到摆放完所有数字。这样得到的二叉树就是完全二叉树，中间有任何缺失的节点就不能称为完全二叉树。</p></blockquote><p><img src="http://bloghello.oursnail.cn/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89%E5%9B%BE.png" alt="image"></p><p>二叉堆是一种完全二叉树，他们的区别是：</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%8F%89%E5%A0%86%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉堆与完全二叉树"></p><p>二叉堆是一颗完全二叉树，完全二叉树有一个非常重要的性质：即完全二叉树只用数组而不需要指针就可以表示。优势在于数组表示的话内存是紧凑排列的，不会有太多的内存碎片，并且数组对于随机访问是很快的，基于数组下标即可。</p><p><img src="http://bloghello.oursnail.cn/%E5%A0%86%E7%94%A8%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA.png" alt="堆用数组表示"></p><h2>3. 二叉堆与优先队列</h2><p>什么是优先队列，队列我们是比较熟悉的，是一种先进先出的数据结构，在优先队列中，出队的顺序与入队的顺序无关了，而是与优先级有关。即优先级越高，越早出队。</p><p>优先队列到底有什么实际应用呢？比如一个电商网站搞特卖或抢购，用户登录下单提交后，考虑这个时间段用户访问下单提交量很大，通常表单提交到服务器后端后，后端程序一般不直接进行扣库存处理，将请求放到队列列，异步消费处理，用普通队列是FIFO的，这里有个需求是，用户会员级别高的，可以优先抢购到商品，可能这个时间段的级别较高的会员用户下单时间在普通用户之后，这个时候使用优先队列代替普通队列，基本能满足我们的需求。</p><p>优先队列就是依靠二叉堆来实现的。优先队列需要支持两种操作：</p><ul><li>删除最小（最大）元素</li><li>插入元素</li></ul><p>为什么要用堆来实现优先队列？</p><ul><li>优先队列所需要实现的两种操作，不同于队列和栈，它需要一个有序的元素序列，但不要求全部有序，只需要从这些元素中找到最大（或最小）的一个元素。而堆刚好满足这个条件。</li><li>队列，栈都是用数组或者链表来实现的，针对优先队列，用数组和链表实现也是可以的，在队列较小，大量使用两种操作之一时，或者所操作的元素的顺序已知时，用数组和链表十分有用，但是，在最坏的情况下，优先队列用这两张方法实现所需的时间却是线性的。而用堆在最坏情况下的时间则是对数级别。</li></ul><p>由于我们比较关注的是立即拿到最大或者最小的元素，然后高效地删除和插入。这些都依赖于堆的内部算法实现，下面我们就来看看大顶堆为例的插入和删除操作原理。</p><h3>4. 堆的算法</h3><p>我们用N+1长度的数组来表示一个大小为N的堆，我们不会使用[0],堆元素会被保存于[1]-[N-1]中。</p><h5>4.1 大顶堆的插入(上浮)</h5><p><img src="http://bloghello.oursnail.cn/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * k:当前插入元素的位置，相应地k/2就是其父结点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">swap(k/<span class="number">2</span>,k);</span><br><span class="line">k = k/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>4.2 大顶堆的删除</h5><p><img src="http://bloghello.oursnail.cn/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">1. 获取根结点</span><br><span class="line">2. 将根结点与最后一个结点交换</span><br><span class="line">3. 恢复堆的有序性...</span><br></pre></td></tr></table></figure><blockquote><p>显然现在看来该二叉树虽然是一个完全二叉树，但是它并不符合最大堆的相关定义，我们的目的是要在删除完成之后，该完全二叉树依然是最大堆。因此就需要我们来做一些相关的操作！</p></blockquote><p><img src="http://bloghello.oursnail.cn/%E4%B8%8B%E6%B2%89%E5%9B%9E%E5%A4%8D%E5%A0%86%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * k:当前被删除元素的位置(若删除根节点,则k=1)，相应地2*k就是其左子结点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">2</span>*k &lt; N)&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line"><span class="keyword">if</span>(j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>))</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(!less(k,j))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">swap(k,j);</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>5. 堆排</h2><p>在了解了堆的基本操作之后，我们将目标先转到堆排序上，这才是本章研究的重点。</p><p>时间复杂度为<code>O(logN)</code>，额外空间复杂度为<code>O(1)</code>;</p><p>我们知道，数组可以对应到一个完全二叉树。</p><p>堆:大根堆和小根堆。堆就是一个完全二叉树。</p><p>大根堆：完全二叉树中任何一个子树的最大值就是其头部节点对应的值。</p><p>那么，数组已经是一个完全二叉树，而下面的任务就是：将一个数组变成大根堆。</p><p>构建一个大根堆的复杂度是log1+log2+…+logi = O(N)</p><p>第一次构建完大根堆之后，还不是有序的。堆排序的主要思路是：每次将最后一个数与第一个数交换，就是完全二叉树的最后一个数与根节点进行交换。由于根节点已经是最大的数，所以我们就可以不要再管它。我们再将0~n-1下标的所有数进行调整，也调整为大顶堆，然后重复上面的动作。这样，不停地把当前大顶堆的最大数调整到后面，一直到最后，整个数组就是有序的。</p><p><img src="http://bloghello.oursnail.cn/suanfa10-2.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            System.out.print(anArr + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次调整为大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            heapInsert(arr,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">        <span class="comment">//第一个数与最后一个数交换，最后一个数就是最大的值，前面的数再调整为新的大顶堆</span></span><br><span class="line">        <span class="comment">//这样每次都将当前最大的数从数组的后面依次往前排，排到最后整个数组升序</span></span><br><span class="line">        swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">        <span class="keyword">while</span>(heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            heapify(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">            swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前的值是大于父节点的，就与父节点交换，使得大的数上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[index] &gt; arr[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">            swap(arr,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次将最后一个数与第一个数交换后，我们要重新构建大顶堆，主要是将当前第一个数与自己的子节点进行比较，如果小于当前的子节点，则交换；否则不变，已经是大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">        <span class="comment">//拿到当前节点的左子节点</span></span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左子节点下标不能越界</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">            <span class="comment">//在右子节点也不越界的情况下，选出左右子节点中的较大者</span></span><br><span class="line">            <span class="keyword">int</span> largest = left+<span class="number">1</span> &lt; heapSize &amp;&amp; arr[left+<span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">//当前节点与左右子节点的最大者再比较</span></span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            <span class="comment">//如果最大值就是当前节点，说明当前节点的值是大于左右两个子节点的，不需要交换，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(largest == index)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个时候说明当前节点是小于某一个子节点的，那么就要进行交换，并且更新当前节点的坐标为子节点的而坐标，再更新左子节点，做下一次循环的比较</span></span><br><span class="line">            swap(arr,largest,index);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆这个数据结构是非常重要的，因为他的动态调整的时间复杂度为logN，是非常低的。比如经典问题：快速在一串数字流中快速找到中位数等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序的重要性在于它涉及到二叉堆这个数据结构，面试中曾经被问过堆这个数据结构，那么堆其实是一个完全二叉树，它里面含有好几种类型的堆，其中我们比较关注的是二叉堆，它分为大顶堆和小顶堆，是非常常用的一种数据结构。所以我觉得面试中问到堆这个数据结构的时候可以往二叉堆上进行靠拢，然后回答问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法9-快速排序</title>
    <link href="http://yoursite.com/2019/02/28/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%959-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/28/algorithms-basic/基础算法9-快速排序/</id>
    <published>2019-02-28T05:25:30.182Z</published>
    <updated>2019-02-28T05:30:59.277Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了归并排序，本文介绍快速排序，顾名思义，应该是综合性能最好的排序了。在具体实现上，往上也有很多的版本，虽然大体思想一致，但是我觉得掌握其中一种最实用的方式就够了，本文的快排思想基于荷兰国旗问题演变，即所谓的三路快排，对于重复元素较多的场景是非常适合的，对于普通场景来说，性能也不弱。</p><a id="more"></a><h2>1. 荷兰国旗问题</h2><p>在研究快速排序之前，我们先来研究一下一个经典问题：荷兰国旗问题，我们的目标是给出一个num，将原来的数组中的值按照下面的规则进行排列：比num小的全放到num的左边，比bum大的全部放在右边，中间全是等于num的值。类似于荷兰国旗的三色旗。</p><p><img src="http://bloghello.oursnail.cn/suanfa9-1.gif" alt="image"><img src="http://bloghello.oursnail.cn/suanfa9-2.gif" alt="image"></p><p>具体的算法思想看代码注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 荷兰国旗问题</span></span><br><span class="line"><span class="comment"> * 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，</span></span><br><span class="line"><span class="comment"> * 等于num的数放在数组的中间，大于num的数放在数组的右边。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helan_flag_question_solve</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        solve(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要思想是：初始化的坐标分别为-1和N，就是取超出数组的范围，当前坐标是从0开始</span></span><br><span class="line"><span class="comment">     * 分为三种情况：如果当前等于num，那么指针后移一格即可</span></span><br><span class="line"><span class="comment">     * 如果当前小于num，那么就将当前和less+1交换位置，并且当前指针后移一格</span></span><br><span class="line"><span class="comment">     * 如果当前大于num，那么就将当前和more-1交换位置，当前位置不变继续判断、</span></span><br><span class="line"><span class="comment">     * 为什么与前面交换当前指针就要后移一格，但是与后面交换不用后移呢？</span></span><br><span class="line"><span class="comment">     * 我们知道，curr扫过的地方，curr当前指向的和前面的数肯定都是小于num的了，所以需要后移一个判断下一个元素</span></span><br><span class="line"><span class="comment">     * 但是从后面交换过来的，我们不知道这个交换过来的元素比num小还是大，所以对这个元素还需要判断一下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = L-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = L;</span><br><span class="line">        <span class="keyword">while</span>(curr &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[curr] &lt; num)&#123;</span><br><span class="line">                swap(arr,++less,curr++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[curr] &gt; num)&#123;</span><br><span class="line">                swap(arr,--more,curr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目一定一定要注意边界问题。下面的快排其实就是对荷兰国旗问题的递归操作。因此要想理解快排，需要先掌握荷兰国旗问题。</p><h2>2. 快排</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（<code>pivot</code>）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（<code>partition</code>）操作；</li><li>递归地（<code>recursive</code>）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><img src="http://bloghello.oursnail.cn/suanfa9-3.gif" alt="image"></p><p>时间复杂度为O(N*logN),额外空间复杂度O(logN);</p><p>因为要记录划分区域的边界，所以需要一定的空间。这里划分的空间与二分的次数有关，所以需要O(logN)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            System.out.print(anArr + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要思想是根据荷兰国旗的思想，首先揪出一个数，分成三块。然后分别对左右两块递归进行同样地分法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt; R)&#123;</span><br><span class="line">            <span class="comment">//swap(arr,L+(int)(Math.random()*(R-L+1)),R);</span></span><br><span class="line">            <span class="keyword">int</span>[] p = partition(arr,L,R);</span><br><span class="line">            quickSort(arr,L,p[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">            quickSort(arr,p[<span class="number">0</span>]+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的是中间相等的这一串数的左右边界值，所以数组长度固定为2</span></span><br><span class="line"><span class="comment">//选择比较的基准数是数组的最左元素，即arr[L],这样每次都将等于arr[L]的数排到它们应该在的位置上，并且返回等于arr[L]的数的最左坐标less+1和最右坐标more</span></span><br><span class="line"><span class="comment">//下次，就可以从L到less进行相同操作以及more+1和R进行相同操作</span></span><br><span class="line"><span class="comment">//最终，每个元素都来到属于自己的位置上，排序成功</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[L] &lt; arr[R])&#123;</span><br><span class="line">                swap(arr,++less,L++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[L] &gt; arr[R])&#123;</span><br><span class="line">                swap(arr,--more,L);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,more,R);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快排存在的一个问题是：可能划分出来两边数组很偏，排序效率就会变差。可以用随机快排进行改进。</p><p>思路：随机选一个数与数组最后一个数交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(arr,L+(int)(Math.random()*(R-L+1)),R);</span><br></pre></td></tr></table></figure><p>相比于经典快排，这个优化的快排的优点在于：每一次partition之后，就可能会揪出一串的相等数字，然后左边全是小于这个数，右边都是大于这个数。而经典快排每次只找出一个数字来，左边是小于等于这个数，右边是大于这个数。很显然，优化后的快排要快一点。</p><p>这种从荷兰国旗演变过来的快排，对于重复元素较多的时候是非常有利的，因此这种是我比较喜欢的一种写法，这也意味着快排的实现上有一些差异，但是主要的思想是一致的，即分治处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了归并排序，本文介绍快速排序，顾名思义，应该是综合性能最好的排序了。在具体实现上，往上也有很多的版本，虽然大体思想一致，但是我觉得掌握其中一种最实用的方式就够了，本文的快排思想基于荷兰国旗问题演变，即所谓的三路快排，对于重复元素较多的场景是非常适合的，对于普通场景来说，性能也不弱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法8-归并排序</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%958-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法8-归并排序/</id>
    <published>2019-02-27T11:39:19.969Z</published>
    <updated>2019-02-27T11:46:44.159Z</updated>
    
    <content type="html"><![CDATA[<p>从本文开始就要介绍O(nlogn)复杂度级别的排序算法了，首先登场的是归并排序，这个排序可以解决一些问题，会在文章的后面给出，并且是一个经典的分治思想，即先分隔再合并，将复杂的大问题瓦解为小问题，将若干小问题解决了之后大问题也就迎刃而解了。下面我们来学习一下归并排序的基本原理。</p><a id="more"></a><h2>1. 原理</h2><p>归并排序（<code>MERGE-SORT</code>）是利用归并的思想实现的排序方法，该算法采用经典的分治（<code>divide-and-conquer</code>）策略（分治法将问题分(<code>divide</code>)成一些小的问题然后递归求解，而治(<code>conquer</code>)的阶段则将分的阶段得到的各答案&quot;修补&quot;在一起，即分而治之)。</p><p>复杂度为(<code>nlogN</code>),这里采用自顶向下和递归来完成的。</p><p><img src="http://bloghello.oursnail.cn/suanfa8-1.png" alt="image"></p><p>归并排序的原理是，先把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p>归并的前提是先把要排序的序列分为若干个字序列，然后才归并。在拆分数列的时候，就要用到拆分，直到不能再拆为止。</p><blockquote><p>如一个数列{9,8,7,6,5,4,3,2,1}</p><p>先分成{9,8,7,6,5}和{4,3,2,1}</p><p>然后再分成{9,8,7}和{6,5}和{4,3}和{2,1}</p><p>然后再分{9,8}、{6}、{5}、{4}、{3}、{2}、{1}</p><p>然后再合并起来，小在的前面，大的在后面，没有比较的在后面填充数列。</p></blockquote><p>具体如何合并的呢？下面展示的最后的一步合并过程：</p><p><img src="http://bloghello.oursnail.cn/suanfa8-2.png" alt="image"></p><p>我们注意到，归并排序是需要额外的空间来辅助的。动态图为：</p><p><img src="http://bloghello.oursnail.cn/suanfa7-4.gif" alt="image"></p><h2>2. 代码</h2><h5>2.1 左右分开</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int mid = (low + high) / 2;</span></span><br><span class="line"><span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">    sort(a, low, mid);</span><br><span class="line">        <span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">    sort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>2.2 合并过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//临时指针</span></span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">        a[k2 + low] = temp[k2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于它的理解，一句话就是先对半分，分到不能分为止，然后再倒过来将卡擦分开的两组数进行比较合并成有序序列，最终逐渐合并成有序序列。</p><h2>3. 归并排序应用1–小和问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序的应用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  例子：</span></span><br><span class="line"><span class="comment"> *  [1,3,4,2,5]</span></span><br><span class="line"><span class="comment"> *  1左边比1小的数，没有；</span></span><br><span class="line"><span class="comment"> *  3左边比3小的数，1；</span></span><br><span class="line"><span class="comment"> *  4左边比4小的数，1、3；</span></span><br><span class="line"><span class="comment"> *  2左边比2小的数，1；</span></span><br><span class="line"><span class="comment"> *  5左边比5小的数，1、3、4、2；</span></span><br><span class="line"><span class="comment"> *  所以小和为1+1+3+1+1+3+4+2=16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortApply1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(merge_sort(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,low,mid) +</span><br><span class="line">                sortProcess(arr,mid+<span class="number">1</span>,high) +</span><br><span class="line">                  merge(arr,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= high)&#123;</span><br><span class="line">            <span class="comment">//核心的是增加这一句，当发现arr[p1] &lt; arr[p2]时</span></span><br><span class="line">            <span class="comment">//那么p2后面的数必然都大于它，所以这一次合并过程中</span></span><br><span class="line">            <span class="comment">//p1位置比(high-p2+1)这些位置都小，那么针对这个p1位置的数字，一次性全部累计起来即可</span></span><br><span class="line">            count += arr[p1] &lt; arr[p2] ? (high-p2+<span class="number">1</span>)*arr[p1] : <span class="number">0</span>;</span><br><span class="line">            help[k++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">            help[k++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= high)&#123;</span><br><span class="line">            help[k++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;help.length;ii++)&#123;</span><br><span class="line">            arr[ii+low] = help[ii];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>4. 归并排序应用2–逆序对问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序的应用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对的数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortApply2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(merge_sort(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,low,mid) +</span><br><span class="line">                sortProcess(arr,mid+<span class="number">1</span>,high) +</span><br><span class="line">                  merge(arr,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= high)&#123;</span><br><span class="line">            <span class="comment">//归并的过程中发现前面大于后面的话就算一组</span></span><br><span class="line">            count += arr[p1] &gt; arr[p2] ? (high-p2+<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            help[k++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">            help[k++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= high)&#123;</span><br><span class="line">            help[k++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;help.length;ii++)&#123;</span><br><span class="line">            arr[ii+low] = help[ii];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本文开始就要介绍O(nlogn)复杂度级别的排序算法了，首先登场的是归并排序，这个排序可以解决一些问题，会在文章的后面给出，并且是一个经典的分治思想，即先分隔再合并，将复杂的大问题瓦解为小问题，将若干小问题解决了之后大问题也就迎刃而解了。下面我们来学习一下归并排序的基本原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法7-基本排序之冒泡、选择、插入</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%957-%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法7-基本排序之冒泡、选择、插入/</id>
    <published>2019-02-27T08:45:32.009Z</published>
    <updated>2019-02-27T08:45:53.912Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法毋庸置疑，是最重要最重要的基础算法，真正的实际应用中，往往是几种排序算法的组合，因为没有完美的算法，只有适合的算法。学好算法的第一步应该是熟练手写出基本的排序算法，本文应该被放在一篇文章，但是命运的巧合，我还是选择了递归。因为排序算法就摆在那，思想比较清晰，理解上没有难度，但是递归也摆在那，好像简单但是又无从下手。本文先从复杂度比较高但是比较简单的几种排序算法入手。这几种都是O(n^2)的时间复杂度。</p><a id="more"></a><h2>1. 冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>算法的基本步骤：</p><ul><li>比较相邻的元素。如果第一个比第二个大(注意相等不要交换，所谓冒泡是稳定的排序)，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p>动态图：</p><p><img src="http://bloghello.oursnail.cn/suanfa7-1.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 冒泡排序整体思路：每一趟的比较，都会将最大的一个数排到最后面</span></span><br><span class="line"><span class="comment">         * 0。。。。。。。n-1   第一趟一直比较到最后一个，把最大的放到对后面</span></span><br><span class="line"><span class="comment">         * 0。。。。。n-2   第二趟比较的数组长度会减少一个，因为最大的已经确定了</span></span><br><span class="line"><span class="comment">         * 0。。。。n-3    第三趟比较的就再少两个，因为两个最大的已经确定了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//两两比较交换</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>2. 选择排序</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：不断地在未排序序列中找到最小元素，交换到数组的最前面。</p><p><img src="http://bloghello.oursnail.cn/suanfa7-2.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 基本思想是：每一趟都将最小值的索引确定好，然后放到前</span></span><br><span class="line"><span class="comment">         * 所以每一趟结束之后，前面是已经排好序的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,min,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>3. 插入排序</h2><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><img src="http://bloghello.oursnail.cn/suanfa7-3.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        insert_sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 插入排序主要思想是：每一趟都保证当前索引前的所有元素都小于当前索引</span></span><br><span class="line"><span class="comment">         * 比如【5,4,3,2,1】，那么第一趟是【4,5,3,2,1】，第二趟是【3,4,5,2,1】</span></span><br><span class="line"><span class="comment">         * 第三趟是【2,3,4,5,1】，第四趟是【1,2,3,4,5】</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 其实这是优化后的方法，简单的插入排序是这样子的：</span></span><br><span class="line"><span class="comment">         *    for(int i=1;i&lt;arr.length;i++)&#123;</span></span><br><span class="line"><span class="comment">         *        for(int j=i; j&gt;0 &amp;&amp; array[j-1]&gt;array[j]; j--)&#123;</span></span><br><span class="line"><span class="comment">         *           swap(array, j, j-1);</span></span><br><span class="line"><span class="comment">         *        &#125;</span></span><br><span class="line"><span class="comment">         *    &#125;</span></span><br><span class="line"><span class="comment">         * 这里的优化是考虑到原始方法要不断地进行交换，其实是没有必要的，直接赋值就好了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>] &gt; tmp ;j--)&#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法毋庸置疑，是最重要最重要的基础算法，真正的实际应用中，往往是几种排序算法的组合，因为没有完美的算法，只有适合的算法。学好算法的第一步应该是熟练手写出基本的排序算法，本文应该被放在一篇文章，但是命运的巧合，我还是选择了递归。因为排序算法就摆在那，思想比较清晰，理解上没有难度，但是递归也摆在那，好像简单但是又无从下手。本文先从复杂度比较高但是比较简单的几种排序算法入手。这几种都是O(n^2)的时间复杂度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法6-关于二叉树的经典面试题分析</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%956-%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法6-关于二叉树的经典面试题分析/</id>
    <published>2019-02-27T06:45:13.480Z</published>
    <updated>2019-02-27T06:45:39.240Z</updated>
    
    <content type="html"><![CDATA[<p>掌握对树的基本操作是很重要的，这里所谓的操作是指对树的遍历，以及对树的构造等等。下面通过一些题目来好好研究研究。由于篇幅、时间以及精力有限，本文着重提取两种题型进行分析，都是高频面试问题。</p><a id="more"></a><h2>问题1</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-1.png" alt="image"></p><p>这是一道比较常见的题目，虽然难度是<code>medium</code>，但是也没有那么难，这个题目主要是要求我们根据前序遍历和中序遍历构造出整棵树。</p><p>基本的思路是：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-2.png" alt="image"></p><p>也就是说，前序遍历的第一个元素必然是整棵树的头节点，那么我在中序遍历找到头节点的位置后，就可以根据中序遍历的特点，前面的都是左子树，后面的都是右子树。找到了这一个，下面就让计算机递归去找，所以问题的关键就是第一步的缩小范围。无需关心构造树的细节。</p><p>我的解题方案是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//6.递归的停止条件，最后考虑，先考虑下面的一般情况</span></span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.根据前序遍历的结果，第一个元素就是树的root</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.根据root的值去inorder中去找，题目规定这个序列是没有重复元素的</span></span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.找到了之后，我们就可以确定root的左子树和右子树的所有元素了</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.下面就交给计算机了，我们只要考虑第一次的缩小规模，即root的左子树是什么范围，递归下去，相信它一定可以给我们一个正确的root的左子树</span></span><br><span class="line">        <span class="comment">//这个范围的确定也是很简单的，根据前序遍历和中序遍历的关系就可以获得</span></span><br><span class="line">        <span class="comment">//不过额外需要注意的是Arrays.copyOfRange是一个[)的结果集，需要注意以下边界</span></span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,<span class="number">1</span>+rootIndex),Arrays.copyOfRange(inorder,<span class="number">0</span>,rootIndex));</span><br><span class="line">        <span class="comment">//递归下去，相信它一定可以给我们一个正确的root的右子树</span></span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>+rootIndex,preorder.length),Arrays.copyOfRange(inorder,rootIndex+<span class="number">1</span>,inorder.length));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.返回root，构造完毕</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题2</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-3.png" alt="image"></p><p>根据前序和后序构建的二叉树不唯一，理由是前序与后序都没有明确规定节点间的父子关系，例如下图所示：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-4.png" alt="image"></p><p>本题比较人性化，要求只要输出其中一种可能性即可。还是可以根据一般的思路，采用递归思想，对于每一个先序序列，划分出对应的根节点、左子树、右子树范围即可自上而下构建出二叉树。</p><p>例如对于上例中的先序序列[1,2,4,5,3,6,7]，第一个节点一定为根节点，第2到第i个节点为左子树，第i+1到最后一个节点为右子树，那么问题就可以简化为：<strong>如何确定左右子树分界点？</strong></p><p><img src="http://bloghello.oursnail.cn/suanfa6-5.png" alt="image"></p><p>对于这个简化过后的问题，从后序遍历序列上很容易得到答案：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-6.png" alt="image"></p><p>根据上图的思路，就可以写代码啦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组还有元素，则取出第一个元素作为root</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组长度为1 的时候直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到左子树根节点在后序遍历中的位置，找到之后，元素前面的都是左子树元素，后面除了最后一个元素都是右子树元素</span></span><br><span class="line">        <span class="keyword">int</span> leftRootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftRootVal = pre[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;post.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(post[i] == leftRootVal)&#123;</span><br><span class="line">                leftRootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">//递归构造</span></span><br><span class="line">        root.left = constructFromPrePost(Arrays.copyOfRange(pre,<span class="number">1</span>,leftRootIndex+<span class="number">2</span>),</span><br><span class="line">                                        Arrays.copyOfRange(post,<span class="number">0</span>,leftRootIndex+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        root.right = constructFromPrePost(Arrays.copyOfRange(pre,leftRootIndex+<span class="number">2</span>,pre.length),</span><br><span class="line">                                         Arrays.copyOfRange(post,leftRootIndex+<span class="number">1</span>,post.length-<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题3</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-7.png" alt="image"></p><p>到现在为止，我们对于中序排序的规则已经很熟悉，下面图示:</p><p><img src="http://bloghello.oursnail.cn/suanfa6-8.png" alt="image"></p><p>我们从这个图上可以看到，找下一个节点是可以分为几种情况的。</p><p>第一种情况，就是一个节点有右子树。比如要求节点B的下一个节点，其实是找到它的右子树的最左孩子，就是G节点。</p><p>第二种情况，就是一个节点没有右子树，此时又可以分为两种情况。</p><p>对于G这个节点来说，没有右子节点了，它的父亲节点是E，G是E的左子节点，即E的左子节点是G，那么G的下一个节点就是E。</p><p>对于E这个节点来说，也没有右子节点，它的父亲节点是B，此时E是B的右子节点，根据实际情况来说，E的下一个节点绝对不是B，因为E是B的右子节点，根据中序遍历的规则，此时肯定是先遍历B再遍历E，所以B肯定在E的前面，而不是后面，所以我们还需要再往上找父亲节点，此时B的父亲节点为A，B为A的左子节点，此时根据实际情况，A就是我们要找的E的下一个节点。</p><p>所以，对于一个没有右子节点的节点来说，只需要判断它有没有父节点并且是不是父节点的左子节点，是的话，就找到了，不是则要不断地向上找。</p><p>如果一直找到根还是找不到，像节点F，那就返回null，因为实际上F节点就是中序遍历的最后一个节点，没有所谓的下一个节点了。</p><p>将上面所述转换为图示为：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-9.png" alt="image"></p><p>总之，我们不关心当前节点的左子节点，因为它不在我们的考虑范围内，它必定出现在当前节点的前面。</p><p>我们主要就是考虑有没有右子节点，或者没有右子节点的话就考虑父亲节点。有右子节点比较简单，一直找最左边的子节点即可。但是没有右子节点的时候，就需要去查询父亲节点了。理解了这些，程序也就呼之欲出了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.判断当前节点是否有右子节点，有则去里面找</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> firstInRightTree(pNode);</span><br><span class="line">        <span class="comment">//2.没有右子节点，就需要去父节点找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3.直到找到符合条件的父节点为止，跳出循环时pNode的父节点符合条件，这个父节点就是我们要的东西</span></span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span> &amp;&amp; pNode.next.left != pNode)&#123;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到右子树中找符合条件的，显然就是找最最最左边的子节点即可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeLinkNode <span class="title">firstInRightTree</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        TreeLinkNode curr = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对比较常见的树的一些算法题进行了分析，关于树的题目还有很多，并且很多重要的题目也还每设计到，后面有时间整理一下leetcode上比较经典的二叉树的算法题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌握对树的基本操作是很重要的，这里所谓的操作是指对树的遍历，以及对树的构造等等。下面通过一些题目来好好研究研究。由于篇幅、时间以及精力有限，本文着重提取两种题型进行分析，都是高频面试问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法5-二分搜索树</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%955-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法5-二分搜索树/</id>
    <published>2019-02-26T14:29:31.521Z</published>
    <updated>2019-02-26T14:29:49.786Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。普通的二叉树其实没什么好讲的，就是最多只有两个孩子的树，而二叉搜索树赋予了它一些额外的条件，使得它有了使用的价值，例如根据它的性质，那么中序遍历出来的结果恰好就是有序的结果，故本文着重说明二叉搜索树。</p><a id="more"></a><h2>一、二叉树</h2><p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。它本身对里面的数据是没有说明要求的，只是个数要满足二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2的(i-1)次方个结点；深度为k的二叉树至多有2的k次方-1个结点；</p><p><img src="http://bloghello.oursnail.cn/suanfa5-1.png" alt="image"></p><h2>二、满二叉树和完全二叉树</h2><p>一张图就可以看出它们的区别了：</p><p><img src="http://bloghello.oursnail.cn/suanfa5-2.png" alt="image"></p><h2>三、二叉搜索树概念</h2><p><strong>二叉查找树定义</strong>：又称为是二叉排序树（<code>Binary Sort Tree</code>）或二叉搜索树,不需要是一棵完全二叉树。具有以下性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ul><p><strong>二叉查找树的性质</strong>：对二叉查找树进行中序遍历，即可得到有序的数列。</p><p><strong>二叉查找树的时间复杂度</strong>：它和二分查找一样，插入和查找的时间复杂度均为<code>O(logn)</code>，但是在最坏的情况下仍然会有<code>O(n)</code>的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p><p>二叉查找树的高度决定了二叉查找树的查找效率。</p><h2>四、树的定义</h2><p>就是说如果我要定义一个二叉树，那么这个<code>Node</code>如何定义呢？其实很简单，无非就是<code>left</code>,<code>right</code>,<code>val</code>这三个变量而已，也有可能是<code>key</code>和<code>value</code>这种类型，这个定义是在《算法4》上看到的，二叉搜索树判断大小的依据就是这个<code>key</code>.不必对这个纠结.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分搜索树</span></span><br><span class="line"><span class="comment">//由于Key需要能够进行比较，所以需要extends Comparable&lt;Key&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 树中的节点为私有的类, 外界不需要了解二分搜索树节点的具体实现</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Key key;</span><br><span class="line">     <span class="keyword">private</span> Value value;</span><br><span class="line">     <span class="keyword">private</span> Node left, right;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.key = key;</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">         left = right = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Node root;  <span class="comment">// 根节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> count;  <span class="comment">// 树种的节点个数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>五、插入新节点</h2><p>查看以下动画演示了解插入新节点的算法思想：（其插入过程充分利用了二分搜索树的特性）</p><p>例如待插入数据60，首先与根元素41比较，大于根元素，则与其右孩子再进行比较，大于58由于58无右孩子，则60为58的右孩子，过程结束。（注意其递归过程）</p><p><img src="http://bloghello.oursnail.cn/%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9.gif" alt="image"></p><blockquote><p>判断node节点是否为空，为空则创建节点并将其返回（ 判断递归到底的情况）。</p></blockquote><blockquote><p>若不为空，则继续判断根元素的key值是否等于根元素的key值：若相等则直接更新value值即可。若不相等，则根据其大小比较在左孩子或右孩子部分继续递归直至找到合适位置为止。、</p></blockquote><p>代码实现(递归实现)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中插入一个新的(key, value)数据对</span></span><br><span class="line"><span class="comment">// 返回的是最后插入完成之后二叉树的根</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">    root = insert(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************</span></span><br><span class="line"><span class="comment">//* 二分搜索树的辅助函数</span></span><br><span class="line"><span class="comment">//********************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法</span></span><br><span class="line"><span class="comment">// 返回插入新节点后的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">insert</span><span class="params">(Node node, Key key, Value value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) == <span class="number">0</span> )</span><br><span class="line">        node.value = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )</span><br><span class="line">        node.left = insert( node.left , key, value);</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        node.right = insert( node.right, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>六、二分搜索树的查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看二分搜索树中是否存在键key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contain(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(Node node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> contain( node.left , key );</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">        <span class="keyword">return</span> contain( node.right , key );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>七、二分搜索树的遍历</h2><p>这块内容其实我想删除的，但是吧，这一段对树的前中后序遍历的动态图是非常不错的，对理解树的遍历是非常有利的，所以保留在这里。下面进入正文。</p><p>遍历分为前序遍历、中序遍历以及后序遍历三种，如何理解其遍历顺序呢？</p><p>对于每个节点而言，可能会有左、右两个孩子，所以分成下图中3个点，每次递归过程中会经过这3个点。</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86.png" alt="image"></p><blockquote><p>前序遍历：先访问当前节点，再依次递归访问左右子树</p></blockquote><blockquote><p>中序遍历：先递归访问左子树，再访问自身，再递归访问右子树</p></blockquote><blockquote><p>后续遍历：先递归访问左右子树，再访问自身节点</p></blockquote><p>下面分别来看看是如何遍历的。</p><h5>7.1 前序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%89%8D%E5%BA%8F%E4%BE%BF%E5%88%A9.gif" alt="image"></p><p>我们注意看，先找到28的第一个点，然后将28返回，下面看有没有左儿子，有就先来到左儿子的节点，然后将16弹出…</p><p>最终的打印结果:</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.2 中序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>最终的打印结果:</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.3 后序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>最终打印结果：</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.4 递归代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行前序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行中序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行后序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对非递归的写法，推荐用第二篇文章中说明的方式，那种方式具有较好的通用性。当然了，此时应该认识到学好递归的重要性了。</p><h2>八、层序遍历</h2><h5>8.1 算法思想</h5><p>层序遍历即一层一层地向下遍历，查看以下动画：</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>查看以上动画，实现其过程需要引入先进先出的“队列”数据结构，首先将28入队，第一层遍历完毕，可进行操作，将28出队并打印。遍历第二层16、30依次入队，再出队进行打印操作，依次类推。</p><h5>8.2 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们使用LinkedList来作为我们的队列</span></span><br><span class="line">    LinkedList&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span>( !q.isEmpty() )&#123;</span><br><span class="line"></span><br><span class="line">        Node node = q.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(node.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node.left != <span class="keyword">null</span> )</span><br><span class="line">            q.add( node.left );</span><br><span class="line">        <span class="keyword">if</span>( node.right != <span class="keyword">null</span> )</span><br><span class="line">            q.add( node.right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>九、局限性来源</h2><p>它的局限性来源于哪？注意其二分搜索树的创建，如下图所示，同样的数据，可以对应不同的二分搜索树。</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B1%80%E9%99%90.png" alt="image"></p><p>如上图，第一种创建情况可能是大部分人心中设想，但是第二种情况也是符合二分搜索树的特征，如此一来，二分搜索树可能退化成链表。二分搜索树的查找过程是与其高度相关，此时高度为n，时间复杂度为O(n^2)。</p><h2>十、初识红黑树</h2><p>其实二分搜索树的性能总体而言还是十分优异的，它所有的有关操作时间复杂度为O(n)，出现以上情况的概率很小，但如果创建时其数据都是有序的，那么就会令人担忧了。也许你会想到快速排序中也有此问题，不过它通过随机获取标志点的方法解决了此问题。</p><p>所以类似以上解决办法，将其顺序打乱再插入到二分搜索树即可？这是一个解决办法，但是需要一开始获取所有数据，其实这些数据是慢慢流入系统的，所以在创建其过程中才会发现数据是否几乎有序。</p><p>为了解决此问题，可以改造二叉树的实现，使得其无法退化成链表—–平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 <code>logn</code> 级别的，此概念的经典实现就是红黑树。</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。普通的二叉树其实没什么好讲的，就是最多只有两个孩子的树，而二叉搜索树赋予了它一些额外的条件，使得它有了使用的价值，例如根据它的性质，那么中序遍历出来的结果恰好就是有序的结果，故本文着重说明二叉搜索树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法4-二分查找算法</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%954-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法4-二分查找算法/</id>
    <published>2019-02-26T13:05:21.351Z</published>
    <updated>2019-02-26T13:05:48.546Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是比较常见的查找算法，但是它需要一个条件就是数组有序，因此当面试中听到有序数组这个关键词的时候，不妨往二分查找法想一想，或许它就是解开问题的钥匙。</p><a id="more"></a><p>算法思想：</p><blockquote><p>注意该算法的前提条件：有序数组。想查找元素value，先查看数组中间元素值v与value的大小，若相等则刚好，否则根据比较结果选择左、右半部分再次寻找。</p></blockquote><p>时间复杂度：</p><blockquote><p>整个查找过程可构成一棵树，时间复杂度为O(logn)。</p></blockquote><h2>问题1</h2><p>给定一个有序的数组，查找value是否在数组中，不存在返回-1。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arr:数组</span></span><br><span class="line"><span class="comment"> * n:数组数据长度</span></span><br><span class="line"><span class="comment"> * target:就是要查找的被返回的值</span></span><br><span class="line"><span class="comment"> * while循环迭代的方式实现二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( lo &lt;= hi )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int mid = (l + r)/2;防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归的方式实现二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( lo &gt; hi )</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, lo, mid-<span class="number">1</span>, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, mid+<span class="number">1</span>, hi, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题2</h2><p><img src="http://bloghello.oursnail.cn/suanfa4-1.png" alt="image"></p><p>这就是一道经典的用二分查找解决的问题。下面给出解题答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这边相等的话，就要找它周围的数字是否相等，直到找到一个区间为止</span></span><br><span class="line">                <span class="keyword">int</span> low = mid;</span><br><span class="line">                <span class="keyword">int</span> high = mid;</span><br><span class="line">                <span class="keyword">while</span>(low - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[low-<span class="number">1</span>] == target)&#123;</span><br><span class="line">                    low--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(high + <span class="number">1</span> &lt;= nums.length-<span class="number">1</span> &amp;&amp; nums[high+<span class="number">1</span>] == target)&#123;</span><br><span class="line">                    high++;</span><br><span class="line">                &#125;</span><br><span class="line">                res[<span class="number">0</span>] = low;</span><br><span class="line">                res[<span class="number">1</span>] = high;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我的思路很简单，就是在找到符合条件的mid之后，我就尝试在mid的两边再去找是否有相等的数字，由于是递增的数组，所以很好判断。</p><h2>问题3</h2><p><img src="http://bloghello.oursnail.cn/suanfa4-2.png" alt="image"></p><p>这是《剑指offer》上的一道题目，原本的数列一个非递减的序列，这里在中间咔了一刀变成两截，并且颠倒，那么就被划成了两段非递减的序列，并且前面的非递减数列要比后面的非递减数列要大于等于。所以，是有一定的规律的，这里还是推荐使用二分查找，只是是二分查找法的变体了。</p><p>当然了这个题目的暴力解法其实已经很简单了，就是从头开始遍历，只要出现一个数比前面一个数小，那么这个数就是原来序列的最前面的数，那么其实就是最小的数。</p><p>而二分查找在比较极端的条件下，比如元素都相等，可能就会退化为O(n)复杂度，但是如果原来的数列是一个严格递增的数列，那么还是快一点的。因为缩小的范围比较快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[right])&#123;</span><br><span class="line">                <span class="comment">//最小的元素一定在mid后面</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[right])&#123;</span><br><span class="line">                <span class="comment">//最小的元素在mid或者mid之前，注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字</span></span><br><span class="line">                <span class="comment">//比如 array = [4,6]</span></span><br><span class="line">                <span class="comment">//array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;</span></span><br><span class="line">                <span class="comment">//如果high = mid - 1，就会产生错误， 因此high = mid</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]</span></span><br><span class="line">                <span class="comment">//此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 </span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找法最主要的注意点就是边界，一定要注意边界的选取，这直接影响了程序的实现细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找是比较常见的查找算法，但是它需要一个条件就是数组有序，因此当面试中听到有序数组这个关键词的时候，不妨往二分查找法想一想，或许它就是解开问题的钥匙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法3-循环控制</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%953-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法3-循环控制/</id>
    <published>2019-02-26T10:00:17.013Z</published>
    <updated>2019-02-26T10:11:50.268Z</updated>
    
    <content type="html"><![CDATA[<p>在第一篇文章中为了说明递归如何写，所以对于链表的操作都是用递归来写的，我们发现递归写起来比较简洁，但是执行的过程有点复杂，并且往往在实际的算法中都是要将递归改成循环来做，可以一定程度上减少开销提高性能。下面我们来看看循环如何实现的。</p><a id="more"></a><h2>链表的反转</h2><p>需要验证准确性的话，可以去leetcode上去做这道题，题号为206.这道题还是比较经典的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = currentNode.next;</span><br><span class="line">            currentNode.next = newHead;</span><br><span class="line">            newHead = currentNode;</span><br><span class="line">            currentNode = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始学的时候看的答案就是这个方法，显然是要比递归好的，但是如果不理解的话，光靠背很容易出错，并且也不大背的上，如今重温这道题，其实是很简单的，我们下面用图示来阐述。</p><p>主要的思想是用两个指针，其中<code>newHead</code>指向的是反转成功的链表的头部，<code>currentHead</code>指向的是还没有反转的链表的头部：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-1.png" alt="image"></p><p>初始状态是<code>newHead</code>指向<code>null</code>，<code>currentHead</code>指向的是第一个元素，一直往后遍历直到<code>newHead</code>指向最后一个元素为止：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-3.png" alt="image"></p><p>下面展示的是其中某个时间点的指向细节：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-2.png" alt="image"></p><p>理解了上面的图示，程序就呼之欲出了。</p><h2>删除链表节点</h2><p>题目为：给一个数值，找到链表中这个等于这个数的所有节点并且删除。效果如下，比如给的数是2，则表示删除链表中所有为2的节点。</p><p><img src="http://bloghello.oursnail.cn/suanfa3-4.png" alt="image"></p><p>这个题目也是非常地经典，面试中经常会看到。我们务必要掌握。</p><p>这个其实有两种解题思路，比较简单的是增加一个虚拟的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造一个虚拟的头节点，指向head</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用一个指针指向虚拟头节点，因为虚拟头节点还要表示去重后的链表的头节点</span></span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        <span class="comment">//进入循环，看虚拟头节点下一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果下一个节点不为空并且值是等于val的，那么就说明要删除掉这个节点</span></span><br><span class="line">            <span class="comment">//所谓的删除，只是改变指针，使得这个要删除的节点没有任何引用即可，java会自动回收它</span></span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">                ListNode delNode = curr.next;</span><br><span class="line">                curr.next = delNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明值不等于val，那么就后移一个即可</span></span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现的方式相对来说比较简单。大体的解决思路为：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-6.png" alt="image"></p><p>另一种是比较特殊的处理方式，不需要虚拟的头节点就可以实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于比较特殊的，就是head也与val相等的情况，需要出一下</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，还需要判断一下head是否为null，因为有可能这个链表全部都等于val</span></span><br><span class="line">        <span class="comment">//那么经过上一步之后这个链表已经为null了，那么就不需要进入下一步了</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时链表开头的重复元素全部剔除了，下面就是普通的后续的元素，循环判断删除即可</span></span><br><span class="line">        ListNode prev = head;</span><br><span class="line">        <span class="keyword">while</span>(prev.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.next.val == val)&#123;</span><br><span class="line">                ListNode delNode = prev.next;</span><br><span class="line">                prev.next = delNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，代码大体是相似的，特殊的处理在于一开始的节点的值与val相等的处理，所以我们需要先处理一下head以及head的后面连续的都是等于val的节点，直到处理到不为val的节点为止，即把开头相等的节点全部剔除掉，下面再继续循环判断是否相等。</p><p>关于链表的题目还有很多，由于链表数据结构比较简单，但是算法并不简单，所以面试中经常会被问道，需要好好准备一下。后面会进行相应的总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一篇文章中为了说明递归如何写，所以对于链表的操作都是用递归来写的，我们发现递归写起来比较简洁，但是执行的过程有点复杂，并且往往在实际的算法中都是要将递归改成循环来做，可以一定程度上减少开销提高性能。下面我们来看看循环如何实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法2-汉诺塔问题</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%952-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法2-汉诺塔问题/</id>
    <published>2019-02-26T06:16:12.421Z</published>
    <updated>2019-02-26T06:16:36.020Z</updated>
    
    <content type="html"><![CDATA[<p>为什么还要再来说说递归问题，因为数据结构中二叉树是比较重要也是比较难的数据结构，它的结构是天生递归的，所以对于二叉树的很多操作都可以用递归来实现，因此递归这一关能尽量理解是最好的，本章从汉诺塔的问题出发，来看看递归的实现原理。</p><a id="more"></a><h2>汉诺塔问题</h2><p>这个问题估计大多数人都是知道的，汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p>抽象为数学问题：如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-1.png" alt="image"></p><p>其实核心的思想已经在上篇文章中说明了，就是数学归纳法的思想，就拿简单又不失一般性的三个盘子先说事。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-2.png" alt="image"></p><p>其实我们发现，最核心的一个状态就是：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-3.png" alt="image"></p><p>就是说，我们已经有了中间B这个符合条件的2个盘子的情况，那么我只需要将这两个想办法将这B上两个盘子放到C上就结束了。</p><p>同理，更多的盘子n，我就是想办法将n-1个符合条件的盘子放到第n个盘子上不就可以了。大概的思想如下：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-7.png" alt="image"></p><p>OK，下面展示程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> A,<span class="keyword">char</span> B,<span class="keyword">char</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(A+<span class="string">" -&gt; "</span>+C);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//上面n-1个盘子从A通过C想办法移到B上，对应上图的第一行图示</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,A,C,B);</span><br><span class="line">        <span class="comment">//将A剩下的盘子移到C上</span></span><br><span class="line">        System.out.println(A+<span class="string">" -&gt; "</span>+C);</span><br><span class="line">        <span class="comment">//这个n-1个盘子再想办法从B通过A移到C上，对应上如的第三行图示</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,B,A,C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先拿2测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   hanoi(<span class="number">2</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B</span><br><span class="line">A -&gt; C</span><br><span class="line">B -&gt; C</span><br></pre></td></tr></table></figure><p>是符合我们的预期的。并且尝试更多的时候，按照它一步一步是正确的。</p><p>如果理解了上面说的，那么这个程序是非常好理解的。但是真正想深入进递归里面，一旦多起来还是比较复杂的。其实我们可以这样理解：</p><blockquote><p>一个小朋友坐在第10排，他的作业本被小组长扔到了第1排，小朋友要拿回他的作业本，可以怎么办？他可以拍拍第9排小朋友，说：“帮我拿第1排的本子”，而第9排的小朋友可以拍拍第8排小朋友，说：“帮我拿第1排的本子”…如此下去，消息终于传到了第1排小朋友那里，于是他把本子递给第2排，第2排又递给第3排…终于，本子到手啦！这就是递归，拍拍小朋友的背可以类比函数调用，而小朋友们都记得要传消息、送本子，是因为他们有记忆力，这可以类比栈。</p><p>更严谨一些，递归蕴含的思想其实是数学归纳法：为了求解问题p（n），首先解决基础情形p（1），然后假定p（n-1）已经解决，在此基础上若p（n）得解，那所有问题均得解。这也启发我们：使用递归，切忌纠结中间步骤，因为这样做的代价是手动推理中间的若干步骤，而这些脏活，应该是计算机给我们干的!</p></blockquote><p>所以理解递归还是不能太纠结具体的过程，这样只会更加地糊涂，我们注重的应该是思想以及写递归的一些注意事项，比如对于参数的确定，停止条件以及每次都要缩小范围并且都是以1这个段位缩小，不要跨段不要跨段。</p><h2>递归与栈</h2><p>虽然说我们不能纠结于递归的过程，但是递归与栈关系紧密，区别只是这个栈是计算机系统栈帮我们实现，而迭代是我们自己控制栈来实现，两者的基本思想都是栈，那么我们就来探讨探讨递归与栈。这个问题也是我之前面试被问过的一个问题，希望再这里能有个比较清晰的理解。</p><p>前面说过，树是一个天然递归的数据结构，这里拿二叉树的前序遍历作为分析点，并且拿最简单的三个节点的二叉树作为示例。</p><p>对于树这个数据结构暂且不多说，我们如果用递归的方式来实现前序遍历还是非常简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个直接放到leetcode上竟然也是可以通过的，说明对这个递归答案还是认可的。不过这里想说明一下递归与栈的关系，所以需要详细说明一下它里面是如何通过系统栈来进行调用的。（前序遍历：144号，中序遍历84号，后序遍历145号）。</p><p>当然了，我们也知道递归相当于一个函数调用另一个子函数，它是自己再调用自己而已，递归借助了系统栈自己来实现的。我们这里以遍历最简单的二叉树为例：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-10.png" alt="image"></p><p>当执行到第一个<code>preorder</code>的时候，此时系统栈里面已经标志一下前面两句执行完毕，还剩下遍历右孩子的操作。此时就是已经遍历了1这个节点，下面就是准备进入1的左孩子即2这个节点的遍历。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-8.png" alt="image"></p><p>此时进入递归重新执行<code>preorder</code>，那么此时又将这个重新执行的函数的参数压到栈顶：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-9.png" alt="image"></p><p>此时2这个节点已经打印出来了，此时又要进入<code>preorder</code>重新执行了，再将2的左孩子放进<code>preorder</code>进行遍历，此时为null，那么就会直接结束<code>preorder</code>函数，返回来继续执行，此时<code>go 2-R</code>还没有执行，那么就是看看2的右孩子，也是null，那么此时关于2的节点的孩子们都遍历完毕了，就会出栈，回到一开始继续执行<code>go 1-R</code>。同理再去遍历1的右孩子们。</p><p>我们从上面的过程中知道，系统栈会保留递归调用的时候调用方的参数以及执行情况，等递归返回的时候，就可以将现场恢复并且继续执行。我们还明确，比如对于节点1来说，系统栈的处理方式是：先<code>count 1</code>即打印1，然后递归访问左孩子<code>go 1-L</code>，最后递归访问右孩子<code>go 1-R</code>，那么我们也可以用栈来模拟这个过程，那么压栈的过程必然是<code>go 1-R</code>–<code>go 1-L</code>–<code>count 1</code>，这样根据后进先出的原则，出来的顺序正好是<code>count 1</code>–<code>go 1-L</code>–<code>go 1-R</code>。</p><p>根据这个思路，我们完全可以将上面的递归程序改成用栈来实现。</p><p>首先将<code>root</code>入栈，并且标识为<code>go</code>，下面进入循环判断栈是否为空，不为空则进入循环。</p><p>首先是判断如果当前节点为<code>go</code>，则表示进行入栈操作，这里首先演示的是前序遍历，所以入栈的顺序是右孩子(go 1-R)–左孩子(go 1-L)–自身(print 1)，此时栈中已经有了这三个信息，那么进入下一次循环，首先出栈的就是自身(print 1)，那么则打印，继续循环，此时出栈的是左孩子(go 1-L)，因为是<code>go</code>所以要添加左右孩子，但是它没有左右孩子，则直接将<code>print 2</code>压入栈中，那么下次循环就会打印出来。最后同理就是右孩子出栈，跟2一样没有左右子孩子则直接将<code>print 3</code>压入栈中下次循环打印出来。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(String str,TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Command&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,root));</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Command command = stack.pop();</span><br><span class="line">            <span class="comment">//遇到go则按照顺序入栈</span></span><br><span class="line">            <span class="keyword">if</span> (command.str.equals(<span class="string">"go"</span>))&#123;</span><br><span class="line">                <span class="comment">//首先压入的是当前节点的右子节点</span></span><br><span class="line">                <span class="keyword">if</span>(command.node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,command.node.right));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//然后压入的是当前节点的左子节点</span></span><br><span class="line">                <span class="keyword">if</span>(command.node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,command.node.left));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后压入的是当前节点，准备打印</span></span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="string">"print"</span>,command.node));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//等于`print`的节点则打印出来</span></span><br><span class="line">                System.out.println(command.node.val);</span><br><span class="line">                res.add(command.node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的小伙伴可能会发现这个写法好像跟主流的写法不大一样，后面介绍二叉树的话会介绍一下主流的写法是什么，但是这个写法是比较通用的。原因在于这个写法是真正模拟了系统栈的执行流程，思路会比较清晰一点，并且它具有通用性，如果我想改为中序遍历或者后续遍历是非常简单的，只需要简单地调整<code>if (command.str.equals(&quot;go&quot;))</code>里面的顺序即可。</p><p>至此，简单地昭示了系统栈的执行流程，阐明了递归与栈之间的关系，并且用自己的栈来模拟系统栈写出了非递归的版本。递归在树这种数据结构中是随处可见的，应该对它重视起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么还要再来说说递归问题，因为数据结构中二叉树是比较重要也是比较难的数据结构，它的结构是天生递归的，所以对于二叉树的很多操作都可以用递归来实现，因此递归这一关能尽量理解是最好的，本章从汉诺塔的问题出发，来看看递归的实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法1-递归入门</title>
    <link href="http://yoursite.com/2019/02/25/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%951-%E9%80%92%E5%BD%92%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/02/25/algorithms-basic/基础算法1-递归入门/</id>
    <published>2019-02-25T13:19:57.931Z</published>
    <updated>2019-02-25T13:24:44.792Z</updated>
    
    <content type="html"><![CDATA[<p>算法入门系列以递归开头，我们知道，递归的编码往往是比较简单的，但是递归的思想往往又是难以理解。在写完这篇笔记之后仍然无法得递归之要领，不过对于如何写递归是有了一定得章法，一句话就是用数据归纳法，先尝试n得情况，再去考虑0或者1得情况，并且保证范围在逐渐缩小并且一定可以结束，下面我们来详细说一说递归。</p><a id="more"></a><h2>一、什么是递归</h2><p>我们可以把”递归“比喻成”查字典“，当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词。</p><p>可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。（摘自知乎的一个回答）</p><p>从程序本身来看，就是一个函数直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</p><p>我们这里以计算阶乘为切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;    </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> n * Factorial(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以上述代码为例，取 n=3，则过程如下：</p><p>第 1~4 步，都是入栈过程，<code>Factorial(3)</code>调用了<code>Factorial(2)</code>，<code>Factorial(2)</code>又接着调用<code>Factorial(1)</code>，直到<code>Factorial(0)</code>；</p><p>第 5 步，因 0 是递归结束条件，故不再入栈，此时栈高度为 4，即为我们平时所说的递归深度；</p><p>第 6~9 步，<code>Factorial(0)</code>做完，出栈，而<code>Factorial(0)</code>做完意味着<code>Factorial(1)</code>也做完，同样进行出栈，重复下去，直到所有的都出栈完毕，递归结束。</p><p>可以看出来，递归的本质就是由一个系统栈不停地保存每一层调用的方法及其参数，直到遇到终止条件为止，一层一层地结束返回，但是当层数过深的时候就有可能出现<code>stack overflow</code>这样的栈溢出错误。</p><p>也可以看出来，每一个递归程序都可以把它改写为非递归版本。但是并不是每个递归程序都是那么容易被改写为非递归的。某些递归程序比较复杂，其入栈和出栈非常繁琐，给编码带来了很大难度，而且易读性极差，所以条件允许的情况下，推荐使用递归。</p><h2>二、如何思考递归</h2><p>在初学递归的时候, 看到一个递归实现, 我们总是难免陷入不停的验证之中，比如上面提及的阶乘，求解<code>Factorial(n)</code>时，我们总会情不自禁的发问，<code>Factorial(n-1)</code>可以求出正确的答案么？接着我们就会再用<code>Factorial(n-2)</code>去验证，，，不停地往下验证直到<code>Factorial(0)</code>。</p><p>对递归这样的不适应，和我们平时习惯的思维方式有关。我们习惯的思维是：已知<code>Factorial(0)</code>，乘上 1 就等于<code>Factorial(1)</code>，再乘以 2 就等于<code>Factorial(2)</code>，，，直到乘到 n。</p><p>因此，递归和我们的思维方式正好相反。这就会给我们编程造成相当大的思维干扰。</p><p>其实，递归的数学思想是数学归纳法：</p><ul><li>如果下面这两点是成立的，我们就知道这个递归对于所有的 n 都是正确的。</li><li>1）当 n=0,1 时，结果正确；</li><li>2）假设递归对于 n 是正确的，同时对于 n+1 也正确。</li></ul><p>在递归中，我们通常把第 1 点称为终止条件，因为这样更容易理解，其作用就是终止递归，防止递归无限地运行下去。</p><p>对于第二点就是假定如果n-1的情况是正确的，那么n的情况就是正确的，然后再假定n-2的情况是正确的，那么n-1的情况也是正确的，那么就会一直推导到特殊情况比如0的时候，这个时候是正确的，那么前面所有的都是正确的。</p><p>从而达到了上面说的，将一个复杂的问题一层一层地转化为相似的小规模的问题，这样，解决了小规模问题之后一层一层地就可以返回来求出复杂的问题。</p><p>根据数学归纳法，其实我们还可以归纳出编写递归程序的一些准则：</p><ul><li>严格定义递归函数作用，包括参数、返回值、<code>side-effect</code></li><li>先一般再特殊</li><li>每次调用必须缩小问题规模</li><li>每次问题规模缩小程度必须为1</li></ul><p>这里简单地再解释一下，第一条中注意的是<code>side-effect</code>，这些是一些存储状态的变量，比如一些全局的变量来控制递归里面的一些逻辑等等。</p><p>考虑问题的时候可以从特殊的问题来考虑，但是在编写递归程序的时候，最好是先考虑一般的场景，最后再来看特殊的场景从而终止递归。并且每次缩小程度为1，不能为2或者3等。</p><p>好了，其实递归真正说起来好像也就那回事，但是真正用好确实是需要大量的训练，即递归的思维训练。</p><h2>三、递归的方式创建单向链表</h2><p>首先定义一下链表类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(head.val+<span class="string">"-&gt;"</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"null"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个数组：1，2，3，4，5，目标是将它们转换为链表。</p><p>正常的思维是：创建节点<code>node1</code>，<code>node2</code>，然后<code>node1</code>的<code>next</code>指向<code>node2</code>，依次类推直到最后。但是用递归的时候就不要这么想了，我们的思维方式变为：</p><p>假设2，3，4，5已经组装好了，那么我只需要再将1插到这个组装好的链表的最前面即可：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-1.png" alt="image"></p><p>那么，首先我们确定函数参数，返回值等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，首先，我取出1作为<code>firstNode</code>，然后我这个1指向的是后面已经排好的(2-&gt;3-&gt;4-&gt;5)这个链表，此时不就成功了嘛！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取数组第一个元素</span></span><br><span class="line">    Node firstNode = <span class="keyword">new</span> Node(values.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//获取后面排好的链表的头节点</span></span><br><span class="line">    Node fisrtSubNode = createLinkedList(values.subList(<span class="number">1</span>,values.size()));</span><br><span class="line">    <span class="comment">//第一个元素指向后面排好的链表的头节点即可</span></span><br><span class="line">    firstNode.setNext(fisrtSubNode);</span><br><span class="line">    <span class="comment">//返回整个链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> firstNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们只要知道：<code>createLinkedList(values.subList(1,values.size()));</code>这个就可以帮助我们拼接成我们需要的(2-&gt;3-&gt;4-&gt;5)这个链表，下面我只需要将1指向这个链表就可以成功了。我们仔细来看这个函数，就是调用自身，即递归，里面参数是：除了第一个元素外剩余的元素，并且每一层就剔除掉第一个元素，那么此时还需要一个终止条件，就是这个数组已经没有元素了就停止。所以完整的程序是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    <span class="comment">//5.递归停止的条件就是没有元素了</span></span><br><span class="line">    <span class="keyword">if</span> (values.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.获取数组第一个元素</span></span><br><span class="line">    Node firstNode = <span class="keyword">new</span> Node(values.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//2.获取后面排好的链表的头节点，用subList来截取，逐渐地截短使得问题的规模变小</span></span><br><span class="line">    Node fisrtSubNode = createLinkedList(values.subList(<span class="number">1</span>,values.size()));</span><br><span class="line">    <span class="comment">//3.第一个元素指向后面排好的链表的头节点即可</span></span><br><span class="line">    firstNode.setNext(fisrtSubNode);</span><br><span class="line">    <span class="comment">//4.返回整个链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> firstNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以想象，一层一层地剔除第一个元素，过程是(2-&gt;3-&gt;4-&gt;5)，(3-&gt;4-&gt;5)，(4-&gt;5)，（5)，()，此时为空了停止，就会返回到上一层执行的地方，即<code>Node fisrtSubNode = null</code>这一句，此时，上一层的<code>firstNode</code>就是5，那么继续执行就是<code>5.setNext(null)</code>，<code>return 5</code>，这一层又结束了返回到上一层，上一层此时<code>firstNode=4</code>，那么<code>fisrtSubNode = 5</code>，然后继续执行就是<code>4.setNext(5)</code>，最后<code>return 4</code>，此时链表已经是<code>4-&gt;5-&gt;null</code>了，再重复以上的过程直到<code>2-&gt;3-&gt;4-&gt;5-&gt;null</code>，此时回到最上层，即一开始的地方，即假定1后面就是拼接好的链表，此时确实也是拼接好的。所以这里用的就是数学归纳法的思想。</p><h2>四、递归的方式反转单向链表</h2><p>链表的反转效果为：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-2.png" alt="image"></p><p>我们跟上面一样考虑，考虑一般的情况，那就是1后面的所有元素已经全部反转好了，初始状态为：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-3.png" alt="image"></p><p>此时假定后面全部反转好了：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-4.png" alt="image"></p><p>下面只需要将2指向1，并且1指向null即可：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-5.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node newHead = reverseLinkedList(head.getNext());</span><br><span class="line">    head.getNext().setNext(head);</span><br><span class="line">    head.setNext(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>六、递归存在的问题</h2><p>比如计算斐波那契数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==<span class="number">1</span>||index==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fib(index-<span class="number">1</span>)+fib(index-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个递归里做了冗余的工作，如图，我们在f4里面已经计算了f2，可是f3里有同样计算了f2，以此类推那些冗余的工作，在数值比较小的情况下，计算机还是可以接受的。但是，当求解的数值比较大，它是成指数级增长的，所以不要再递归中做重复的工作。</p><p><img src="http://bloghello.oursnail.cn/suanfa1-7.png" alt="image"></p><p>下一节通过经典得汉诺塔问题再来探讨一下递归的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法入门系列以递归开头，我们知道，递归的编码往往是比较简单的，但是递归的思想往往又是难以理解。在写完这篇笔记之后仍然无法得递归之要领，不过对于如何写递归是有了一定得章法，一句话就是用数据归纳法，先尝试n得情况，再去考虑0或者1得情况，并且保证范围在逐渐缩小并且一定可以结束，下面我们来详细说一说递归。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记12-分布式锁</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B012-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记12-分布式锁/</id>
    <published>2019-02-23T08:48:05.271Z</published>
    <updated>2019-02-23T08:51:35.857Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁在分布式系统中是非常常见的，redis以及ZK都可以实现分布式锁，在文章<a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">Curator</a>从实战的层面进行了实际的分布式锁的实现，具体看这个文章即可。下面是再唠叨唠叨。</p><a id="more"></a><h2>redis实现分布式锁</h2><p>之前，在<a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">redis实现分布式锁</a>实现过一个基于redis的分布式锁，用来保证一个系统去定时关单。</p><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V2.png" alt="image"></p><p>这上面两个例子，一个是针对多个系统修改同一个资源，一个是面临高并发下订单时控制同一时间只能有一个用户拿到锁然后下订单（可能是多个系统，比如是订单服务器和库存服务器，当然，为了解耦和提高速度，那么可以把写订单表这个逻辑用MQ异步出去），首先我要判断库存是不是真的够，那么这个时候我就要用分布式锁控制，防止两个用户同时来查库存数量然后都觉得自己可以下订单（极端情况，库存只有1，那么这两个用户同时查到为1，那么都认为自己可以下订单咋办？），其他的用户必须等到这个用户释放锁或者超时才可以再拿到锁再去执行操作。这样，有效地解决了商品的超卖问题。</p><p>优点：实现简单，吞吐量十分客观，对于高并发情况应付自如，自带超时保护，对于网络抖动的情况也可以利用超时删除策略保证不会阻塞所有流程。但是redis存在一些问题：</p><ul><li><strong>单点问题</strong>：因为redis一般都是单实例使用，那么对于单点问题，可以做一个主从。当然主从切换的时候也是不可用的，因为主从同步是异步的，可能会并发问题。如果对于主从还是不能保证可靠性的话，可以上Redis集群，对于Redis集群，因为使用了类一致性Hash算法，虽然不能避免节点下线的并发问题(当前的任务没有执行完，其他任务就开始执行)，但是能保证Redis是可用的。可用性的问题是出了问题之后的备选方案，如果我们系统天天都出问题还玩毛啊，对于突发情况牺牲一两个请求还是没问题的。</li><li><strong>锁删除失败</strong>：分布式锁基本都有这个问题，可以对key设置失效时间。这个超时时间需要把控好，过大那么系统吞吐量低，很容易导致超时。如果过小那么会有并发问题，部分耗时时间比较长的任务就要遭殃了。</li></ul><p><strong>redis集群的同步策略是需要时间的，有可能A线程setNX成功后拿到锁，但是这个值还没有更新到B线程执行setNX的这台服务器，那就会产生并发问题。</strong></p><h3>zookeeper实现分布式锁</h3><p>Zookeeper是一个分布式一致性协调框架，主要可以实现选主、配置管理和分布式锁等常用功能，因为Zookeeper的写入都是顺序的，在一个节点创建之后，其他请求再次创建便会失败，同时可以对这个节点进行Watch，如果节点删除会通知其他节点抢占锁。</p><p>Zookeeper实现分布式锁虽然是比较重量级的，但实现的锁功能十分健全，由于Zookeeper本身需要维护自己的一致性，所以性能上较Redis还是有一定差距的。</p><p>“惊群”就是在一个节点删除的时候，大量对这个节点的删除动作有订阅Watcher的线程会进行回调，这对Zk集群是十分不利的。所以需要避免这种现象的发生。</p><p>为了解决“惊群“问题，我们需要放弃订阅一个节点的策略，那么怎么做呢？详细看这里：<a href="https://www.jianshu.com/p/5d12a01018e1" target="_blank" rel="noopener">https://www.jianshu.com/p/5d12a01018e1</a></p><p>最后想说明一点，其实对于Zookeeper的一些常用功能是有一些成熟的包实现的，像Curator。Curator的确是足够牛逼，不仅封装了Zookeeper的常用API，也包装了很多常用Case的实现。形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"><span class="keyword">if</span> ( lock.acquire(maxWait, waitUnit) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do some work inside of the critical section here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的时间在<a href="https://github.com/sunweiguo/mama-buy" target="_blank" rel="noopener">分布式电商项目-码码购</a>中用<code>Curator</code>实现分布式锁实现了某些场景的需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式锁在分布式系统中是非常常见的，redis以及ZK都可以实现分布式锁，在文章&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Curator&lt;/a&gt;从实战的层面进行了实际的分布式锁的实现，具体看这个文章即可。下面是再唠叨唠叨。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记11-Apache Curator客户端的使用（二）</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B011-Apache%20Curator%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记11-Apache Curator客户端的使用（二）/</id>
    <published>2019-02-23T08:46:29.028Z</published>
    <updated>2019-02-23T08:47:11.188Z</updated>
    
    <content type="html"><![CDATA[<p>本文来继续来看Apache Curator客户端的使用！</p><a id="more"></a><h2>zk-watcher应用实例之模拟统一更新N台节点的配置文件</h2><p>zookeeper有一个比较常见的应用场景就是统一管理、更新分布式集群环境中每个节点的配置文件，我们可以在代码中监听集群中的节点，当节点数据发生改变时就同步到其他节点上。如下图：</p><p><img src="http://bloghello.oursnail.cn/18-12-10/90520428.jpg" alt="image"></p><p>因为我们使用的json作为节点存储的数据格式，所以需要准备一个工具类来做json与pojo对象的一个转换，也就是所谓的反序列化。创建一个 JsonUtils 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义jackson对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象转换成json字符串。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Title: pojoToJson&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Description: &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">objectToJson</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String string = MAPPER.writeValueAsString(data);</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json结果集转化为对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanType 对象中的object类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">jsonToPojo</span><span class="params">(String jsonData, Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T t = MAPPER.readValue(jsonData, beanType);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json数据转换成pojo对象list</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Title: jsonToList&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Description: &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function">List&lt;T&gt; <span class="title">jsonToList</span><span class="params">(String jsonData, Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">        JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要额外的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后创建客户端类，客户端类就是用来监听集群中的节点的。由于是模拟，所以这里的部分代码是伪代码。客户端类我们这里创建了三个，因为集群中有三个节点，由于代码基本上是一样的，每个客户端分别监听watch事件，所以这里只贴出客户端_1的代码。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerIp = <span class="string">"192.168.190.128:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化重连策略以及客户端对象并启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerIp)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  public final static String CONFIG_NODE = "/super/testNode/redis-config";</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONFIG_NODE_PATH = <span class="string">"/super/testNode"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SUB_PATH = <span class="string">"/redis-config"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CountDownLatch countDown = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Client_1 cto = <span class="keyword">new</span> Client_1();</span><br><span class="line">        System.out.println(<span class="string">"client1 启动成功..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启子节点缓存</span></span><br><span class="line">        <span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(cto.client, CONFIG_NODE_PATH, <span class="keyword">true</span>);</span><br><span class="line">        childrenCache.start(StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加子节点监听事件</span></span><br><span class="line">        childrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 监听节点的数据更新事件</span></span><br><span class="line">                <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) &#123;</span><br><span class="line">                    String configNodePath = event.getData().getPath();</span><br><span class="line">                    <span class="keyword">if</span> (configNodePath.equals(CONFIG_NODE_PATH + SUB_PATH)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"监听到配置发生变化，节点路径为:"</span> + configNodePath);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取节点数据</span></span><br><span class="line">                        String jsonConfig = <span class="keyword">new</span> String(event.getData().getData());</span><br><span class="line">                        System.out.println(<span class="string">"节点"</span> + CONFIG_NODE_PATH + <span class="string">"的数据为: "</span> + jsonConfig);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 从json转换配置</span></span><br><span class="line">                        RedisConfig redisConfig = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotBlank(jsonConfig)) &#123;</span><br><span class="line">                            redisConfig = JsonUtils.jsonToPojo(jsonConfig, RedisConfig.class);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 配置不为空则进行相应操作</span></span><br><span class="line">                        <span class="keyword">if</span> (redisConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            String type = redisConfig.getType();</span><br><span class="line">                            String url = redisConfig.getUrl();</span><br><span class="line">                            String remark = redisConfig.getRemark();</span><br><span class="line">                            <span class="comment">// 判断事件</span></span><br><span class="line">                            <span class="keyword">if</span> (type.equals(<span class="string">"add"</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"\n-------------------\n"</span>);</span><br><span class="line">                                System.out.println(<span class="string">"监听到新增的配置，准备下载..."</span>);</span><br><span class="line">                                <span class="comment">// ... 连接ftp服务器，根据url找到相应的配置</span></span><br><span class="line">                                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                                System.out.println(<span class="string">"开始下载新的配置文件，下载路径为&lt;"</span> + url + <span class="string">"&gt;"</span>);</span><br><span class="line">                                <span class="comment">// ... 下载配置到你指定的目录</span></span><br><span class="line">                                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                                System.out.println(<span class="string">"下载成功，已经添加到项目中"</span>);</span><br><span class="line">                                <span class="comment">// ... 拷贝文件到项目目录</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"update"</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"\n-------------------\n"</span>);</span><br><span class="line">                                System.out.println(<span class="string">"监听到更新的配置，准备下载..."</span>);</span><br><span class="line">                                <span class="comment">// ... 连接ftp服务器，根据url找到相应的配置</span></span><br><span class="line">                                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                                System.out.println(<span class="string">"开始下载配置文件，下载路径为&lt;"</span> + url + <span class="string">"&gt;"</span>);</span><br><span class="line">                                <span class="comment">// ... 下载配置到你指定的目录</span></span><br><span class="line">                                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                                System.out.println(<span class="string">"下载成功..."</span>);</span><br><span class="line">                                System.out.println(<span class="string">"删除项目中原配置文件..."</span>);</span><br><span class="line">                                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                                <span class="comment">// ... 删除原文件</span></span><br><span class="line">                                System.out.println(<span class="string">"拷贝配置文件到项目目录..."</span>);</span><br><span class="line">                                <span class="comment">// ... 拷贝文件到项目目录</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"delete"</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"\n-------------------\n"</span>);</span><br><span class="line">                                System.out.println(<span class="string">"监听到需要删除配置"</span>);</span><br><span class="line">                                System.out.println(<span class="string">"删除项目中原配置文件..."</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// TODO 视情况统一重启服务</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        countDown.await();</span><br><span class="line"></span><br><span class="line">        cto.closeZKClient();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上代码的编写后，将所有的客户类都运行起来。然后到zookeeper服务器上，进行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 14] set /workspace/super/testNode/redis-config &#123;&quot;type&quot;:&quot;add&quot;,&quot;url&quot;:&quot;ftp://192.168.10.123/config/redis.xml&quot;,&quot;remark&quot;:&quot;add&quot;&#125;</span><br><span class="line">cZxid = 0xc00000039</span><br><span class="line">ctime = Mon Apr 30 01:43:47 CST 2018</span><br><span class="line">mZxid = 0xc00000043</span><br><span class="line">mtime = Mon Apr 30 01:52:35 CST 2018</span><br><span class="line">pZxid = 0xc00000039</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 75</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 15] set /workspace/super/testNode/redis-config &#123;&quot;type&quot;:&quot;update&quot;,&quot;url&quot;:&quot;ftp://192.168.10.123/config/redis.xml&quot;,&quot;remark&quot;:&quot;update&quot;&#125;</span><br><span class="line">cZxid = 0xc00000039</span><br><span class="line">ctime = Mon Apr 30 01:43:47 CST 2018</span><br><span class="line">mZxid = 0xc00000044</span><br><span class="line">mtime = Mon Apr 30 01:53:46 CST 2018</span><br><span class="line">pZxid = 0xc00000039</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 81</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 16] set /workspace/super/testNode/redis-config &#123;&quot;type&quot;:&quot;delete&quot;,&quot;url&quot;:&quot;&quot;,&quot;remark&quot;:&quot;delete&quot;&#125;   </span><br><span class="line">cZxid = 0xc00000039               </span><br><span class="line">ctime = Mon Apr 30 01:43:47 CST 2018</span><br><span class="line">mZxid = 0xc00000045</span><br><span class="line">mtime = Mon Apr 30 01:54:06 CST 2018</span><br><span class="line">pZxid = 0xc00000039</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 44</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 17]</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/18-12-10/55655494.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-12-10/45175373.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-12-10/92597884.jpg" alt="image"></p><p>如上，从三个客户端的控制台输出信息可以看到，三个节点都进行了同样操作，触发了同样的watch事件，这样就可以完成统一的配置文件管理。</p><h2>curator之acl权限操作与认证授权</h2><p>我们先演示在创建节点时设置acl权限，现在/workspace/super只有如下节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 27] ls /workspace/super</span><br><span class="line">[xxxnode, testNode]</span><br></pre></td></tr></table></figure><p>然后新建一个 CuratorAcl 类，关于acl权限的概念以及部分API代码都在之前的zk原生API使用一文中介绍过了，所以这里就不赘述了。编写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorAcl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Curator客户端</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集群模式则是多个ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerIps = <span class="string">"192.168.190.128:2181,192.168.190.129:2181,192.168.190.130:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorAcl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder().authorization(<span class="string">"digest"</span>, <span class="string">"user1:123456a"</span>.getBytes())  <span class="comment">// 认证授权，登录用户</span></span><br><span class="line">                .connectString(zkServerIps)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorAcl cto = <span class="keyword">new</span> CuratorAcl();</span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = cto.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line"></span><br><span class="line">        String nodePath = <span class="string">"/super/testAclNode/testOne"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义权限列表</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">        Id user1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, AclUtils.getDigestUserPwd(<span class="string">"user1:123456a"</span>));</span><br><span class="line">        Id user2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, AclUtils.getDigestUserPwd(<span class="string">"user2:123456b"</span>));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL, user1));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ, user2));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.DELETE | ZooDefs.Perms.CREATE, user2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点，使用自定义权限列表来设置节点的acl权限</span></span><br><span class="line">        <span class="keyword">byte</span>[] nodeData = <span class="string">"child-data"</span>.getBytes();</span><br><span class="line">        cto.client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).withACL(acls).forPath(nodePath, nodeData);</span><br><span class="line"></span><br><span class="line">        cto.closeZKClient();</span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted2 = cto.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted2 ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类，然后到zookeeper服务器上，通过命令行进行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 19] ls /workspace/super/testAclNode    </span><br><span class="line">[testOne]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 20] getAcl /workspace/super/testAclNode</span><br><span class="line">&apos;world,&apos;anyone</span><br><span class="line">: cdrwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 21] getAcl /workspace/super/testAclNode/testOne</span><br><span class="line">&apos;digest,&apos;user1:TQYTqd46qVVbWpOd02tLO5qb+JM=</span><br><span class="line">: cdrwa</span><br><span class="line">&apos;digest,&apos;user2:CV4ED0rE6SxA3h/DN/WyScDMbCs=</span><br><span class="line">: r</span><br><span class="line">&apos;digest,&apos;user2:CV4ED0rE6SxA3h/DN/WyScDMbCs=</span><br><span class="line">: cd</span><br></pre></td></tr></table></figure><p>如上，可以看到，创建的全部节点的acl权限都是我们设置的自定义权限。</p><p>最后我们再来演示如何修改一个已存在的节点的acl权限，修改 CuratorAcl 类中的main方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化</span></span><br><span class="line">    CuratorAcl cto = <span class="keyword">new</span> CuratorAcl();</span><br><span class="line">    <span class="keyword">boolean</span> isZkCuratorStarted = cto.client.isStarted();</span><br><span class="line">    System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line"></span><br><span class="line">    String nodePath = <span class="string">"/super/testAclNodeTwo/testOne"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义权限列表</span></span><br><span class="line">    List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">    Id user1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, AclUtils.getDigestUserPwd(<span class="string">"user1:123456a"</span>));</span><br><span class="line">    Id user2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, AclUtils.getDigestUserPwd(<span class="string">"user2:123456b"</span>));</span><br><span class="line">    acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ | ZooDefs.Perms.CREATE | ZooDefs.Perms.ADMIN, user1));</span><br><span class="line">    acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ | ZooDefs.Perms.DELETE | ZooDefs.Perms.CREATE, user2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定节点的acl权限</span></span><br><span class="line">    cto.client.setACL().withACL(acls).forPath(nodePath);</span><br><span class="line"></span><br><span class="line">    cto.closeZKClient();</span><br><span class="line">    <span class="keyword">boolean</span> isZkCuratorStarted2 = cto.client.isStarted();</span><br><span class="line">    System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted2 ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类，然后到zookeeper服务器上，通过命令行进行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 31] getAcl /workspace/super/testAclNodeTwo/testOne</span><br><span class="line">&apos;digest,&apos;user1:TQYTqd46qVVbWpOd02tLO5qb+JM=</span><br><span class="line">: cra</span><br><span class="line">&apos;digest,&apos;user2:CV4ED0rE6SxA3h/DN/WyScDMbCs=</span><br><span class="line">: cdr</span><br><span class="line">[zk: localhost:2181(CONNECTED) 32]</span><br></pre></td></tr></table></figure><p>可以看到，成功修改了该节点的acl权限。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来继续来看Apache Curator客户端的使用！&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记10-Apache Curator客户端的使用（一）</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B010-Apache%20Curator%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记10-Apache Curator客户端的使用（一）/</id>
    <published>2019-02-23T08:43:42.684Z</published>
    <updated>2019-02-23T08:45:37.497Z</updated>
    
    <content type="html"><![CDATA[<p>本文来看看Apache Curator客户端的使用吧！</p><a id="more"></a><h2>一、前言</h2><p>对于上一章中应用的java 原生API来操作节点。来看看他的不足：</p><ul><li>超时重连，不支持自动，需要手动操作</li><li>watcher注册一次后会失效</li><li>不支持递归创建节点</li></ul><p>对于Apache Curator开源客户端，具有以下的优点：</p><ul><li>Apache的开源项目，值得信赖</li><li>解决watcher的注册一次就失效的问题</li><li>API更加简单易用</li><li>提供更多解决方案并且实现简单，比如分布式锁</li><li>提供常用的zookeeper工具类</li><li>编程风格更爽</li></ul><p>本篇文章为上半部分，主要学习了一下自动重连、创建节点、查询节点数据和子节点、删除和修改节点数据。还有就是用nodeCache以及PathChildrenCache缓存节点数据来解决注册一次就失效的问题。</p><h2>二、使用</h2><p>首先新建一个maven工程，我这里直接新建了一个SpringBoot工程，依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--curator--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2>三、连接&amp;自动重连</h2><p>配置完依赖后，我们就可以来写一个简单的demo测试与zookeeper服务端的连接。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorConnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * （推荐）</span></span><br><span class="line"><span class="comment">         * 同步创建zk示例，原生api是异步的</span></span><br><span class="line"><span class="comment">         * 这一步是设置重连策略</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 构造器参数：</span></span><br><span class="line"><span class="comment">         *  curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment">         *  baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment">         *  maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment">         *  maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>,<span class="number">5</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerPath)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10</span>*<span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(client != <span class="keyword">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="keyword">boolean</span> isZkClientStart = curatorConnect.client.isStarted();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端是否打开:"</span>+isZkClientStart);</span><br><span class="line"></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        isZkClientStart = curatorConnect.client.isStarted();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端是否打开:"</span>+isZkClientStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>curator连接zookeeper服务器时有自动重连机制，而curator的重连策略有五种。</p><ul><li>第一种就是上面提到的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （推荐）</span></span><br><span class="line"><span class="comment"> * 同步创建zk示例，原生api是异步的</span></span><br><span class="line"><span class="comment"> * 这一步是设置重连策略</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造器参数：</span></span><br><span class="line"><span class="comment"> *  curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment"> *  baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment"> *  maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment"> *  maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>第二种，可设定重连n次：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （推荐）</span></span><br><span class="line"><span class="comment"> * curator链接zookeeper的策略:RetryNTimes</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造器参数：</span></span><br><span class="line"><span class="comment"> * n：重试的次数</span></span><br><span class="line"><span class="comment"> * sleepMsBetweenRetries：每次重试间隔的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><ul><li>第三种，只会重连一次：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （不推荐）</span></span><br><span class="line"><span class="comment"> * curator链接zookeeper的策略:RetryOneTime</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造器参数：</span></span><br><span class="line"><span class="comment"> * sleepMsBetweenRetry:每次重试间隔的时间</span></span><br><span class="line"><span class="comment"> * 这个策略只会重试一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy2 = <span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>第四种，永远重连：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 永远重试，不推荐使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy3 = <span class="keyword">new</span> RetryForever(retryIntervalMs)</span><br></pre></td></tr></table></figure><ul><li>第五种，可设定最大重试时间：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * curator链接zookeeper的策略:RetryUntilElapsed</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造器参数：</span></span><br><span class="line"><span class="comment"> * maxElapsedTimeMs:最大重试时间</span></span><br><span class="line"><span class="comment"> * sleepMsBetweenRetries:每次重试间隔</span></span><br><span class="line"><span class="comment"> * 重试时间超过maxElapsedTimeMs后，就不再重试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy4 = <span class="keyword">new</span> RetryUntilElapsed(<span class="number">2000</span>, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2>四、zk命名空间以及创建节点</h2><p>zookeeper的命名空间就类似于我们平时使用Eclipse等开发工具的工作空间一样，我们该连接中所有的操作都是基于这个命名空间的。curator提供了设置命名空间的方法，这样我们任何的连接都可以去设置一个命名空间。设置了命名空间并成功连接后，zookeeper的根节点会多出一个以命名空间名称所命名的节点。然后我们在该连接的增删查改等操作都会在这个节点中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorCreateNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Curator客户端</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集群模式则是多个ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerIps = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorCreateNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化Curator客户端</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder() <span class="comment">// 使用工厂类来建造客户端的实例对象</span></span><br><span class="line">                .connectString(zkServerIps)  <span class="comment">// 放入zookeeper服务器ip</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)  <span class="comment">// 设定会话时间以及重连策略</span></span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();  <span class="comment">// 设置命名空间以及开始建立连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动Curator客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭zk客户端连接</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorCreateNode curatorConnect = <span class="keyword">new</span> CuratorCreateNode();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;  <span class="comment">// 节点路径</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">"this is a test data"</span>.getBytes();  <span class="comment">// 节点数据</span></span><br><span class="line">        String result = curatorConnect.client.create().creatingParentsIfNeeded()  <span class="comment">// 创建父节点，也就是会递归创建</span></span><br><span class="line">                .withMode(CreateMode.PERSISTENT)  <span class="comment">// 节点类型</span></span><br><span class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)  <span class="comment">// 节点的acl权限</span></span><br><span class="line">                .forPath(nodePath, data);</span><br><span class="line"></span><br><span class="line">        System.out.println(result + <span class="string">"节点，创建成功..."</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类，控制台输出信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前客户端的状态：连接中...</span><br><span class="line">/super/testNode节点，创建成功...</span><br><span class="line">当前客户端的状态：已关闭...</span><br></pre></td></tr></table></figure><h2>五、修改节点以及删除节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Curator客户端</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集群模式则是多个ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerIps = <span class="string">"192.168.190.128:2181,192.168.190.129:2181,192.168.190.130:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化Curator客户端</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder() <span class="comment">// 使用工厂类来建造客户端的实例对象</span></span><br><span class="line">                .connectString(zkServerIps)  <span class="comment">// 放入zookeeper服务器ip</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)  <span class="comment">// 设定会话时间以及重连策略</span></span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();  <span class="comment">// 设置命名空间以及开始建立连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动Curator客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭zk客户端连接</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新节点数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] newData = <span class="string">"this is a new data"</span>.getBytes();</span><br><span class="line">        Stat resultStat = curatorConnect.client.setData().withVersion(<span class="number">0</span>)  <span class="comment">// 指定数据版本</span></span><br><span class="line">                .forPath(nodePath, newData);  <span class="comment">// 需要修改的节点路径以及新数据</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"更新节点数据成功，新的数据版本为："</span> + resultStat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        curatorConnect.client.delete()</span><br><span class="line">                .guaranteed()  <span class="comment">// 如果删除失败，那么在后端还是会继续删除，直到成功</span></span><br><span class="line">                .deletingChildrenIfNeeded()  <span class="comment">// 子节点也一并删除，也就是会递归删除</span></span><br><span class="line">                .withVersion(resultStat.getVersion())</span><br><span class="line">                .forPath(nodePath);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>六、查询节点相关信息</h2><p>1.获取某个节点的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取节点数据</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] nodeData = curatorConnect.client.getData().storingStatIn(stat).forPath(nodePath);</span><br><span class="line">        System.out.println(<span class="string">"节点 "</span> + nodePath + <span class="string">" 的数据为："</span> + <span class="keyword">new</span> String(nodeData));</span><br><span class="line">        System.out.println(<span class="string">"该节点的数据版本号为："</span> + stat.getVersion());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.获取某个节点下的子节点列表，现有一个节点的子节点列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 33] ls /workspace/super/testNode</span><br><span class="line">[threeNode, twoNode, oneNode]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 34]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取子节点列表</span></span><br><span class="line">        List&lt;String&gt; childNodes = curatorConnect.client.getChildren().forPath(nodePath);</span><br><span class="line">        System.out.println(nodePath + <span class="string">" 节点下的子节点列表："</span>);</span><br><span class="line">        <span class="keyword">for</span> (String childNode : childNodes) &#123;</span><br><span class="line">            System.out.println(childNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.查询某个节点是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询某个节点是否存在，存在就会返回该节点的状态信息，如果不存在的话则返回空</span></span><br><span class="line">        Stat statExist = curatorConnect.client.checkExists().forPath(nodePath);</span><br><span class="line">        <span class="keyword">if</span> (statExist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(nodePath + <span class="string">" 节点不存在"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(nodePath + <span class="string">" 节点存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>七、curator之usingWatcher</h2><p>curator在注册watch事件上，提供了一个usingWatcher方法，使用这个方法注册的watch事件和默认watch事件一样，监听只会触发一次，监听完毕后就会销毁，也就是一次性的。而这个方法有两种参数可选，一个是zk原生API的Watcher接口的实现类，另一个是Curator提供的CuratorWatcher接口的实现类，不过在usingWatcher方法上使用哪一个效果都是一样的，都是一次性的。</p><p>新建一个 MyWatcher 实现类，实现 Watcher 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: zookeeper-connection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:  zk原生API的Watcher接口实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-04-28 13:41</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Watcher事件通知方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"触发watcher，节点路径为："</span> + watchedEvent.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个 MyCuratorWatcher 实现类，实现 CuratorWatcher 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: zookeeper-connection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Curator提供的CuratorWatcher接口实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-04-28 13:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCuratorWatcher</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Watcher事件通知方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"触发watcher，节点路径为："</span> + watchedEvent.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 watcher 事件，当使用usingWatcher的时候，监听只会触发一次，监听完毕后就销毁</span></span><br><span class="line">        curatorConnect.client.getData().usingWatcher(<span class="keyword">new</span> MyCuratorWatcher()).forPath(nodePath);</span><br><span class="line">        <span class="comment">// curatorConnect.client.getData().usingWatcher(new MyWatcher()).forPath(nodePath);</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类，然后到zookeeper服务器上修改/super/testNode节点的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">35</span>] set /workspace/<span class="keyword">super</span>/testNode <span class="keyword">new</span>-data</span><br><span class="line">cZxid = <span class="number">0xb00000015</span></span><br><span class="line">ctime = Sat Apr <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">57</span> CST <span class="number">2018</span></span><br><span class="line">mZxid = <span class="number">0xb0000002b</span></span><br><span class="line">mtime = Sat Apr <span class="number">28</span> <span class="number">21</span>:<span class="number">40</span>:<span class="number">58</span> CST <span class="number">2018</span></span><br><span class="line">pZxid = <span class="number">0xb0000001c</span></span><br><span class="line">cversion = <span class="number">3</span></span><br><span class="line">dataVersion = <span class="number">2</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x0</span></span><br><span class="line">dataLength = <span class="number">8</span></span><br><span class="line">numChildren = <span class="number">3</span></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">36</span>]</span><br></pre></td></tr></table></figure><p>修改完成后，此时控制台输出内容如下，因为workspace是命名空间节点，所以不会被打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">触发watcher，节点路径为：/super/testNode</span><br></pre></td></tr></table></figure><h2>八、curator之nodeCache一次注册N次监听</h2><p>想要实现watch一次注册n次监听的话，我们需要使用到curator里的一个NodeCache对象。这个对象可以用来缓存节点数据，并且可以给节点添加nodeChange事件，当节点的数据发生变化就会触发这个事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// NodeCache: 缓存节点，并且可以监听数据节点的变更，会触发事件</span></span><br><span class="line">        <span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(curatorConnect.client, nodePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数 buildInitial : 初始化的时候获取node的值并且缓存</span></span><br><span class="line">        nodeCache.start(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取缓存里的节点初始化数据</span></span><br><span class="line">        <span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"节点初始化数据为："</span> + <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"节点初始化数据为空..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为缓存的节点添加watcher，或者说添加监听器</span></span><br><span class="line">        nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">            <span class="comment">// 节点数据change事件的通知方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 防止节点被删除时发生错误</span></span><br><span class="line">                <span class="keyword">if</span> (nodeCache.getCurrentData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"获取节点数据异常，无法获取当前缓存的节点数据，可能该节点已被删除"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取节点最新的数据</span></span><br><span class="line">                String data = <span class="keyword">new</span> String(nodeCache.getCurrentData().getData());</span><br><span class="line">                System.out.println(nodeCache.getCurrentData().getPath() + <span class="string">" 节点的数据发生变化，最新的数据为："</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">200000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类后，我们到zookeeper服务器上，对/super/testNode节点进行如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">2</span>] set /workspace/<span class="keyword">super</span>/testNode change-data     </span><br><span class="line">cZxid = <span class="number">0xb00000015</span></span><br><span class="line">ctime = Sat Apr <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">57</span> CST <span class="number">2018</span></span><br><span class="line">mZxid = <span class="number">0xb00000037</span></span><br><span class="line">mtime = Sat Apr <span class="number">28</span> <span class="number">23</span>:<span class="number">49</span>:<span class="number">42</span> CST <span class="number">2018</span></span><br><span class="line">pZxid = <span class="number">0xb0000001c</span></span><br><span class="line">cversion = <span class="number">3</span></span><br><span class="line">dataVersion = <span class="number">6</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x0</span></span><br><span class="line">dataLength = <span class="number">11</span></span><br><span class="line">numChildren = <span class="number">3</span>      </span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">3</span>] set /workspace/<span class="keyword">super</span>/testNode change-agin-data</span><br><span class="line">cZxid = <span class="number">0xb00000015</span></span><br><span class="line">ctime = Sat Apr <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">57</span> CST <span class="number">2018</span></span><br><span class="line">mZxid = <span class="number">0xb00000038</span></span><br><span class="line">mtime = Sat Apr <span class="number">28</span> <span class="number">23</span>:<span class="number">50</span>:<span class="number">01</span> CST <span class="number">2018</span></span><br><span class="line">pZxid = <span class="number">0xb0000001c</span></span><br><span class="line">cversion = <span class="number">3</span></span><br><span class="line">dataVersion = <span class="number">7</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x0</span></span><br><span class="line">dataLength = <span class="number">16</span></span><br><span class="line">numChildren = <span class="number">3</span></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">8</span>] delete /workspace/<span class="keyword">super</span>/testNode</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">9</span>] create /workspace/<span class="keyword">super</span>/testNode test-data</span><br><span class="line">Created /workspace/<span class="keyword">super</span>/testNode</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>此时控制台输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前客户端的状态：连接中...</span><br><span class="line">节点初始化数据为：new-data</span><br><span class="line">/super/testNode 节点的数据发生变化，最新的数据为：change-data</span><br><span class="line">/super/testNode 节点的数据发生变化，最新的数据为：change-agin-data</span><br><span class="line">获取节点数据异常，无法获取当前缓存的节点数据，可能该节点已被删除</span><br><span class="line">/super/testNode 节点的数据发生变化，最新的数据为：test-data</span><br><span class="line">当前客户端的状态：已关闭...</span><br></pre></td></tr></table></figure><p>从控制台输出的内容可以看到，只要数据发生改变了都会触发这个事件，并且是可以重复触发的，而不是一次性的。</p><h2>九、curator之PathChildrenCache子节点监听</h2><p>使用NodeCache虽然能实现一次注册n次监听，但是却只能监听一个nodeChanged事件，也就是说创建、删除以及子节点的事件都无法监听。如果我们要监听某一个节点的子节点的事件，或者监听某一个特定节点的增删改事件都需要借助PathChildrenCache来实现。从名称上可以看到，PathChildrenCache也是用缓存实现的，并且也是一次注册n次监听。当我们传递一个节点路径时是监听该节点下的子节点事件，如果我们要限制监听某一个节点，只需要加上判断条件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为子节点添加watcher</span></span><br><span class="line">        <span class="comment">// PathChildrenCache: 监听数据节点的增删改，可以设置触发的事件</span></span><br><span class="line">        <span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(curatorConnect.client, nodePath, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * StartMode: 初始化方式</span></span><br><span class="line"><span class="comment">         * POST_INITIALIZED_EVENT：异步初始化，初始化之后会触发事件</span></span><br><span class="line"><span class="comment">         * NORMAL：异步初始化</span></span><br><span class="line"><span class="comment">         * BUILD_INITIAL_CACHE：同步初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        childrenCache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列出子节点数据列表，需要使用BUILD_INITIAL_CACHE同步初始化模式才能获得，异步是获取不到的</span></span><br><span class="line">        List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();</span><br><span class="line">        System.out.println(<span class="string">"当前节点的子节点详细数据列表："</span>);</span><br><span class="line">        <span class="keyword">for</span> (ChildData childData : childDataList) &#123;</span><br><span class="line">            System.out.println(<span class="string">"\t* 子节点路径："</span> + <span class="keyword">new</span> String(childData.getPath()) + <span class="string">"，该节点的数据为："</span> + <span class="keyword">new</span> String(childData.getData()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加事件监听器</span></span><br><span class="line">        childrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 通过判断event type的方式来实现不同事件的触发</span></span><br><span class="line">                <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED)) &#123;  <span class="comment">// 子节点初始化时触发</span></span><br><span class="line">                    System.out.println(<span class="string">"\n--------------\n"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子节点初始化成功"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)) &#123;  <span class="comment">// 添加子节点时触发</span></span><br><span class="line">                    System.out.println(<span class="string">"\n--------------\n"</span>);</span><br><span class="line">                    System.out.print(<span class="string">"子节点："</span> + event.getData().getPath() + <span class="string">" 添加成功，"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"该子节点的数据为："</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) &#123;  <span class="comment">// 删除子节点时触发</span></span><br><span class="line">                    System.out.println(<span class="string">"\n--------------\n"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子节点："</span> + event.getData().getPath() + <span class="string">" 删除成功"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) &#123;  <span class="comment">// 修改子节点数据时触发</span></span><br><span class="line">                    System.out.println(<span class="string">"\n--------------\n"</span>);</span><br><span class="line">                    System.out.print(<span class="string">"子节点："</span> + event.getData().getPath() + <span class="string">" 数据更新成功，"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子节点："</span> + event.getData().getPath() + <span class="string">" 新的数据为："</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">200000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来看看Apache Curator客户端的使用吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记9-原生Java API使用</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B09-%E5%8E%9F%E7%94%9FJava%20API%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记9-原生Java API使用/</id>
    <published>2019-02-23T08:41:33.698Z</published>
    <updated>2019-02-23T08:44:39.765Z</updated>
    
    <content type="html"><![CDATA[<p>本文来介绍原生的API来操作ZK节点，从而引出下节要说明的Curator客户端。</p><a id="more"></a><h2>环境准备</h2><p>新建一个普通的java项目即可，然后引入一些jar包的依赖：</p><p><img src="http://bloghello.oursnail.cn/18-12-9/86051910.jpg" alt="image"></p><p>代码在<code>code-for-chapter9</code></p><h2>客户端与ZK建立连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConnect</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String serverPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * serverPath:可以是一个ip，也可以是多个ip</span></span><br><span class="line"><span class="comment">         * sessionTimeout：超时时间，心跳收不到，就超时</span></span><br><span class="line"><span class="comment">         * watcher：通知事件，如果有对应的事件发生触发，则客户端会收到通知</span></span><br><span class="line"><span class="comment">         * canBeReadOnly：可读，当这个物理机节点断开以后，还是可以读到数据的，只是不能写</span></span><br><span class="line"><span class="comment">         * 此时数据被读取到的可能是旧数据，此处建议设置为false</span></span><br><span class="line"><span class="comment">         * sessionId：会话的ID</span></span><br><span class="line"><span class="comment">         * sessionPassword：会话密码 当会话消失以后，可以一句sessionId和sessionPasswd重新获取会话</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(serverPath,<span class="number">5</span>*<span class="number">1000</span>,<span class="keyword">new</span> ZKConnect());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端开始连接zk...，连接状态为:"</span>+zk.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 休息一段时间，保证让节点状态看到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"连接状态为:"</span>+zk.getState());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接受到的watch通知："</span>+watchedEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>会话重连机制</h2><p>主要的思路就是上一个程序注释中所描述:用上一次连接的sessionId和sessionPasswd这两个参数代入到下次连接中，就可以重新获取上一次的连接了。</p><p>下面就是不断地看seesionId来判断是否为同一个连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConnectSessionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String serverPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line">        <span class="keyword">long</span> sessionId = <span class="number">999L</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] sessionPasswd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(serverPath,<span class="number">5</span>*<span class="number">1000</span>,<span class="keyword">new</span> ZKConnectSessionWatcher());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果状态时已连接了，就获取sessionId</span></span><br><span class="line">        <span class="keyword">if</span> (zk.getState().equals(ZooKeeper.States.CONNECTED))&#123;</span><br><span class="line">            sessionId = zk.getSessionId();</span><br><span class="line">            System.out.println(sessionId);</span><br><span class="line"></span><br><span class="line">            String ssid = <span class="string">"0x"</span> + Long.toHexString(sessionId);</span><br><span class="line">            <span class="comment">//对sessionId经过64位编码之后的值，也就是dump命令查出来的sessionId值</span></span><br><span class="line">            System.out.println(ssid);</span><br><span class="line"></span><br><span class="line">            sessionPasswd = zk.getSessionPasswd();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第2次连接，会话重连，那么用sessionID和password来进行来重新获取连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"会话重连..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ZooKeeper zkSession = <span class="keyword">new</span> ZooKeeper(serverPath,<span class="number">5</span>*<span class="number">1000</span>,<span class="keyword">new</span> ZKConnectSessionWatcher(),sessionId,sessionPasswd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"重连之后的sessionId为："</span>+zkSession.getSessionId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接受到的watch通知："</span>+watchedEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>节点的增删改查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKNodeOperator</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String serverPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZooKeeper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZooKeeper</span><span class="params">(ZooKeeper zooKeeper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKNodeOperator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKNodeOperator</span><span class="params">(String connectionString,<span class="keyword">int</span> sessionTimeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(connectionString,sessionTimeout,<span class="keyword">new</span> ZKNodeOperator());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span>(zooKeeper != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zooKeeper.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZKNodeOperator zkServer = <span class="keyword">new</span> ZKNodeOperator(serverPath,<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 同步创建节点</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * zkServer.syncCreateZkNode(path,data,acls);</span></span><br><span class="line"><span class="comment">         * path：节点路径</span></span><br><span class="line"><span class="comment">         * data：节点数据</span></span><br><span class="line"><span class="comment">         * acls：节点权限，有Id ANYONE_ID_UNSAFE = new Id("world", "anyone");和Id AUTH_IDS = new Id("auth", "");</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            zkServer.getZooKeeper().create("/testNode1","123".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (KeeperException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 异步创建节点</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * path：节点路径</span></span><br><span class="line"><span class="comment">         * data：节点数据</span></span><br><span class="line"><span class="comment">         * acls：权限</span></span><br><span class="line"><span class="comment">         * mode：持久类型还是其他类型</span></span><br><span class="line"><span class="comment">         * callback：异步的回调函数</span></span><br><span class="line"><span class="comment">         * ctx：回调内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        String ctx = "&#123;'create':'success'&#125;";</span></span><br><span class="line"><span class="comment">        zkServer.getZooKeeper().create("/testNode2","456".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT,new CreateCallBack(),ctx);</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 同步修改节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            zkServer.getZooKeeper().setData("/testNode1","update123".getBytes(),0);//版本必须要对</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (KeeperException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 异步修改节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        String ctx = "&#123;'update':'success'&#125;";</span></span><br><span class="line"><span class="comment">        zkServer.getZooKeeper().setData("/testNode1","update123456".getBytes(),1,new UpdateCallBack(),ctx);</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 同步删除节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            zkServer.getZooKeeper(). delete("/testNode1",2);</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (KeeperException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 异步删除数据</span></span><br><span class="line">        </span><br><span class="line">        String ctx = <span class="string">"&#123;'delete':'success'&#125;"</span>;</span><br><span class="line">        zkServer.getZooKeeper().delete(<span class="string">"/testNode1"</span>,<span class="number">0</span>,<span class="keyword">new</span> DeleteCallBack(),ctx);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"watch被触发..."</span>+watchedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>countDownLatch</h2><p>上面学习了对于节点的增删改，还差一个查，这里先学习一下<code>countDownLatch</code>：</p><p>demo的场景是：有一个监控中心，监控很多地方的调度中心的情况，每检查一个，就返回一个状态，直到所有的调度中心都检查完。</p><p>代码在文件夹<code>countdownlatchdemo</code>.</p><p>这个玩意就是一个计数器。引入这个玩意，是为了配合下面的案例，使得线程能挂起，我们可以测试数据变化一下，然后触发watcher,拿到变化后的值，然后主线程执行结束。</p><h2>获取父节点数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKGetNodeData</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String serverPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKGetNodeData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKGetNodeData</span><span class="params">(String connectionString,<span class="keyword">int</span> sessionTimeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(connectionString,sessionTimeout,<span class="keyword">new</span> ZKGetNodeData());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span>(zooKeeper != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zooKeeper.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        ZKGetNodeData zkServer = <span class="keyword">new</span> ZKGetNodeData(serverPath,<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] resByte = zkServer.getZooKeeper().getData(<span class="string">"/hello"</span>,<span class="keyword">true</span>,stat);</span><br><span class="line">        String result = <span class="keyword">new</span> String(resByte);</span><br><span class="line">        System.out.println(<span class="string">"当前值:"</span>+result);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(event.getType() == Event.EventType.NodeDataChanged)&#123;</span><br><span class="line">                ZKGetNodeData zkServer = <span class="keyword">new</span> ZKGetNodeData(serverPath,<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] resByte = zkServer.getZooKeeper().getData(<span class="string">"/hello"</span>,<span class="keyword">true</span>,stat);</span><br><span class="line">                String result = <span class="keyword">new</span> String(resByte);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"更改后的值："</span>+result);</span><br><span class="line">                System.out.println(<span class="string">"版本："</span>+stat.getVersion());</span><br><span class="line"></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType() == Event.EventType.NodeCreated)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType() == Event.EventType.NodeChildrenChanged)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType() == Event.EventType.NodeDeleted)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZooKeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZooKeeper</span><span class="params">(ZooKeeper zooKeeper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>获取子节点数据</h2><p>基本同上，见代码<code>ZKGetChildrenList</code></p><h2>判断节点是否存在</h2><p>基本同上，见代码<code>ZKNodeExist</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来介绍原生的API来操作ZK节点，从而引出下节要说明的Curator客户端。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记8-典型应用场景详解</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B08-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记8-典型应用场景详解/</id>
    <published>2019-02-23T08:17:03.090Z</published>
    <updated>2019-02-23T08:17:46.045Z</updated>
    
    <content type="html"><![CDATA[<p>本章对于zk的应用场景和解决方案进行详细的介绍。</p><a id="more"></a><h2>一、从应用程序的角度看ZooKeeper</h2><p><img src="http://bloghello.oursnail.cn/18-12-9/13282729.jpg" alt="image"></p><p>ZNode之间的层级关系就像文件系统的目录结构一样，但和传统的磁盘文件系统不同的是全量数据都存储在内存中，以此来实现提高服务器吞吐、减少延迟的目的，从这一点来说应用只应该存储控制信息和配置信息到ZNode，而不应该用它来存储大量数据。</p><p>ZNode可以分为持久节点和临时节点两类。持久节点是指一旦该ZNode被创建了，除非主动进行删除操作，这个节点就会一直存在；而临时节点的生命周期会和客户端会话绑定在一起，一旦客户端会话失效其所创建的所有临时节点都会被删除。</p><p>ZK还支持客户端创建节点时指定一个特殊的SEQUENTIAL属性，这个节点被创建的时候ZK会自动在其节点名后面追加上一个整形数字，该数字是一个由服务端维护的自增数字，以此实现创建名称自增的顺序节点。</p><h2>二、监听器Watcher</h2><p>Watcher是ZK中很重要的特性，ZK允许用户在指定节点上注册一些Watcher，在该节点相关特定事件（比如节点添加、删除、子节点变更等）发生时Watcher会监听到，ZK服务端会将事件通知到感兴趣的客户端上去，该机制是ZK实现分布式协调服务的重要特性。</p><p>通知的时候服务端只会告诉客户端一个简单的事件（通知状态、事件类型、节点路径）而不包含具体的变化信息（如原始数据及变更后的数据），客户端如要具体信息再次主动去重新获取数据；此外，无论是服务端还是客户端，只要Watcher被触发ZK就会将其删除，因此在Watcher的使用上需要反复注册，这样轻量的设计有效减轻了服务端压力，如果Watcher一直有效，节点更新频繁时服务端会不断向客户端发送通知，对网络及服务端性能影响会非常大。</p><h2>三、典型应用场景</h2><h3>3.1 数据发布/订阅（以Dubbo注册中心为例）</h3><p>Dubbo是阿里集团开源的分布式服务框架，致力于提供高性能和透明化的远程服务调用解决方案和基于服务框架展开的完整SOA服务治理方案。</p><p>其中服务自动发现是最核心的模块之一，该模块提供基于注册中心的目录服务，使服务消费方能够动态的查找服务提供方，让服务地址透明化，同时服务提供方可以平滑的对机器进行扩容和缩容，其注册中心可以基于提供的外部接口来实现各种不同类型的注册中心，例如数据库、ZK和Redis等。接下来看一下基于ZK实现的Dubbo注册中心。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/10130945.jpg" alt="image"></p><ul><li><code>/dubbo</code>: 这是Dubbo在ZK上创建的根节点。</li><li><code>/dubbo/com.foo.BarService</code>: 这是服务节点，代表了Dubbo的一个服务。</li><li><code>/dubbo/com.foo.BarService/Providers</code>: 这是服务提供者的根节点，其子节点代表了每个服务的真正提供者。</li><li><code>/dubbo/com.foo.BarService/Consumers</code>: 这是服务消费者的根节点，其子节点代表了没一个服务的真正消费者</li><li>Dubbo基于ZK实现注册中心的工作流程：<ul><li>服务提供者：在初始化启动的时候首先在<code>/dubbo/com.foo.BarService/Providers</code>节点下创建一个子节点，同时写入自己的url地址，代表这个服务的一个提供者。</li><li>服务消费者：在启动的时候读取并订阅ZooKeeper上<code>/dubbo/com.foo.BarService/Providers</code>节点下的所有子节点，并解析所有提供者的url地址类作为该服务的地址列表，开始发起正常调用。同时在Consumers节点下创建一个临时节点，写入自己的url地址，代表自己是BarService的一个消费者</li><li>监控中心：监控中心是Dubbo服务治理体系的重要一部分，它需要知道一个服务的所有提供者和订阅者及变化情况。监控中心在启动的时候会通过ZK的<code>/dubbo/com.foo.BarService</code>节点来获取所有提供者和消费者的url地址，并注册Watcher来监听其子节点变化情况</li></ul></li></ul><p><strong>所有服务提供者在ZK上创建的节点都是临时节点</strong>，利用的是临时节点的生命周期和客户端会话绑定的特性，一旦提供者机器挂掉无法对外提供服务时该临时节点就会从ZK上摘除，这样服务消费者和监控中心都能感知到服务提供者的变化。</p><h3>3.2 命名服务</h3><p>命名服务也是分布式系统中比较常见的一类场景，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象，其中较为常见的是一些分布式服务框架中的服务地址列表，通过使用命名服务客户端应用能够指定名字来获取资源的实体、服务地址和提供者的信息等。</p><h3>3.3 Master选举</h3><p>当前系统的mater节点挂了怎么办？那就要重新选出一个master来。</p><p>ZK创建节点时有一个重要的特性，利用ZK的强一致性能够很好的保证在分布式高并发情况下节点的创建一定能够保证全局唯一，即ZK会保证客户端无法重复创建一个已经存在的数据节点。也就是说同时有多个客户端请求创建同一个节点最终一定只有一个客户端能够请求创建成功，利用这个特性就能很容易的在分布式环境中进行Master选举了。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/39480696.jpg" alt="image"></p><p>进行Master选举时客户端启动后可以向ZK请求创建一个临时节点，例如<code>/master_election/master</code>。在多个客户端创建时只有一个能创建成功，那么这个创建成功的客户端所在的机器就成为了Master。</p><p>同时其他没有创建成功的客户端都可以在节点<code>/master_election</code>上注册一个子节点变更的Watcher来监控当前Master是否在线，一旦发现Master挂了临时节点会被删除，其它客户端会收到通知，开始重新进行Master选举。</p><h3>3.4 分布式锁</h3><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同系统或同一系统不同机器之间共享了同一资源，那访问这些资源时通常需要一些互斥手段来保证一致性，这种情况下就需要用到分布式锁了。</p><p>接下来看下使用ZK如何实现排他锁。排他锁的核心是如何保证当前有且只有一个事务获得锁，并且锁被释放后所有等待获取锁的事务能够被通知到。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/33804933.jpg" alt="image"></p><p>和Master选举类似，在需要获取排他锁时，所有客户端都会试图在<code>/exclusive_lock</code>下创建临时子节点<code>/exclusive_lock/lock</code>，最终只有一个客户端能创建成功，该客户端就获取到了锁。</p><p>同时没有获取到锁的客户端需要到<code>/exclusive_lock</code>节点上注册一个子节点变更的Watcher监听，用于实时监听lock节点的变更情况。</p><p><code>/exclusive_lock/lock</code>是一个临时节点，在一下两种情况下都有可能释放锁：</p><ul><li>当获取锁的客户端挂掉，ZK上的该节点会被删除</li><li>正常执行完业务逻辑之后客户端会主动将自己创建的临时节点删除。</li></ul><p>无论在什么情况下删除了lock临时节点ZK都会通知在<code>/exclusive_lock</code>节点上注册了子节点变更Watcher监听的客户端，重新发起锁的获取。</p><h3>3.5 分布式屏障</h3><p>分布式屏障，举个栗子，在大规模分布式并行计算的场景下，最终的合并计算需要基于很多并行计算的子结果来进行，即系统需要满足特定的条件，一个队列的元素必须都聚齐之后才能进行后续处理，否则一直等待。看下如何用ZK来支持这种场景。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/11515311.jpg" alt="image"></p><p>开始时<code>/queue_barrier</code>是一个存在的节点，数据内容赋值为一个数字n来代表满足条件的机器总数，例如n=10表示只有当<code>/queue_barrier</code>节点下的子节点数量达到10后才会打开屏障继续处理。</p><p>然后所有的客户端都会到<code>/queue_barrier</code>节点下创建一个临时节点，如<code>/queue_barrier/192.168.0.1</code>。创建完节点之后根据以下步骤来确定执行顺序:</p><ul><li>1、调用获取节点数据的api获取<code>/queue_barrier</code>节点的内容：10</li><li>2、调用获取子节点总数的api获取<code>/queue_barrier</code>下的所有子节点，并且注册对子节点变更的Watcher监听</li><li>3、统计子节点个数</li><li>4、如果子节点个数小于10则继续等待，否则打开屏障继续处理</li><li>5、接收到Watcher通知后，重复步骤2</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章对于zk的应用场景和解决方案进行详细的介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记7-ZK的基本操作以及权限控制</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B07-ZK%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记7-ZK的基本操作以及权限控制/</id>
    <published>2019-02-23T07:46:23.228Z</published>
    <updated>2019-02-23T07:48:52.697Z</updated>
    
    <content type="html"><![CDATA[<p>说了那么久的理论，但是其实对于大多数人来说，会用才是王道，在会用的基础上再去深入探讨原理可能是最佳的实践方式，但是对于笔记来说，先原理再实践可能更为稳妥，本文介绍zk最基本的一些操作，比如查看节点、增加一个节点、Watch机制以及ACL权限控制等基本命令，最后还介绍了一下为了方便而产生的四字命令。</p><a id="more"></a><h2>基本数据模型</h2><ul><li>树形结构，每个节点成为znode，它可以有子节点，也可以有数据</li><li>临时节点和永久节点，临时节点在客户端断开后消失</li><li>每个zk节点都有各自的版本号，可以通过命令行来显示节点信息</li><li>每当节点数据发生变化，那么该节点的版本号会累加（<strong>乐观锁</strong>）</li><li>删除/修改过时节点，版本号不匹配则会报错</li><li>每个zk节点存储的数据不宜过大，几k即可</li><li>节点可以设置acl，可以通过权限来限制用户的访问</li></ul><h2>zk的作用</h2><ul><li>master选举，保证集群是高可用的</li><li>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器</li><li>发布与订阅，dubbo发布者把数据存在znode上，订阅者可以读取这个数据</li><li>分布式锁</li><li>集群管理，集群中保证数据的强一致性</li></ul><h2>zk的基本操作</h2><ul><li><code>ls /</code> 显示根节点名称</li><li><code>ls2 /</code> 显示了根节点的状态信息（stat也可以看状态）</li><li><code>get /</code> 拿出节点的数据和信息</li><li><code>create [-s] [-e] path data acl</code> 创建节点，如果是默认创建，则是非顺序的、 持久的节点。加上-e则是临时节点；加上-s表示顺序节点</li><li><strong>【注1】</strong>：如果是持久节点，状态信息中的ephemeralOwner=0x0；临时节点的这个属性，是后面一串比较长的字符</li><li><strong>【注2】</strong>：客户端断开连接了，一段时间之后，那么临时节点就会消失（主要是有个时效，超出这个时间还不收到来自客户端的心跳包则才认定客户端挂了）</li><li><strong>【注3】</strong>：在加上-s后，创建的节点会重命名为一个累加的名称</li><li><code>set path newData</code> 每次修改值后<code>dataVersion</code>数据版本号会增1</li><li><strong>【注4】</strong>：如何实现乐观锁？<code>set path data version</code>,就是说带上版本号，如果这个版本不对应，那么就修改失败</li><li><code>delete path version</code> 删除节点</li></ul><h2>watcher机制</h2><ul><li>针对每个节点的操作，都会有一个监督者<code>watcher</code></li><li>当监控的某个对象(znode)发生了变化，则触发watcher事件</li><li>zk中watcher是一次性的，触发后立即销毁（用其他的开源客户端开源让其不会销毁，重复触发）</li><li>父节点以及他的子孙们的 增 删 改 都能够触发其watcher</li><li>针对不同类型的事件，触发的watcher事件也不同：<ul><li>（子）节点创建事件</li><li>（子）节点删除事件</li><li>（子）节点数据变化事件</li></ul></li><li>通过<code>get path [watch]</code>或者<code>stat path [watch]</code>或者<code>ls path [watch]</code>都可以设置watcher</li><li>父节点 增 删 改 操作触发watcher</li><li>子节点 增 删 改 操作触发watcher</li></ul><h3>【创建父节点触发】：NodeCreated</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 24] stat /hello watch  </span><br><span class="line">Node does not exist: /hello</span><br><span class="line">[zk: localhost:2181(CONNECTED) 25] create /hello world</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">Created /hello</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeCreated path:/hello</span><br></pre></td></tr></table></figure><h3>【修改父节点数据触发】：NodeDataChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 26] stat /hello watch</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 27] get /hello</span><br><span class="line">world</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 28] set /hello lalala</span><br><span class="line"></span><br><span class="line">WATCHER::cZxid = 0x300000011</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/helloctime = Sat Dec 08 20:00:53 CST 2018</span><br></pre></td></tr></table></figure><h3>【删除父节点触发】：NodeDeleted</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 32] get /hello watch</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 33] delete /hello</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">[zk: localhost:2181(CONNECTED) 34]</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDeleted path:/hello</span><br></pre></td></tr></table></figure><h3>【创建子节点触发】：ls为父节点设置watcher，创建子节点触发NodeChildrenChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 52] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 53] create /hello world</span><br><span class="line">Created /hello</span><br><span class="line">[zk: localhost:2181(CONNECTED) 54] ls /hello watch</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 55] create /hello/helloson worldson</span><br><span class="line"></span><br><span class="line">WATCHER::Created /hello/helloson</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/hello</span><br></pre></td></tr></table></figure><h3>【删除子节点触发】：ls为父节点设置watcher，删除子节点触发NodeChildrenChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 56] ls /hello</span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 57] ls /hello watch</span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 58] delete /hello/helloson</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">[zk: localhost:2181(CONNECTED) 59]</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/hello</span><br></pre></td></tr></table></figure><h3>【更新子节点触发】：ls为父节点设置watcher，更新子节点不触发事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 59] ls /hello</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 60] create /hello/helloson worldson</span><br><span class="line">Created /hello/helloson</span><br><span class="line">[zk: localhost:2181(CONNECTED) 61] ls /hello watch </span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 62] set /hello/helloson worldsonhahaha</span><br><span class="line">cZxid = 0x300000020</span><br><span class="line">ctime = Sat Dec 08 20:15:05 CST 2018</span><br><span class="line">mZxid = 0x300000021</span><br><span class="line">mtime = Sat Dec 08 20:16:06 CST 2018</span><br><span class="line">pZxid = 0x300000020</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 14</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 63] get /hello/helloson</span><br><span class="line">worldsonhahaha</span><br></pre></td></tr></table></figure><p>就算是设置成<code>ls /hello/helloson watch</code>也不行。只有这样才可以触发watcher:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 72] get /swg/swgson watch</span><br><span class="line">8080</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 74] set /swg/swgson 7070</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">cZxid = 0x300000024</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/swg/swgsonctime = Sat Dec 08 20:18:53 CST 2018</span><br></pre></td></tr></table></figure><p>为什么更新子节点的时候ls不行，但是get就行呢？客户端要想收到更新子节点内容的消息的话，不能通过子节点的事件来触发，必须把子节点当作父节点来做。然而<code>ls path [watch] ：查询指定路径下的子节点</code>所以是针对的子节点，所以不能触发这个事件；而<code>get path [watch] : 查询指定节点中的数据，如果节点中有数据</code>或者<code>stat path [watch] : 查询指定节点的一些描述信息</code>这些直接是操作这个节点，把这个节点当作是父节点，所以能起作用。</p><h2>watcher使用场景</h2><p>Watcher是ZK中很重要的特性，ZK允许用户在指定节点上注册一些Watcher，在该节点相关特定事件（比如节点添加、删除、子节点变更等）发生时Watcher会监听到，ZK服务端会将事件通知到感兴趣的客户端上去，该机制是ZK实现分布式协调服务的重要特性。</p><p>通知的时候服务端只会告诉客户端一个简单的事件（通知状态、事件类型、节点路径）而不包含具体的变化信息（如原始数据及变更后的数据），客户端如要具体信息再次主动去重新获取数据；此外，无论是服务端还是客户端，只要Watcher被触发ZK就会将其删除，因此在Watcher的使用上需要反复注册，这样轻量的设计有效减轻了服务端压力，如果Watcher一直有效，节点更新频繁时服务端会不断向客户端发送通知，对网络及服务端性能影响会非常大。</p><p>比如统一资源配置。</p><h2>ACL 权限控制列表</h2><ul><li>针对节点可以设置相关读写等权限，目的是为了保障数据安全性</li><li>权限permissions可以指定不同的权限范围以及角色</li><li><code>getAcl</code>：获取某个节点的acl权限信息</li><li><code>setAcl</code>：设置某个节点的acl权限信息</li><li><code>addauth</code>：注册某个用户，要把某个用户的用户名和密码输入到系统中进行注册，用户才能登陆。</li><li>默认权限：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 76] getAcl /swg</span><br><span class="line">&apos;world,&apos;anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure><ul><li>ACL构成：zk的acl通过[scheme🆔permissions]来构成权限列表，其中<code>scheme</code>指采用的某种权限机制；<code>id</code>指允许访问的用户；<code>permissions</code>指权限组合字符串</li><li><code>scheme</code>：主要是四种<ul><li><code>world</code>：<code>world</code>下只有一个<code>id</code>，即只有一个用户，也就是<code>anyone</code>，那么组合的写法就是<code>world:anyone:[permissions]</code></li><li><code>auth</code>：代表认证登陆，需要注册用户有权限就可以，形式为<code>auth:user:password:[permissions]</code>,密码是明文</li><li><code>degest</code>：需要对密码加密才能访问，组合形式为<code>digest:username:BASE64(SHA(password)):[permissions]</code>，密码是加密的</li><li><code>ip</code>：当设置为ip指定的ip地址，此时限制ip进行访问，比如<code>ip:192.168.1.1:[permissions]</code></li><li><code>super</code>：代表超级管理员，拥有所有权限</li></ul></li><li><code>id</code>：代表允许访问的用户</li><li><code>permissions</code>：<ul><li><code>c</code>：create,创建当前节点的子节点权限</li><li><code>r</code>：read,获取当前节点或者子节点列表</li><li><code>w</code>：write,设置当前节点的数据</li><li><code>d</code>：delete，删除子节点</li><li><code>a</code>：admin，是比较高的权限，可以去设置和修改权限，即拥有分配权限的权限</li></ul></li></ul><ul><li><code>world:anyone:cdrwa</code>：对于默认权限，我们可以修改他的权限字符串，如<code>setAcl path world:anyone:crwa</code></li><li><code>auth</code>和<code>digest</code>：先<code>addauth digest username:password（明文密码）</code>注册用户,然后<code>setAcl path auth:username:password（明文密码）:cdrwa</code>就可以设置ACL了。再去<code>getAcl path</code>查询到的密码时加密后的。</li><li><code>digest</code>：要先退出刚才的<code>auth</code>的账号，直接重启当前客户端即可。<code>setAcl path digest:username:password（密文密码）:cdrwa</code>。再去<code>getAcl path</code>查询到的密码时加密后的。此时访问、删除、创建节点比如<code>get path</code>是需要登陆的，即先<code>addauth digest username:password（明文密码）</code>登陆。</li><li><code>ip</code>：<code>setAcl path ip:192.168.1.1:cdrwa</code></li><li><code>super</code>：最高权限，修改<code>zkServer.sh</code>增加super管理员，重启<code>zkServer.sh</code>。到<code>bin</code>目录下修改<code>zkServer.sh</code>增加配置：</li></ul><p>找到这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup $JAVA &quot;-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;&quot; &quot;-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;&quot;</span><br></pre></td></tr></table></figure><p>在后面继续添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=username:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</span><br></pre></td></tr></table></figure><h2>ACL常用使用场景</h2><ul><li>开发/测试环境分离，开发者无权限操作测试库的节点，只能看。比如分为开发节点和测试节点。</li><li>生产环境上控制指定ip的服务可以访问相关节点防止混乱</li></ul><h2>zk四字命令</h2><ul><li>zk可以通过它自身提供的简写命令来和服务器进行交互</li><li>需要使用到 <code>nc</code> 命令，<code>yum install nc</code></li><li><code>echo [command] | nc [ip] [port]</code><ul><li>【stat】查看zk的状态信息，以及是单机还是集群状态：<code>echo stat | nc ip或者localhost 2181</code></li><li>【ruok】查看当前zkServer是否启动，正常返回imok：<code>echo ruok | nc ip 2181</code></li><li>【dump】列出未经处理的会话和临时节点：<code>echo dump | nc ip 2181</code></li><li>【conf】查看服务配置</li><li>【cons】展示连接到服务器的客户端信息</li><li>【envi】环境变量，显示jdk和zk等环境变量的信息</li><li>【mntr】监控zk健康信息</li><li>【wchs】展示watch的信息</li><li>【wchc】与【wchp】：分别展示session与watch及path与watcher的信息，默认这两个命令是不能访问的，需要将他们列入白名单才行</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说了那么久的理论，但是其实对于大多数人来说，会用才是王道，在会用的基础上再去深入探讨原理可能是最佳的实践方式，但是对于笔记来说，先原理再实践可能更为稳妥，本文介绍zk最基本的一些操作，比如查看节点、增加一个节点、Watch机制以及ACL权限控制等基本命令，最后还介绍了一下为了方便而产生的四字命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记6-zk安装和集群搭建</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B06-zk%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记6-zk安装和集群搭建/</id>
    <published>2019-02-23T07:24:59.806Z</published>
    <updated>2019-02-23T07:25:21.850Z</updated>
    
    <content type="html"><![CDATA[<p>本章会回顾一下ZAB协议，然后介绍一下集群搭建的配置文件。</p><a id="more"></a><h2>前言</h2><p>回顾一下<code>ZAB</code>协议。<code>Zab</code>协议包括两个核心：</p><p><strong>第一，原子广播</strong></p><p>客户端提交事务请求时<code>Leader</code>节点为每一个请求生成一个事务<code>Proposal</code>，将其发送给集群中所有的<code>Follower</code>节点，收到过半<code>Follower</code>的反馈后开始对事务进行提交。</p><p>这也导致了<code>Leader</code>崩溃后可能会出现数据不一致的情况，ZAB使用了崩溃恢复来处理数字不一致问题；</p><p>消息广播使用了TCP协议进行通讯所有保证了接受和发送事务的顺序性。广播消息时<code>Leader</code>节点为每个事务<code>Proposal</code>分配一个全局递增的<code>ZXID</code>（事务ID），每个事务<code>Proposal</code>都按照<code>ZXID</code>顺序来处理；</p><p><code>Leader</code>节点为每一个<code>Follower</code>节点分配一个队列按事务<code>ZXID</code>顺序放入到队列中，且根据队列的规则FIFO来进行事务的发送。</p><p><code>Follower</code>节点收到事务<code>Proposal</code>后会将该事务以事务日志方式写入到本地磁盘中，成功后反馈<code>Ack</code>消息给<code>Leader</code>节点。</p><p>收到过半<code>ACK</code>反馈之后，同时向所有的<code>Follower</code>节点广播<code>Commit</code>消息，<code>Follower</code>节点收到<code>Commit</code>后开始对事务进行提交；</p><p><strong>第二，Master选举</strong></p><p>里面用的算法叫做：<code>Fast Leader Election</code>。</p><ul><li><code>epoch</code>：选举轮数,即周期，就是之前说的逻辑时钟<code>logicClock</code></li><li><code>Zxid</code>: <code>Zxid</code> 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，针对客户端每一个事务请求，计数器加 1；而高 32 位则代表 <code>Leader</code> 周期 <code>epoch</code> 的编号，每个当选产生一个新的 <code>Leader</code> 服务器，就会从这个 <code>Leader</code> 服务器上取出其本地日志中最大事务的<code>ZXID</code>，并从中读取 <code>epoch</code> 值，然后加 1，以此作为新的 <code>epoch</code>，并将低 32 位从 0 开始计数。</li></ul><p><strong>成为leader的条件</strong></p><ul><li>选<code>epoch</code>最大的</li><li><code>epoch</code>相等，选 <code>zxid</code> 最大的</li><li><code>epoch</code>和<code>zxid</code>都相等，选择<code>server id</code>最大的（就是我们配置<code>zoo.cfg</code>中的<code>myid</code>）</li></ul><p><strong>选举的基本步骤</strong></p><ol><li>每个从节点都向其他节点发送选自身为<code>Leader</code>的<code>Vote</code>投票请求，等待回复；</li><li>从节点接受到的<code>Vote</code>如果比自身的大（ZXID更新）时则投票，并更新自身的<code>Vote</code>，否则拒绝投票；</li><li>每个从节点中维护着一个投票记录表，当某个节点收到过半的投票时，结束投票并把该从节点选为<code>Leader</code>，投票结束；</li></ol><p>具体一点的步骤：</p><ul><li>1、发起一轮投票选举，推举自己作为<code>leader</code>，通知所有的服务器，等待接收外部选票。</li><li>2、只要当前服务器状态为<code>LOOKING</code>，进入循环，不断地读取其它<code>Server</code>发来的通知、进行比较、更新自己的投票、发送自己的投票、统计投票结果，直到<code>leader</code>选出或出错退出。具体做法：<ul><li>2.1 如果发送过来的逻辑时钟大于目前的逻辑时钟，那么说明这是更新的一次选举投票，此时更新本机的逻辑时钟（<code>logicalclock</code>），清空投票箱（因为已经过期没有用了）调用<code>totalOrderPredicate</code>函数判断对方的投票是否优于当前的投票（见下面代码），是的话用对方推荐的<code>leader</code>更新下一次的投票，否则使用初始的投票（投自己），调用<code>sendNotifications()</code> 通知所有服务器我的选择，跳到2.4。</li><li>2.2 如果对方处于上轮投票，不予理睬，回到2。</li><li>2.3 如果对方也处于本轮投票，调用<code>totalOrderPredicate</code>函数判断对方的投票是否优于当前的投票，是的话更新当前的投票，否则使用初始的投票（投自己）并新生成<code>notification</code>消息放入发送队列。调用<code>sendNotifications()</code> 通知所有服务器我的选择。</li><li>2.4 将收到的投票放入自己的投票箱中。</li><li>2.5 调用计票器的<code>containsQuorum</code>函数，判断所推荐的leader是否得到集群多数人的同意，如果得到多数人同意，那么还需等待一段时间，看是否有比当前更优的提议，如果没有，则认为投票结束。根据投票结果修改自己的状态。以上任何一条不满足，则继续循环。</li></ul></li></ul><p>关于<code>totalOrderPredicate</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">totalOrderPredicate</span><span class="params">(<span class="keyword">long</span> newId, <span class="keyword">long</span> newZxid, <span class="keyword">long</span> newEpoch, <span class="keyword">long</span> curId, <span class="keyword">long</span> curZxid, <span class="keyword">long</span> curEpoch)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    LOG.debug(<span class="string">"id: "</span> + newId + <span class="string">", proposed id: "</span> + curId + <span class="string">", zxid: 0x"</span> +</span><br><span class="line">    </span><br><span class="line">            Long.toHexString(newZxid) + <span class="string">", proposed zxid: 0x"</span> + Long.toHexString(curZxid));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用计票器判断当前server的权重是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(self.getQuorumVerifier().getWeight(newId) == <span class="number">0</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Epoch、zxid、id来比较两个候选leader</span></span><br><span class="line">    <span class="keyword">return</span> ((newEpoch &gt; curEpoch) ||</span><br><span class="line">    </span><br><span class="line">            ((newEpoch == curEpoch) &amp;&amp;</span><br><span class="line">    </span><br><span class="line">            ((newZxid &gt; curZxid) || ((newZxid == curZxid) &amp;&amp; (newId &gt; curId)))));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>总结起来就是一句话：若干个节点，第一次都是投给自己；后面就是，尽量向数据最新的节点靠拢，可以理解为：每个节点贫富有差距，富有的节点让贫穷的节点投自己一票，那么贫穷的节点会接受，反之不行，那么最先拿到超过一半的贫穷的节点的投票，就成为leader。（贫穷与富有都是相对的，越富有越可能成为leader）。</strong></p><h2>zk集群搭建</h2><p>首先准备三份解压文件，每一份中都新建一个叫<code>data</code>的文件夹：里面新建一个叫做myid的文件，第一个写1，后面递增。</p><p>每一份中配置文件改为<code>zoo.cfg</code>。zk1对应的zoo.cfg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick 心跳检测时间</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line"># 集群启动后，相互连接，如果在initLimit*tickTime时间内没有连接成功，那么认为连接失败</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># Masrer和slave之间或者slave和slave之间的数据同步时间，在syncLimit*tickTime是按内没有返回一个ACk，则</span><br><span class="line"># 认为该节点宕机，如果是Master宕机了，就要重新选举了</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 数据存放的目录，这是我新建的</span><br><span class="line">dataDir=D:/zookeeper1-3.4.10/data</span><br><span class="line"># dataLogDir = xx</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># 客户端连接集群的端口号</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第一个端口是数据同步的端口号  第二个端口是选举的端口号</span><br><span class="line">server.1=127.0.0.1:2887:3887</span><br><span class="line">server.2=127.0.0.1:2888:3888</span><br><span class="line">server.3=127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure><p>后面一次递增这个<code>clientPort</code>和<code>data</code>文件夹位置。</p><p>依次启动即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章会回顾一下ZAB协议，然后介绍一下集群搭建的配置文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记5-ZAB协议</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B05-ZAB%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记5-ZAB协议/</id>
    <published>2019-02-23T07:09:59.185Z</published>
    <updated>2019-02-23T07:20:23.561Z</updated>
    
    <content type="html"><![CDATA[<p>在zookeeper中其实使用的ZAB协议来实现数据的一致性，并且主要依靠的是leader和follower这两种角色控制数据的一致性，而leader是里面最重要的一个角色，它是主要负责写操作的节点，然后与其他的follower进行数据同步，所以我们也要保证leader宕机的时候要快速选举出新的leader并且进行数据恢复。</p><a id="more"></a><h2>一、前言</h2><p>ZooKeeper是一个分布式协调服务，可用于服务发现、分布式锁、分布式领导选举、配置管理等。</p><p><strong>这一切的基础，都是ZooKeeper提供了一个类似于Linux文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。</strong></p><p>既然是一个文件系统，就不得不提ZooKeeper是如何保证数据的一致性的。本节将将介绍ZooKeeper如何保证数据一致性，如何进行领导选举，以及数据监控/通知机制的语义保证。</p><h2>二、ZAB-原子广播（重点）</h2><p><code>ZooKeeper</code>集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种：</p><ul><li><code>Leader</code>： 一个<code>ZooKeeper</code>集群同一时间只会有一个实际工作的<code>Leader</code>，它会发起并维护与各<code>Follwer</code>及<code>Observer</code>间的心跳。所有的写操作必须要通过<code>Leader</code>完成再由<code>Leader</code>将写操作广播给其它服务器。</li><li><code>Follower</code>： 一个<code>ZooKeeper</code>集群可能同时存在多个<code>Follower</code>，它会响应<code>Leader</code>的心跳。<code>Follower</code>可直接处理并返回客户端的读请求，同时会将写请求转发给<code>Leader</code>处理，并且负责在<code>Leader</code>处理写请求时对请求进行投票。</li><li><code>Observer</code>： 角色与<code>Follower</code>类似，但是无投票权。</li></ul><p><img src="http://bloghello.oursnail.cn/18-12-4/8438336.jpg" alt="image"></p><p><font color="red">为了保证写操作的一致性与可用性，ZooKeeper专门设计了一种名为原子广播（ZAB）的支持崩溃恢复的一致性协议。基于该协议，ZooKeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。</font></p><p>根据ZAB协议，所有的写操作都必须通过<code>Leader</code>完成，<code>Leader</code>写入本地日志后再复制到所有的<code>Follower</code>节点。</p><p>一旦<code>Leader</code>节点无法工作，ZAB协议能够自动从<code>Follower</code>节点中重新选出一个合适的替代者，即新的<code>Leader</code>，该过程即为领导选举。该领导选举过程，是ZAB协议中最为重要和复杂的过程。</p><h3>1、写Leader</h3><p>通过Leader进行写操作流程如下图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/18727361.jpg" alt="image"></p><p>由上图可见，通过<code>Leader</code>进行写操作，主要分为五步：</p><ul><li>客户端向<code>Leader</code>发起写请求</li><li><code>Leader</code>将写请求以<code>Proposal</code>的形式发给所有<code>Follower</code>并等待<code>ACK</code></li><li><code>Follower</code>收到<code>Leader</code>的<code>Proposal</code>后返回<code>ACK</code></li><li><code>Leader</code>得到过半数的<code>ACK</code>（<code>Leader</code>对自己默认有一个<code>ACK</code>）后向所有的<code>Follower</code>和<code>Observer</code>发送<code>Commmit</code></li><li><code>Leader</code>将处理结果返回给客户端</li></ul><p><font color="red">这里要注意：</font></p><ul><li><code>Leader</code>并不需要得到<code>Observer</code>的<code>ACK</code>，即<code>Observer</code>无投票权</li><li><code>Leader</code>不需要得到所有<code>Follower</code>的<code>ACK</code>，只要收到过半的<code>ACK</code>即可，同时<code>Leader</code>本身对自己有一个<code>ACK</code>。上图中有4个<code>Follower</code>，只需其中两个返回<code>ACK</code>即可，因为(2+1) / (4+1) &gt; 1/2</li><li><code>Observer</code>虽然无投票权，但仍须同步<code>Leader</code>的数据从而在处理读请求时可以返回尽可能新的数据</li></ul><h3>2、写Follower/Observer</h3><p>通过<code>Follower</code>/<code>Observer</code>进行写操作流程如下图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/92869076.jpg" alt="image"></p><p>从上图可见：</p><ul><li><code>Follower</code>/<code>Observer</code>均可接受写请求，但不能直接处理，而需要将写请求转发给<code>Leader</code>处理</li><li>除了多了一步请求转发，其它流程与直接写<code>Leader</code>无任何区别</li></ul><h2>3、读操作</h2><p><code>Leader</code>/<code>Follower</code>/<code>Observer</code>都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。</p><p><img src="http://bloghello.oursnail.cn/18-12-4/63826294.jpg" alt="image"></p><p>由于处理读请求不需要服务器之间的交互，<code>Follower</code>/<code>Observer</code>越多，整体可处理的读请求量越大，也即读性能越好。</p><p><font color="red">在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个事务Proposal分配一个全局单调递增的唯一ID，我们称之为事务ID(即ZXID)。由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的先后顺序进行排序和处理。</font></p><p>具体的，在消息广播过程中，<code>Leader</code>服务器会为每个<code>Follower</code>服务器都<font color="red">各自分配一个单独的队列</font>，然后将需要广播的事务<code>Proposal</code>依次放入这些队列中取，并且根据FIFO策略进行消息发送。每一个<code>Follower</code>服务器在接收到这个事务<code>Proposal</code>之后，都会首先将其以事务日志的形式写入本地磁盘中，并且成功写入后反馈给<code>Leader</code>服务器一个Ack相应。当<code>Leader</code>服务器接收到过半数<code>Follower</code>的Ack响应后，就会广播一个<code>Commit</code>消息给所有的<code>Follower</code>服务器以通知其进行事务提交，同时<code>Leader</code>自身也会完成对事务的提交，而每个<code>Follower</code>服务器在接收到<code>Commit</code>消息后，也会完成对事务的提交。</p><p><font color="red">然而，在这种简化的二阶段提交模型下，无法处理Leader服务器崩溃退出而带来的数据不一致问题，因此ZAB协议添加了崩溃恢复模式来解决这个问题</font>。另外，整个消息广播协议是基于有FIFO特性的TCP协议来进行网络通信的，因此很容易地保证消息广播过程中消息接收和发送的顺序性。</p><p>在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的<code>Leader</code>服务器。因此，ZAB协议需要一个高效且可靠的<code>Leader</code>选举算法，从而确保能够快速选举出新的<code>Leader</code>。同时，<code>Leader</code>选举算法不仅仅需要让<code>Leader</code>自己知道其自身已经被选举为<code>Leader</code>，同时还需要让集群中的所有其他服务器也快速地感知到选举产生的新的<code>Leader</code>服务器。<font color="red">崩溃恢复主要包括Leader选举和数据恢复两部分</font>，下面将详细讲解<code>Leader</code>选举和数据恢复流程。</p><h2>三、支持的领导选举算法</h2><p>在3.4.10版本中，默认值为3，也即基于TCP的<code>FastLeaderElection</code>。另外三种算法已经被弃用，并且有计划在之后的版本中将它们彻底删除而不再支持。</p><p>何时触发选举？</p><p>选举<code>Leader</code>不是随时选举的，毕竟选举有产生大量的通信，造成网络IO的消耗。因此下面情况才会出现选举：</p><ul><li>集群启动</li><li>服务器处于寻找<code>Leader</code>状态</li><li>当服务器处于<code>LOOKING</code>状态时，表示当前没有<code>Leader</code>，需要进入选举流程</li><li>崩溃恢复</li><li><code>Leader</code>宕机</li><li>网络原因导致过半节点与<code>Leader</code>心跳中断</li></ul><p>下面学习一下<code>FastLeaderElection</code>的原理。</p><h2>四、名词解释</h2><h3>1、myid</h3><p>每个<code>ZooKeeper</code>服务器，都需要在数据文件夹下创建一个名为<code>myid</code>的文件，该文件包含整个<code>ZooKeeper</code>集群唯一的ID（整数）。例如，某<code>ZooKeeper</code>集群包含三台服务器，<code>hostname</code>分别为<code>zoo1</code>、<code>zoo2</code>和<code>zoo3</code>，其<code>myid</code>分别为1、2和3，则在配置文件中其ID与<code>hostname</code>必须一一对应，如下所示。在该配置文件中，server.后面的数据即为<code>myid</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=zoo1:2888:3888</span><br><span class="line">server.2=zoo2:2888:3888</span><br><span class="line">server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure><ul><li>第1个端口是通信和数据同步端口，默认是2888</li><li>第2个端口是投票端口，默认是3888</li></ul><p>数小的向数大的发起TCP连接。比如有3个节点，myid文件内容分别为1,2,3。zk集群的tcp连接顺序是1向2发起TCP连接，2向3发起TCP连接。如果有n个节点，那么tcp连接顺序也以此类推。这样整个zk集群就会连接起来</p><h3>2、zxid</h3><p>类似于<code>RDBMS</code>中的事务ID，用于标识一次更新操作的<code>Proposal ID</code>。为了保证顺序性，该<code>zxid</code>必须<strong>单调递增</strong>。因此<code>ZooKeeper</code>使用一个64位的数来表示，<strong>高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加一。低32位为该epoch内的序号，每次epoch变化，<strong>都将低32位的序号重置</strong></strong>。这样保证了<code>zxid</code>的全局递增性。</p><h3>3、服务器状态</h3><ul><li><code>LOOKING</code> 不确定<code>Leader</code>状态。该状态下的服务器认为当前集群中没有<code>Leader</code>，会发起<code>Leader</code>选举。</li><li><code>FOLLOWING</code> 跟随者状态。表明当前服务器角色是<code>Follower</code>，并且它知道<code>Leader</code>是谁。</li><li><code>LEADING</code> 领导者状态。表明当前服务器角色是<code>Leader</code>，它会维护与<code>Follower</code>间的心跳。</li><li><code>OBSERVING</code> 观察者状态。表明当前服务器角色是<code>Observer</code>，与<code>Folower</code>唯一的不同在于不参与选举，也不参与集群写操作时的投票。</li></ul><h3>4、选票数据结构</h3><p>每个服务器在进行领导选举时，会发送如下关键信息：</p><ul><li><code>logicClock</code> 每个服务器会维护一个自增的整数，名为<code>logicClock</code>，它表示这是该服务器发起的第多少轮投票</li><li><code>state</code> 当前服务器的状态</li><li><code>self_id</code> 当前服务器的myid</li><li><code>self_zxid</code> 当前服务器上所保存的数据的最大zxid</li><li><code>vote_id</code> 被推举的服务器的myid</li><li><code>vote_zxid</code> 被推举的服务器上所保存的数据的最大zxid</li></ul><h2>五、leader的判定标准</h2><ul><li>数据新旧程度，只有拥有最新数据的节点才能有机会成为<code>Leader</code>，通过<code>zxid</code>的大小来表示数据的新，<code>zxid</code>越大代表数据越新</li><li><code>myid</code>:集群启动时，会在<code>data</code>目录下配置<code>myid</code>文件，里面的数字代表当前zk服务器节点的编号.当zk服务器节点数据一样新时， <code>myid</code>中数字越大的就会被选举成<code>Leader</code></li><li>当集群中已经有<code>Leader</code>时，新加入的节点不会影响原来的集群</li><li>投票数量，只有得到集群中多半的投票，才能成为<code>Leader</code>，多半即：n/2+1,其中n为集群中的节点数量</li></ul><h2>六、Leader选举流程</h2><h3>1、自增选举轮次</h3><p><code>ZooKeeper</code>规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的<code>logicClock</code>进行自增操作。</p><h3>2、发送初始化选票</h3><p>每个服务器最开始都是通过广播把票投给自己。</p><h3>4、更新选票</h3><p>根据选票<code>logicClock</code> -&gt; <code>vote_zxid</code> -&gt; <code>vote_id</code>依次判断</p><h5>4.1 判断选举轮次收到外部投票后，首先会根据投票信息中所包含的logicClock来进行不同处理：</h5><p><strong>外部投票的logicClock &gt; 自己的logicClock：</strong><br>说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的<code>logicClock</code>更新为收到的<code>logicClock</code>，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去;</p><p><strong>外部投票的logicClock &lt; 自己的logicClock：</strong><br>当前服务器直接忽略该投票，继续处理下一个投票;</p><p><strong>外部投票的logickClock = 自己的：</strong> 进行下一步的进行选票PK。</p><h5>4.2 选票PK是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比：</h5><p>若<code>logicClock</code>一致，则对比二者的<code>vote_zxid</code>。</p><p>若外部投票的<code>vote_zxid</code>比较大，则将自己的票中的<code>vote_zxid</code>与<code>vote_myid</code>更新为收到的票中的<code>vote_zxid</code>与<code>vote_myid</code>并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(<code>self_myid</code>, <code>self_zxid</code>)相同的选票，则直接覆盖</p><p>若二者<code>vote_zxid</code>一致，则比较二者的<code>vote_myid</code>。</p><p>若外部投票的<code>vote_myid</code>比较大，则将自己的票中的<code>vote_myid</code>更新为收到的票中的<code>vote_myid</code>并广播出去，另外将收到的票及自己更新后的票放入自己的票箱</p><h3>5、统计选票</h3><p>如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。</p><h3>6、更新服务器状态</h3><p>投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为<code>LEADING</code>，否则将自己的状态更新为<code>FOLLOWING</code>。</p><h2>七、图示Leader选举流程</h2><p><img src="http://bloghello.oursnail.cn/18-12-4/35769576.jpg" alt="image"></p><p>说明：</p><p>图中箭头上的(1,1,0) 三个数依次代表</p><ul><li>该选票的服务器的<code>LogicClock</code>（即投票轮数）;</li><li>被推荐的服务器的<code>myid</code> (即<code>vote_myid</code>);</li><li>被推荐的服务器的最大事务ID(即<code>vote_zxid</code>)；</li></ul><p>(1, 1)表示：</p><ul><li>投票服务器<code>myid</code>(即<code>self_myid</code>)</li><li>被推荐的服务器的<code>myid</code> (即<code>vote_myid</code>)</li></ul><p>所以(1,1,0)在这里的意思是：第一轮投票中，投给server 1，并且自己的最大事务ID都是0(这里可能会比较乱，ZXID可用这样理解：前32位是年号，比如万历年间；后32位是多少年，比如万历15年)，我们这里先不考虑年号的更迭，就假设这个投票发生在万历15年这一年，并且只考虑第一轮投票。即(1,vote_id,0)，所以暂时只考虑中间个数字。后面接受外部选票的时候，我们只要关注中间个数字即可，比如(1,2,0)说明是投给server 2的。</p><p>这里的示例只考虑第一轮，并且ZXID就是0.</p><h3>第一步：自增选票轮次&amp;初始化选票&amp;发送初始化选票</h3><p>首先，三台服务器自增选举轮次将<code>LogicClock=1</code>；然后初始化选票，清空票箱；最后发起初始化投票给自己将各自的票通过广播的形式投个自己并保存在自己的票箱里。</p><p>所以都是自己投给自己一票(1,1,0),(1,2,0),(1,3,0)</p><p>投完票之后的状态时(1,1),(2,2),(3,3)</p><h3>第二步：接受外部投票&amp;更新选票</h3><p>以<code>Server 1</code> 为例，分别经历 <code>Server 1 PK Server 2</code> 和 <code>Server 1 PK Server 3</code> 过程</p><h5>Server 1 PK Server 2</h5><p><code>Server 1</code> 接收到<code>Server 2</code>的选票(1,2,0) 表示投给<code>server 2</code>.</p><p>这时<code>Server 1</code>将自身的选票轮次和<code>Server 2</code> 的选票轮次比较，发现<code>LogicClock=1</code>相等，接着<code>Server 2</code>比较比较最大事务ID，发现也<code>zxid=0</code>也相等，最后比较各自的<code>myid</code>，发现<code>Server 2</code>的<code>myid=2</code> 大于自己的<code>myid=1</code>；</p><p>根据选票PK规则，<code>Server 1</code>将自己的选票由 (1, 1) 更正为 (1, 2)，表示选举<code>Server 2</code>为<code>Leader</code>，然后将自己的新选票 (1, 2)广播给 <code>Server 2</code> 和 <code>Server 3</code>，同时更新票箱子中自己的选票并保存<code>Server 2</code>的选票，至此<code>Server 1</code>票箱中的选票为(1, 2) 和 (2, 2)；</p><p><code>Server 2</code>收到<code>Server 1</code>的选票同样经过轮次比较和选票PK后确认自己的选票保持不变，并更新票箱中<code>Server 1</code>的选票由(1, 1)更新为(1, 2)，注意此次<code>Server 2</code>自己的选票并没有改变所有不用对外广播自己的选票。</p><p>此时便认为已经选出了<code>Leader</code>。但是这里可能会等一会看看有没有最优的情况，可能就会来到下面一步。</p><h5>Server 1 PK Server 3</h5><p><code>Server 1</code> 接收到<code>Server 3</code>的选票(1,3,0) 表示投给<code>server 3</code>.</p><p>根据<code>Server 1 PK Server 2</code>的流程类推，<code>Server 1</code>自己的选票由(1, 2)更新为(1, 3), 同样更新自己的票箱并广播给<code>Server 2</code> 和 <code>Server 3</code>；</p><p><code>Server 2</code>再次接收到<code>Server 1</code>的选票(1, 3)时经过比较后根据规则也要将自己的选票从(1, 2)更新为(1, 3), 并更新票箱里自己的选票和<code>Server 1</code>的选票，同时向<code>Server 1</code>和 <code>Server 3</code>广播；</p><p>同理 <code>Server 2</code> 和 <code>Server 3</code>也会经历上述投票过程，依次类推，<code>Server 1</code> 、<code>Server 2</code> 和<code>Server 3</code> 在俩俩之间在经历多次选举轮次比较和选票PK后最终确定各自的选票。</p><p>最后更新服务器状态：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/82571929.jpg" alt="image"></p><p>选票确定后服务器根据自己票箱中的选票确定各自的角色和状态，票箱中超过半数的选票投给自己的则为<code>Leader</code>，更新自己的状态为<code>LEADING</code>，否则为<code>Follower</code>角色，状态为<code>FOLLOWING</code>，成为<code>Leader</code>的服务器要主动向<code>Follower</code>发送心跳包，<code>Follower</code>做出<code>ACK</code>回应，以维持他们之间的长连接。</p><ul><li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener">https://dbaplus.cn/news-141-1875-1.html</a></li><li><a href="https://www.jianshu.com/p/3fec1f8bfc5f" target="_blank" rel="noopener">https://www.jianshu.com/p/3fec1f8bfc5f</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在zookeeper中其实使用的ZAB协议来实现数据的一致性，并且主要依靠的是leader和follower这两种角色控制数据的一致性，而leader是里面最重要的一个角色，它是主要负责写操作的节点，然后与其他的follower进行数据同步，所以我们也要保证leader宕机的时候要快速选举出新的leader并且进行数据恢复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
</feed>
