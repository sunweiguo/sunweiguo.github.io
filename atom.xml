<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-03T04:48:29.962Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>注解-属性赋值和自动装配</title>
    <link href="http://yoursite.com/2019/03/03/spring/%E6%B3%A8%E8%A7%A3-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>http://yoursite.com/2019/03/03/spring/注解-属性赋值和自动装配/</id>
    <published>2019-03-03T04:47:58.720Z</published>
    <updated>2019-03-03T04:48:29.962Z</updated>
    
    <content type="html"><![CDATA[<h2>1. @Value赋值</h2><p>给一个<code>Person</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册到容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动查看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig3.class);</span><br><span class="line">    System.out.println(<span class="string">"容器已经启动成功..."</span>);</span><br><span class="line">    Person person = applicationContext.getBean(Person.class);</span><br><span class="line">    System.out.println(person);<span class="comment">//Person(name=null, age=null)</span></span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在以前写配置文件的时候，我们可以在xml中给属性注入值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.swg.bean.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么现在的注解可以实现这样的功能吗？</p><ul><li>@Value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><ul><li>@SpEL表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;20-6&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure><h2>2. @PropertySource加载外部配置文件</h2><h4>${}注入属性文件的值</h4><ul><li>新建一个配置文件<code>db.properties</code>，在里面写:</li></ul><blockquote><p>person.nickname = hello</p></blockquote><ul><li>首先在配置类中声明要引入的配置文件：</li></ul><blockquote><p>@PropertySource(value = “classpath:/db.properties”)</p></blockquote><ul><li>然后再引入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;person.nickname&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String nickname;</span><br></pre></td></tr></table></figure><ul><li>以前在用xml的时候，是这样引入这个值的：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//然后下面就引入这个属性文件的值</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nickname"</span> <span class="attr">value</span>=<span class="string">"$&#123;person.nickname&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><p>自动装配：spring利用依赖注入DI，完成对IOC容器中各个组件依赖关系赋值</p><h2>3. @Autowired &amp; @Qualifier &amp; @Primary</h2><p><code>@Autowired</code>：默认是按照类型去容器中找相应的组件。找到就赋值。</p><blockquote><p>applicationContext.getBean(Person.class)</p></blockquote><p>如果找到多个相同类型的组件，再将属性名(默认是小写字母开头的id或者用<code>@Bean(&quot;xxx&quot;)</code>中的xxx为属性名)作为组件的id去容器中查找。</p><blockquote><p>applicationContext.getBean(“person”)</p></blockquote><p>所以，最好名字不一样。</p><p>如果有多个相同类型的组件，可以用<code>@Qualifier(&quot;xxx&quot;)</code>可以指定装配的id，而不是属性名。</p><p><strong>@Primary：让spring自动装配的时候，默认使用首选的bean；但是如果@Qualifier明确指定了要装配哪一个，还是以@Qualifier为准。</strong></p><p>默认，如果容器中没有这个组件，那么@Autowired就会报错。那么可不可以有就装配，没有就算了呢？</p><blockquote><p>@Autowired（required=false）</p></blockquote><h2>4. @Resource &amp; @Inject</h2><p>这两个都是java规范的注解。</p><ul><li>@Resource–JSR250</li></ul><p>默认是按照组件名称进行装配的。没有能支持<code>@Primary</code>和<code>@Autowired（required=false）</code>这个功能。</p><ul><li>@Inject–JSR330</li></ul><p>还需要一个依赖：<code>javax.inject</code></p><p>和<code>@Autowired</code>差不多，但是比<code>@Autowired</code>稍弱，虽然支持<code>@Primary</code>，但是没有<code>required=false</code></p><p><code>@Autowired</code>是<code>spring</code>定义的，后两者都是java的规范。</p><p>那么这些自动装配功能的注解是如何实现的呢？原来是<code>AutowiredAnnotationBeanPostProcessor</code>来实现的。</p><h2>5. 方法、构造器位置的自动装配</h2><p><code>@Autowired</code>能标注的位置：构造器、参数、方法、属性</p><ul><li>写在属性上面：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Car car;</span><br></pre></td></tr></table></figure><ul><li>写在方法上：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spring容器创建当前对象，就会调用方法，完成赋值；</span></span><br><span class="line"><span class="comment">//方法使用的参数，自定义类型的值从ioc容器中获取，就是这里的参数car。</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function">publlic <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写在构造器上：</li></ul><p>因为注册到ioc容器的组件，容器启动的时候回调用无参构造器创建对象，然后在进行初始化赋值等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放在有参构造器上面，这样容器启动的时候就会调用这个有参构造器</span></span><br><span class="line"><span class="comment">//构造器中要用的组件car，也是从容器中获取</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function">publlic <span class="title">Boss</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果当前类只有一个有参构造器，@Autowired是可以省略的。</strong></p><ul><li>写在参数前面：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//car都是从容器中获取的</span></span><br><span class="line"><span class="function">publlic <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(@Autowired Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>6. Aware注入Spring底层组件及原理</h2><p>自定义组件想使用spring容器底层的一些组件，比如<code>applicationContext</code>或者<code>beanFactory</code>等。只需要实现<code>xxxAware</code>接口即可。在创建对象的时候，会调用接口规定的方法注入相关组件。</p><p>比如<code>ApplicationContextAware</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以将它传进来的<code>ApplicationContext</code>保存一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snail</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>7. @Profile环境搭建和根据环境注册bean</h2><p>spring为我们提供的可用根据当前环境，动态地激活和切换一系列组件的功能。</p><p>开发环境、测试环境、生产环境，可能用不同的数据源，那么不想改动很多代码的话，就可以用<code>@Profile</code>切换。</p><p><code>@Profile</code>：指定组件在哪个环境的情况下才能被注册到容器中，<strong>不指定，在任何环境下都能注册这个组件</strong>。</p><p><strong>加了@Profile的@Bean，只有这个环境被激活的时候才能注册到容器中，但是有一个默认注册的：@Profile(“default”)</strong></p><p>那么如何指定某个环境注册到spring容器中呢？</p><ul><li>第一种方式：使用命令行动态参数</li></ul><blockquote><p>VM arguments: -Dspring.profiles.active=test</p></blockquote><ul><li>第二种方式：代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,创建一个applicationContext</span></span><br><span class="line"><span class="comment">//2,设置需要激活的环境</span></span><br><span class="line">applicationContext.getEnvironment().setActiveProfiles(<span class="string">"test"</span>,<span class="string">"dev"</span>);</span><br><span class="line"><span class="comment">//3,注册配置类</span></span><br><span class="line">applicationContext.register(MainConfigOfProfile.class);</span><br><span class="line"><span class="comment">//4,启动刷新容器</span></span><br><span class="line">applicationContext.refresh();</span><br></pre></td></tr></table></figure><h2>8. 总结</h2><ol><li><code>@Value</code>赋值</li><li><code>@PropertySource</code>加载外部配置文件</li><li><code>@Autowired</code> &amp; <code>@Qualifier</code> &amp; <code>@Primary</code> &amp; <code>@Resource</code> &amp; <code>@Inject</code>以及<code>@Autowired</code>在方法、构造器、参数位置的自动装配</li><li>通过实现<code>Aware</code>接口可以注入<code>Spring</code>底层的一些组件</li><li><code>@Profile</code>环境搭建和根据环境注册<code>bean</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1. @Value赋值&lt;/h2&gt;
&lt;p&gt;给一个&lt;code&gt;Person&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>注解-生命周期</title>
    <link href="http://yoursite.com/2019/03/03/spring/%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/03/spring/注解-生命周期/</id>
    <published>2019-03-03T04:21:05.538Z</published>
    <updated>2019-03-03T04:23:04.046Z</updated>
    
    <content type="html"><![CDATA[<p>我们在之前说到过bean的生命周期，其中提到了很多初始化方法，搞得我们晕头晕脑，本文就是来解决这个问题，对bean生命周期中重要的几个初始化和销毁接口或注解进行消息阐述，使得对bean的生命周期理解更加轻松。</p><a id="more"></a><h2>1. @Bean指定初始化和销毁方法</h2><p>bean生命周期：bean创建----初始化----销毁的过程</p><p>容器管理bean的生命周期，我们可以自定义初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法。</p><ul><li>指定初始化和销毁方法</li></ul><p>用xml配置的方式，可以指定<code>init-method</code>和<code>destory-method</code>；</p><p>那么注解如何做到自定义的初始化和销毁方法呢？</p><p>我们先来创建一个Dog的类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog constructor...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog destory..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个配置类来注册这个Dog：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来启动容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);</span><br><span class="line">    System.out.println(<span class="string">"容器已经启动成功..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么打印结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog constructor....</span><br><span class="line">容器已经启动成功...</span><br></pre></td></tr></table></figure><p>那如何指定我们自定义的初始化和销毁方法呢？</p><p>首先修改一下测试方法，增加一句关闭容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);</span><br><span class="line">    System.out.println(<span class="string">"容器已经启动成功..."</span>);</span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在@Bean注解上指定初始化方法和销毁方法：</p><blockquote><p>@Bean(initMethod = “init”,destroyMethod = “destory”)</p></blockquote><p>再次启动，显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog constructor....</span><br><span class="line">Dog init...</span><br><span class="line">容器已经启动成功...</span><br><span class="line">Dog destory...</span><br></pre></td></tr></table></figure><p>但是注意单例和多例的区别，现在我将其配置成多例，由于多例是每次访问才会创建bean，所以我们还需要访问一下。</p><p>最后的打印结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器已经启动成功...</span><br><span class="line">Dog constructor....</span><br><span class="line">五月 28, 2018 3:49:33 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@16f65612: startup date [Mon May 28 15:49:32 CST 2018]; root of context hierarchy</span><br><span class="line">Dog init...</span><br></pre></td></tr></table></figure><p>说明在多例的情况下，容器最后不会销毁这个bean。</p><p><strong>⭐总结一下：</strong></p><blockquote><p>注解如何指定bean的初始化和销毁：@Bean注解后面指定init-method和destory-method</p><p>初始化：对象创建完成之后，并赋值好，在调用初始化方法</p><p>销毁方法：单例：容器关闭的时候销毁；多例：容器不会管理这个bean，容器不会调用销毁方法</p></blockquote><h2>2. InitializingBean和DisposableBean</h2><p>除了上一种用<code>@Bean</code>的方式来指定<code>bean</code>的初始化和销毁之外，spring还提供了另外的方法来实现。</p><p>初始化：</p><p>让<code>Bean</code>实现<code>InitializingBean</code>接口并且实现它的<code>afterPropertiesSet</code>方法，他的作用时机是：当一个<code>BeanFactory</code>创建之后并且所有的属性值已经被设置完成之后，可以调用这个方法来进行初始化的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁：</p><p>让<code>Bean</code>实现<code>DisposableBean</code>接口并且实现<code>destroy</code>方法，他的作用时机是<code>BeanFactory</code>销毁的时候也将单实例bean给销毁掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat destory..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat afterPropertiesSet init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后打印一下，发现达到了一样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat constructor...</span><br><span class="line">cat afterPropertiesSet init...</span><br><span class="line">容器已经启动成功...</span><br><span class="line">cat destory...</span><br></pre></td></tr></table></figure><h2>3. @PostConstruct&amp;@PreDestory</h2><p><code>@PostConstruct</code>：bean创建好并且赋值好属性值之后执行一些初始化工作</p><p><code>@PreDestory</code>：在容器销毁bean之前通知我们进行清理工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pig constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pig destory..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样的效果。</p><h2>4. BeanPostProcessor-后置处理器</h2><p>这是一个接口，bean的后置处理器，在bean初始化前后进行一些处理工作，有两个方法，一个是初始化之前处理，一个是初始化之后处理。</p><p><strong>具体的执行时机：</strong></p><blockquote><p>postProcessBeforeInitialization是在bean实例生成之后，在任何的初始化方法之前（比如InitializingBean接口的afterPropertiesSet方法；比如init-method方法）</p></blockquote><blockquote><p>postProcessAfterInitialization与上面个完全相反，在任何的初始化方法完成之后再调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><p>我这里将上面的Dog，Cat，Pig全部用起来。pig用到init-destory和destory-method方法；cat实现InitializingBean,DisposableBean这两个接口；pig是实现@PostConstruct和@PreDestory这两个接口。</p><p>再加上后置处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean 还未初始化的bean对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName 这个bean对象在容器中的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回我们要用的bean实例对象，可以直接返回传进来的bean，也可以包装一下再返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessBeforeInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line">        <span class="keyword">return</span> bean;<span class="comment">//返回null的话，下面个方法就不会再执行了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessAfterInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一起启动，看看是什么先后顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//1.首先是Dog对象创建</span><br><span class="line">//2.然后是在任何的初始化方法之前执行postProcessBeforeInitialization</span><br><span class="line">//3.然后初始化init</span><br><span class="line">//4.init初始化之后执行postProcessAfterInitialization</span><br><span class="line">Dog constructor....</span><br><span class="line">postProcessBeforeInitialization...dog=&gt;com.swg.bean.Dog@157632c9</span><br><span class="line">Dog init...</span><br><span class="line">postProcessAfterInitialization...dog=&gt;com.swg.bean.Dog@157632c9</span><br><span class="line">//同理</span><br><span class="line">cat constructor...</span><br><span class="line">postProcessBeforeInitialization...cat=&gt;com.swg.bean.Cat@64c87930</span><br><span class="line">cat afterPropertiesSet init...</span><br><span class="line">postProcessAfterInitialization...cat=&gt;com.swg.bean.Cat@64c87930</span><br><span class="line">//同理</span><br><span class="line">pig constructor...</span><br><span class="line">postProcessBeforeInitialization...pig=&gt;com.swg.bean.Pig@4de5031f</span><br><span class="line">pig init...</span><br><span class="line">postProcessAfterInitialization...pig=&gt;com.swg.bean.Pig@4de5031f</span><br><span class="line"></span><br><span class="line">容器已经启动成功...</span><br><span class="line">五月 28, 2018 4:29:27 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@16f65612: startup date [Mon May 28 16:29:26 CST 2018]; root of context hierarchy</span><br><span class="line"></span><br><span class="line">pig destory...</span><br><span class="line">cat destory...</span><br><span class="line">Dog destory...</span><br></pre></td></tr></table></figure><p>⭐⭐⭐其实顺序是这样的：<code>Constructor</code> &gt; <code>@BeanPostProcessor</code>前置处理 &gt; <code>@PostConstruct</code> &gt; <code>InitializingBean</code> &gt; <code>init-method</code> &gt; <code>@BeanPostProcessor</code>后置处理</p><p><img src="http://bloghello.oursnail.cn/Spring%E4%B8%ADBean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt="image"></p><h2>5. BeanPostProcessor原理</h2><p>首先是创建IOC容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);</span><br></pre></td></tr></table></figure><p>进去之后是构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="keyword">this</span>.register(annotatedClasses);</span><br><span class="line">    <span class="keyword">this</span>.refresh();<span class="comment">//刷新IOC容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>refresh</code>方法中有<code>finishBeanFactoryInitialization</code>这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化剩下的所有非懒记载的单例bean</span></span><br><span class="line"><span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure><p><code>finishBeanFactoryInitialization</code>这个方法中有一个方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//真正初始化剩下的所有非懒记载的单例bean</span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure><p>下面就是获取bean，获取不到就创建对象。</p><p>上面已经完成了对象的创建。下面就是进行属性赋值和初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、赋值</span><br><span class="line">先执行populateBean方法，是对bean进行属性赋值</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、初始化</span><br><span class="line"><span class="comment">//遍历得到容器中所有的BeanPostProcessor：挨个执行beforeInitialization,一旦返回null，后置处理器就不会再执行</span></span><br><span class="line">applyBeanPostProcessorsBeforeInitialization<span class="comment">//初始化之前处理</span></span><br><span class="line">invokeInitMethods：执行初始化方法</span><br><span class="line">applyBeanPostProcessorsAfterInitialization<span class="comment">//初始化之后处理</span></span><br></pre></td></tr></table></figure><h2>6. BeanPostProcessor在spring底层的使用</h2><p>aop最基本的原理就是通过动态代理（jdk，cglib）来构造出一个代理对象，在容器创建bean的时候替换原来的bean。</p><p>是谁来创建这个代理对象呢？<code>AnnotationAwareAspectJAutoProxyCreator</code>，这个玩意就是<code>BeanPostProcessor</code>的某个子类。</p><p>关于Spring AOP的具体实现，还是比较复杂的，具体的代码以后再去研究，这里给出一个大概的步骤：</p><ul><li><code>@EnableAspectJAutoProxy</code> 会注册一个<code>AnnotationAwareAspectJAutoProxyCreator</code></li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>是一个<code>InstantiationAwareBeanPostProcessor</code></li><li>创建流程<ul><li><code>registerBeanPostProcessors()</code> 注册后置处理器，创建<code>AnnotationAwareAspectJAutoProxyCreator</code></li><li><code>finishBeanFactoryInitialization</code> 初始化剩下的单实例<code>Bean</code><ul><li>创建<code>Bean</code>和切面</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>拦截创建过程</li><li>创建完<code>Bean</code>判断是否需要增强。通过<code>BeanPostProcessorsAfterInitialization</code>，<code>wrapIfNecessary()</code> 包装代理对象</li></ul></li></ul></li><li>执行目标方法<ul><li>获取拦截器链（<code>advisor</code>包装为<code>Interceptor</code>）</li><li>递归调用拦截器链<ul><li>前置通知、目标方法、后置通知、返回通知、异常通知</li></ul></li></ul></li></ul><h2>总结</h2><ul><li>执行初始化和销毁方法<ul><li>通过<code>@Bean</code>指定<code>init-destory</code>和<code>destory-method</code>方法</li></ul></li><li>通过让<code>Bean</code>实现<code>InitializingBean</code>（定义初始化逻辑）,<code>DisposableBean</code>（定义销毁前的逻辑）</li><li>通过使用JSR250规范中的<code>@PostConstruct</code>和<code>@PreDestory</code>来进行初始化工作和销毁之前的工作</li><li><code>BeanPostProcessor</code>：<code>bean</code>的后置处理器，在<code>bean</code>初始化前后进行一些处理工作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在之前说到过bean的生命周期，其中提到了很多初始化方法，搞得我们晕头晕脑，本文就是来解决这个问题，对bean生命周期中重要的几个初始化和销毁接口或注解进行消息阐述，使得对bean的生命周期理解更加轻松。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>注解--组件注册</title>
    <link href="http://yoursite.com/2019/03/03/spring/%E6%B3%A8%E8%A7%A3--%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/"/>
    <id>http://yoursite.com/2019/03/03/spring/注解--组件注册/</id>
    <published>2019-03-03T03:44:21.165Z</published>
    <updated>2019-03-03T03:46:21.127Z</updated>
    
    <content type="html"><![CDATA[<p>所有的组件都应该放进IOC容器中，组件之间的关系通过容器实现自动装配，也就是依赖注入。对于如何将组件注册到容器中，本文从使用的角度出发详细阐述配置文件和注解的实现方式。涉及的注解还是挺多的，不过还是需要记忆一下，尤其是设置bean作用域的注解，面试中被问到过如何设置为多例。</p><a id="more"></a><p>新建一个<code>maven</code>工程，引入<code>spring-context</code>依赖。</p><h2>1. @Configuration &amp; @Bean给容器注册组件</h2><h5>以往的方式注册一个bean</h5><p>新建一个实体类Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们可以在beans.xml中注册这个bean，给他赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.swg.bean.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，我们就可以拿到张三这个人了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Person person = (Person) applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//输出：Person(name=张三, age=10)</span></span><br></pre></td></tr></table></figure><h5>注解的方式注册bean</h5><ul><li>配置类 = 配置文件</li><li>@Configuration 告诉spring这是一个配置类</li><li>@Bean 给容器注册一个Bean，类型为返回值类型，id默认是方法名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取这个bean呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">Person person = applicationContext.getBean(Person.class);</span><br><span class="line">System.out.println(person);<span class="comment">//Person(name=李四, age=20)</span></span><br></pre></td></tr></table></figure><p>我们还可以根据类型来获取这个bean在容器中名字是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] names = applicationContext.getBeanNamesForType(Person.class);</span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">    System.out.println(name);<span class="comment">//person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到，id默认是方法名。如果我们修改MainConfig中的person这个方法名，果然打印结果也随着这个方法名改变而改变；也可以自己另外指定这个bean在容器中的名字：@Bean(“hello”)，那么这个bean的名字就变成了hello.</p><h2>2. @ComponentScan自动扫描组件以及扫描规则</h2><p>配置文件中配置包扫描时这样配置的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--包扫描，只要标注了@Controller，@Service，@Repository，@Component，就会被自动扫描到加入到容器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>现在用注解来实现这个功能：</p><p>只需要加上注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>)<span class="comment">//java8可以写多个@ComponentScan</span></span><br><span class="line"><span class="comment">//java8以前虽然不能写多个，但是也可以实现这个功能，用@ComponentScans配置即可</span></span><br></pre></td></tr></table></figure><p>我们增加BookController.java,BookService.java以及BookDao.java三个类，并且分别加上注解：@Controller，@Service，@Repository；那么包扫描就可以把这些类全部注册到IOC容器中了。</p><p>我们来打印一下目前所有注册到IOC容器的类的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldAnswerWithTrue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">    String[] names = applicationContext.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">//以上是spring IOC容器自身需要的组件，下面是我们自定义的组件</span><br><span class="line">mainConfig//主配置类，因为有注解@Configuration，而这个注解本身是有@Component的，所以也是一个bean</span><br><span class="line">bookController//@Controller</span><br><span class="line">bookDao//@Repository</span><br><span class="line">bookService//@Service</span><br><span class="line">person//这是由自己@Bean注册进去的</span><br></pre></td></tr></table></figure><p>上面的扫描路径是扫描所有的，有的时候我们需要排除掉一些扫描路径或者只扫描某个路径，如何做到呢？</p><p>用<code>excludeFilters</code>来排除，里面可以指定排除规则，这里是按照<code>ANNOTATION</code>来排除，排除掉所有<code>@Controller</code>注解的类。<code>classes</code>也是个数组，可以排除很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>,excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么效果就是<code>controller</code>没有了，但是<code>service</code>和<code>dao</code>都在。</p><p>那如果我想只包含<code>controller</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>, includeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)</span><br><span class="line">&#125;,useDefaultFilters = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>注意要<code>useDefaultFilters = false</code>，因为默认为<code>true</code>，就是扫描所有，不设置为<code>false</code>无效。</p><h2>3. 自定义TypeFilter制定过滤规则</h2><p>上面包扫描是按照<code>FilterType.ANNOTATION</code>规则来实现的，他还有其他几种规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FilterType &#123;</span><br><span class="line">    ANNOTATION,<span class="comment">//注解，最常用</span></span><br><span class="line">    ASSIGNABLE_TYPE,<span class="comment">//按照给定的类型，比如指定是BookService.class，那么只要是BookService这个类型就会被规则配置进来，子类或者实现类都可以</span></span><br><span class="line">    ASPECTJ,<span class="comment">//ASPECTJ表达式，不常用</span></span><br><span class="line">    REGEX,<span class="comment">//正则</span></span><br><span class="line">    CUSTOM;<span class="comment">//自定义规则</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FilterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最后的<code>CUSTOM</code>，这里着重说一说怎么用。</p><p>首先是要求实现<code>FilterType</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReader:读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReaderFactory：可以获取到其他任何类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前类注解信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">//获取当前正在扫描的类的类信息,可以获取子类，父类，接口等信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        System.out.println(<span class="string">"----&gt;"</span>+className);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回false，表示不匹配，返回true的就匹配。这里默认是false；</p><p>在<code>mainConfig</code>类中配置这个自定义的过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>, includeFilters = &#123;</span><br><span class="line"><span class="meta">@ComponentScan</span>.Filter(type = FilterType.CUSTOM,classes = &#123;MyTypeFilter.class&#125;)</span><br><span class="line">&#125;,useDefaultFilters = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>那么此时输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----&gt;com.swg.AppTest</span><br><span class="line">----&gt;com.swg.bean.Person</span><br><span class="line">----&gt;com.swg.controller.BookController</span><br><span class="line">----&gt;com.swg.dao.BookDao</span><br><span class="line">----&gt;com.swg.FilterType.MyTypeFilter</span><br><span class="line">----&gt;com.swg.MainTest</span><br><span class="line">----&gt;com.swg.service.BookService</span><br><span class="line"></span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">mainConfig</span><br><span class="line">person</span><br></pre></td></tr></table></figure><p>就是显示了所有他处理的类，最后由于都返回fasle，那么那些controller，service都将被过滤掉。</p><p>下面指定通过一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(className.contains(<span class="string">"er"</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mainConfig</span><br><span class="line">person</span><br><span class="line">bookController//new</span><br><span class="line">myTypeFilter//new</span><br><span class="line">bookService//new</span><br></pre></td></tr></table></figure><h2>4. @Scope-设置组件作用域</h2><p>spring的bean默认是单实例，下面佐证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br><span class="line">    String[] names = applicationContext.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean  = applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">    Object bean1  = applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">    System.out.println(bean == bean1);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以配置bean为多例吗？显然是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Scope</code>注解中有四个选项：</p><ul><li><code>prototype</code>:多例</li><li><code>singleton</code>:单例，默认</li><li><code>request</code>:同一次请求创建一个实例</li><li><code>session</code>:同一个session创建一个实例</li></ul><p>着重看一下<code>singleton</code>和<code>prototype</code>，他们的加载时机？</p><p>⭐⭐⭐<code>singleton</code>：<strong>IOC容器启动时调用方法创建对象放到IOC容器中，以后每次获取都直接从容器中拿，类似于map.get();</strong></p><p>⭐⭐⭐<code>prototype</code><strong>:IOC容器启动时不会创建对象，而是在每次获取时才会调用方法创建对象；并且是新new出来的对象，都是不一样的。</strong></p><h2>5. @lazy-bean-懒加载</h2><p>单实例bean，默认在容器启动时创建对象。</p><p>即只要执行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br></pre></td></tr></table></figure><p>Person这个对象就会加载在容器中。测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建对象Person"</span>);<span class="comment">//容器启动的时候就会执行这个方法，创建Perosn对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒加载：容器启动时不创建对象，第一次使用(获取)Bean创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建对象Person"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，就不会在容器一启动的时候就加载了。那什么时候加载呢？</p><p>我获取一下这个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br><span class="line">Object bean  = applicationContext.getBean(<span class="string">"person"</span>);</span><br></pre></td></tr></table></figure><p>这个时候，@Bean就被创建了。这就是懒加载。</p><h2>6. @Conditional-按照条件注册bean</h2><p>按照一定的条件进行判断，满足条件给容器注册bean。</p><p>先创建三个bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"bill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Bill"</span>,<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"linus"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"linus"</span>,<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印一下创建的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br><span class="line">    String[] names = applicationContext.getBeanNamesForType(Person.class);</span><br><span class="line">    <span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">        System.out.println(<span class="string">"---&gt;"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Person&gt; types = applicationContext.getBeansOfType(Person.class);</span><br><span class="line">    System.out.println(types);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---&gt;person</span><br><span class="line">---&gt;bill</span><br><span class="line">---&gt;linus</span><br><span class="line">&#123;person=Person(name=李四, age=20), bill=Person(name=Bill, age=60), linus=Person(name=linus, age=50)&#125;</span><br></pre></td></tr></table></figure><p>那假设一个场景：如果系统是windows,给容器注册“bill”；如果系统是linux,给容器注册“linus”；</p><p>至于获取操作系统是什么，我们可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();</span><br><span class="line">String osName = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">System.out.println(osName);<span class="comment">//wondows 7</span></span><br></pre></td></tr></table></figure><p>那么我们如何根据条件来注册bean呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否是linux系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取IOC使用的bean factory，这个factory就是创建对象并进行装配的工厂</span></span><br><span class="line">        ConfigurableListableBeanFactory factory = conditionContext.getBeanFactory();</span><br><span class="line">        <span class="comment">//2.获取类加载器</span></span><br><span class="line">        ClassLoader classLoader = conditionContext.getClassLoader();</span><br><span class="line">        <span class="comment">//3.获取当前环境信息</span></span><br><span class="line">        Environment environment = conditionContext.getEnvironment();</span><br><span class="line">        <span class="comment">//4.获取到bean定义的注册类</span></span><br><span class="line">        BeanDefinitionRegistry registry = conditionContext.getRegistry();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是liunx系统，就让其注册进容器，windows也是如此</span></span><br><span class="line">        String osName = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        <span class="keyword">if</span>(osName.contains(<span class="string">"Linux"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Conditional</span>(&#123;WindowsCondition.class&#125;)<span class="comment">//传condition数组</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"bill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Bill"</span>,<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition.class)</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"linus"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"linus"</span>,<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么运行结果可以预测到：由于我们是windows系统，所以linux的就不能注册进容器了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows 7</span><br><span class="line">---&gt;person</span><br><span class="line">---&gt;bill</span><br><span class="line">&#123;person=Person(name=李四, age=20), bill=Person(name=Bill, age=60)&#125;</span><br></pre></td></tr></table></figure><h2>7. @Import-给容器中快速导入一个组件</h2><p>上面所说得给容器注册组件的方式是：</p><p>包扫描+组件标注注解：<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Component</code></p><p>比较方便，但是有局限性：如果是注册第三方包怎么办呢？</p><p>有一种是：<code>@Bean</code>[导入第三方包里面的组件],对于简单的可用这样用</p><p>还有一种是：<code>@Import</code>，快速给容器导入一个组件</p><p>比如我随便新建一个类叫<code>Dog</code>，里面啥注解和内容都不写。默认他是不会导入进去的。但是我在<code>webconfig</code>类上增加注解：</p><blockquote><p>@Import(Dog.class)</p></blockquote><p>那么再次打印出所有注册进容器的组件时，会出现</p><blockquote><p>com.swg.bean.Dog</p></blockquote><p>可见，<code>@import</code>注解可以方便快速地导入一个组件，并且id默认是组件的全类名</p><p>那如何导入多个呢？</p><blockquote><p>@Import({Dog.class, Cat.class})</p></blockquote><h2>8. @Import-使用ImportSelector</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义逻辑返回需要导入的组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationMetadata 当前标注Import注解的类的所有注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值就是导入到容器中的组件的全类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"com.swg.bean.Dog"</span>,<span class="string">"com.swg.bean.Cat"</span>,<span class="string">"com.swg.bean.pig"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打上注解导入进来即可：</p><blockquote><p>@Import(MyImportSelector.class)</p></blockquote><p>这里导入的实际上不是<code>MyImportSelector.class</code>这个类，而是他返回的组件全类名</p><h2>9. @Import-使用ImportBeanDefinitionRegistrar</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationMetadata 当前类的注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry  beanDefinition注册类；</span></span><br><span class="line"><span class="comment">     *                   把所有需要添加进容器的bean：调用BeanDefinitionRegistry.registerBeanDefinition</span></span><br><span class="line"><span class="comment">     *                   来手工注册进来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断这两个bean是否都已经存在于容器中</span></span><br><span class="line">        <span class="keyword">boolean</span> definition = registry.containsBeanDefinition(<span class="string">"com.swg.bean.Pig"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> definition2 = registry.containsBeanDefinition(<span class="string">"com.swg.bean.Cat"</span>);</span><br><span class="line">        <span class="comment">//如果两个bean都有，则注册一头牛</span></span><br><span class="line">        <span class="keyword">if</span>(definition &amp;&amp; definition2)&#123;</span><br><span class="line">            <span class="comment">//指定bean定义信息</span></span><br><span class="line">            RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(Bull.class);</span><br><span class="line">            <span class="comment">//注册一个bean，指定bean的名字</span></span><br><span class="line">            registry.registerBeanDefinition(<span class="string">"bull"</span>,rootBeanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打上注解导入进来即可：</p><blockquote><p>@Import(MyImportBeanDefinitionRegistrar.class)</p></blockquote><h2>10. 使用FactoryBean注册组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个Pig对象，这个对象会添加到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AnimalFactory...getObject()..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Pig.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是单例吗？返回true表示是单例，在容器中保存一份</span></span><br><span class="line"><span class="comment">     * false：表示是多例，每次获取都创建新的，每次调用getObject()这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先将它用@Bean添加进容器看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnimalFactory <span class="title">animalFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnimalFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示的id是animalFactory，我们根据这个id获取一下这个bean的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object bean = applicationContext.getBean(<span class="string">"animalFactory"</span>);</span><br><span class="line">System.out.println(<span class="string">"bean的类型："</span>+bean.getClass());</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimalFactory...getObject()...</span><br><span class="line">bean的类型：class com.swg.bean.Pig</span><br></pre></td></tr></table></figure><p>就是说，这个bean的类型就是getObject方法中返回的Pig对象。</p><p>那如果我们想获取这个工厂对象呢？也是可以的，id前面加上&amp;即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object bean = applicationContext.getBean(<span class="string">"&amp;animalFactory"</span>);</span><br><span class="line">System.out.println(<span class="string">"bean的类型："</span>+bean.getClass());<span class="comment">//bean的类型：class com.swg.bean.AnimalFactory</span></span><br></pre></td></tr></table></figure><p>原因是在BeanFactory中定义了一个前缀&amp;，只要是以&amp;为前缀，表示拿FactoryBean本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br></pre></td></tr></table></figure><h2>11. 总结</h2><p>给容器中注册组件：</p><ol><li><p>包扫描+组件标注注解：@Controller，@Service，@Repository，@Component</p></li><li><p>@Bean[导入第三方包里面的组件]</p></li><li><p><strong>@Import，快速给容器导入一个组件—重要</strong></p><p>1).@Import(要导入到容器中的组件)；容器会自动注册这个组件，id默认是全类名</p><p>2).@ImportSelector：返回要导入的组件的全类名数组</p><p>3).@ImportBeanDefinitionRegistrar：手动注册bean到容器中</p></li><li><p>使用spring提供的@FactoryBean（工厂bean）来注册bean</p></li><li><p><strong>@Conditional按照条件注册bean—重要</strong></p></li><li><p>@Scope作用域</p></li><li><p>懒加载，单例和多例是不一样的</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有的组件都应该放进IOC容器中，组件之间的关系通过容器实现自动装配，也就是依赖注入。对于如何将组件注册到容器中，本文从使用的角度出发详细阐述配置文件和注解的实现方式。涉及的注解还是挺多的，不过还是需要记忆一下，尤其是设置bean作用域的注解，面试中被问到过如何设置为多例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean</title>
    <link href="http://yoursite.com/2019/03/02/spring/Spring%20Bean/"/>
    <id>http://yoursite.com/2019/03/02/spring/Spring Bean/</id>
    <published>2019-03-02T13:33:29.306Z</published>
    <updated>2019-03-03T04:27:07.002Z</updated>
    
    <content type="html"><![CDATA[<p>一提到Spring的IOC，那么里面的Bean基本就会被问到，我们也知道，Spring的任务就是对这些bean进行管理和装配，所以bean就是spring IOC处理的对象，如此关键的对象，我们需要了解它核心的两点：作用域和生命周期。</p><a id="more"></a><h2>一、Spring Bean的作用域</h2><ul><li><code>singleton</code>：Spring默认作用域，容器里拥有唯一的Bean实例</li><li><code>prototype</code>：针对每个getBean请求，容器都会创建一个bean实例</li><li><code>request</code>：会为每个HTTP请求创建一个Bean实例</li><li><code>session</code>：会为每个session创建一个Bean实例</li><li><code>globalSession</code>：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效</li></ul><p>对于这个问题面试中我也被问过，即spring中bean默认作用域，如何设置为多例。这个问题我在<a href="http://fourcolor.oursnail.cn/2019/03/03/spring/%E6%B3%A8%E8%A7%A3--%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/" target="_blank" rel="noopener">注解–组件注册</a>这篇文章中会详细谈论。</p><h2>二、Bean的生命周期</h2><p><code>beanDefinition</code>（容器启动阶段）只完成<code>bean</code>的定义，并未完成初始化。初始是通过<code>beanFactory</code>的<code>getBean()</code>时才进行的。</p><p>对于普通的Java对象，当new的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。而由Spring IoC容器托管的对象，它们的生命周期完全由容器控制。Spring中每个Bean的生命周期如下：</p><p><img src="http://bloghello.oursnail.cn/spring4-1.png" alt="image"></p><h5>2.1 实例化Bean</h5><p>对于<code>BeanFactory</code>容器，当客户向容器请求一个尚未初始化的<code>bean</code>时，或初始化<code>bean</code>的时候需要注入另一个尚未初始化的依赖时，容器就会调用<code>createBean</code>进行实例化。</p><p>容器通过获取<code>BeanDefinition</code>对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。</p><p>实例化对象被包装在<code>BeanWrapper</code>对象中，<code>BeanWrapper</code>提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h5>2.2 设置对象属性（依赖注入）</h5><p>实例化后的对象被封装在<code>BeanWrapper</code>对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。</p><p>紧接着，<code>Spring</code>根据<code>BeanDefinition</code>中的信息进行依赖注入。</p><p>并且通过<code>BeanWrapper</code>提供的设置属性的接口完成依赖注入。</p><h5>2.3 注入Aware接口</h5><p>紧接着，Spring会检测该对象是否实现了<code>xxxAware</code>接口，并将相关的<code>xxxAware</code>实例注入给bean。</p><h5>2.4 BeanPostProcessor</h5><p>当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过<code>BeanPostProcessor</code>接口实现。</p><p>该接口提供了两个函数：</p><ul><li><code>postProcessBeforeInitialzation( Object bean, String beanName )</code><ul><li>当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。</li><li>这个函数会先于<code>InitialzationBean</code>执行，因此称为前置处理。</li><li>所有Aware接口的注入就是在这一步完成的。</li></ul></li><li><code>postProcessAfterInitialzation( Object bean, String beanName )</code><ul><li>当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。</li><li>这个函数会在<code>InitialzationBean</code>完成后执行，因此称为后置处理。</li></ul></li></ul><h5>2.5 InitializingBean与init-method</h5><p>当<code>BeanPostProcessor</code>的前置处理完成后就会进入本阶段。</p><p><code>InitializingBean</code>接口只有一个函数：</p><ul><li><code>afterPropertiesSet()</code></li></ul><p>这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行<code>afterPropertiesSet</code>函数。</p><h5>2.6 DisposableBean和destroy-method</h5><p>和<code>init-method</code>一样，通过给<code>destroy-method</code>指定函数，就可以在bean销毁前执行指定的逻辑。</p><p>对于上面的过程只能理解并且记忆，还是很容易被问到的，是spring的一个高频考点。或许你对这些所说的方法一脸懵逼，对于生命周期这一块，我对里面涉及的所有初始化以及销毁方法进行了汇总，详情见文章:<a href="http://fourcolor.oursnail.cn/2019/03/03/spring/%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" target="_blank" rel="noopener">注解-生命周期</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一提到Spring的IOC，那么里面的Bean基本就会被问到，我们也知道，Spring的任务就是对这些bean进行管理和装配，所以bean就是spring IOC处理的对象，如此关键的对象，我们需要了解它核心的两点：作用域和生命周期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>AOP基本使用和原理</title>
    <link href="http://yoursite.com/2019/03/02/spring/AOP%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/02/spring/AOP基本使用和原理/</id>
    <published>2019-03-02T11:06:02.574Z</published>
    <updated>2019-03-02T11:26:45.267Z</updated>
    
    <content type="html"><![CDATA[<p>除了IOC之外，spring核心的东西就是AOP。主要的目标是实现关注业务逻辑，解耦非业务逻辑，比如比较典型的日志处理。将日志的处理划分出来，在运行时动态地添加到要拦截的接口方法上，对这个方法的执行前后以及发生异常时实现日志的监控。这种动态的功能是非常重要的功能，本文来介绍一下AOP最基本的使用。</p><a id="more"></a><h2>一、什么是aop</h2><p>AOP（Aspect Oriented Programming），即面向切面编程（也叫面向方面编程，面向方法编程）。其主要作用是，在不修改源代码的情况下给某个或者一组操作添加额外的功能。像日志记录，事务处理，权限控制等功能，都可以用AOP来“优雅”地实现，使这些额外功能和真正的业务逻辑分离开来，软件的结构将更加清晰。AOP是OOP的一个强有力的补充。</p><h2>二、先简单用一下spring aop</h2><h5>首先要导入依赖：spring-aspects</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5>写一个业务逻辑类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathCaculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要向在这个业务逻辑方法运行前，运行结束时，方法出现异常时都将日志文件打印。</p><h5>定义一个日志切面类</h5><p>切面类里面的方法需要动态感知MathCaculator.div运行到哪里。</p><p>通知方法：</p><ul><li>前置通知(<code>@Before</code>)：<code>logStart()</code>：在目标方法div运行之前运行</li><li>后置通知(<code>@After</code>)：<code>logEnd()</code>:在目标方法div运行结束之后运行</li><li>返回通知(<code>@AfterReturning</code>)：<code>logReturn()</code>:在目标方法div运行正常返回之后运行</li><li>异常通知(<code>@AfterThrowing</code>)：<code>logException()</code>:在目标方法div出现异常之后运行</li><li>环绕通知(<code>@Around</code>)：动态代理，手动推进目标方法运行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.swg.aop.MathCaculator.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(<span class="string">"【@Before】...方法名：&#123;"</span>+methodName+<span class="string">"&#125;...参数列表是-&gt;&#123;"</span>+ Arrays.asList(args)+<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【@After】...&#123;"</span>+joinPoint.getSignature().getName()+<span class="string">"&#125;结束..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"pointCut()"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【@AfterReturning】...&#123;"</span>+joinPoint.getSignature().getName()+<span class="string">"&#125;正常返回，运行结果是&#123;"</span>+result+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"pointCut()"</span>,throwing = <span class="string">"exception"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【@AfterThrowing】...&#123;"</span>+joinPoint.getSignature().getName()+<span class="string">"&#125;发生异常,异常信息是&#123;"</span>+exception.getMessage()+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>切面类和业务逻辑类都加入到容器中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathCaculator <span class="title">mathCaculator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathCaculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogAspect <span class="title">aspect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogAspect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>容器启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfAop.class);</span><br><span class="line">    System.out.println(<span class="string">"容器已经启动成功..."</span>);</span><br><span class="line">    MathCaculator caculator = applicationContext.getBean(MathCaculator.class);</span><br><span class="line">    caculator.div(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>无异常的情况输出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器已经启动成功...</span><br><span class="line">【@Before】...方法名：&#123;div&#125;...参数列表是-&gt;&#123;[6, 2]&#125;</span><br><span class="line">div...</span><br><span class="line">【@After】...&#123;div&#125;结束...</span><br><span class="line">【@AfterReturning】...div正常返回，运行结果是&#123;3&#125;</span><br></pre></td></tr></table></figure><h5>有异常的情况输出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器已经启动成功...</span><br><span class="line">【@Before】...方法名：&#123;div&#125;...参数列表是-&gt;&#123;[6, 0]&#125;</span><br><span class="line">div...</span><br><span class="line">【@After】...&#123;div&#125;结束...</span><br><span class="line">【@AfterThrowing】...&#123;div&#125;发生异常,异常信息是&#123;/ by zero&#125;</span><br></pre></td></tr></table></figure><p>主要是有三步：</p><blockquote><p>将业务逻辑组件和切面类都加入到容器中，告诉spring哪个是切面类(@Aspect)</p><p>在切面类上的每一个通知方法上标注通知注释，告诉spring合适何地运行(切入点表达式)</p><p>开启基于注解的aop模式(@EnableAspectJAutoProxy)</p></blockquote><h2>三、基本原理</h2><p>AOP是具有特定的应用场合的，它只适合那些具有横切逻辑的应用场合，如性能检测、访问控制、事务管理及日志纪录。</p><p>Spring AOP使用动态代理技术在运行期织入增强的代码，Spring AOP使用了两种代理机制：<strong>一种是基于JDK的动态代理；另一种是基于CGLib的动态代理</strong>。这两种机制就是AOP最根本的实现原理，面试中把这两者说清楚即可。</p><h5>3.1 JDK动态代理</h5><p>Java1.3后，Java提供了动态代理技术，运行开发者在运行期间创建接口的代理实例。JDK动态代理主要涉及<code>java.lang.reflect</code>包中的两个类：<code>Proxy</code>和<code>InvocationHandler</code>。<code>InvocationHandler</code>是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。</p><p>具体请看笔记<a href="http://fourcolor.oursnail.cn/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">java基础之JDK动态代理</a></p><h5>3.2 CGLib动态代理</h5><p>CGLib采用底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p><p>需要注意的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final或private方法进行代理。</p><h5>3.3 为什么会有两种代理机制</h5><ul><li>JDK创建代理有一个限制，即它只能为接口创建代理实例，虽然面向接口编程是好的编程习惯，但有时候并不是必须的，这是JDK动态代理的局限性。</li><li>就性能来说，CGLib所创建的动态代理对象的性能比JDK所创建的动态代理对象的性能高差不多10倍，CGLib在创建代理对象时所话费的时间却比JDK动态代理大概多8倍，但是对于singleton的代理对象或者具有实例池的代理，因为无需频繁创建代理对象，所以比较合适采用CGLib动态代理技术，反之则适合采用JDK动态代理技术。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了IOC之外，spring核心的东西就是AOP。主要的目标是实现关注业务逻辑，解耦非业务逻辑，比如比较典型的日志处理。将日志的处理划分出来，在运行时动态地添加到要拦截的接口方法上，对这个方法的执行前后以及发生异常时实现日志的监控。这种动态的功能是非常重要的功能，本文来介绍一下AOP最基本的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>IOC的用法</title>
    <link href="http://yoursite.com/2019/03/02/spring/IOC%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/02/spring/IOC的用法/</id>
    <published>2019-03-02T10:29:16.202Z</published>
    <updated>2019-03-03T03:38:01.368Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经知道了IOC的基本思想，它用一种倒置的思想帮助我们实现高层建筑需要什么直接引入底层就行，而不需要关心底层的具体实现，因为具体实现已经交给了我们的IOC去实现了。了解了这些之后，光说不练肯定是不行的，下面我们来看看这种依赖倒置到底是如何去用的。首先介绍一下传统的方式，就是spring中经常用的方式。然后再介绍一下springBoot中是什么样子的。其实它们两是差不多的。</p><a id="more"></a><p>我们知道，要想用<code>Bean</code>，那么必然是要先注册进去才行。<code>Spring</code> 启动时读取应用程序提供的<code>Bean</code>配置信息，并在<code>Spring</code>容器中生成一份相应的<code>Bean</code>配置注册表，然后根据这张注册表实例化<code>Bean</code>，装配好<code>Bean</code>之间的依赖关系，为上层应用提供准备就绪的运行环境。</p><p><img src="http://bloghello.oursnail.cn/spring2-1.png" alt="image"></p><h2>一、@Configuration 和 @Bean给容器注册组件</h2><p>新建一个<code>maven</code>工程，引入<code>spring-context</code>依赖。</p><h5>1.1 以往的方式注册一个bean</h5><p>新建一个实体类<code>Person</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们可以在<code>beans.xml</code>中注册这个<code>bean</code>，给他赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.swg.bean.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，我们就可以拿到张三这个人了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Person person = (Person) applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//输出：Person(name=张三, age=10)</span></span><br></pre></td></tr></table></figure><h5>1.2 注解的方式注册bean</h5><ul><li>配置类 = 配置文件</li><li><code>@Configuration</code> 告诉<code>spring</code>这是一个配置类</li><li><code>@Bean</code> 给容器注册一个<code>Bean</code>，类型为返回值类型，<code>id</code>默认是方法名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取这个<code>bean</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">Person person = applicationContext.getBean(Person.class);</span><br><span class="line">System.out.println(person);<span class="comment">//Person(name=李四, age=20)</span></span><br></pre></td></tr></table></figure><p>我们还可以根据类型来获取这个bean在容器中名字是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] names = applicationContext.getBeanNamesForType(Person.class);</span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">    System.out.println(name);<span class="comment">//person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到，<code>id</code>默认是方法名。如果我们修改<code>MainConfig</code>中的<code>person</code>这个方法名，果然打印结果也随着这个方法名改变而改变；也可以自己另外指定这个<code>bean</code>在容器中的名字：<code>@Bean(&quot;hello&quot;)</code>，那么这个<code>bean</code>的名字就变成了<code>hello</code>.</p><h5>1.3 springboot中用这种方式注册bean以及获取</h5><p><code>springboot</code>那就更简单了。</p><p>定义<code>bean</code>跟注解的方式是一样的，不再赘述。只是，我们来到它的启动类，直接可以获取到<code>ApplicationContext</code>，然后就可以直接获取到<code>bean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootdemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = SpringApplication.run(SpringbootdemoApplication.class, args);</span><br><span class="line">        Person person = (Person) ctx.getBean(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们点进<code>run</code>里面：</p><p><img src="http://bloghello.oursnail.cn/spring2-2.png" alt="image"></p><p>我们这里不深入探讨里面的实现细节，我们这里只要知道可以用<code>ApplicationContext</code>来接收即可。</p><p>只是，到现在，我们一直在用这个<code>ApplicationContext</code>，它到底是何方神圣？</p><h2>二、BeanFactory和ApplicationContext</h2><p>我们知道，IOC会帮助我们完成对象的创建并将其送到服务对象即完成对象的绑定，即IOC要实现这两件事情：</p><ul><li>对象的构建</li><li>对象的绑定</li></ul><p>spring提供了两种类型的容器来实现对<code>bean</code>的管理，一个是<code>BeanFactory</code>,一个是<code>ApplicationContext</code>(可以认为是<code>BeanFactory</code>的扩展)，这两者是<code>spring core</code>中最核心的两个基础接口。下面我们将介绍这两种容器如何实现对对象的管理。</p><p><code>Spring</code> 通过一个配置文件描述 <code>Bean</code> 及 <code>Bean</code> 之间的依赖关系，利用 <code>Java</code> 语言的反射功能实例化 <code>Bean</code> 并建立 <code>Bean</code> 之间的依赖关系。 <code>Spring</code> 的 <code>IoC</code> 容器在完成这些底层工作的基础上，还提供了 <code>Bean</code> 实例缓存、生命周期管理、 <code>Bean</code> 实例代理、事件发布、资源装载等高级服务。</p><p><code>BeanFactory</code> 是 <code>Spring</code> 框架的基础设施，面向 <code>Spring</code> 本身；</p><p><code>ApplicationContext</code> 面向使用 <code>Spring</code>框架的开发者，几乎所有的应用场合我们都直接使用 <code>ApplicationContext</code> 而非底层的 <code>BeanFactory</code>。</p><p>我们先来看看 <code>BeanFactory</code> ，再来看看 <code>ApplicationContext</code> 。</p><h5>2.1 BeanFactory</h5><p><code>BeanFactory</code> 体系架构：</p><p><img src="http://bloghello.oursnail.cn/spring2-3.png" alt="image"></p><ul><li><code>BeanDefinitionRegistry</code>： <code>Spring</code> 配置文件中每一个节点元素在 <code>Spring</code> 容器里都通过一个 <code>BeanDefinition</code> 对象表示，它描述了 <code>Bean</code> 的配置信息。而 <code>BeanDefinitionRegistry</code> 接口提供了向容器手工注册 <code>BeanDefinition</code> 对象的方法。</li><li><code>BeanFactory</code> 接口位于类结构树的顶端 ，它最主要的方法就是 <code>getBean(String beanName)</code>，该方法从容器中返回特定名称的 <code>Bean</code>，<code>BeanFactory</code> 的功能通过其他的接口得到不断扩展.</li><li><code>ListableBeanFactory</code>：该接口定义了访问容器中 <code>Bean</code> 基本信息的若干方法，如查看<code>Bean</code> 的个数、获取某一类型 <code>Bean</code> 的配置名、查看容器中是否包括某一 <code>Bean</code> 等方法；</li><li><code>HierarchicalBeanFactory</code>：父子级联 <code>IoC</code>容器的接口，子容器可以通过接口方法访问父容器； 通过 <code>HierarchicalBeanFactory</code> 接口， <code>Spring</code> 的 <code>IoC</code> 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 <code>Bean</code>，但父容器不能访问子容器的 <code>Bean</code>。<code>Spring</code> 使用父子容器实现了很多功能，比如在 <code>Spring MVC</code> 中，展现层 <code>Bean</code> 位于一个子容器中，而业务层和持久层的 <code>Bean</code> 位于父容器中。这样，展现层 <code>Bean</code> 就可以引用业务层和持久层的 <code>Bean</code>，而业务层和持久层的 <code>Bean</code> 则看不到展现层的 <code>Bean</code>。</li><li><code>ConfigurableBeanFactory</code>：是一个重要的接口，增强了 <code>IoC</code> 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li><li><code>AutowireCapableBeanFactory</code>：定义了将容器中的 <code>Bean</code>按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li><li><code>SingletonBeanRegistry</code>：定义了允许在运行期间向容器注册单实例 <code>Bean</code> 的方法；</li></ul><p>⭐⭐⭐其中，我们最关心的是<code>BeanDefinition</code>、<code>BeanDefinitionRegistry</code>、<br><code>BeanFactory</code>。注意，<code>BeanDefinition</code>,它完成了<code>Bean</code>的生成过程。<code>BeanDefinitionRegistry</code>是将定义好的<code>bean</code>，注册到容器中。<code>BeanFactory</code> 是一个<code>bean</code>工厂类，从容器中可以取到任意定义过的<code>bean</code>。</p><p><code>Bean</code>的生成大致可以分为两个阶段：容器启动阶段和<code>bean</code>实例化阶段：</p><p><img src="http://bloghello.oursnail.cn/spring2-6.png" alt="image"></p><p>它是面向<code>spring</code>管理<code>bean</code>的最核心的一个接口，但是作为使用者，我们往往更关心的是<code>ApplicationContext</code>.</p><h5>2.2 ApplicationContext</h5><p><code>ApplicationContext</code> 由 <code>BeanFactory</code> 派生而来，提供了更多面向实际应用的功能。</p><p>在<code>BeanFactory</code> 中，很多功能需要以编程的方式实现，而在 <code>ApplicationContext</code> 中则可以通过配置的方式实现。</p><p><img src="http://bloghello.oursnail.cn/spring2-4.png" alt="image"></p><p><code>ApplicationContext</code> 继承了 <code>HierarchicalBeanFactory</code> 和 <code>ListableBeanFactory</code> 接口，在此基础上，还通过多个其他的接口扩展了 <code>BeanFactory</code> 的功能：</p><ul><li><code>ClassPathXmlApplicationContext</code>：默认从类路径加载配置文件</li><li><code>FileSystemXmlApplicationContext</code>：默认从文件系统中装载配置文件</li><li><code>ApplicationEventPublisher</code>：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了 <code>ApplicationListener</code> 事件监听接口的 <code>Bean</code> 可以接收到容器事件 ， 并对事件进行响应处理 。 在 <code>ApplicationContext</code> 抽象实现类<code>AbstractApplicationContext</code> 中，我们可以发现存在一个 <code>ApplicationEventMulticaster</code>，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。</li><li><code>MessageSource</code>：为应用提供 i18n 国际化消息访问的功能；</li><li><code>ResourcePatternResolver</code> ： 加载资源文件</li><li><code>LifeCycle</code>：该接口是 <code>Spring 2.0</code> 加入的，该接口提供了 <code>start()</code>和 <code>stop()</code>两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 <code>ApplicationContext</code> 实现及具体 <code>Bean</code> 实现， <code>ApplicationContext</code> 会将 <code>start/stop</code> 的信息传递给容器中所有实现了该接口的 <code>Bean</code>，以达到管理和控制 <code>JMX</code>、任务调度等目的。</li><li><code>ConfigurableApplicationContext</code> 扩展于 <code>ApplicationContext</code>，它新增加了两个主要的方法： <code>refresh()</code>和 <code>close()</code>，让 <code>ApplicationContext</code> 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 <code>refresh()</code> 即可启动应用上下文，在已经启动的状态下，调用 <code>refresh()</code>则清除缓存并重新装载配置信息，而调用<code>close()</code>则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。</li></ul><h5>2.3 两者的区别</h5><ul><li><code>BeanFactory</code>是<code>Spring</code>框架的基础设施，面向<code>Spring</code></li><li><code>ApplicationContext</code>面向使用<code>Spring</code>框架的开发者</li></ul><p><code>BeanFactory</code>可以理解为汽车的发动机，<code>ApplicationContext</code>可以理解为比较完整的一辆汽车。</p><h2>三、@ComponentScan自动扫描组件以及扫描规则</h2><p>每次都用<code>@Configure</code>和<code>@Bean</code>着实太麻烦了，有没有什么办法可以自动地装载为<code>Bean</code>呢？答案就是这个自动扫描的注解。下面来看看是如何使用的。</p><p>配置文件中配置包扫描时这样配置的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--包扫描，只要标注了@Controller，@Service，@Repository，@Component，就会被自动扫描到加入到容器中--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.swg&quot;/&gt;</span><br></pre></td></tr></table></figure><p>现在用注解来实现这个功能，只需要加上注解<code>@ComponentScan</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>)<span class="comment">//java8可以写多个@ComponentScan</span></span><br><span class="line"><span class="comment">//java8以前虽然不能写多个，但是也可以实现这个功能，用@ComponentScans配置即可</span></span><br></pre></td></tr></table></figure><p>表示自动扫描<code>com.swg</code>包路径下以及子目录下所有的<code>Bean</code>，装载进容器中。</p><p>上面的扫描路径是扫描所有的，有的时候我们需要排除掉一些扫描路径或者只扫描某个路径，如何做到呢？</p><p>用<code>excludeFilters</code>来排除，里面可以指定排除规则，这里是按照<code>ANNOTATION</code>来排除，排除掉所有<code>@Controller</code>注解的类。<code>classes</code>也是个数组，可以排除很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>,excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么效果就是<code>controller</code>没有了，但是<code>service</code>和<code>dao</code>都在。</p><p>那如果我想只包含<code>controller</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>, includeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)</span><br><span class="line">&#125;,useDefaultFilters = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>注意要<code>useDefaultFilters = false</code>，因为默认为<code>true</code>，就是扫描所有，不设置为<code>false</code>无效。</p><p>关于<code>springboot</code>这里强调一下， 启动方法上的注解中已经默认有了扫描的注解，默认扫描的范围是这个启动类所在的路径及其子路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们已经知道了IOC的基本思想，它用一种倒置的思想帮助我们实现高层建筑需要什么直接引入底层就行，而不需要关心底层的具体实现，因为具体实现已经交给了我们的IOC去实现了。了解了这些之后，光说不练肯定是不行的，下面我们来看看这种依赖倒置到底是如何去用的。首先介绍一下传统的方式，就是spring中经常用的方式。然后再介绍一下springBoot中是什么样子的。其实它们两是差不多的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>IOC基本原理</title>
    <link href="http://yoursite.com/2019/03/02/spring/IOC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/02/spring/IOC基本原理/</id>
    <published>2019-03-02T05:48:29.745Z</published>
    <updated>2019-03-02T05:49:31.060Z</updated>
    
    <content type="html"><![CDATA[<p>学习spring的原理，第一步就是要理解IOC的基本原理，而IOC的重要实现方式是DI，本文了解为什么要有IOC这种思想，它到底帮助我们解决了什么问题，它的优势又是什么。</p><a id="more"></a><h2>依赖倒置原则</h2><p>要了解控制反转( <code>Inversion of Control</code> ), 我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则（<code>Dependency Inversion Principle</code> ）。</p><p>什么是依赖倒置原则？假设我们设计一辆汽车：<font color="red">先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。</font>这里就出现了一个“依赖”关系：<strong>汽车依赖车身，车身依赖底盘，底盘依赖轮子</strong>。</p><p><img src="http://bloghello.oursnail.cn/spring1-1.png" alt="image"></p><p>这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！</p><p>注意，我们这里的轮胎是底层，汽车是高层，在整体高层架构确定的情况下，底层根据客户的需求进行改动是很正常的，但是这种模式改动的话，牵一发而动全身，不仅浪费极大时间，在成千上万的类的情况下，也无法进行逐一改动了。</p><p>我们现在换一种思路。<font color="red">我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。</font>这时候，依赖关系就倒置过来了：<strong>轮子依赖底盘， 底盘依赖车身， 车身依赖汽车</strong>。</p><p><img src="http://bloghello.oursnail.cn/spring1-2.png" alt="image"></p><p>这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。</p><p>这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。</p><p>从软件设计的角度来看，改变轮胎这种类的实现是比较简单的，但是有的人会问：如果我要改汽车样式咋办呢？这不跟上面一样了。注意，汽车是高层建筑，这个东西相当于初期的软件架构，如果到后期要改动这个，将相当于处于架构设计不合理，那么整个项目会出现推倒重来的现象，这不是spring所能解决的事情了。</p><p>控制反转（<code>Inversion of Control</code>） 就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（<code>Dependency Injection</code>）。其实这些概念初次接触都会感到云里雾里的。说穿了，这几种概念的关系大概如下：</p><p><img src="http://bloghello.oursnail.cn/spring1-3.png" alt="image"></p><p>为了理解这几个概念，我们还是用上面汽车的例子。只不过这次换成代码。我们先定义四个<code>Class</code>，车，车身，底盘，轮胎。然后初始化这辆车，最后跑这辆车。代码结构如下：</p><p><img src="http://bloghello.oursnail.cn/spring1-4.png" alt="image"></p><p>这样，就相当于上面第一个例子，上层建筑依赖下层建筑——每一个类的构造函数都直接调用了底层代码的构造函数。假设我们需要改动一下轮胎（<code>Tire</code>）类，把它的尺寸变成动态的，而不是一直都是30。我们需要这样改：</p><p><img src="http://bloghello.oursnail.cn/spring1-5.png" alt="image"></p><p>由于我们修改了轮胎的定义，为了让整个程序正常运行，我们需要做以下改动：</p><p><img src="http://bloghello.oursnail.cn/spring1-6.png" alt="image"></p><p>由此我们可以看到，仅仅是为了修改轮胎的构造函数，这种设计却需要修改整个上层所有类的构造函数！在软件工程中，这样的设计几乎是不可维护的——在实际工程项目中，有的类可能会是几千个类的底层，如果每次修改这个类，我们都要修改所有以它作为依赖的类，那软件的维护成本就太高了。</p><p>所以我们需要进行控制反转（<code>IoC</code>），及上层控制下层，而不是下层控制着上层。我们用依赖注入（<code>Dependency Injection</code>）这种方式来实现控制反转。所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。这里我们用构造方法传递的依赖注入方式重新写车类的定义：</p><p><img src="http://bloghello.oursnail.cn/spring1-7.png" alt="image"></p><p>这里我们再把轮胎尺寸变成动态的，同样为了让整个系统顺利运行，我们需要做如下修改：</p><p><img src="http://bloghello.oursnail.cn/spring1-8.png" alt="image"></p><p>看到没？这里我只需要修改轮胎类就行了，不用修改其他任何上层类。这显然是更容易维护的代码。不仅如此，在实际的工程中，这种设计模式还有利于不同组的协同合作和单元测试：比如开发这四个类的分别是四个不同的组，那么只要定义好了接口，四个不同的组可以同时进行开发而不相互受限制；而对于单元测试，如果我们要写Car类的单元测试，就只需要<code>Mock</code>一下<code>Framework</code>类传入<code>Car</code>就行了，而不用把<code>Framework</code>, <code>Bottom</code> , <code>Tire</code> 全部 <code>new</code> 一遍再来构造 <code>Car</code> 。</p><p>这里我们是采用的构造函数传入的方式进行的依赖注入。其实还有另外两种方法：<code>Setter</code>传递和接口传递。这里就不多讲了，核心思路都是一样的，都是为了实现控制反转。</p><p><img src="http://bloghello.oursnail.cn/spring1-9.png" alt="image"></p><p>看到这里你应该能理解什么控制反转和依赖注入了。那什么是控制反转容器(<code>IoC Container</code>)呢？其实上面的例子中，对车类进行初始化的那段代码发生的地方，就是控制反转容器。</p><p><img src="http://bloghello.oursnail.cn/spring1-10.png" alt="image"></p><p>显然你也应该观察到了，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的<code>new</code>。这里<code>IoC</code>容器就解决了这个问题。这个容器可以自动对你的代码进行初始化，你只需要维护一个<code>Configuration</code>（可以是<code>xml</code>可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码。这是引入<code>IoC Container</code>的第一个好处。</p><p><code>IoC Container</code>的第二个好处是：我们在创建实例的时候不需要了解其中的细节。在上面的例子中，我们自己手动创建一个车<code>instance</code>时候，是从底层往上层<code>new</code>的：</p><p><img src="http://bloghello.oursnail.cn/spring1-11.png" alt="image"></p><p>这个过程中，我们需要了解整个<code>Car</code>/<code>Framework</code>/<code>Bottom</code>/<code>Tire</code>类构造函数是怎么定义的，才能一步一步<code>new</code>注入。而<code>IoC Container</code>在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步<code>new</code>（有点像深度优先遍历）：</p><p><img src="http://bloghello.oursnail.cn/spring1-12.png" alt="image"></p><p>这里<code>IoC Container</code>可以直接隐藏具体的创建实例的细节，在我们来看它就像一个工厂：</p><p><img src="http://bloghello.oursnail.cn/spring1-13.png" alt="image"></p><p>我们就像是工厂的客户。我们只需要向工厂请求一个<code>Car</code>实例，然后它就给我们按照<code>Config</code>创建了一个<code>Car</code>实例。我们完全不用管这个<code>Car</code>实例是怎么一步一步被创建出来。</p><p>实际项目中，有的<code>Service Class</code>可能是十年前写的，有几百个类作为它的底层。假设我们新写的一个<code>API</code>需要实例化这个<code>Service</code>，我们总不可能回头去搞清楚这几百个类的构造函数吧？<code>IoC Container</code>的这个特性就很完美的解决了这类问题——因为这个架构要求你在写<code>class</code>的时候需要写相应的<code>Config</code>文件，所以你要初始化很久以前的<code>Service</code>类的时候，前人都已经写好了<code>Config</code>文件，你直接在需要用的地方注入这个<code>Service</code>就可以了。这大大增加了项目的可维护性且降低了开发难度。</p><p>整理自：<a href="https://www.zhihu.com/question/23277575/answer/169698662" target="_blank" rel="noopener">Sevenvidia的回答</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习spring的原理，第一步就是要理解IOC的基本原理，而IOC的重要实现方式是DI，本文了解为什么要有IOC这种思想，它到底帮助我们解决了什么问题，它的优势又是什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法12-排序总结</title>
    <link href="http://yoursite.com/2019/03/01/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9512-%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/01/algorithms-basic/基础算法12-排序总结/</id>
    <published>2019-03-01T03:10:33.788Z</published>
    <updated>2019-03-01T03:14:33.587Z</updated>
    
    <content type="html"><![CDATA[<p>至此，经典的排序算法的原理全部过了一遍，其中没有说明希尔排序，不过这个并不是重点，我们重点掌握的应该是快排，其次是归并和堆排，最后是插入排序和冒泡排序，在后面就是非比较的排序。本文对它们的特性做一个简单的总结。算法复杂度已经说明，所以不再赘述。</p><a id="more"></a><h2>1.稳定性说明</h2><p>定义：相同的数字排序前后相对位置不变。</p><p><font color="red">1.冒泡排序</font>：<strong>可以做到稳定</strong>，因为冒泡排序的思想是每次将大的数往下沉。如果我们设置每次相等也交换，那么就不是稳定的；反之，我们就可以做到稳定。</p><p><font color="red">2.选择排序</font>：<strong>不可以</strong>，考虑下面这个数组：5，5，5，5，1；那么我们选择一个最小的与第0号元素交换。那么就变成：1，5，5，5，5；此时，第一个5越过后面所有的5跑到了最后面。</p><p><font color="red">3.插入排序</font>：<strong>可以做到稳定</strong>，插入排序的基本思想是前面已经排好序，后面个数与前面已排好序的比较，小于的话就交换。相等的时候是不需要交换的。</p><p><font color="red">4.归并排序</font>：<strong>可以做到稳定</strong>，因为主要思想是分治，在merge的时候，两边数组进行比较，凑成一个排序的数组。那么我们只要设置：相等的时候，一直先考虑左边(或者右边)就可以。</p><p><font color="red">5.快速排序</font>：<strong>一般不可以</strong>，这个就很明显了，我们以三路快排为例，partition的过程中，随机选择一个数，每次形成的数组是&lt;x =x &gt;x这三种，显然中间的x就会打乱顺序。</p><p><font color="red">6.堆排序</font>：<strong>很显然不可以</strong>。因为每次的建堆过程中，即heapInsert过程中，由于新加入的大的值要上浮，那么就可以调换其中的顺序。比如 6 4 4，此时插入一个5建堆，那么显然第一个4要跟5交换，那么第一个4就跑到了第二个4的后面。</p><h2>2.工程中的综合算法</h2><p>如果是很长的基本类型数组，考虑快排；如果是很长的自定义类型的数组，考虑归并排序；如果数组很短(&lt;60)，考虑插入排序，因为常数项小。</p><p>因为基本类型相等的是没有差异的，不需要注意原始顺序，所以直接用快排；</p><p>但是自定义类型的个体是有差异的，需要对自定义类型中的属性进行判断，关系到顺序。</p><h2>3.排序问题的补充</h2><ol><li>归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握。</li><li>快速排序可以做到稳定性问题，但是非常难，不需要掌握。</li><li>面试中碰到一个问题：奇数放在数组左边，偶数放在数组右边，<strong>还要求原始的相对次序是不变的</strong>。空间复杂度为O(1)，时间复杂度为O(N).</li></ol><p>针对这个问题，其实是很难的，因为一个数不是奇数就是偶数，属于01问题，那么就跟快排的partition过程是类似的，就是小于等于某个数放左边，大于某个数放右边，那么也是01问题，就是说，荷兰国旗问题是做不到稳定的。但是快速排序做到稳定性是很难的，所以这道题目其实是比较难做到的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;至此，经典的排序算法的原理全部过了一遍，其中没有说明希尔排序，不过这个并不是重点，我们重点掌握的应该是快排，其次是归并和堆排，最后是插入排序和冒泡排序，在后面就是非比较的排序。本文对它们的特性做一个简单的总结。算法复杂度已经说明，所以不再赘述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法11-排序之计数排序、桶排序、基数排序</title>
    <link href="http://yoursite.com/2019/03/01/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9511-%E6%8E%92%E5%BA%8F%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/03/01/algorithms-basic/基础算法11-排序之计数排序、桶排序、基数排序/</id>
    <published>2019-03-01T02:46:21.477Z</published>
    <updated>2019-03-01T02:46:53.329Z</updated>
    
    <content type="html"><![CDATA[<p>在之前我们介绍的都是比较排序算法，在结果中各元素的次序都基于输入元素间的比较。而任何比较排序算法在最坏情况下都要用 O(NlgN) 此比较来排序。而非基于比较的排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。</p><a id="more"></a><h2>计数排序</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><p><img src="http://bloghello.oursnail.cn/suanfa11-1.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//maxVal为传入的数组的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array,<span class="keyword">int</span> maxVal)&#123;</span><br><span class="line">    <span class="comment">// 1.根据最大值可以确定辅助数组的长度</span></span><br><span class="line">    <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[maxVal+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//2.遍历array数组，统计每个元素出现的次数，记录在辅助数组对应索引处</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        helper[array[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.遍历辅助数组，覆盖原数组</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxVal+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (helper[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            array[index++] = i;</span><br><span class="line">            helper[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (<code>Bucket sort</code>)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序.</p><ul><li>找出待排序数组中的最大值<code>max</code>、最小值<code>min</code></li><li>我们使用动态数组 <code>ArrayList</code> 作为桶，桶里放的元素也用 <code>ArrayList</code> 存储。桶的数量为<code>(max-min)/arr.length+1</code></li><li>遍历数组 <code>arr</code>，计算每个元素 <code>arr[i]</code> 放的桶</li><li>每个桶各自排序</li><li>遍历桶数组，把排序好的元素放进输出数组</li></ul><p><img src="http://bloghello.oursnail.cn/suanfa11-2.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="comment">//1.确定出数组的最大值和最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        max = Math.max(arr[i],max);</span><br><span class="line">        min = Math.min(arr[i],min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据最大值和最小值确定桶的数量，并且初始化每个桶</span></span><br><span class="line">    <span class="keyword">int</span> buctetSize = (max-min)%arr.length + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> ArrayList&lt;&gt;(buctetSize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        bucket.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.类似于hashmap，将其元素放到对应下标的桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (arr[i] - min)%buctetSize;</span><br><span class="line">        bucket.get(num).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对每个桶中的元素都要进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        Collections.sort(bucket.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(bucket.toString());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.遍历所有的桶，类似于计数排序一样覆盖原数组得到有序的序列</span></span><br><span class="line">    <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buctetSize;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = bucket.get(i).size();</span><br><span class="line">        <span class="keyword">while</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[arrIndex++] = bucket.get(i).get(index++);</span><br><span class="line">            sum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>基数排序</h2><p>基数排序(<code>Radix Sort</code>)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。</p><p>通过基数排序对数组{53, 3, 542, 748, 14, 214, 154, 63, 616}，它的示意图如下：</p><p><img src="http://bloghello.oursnail.cn/suanfa11-3.jpg" alt="image"></p><p>在上图中，首先将所有待比较数值统一为统一位数长度，接着从最低位开始，依次进行排序。</p><ul><li>按照个位数进行排序。</li><li>按照十位数进行排序。</li><li>按照百位数进行排序。<br>排序后，数列就变成了一个有序序列。</li></ul><p>在理解了基本的思想之后，下面以一个简单的例子辅助理解程序思想。</p><p>首先我们有以下这个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrays = &#123;<span class="number">6</span>,  <span class="number">4322</span>, <span class="number">432</span>, <span class="number">344</span>, <span class="number">55</span> &#125;;</span><br></pre></td></tr></table></figure><p>现在我们有10个桶子，每个桶子下能装载arrays.length个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length][<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://bloghello.oursnail.cn/suanfa11-4.jpg" alt="image"></p><p>第一趟分配与回收:将数组的每个个位数进行分配到不同的桶子上</p><p><img src="http://bloghello.oursnail.cn/suanfa11-5.jpg" alt="image"></p><p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{4322,432,344,55,6}</p><p>第二趟分配与回收:将数组的每个十位数进行分配到不同的桶子上(像6这样的数，往前边补0)</p><p><img src="http://bloghello.oursnail.cn/suanfa11-6.jpg" alt="image"></p><p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,4322,432,344,55}</p><p>第三趟分配与回收:将数组的每个百位数进行分配到不同的桶子上(像6、55这样的数，往前边补0)</p><p><img src="http://bloghello.oursnail.cn/suanfa11-7.jpg" alt="image"></p><p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,55,4322,344,432}</p><p>第四趟分配与回收:将数组的每个百位数进行分配到不同的桶子上(像6、55，344，432这样的数，往前边补0)</p><p><img src="http://bloghello.oursnail.cn/suanfa11-8.jpg" alt="image"></p><p>分配完之后，我们按照顺序来进行回收：得到的结果应该是这样子的：{6,55,344,432,4322}</p><p>理解了上面，代码也就非常容易理解了：</p><p>获取这个数组的最大值，这里用递归来实现一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = arr[L];</span><br><span class="line">    <span class="keyword">int</span> b = getMax(arr,L+<span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基数排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">//求得数组最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = getMax(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大数的位数就是我们要分配的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; max / i &gt; <span class="number">0</span> ; i *= <span class="number">10</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//构造arr.length行，10列的二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//求数组每个位，如个位，十位等，根据该位的数字放到对应的二维数组里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[j]/i)%<span class="number">10</span>;</span><br><span class="line">            buckets[j][num] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一次放完之后，就要回收起来放进原来的数组中，等待下一次的重新分配</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(buckets[j][k] != <span class="number">0</span>)&#123;</span><br><span class="line">                    arr[index++] = buckets[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基数排序要理解起来并不困难，不过值得注意的是：基数排序对有负数和0的数列难以进行排序</p><ul><li>因此，往往有0和负数的数组一般我们都不用基数来进行排序</li></ul><p>基数排序的要点就两个：</p><ul><li>分配：按照元素的大小来放入不同的桶子里</li><li>回收：将桶子里的元素按桶子顺序重新放到数组中</li><li>重复…两个步骤</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前我们介绍的都是比较排序算法，在结果中各元素的次序都基于输入元素间的比较。而任何比较排序算法在最坏情况下都要用 O(NlgN) 此比较来排序。而非基于比较的排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内)。但并非因为有条件限制就会使非基于比较的排序算法变得无用，对于特定场合有着特殊的性质数据，非基于比较的排序算法则能够非常巧妙地解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法10-堆排序</title>
    <link href="http://yoursite.com/2019/02/28/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9510-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/28/algorithms-basic/基础算法10-堆排序/</id>
    <published>2019-02-28T07:16:36.247Z</published>
    <updated>2019-02-28T08:30:11.174Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序的重要性在于它涉及到二叉堆这个数据结构，面试中曾经被问过堆这个数据结构，那么堆其实是一个完全二叉树，它里面含有好几种类型的堆，其中我们比较关注的是二叉堆，它分为大顶堆和小顶堆，是非常常用的一种数据结构。所以我觉得面试中问到堆这个数据结构的时候可以往二叉堆上进行靠拢，然后回答问题。</p><a id="more"></a><h2>1. 前言</h2><p>在学习堆排序之前，有必要把一些数据结构方面的知识理一下，要不然会有点乱。</p><p>首先看一下一个大的分类：</p><p><img src="http://bloghello.oursnail.cn/suanfa10-1.png" alt="image"></p><p>因此堆是一种特殊的树，并且是特殊的完全二叉树。对于堆排序中的堆通常是指二叉堆。二叉堆分为大根堆和小根堆。其中每个节点的值小于等于其左、右孩子的值，这样的堆称为小根堆；其中每个节点的值大于等于其左、右孩子的值，这样的堆称为大根堆；这里注意二叉堆和二叉搜索树的区别。</p><p>那么理清这个关系之后，我们知道了，我们主要的研究对象是二叉堆这个数据结构。</p><h2>2. 二叉堆的结构</h2><p>回顾一下完全二叉树的定义。</p><blockquote><p>如下图，每一层都是从左向右摆放节点，每个节点都是摆满两个子节点后才向右移动到下一个节点，一层摆满后向下移动一层，直到摆放完所有数字。这样得到的二叉树就是完全二叉树，中间有任何缺失的节点就不能称为完全二叉树。</p></blockquote><p><img src="http://bloghello.oursnail.cn/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89%E5%9B%BE.png" alt="image"></p><p>二叉堆是一种完全二叉树，他们的区别是：</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%8F%89%E5%A0%86%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉堆与完全二叉树"></p><p>二叉堆是一颗完全二叉树，完全二叉树有一个非常重要的性质：即完全二叉树只用数组而不需要指针就可以表示。优势在于数组表示的话内存是紧凑排列的，不会有太多的内存碎片，并且数组对于随机访问是很快的，基于数组下标即可。</p><p><img src="http://bloghello.oursnail.cn/%E5%A0%86%E7%94%A8%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA.png" alt="堆用数组表示"></p><h2>3. 二叉堆与优先队列</h2><p>什么是优先队列，队列我们是比较熟悉的，是一种先进先出的数据结构，在优先队列中，出队的顺序与入队的顺序无关了，而是与优先级有关。即优先级越高，越早出队。</p><p>优先队列到底有什么实际应用呢？比如一个电商网站搞特卖或抢购，用户登录下单提交后，考虑这个时间段用户访问下单提交量很大，通常表单提交到服务器后端后，后端程序一般不直接进行扣库存处理，将请求放到队列列，异步消费处理，用普通队列是FIFO的，这里有个需求是，用户会员级别高的，可以优先抢购到商品，可能这个时间段的级别较高的会员用户下单时间在普通用户之后，这个时候使用优先队列代替普通队列，基本能满足我们的需求。</p><p>优先队列就是依靠二叉堆来实现的。优先队列需要支持两种操作：</p><ul><li>删除最小（最大）元素</li><li>插入元素</li></ul><p>为什么要用堆来实现优先队列？</p><ul><li>优先队列所需要实现的两种操作，不同于队列和栈，它需要一个有序的元素序列，但不要求全部有序，只需要从这些元素中找到最大（或最小）的一个元素。而堆刚好满足这个条件。</li><li>队列，栈都是用数组或者链表来实现的，针对优先队列，用数组和链表实现也是可以的，在队列较小，大量使用两种操作之一时，或者所操作的元素的顺序已知时，用数组和链表十分有用，但是，在最坏的情况下，优先队列用这两张方法实现所需的时间却是线性的。而用堆在最坏情况下的时间则是对数级别。</li></ul><p>由于我们比较关注的是立即拿到最大或者最小的元素，然后高效地删除和插入。这些都依赖于堆的内部算法实现，下面我们就来看看大顶堆为例的插入和删除操作原理。</p><h3>4. 堆的算法</h3><p>我们用N+1长度的数组来表示一个大小为N的堆，我们不会使用[0],堆元素会被保存于[1]-[N-1]中。</p><h5>4.1 大顶堆的插入(上浮)</h5><p><img src="http://bloghello.oursnail.cn/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * k:当前插入元素的位置，相应地k/2就是其父结点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(k&gt;<span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">swap(k/<span class="number">2</span>,k);</span><br><span class="line">k = k/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>4.2 大顶堆的删除</h5><p><img src="http://bloghello.oursnail.cn/%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">1. 获取根结点</span><br><span class="line">2. 将根结点与最后一个结点交换</span><br><span class="line">3. 恢复堆的有序性...</span><br></pre></td></tr></table></figure><blockquote><p>显然现在看来该二叉树虽然是一个完全二叉树，但是它并不符合最大堆的相关定义，我们的目的是要在删除完成之后，该完全二叉树依然是最大堆。因此就需要我们来做一些相关的操作！</p></blockquote><p><img src="http://bloghello.oursnail.cn/%E4%B8%8B%E6%B2%89%E5%9B%9E%E5%A4%8D%E5%A0%86%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * k:当前被删除元素的位置(若删除根节点,则k=1)，相应地2*k就是其左子结点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">2</span>*k &lt; N)&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line"><span class="keyword">if</span>(j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>))</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span>(!less(k,j))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">swap(k,j);</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>5. 堆排</h2><p>在了解了堆的基本操作之后，我们将目标先转到堆排序上，这才是本章研究的重点。</p><p>时间复杂度为<code>O(logN)</code>，额外空间复杂度为<code>O(1)</code>;</p><p>我们知道，数组可以对应到一个完全二叉树。</p><p>堆:大根堆和小根堆。堆就是一个完全二叉树。</p><p>大根堆：完全二叉树中任何一个子树的最大值就是其头部节点对应的值。</p><p>那么，数组已经是一个完全二叉树，而下面的任务就是：将一个数组变成大根堆。</p><p>构建一个大根堆的复杂度是log1+log2+…+logi = O(N)</p><p>第一次构建完大根堆之后，还不是有序的。堆排序的主要思路是：每次将最后一个数与第一个数交换，就是完全二叉树的最后一个数与根节点进行交换。由于根节点已经是最大的数，所以我们就可以不要再管它。我们再将0~n-1下标的所有数进行调整，也调整为大顶堆，然后重复上面的动作。这样，不停地把当前大顶堆的最大数调整到后面，一直到最后，整个数组就是有序的。</p><p><img src="http://bloghello.oursnail.cn/suanfa10-2.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            System.out.print(anArr + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一次调整为大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            heapInsert(arr,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">        <span class="comment">//第一个数与最后一个数交换，最后一个数就是最大的值，前面的数再调整为新的大顶堆</span></span><br><span class="line">        <span class="comment">//这样每次都将当前最大的数从数组的后面依次往前排，排到最后整个数组升序</span></span><br><span class="line">        swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">        <span class="keyword">while</span>(heapSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            heapify(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">            swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前的值是大于父节点的，就与父节点交换，使得大的数上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[index] &gt; arr[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">            swap(arr,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次将最后一个数与第一个数交换后，我们要重新构建大顶堆，主要是将当前第一个数与自己的子节点进行比较，如果小于当前的子节点，则交换；否则不变，已经是大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">        <span class="comment">//拿到当前节点的左子节点</span></span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左子节点下标不能越界</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">            <span class="comment">//在右子节点也不越界的情况下，选出左右子节点中的较大者</span></span><br><span class="line">            <span class="keyword">int</span> largest = left+<span class="number">1</span> &lt; heapSize &amp;&amp; arr[left+<span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">//当前节点与左右子节点的最大者再比较</span></span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            <span class="comment">//如果最大值就是当前节点，说明当前节点的值是大于左右两个子节点的，不需要交换，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(largest == index)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个时候说明当前节点是小于某一个子节点的，那么就要进行交换，并且更新当前节点的坐标为子节点的而坐标，再更新左子节点，做下一次循环的比较</span></span><br><span class="line">            swap(arr,largest,index);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆这个数据结构是非常重要的，因为他的动态调整的时间复杂度为logN，是非常低的。比如经典问题：快速在一串数字流中快速找到中位数等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序的重要性在于它涉及到二叉堆这个数据结构，面试中曾经被问过堆这个数据结构，那么堆其实是一个完全二叉树，它里面含有好几种类型的堆，其中我们比较关注的是二叉堆，它分为大顶堆和小顶堆，是非常常用的一种数据结构。所以我觉得面试中问到堆这个数据结构的时候可以往二叉堆上进行靠拢，然后回答问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法9-快速排序</title>
    <link href="http://yoursite.com/2019/02/28/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%959-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/28/algorithms-basic/基础算法9-快速排序/</id>
    <published>2019-02-28T05:25:30.182Z</published>
    <updated>2019-02-28T05:30:59.277Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了归并排序，本文介绍快速排序，顾名思义，应该是综合性能最好的排序了。在具体实现上，往上也有很多的版本，虽然大体思想一致，但是我觉得掌握其中一种最实用的方式就够了，本文的快排思想基于荷兰国旗问题演变，即所谓的三路快排，对于重复元素较多的场景是非常适合的，对于普通场景来说，性能也不弱。</p><a id="more"></a><h2>1. 荷兰国旗问题</h2><p>在研究快速排序之前，我们先来研究一下一个经典问题：荷兰国旗问题，我们的目标是给出一个num，将原来的数组中的值按照下面的规则进行排列：比num小的全放到num的左边，比bum大的全部放在右边，中间全是等于num的值。类似于荷兰国旗的三色旗。</p><p><img src="http://bloghello.oursnail.cn/suanfa9-1.gif" alt="image"><img src="http://bloghello.oursnail.cn/suanfa9-2.gif" alt="image"></p><p>具体的算法思想看代码注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 荷兰国旗问题</span></span><br><span class="line"><span class="comment"> * 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，</span></span><br><span class="line"><span class="comment"> * 等于num的数放在数组的中间，大于num的数放在数组的右边。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helan_flag_question_solve</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        solve(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要思想是：初始化的坐标分别为-1和N，就是取超出数组的范围，当前坐标是从0开始</span></span><br><span class="line"><span class="comment">     * 分为三种情况：如果当前等于num，那么指针后移一格即可</span></span><br><span class="line"><span class="comment">     * 如果当前小于num，那么就将当前和less+1交换位置，并且当前指针后移一格</span></span><br><span class="line"><span class="comment">     * 如果当前大于num，那么就将当前和more-1交换位置，当前位置不变继续判断、</span></span><br><span class="line"><span class="comment">     * 为什么与前面交换当前指针就要后移一格，但是与后面交换不用后移呢？</span></span><br><span class="line"><span class="comment">     * 我们知道，curr扫过的地方，curr当前指向的和前面的数肯定都是小于num的了，所以需要后移一个判断下一个元素</span></span><br><span class="line"><span class="comment">     * 但是从后面交换过来的，我们不知道这个交换过来的元素比num小还是大，所以对这个元素还需要判断一下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = L-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = L;</span><br><span class="line">        <span class="keyword">while</span>(curr &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[curr] &lt; num)&#123;</span><br><span class="line">                swap(arr,++less,curr++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[curr] &gt; num)&#123;</span><br><span class="line">                swap(arr,--more,curr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目一定一定要注意边界问题。下面的快排其实就是对荷兰国旗问题的递归操作。因此要想理解快排，需要先掌握荷兰国旗问题。</p><h2>2. 快排</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（<code>pivot</code>）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（<code>partition</code>）操作；</li><li>递归地（<code>recursive</code>）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><p><img src="http://bloghello.oursnail.cn/suanfa9-3.gif" alt="image"></p><p>时间复杂度为O(N*logN),额外空间复杂度O(logN);</p><p>因为要记录划分区域的边界，所以需要一定的空间。这里划分的空间与二分的次数有关，所以需要O(logN)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">            System.out.print(anArr + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要思想是根据荷兰国旗的思想，首先揪出一个数，分成三块。然后分别对左右两块递归进行同样地分法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &lt; R)&#123;</span><br><span class="line">            <span class="comment">//swap(arr,L+(int)(Math.random()*(R-L+1)),R);</span></span><br><span class="line">            <span class="keyword">int</span>[] p = partition(arr,L,R);</span><br><span class="line">            quickSort(arr,L,p[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">            quickSort(arr,p[<span class="number">0</span>]+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的是中间相等的这一串数的左右边界值，所以数组长度固定为2</span></span><br><span class="line"><span class="comment">//选择比较的基准数是数组的最左元素，即arr[L],这样每次都将等于arr[L]的数排到它们应该在的位置上，并且返回等于arr[L]的数的最左坐标less+1和最右坐标more</span></span><br><span class="line"><span class="comment">//下次，就可以从L到less进行相同操作以及more+1和R进行相同操作</span></span><br><span class="line"><span class="comment">//最终，每个元素都来到属于自己的位置上，排序成功</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[L] &lt; arr[R])&#123;</span><br><span class="line">                swap(arr,++less,L++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[L] &gt; arr[R])&#123;</span><br><span class="line">                swap(arr,--more,L);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,more,R);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快排存在的一个问题是：可能划分出来两边数组很偏，排序效率就会变差。可以用随机快排进行改进。</p><p>思路：随机选一个数与数组最后一个数交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(arr,L+(int)(Math.random()*(R-L+1)),R);</span><br></pre></td></tr></table></figure><p>相比于经典快排，这个优化的快排的优点在于：每一次partition之后，就可能会揪出一串的相等数字，然后左边全是小于这个数，右边都是大于这个数。而经典快排每次只找出一个数字来，左边是小于等于这个数，右边是大于这个数。很显然，优化后的快排要快一点。</p><p>这种从荷兰国旗演变过来的快排，对于重复元素较多的时候是非常有利的，因此这种是我比较喜欢的一种写法，这也意味着快排的实现上有一些差异，但是主要的思想是一致的，即分治处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了归并排序，本文介绍快速排序，顾名思义，应该是综合性能最好的排序了。在具体实现上，往上也有很多的版本，虽然大体思想一致，但是我觉得掌握其中一种最实用的方式就够了，本文的快排思想基于荷兰国旗问题演变，即所谓的三路快排，对于重复元素较多的场景是非常适合的，对于普通场景来说，性能也不弱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法8-归并排序</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%958-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法8-归并排序/</id>
    <published>2019-02-27T11:39:19.969Z</published>
    <updated>2019-02-27T11:46:44.159Z</updated>
    
    <content type="html"><![CDATA[<p>从本文开始就要介绍O(nlogn)复杂度级别的排序算法了，首先登场的是归并排序，这个排序可以解决一些问题，会在文章的后面给出，并且是一个经典的分治思想，即先分隔再合并，将复杂的大问题瓦解为小问题，将若干小问题解决了之后大问题也就迎刃而解了。下面我们来学习一下归并排序的基本原理。</p><a id="more"></a><h2>1. 原理</h2><p>归并排序（<code>MERGE-SORT</code>）是利用归并的思想实现的排序方法，该算法采用经典的分治（<code>divide-and-conquer</code>）策略（分治法将问题分(<code>divide</code>)成一些小的问题然后递归求解，而治(<code>conquer</code>)的阶段则将分的阶段得到的各答案&quot;修补&quot;在一起，即分而治之)。</p><p>复杂度为(<code>nlogN</code>),这里采用自顶向下和递归来完成的。</p><p><img src="http://bloghello.oursnail.cn/suanfa8-1.png" alt="image"></p><p>归并排序的原理是，先把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p>归并的前提是先把要排序的序列分为若干个字序列，然后才归并。在拆分数列的时候，就要用到拆分，直到不能再拆为止。</p><blockquote><p>如一个数列{9,8,7,6,5,4,3,2,1}</p><p>先分成{9,8,7,6,5}和{4,3,2,1}</p><p>然后再分成{9,8,7}和{6,5}和{4,3}和{2,1}</p><p>然后再分{9,8}、{6}、{5}、{4}、{3}、{2}、{1}</p><p>然后再合并起来，小在的前面，大的在后面，没有比较的在后面填充数列。</p></blockquote><p>具体如何合并的呢？下面展示的最后的一步合并过程：</p><p><img src="http://bloghello.oursnail.cn/suanfa8-2.png" alt="image"></p><p>我们注意到，归并排序是需要额外的空间来辅助的。动态图为：</p><p><img src="http://bloghello.oursnail.cn/suanfa7-4.gif" alt="image"></p><h2>2. 代码</h2><h5>2.1 左右分开</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int mid = (low + high) / 2;</span></span><br><span class="line"><span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">    sort(a, low, mid);</span><br><span class="line">        <span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">    sort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>2.2 合并过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//临时指针</span></span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">        a[k2 + low] = temp[k2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于它的理解，一句话就是先对半分，分到不能分为止，然后再倒过来将卡擦分开的两组数进行比较合并成有序序列，最终逐渐合并成有序序列。</p><h2>3. 归并排序应用1–小和问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序的应用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  例子：</span></span><br><span class="line"><span class="comment"> *  [1,3,4,2,5]</span></span><br><span class="line"><span class="comment"> *  1左边比1小的数，没有；</span></span><br><span class="line"><span class="comment"> *  3左边比3小的数，1；</span></span><br><span class="line"><span class="comment"> *  4左边比4小的数，1、3；</span></span><br><span class="line"><span class="comment"> *  2左边比2小的数，1；</span></span><br><span class="line"><span class="comment"> *  5左边比5小的数，1、3、4、2；</span></span><br><span class="line"><span class="comment"> *  所以小和为1+1+3+1+1+3+4+2=16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortApply1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(merge_sort(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,low,mid) +</span><br><span class="line">                sortProcess(arr,mid+<span class="number">1</span>,high) +</span><br><span class="line">                  merge(arr,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= high)&#123;</span><br><span class="line">            <span class="comment">//核心的是增加这一句，当发现arr[p1] &lt; arr[p2]时</span></span><br><span class="line">            <span class="comment">//那么p2后面的数必然都大于它，所以这一次合并过程中</span></span><br><span class="line">            <span class="comment">//p1位置比(high-p2+1)这些位置都小，那么针对这个p1位置的数字，一次性全部累计起来即可</span></span><br><span class="line">            count += arr[p1] &lt; arr[p2] ? (high-p2+<span class="number">1</span>)*arr[p1] : <span class="number">0</span>;</span><br><span class="line">            help[k++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">            help[k++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= high)&#123;</span><br><span class="line">            help[k++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;help.length;ii++)&#123;</span><br><span class="line">            arr[ii+low] = help[ii];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>4. 归并排序应用2–逆序对问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序的应用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对的数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortApply2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(merge_sort(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,low,mid) +</span><br><span class="line">                sortProcess(arr,mid+<span class="number">1</span>,high) +</span><br><span class="line">                  merge(arr,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= high)&#123;</span><br><span class="line">            <span class="comment">//归并的过程中发现前面大于后面的话就算一组</span></span><br><span class="line">            count += arr[p1] &gt; arr[p2] ? (high-p2+<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            help[k++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">            help[k++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= high)&#123;</span><br><span class="line">            help[k++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;help.length;ii++)&#123;</span><br><span class="line">            arr[ii+low] = help[ii];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本文开始就要介绍O(nlogn)复杂度级别的排序算法了，首先登场的是归并排序，这个排序可以解决一些问题，会在文章的后面给出，并且是一个经典的分治思想，即先分隔再合并，将复杂的大问题瓦解为小问题，将若干小问题解决了之后大问题也就迎刃而解了。下面我们来学习一下归并排序的基本原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法7-基本排序之冒泡、选择、插入</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%957-%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法7-基本排序之冒泡、选择、插入/</id>
    <published>2019-02-27T08:45:32.009Z</published>
    <updated>2019-02-27T08:45:53.912Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法毋庸置疑，是最重要最重要的基础算法，真正的实际应用中，往往是几种排序算法的组合，因为没有完美的算法，只有适合的算法。学好算法的第一步应该是熟练手写出基本的排序算法，本文应该被放在一篇文章，但是命运的巧合，我还是选择了递归。因为排序算法就摆在那，思想比较清晰，理解上没有难度，但是递归也摆在那，好像简单但是又无从下手。本文先从复杂度比较高但是比较简单的几种排序算法入手。这几种都是O(n^2)的时间复杂度。</p><a id="more"></a><h2>1. 冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>算法的基本步骤：</p><ul><li>比较相邻的元素。如果第一个比第二个大(注意相等不要交换，所谓冒泡是稳定的排序)，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p>动态图：</p><p><img src="http://bloghello.oursnail.cn/suanfa7-1.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 冒泡排序整体思路：每一趟的比较，都会将最大的一个数排到最后面</span></span><br><span class="line"><span class="comment">         * 0。。。。。。。n-1   第一趟一直比较到最后一个，把最大的放到对后面</span></span><br><span class="line"><span class="comment">         * 0。。。。。n-2   第二趟比较的数组长度会减少一个，因为最大的已经确定了</span></span><br><span class="line"><span class="comment">         * 0。。。。n-3    第三趟比较的就再少两个，因为两个最大的已经确定了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//两两比较交换</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>2. 选择排序</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：不断地在未排序序列中找到最小元素，交换到数组的最前面。</p><p><img src="http://bloghello.oursnail.cn/suanfa7-2.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 基本思想是：每一趟都将最小值的索引确定好，然后放到前</span></span><br><span class="line"><span class="comment">         * 所以每一趟结束之后，前面是已经排好序的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,min,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>3. 插入排序</h2><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><img src="http://bloghello.oursnail.cn/suanfa7-3.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        insert_sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 插入排序主要思想是：每一趟都保证当前索引前的所有元素都小于当前索引</span></span><br><span class="line"><span class="comment">         * 比如【5,4,3,2,1】，那么第一趟是【4,5,3,2,1】，第二趟是【3,4,5,2,1】</span></span><br><span class="line"><span class="comment">         * 第三趟是【2,3,4,5,1】，第四趟是【1,2,3,4,5】</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 其实这是优化后的方法，简单的插入排序是这样子的：</span></span><br><span class="line"><span class="comment">         *    for(int i=1;i&lt;arr.length;i++)&#123;</span></span><br><span class="line"><span class="comment">         *        for(int j=i; j&gt;0 &amp;&amp; array[j-1]&gt;array[j]; j--)&#123;</span></span><br><span class="line"><span class="comment">         *           swap(array, j, j-1);</span></span><br><span class="line"><span class="comment">         *        &#125;</span></span><br><span class="line"><span class="comment">         *    &#125;</span></span><br><span class="line"><span class="comment">         * 这里的优化是考虑到原始方法要不断地进行交换，其实是没有必要的，直接赋值就好了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>] &gt; tmp ;j--)&#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法毋庸置疑，是最重要最重要的基础算法，真正的实际应用中，往往是几种排序算法的组合，因为没有完美的算法，只有适合的算法。学好算法的第一步应该是熟练手写出基本的排序算法，本文应该被放在一篇文章，但是命运的巧合，我还是选择了递归。因为排序算法就摆在那，思想比较清晰，理解上没有难度，但是递归也摆在那，好像简单但是又无从下手。本文先从复杂度比较高但是比较简单的几种排序算法入手。这几种都是O(n^2)的时间复杂度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法6-关于二叉树的经典面试题分析</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%956-%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法6-关于二叉树的经典面试题分析/</id>
    <published>2019-02-27T06:45:13.480Z</published>
    <updated>2019-02-27T06:45:39.240Z</updated>
    
    <content type="html"><![CDATA[<p>掌握对树的基本操作是很重要的，这里所谓的操作是指对树的遍历，以及对树的构造等等。下面通过一些题目来好好研究研究。由于篇幅、时间以及精力有限，本文着重提取两种题型进行分析，都是高频面试问题。</p><a id="more"></a><h2>问题1</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-1.png" alt="image"></p><p>这是一道比较常见的题目，虽然难度是<code>medium</code>，但是也没有那么难，这个题目主要是要求我们根据前序遍历和中序遍历构造出整棵树。</p><p>基本的思路是：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-2.png" alt="image"></p><p>也就是说，前序遍历的第一个元素必然是整棵树的头节点，那么我在中序遍历找到头节点的位置后，就可以根据中序遍历的特点，前面的都是左子树，后面的都是右子树。找到了这一个，下面就让计算机递归去找，所以问题的关键就是第一步的缩小范围。无需关心构造树的细节。</p><p>我的解题方案是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//6.递归的停止条件，最后考虑，先考虑下面的一般情况</span></span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.根据前序遍历的结果，第一个元素就是树的root</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.根据root的值去inorder中去找，题目规定这个序列是没有重复元素的</span></span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.找到了之后，我们就可以确定root的左子树和右子树的所有元素了</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.下面就交给计算机了，我们只要考虑第一次的缩小规模，即root的左子树是什么范围，递归下去，相信它一定可以给我们一个正确的root的左子树</span></span><br><span class="line">        <span class="comment">//这个范围的确定也是很简单的，根据前序遍历和中序遍历的关系就可以获得</span></span><br><span class="line">        <span class="comment">//不过额外需要注意的是Arrays.copyOfRange是一个[)的结果集，需要注意以下边界</span></span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,<span class="number">1</span>+rootIndex),Arrays.copyOfRange(inorder,<span class="number">0</span>,rootIndex));</span><br><span class="line">        <span class="comment">//递归下去，相信它一定可以给我们一个正确的root的右子树</span></span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>+rootIndex,preorder.length),Arrays.copyOfRange(inorder,rootIndex+<span class="number">1</span>,inorder.length));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.返回root，构造完毕</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题2</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-3.png" alt="image"></p><p>根据前序和后序构建的二叉树不唯一，理由是前序与后序都没有明确规定节点间的父子关系，例如下图所示：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-4.png" alt="image"></p><p>本题比较人性化，要求只要输出其中一种可能性即可。还是可以根据一般的思路，采用递归思想，对于每一个先序序列，划分出对应的根节点、左子树、右子树范围即可自上而下构建出二叉树。</p><p>例如对于上例中的先序序列[1,2,4,5,3,6,7]，第一个节点一定为根节点，第2到第i个节点为左子树，第i+1到最后一个节点为右子树，那么问题就可以简化为：<strong>如何确定左右子树分界点？</strong></p><p><img src="http://bloghello.oursnail.cn/suanfa6-5.png" alt="image"></p><p>对于这个简化过后的问题，从后序遍历序列上很容易得到答案：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-6.png" alt="image"></p><p>根据上图的思路，就可以写代码啦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组还有元素，则取出第一个元素作为root</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组长度为1 的时候直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到左子树根节点在后序遍历中的位置，找到之后，元素前面的都是左子树元素，后面除了最后一个元素都是右子树元素</span></span><br><span class="line">        <span class="keyword">int</span> leftRootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftRootVal = pre[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;post.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(post[i] == leftRootVal)&#123;</span><br><span class="line">                leftRootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">//递归构造</span></span><br><span class="line">        root.left = constructFromPrePost(Arrays.copyOfRange(pre,<span class="number">1</span>,leftRootIndex+<span class="number">2</span>),</span><br><span class="line">                                        Arrays.copyOfRange(post,<span class="number">0</span>,leftRootIndex+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        root.right = constructFromPrePost(Arrays.copyOfRange(pre,leftRootIndex+<span class="number">2</span>,pre.length),</span><br><span class="line">                                         Arrays.copyOfRange(post,leftRootIndex+<span class="number">1</span>,post.length-<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题3</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-7.png" alt="image"></p><p>到现在为止，我们对于中序排序的规则已经很熟悉，下面图示:</p><p><img src="http://bloghello.oursnail.cn/suanfa6-8.png" alt="image"></p><p>我们从这个图上可以看到，找下一个节点是可以分为几种情况的。</p><p>第一种情况，就是一个节点有右子树。比如要求节点B的下一个节点，其实是找到它的右子树的最左孩子，就是G节点。</p><p>第二种情况，就是一个节点没有右子树，此时又可以分为两种情况。</p><p>对于G这个节点来说，没有右子节点了，它的父亲节点是E，G是E的左子节点，即E的左子节点是G，那么G的下一个节点就是E。</p><p>对于E这个节点来说，也没有右子节点，它的父亲节点是B，此时E是B的右子节点，根据实际情况来说，E的下一个节点绝对不是B，因为E是B的右子节点，根据中序遍历的规则，此时肯定是先遍历B再遍历E，所以B肯定在E的前面，而不是后面，所以我们还需要再往上找父亲节点，此时B的父亲节点为A，B为A的左子节点，此时根据实际情况，A就是我们要找的E的下一个节点。</p><p>所以，对于一个没有右子节点的节点来说，只需要判断它有没有父节点并且是不是父节点的左子节点，是的话，就找到了，不是则要不断地向上找。</p><p>如果一直找到根还是找不到，像节点F，那就返回null，因为实际上F节点就是中序遍历的最后一个节点，没有所谓的下一个节点了。</p><p>将上面所述转换为图示为：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-9.png" alt="image"></p><p>总之，我们不关心当前节点的左子节点，因为它不在我们的考虑范围内，它必定出现在当前节点的前面。</p><p>我们主要就是考虑有没有右子节点，或者没有右子节点的话就考虑父亲节点。有右子节点比较简单，一直找最左边的子节点即可。但是没有右子节点的时候，就需要去查询父亲节点了。理解了这些，程序也就呼之欲出了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.判断当前节点是否有右子节点，有则去里面找</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> firstInRightTree(pNode);</span><br><span class="line">        <span class="comment">//2.没有右子节点，就需要去父节点找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3.直到找到符合条件的父节点为止，跳出循环时pNode的父节点符合条件，这个父节点就是我们要的东西</span></span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span> &amp;&amp; pNode.next.left != pNode)&#123;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到右子树中找符合条件的，显然就是找最最最左边的子节点即可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeLinkNode <span class="title">firstInRightTree</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        TreeLinkNode curr = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对比较常见的树的一些算法题进行了分析，关于树的题目还有很多，并且很多重要的题目也还每设计到，后面有时间整理一下leetcode上比较经典的二叉树的算法题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌握对树的基本操作是很重要的，这里所谓的操作是指对树的遍历，以及对树的构造等等。下面通过一些题目来好好研究研究。由于篇幅、时间以及精力有限，本文着重提取两种题型进行分析，都是高频面试问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法5-二分搜索树</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%955-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法5-二分搜索树/</id>
    <published>2019-02-26T14:29:31.521Z</published>
    <updated>2019-02-26T14:29:49.786Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。普通的二叉树其实没什么好讲的，就是最多只有两个孩子的树，而二叉搜索树赋予了它一些额外的条件，使得它有了使用的价值，例如根据它的性质，那么中序遍历出来的结果恰好就是有序的结果，故本文着重说明二叉搜索树。</p><a id="more"></a><h2>一、二叉树</h2><p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。它本身对里面的数据是没有说明要求的，只是个数要满足二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2的(i-1)次方个结点；深度为k的二叉树至多有2的k次方-1个结点；</p><p><img src="http://bloghello.oursnail.cn/suanfa5-1.png" alt="image"></p><h2>二、满二叉树和完全二叉树</h2><p>一张图就可以看出它们的区别了：</p><p><img src="http://bloghello.oursnail.cn/suanfa5-2.png" alt="image"></p><h2>三、二叉搜索树概念</h2><p><strong>二叉查找树定义</strong>：又称为是二叉排序树（<code>Binary Sort Tree</code>）或二叉搜索树,不需要是一棵完全二叉树。具有以下性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ul><p><strong>二叉查找树的性质</strong>：对二叉查找树进行中序遍历，即可得到有序的数列。</p><p><strong>二叉查找树的时间复杂度</strong>：它和二分查找一样，插入和查找的时间复杂度均为<code>O(logn)</code>，但是在最坏的情况下仍然会有<code>O(n)</code>的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p><p>二叉查找树的高度决定了二叉查找树的查找效率。</p><h2>四、树的定义</h2><p>就是说如果我要定义一个二叉树，那么这个<code>Node</code>如何定义呢？其实很简单，无非就是<code>left</code>,<code>right</code>,<code>val</code>这三个变量而已，也有可能是<code>key</code>和<code>value</code>这种类型，这个定义是在《算法4》上看到的，二叉搜索树判断大小的依据就是这个<code>key</code>.不必对这个纠结.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分搜索树</span></span><br><span class="line"><span class="comment">//由于Key需要能够进行比较，所以需要extends Comparable&lt;Key&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 树中的节点为私有的类, 外界不需要了解二分搜索树节点的具体实现</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Key key;</span><br><span class="line">     <span class="keyword">private</span> Value value;</span><br><span class="line">     <span class="keyword">private</span> Node left, right;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.key = key;</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">         left = right = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Node root;  <span class="comment">// 根节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> count;  <span class="comment">// 树种的节点个数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>五、插入新节点</h2><p>查看以下动画演示了解插入新节点的算法思想：（其插入过程充分利用了二分搜索树的特性）</p><p>例如待插入数据60，首先与根元素41比较，大于根元素，则与其右孩子再进行比较，大于58由于58无右孩子，则60为58的右孩子，过程结束。（注意其递归过程）</p><p><img src="http://bloghello.oursnail.cn/%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9.gif" alt="image"></p><blockquote><p>判断node节点是否为空，为空则创建节点并将其返回（ 判断递归到底的情况）。</p></blockquote><blockquote><p>若不为空，则继续判断根元素的key值是否等于根元素的key值：若相等则直接更新value值即可。若不相等，则根据其大小比较在左孩子或右孩子部分继续递归直至找到合适位置为止。、</p></blockquote><p>代码实现(递归实现)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中插入一个新的(key, value)数据对</span></span><br><span class="line"><span class="comment">// 返回的是最后插入完成之后二叉树的根</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">    root = insert(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************</span></span><br><span class="line"><span class="comment">//* 二分搜索树的辅助函数</span></span><br><span class="line"><span class="comment">//********************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法</span></span><br><span class="line"><span class="comment">// 返回插入新节点后的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">insert</span><span class="params">(Node node, Key key, Value value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) == <span class="number">0</span> )</span><br><span class="line">        node.value = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )</span><br><span class="line">        node.left = insert( node.left , key, value);</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        node.right = insert( node.right, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>六、二分搜索树的查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看二分搜索树中是否存在键key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contain(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(Node node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> contain( node.left , key );</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">        <span class="keyword">return</span> contain( node.right , key );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>七、二分搜索树的遍历</h2><p>这块内容其实我想删除的，但是吧，这一段对树的前中后序遍历的动态图是非常不错的，对理解树的遍历是非常有利的，所以保留在这里。下面进入正文。</p><p>遍历分为前序遍历、中序遍历以及后序遍历三种，如何理解其遍历顺序呢？</p><p>对于每个节点而言，可能会有左、右两个孩子，所以分成下图中3个点，每次递归过程中会经过这3个点。</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86.png" alt="image"></p><blockquote><p>前序遍历：先访问当前节点，再依次递归访问左右子树</p></blockquote><blockquote><p>中序遍历：先递归访问左子树，再访问自身，再递归访问右子树</p></blockquote><blockquote><p>后续遍历：先递归访问左右子树，再访问自身节点</p></blockquote><p>下面分别来看看是如何遍历的。</p><h5>7.1 前序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%89%8D%E5%BA%8F%E4%BE%BF%E5%88%A9.gif" alt="image"></p><p>我们注意看，先找到28的第一个点，然后将28返回，下面看有没有左儿子，有就先来到左儿子的节点，然后将16弹出…</p><p>最终的打印结果:</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.2 中序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>最终的打印结果:</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.3 后序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>最终打印结果：</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.4 递归代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行前序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行中序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行后序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对非递归的写法，推荐用第二篇文章中说明的方式，那种方式具有较好的通用性。当然了，此时应该认识到学好递归的重要性了。</p><h2>八、层序遍历</h2><h5>8.1 算法思想</h5><p>层序遍历即一层一层地向下遍历，查看以下动画：</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>查看以上动画，实现其过程需要引入先进先出的“队列”数据结构，首先将28入队，第一层遍历完毕，可进行操作，将28出队并打印。遍历第二层16、30依次入队，再出队进行打印操作，依次类推。</p><h5>8.2 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们使用LinkedList来作为我们的队列</span></span><br><span class="line">    LinkedList&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span>( !q.isEmpty() )&#123;</span><br><span class="line"></span><br><span class="line">        Node node = q.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(node.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node.left != <span class="keyword">null</span> )</span><br><span class="line">            q.add( node.left );</span><br><span class="line">        <span class="keyword">if</span>( node.right != <span class="keyword">null</span> )</span><br><span class="line">            q.add( node.right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>九、局限性来源</h2><p>它的局限性来源于哪？注意其二分搜索树的创建，如下图所示，同样的数据，可以对应不同的二分搜索树。</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B1%80%E9%99%90.png" alt="image"></p><p>如上图，第一种创建情况可能是大部分人心中设想，但是第二种情况也是符合二分搜索树的特征，如此一来，二分搜索树可能退化成链表。二分搜索树的查找过程是与其高度相关，此时高度为n，时间复杂度为O(n^2)。</p><h2>十、初识红黑树</h2><p>其实二分搜索树的性能总体而言还是十分优异的，它所有的有关操作时间复杂度为O(n)，出现以上情况的概率很小，但如果创建时其数据都是有序的，那么就会令人担忧了。也许你会想到快速排序中也有此问题，不过它通过随机获取标志点的方法解决了此问题。</p><p>所以类似以上解决办法，将其顺序打乱再插入到二分搜索树即可？这是一个解决办法，但是需要一开始获取所有数据，其实这些数据是慢慢流入系统的，所以在创建其过程中才会发现数据是否几乎有序。</p><p>为了解决此问题，可以改造二叉树的实现，使得其无法退化成链表—–平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 <code>logn</code> 级别的，此概念的经典实现就是红黑树。</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。普通的二叉树其实没什么好讲的，就是最多只有两个孩子的树，而二叉搜索树赋予了它一些额外的条件，使得它有了使用的价值，例如根据它的性质，那么中序遍历出来的结果恰好就是有序的结果，故本文着重说明二叉搜索树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法4-二分查找算法</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%954-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法4-二分查找算法/</id>
    <published>2019-02-26T13:05:21.351Z</published>
    <updated>2019-02-26T13:05:48.546Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是比较常见的查找算法，但是它需要一个条件就是数组有序，因此当面试中听到有序数组这个关键词的时候，不妨往二分查找法想一想，或许它就是解开问题的钥匙。</p><a id="more"></a><p>算法思想：</p><blockquote><p>注意该算法的前提条件：有序数组。想查找元素value，先查看数组中间元素值v与value的大小，若相等则刚好，否则根据比较结果选择左、右半部分再次寻找。</p></blockquote><p>时间复杂度：</p><blockquote><p>整个查找过程可构成一棵树，时间复杂度为O(logn)。</p></blockquote><h2>问题1</h2><p>给定一个有序的数组，查找value是否在数组中，不存在返回-1。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arr:数组</span></span><br><span class="line"><span class="comment"> * n:数组数据长度</span></span><br><span class="line"><span class="comment"> * target:就是要查找的被返回的值</span></span><br><span class="line"><span class="comment"> * while循环迭代的方式实现二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( lo &lt;= hi )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int mid = (l + r)/2;防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归的方式实现二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( lo &gt; hi )</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, lo, mid-<span class="number">1</span>, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, mid+<span class="number">1</span>, hi, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题2</h2><p><img src="http://bloghello.oursnail.cn/suanfa4-1.png" alt="image"></p><p>这就是一道经典的用二分查找解决的问题。下面给出解题答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这边相等的话，就要找它周围的数字是否相等，直到找到一个区间为止</span></span><br><span class="line">                <span class="keyword">int</span> low = mid;</span><br><span class="line">                <span class="keyword">int</span> high = mid;</span><br><span class="line">                <span class="keyword">while</span>(low - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[low-<span class="number">1</span>] == target)&#123;</span><br><span class="line">                    low--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(high + <span class="number">1</span> &lt;= nums.length-<span class="number">1</span> &amp;&amp; nums[high+<span class="number">1</span>] == target)&#123;</span><br><span class="line">                    high++;</span><br><span class="line">                &#125;</span><br><span class="line">                res[<span class="number">0</span>] = low;</span><br><span class="line">                res[<span class="number">1</span>] = high;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我的思路很简单，就是在找到符合条件的mid之后，我就尝试在mid的两边再去找是否有相等的数字，由于是递增的数组，所以很好判断。</p><h2>问题3</h2><p><img src="http://bloghello.oursnail.cn/suanfa4-2.png" alt="image"></p><p>这是《剑指offer》上的一道题目，原本的数列一个非递减的序列，这里在中间咔了一刀变成两截，并且颠倒，那么就被划成了两段非递减的序列，并且前面的非递减数列要比后面的非递减数列要大于等于。所以，是有一定的规律的，这里还是推荐使用二分查找，只是是二分查找法的变体了。</p><p>当然了这个题目的暴力解法其实已经很简单了，就是从头开始遍历，只要出现一个数比前面一个数小，那么这个数就是原来序列的最前面的数，那么其实就是最小的数。</p><p>而二分查找在比较极端的条件下，比如元素都相等，可能就会退化为O(n)复杂度，但是如果原来的数列是一个严格递增的数列，那么还是快一点的。因为缩小的范围比较快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[right])&#123;</span><br><span class="line">                <span class="comment">//最小的元素一定在mid后面</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[right])&#123;</span><br><span class="line">                <span class="comment">//最小的元素在mid或者mid之前，注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字</span></span><br><span class="line">                <span class="comment">//比如 array = [4,6]</span></span><br><span class="line">                <span class="comment">//array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;</span></span><br><span class="line">                <span class="comment">//如果high = mid - 1，就会产生错误， 因此high = mid</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]</span></span><br><span class="line">                <span class="comment">//此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 </span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找法最主要的注意点就是边界，一定要注意边界的选取，这直接影响了程序的实现细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找是比较常见的查找算法，但是它需要一个条件就是数组有序，因此当面试中听到有序数组这个关键词的时候，不妨往二分查找法想一想，或许它就是解开问题的钥匙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法3-循环控制</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%953-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法3-循环控制/</id>
    <published>2019-02-26T10:00:17.013Z</published>
    <updated>2019-02-26T10:11:50.268Z</updated>
    
    <content type="html"><![CDATA[<p>在第一篇文章中为了说明递归如何写，所以对于链表的操作都是用递归来写的，我们发现递归写起来比较简洁，但是执行的过程有点复杂，并且往往在实际的算法中都是要将递归改成循环来做，可以一定程度上减少开销提高性能。下面我们来看看循环如何实现的。</p><a id="more"></a><h2>链表的反转</h2><p>需要验证准确性的话，可以去leetcode上去做这道题，题号为206.这道题还是比较经典的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = currentNode.next;</span><br><span class="line">            currentNode.next = newHead;</span><br><span class="line">            newHead = currentNode;</span><br><span class="line">            currentNode = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始学的时候看的答案就是这个方法，显然是要比递归好的，但是如果不理解的话，光靠背很容易出错，并且也不大背的上，如今重温这道题，其实是很简单的，我们下面用图示来阐述。</p><p>主要的思想是用两个指针，其中<code>newHead</code>指向的是反转成功的链表的头部，<code>currentHead</code>指向的是还没有反转的链表的头部：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-1.png" alt="image"></p><p>初始状态是<code>newHead</code>指向<code>null</code>，<code>currentHead</code>指向的是第一个元素，一直往后遍历直到<code>newHead</code>指向最后一个元素为止：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-3.png" alt="image"></p><p>下面展示的是其中某个时间点的指向细节：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-2.png" alt="image"></p><p>理解了上面的图示，程序就呼之欲出了。</p><h2>删除链表节点</h2><p>题目为：给一个数值，找到链表中这个等于这个数的所有节点并且删除。效果如下，比如给的数是2，则表示删除链表中所有为2的节点。</p><p><img src="http://bloghello.oursnail.cn/suanfa3-4.png" alt="image"></p><p>这个题目也是非常地经典，面试中经常会看到。我们务必要掌握。</p><p>这个其实有两种解题思路，比较简单的是增加一个虚拟的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造一个虚拟的头节点，指向head</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用一个指针指向虚拟头节点，因为虚拟头节点还要表示去重后的链表的头节点</span></span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        <span class="comment">//进入循环，看虚拟头节点下一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果下一个节点不为空并且值是等于val的，那么就说明要删除掉这个节点</span></span><br><span class="line">            <span class="comment">//所谓的删除，只是改变指针，使得这个要删除的节点没有任何引用即可，java会自动回收它</span></span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">                ListNode delNode = curr.next;</span><br><span class="line">                curr.next = delNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明值不等于val，那么就后移一个即可</span></span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现的方式相对来说比较简单。大体的解决思路为：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-6.png" alt="image"></p><p>另一种是比较特殊的处理方式，不需要虚拟的头节点就可以实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于比较特殊的，就是head也与val相等的情况，需要出一下</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，还需要判断一下head是否为null，因为有可能这个链表全部都等于val</span></span><br><span class="line">        <span class="comment">//那么经过上一步之后这个链表已经为null了，那么就不需要进入下一步了</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时链表开头的重复元素全部剔除了，下面就是普通的后续的元素，循环判断删除即可</span></span><br><span class="line">        ListNode prev = head;</span><br><span class="line">        <span class="keyword">while</span>(prev.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.next.val == val)&#123;</span><br><span class="line">                ListNode delNode = prev.next;</span><br><span class="line">                prev.next = delNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，代码大体是相似的，特殊的处理在于一开始的节点的值与val相等的处理，所以我们需要先处理一下head以及head的后面连续的都是等于val的节点，直到处理到不为val的节点为止，即把开头相等的节点全部剔除掉，下面再继续循环判断是否相等。</p><p>关于链表的题目还有很多，由于链表数据结构比较简单，但是算法并不简单，所以面试中经常会被问道，需要好好准备一下。后面会进行相应的总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一篇文章中为了说明递归如何写，所以对于链表的操作都是用递归来写的，我们发现递归写起来比较简洁，但是执行的过程有点复杂，并且往往在实际的算法中都是要将递归改成循环来做，可以一定程度上减少开销提高性能。下面我们来看看循环如何实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法2-汉诺塔问题</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%952-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法2-汉诺塔问题/</id>
    <published>2019-02-26T06:16:12.421Z</published>
    <updated>2019-02-26T06:16:36.020Z</updated>
    
    <content type="html"><![CDATA[<p>为什么还要再来说说递归问题，因为数据结构中二叉树是比较重要也是比较难的数据结构，它的结构是天生递归的，所以对于二叉树的很多操作都可以用递归来实现，因此递归这一关能尽量理解是最好的，本章从汉诺塔的问题出发，来看看递归的实现原理。</p><a id="more"></a><h2>汉诺塔问题</h2><p>这个问题估计大多数人都是知道的，汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p>抽象为数学问题：如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-1.png" alt="image"></p><p>其实核心的思想已经在上篇文章中说明了，就是数学归纳法的思想，就拿简单又不失一般性的三个盘子先说事。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-2.png" alt="image"></p><p>其实我们发现，最核心的一个状态就是：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-3.png" alt="image"></p><p>就是说，我们已经有了中间B这个符合条件的2个盘子的情况，那么我只需要将这两个想办法将这B上两个盘子放到C上就结束了。</p><p>同理，更多的盘子n，我就是想办法将n-1个符合条件的盘子放到第n个盘子上不就可以了。大概的思想如下：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-7.png" alt="image"></p><p>OK，下面展示程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> A,<span class="keyword">char</span> B,<span class="keyword">char</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(A+<span class="string">" -&gt; "</span>+C);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//上面n-1个盘子从A通过C想办法移到B上，对应上图的第一行图示</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,A,C,B);</span><br><span class="line">        <span class="comment">//将A剩下的盘子移到C上</span></span><br><span class="line">        System.out.println(A+<span class="string">" -&gt; "</span>+C);</span><br><span class="line">        <span class="comment">//这个n-1个盘子再想办法从B通过A移到C上，对应上如的第三行图示</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,B,A,C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先拿2测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   hanoi(<span class="number">2</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B</span><br><span class="line">A -&gt; C</span><br><span class="line">B -&gt; C</span><br></pre></td></tr></table></figure><p>是符合我们的预期的。并且尝试更多的时候，按照它一步一步是正确的。</p><p>如果理解了上面说的，那么这个程序是非常好理解的。但是真正想深入进递归里面，一旦多起来还是比较复杂的。其实我们可以这样理解：</p><blockquote><p>一个小朋友坐在第10排，他的作业本被小组长扔到了第1排，小朋友要拿回他的作业本，可以怎么办？他可以拍拍第9排小朋友，说：“帮我拿第1排的本子”，而第9排的小朋友可以拍拍第8排小朋友，说：“帮我拿第1排的本子”…如此下去，消息终于传到了第1排小朋友那里，于是他把本子递给第2排，第2排又递给第3排…终于，本子到手啦！这就是递归，拍拍小朋友的背可以类比函数调用，而小朋友们都记得要传消息、送本子，是因为他们有记忆力，这可以类比栈。</p><p>更严谨一些，递归蕴含的思想其实是数学归纳法：为了求解问题p（n），首先解决基础情形p（1），然后假定p（n-1）已经解决，在此基础上若p（n）得解，那所有问题均得解。这也启发我们：使用递归，切忌纠结中间步骤，因为这样做的代价是手动推理中间的若干步骤，而这些脏活，应该是计算机给我们干的!</p></blockquote><p>所以理解递归还是不能太纠结具体的过程，这样只会更加地糊涂，我们注重的应该是思想以及写递归的一些注意事项，比如对于参数的确定，停止条件以及每次都要缩小范围并且都是以1这个段位缩小，不要跨段不要跨段。</p><h2>递归与栈</h2><p>虽然说我们不能纠结于递归的过程，但是递归与栈关系紧密，区别只是这个栈是计算机系统栈帮我们实现，而迭代是我们自己控制栈来实现，两者的基本思想都是栈，那么我们就来探讨探讨递归与栈。这个问题也是我之前面试被问过的一个问题，希望再这里能有个比较清晰的理解。</p><p>前面说过，树是一个天然递归的数据结构，这里拿二叉树的前序遍历作为分析点，并且拿最简单的三个节点的二叉树作为示例。</p><p>对于树这个数据结构暂且不多说，我们如果用递归的方式来实现前序遍历还是非常简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个直接放到leetcode上竟然也是可以通过的，说明对这个递归答案还是认可的。不过这里想说明一下递归与栈的关系，所以需要详细说明一下它里面是如何通过系统栈来进行调用的。（前序遍历：144号，中序遍历84号，后序遍历145号）。</p><p>当然了，我们也知道递归相当于一个函数调用另一个子函数，它是自己再调用自己而已，递归借助了系统栈自己来实现的。我们这里以遍历最简单的二叉树为例：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-10.png" alt="image"></p><p>当执行到第一个<code>preorder</code>的时候，此时系统栈里面已经标志一下前面两句执行完毕，还剩下遍历右孩子的操作。此时就是已经遍历了1这个节点，下面就是准备进入1的左孩子即2这个节点的遍历。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-8.png" alt="image"></p><p>此时进入递归重新执行<code>preorder</code>，那么此时又将这个重新执行的函数的参数压到栈顶：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-9.png" alt="image"></p><p>此时2这个节点已经打印出来了，此时又要进入<code>preorder</code>重新执行了，再将2的左孩子放进<code>preorder</code>进行遍历，此时为null，那么就会直接结束<code>preorder</code>函数，返回来继续执行，此时<code>go 2-R</code>还没有执行，那么就是看看2的右孩子，也是null，那么此时关于2的节点的孩子们都遍历完毕了，就会出栈，回到一开始继续执行<code>go 1-R</code>。同理再去遍历1的右孩子们。</p><p>我们从上面的过程中知道，系统栈会保留递归调用的时候调用方的参数以及执行情况，等递归返回的时候，就可以将现场恢复并且继续执行。我们还明确，比如对于节点1来说，系统栈的处理方式是：先<code>count 1</code>即打印1，然后递归访问左孩子<code>go 1-L</code>，最后递归访问右孩子<code>go 1-R</code>，那么我们也可以用栈来模拟这个过程，那么压栈的过程必然是<code>go 1-R</code>–<code>go 1-L</code>–<code>count 1</code>，这样根据后进先出的原则，出来的顺序正好是<code>count 1</code>–<code>go 1-L</code>–<code>go 1-R</code>。</p><p>根据这个思路，我们完全可以将上面的递归程序改成用栈来实现。</p><p>首先将<code>root</code>入栈，并且标识为<code>go</code>，下面进入循环判断栈是否为空，不为空则进入循环。</p><p>首先是判断如果当前节点为<code>go</code>，则表示进行入栈操作，这里首先演示的是前序遍历，所以入栈的顺序是右孩子(go 1-R)–左孩子(go 1-L)–自身(print 1)，此时栈中已经有了这三个信息，那么进入下一次循环，首先出栈的就是自身(print 1)，那么则打印，继续循环，此时出栈的是左孩子(go 1-L)，因为是<code>go</code>所以要添加左右孩子，但是它没有左右孩子，则直接将<code>print 2</code>压入栈中，那么下次循环就会打印出来。最后同理就是右孩子出栈，跟2一样没有左右子孩子则直接将<code>print 3</code>压入栈中下次循环打印出来。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(String str,TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Command&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,root));</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Command command = stack.pop();</span><br><span class="line">            <span class="comment">//遇到go则按照顺序入栈</span></span><br><span class="line">            <span class="keyword">if</span> (command.str.equals(<span class="string">"go"</span>))&#123;</span><br><span class="line">                <span class="comment">//首先压入的是当前节点的右子节点</span></span><br><span class="line">                <span class="keyword">if</span>(command.node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,command.node.right));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//然后压入的是当前节点的左子节点</span></span><br><span class="line">                <span class="keyword">if</span>(command.node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,command.node.left));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后压入的是当前节点，准备打印</span></span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="string">"print"</span>,command.node));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//等于`print`的节点则打印出来</span></span><br><span class="line">                System.out.println(command.node.val);</span><br><span class="line">                res.add(command.node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的小伙伴可能会发现这个写法好像跟主流的写法不大一样，后面介绍二叉树的话会介绍一下主流的写法是什么，但是这个写法是比较通用的。原因在于这个写法是真正模拟了系统栈的执行流程，思路会比较清晰一点，并且它具有通用性，如果我想改为中序遍历或者后续遍历是非常简单的，只需要简单地调整<code>if (command.str.equals(&quot;go&quot;))</code>里面的顺序即可。</p><p>至此，简单地昭示了系统栈的执行流程，阐明了递归与栈之间的关系，并且用自己的栈来模拟系统栈写出了非递归的版本。递归在树这种数据结构中是随处可见的，应该对它重视起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么还要再来说说递归问题，因为数据结构中二叉树是比较重要也是比较难的数据结构，它的结构是天生递归的，所以对于二叉树的很多操作都可以用递归来实现，因此递归这一关能尽量理解是最好的，本章从汉诺塔的问题出发，来看看递归的实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法1-递归入门</title>
    <link href="http://yoursite.com/2019/02/25/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%951-%E9%80%92%E5%BD%92%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/02/25/algorithms-basic/基础算法1-递归入门/</id>
    <published>2019-02-25T13:19:57.931Z</published>
    <updated>2019-02-25T13:24:44.792Z</updated>
    
    <content type="html"><![CDATA[<p>算法入门系列以递归开头，我们知道，递归的编码往往是比较简单的，但是递归的思想往往又是难以理解。在写完这篇笔记之后仍然无法得递归之要领，不过对于如何写递归是有了一定得章法，一句话就是用数据归纳法，先尝试n得情况，再去考虑0或者1得情况，并且保证范围在逐渐缩小并且一定可以结束，下面我们来详细说一说递归。</p><a id="more"></a><h2>一、什么是递归</h2><p>我们可以把”递归“比喻成”查字典“，当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词。</p><p>可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。（摘自知乎的一个回答）</p><p>从程序本身来看，就是一个函数直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</p><p>我们这里以计算阶乘为切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;    </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> n * Factorial(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以上述代码为例，取 n=3，则过程如下：</p><p>第 1~4 步，都是入栈过程，<code>Factorial(3)</code>调用了<code>Factorial(2)</code>，<code>Factorial(2)</code>又接着调用<code>Factorial(1)</code>，直到<code>Factorial(0)</code>；</p><p>第 5 步，因 0 是递归结束条件，故不再入栈，此时栈高度为 4，即为我们平时所说的递归深度；</p><p>第 6~9 步，<code>Factorial(0)</code>做完，出栈，而<code>Factorial(0)</code>做完意味着<code>Factorial(1)</code>也做完，同样进行出栈，重复下去，直到所有的都出栈完毕，递归结束。</p><p>可以看出来，递归的本质就是由一个系统栈不停地保存每一层调用的方法及其参数，直到遇到终止条件为止，一层一层地结束返回，但是当层数过深的时候就有可能出现<code>stack overflow</code>这样的栈溢出错误。</p><p>也可以看出来，每一个递归程序都可以把它改写为非递归版本。但是并不是每个递归程序都是那么容易被改写为非递归的。某些递归程序比较复杂，其入栈和出栈非常繁琐，给编码带来了很大难度，而且易读性极差，所以条件允许的情况下，推荐使用递归。</p><h2>二、如何思考递归</h2><p>在初学递归的时候, 看到一个递归实现, 我们总是难免陷入不停的验证之中，比如上面提及的阶乘，求解<code>Factorial(n)</code>时，我们总会情不自禁的发问，<code>Factorial(n-1)</code>可以求出正确的答案么？接着我们就会再用<code>Factorial(n-2)</code>去验证，，，不停地往下验证直到<code>Factorial(0)</code>。</p><p>对递归这样的不适应，和我们平时习惯的思维方式有关。我们习惯的思维是：已知<code>Factorial(0)</code>，乘上 1 就等于<code>Factorial(1)</code>，再乘以 2 就等于<code>Factorial(2)</code>，，，直到乘到 n。</p><p>因此，递归和我们的思维方式正好相反。这就会给我们编程造成相当大的思维干扰。</p><p>其实，递归的数学思想是数学归纳法：</p><ul><li>如果下面这两点是成立的，我们就知道这个递归对于所有的 n 都是正确的。</li><li>1）当 n=0,1 时，结果正确；</li><li>2）假设递归对于 n 是正确的，同时对于 n+1 也正确。</li></ul><p>在递归中，我们通常把第 1 点称为终止条件，因为这样更容易理解，其作用就是终止递归，防止递归无限地运行下去。</p><p>对于第二点就是假定如果n-1的情况是正确的，那么n的情况就是正确的，然后再假定n-2的情况是正确的，那么n-1的情况也是正确的，那么就会一直推导到特殊情况比如0的时候，这个时候是正确的，那么前面所有的都是正确的。</p><p>从而达到了上面说的，将一个复杂的问题一层一层地转化为相似的小规模的问题，这样，解决了小规模问题之后一层一层地就可以返回来求出复杂的问题。</p><p>根据数学归纳法，其实我们还可以归纳出编写递归程序的一些准则：</p><ul><li>严格定义递归函数作用，包括参数、返回值、<code>side-effect</code></li><li>先一般再特殊</li><li>每次调用必须缩小问题规模</li><li>每次问题规模缩小程度必须为1</li></ul><p>这里简单地再解释一下，第一条中注意的是<code>side-effect</code>，这些是一些存储状态的变量，比如一些全局的变量来控制递归里面的一些逻辑等等。</p><p>考虑问题的时候可以从特殊的问题来考虑，但是在编写递归程序的时候，最好是先考虑一般的场景，最后再来看特殊的场景从而终止递归。并且每次缩小程度为1，不能为2或者3等。</p><p>好了，其实递归真正说起来好像也就那回事，但是真正用好确实是需要大量的训练，即递归的思维训练。</p><h2>三、递归的方式创建单向链表</h2><p>首先定义一下链表类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(head.val+<span class="string">"-&gt;"</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"null"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个数组：1，2，3，4，5，目标是将它们转换为链表。</p><p>正常的思维是：创建节点<code>node1</code>，<code>node2</code>，然后<code>node1</code>的<code>next</code>指向<code>node2</code>，依次类推直到最后。但是用递归的时候就不要这么想了，我们的思维方式变为：</p><p>假设2，3，4，5已经组装好了，那么我只需要再将1插到这个组装好的链表的最前面即可：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-1.png" alt="image"></p><p>那么，首先我们确定函数参数，返回值等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，首先，我取出1作为<code>firstNode</code>，然后我这个1指向的是后面已经排好的(2-&gt;3-&gt;4-&gt;5)这个链表，此时不就成功了嘛！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取数组第一个元素</span></span><br><span class="line">    Node firstNode = <span class="keyword">new</span> Node(values.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//获取后面排好的链表的头节点</span></span><br><span class="line">    Node fisrtSubNode = createLinkedList(values.subList(<span class="number">1</span>,values.size()));</span><br><span class="line">    <span class="comment">//第一个元素指向后面排好的链表的头节点即可</span></span><br><span class="line">    firstNode.setNext(fisrtSubNode);</span><br><span class="line">    <span class="comment">//返回整个链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> firstNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们只要知道：<code>createLinkedList(values.subList(1,values.size()));</code>这个就可以帮助我们拼接成我们需要的(2-&gt;3-&gt;4-&gt;5)这个链表，下面我只需要将1指向这个链表就可以成功了。我们仔细来看这个函数，就是调用自身，即递归，里面参数是：除了第一个元素外剩余的元素，并且每一层就剔除掉第一个元素，那么此时还需要一个终止条件，就是这个数组已经没有元素了就停止。所以完整的程序是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    <span class="comment">//5.递归停止的条件就是没有元素了</span></span><br><span class="line">    <span class="keyword">if</span> (values.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.获取数组第一个元素</span></span><br><span class="line">    Node firstNode = <span class="keyword">new</span> Node(values.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//2.获取后面排好的链表的头节点，用subList来截取，逐渐地截短使得问题的规模变小</span></span><br><span class="line">    Node fisrtSubNode = createLinkedList(values.subList(<span class="number">1</span>,values.size()));</span><br><span class="line">    <span class="comment">//3.第一个元素指向后面排好的链表的头节点即可</span></span><br><span class="line">    firstNode.setNext(fisrtSubNode);</span><br><span class="line">    <span class="comment">//4.返回整个链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> firstNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以想象，一层一层地剔除第一个元素，过程是(2-&gt;3-&gt;4-&gt;5)，(3-&gt;4-&gt;5)，(4-&gt;5)，（5)，()，此时为空了停止，就会返回到上一层执行的地方，即<code>Node fisrtSubNode = null</code>这一句，此时，上一层的<code>firstNode</code>就是5，那么继续执行就是<code>5.setNext(null)</code>，<code>return 5</code>，这一层又结束了返回到上一层，上一层此时<code>firstNode=4</code>，那么<code>fisrtSubNode = 5</code>，然后继续执行就是<code>4.setNext(5)</code>，最后<code>return 4</code>，此时链表已经是<code>4-&gt;5-&gt;null</code>了，再重复以上的过程直到<code>2-&gt;3-&gt;4-&gt;5-&gt;null</code>，此时回到最上层，即一开始的地方，即假定1后面就是拼接好的链表，此时确实也是拼接好的。所以这里用的就是数学归纳法的思想。</p><h2>四、递归的方式反转单向链表</h2><p>链表的反转效果为：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-2.png" alt="image"></p><p>我们跟上面一样考虑，考虑一般的情况，那就是1后面的所有元素已经全部反转好了，初始状态为：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-3.png" alt="image"></p><p>此时假定后面全部反转好了：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-4.png" alt="image"></p><p>下面只需要将2指向1，并且1指向null即可：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-5.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node newHead = reverseLinkedList(head.getNext());</span><br><span class="line">    head.getNext().setNext(head);</span><br><span class="line">    head.setNext(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>六、递归存在的问题</h2><p>比如计算斐波那契数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==<span class="number">1</span>||index==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fib(index-<span class="number">1</span>)+fib(index-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个递归里做了冗余的工作，如图，我们在f4里面已经计算了f2，可是f3里有同样计算了f2，以此类推那些冗余的工作，在数值比较小的情况下，计算机还是可以接受的。但是，当求解的数值比较大，它是成指数级增长的，所以不要再递归中做重复的工作。</p><p><img src="http://bloghello.oursnail.cn/suanfa1-7.png" alt="image"></p><p>下一节通过经典得汉诺塔问题再来探讨一下递归的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法入门系列以递归开头，我们知道，递归的编码往往是比较简单的，但是递归的思想往往又是难以理解。在写完这篇笔记之后仍然无法得递归之要领，不过对于如何写递归是有了一定得章法，一句话就是用数据归纳法，先尝试n得情况，再去考虑0或者1得情况，并且保证范围在逐渐缩小并且一定可以结束，下面我们来详细说一说递归。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记12-分布式锁</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B012-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记12-分布式锁/</id>
    <published>2019-02-23T08:48:05.271Z</published>
    <updated>2019-02-23T08:51:35.857Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁在分布式系统中是非常常见的，redis以及ZK都可以实现分布式锁，在文章<a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">Curator</a>从实战的层面进行了实际的分布式锁的实现，具体看这个文章即可。下面是再唠叨唠叨。</p><a id="more"></a><h2>redis实现分布式锁</h2><p>之前，在<a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">redis实现分布式锁</a>实现过一个基于redis的分布式锁，用来保证一个系统去定时关单。</p><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V2.png" alt="image"></p><p>这上面两个例子，一个是针对多个系统修改同一个资源，一个是面临高并发下订单时控制同一时间只能有一个用户拿到锁然后下订单（可能是多个系统，比如是订单服务器和库存服务器，当然，为了解耦和提高速度，那么可以把写订单表这个逻辑用MQ异步出去），首先我要判断库存是不是真的够，那么这个时候我就要用分布式锁控制，防止两个用户同时来查库存数量然后都觉得自己可以下订单（极端情况，库存只有1，那么这两个用户同时查到为1，那么都认为自己可以下订单咋办？），其他的用户必须等到这个用户释放锁或者超时才可以再拿到锁再去执行操作。这样，有效地解决了商品的超卖问题。</p><p>优点：实现简单，吞吐量十分客观，对于高并发情况应付自如，自带超时保护，对于网络抖动的情况也可以利用超时删除策略保证不会阻塞所有流程。但是redis存在一些问题：</p><ul><li><strong>单点问题</strong>：因为redis一般都是单实例使用，那么对于单点问题，可以做一个主从。当然主从切换的时候也是不可用的，因为主从同步是异步的，可能会并发问题。如果对于主从还是不能保证可靠性的话，可以上Redis集群，对于Redis集群，因为使用了类一致性Hash算法，虽然不能避免节点下线的并发问题(当前的任务没有执行完，其他任务就开始执行)，但是能保证Redis是可用的。可用性的问题是出了问题之后的备选方案，如果我们系统天天都出问题还玩毛啊，对于突发情况牺牲一两个请求还是没问题的。</li><li><strong>锁删除失败</strong>：分布式锁基本都有这个问题，可以对key设置失效时间。这个超时时间需要把控好，过大那么系统吞吐量低，很容易导致超时。如果过小那么会有并发问题，部分耗时时间比较长的任务就要遭殃了。</li></ul><p><strong>redis集群的同步策略是需要时间的，有可能A线程setNX成功后拿到锁，但是这个值还没有更新到B线程执行setNX的这台服务器，那就会产生并发问题。</strong></p><h3>zookeeper实现分布式锁</h3><p>Zookeeper是一个分布式一致性协调框架，主要可以实现选主、配置管理和分布式锁等常用功能，因为Zookeeper的写入都是顺序的，在一个节点创建之后，其他请求再次创建便会失败，同时可以对这个节点进行Watch，如果节点删除会通知其他节点抢占锁。</p><p>Zookeeper实现分布式锁虽然是比较重量级的，但实现的锁功能十分健全，由于Zookeeper本身需要维护自己的一致性，所以性能上较Redis还是有一定差距的。</p><p>“惊群”就是在一个节点删除的时候，大量对这个节点的删除动作有订阅Watcher的线程会进行回调，这对Zk集群是十分不利的。所以需要避免这种现象的发生。</p><p>为了解决“惊群“问题，我们需要放弃订阅一个节点的策略，那么怎么做呢？详细看这里：<a href="https://www.jianshu.com/p/5d12a01018e1" target="_blank" rel="noopener">https://www.jianshu.com/p/5d12a01018e1</a></p><p>最后想说明一点，其实对于Zookeeper的一些常用功能是有一些成熟的包实现的，像Curator。Curator的确是足够牛逼，不仅封装了Zookeeper的常用API，也包装了很多常用Case的实现。形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"><span class="keyword">if</span> ( lock.acquire(maxWait, waitUnit) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do some work inside of the critical section here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的时间在<a href="https://github.com/sunweiguo/mama-buy" target="_blank" rel="noopener">分布式电商项目-码码购</a>中用<code>Curator</code>实现分布式锁实现了某些场景的需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式锁在分布式系统中是非常常见的，redis以及ZK都可以实现分布式锁，在文章&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Curator&lt;/a&gt;从实战的层面进行了实际的分布式锁的实现，具体看这个文章即可。下面是再唠叨唠叨。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
</feed>
