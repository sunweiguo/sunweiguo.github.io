<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-14T10:00:14.407Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【面试题54-字符流中第一个不重复的字符】</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9854-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/14/剑指offer/【面试题54-字符流中第一个不重复的字符】/</id>
    <published>2019-03-14T09:59:51.334Z</published>
    <updated>2019-03-14T10:00:14.407Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十四题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。</p><h2>解题思路</h2><p>常规的解法是用一个map来存储，这样空间复杂度为O(n)，然后每次都遍历map获取第一个不重复的字符，时间复杂度也为O(n)。下面显示i代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用有序的Map：LinkedHashMap来存放char，并且记录其出现次数</span></span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;Character,Integer&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(ch))&#123;</span><br><span class="line">            map.put(ch,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(ch,map.get(ch)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.get(ch);</span><br><span class="line">            <span class="comment">//目前第一个只出现一次的字符，返回</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种很容易想到，但是能不能再优化一点呢？我们知道，ASCII码一共只有128个字符，那么我可以直接定义一个长度为128的数组，空间复杂度为O(n)，时间复杂度控制在常数级别，虽然我获取第一个只出现一次的元素需要一个while循环，但是这个循环不可能超过128，一般很快就可以拿到。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//英文字符不会逃出128个ascii码的范围，所以定义这个长度的数组</span></span><br><span class="line">    <span class="comment">//第一个ASCII码是一个空字符，所以我都是相对于` `进行一一排列</span></span><br><span class="line">    <span class="comment">//比如数字'0'是30，那'0'-''等于30，就存在tmp[30]这个地方即可</span></span><br><span class="line">    <span class="comment">//注意，tmp存的是出现的子树，即'0'出现了两次，那么tmp[30]就是2</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//维护一个队列，只保存一次进来的元素，重复的丢掉</span></span><br><span class="line">    LinkedList&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//第一次进来的元素放进队列尾部</span></span><br><span class="line">        <span class="keyword">if</span>(tmp[ch-<span class="string">' '</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            queue.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进来一次，就对相应坐标加一，统计出出现次数</span></span><br><span class="line">        tmp[ch-<span class="string">' '</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//取得时候是从队列得头部取，因为头部是比较早的数据</span></span><br><span class="line">        <span class="comment">//出现次数大于等于2的话就不断丢弃，知道找到第一个出现次数为1的字符跳出循环</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; tmp[queue.getFirst()-<span class="string">' '</span>]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            queue.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿到这个第一个只出现一次的字符</span></span><br><span class="line">        <span class="keyword">if</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.getFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿不到了，说明没有只出现一次的字符，那么就返回#</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题53-表示数值的字符串】</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9853-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/14/剑指offer/【面试题53-表示数值的字符串】/</id>
    <published>2019-03-14T09:13:38.371Z</published>
    <updated>2019-03-14T09:15:57.788Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十三题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,“5e2”,&quot;-123&quot;,“3.1416&quot;和”-1E-16&quot;都表示数值。 但是&quot;12e&quot;,“1a3.14”,“1.2.3”,&quot;±5&quot;和&quot;12e+4.3&quot;都不是。</p><h2>解题思路</h2><ol><li><code>12e</code>说明e的后面必须有数字，不能有两个e</li><li><code>+-5</code>说明符号位要么出现一次在首位，要么出现一次在e的后一位，其他地方都不能有</li><li><code>12e4.3</code>说明e的后面不能有小数，<code>1.2.3</code>说明不能有两个小数点</li><li><code>1a3.14</code>说明不能有其他的非法字符，比如这里的<code>a</code></li></ol><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//signal表示符号，decimal表示小树点，hasE表示含有符号e</span></span><br><span class="line">        <span class="keyword">boolean</span> signal = <span class="keyword">false</span>,decimal = <span class="keyword">false</span>,hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'E'</span> || str[i] == <span class="string">'e'</span>)&#123;</span><br><span class="line">                <span class="comment">//e后面必须有数字，所以是最后一位肯定不通过</span></span><br><span class="line">                <span class="keyword">if</span>(i==str.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不能有两个e</span></span><br><span class="line">                <span class="keyword">if</span>(hasE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="comment">//不是第一次出现，那么后面能出现符合的地方只有紧贴着e的后面一位，不是则不通过</span></span><br><span class="line">                <span class="keyword">if</span>(signal &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次出现，如果不是出现在第一位，那么还是判断一下是不是出现在e的后面一位</span></span><br><span class="line">                <span class="keyword">if</span>(!signal &amp;&amp; i&gt;<span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                signal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="comment">//如果存在e并且e后面为小数则不通过</span></span><br><span class="line">                <span class="keyword">if</span>(hasE)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不能有两个小数点</span></span><br><span class="line">                <span class="keyword">if</span>(decimal)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="comment">//不是e也不是+-符号也不是小数点，那么只能是数字，不是数字就是非法的字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题52-正则表达式匹配】</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9852-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/14/剑指offer/【面试题52-正则表达式匹配】/</id>
    <published>2019-03-14T04:30:45.546Z</published>
    <updated>2019-03-14T04:31:24.989Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十二题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数用来匹配包括<code>.</code>和<code>*</code>的正则表达式。模式中的字符<code>.</code>表示任意一个字符，而<code>*</code>表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>aaa</code>与模式<code>a.a</code>和<code>ab*ac*a</code>匹配，但是与<code>aa.a</code>和<code>ab*a</code>均不匹配</p><h2>解题思路</h2><p>这道题目实现起来很麻烦</p><p><strong>当模式中的第二个字符不是<code>*</code>时：</strong></p><p>这种情况比较简单：</p><p>①、<u>如果字符串第一个字符和模式中的第一个字符相匹配</u>，那么字符串和模式都后移一个字符，然后匹配剩余的。</p><p>②、<u>如果字符串第一个字符和模式中的第一个字符相不匹配</u>，直接返回<code>false</code>。</p><p><strong>而当模式中的第二个字符是<code>*</code>时：</strong></p><p>这种情况就比较复杂了：</p><p><u>如果字符串第一个字符跟模式第一个字符不匹配</u>，则模式后移2个字符，继续匹配，因为*是可以表示0个的。</p><p><u>如果字符串第一个字符跟模式第一个字符匹配</u>，因为*是比较特殊的，他可以表示0个，也可以表示1个，也可以表示多个，我们需要考虑所有的情况，就有3种匹配方式：</p><p>①、模式后移2字符，相当于x*被忽略，字符不后移；</p><p>②、字符串后移1字符，模式后移2字符；</p><p>③、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</p><p>对于.来说，表示任意一个字符，所以在进行上面的判断的时候，要额外判断一下是否有.这个情况，他可以与任意字符匹配的。</p><p>理顺了这个思路之后，下面就可以用代码来实线一波了。</p><h2>我的答案</h2><p>这一题给我的压力挺大的，虽然说思路可以理解，但是真正要写完整还是不容易的，我感觉这个程序<strong>可能</strong>还是存在一些问题的，但是牛客的案例比较少，所以可以通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> match(str,strIndex,pattern,patternIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> strIndex,<span class="keyword">char</span>[] pattern,<span class="keyword">int</span> patternIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//两者都走到最后了，说明匹配成功了</span></span><br><span class="line">        <span class="keyword">if</span>(strIndex == str.length &amp;&amp; patternIndex == pattern.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模式走到最后但是字符串还没有，说明匹配失败了</span></span><br><span class="line">        <span class="keyword">if</span>(strIndex != str.length &amp;&amp; patternIndex == pattern.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第二个字符是*</span></span><br><span class="line">        <span class="keyword">if</span>(patternIndex &lt; pattern.length-<span class="number">1</span> &amp;&amp; pattern[patternIndex+<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="comment">//如果匹配，匹配分为直接字符匹配和.匹配两种</span></span><br><span class="line">            <span class="keyword">if</span>((strIndex != str.length &amp;&amp; str[strIndex] == pattern[patternIndex]) </span><br><span class="line">              || (strIndex != str.length &amp;&amp; pattern[patternIndex] == <span class="string">'.'</span>))&#123;</span><br><span class="line">                <span class="comment">//匹配了之后有三种选择的路，递归下去一直匹配到最后</span></span><br><span class="line">                <span class="keyword">return</span> match(str,strIndex,pattern,patternIndex+<span class="number">2</span>) ||</span><br><span class="line">                        match(str,strIndex+<span class="number">1</span>,pattern,patternIndex+<span class="number">2</span>) || </span><br><span class="line">                            match(str,strIndex+<span class="number">1</span>,pattern,patternIndex);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//一开始跟*之前的字符就不匹配的话，就忽略这个*和*之前的字符，直接尝试匹配下个字符</span></span><br><span class="line">                <span class="keyword">return</span> match(str,strIndex,pattern,patternIndex+<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果第二个字符不是*，并且匹配的话就都往后移动一格</span></span><br><span class="line">        <span class="keyword">if</span>((strIndex != str.length &amp;&amp; str[strIndex] == pattern[patternIndex]) </span><br><span class="line">              || (strIndex != str.length &amp;&amp; pattern[patternIndex] == <span class="string">'.'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> match(str,strIndex+<span class="number">1</span>,pattern,patternIndex+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题51-构建乘积数组】</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9851-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/14/剑指offer/【面试题51-构建乘积数组】/</id>
    <published>2019-03-14T03:02:31.781Z</published>
    <updated>2019-03-14T03:03:01.603Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十一题。</p><a id="more"></a><h2>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。不能使用除法。</p><h2>解题思路</h2><p><img src="http://bloghello.oursnail.cn/offer51-1.png" alt="image"></p><p>我们注意到，要计算B2，那么分为两个部分，左边是(A0 * A1)，右边是(An-1 * … * A3).所以对于每一个B，我们都分为两个部分进行计算即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="comment">//构建与A一样长的数组B</span></span><br><span class="line">        <span class="keyword">int</span> len  = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">if</span>(len != <span class="number">0</span>)&#123;</span><br><span class="line">            B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//先计算左边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再计算右边</span></span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                tmp *= A[i+<span class="number">1</span>];</span><br><span class="line">                B[i] *= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>02-软件设计七大原则-开闭原则</title>
    <link href="http://yoursite.com/2019/03/13/design-pattern/02-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/03/13/design-pattern/02-软件设计七大原则-开闭原则/</id>
    <published>2019-03-13T05:58:00.102Z</published>
    <updated>2019-03-13T06:00:25.594Z</updated>
    
    <content type="html"><![CDATA[<p>极速入门了UML类图之后，我们不着急开启设计模式之旅，我们先来探讨一下软件设计的七大原则，为什么要探讨这个，其实无论哪种设计模式，都是在这七大原则中进行了相应的取舍才逐渐形成的，因此七大原则是指导我们怎么用设计模式以及编写代码的基本原则。本文先来了解一下开闭原则。</p><a id="more"></a><h2>定义</h2><ul><li>定义：一个软件实体如类，模块和函数应该对扩展开放，对修改关闭</li><li>用抽象构建框架，用实现扩展细节</li><li>优点：提高软件系统的可复用性和可维护性</li></ul><h2>例子</h2><p>比如一个简单场景：有一个课程，原价200，现在双十一打八折，那么这个打折功能如何添加上去呢?</p><p>平时这个java课程是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaCourse</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ICourse javaCourse = <span class="keyword">new</span> JavaCourse(<span class="number">1</span>,<span class="string">"好看的课"</span>,<span class="number">200.00</span>);</span><br><span class="line">        System.out.println(<span class="string">"课程id："</span>+javaCourse.getId()+<span class="string">",课程的名称："</span>+javaCourse.getName()+<span class="string">",课程的价格:"</span>+javaCourse.getPrice());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，要在双十一搞活动，需要对这个价格限时打折，该怎么做？</p><p>比较简单的方法是：直接在接口上新建一个方法，然后重新实现这个打折的方法，最后再调用这个方法；<strong>这显然违背了我们这里对修改封闭的原则，接口是一种契约，不应该随便更改</strong>。</p><p>那么直接在实现类上面的<code>getPrice()</code>方法里面乘0.8?这显然也一样不行。</p><p>⭐⭐⭐这个时候，需要新建一个这个课程打折的类<code>discountJavaCourse</code><strong>继承</strong><code>javaCourse</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountJavaCourse</span> <span class="keyword">extends</span> <span class="title">JavaCourse</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscountJavaCourse</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id, name, price);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDiscountPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice()*<span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在调用的时候，因为是父类声明的引用，需要强转一下，否则拿不到这个扩展的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ICourse javaCourse = new JavaCourse(1,"好看的课",200.00);</span></span><br><span class="line"><span class="comment">//        System.out.println("课程id："+javaCourse.getId()+",课程的名称："+javaCourse.getName()+",课程的价格:"+javaCourse.getPrice());</span></span><br><span class="line"></span><br><span class="line">        ICourse iCourse = <span class="keyword">new</span> DiscountJavaCourse(<span class="number">1</span>,<span class="string">"好看的课"</span>,<span class="number">200.00</span>);</span><br><span class="line">        DiscountJavaCourse discountJavaCourse = (DiscountJavaCourse)iCourse;</span><br><span class="line">        System.out.println(<span class="string">"课程id："</span>+discountJavaCourse.getId()+<span class="string">",课程的名称："</span>+discountJavaCourse.getName()+<span class="string">",原价:"</span>+discountJavaCourse.getPrice()+<span class="string">",折后价为："</span>+discountJavaCourse.getDiscountPrice());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而达到了对于扩展开放，对于修改封闭的效果。<strong>因为越基层的类所影响的东西越多，所以不要去动他。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;极速入门了UML类图之后，我们不着急开启设计模式之旅，我们先来探讨一下软件设计的七大原则，为什么要探讨这个，其实无论哪种设计模式，都是在这七大原则中进行了相应的取舍才逐渐形成的，因此七大原则是指导我们怎么用设计模式以及编写代码的基本原则。本文先来了解一下开闭原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>01-UML(统一建模语言)</title>
    <link href="http://yoursite.com/2019/03/13/design-pattern/01-UML(%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80)/"/>
    <id>http://yoursite.com/2019/03/13/design-pattern/01-UML(统一建模语言)/</id>
    <published>2019-03-13T05:36:51.688Z</published>
    <updated>2019-03-13T05:43:42.627Z</updated>
    
    <content type="html"><![CDATA[<p>在开始系统学习设计模式之前，先学习一下UML类图的表示方法，在阅读各种源码的时候，要想快速摸清框架结构的话，一个好的方式就是查看它的类图，了解里面的骨架，找到核心开始攻克。本文来极速入门UML类图。</p><a id="more"></a><h2>一、什么是UML类图</h2><p>用于表示类、接口、实例等之间相互的静态关系</p><h2>二、箭头方向的含义</h2><p>一般情况下是从子指向父。</p><h2>三、继承和实现</h2><p>典型的特征是<strong>空心三角箭头</strong>。其中，实线代表继承父类，虚线代表实现接口。关于继承和实现，我们都太熟悉了，就不再赘述了。</p><p><img src="http://bloghello.oursnail.cn/pattern1-1.png" alt="image"></p><h2>四、聚合和组合</h2><p>典型特征是<strong>菱形箭头</strong>。聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上。</p><p><img src="http://bloghello.oursnail.cn/pattern1-2.png" alt="image"></p><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成。</p><p><img src="http://bloghello.oursnail.cn/pattern1-3.png" alt="image"></p><p>我们一定要注意区分它们两者，首先说明一下，组合的依赖关系强于聚合。我们可以将聚合关系理解为：整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><p>我们可以将组合关系理解为：组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><p>聚合可以这样说：大雁聚合成大雁群；组合可以这样说：鸟儿与翅膀，两者生死与共。</p><p>之间依赖关系强则用实心菱形。</p><p>关于组合关系中常见的数字表达含义，假设有A类和B类，数字标记在A类侧,表明系统在某一时刻，B的实例可以与A的xx个实例相关：</p><ul><li><code>0..1</code>    0或1个实例</li><li><code>0..*</code>    0或多个实例</li><li><code>1..1</code>    1个实例</li><li><code>1</code>       只能由一个实例</li><li><code>1..*</code>    至少有一个实例</li></ul><h2>五、关联和依赖</h2><p>是一个<strong>普通箭头</strong>。关联关系是用一条实线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；注意，强调的是一种天然的静态关系，是不可改变的固有关系，所以是实线。</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><p>在代码中，关联对象通常是以成员变量的形式实现的；</p><p><img src="http://bloghello.oursnail.cn/pattern1-4.png" alt="image"></p><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><p><img src="http://bloghello.oursnail.cn/pattern1-5.png" alt="image"></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>在代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还可以“使用”对方的方法和属性；</p><h2>六、一个类如何表示？</h2><p><img src="http://bloghello.oursnail.cn/uml1-2.png" alt="image"></p><h2>七、从整体来看一张UML类图</h2><p><img src="http://bloghello.oursnail.cn/uml1-3.png" alt="image"></p><p>我们看到，氧气和水都是以参数的形式传递进来，所以是变化的，因此是依赖关系，因此是带箭头的虚线。</p><p>鸟和翅膀不可分割，因此是组合关系，因此是实心菱形。</p><p>大雁聚合成大雁群，就像盘子盛放东西一样，是一种聚合关系，因此是空心菱形。</p><p>企鹅需要严寒的气候，这是天然的关系，企鹅不会突然说我想去非洲，因为它适应不了，所以这种天然的关系是关联关系，因此是带箭头的实线。</p><p>鸟是动物的子类，因此是空心三角实线。</p><p>大雁会飞，所以可以实线飞翔的接口，因此是空心三角虚线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开始系统学习设计模式之前，先学习一下UML类图的表示方法，在阅读各种源码的时候，要想快速摸清框架结构的话，一个好的方式就是查看它的类图，了解里面的骨架，找到核心开始攻克。本文来极速入门UML类图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题50-数组中的重复数字】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9850-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题50-数组中的重复数字】/</id>
    <published>2019-03-13T04:21:38.825Z</published>
    <updated>2019-03-13T04:21:59.717Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十题。</p><a id="more"></a><h2>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2>解题思路</h2><p>比较好想的是用一个map来存储和判断。</p><p>但是吧这个问题确实是可以不用额外的O(n)的空间，不过理解上就会难一点，所以还是用map来解决吧。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(numbers[i]))&#123;</span><br><span class="line">            map.put(numbers[i],<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(numbers[i],map.get(numbers[i])+<span class="number">1</span>);</span><br><span class="line">            duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题49-把字符串转换成整数】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9849-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题49-把字符串转换成整数】/</id>
    <published>2019-03-13T04:21:05.834Z</published>
    <updated>2019-03-13T04:29:25.133Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十九题。</p><a id="more"></a><h2>题目描述</h2><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><h2>解题思路</h2><p>主要就是处理一下符号位，以及判断是否有非法字符，最后转换为整数即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(str.trim().length() == <span class="number">0</span> || <span class="keyword">null</span> == str)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.只有一个元素的情况</span></span><br><span class="line">        <span class="keyword">if</span>(str.trim().length() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.toCharArray()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> c-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不是数字的话，那肯定是非法的了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.下面长度都大于1，先拿到首位的符号看是不是负数，是的话记录一下</span></span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span> isMinus = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            isMinus = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.逐个判断，合法则拼接为一个整数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; (ch[i] == <span class="string">'+'</span> || ch[i] == <span class="string">'-'</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i] &lt; <span class="string">'0'</span> || ch[i] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = <span class="number">10</span> * res + (ch[i]-<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isMinus ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题48-不用加减乘除做加法】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9848-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题48-不用加减乘除做加法】/</id>
    <published>2019-03-13T04:20:28.729Z</published>
    <updated>2019-03-13T04:20:53.930Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十八题。</p><a id="more"></a><h2>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h2>解题思路</h2><p>首先看十进制是如何做的： 5+7=12，三步走：</p><p>第一步：相加各位的值，不算进位，得到2。</p><p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p><p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p><p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。</p><p>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1 ^ num2;</span><br><span class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题47-求1+2+3+...+n】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9847-%E6%B1%821+2+3+...+n%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题47-求1+2+3+...+n】/</id>
    <published>2019-03-13T04:19:57.090Z</published>
    <updated>2019-03-13T04:20:15.663Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十七题。</p><a id="more"></a><h2>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h2>解题思路</h2><p>这道题目确实不大好想，是一个蛋疼的问题，看了看答案，才知道用<code>&amp;&amp;</code>和递归来实现。对递归熟悉的话，这个程序就非常好理解了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="comment">//利用&amp;&amp;的短路特性</span></span><br><span class="line">        <span class="comment">//n=0的时候，停止递归，否则一直加</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = (sum&gt;<span class="number">0</span>) &amp;&amp; ((sum+=Sum_Solution(--n))&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题46-孩子们的游戏】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9846-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题46-孩子们的游戏】/</id>
    <published>2019-03-13T04:19:20.781Z</published>
    <updated>2019-03-13T04:19:42.753Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十六题。</p><a id="more"></a><h2>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数…这样下去…直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!<sup>_</sup>)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><h2>解题思路</h2><p>这道题目可以用<code>LinkedList</code>来模拟这个环，只需要每次找到的第m-1编号的小朋友（注意，由于是环，所以需要余上小朋友的数量），找到了之后就剔除，不断地循环，直到还剩一个。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            index = (index + m - <span class="number">1</span>)% list.size();</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list.size() == <span class="number">1</span> ? list.get(<span class="number">0</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Git基本原理</title>
    <link href="http://yoursite.com/2019/03/12/miscellany/16git%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/12/miscellany/16git基本原理/</id>
    <published>2019-03-12T09:18:22.158Z</published>
    <updated>2019-03-12T11:25:52.657Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们对git并不陌生，全球最大的同性交友网站github是程序猿们的最爱，这里只有你想不到的，没有你找不到的，各种资源应有尽有，免去了从浏览器中找到若干垃圾的麻烦。因此熟悉git也成为程序猿标配，本文来简单说说git的基本操作和基本原理。</p><a id="more"></a><h2>一、Git工作流程</h2><p><img src="http://bloghello.oursnail.cn/zaji17-1.png" alt="image"></p><p>这四个区域的名字如下:</p><ul><li>Workspace：工作区</li></ul><blockquote><p>程序员进行开发改动的地方，是你当前看到的，也是最新的。平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。</p></blockquote><ul><li>Index / Stage：暂存区</li></ul><blockquote><p><code>.git</code>目录下的<code>index</code>文件, 暂存区会记录<code>git add</code>添加文件的相关信息(文件名、大小、<code>timestamp</code>…)，不保存文件实体, 通过id指向每个文件实体。</p><p>可以使用<code>git status</code>查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。<br>当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过<code>git add</code>先提交到暂存区，被git管理。</p></blockquote><ul><li>Repository：仓库区（或本地仓库）</li></ul><blockquote><p><code>git commit</code>后同步<code>index</code>的目录树到本地仓库，方便从下一步通过<code>git push</code>同步本地仓库与远程仓库的同步。</p></blockquote><ul><li>Remote：远程仓库</li></ul><blockquote><p>远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p></blockquote><p><strong>总结一下：</strong></p><ul><li>任何对象都是在工作区中诞生和被修改；</li><li>任何修改都是从进入<code>index</code>区才开始被版本控制；</li><li>只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；</li><li>与协作者分享本地的修改，可以把它们<code>push</code>到远程仓库来共享。</li></ul><p>下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。</p><p><img src="http://bloghello.oursnail.cn/zaji17-2.png" alt="image"></p><h2>二、常用git命令</h2><p><img src="http://bloghello.oursnail.cn/zaji17-3.png" alt="image"></p><p>看不清可以拖动图片到新的页面打开。我们从关键字入手git常用命令。</p><h2>2.1 HEAD</h2><p><code>HEAD</code>，它始终指向当前所处分支的最新的提交(commit)点。你所处的分支变化了，或者产生了新的提交点，<code>HEAD</code>就会跟着改变。</p><p><img src="http://bloghello.oursnail.cn/zaji17-4.png" alt="image"></p><h2>2.2 add和commit</h2><p><img src="http://bloghello.oursnail.cn/zaji17-5.png" alt="image"></p><p><code>add</code>相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git add .</td><td>添加当前目录的所有文件到暂存区</td></tr><tr><td>git add [dir]</td><td>添加指定目录到暂存区，包括子目录</td></tr><tr><td>git add [file]</td><td>添加指定文件到暂存区</td></tr></tbody></table><p><code>commit</code>相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的<code>HEAD</code>向后移动一个提交点。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git commit -m [message]</td><td>提交暂存区到本地仓库，message代表说明信息</td></tr><tr><td>git commit [file] -m [message]</td><td>提交暂存区的指定文件到本地仓库</td></tr><tr><td>git commit --amend -m [message]</td><td>使用一次新的commit，替代上一次提交</td></tr></tbody></table><h2>2.3 branch</h2><p><img src="http://bloghello.oursnail.cn/zaji17-8.png" alt="image"></p><p>涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git branch</td><td>列出所有本地分支</td></tr><tr><td>git branch -r</td><td>列出所有远程分支</td></tr><tr><td>git branch -a</td><td>列出所有本地分支和远程分支</td></tr><tr><td>git branch [branch-name]</td><td>新建一个分支，但依然停留在当前分支</td></tr><tr><td>git branch -b [branch-name]</td><td>新建一个分支，并切换到该分支</td></tr><tr><td>git branch --track [branch] remote-branch[]</td><td>新建一个分支，与指定的远程分支建立追踪关系</td></tr><tr><td>git checkout [branch-name]</td><td>切换到指定分支，并更新工作区</td></tr><tr><td>git branch -d [branch-name]</td><td>删除分支</td></tr><tr><td>git push origin --delete [branch-name]</td><td>删除远程分支</td></tr></tbody></table><h2>2.4 merge</h2><p><img src="http://bloghello.oursnail.cn/zaji17-10.png" alt="image"></p><p><code>merge</code>命令把不同的分支合并起来。如上图，在实际开放中，我们可能从<code>master</code>分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的<code>commit</code>记录，最后开发完成需要合入<code>master</code>中，这便用到了<code>merge</code>。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git fetch [remote]</td><td>merge之前先拉一下远程仓库最新代码</td></tr><tr><td>git merge [branch]</td><td>合并指定分支到当前分支</td></tr></tbody></table><p>一般在<code>merge</code>之后，会出现<code>conflict</code>，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。</p><p>就是说同一个代码两个人都进行了修改，那么必然需要通过人工的沟通协调最终选择一个统一的版本。</p><h2>2.5 reset</h2><p><img src="http://bloghello.oursnail.cn/zaji17-12.png" alt="image"></p><p>reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git reset --soft [commit]</td><td>只改变提交点，暂存区和工作区的内容都不改变</td></tr><tr><td>git reset --mixed [commit]</td><td>改变提交点，同时改变暂存区的内容</td></tr><tr><td>git reset --hard [commit]</td><td>暂存区和工作区的内容都会被修改到与提交点完全一致的状态</td></tr><tr><td>git reset --hard HEAD</td><td>让工作区回到上次提交的状态</td></tr></tbody></table><p>还有一个叫做<code>git revert</code>,与<code>git reset</code>的区别是：</p><p><img src="http://bloghello.oursnail.cn/zaji17-14.png" alt="image"></p><p><code>git reset</code> 是把<code>HEAD</code>向后移动了一下，而<code>git revert</code>是<code>HEAD</code>继续前进，只是新的<code>commit</code>的内容和要<code>revert</code>的内容正好相反，能够抵消要被<code>revert</code>的内容。</p><h5>2.6 push</h5><p>上传本地仓库分支到远程仓库分支，实现同步。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git push [remote] [branch]</td><td>上传本地指定分支到远程仓库</td></tr><tr><td>git push [remote] --force</td><td>强行推送当前分支到远程仓库，即使有冲突</td></tr><tr><td>git push [remote] --all</td><td>推送所有分支到远程仓库</td></tr></tbody></table><h2>2.7 其他命令</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git status</td><td>显示有变更的文件</td></tr><tr><td>git log</td><td>显示当前分支的版本历史</td></tr><tr><td>git diff</td><td>显示暂存区和工作区的差异</td></tr><tr><td>git diff HEAD</td><td>显示工作区与当前分支最新commit之间的差异</td></tr><tr><td>git cherry-pick [commit]</td><td>选择一个commit合并进当前分支</td></tr></tbody></table><p>整理自：<a href="https://mp.weixin.qq.com/s?__biz=MzUwOTQ1NTAzNA==&amp;mid=2247483714&amp;idx=2&amp;sn=a7893d7306025dc35ca0fb2678003795&amp;chksm=f910be97ce673781f259bb353b3802818eb64e2cb9b06390290374c3d95d139f32d8acb710e8&amp;mpshare=1&amp;scene=1&amp;srcid=1220thpAb37YI9AJFiDH0rMA#rd" target="_blank" rel="noopener">一篇文章让你读懂Git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们对git并不陌生，全球最大的同性交友网站github是程序猿们的最爱，这里只有你想不到的，没有你找不到的，各种资源应有尽有，免去了从浏览器中找到若干垃圾的麻烦。因此熟悉git也成为程序猿标配，本文来简单说说git的基本操作和基本原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(下)</title>
    <link href="http://yoursite.com/2019/03/12/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(%E4%B8%8B)/"/>
    <id>http://yoursite.com/2019/03/12/design-pattern/单例模式(下)/</id>
    <published>2019-03-12T05:54:29.390Z</published>
    <updated>2019-03-12T05:59:06.727Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中简单介绍了几种单例模式的实现，并且简单处理了一下如何抗反序列化，但是路漫漫，反射攻击等还在等着我们，本文深入探讨反射攻击以及枚举单例是如何实现完美单例的。</p><a id="more"></a><h2>一、反射攻击</h2><p>还是以饿汉模式实现的单例模式类来实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法忽略，跟本章无关</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Class objectClass = HungrySingleton.class;</span><br><span class="line">        Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//普通获取的对象</span></span><br><span class="line">        HungrySingleton instance = HungrySingleton.getGetInstance();</span><br><span class="line">        <span class="comment">//根据构造器反射构建的对象</span></span><br><span class="line">        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance == newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，就是通过反射拿到这个类的私有构造器，然后利用这个构造器去创建这个类的对象。运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@1540e19d</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@677327b6</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>那么可以进行反射的一些防御，因为是饿汉，在类加载之后就已经创建好实例对象了，所以我们可以在构造器种进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射调用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: 单例构造器禁止反射调用</span><br></pre></td></tr></table></figure><p>对于声明静态属性或者用静态内部类的这两种方式，因为类加载的时候，实例就会生成好，所以可以用这种方式进行防御。但是对于不是在类加载时期就加载类对象的模式，就不一定行了，跟具体的时序有关（主要看在反射创建对象的时候是不是已经存在了实例对象）。</p><p>即使添加复杂逻辑，比如用标记位来判断等手段都是不行的，因为反射的威力不仅可以修改构造器，还可以修改一个类的属性，所以是没有意义的。</p><h2>二、Enum枚举单例</h2><p>为了解决反射攻击以及序列化反序列化问题，推荐适用枚举单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumInstance &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其进行序列化和反序列化测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        EnumInstance instance = EnumInstance.getInstance();</span><br><span class="line">        instance.setData(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singletonFile"</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"singletonFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        <span class="comment">//获取反序列化后的对象</span></span><br><span class="line">        EnumInstance newInstance = (EnumInstance) ois.readObject();</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(instance.getData());</span><br><span class="line">        System.out.println(newInstance.getData());</span><br><span class="line">        System.out.println(instance.getData() == newInstance.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@378bf509</span><br><span class="line">java.lang.Object@378bf509</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>原理是：还是要看<code>ObjectInputStream</code>对枚举是如何处理的，我们循着这个路径：</p><p>点开<code>(EnumInstance) ois.readObject();</code>中的<code>readObject()</code>方法，显示：</p><p><img src="http://bloghello.oursnail.cn/pattern14-1.png" alt="image"></p><p>点进去，找到枚举这一个类型：</p><p><img src="http://bloghello.oursnail.cn/pattern14-2.png" alt="image"></p><p>点进<code>readEnum</code>这个方法：</p><p><img src="http://bloghello.oursnail.cn/pattern14-3.png" alt="image"></p><p>我们看到是根据枚举的名字来生成枚举对象的，枚举的名字是唯一的，所以反序列化后还是原来的那个对象实例。解决了序列化和反序列化的问题。下面来看看是如何防止反射攻击的：</p><p>我们还是跟以前一样去获取枚举的构造器试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance.class;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>获取构造器的时候直接抛出异常了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br></pre></td></tr></table></figure><p>为什么获取不到枚举的无参构造器呢？</p><p>我们进入Enum源码，发现里面只有一个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就拿这个有参构造器去尝试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance.class;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">EnumInstance instance = (EnumInstance) constructor.newInstance(<span class="string">"swg"</span>,<span class="number">666</span>);</span><br></pre></td></tr></table></figure><p>但是我们会发现，根据构造器去创建实例对象的时候报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br></pre></td></tr></table></figure><p>报错信息说，不能反射创建枚举对象。原因是：</p><p><img src="http://bloghello.oursnail.cn/pattern14-4.png" alt="image"></p><p>判断如果是枚举类型，就抛出这个异常。ok，这里就解决了反射攻击。</p><p>经过jad反编译之后，我们可以看到这个枚举类是一个final类型，表明不能被继承；构造器私有，不能被new，最重要的是，针对我们创建的实例：</p><p><img src="http://bloghello.oursnail.cn/pattern14-5.png" alt="image"></p><p>说明是在类加载的时候就去创建了，类似于饿汉模式。</p><h2>三、容器单例</h2><p>容器启动的时候，可以将一些单例实例放进map中来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInstance</span><span class="params">(String key,Object instance)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断key不为空，instance也不为空</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            map.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在问题，多线程情况下，两个线程t1和t2，t1线程先塞入一个&lt;“key”,1&gt;，此时t2进来，立即塞入同样的&lt;“key”,2&gt;，那么此时t2返回2,t1也会返回1，造成了数据的混乱。</p><h2>四、ThreadLocal</h2><p>本地线程，是线程隔离的，保证一个线程的实例唯一。</p><p>这属于带引号的单例模式，不赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中简单介绍了几种单例模式的实现，并且简单处理了一下如何抗反序列化，但是路漫漫，反射攻击等还在等着我们，本文深入探讨反射攻击以及枚举单例是如何实现完美单例的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(上)</title>
    <link href="http://yoursite.com/2019/03/12/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(%E4%B8%8A)/"/>
    <id>http://yoursite.com/2019/03/12/design-pattern/单例模式(上)/</id>
    <published>2019-03-12T05:51:21.975Z</published>
    <updated>2019-03-12T05:59:04.324Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式看似十分简单，不就是唯一性嘛！但是当单例模式遇上多线程，遇上序列化，遇上反射的时候，一切就变得有点麻烦了，因为单例不仅要在生成的时候全局唯一，也要支持序列化反序列化后的唯一，还需要抵抗住反射的攻击。分为两截文章进行探讨，本文是上篇。</p><a id="more"></a><h2>一、定义</h2><ul><li>保证一个类只有一个实例，并提供一个全局访问点</li><li>创建型</li><li>对于单例的适用场景是不必多说了</li><li>单例模式的优点也是很明显的了：只有一个实例，减少内存开销</li><li>缺点也很明显：不易扩展</li><li>单例的关键词：私有构造器、线程安全、延迟加载、序列化和反序列化安全、防止反射攻击</li></ul><h2>二、懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在线程安全的问题，解决方法是：<code>synchronized</code>，但是这种排队执行，是比较慢的。下面进行优化。</p><h2>三、双重锁检查–禁止指令重排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazyDoubleCheckSingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazyDoubleCheckSingleton();<span class="comment">//2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要用<code>volatile</code>关键字，来防止指令重排序。因为<code>instance = new LazyDoubleCheckSingleton();</code>这一步可以分为三个步骤：</p><ul><li>第一步：分配内存给对象</li><li>第二步：初始化对象</li><li>第三步：设置instance指向刚刚分配的内存地址</li></ul><p>这个时候，第二步和第三步执行顺序可能会被颠倒。</p><p>比如第一个线程t1，进来了，执行new，即先指向内存，但是对象还没有初始化完成，这个时候instance已经不为null，但是还没有初始化成功。</p><p>此时假设恰好t1时间片执行结束，t2进来了，首先判断是否为Null，因为不为null，所以直接返回这个还没有初始化好的instance，这个时候，针对这个线程t2系统就要报异常了。</p><p>此时，t2线程不影响t1线程继续执行，再去初始化一下对象，返回初始化好的instance.</p><p>加上<code>volatile</code>关键字之后，每个线程就都可以看到这个共享内存中的最新状态了，保证了内存可见性。并且禁止指令重排序，不会出现上述指令排序出现的问题。</p><p>用<code>volatile</code>关键字修饰的共享变量，在进行写操作的时候，将当前缓存行的数据写回到系统内存（共享内存）中，这个写回系统内存的操作会使其他线程缓存的这个变量值失效，所以他们需要去系统内存去同步数据。</p><p>这样，既兼顾了性能，又兼顾了线程安全。</p><h2>四、允许重排序–禁止其他线程看到重排序</h2><p>采用静态内部类的方式。原理如下。</p><p>假设有一个类叫A：</p><ul><li>A类实例被创建</li><li>A类中声明的静态方法被调用</li><li>A类中声明的一个静态成员被赋值</li><li>A类中声明的一个静态成员被使用，并且这个成员不是常量成员</li><li>如果A类为顶级类，并且A类中有嵌套的断言语句（不常用）</li></ul><p>根据java语言规范，其中任何一种情况首次发生，这个类就会立即被初始化。</p><p>那么，我们执行<code>InnerClass.instance</code>这句话的时候，就是调用了这个内部类的静态成员，所以此时这个静态内部类立即被初始化。</p><p><img src="http://bloghello.oursnail.cn/patten13-1.png" alt="image"></p><p>JVM在类的初始化阶段（class加载后，线程使用前），这个阶段会执行类的初始化，<strong>JVM会先获取一个锁</strong>，这个锁可以同步多个线程对一个类的初始化，基于这个特性，可以实现基于静态内部类的延迟加载、线程安全的方案。</p><p>那么，由于存在一把初始化锁，只能有一个线程执行初始化，即使静态内部类中存在重排序，也不会有任何问题，因为其他线程压根看不到，进不来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassLazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassLazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassLazySingleton instance = <span class="keyword">new</span> StaticInnerClassLazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取这个单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassLazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>五、饿汉式</h2><p>类加载的时候就完成了初始化，没有延迟加载(final static修饰的变量会在JVM准备阶段就完全确定了)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将初始化对象放到静态块中，达到一样的效果。</p><h2>六、序列化和反序列化破坏单例模式及解决</h2><p>用上一个饿汉来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//获取单例对象</span></span><br><span class="line">    HungrySingleton instance = HungrySingleton.getGetInstance();</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singletonFile"</span>));</span><br><span class="line">    oos.writeObject(instance);</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"singletonFile"</span>);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">//获取反序列化后的对象</span></span><br><span class="line">    HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    System.out.println(instance);</span><br><span class="line">    System.out.println(newInstance);</span><br><span class="line">    System.out.println(instance == newInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@568db2f2</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>反序列化后就破坏了单例。<font color="red">原因是在<code>ObjectInputStream</code>中，有段逻辑判断这个类是不是<code>implements Serializable</code>，是的话就用反射构建的对象，是新的实例。</font></p><p>此时如果将<code>HungrySingleton</code>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新增一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>为什么呢？在上面反序列化的反射过程中生成了一个新的对象obj之后，下面还有一个判断：</p><p><img src="http://bloghello.oursnail.cn/pattern13-2.png" alt="image"></p><p>这里<code>hasReadResolveMethod</code>这个方法，具体如下：</p><p><img src="http://bloghello.oursnail.cn/pattern13-3.png" alt="image"></p><p>就是说，加入这个类实现了序列化接口，并且有<code>readResolve()</code>这个方法，就返回true.</p><p>就会执行下面的<code>desc.invokeReadResolve(obj)</code>这句，这句其实就是利用反射去调用<code>HungrySingleton</code>类中的<code>readResolve()</code>方法，拿到了原来里面的对象实例。所以就解决了这个问题。</p><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式看似十分简单，不就是唯一性嘛！但是当单例模式遇上多线程，遇上序列化，遇上反射的时候，一切就变得有点麻烦了，因为单例不仅要在生成的时候全局唯一，也要支持序列化反序列化后的唯一，还需要抵抗住反射的攻击。分为两截文章进行探讨，本文是上篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题45-扑克牌顺子】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题45-扑克牌顺子】/</id>
    <published>2019-03-12T04:17:37.594Z</published>
    <updated>2019-03-12T04:17:58.116Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十五题。</p><a id="more"></a><h2>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张<sup>_</sup>)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2>解题思路</h2><p>要组成顺子，我们想一想最简单的情况，就是四个王再搭一个任意牌，这五张牌必然是顺子。</p><p>那么到底如何判断是不是顺子呢？</p><p>一个关键点是0的个数，就是王的个数。另一个关键点是非0元素之间的差值和。</p><p>如果这个差值的和大于王的个数，那么王是无法填补里面的间隙的，那么就形不成顺子了。</p><p>下面举个简单的例子。比如有五张牌，分别是1，3，4，5，0，那么0可以作为2，可以作为顺子，此时0 的个数是1，而间隙是(3-1-1)+(4-3-1)+(5-4-1)=1（注意，数组要先排序，所以此时数组是0,1,3,4,5）,而0不要参与计算。此时0的个数为1，差值也为1，所以0可以来填补这个间隙，所以可以作为顺子。</p><p>再来看一个例子：0,0,1,5,6，0的个数为2，间隙为(5-1-1)+(6-5-1)=3,此时3&gt;2，所以无法用0来填补，所以无法构成顺子。</p><p>最后就是注意，如果存在对子，那么肯定就不是顺子了。</p><p>分析完毕。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//零的个数，即王的个数</span></span><br><span class="line">        <span class="keyword">int</span> zeroNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排序后元素之间的差值</span></span><br><span class="line">        <span class="keyword">int</span> gapNum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组排序</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//统计王的个数，统计到一个就重新循环，因为不需要参与后面的差值计算</span></span><br><span class="line">            <span class="comment">//也不需要对比是不是顺子</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是王，并且还是对子，那肯定不是顺子了</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是王，计算一下两两的差值，最后与王的个数做比较</span></span><br><span class="line">            gapNum += numbers[i+<span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//差值小于王的个数，说明可以用王来构成顺子</span></span><br><span class="line">        <span class="keyword">if</span>(gapNum &lt;= zeroNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题44-翻转单词顺序列】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9844-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题44-翻转单词顺序列】/</id>
    <published>2019-03-12T04:17:02.063Z</published>
    <updated>2019-03-12T04:17:22.703Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十四题。</p><a id="more"></a><h2>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h2>解题思路</h2><p>比较简单的思路是从尾到头遍历数组，依次拼接起来。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.trim().length() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] strArr = str.split(<span class="string">" "</span>);</span><br><span class="line">        </span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=strArr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                res += strArr[i] + <span class="string">" "</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += strArr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题43-左旋转字符串】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9843-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题43-左旋转字符串】/</id>
    <published>2019-03-12T04:16:33.394Z</published>
    <updated>2019-03-12T04:16:52.779Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十三题。</p><a id="more"></a><h2>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h2>解题思路</h2><p>我们可以用一个比较巧妙的方法实现这种循环左移，比如将&quot;abc&quot;拼接成&quot;abcabc&quot;，此时如果要循环左移一位，应该变成&quot;bca&quot;，那么我通过截取&quot;abcabc&quot;来获得，怎么截取呢？很简单，就是截取n-n+length这个长度即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制字符串，比如"abc"复制为`abcabc`</span></span><br><span class="line">        String s = str + str;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="comment">//算出偏移量</span></span><br><span class="line">        n = n%len;</span><br><span class="line">        <span class="comment">//开始从n截取，截取到len+n</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(n,len+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题42-和为S的两个数字】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9842-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题42-和为S的两个数字】/</id>
    <published>2019-03-12T04:15:59.338Z</published>
    <updated>2019-03-12T04:16:21.820Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十二题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>输出描述:</p><blockquote><p>对应每个测试案例，输出两个数，小的先输出。</p></blockquote><h2>解题思路</h2><p>满足递增，设两个头尾两个指针i和j，</p><p>若ai + aj == sum，就是答案（相差越远乘积越小）</p><p>若ai + aj &gt; sum，aj肯定不是答案之一（前面已得出 i 前面的数已是不可能），j -= 1</p><p>若ai + aj &lt; sum，ai肯定不是答案之一（前面已得出 j 后面的数已是不可能），i += 1</p><p>第一组符合条件的也是乘积最小的，数学可以证明，所以我们找到第一个即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = array.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[low] + array[high] == sum)&#123;</span><br><span class="line">                res.add(array[low]);</span><br><span class="line">                res.add(array[high]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[low] + array[high] &gt; sum)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题41-和为S的连续正数序列】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9841-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题41-和为S的连续正数序列】/</id>
    <published>2019-03-12T04:15:25.526Z</published>
    <updated>2019-03-12T04:15:48.037Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十一题。</p><a id="more"></a><h2>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p>输出描述:</p><blockquote><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p></blockquote><h2>解题思路</h2><p>可以采取类似于窗口滑动的思想，慢慢找。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小</span></span><br><span class="line">        <span class="keyword">int</span> plow = <span class="number">1</span>,phigh = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(phigh &gt; plow)&#123;</span><br><span class="line">            <span class="comment">//由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2</span></span><br><span class="line">            <span class="keyword">int</span> cur = (phigh + plow) * (phigh - plow + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//相等，那么就将窗口范围的所有数添加进结果集</span></span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=plow;i&lt;=phigh;i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                plow++;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，那么右边窗口右移一下</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; sum)&#123;</span><br><span class="line">                phigh++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，那么左边窗口右移一下</span></span><br><span class="line">                plow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CSS之定位</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之定位/</id>
    <published>2019-03-11T14:04:48.644Z</published>
    <updated>2019-03-11T14:08:18.177Z</updated>
    
    <content type="html"><![CDATA[<p>本文来研究一下第三个重点：定位。</p><a id="more"></a><h2>绝对定位和相对定位</h2><p>绝对定位的主要特性是不占空间。</p><p><img src="http://bloghello.oursnail.cn/html8-1.png" alt="image"></p><p>但是相对定位是占空间的。</p><p><img src="http://bloghello.oursnail.cn/html8-2.png" alt="image"></p><p>我们看到，占用的是原来的空间。说明相对定位的话，原有的空间会给它保留住，实际占用的空间仍然是原来的，而不是现在移动后的。</p><h2>嵌套子元素</h2><p><img src="http://bloghello.oursnail.cn/html8-3.png" alt="image"></p><p>我们可以发现，如果子元素用的是绝对定位，那么定位是跟父元素没有关系的，而是与浏览器边框有关。此时如何做到跟着父元素一起动呢?最简单的方法是将子元素改为相对定位。</p><p>改为相对定位确实可以解决这个问题，但是有的时候我们需要子元素不占用空间，那么怎么办呢？一般情况下，我们给父元素一个定位信息，一般是相对定位，然后子元素是绝对定位，这样子元素就不会占用空间，并且子元素的位置是相对父元素动的。</p><p>为什么父元素要是相对定位呢？因为父元素一般都是需要占用空间的。一举两得，所以口则是子绝父相。</p><p><img src="http://bloghello.oursnail.cn/html8-4.png" alt="image"></p><p>此时就做到子元素相对于父元素定位了。</p><p>固定定位就是<code>fixed</code>，那么网页内容再多一直往下滑，它依然不动。</p><p>简单总结一下，就是相对定位是占空间的，绝对定位是不占空间的。默认情况下，绝对定位是相对于浏览器边框的，但是如果是父子关系，并且父元素设置<code>relative</code>子元素设置<code>absolute</code>的话，子元素就是相对于父元素进行排版。固定定位就是钉死不动。默认情况下是<code>static</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来研究一下第三个重点：定位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
