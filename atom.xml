<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-21T06:11:19.713Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.Ribbon客户端负载均衡</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/2.Ribbon%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/2.Ribbon客户端负载均衡/</id>
    <published>2019-02-21T05:58:39.663Z</published>
    <updated>2019-02-21T06:11:19.713Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。</p><a id="more"></a><h2><font color="#337ab7">一、前言</font></h2><p>Spring Cloud Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具，它基于 Netflix Ribbon 实现。 通过 Spring Cloud 的封装， 可以让我们轻松地将面向服务的 REST 模板请求自动转换成客户端负载均衡的服务调用。Spring Cloud Ribbon 虽然只是一个工具类框架，它不像服务注册中心、 配置中心、 API 网关那样需要独立部署， 但是它几乎存在于每一个Spring Cloud 构建的微服务和基础设施中。 因为微服务间的调用，API 网关的请求转发等内容实际上都是通过Ribbon 来实现的，包括后续我们将要介绍的 Feign, 它也是基于 Ribbon实现的工具。</p><h2><font color="#337ab7">二、Ribbon</font></h2><p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。</p><p>而之前用的nginx来实现负载均衡，他是一种服务端的负载均衡。</p><p>集成Ribbon也是比较简单的。新建一个项目<code>spring-cloud-eureka-ribbon</code></p><h3><font color="#337ab7">2.1 引入依赖：</font></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><font color="#337ab7">2.2 然后就是注册一个专门负载均衡的一个客户端：</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudEurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工程的启动类中,通过<code>@EnableDiscoveryClient</code>向服务中心注册；并且向程序的ioc注入一个<code>bean</code>: <code>restTemplate</code>;并通过<code>@LoadBalanced</code>注解表明这个<code>restRemplate</code>开启负载均衡的功能。</p><h3><font color="#337ab7">2.3 配置文件</font></h3><p>就是向注册中心集群注册而已。所以，上章中提到的Eureka两个服务端要启动起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-ribbon</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br></pre></td></tr></table></figure><h3><font color="#337ab7">2.4 测试的controller</font></h3><p>这个ribbon来接收请求，然后由他来决定转发到哪个服务。</p><p>所以这里要启动起来两个服务，让我来实际调用，我们就给他一个最简单的功能：打印出来端口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hi "</span>+ name +<span class="string">",you are from "</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我的ribbon中写一个controller作为一个统一的入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHelloServie helloServie;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloServie.hiService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的service就是用刚才定义的<code>restTemplate</code>来根据服务实例的名称去发起调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloServie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hiService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://SERVICE-HI/hello?name="</span>+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><font color="#337ab7">2.5 页面测试</font></h3><p>浏览器输入<code>http://localhost:8082/hello?name=sunweiguo</code>，不停地刷新，我们会看到轮流显示：</p><p><code>hi sunweiguo,you are from 8080</code>和<code>hi sunweiguo,you are from 8081</code>这两句，说明负载均衡已经生效，并且算法是轮询。当然，我们也可以用其他的负载均衡算法。这里就不做演示了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>1.Eureka服务治理</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/1.Eureka%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/1.Eureka服务治理/</id>
    <published>2019-02-21T05:22:47.428Z</published>
    <updated>2019-02-21T05:27:16.278Z</updated>
    
    <content type="html"><![CDATA[<p>在上一系列中，我们以最简单的业务场景急速入门了微服务，当然了，忽略了很多的细节，作为入门是可以的，但是真正使用的时候，还是需要了解很多额外的使用知识，所以本系列就孕育而生，即在上一系列的基础上继续强化，加深对spring cloud的使用理解。本章首先还是介绍eureka服务注册和发现组件，因为它是微服务的基石。</p><a id="more"></a><p>关于<code>Eureka</code>的基本使用，在另外一篇文章中详细介绍了：<a href="http://fourcolor.oursnail.cn/2019/02/21/weather-for-spring-cloud/7.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/" target="_blank" rel="noopener">7.天气预报系统-微服务的注册和发现</a>，不再赘述。本章学习如何搭建一个<code>eureka</code>高可用集群。</p><h2><font color="#337ab7">一、前言</font></h2><p>首先来看看<code>Eureka</code>高可用的架构。</p><p><img src="http://bloghello.oursnail.cn/eureka%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="image"></p><p>其中，续约是指：服务端维持一个有过期时间的服务列表，当客户端访问一次，我就刷新一下过期时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 90秒不来续约就剔除</span><br><span class="line">lease-expiration-duration-in-seconds: 90</span><br><span class="line"># 每隔30秒自动续约一次</span><br><span class="line">lease-renewal-interval-in-seconds: 30</span><br></pre></td></tr></table></figure><p>在客户端也可以设置一个定时任务，每隔多长时间去请求一下服务器，刷新一下服务列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认每隔30去请求一下服务器</span><br><span class="line">registry-fetch-interval-seconds: 30</span><br></pre></td></tr></table></figure><h2><font color="#337ab7">二、总结</font></h2><p><code>Eureka</code>包含两个组件：<code>Eureka Server</code> 和 <code>Eureka Client</code>，它们的作用如下：</p><ul><li><code>Eureka Client</code>是一个Java客户端，用于简化与<code>Eureka Server</code>的交互；</li><li><code>Eureka Server</code>提供服务发现的能力，各个微服务启动时，会通过<code>Eureka Client</code>向<code>Eureka Server</code>进行注册自己的信息（例如网络信息），<code>Eureka Server</code>会存储该服务的信息；</li><li>微服务启动后，会周期性地向<code>Eureka Server</code>发送心跳（默认周期为30秒）以续约自己的信息。如果<code>Eureka Server</code>在一定时间内没有接收到某个微服务节点的心跳，<code>Eureka Server</code>将会注销该微服务节点（默认90秒）；</li><li>每个<code>Eureka Server</code>同时也是<code>Eureka Client</code>，多个<code>Eureka Server</code>之间通过复制的方式完成服务注册表的同步；</li><li><code>Eureka Client</code>会缓存<code>Eureka Server</code>中的信息。即使所有的<code>Eureka Server</code>节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。</li></ul><h2><font color="#337ab7">三、集群配置</font></h2><p>Server1端配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8762/eureka</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br></pre></td></tr></table></figure><p>Server2端配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8762</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br></pre></td></tr></table></figure><p>就是说两个<code>server</code>互相注册。形成一个<code>server</code>集群。</p><p>client1配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-client</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br></pre></td></tr></table></figure><p>client2也是如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-client</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br></pre></td></tr></table></figure><p>分别启动之后，我们会看到效果：</p><p><img src="http://bloghello.oursnail.cn/eureka%E9%9B%86%E7%BE%A4%E6%95%88%E6%9E%9C.png" alt="image"></p><p>关于本系列的所有代码，将按照1-10的章节依次存放在：<a href="https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-modules" target="_blank" rel="noopener">https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-modules</a> 后面不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一系列中，我们以最简单的业务场景急速入门了微服务，当然了，忽略了很多的细节，作为入门是可以的，但是真正使用的时候，还是需要了解很多额外的使用知识，所以本系列就孕育而生，即在上一系列的基础上继续强化，加深对spring cloud的使用理解。本章首先还是介绍eureka服务注册和发现组件，因为它是微服务的基石。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>11.天气预报系统-熔断机制</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/11.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/11.天气预报系统-熔断机制/</id>
    <published>2019-02-21T03:28:01.816Z</published>
    <updated>2019-02-21T04:58:12.298Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第十一篇文章，某个服务一旦出现不可用，可能会牵连整个系统造成雪崩，或者有的时候资源需要聚集在核心业务上，非核心业务就可以适当地关闭，此时就是需要有一种机制来实现系统保护和服务降级的功能。本章介绍hystrix组件。</p><a id="more"></a><h2>一、定义</h2><p>保护系统的一种方式，当请求超出阈值，把真实的服务接口断开，可能只是返回给你一个默认值。这样，掐断了自己的服务，又可以给用户一个响应。</p><blockquote><p>对该服务的调用执行熔断，对于后续请求，不再继续调用该目标服务，而是直接返回，从而可以快速释放资源。</p></blockquote><p>熔断器好处：系统稳定、减少性能损耗、及时响应、阈值可配置</p><p>熔断这一概念来源于电子工程中的断路器（Circuit Breaker）。在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。</p><p>这种牺牲局部，保全整体的措施就叫做熔断。</p><p>如果不采取熔断措施，我们的系统会怎样呢？我们来看一个栗子。当前系统中有A，B，C三个服务，服务A是上游，服务B是中游，服务C是下游。它们的调用链如下：</p><p><img src="http://bloghello.oursnail.cn/%E7%86%94%E6%96%AD%E8%A7%A3%E9%87%8A1.png" alt="image"></p><p>一旦下游服务C因某些原因变得不可用，积压了大量请求，服务B的请求线程也随之阻塞。线程资源逐渐耗尽，使得服务B也变得不可用。紧接着，服务A也变为不可用，整个调用链路被拖垮。</p><p><img src="http://bloghello.oursnail.cn/%E7%86%94%E6%96%AD%E8%A7%A3%E9%87%8A2.png" alt="image"></p><p>像这种调用链路的连锁故障，叫做<b>雪崩</b>。</p><p>正所谓刮骨疗毒，壮士断腕。在这种时候，就需要我们的熔断机制来挽救整个系统。</p><p><img src="http://bloghello.oursnail.cn/%E7%86%94%E6%96%AD%E8%A7%A3%E9%87%8A3.png" alt="image"></p><ol><li><strong><font color="red">开启熔断</font></strong>:在固定时间窗口内，接口调用超时比率达到一个阈值，会开启熔断。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的默认方法，达到服务降级的效果。</li><li><strong><font color="red">熔断恢复</font></strong>:熔断不可能是永久的。当经过了规定时间之后，服务将从熔断状态回复过来，再次接受调用方的远程调用。</li></ol><h2>二、熔断和降级</h2><ol><li>在股票市场，熔断这个词大家都不陌生，是指当股指波幅达到某个点后，交易所为控制风险采取的暂停交易措施。相应的，服务熔断一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护。</li><li>大家都见过女生旅行吧，大号的旅行箱是必备物，平常走走近处绰绰有余，但一旦出个远门，再大的箱子都白搭了，怎么办呢？常见的情景就是把物品拿出来分分堆，比了又比，最后一些非必需品的就忍痛放下了，等到下次箱子够用了，再带上用一用。而服务降级，就是这么回事，整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。</li></ol><blockquote><p>降级白话理解：比如在公司 遇到贵宾要来 就把一些不重要的常规接待暂停 把这些资源供给招待贵宾 之前有个淘宝的分享 比如双11 把订单评论和收藏等功能在这一天暂停 把这些资源分给其它关键服务 比如下单</p></blockquote><p>所以从上述分析来看，两者其实从有些角度看是有一定的类似性的：</p><ol><li><strong><font color="red">目的很一致</font></strong>，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；</li><li><strong><font color="red">最终表现类似</font></strong>，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；</li><li><strong><font color="red">粒度一般都是服务级别</font></strong>，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；</li><li><strong><font color="red">自治性要求很高</font></strong>，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；</li></ol><p>而两者的区别也是明显的：</p><ol><li><strong><font color="red">触发原因不太一样</font></strong>，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</li><li><strong><font color="red">管理目标的层次不太一样</font></strong>，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</li></ol><h2>三、Spring Cloud Hystrix</h2><p>Spring Cloud Hystrix是基于Netflix的开源框架Hystrix实现，该框架实现了服务熔断、线程隔离等一系列服务保护功能。对于熔断机制的实现，Hystrix设计了三种状态：</p><p><img src="http://bloghello.oursnail.cn/Hystrix%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.png" alt="image"></p><ol><li><strong><font color="red">熔断关闭状态（Closed）</font></strong>：服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制。</li><li><strong><font color="red">熔断开启状态（Open）</font></strong>：在固定时间窗口内（Hystrix默认是10秒），接口调用出错比率达到一个阈值（Hystrix默认为50%），会进入熔断开启状态。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法。</li><li><strong><font color="red">半熔断状态（Half-Open）</font></strong>：在进入熔断开启状态一段时间之后（Hystrix默认是5秒），熔断器会进入半熔断状态。所谓半熔断就是尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。</li></ol><p>集成Hystrix也是很简单的：</p><p>demo的改造的基础是<code>eureka-client-feign</code>,将其改造为<code>eureka-client-feign-hystrix</code></p><p>1、引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、添加注解@EnableCircuitBreaker，启用Hystrix</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientFeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在controller方法上增加注解@HystrixCommand</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CityClient cityClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"cities"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"defaultCities"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res = cityClient.listCity();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defaultCities</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"City Data Server is down!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><p>启动eureka和城市数据服务，再启动本服务，是正常的。</p><p><img src="http://bloghello.oursnail.cn/hystrix%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F.png" alt="image"></p><p>那么，我们将城市数据服务关闭，看看有没有返回我们指定的默认值。</p><p><img src="http://bloghello.oursnail.cn/hystrix%E6%B5%8B%E8%AF%95%E5%BC%82%E5%B8%B8.png" alt="image"></p><h2>四、改造本系统</h2><p>在demo中，用<code>@HystrixCommand</code>注解中的熔断时执行的方法来实现异常情况下的默认返回。现在我们要改造<code>msa-weather-report-eureka-feign-gateway</code>，将其改造为<code>msa-weather-report-eureka-feign-gateway-hystrix</code>，我们用新的方式，直接在<code>DataClient</code>这个接口里面声明触发熔断时回调的类<code>DataClientFallback.class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"msa-eureka-client-zuul"</span>,fallback = DataClientFallback.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取城市列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"city/cities"</span>)</span><br><span class="line">    <span class="function">List&lt;City&gt; <span class="title">listCity</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据城市ID获取天气</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"data/weather/cityId/&#123;cityId&#125;"</span>)</span><br><span class="line">    <span class="function">WeatherResponse <span class="title">getDataByCityId</span><span class="params">(@PathVariable(<span class="string">"cityId"</span>)</span> String cityId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体这个回调的类里面时这样写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DataClientFallback implements DataClient &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;City&gt; listCity() throws Exception &#123;</span><br><span class="line">        List&lt;City&gt; cityList = new ArrayList&lt;&gt;();</span><br><span class="line">        City city = new City();</span><br><span class="line">        city.setCityId(&quot;101190101&quot;);</span><br><span class="line">        city.setCityName(&quot;默认的南京&quot;);</span><br><span class="line"></span><br><span class="line">        cityList.add(city);</span><br><span class="line">        return cityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public WeatherResponse getDataByCityId(String cityId) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果城市数据服务挂了，就默认返回一下我这里设置的城市；如果获取天气信息的服务挂了，我们就直接返回null;</p><p>那么，我们就相当于在feign中启用hystrix，就需要在配置文件中增加配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><p>因为如果根据城市id获取天气信息的服务不可用时，我们默认直接返回null，显示页面啥都不显示时不好的，所以我们需要在前端判断一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--不为空时--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"$&#123;reportModel.report&#125; != null"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-success"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.city&#125;"</span>&gt;</span>城市名称<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            空气质量指数：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.aqi&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            当前温度：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.wendu&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            温馨提示：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.ganmao&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card  border-info"</span> <span class="attr">th:each</span>=<span class="string">"forecast : $&#123;reportModel.report.forecast&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-body text-info"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.date&#125;"</span>&gt;</span>日期<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text "</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.type&#125;"</span>&gt;</span>天气类型<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.high&#125;"</span>&gt;</span>最高温度<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.low&#125;"</span>&gt;</span>最低温度<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.fengxiang&#125;"</span>&gt;</span>风向<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为空时，说明熔断器生效，直接显示提示信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"$&#123;reportModel.report&#125; == null"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">           天气数据API服务暂不可用！</span><br><span class="line">       <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面就来测试一把吧！</p><p>首先时完全正常的情况，各个服务都可用：</p><p>启动如下服务：redis,<code>weather-sureka-server</code>,<code>msa-weather-city-eureka</code>,<code>msa-weather-collection-eureka-feign-gateway</code>,<code>msa-weather-data-eureka</code>,<code>msa-weather-report-eureka-feign-gateway-hystrix</code>,<code>msa-eureka-client-zuul</code>这六个服务：</p><p><img src="http://bloghello.oursnail.cn/%E9%9B%86%E6%88%90hystrix%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%83%85%E5%86%B5.png" alt="image"></p><p>正常的话，就会看到之前的页面：<a href="http://localhost:8083/report/cityId/101190101" target="_blank" rel="noopener">http://localhost:8083/report/cityId/101190101</a></p><p>城市数据服务不可用，熔断器生效：</p><p>关闭城市数据服务<code>msa-weather-city-eureka</code>，造成服务不可用的现象。看页面显示是否只有我塞进去的假数据。</p><p><img src="http://bloghello.oursnail.cn/%E9%9B%86%E6%88%90hystrix%E7%9A%84%E6%9C%8D%E5%8A%A1-%E6%96%AD%E5%BC%80%E5%9F%8E%E5%B8%82%E6%95%B0%E6%8D%AE.png" alt="image"></p><p>天气数据服务不可用，熔断器生效：</p><p>关闭天气数据API服务<code>msa-weather-data-eureka</code>.看页面是否显示服务暂不可用的提示信息。</p><p>报了一个空指针错误，原因是<code>msa-weather-report-eureka-feign-gateway-hystrix</code>中<code>WeatherReportServiceImpl</code>中的方法原来是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherReportServiceImpl</span> <span class="keyword">implements</span> <span class="title">IWeatherReportService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WeatherClient weatherClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weather <span class="title">getDataByCityId</span><span class="params">(String cityId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weatherClient.getDataByCityId(cityId).getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，要做一下判空操作，否则是不能调用<code>getData()</code>这个方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherReportServiceImpl</span> <span class="keyword">implements</span> <span class="title">IWeatherReportService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataClient dataClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weather <span class="title">getDataByCityId</span><span class="params">(String cityId)</span> </span>&#123;</span><br><span class="line">        WeatherResponse res = dataClient.getDataByCityId(cityId);</span><br><span class="line">        Weather weather = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="keyword">null</span>)&#123;</span><br><span class="line">            weather = res.getData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weather;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，重新启动天气预报UI服务。就可以看到效果啦！</p><p><img src="http://bloghello.oursnail.cn/%E9%9B%86%E6%88%90hystrix%E7%9A%84%E6%9C%8D%E5%8A%A1-%E6%96%AD%E5%BC%80%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1.png" alt="image"></p><p>这样，本系统集成<code>hystrix</code>就成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第十一篇文章，某个服务一旦出现不可用，可能会牵连整个系统造成雪崩，或者有的时候资源需要聚集在核心业务上，非核心业务就可以适当地关闭，此时就是需要有一种机制来实现系统保护和服务降级的功能。本章介绍hystrix组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>10.天气预报系统-集中化配置</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/10.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E9%9B%86%E4%B8%AD%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/10.天气预报系统-集中化配置/</id>
    <published>2019-02-21T03:27:51.810Z</published>
    <updated>2019-02-21T04:56:11.030Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第十篇文章，服务拆分之后，配置文件就必然随着这些拆分的服务分散在各个服务器上，这对运营是一个灾难，用一个集中化的方式统一进行配置文件的配置与修改是必要的。本章介绍spring config的基本使用，但是还是存在一些小问题，在后面的实战环节中会解决。</p><a id="more"></a><h2>一、背景</h2><p>随着线上项目变的日益庞大，每个项目都散落着各种配置文件，如果采用分布式的开发模式，需要的配置文件随着服务增加而不断增多。某一个基础服务信息变更，都会引起一系列的更新和重启，运维苦不堪言也容易出错。配置中心便是解决此类问题的灵丹妙药。</p><p>我们需要一个外部的、集中化的一个配置中心。</p><h2>二、配置分类</h2><ul><li>按配置的来源划分</li></ul><p>主要有源代码、文件、数据库连接、远程调用等</p><ul><li>按配置的环境划分</li></ul><p>主要有开发环境、测试环境、预发布环境、生产环境等。</p><ul><li>按配置的集成阶段划分</li></ul><p>编译时、打包时和运行时</p><ul><li>按配置的加载方式划分</li></ul><p>启动加载和动态加载</p><h2>三、Spring Cloud Config</h2><p>在我们了解<code>spring cloud config</code>之前，我可以想想一个配置中心提供的核心功能应该有什么</p><ul><li>提供服务端和客户端支持</li><li>集中管理各环境的配置文件</li><li>配置文件修改之后，可以快速的生效</li><li>可以进行版本管理</li><li>支持大的并发查询</li><li>支持各种语言</li></ul><p><code>Spring Cloud Config</code>可以完美的支持以上所有的需求。</p><p><strong>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。Spring cloud使用git或svn存放配置文件，默认情况下使用git.</strong></p><p><img src="http://bloghello.oursnail.cn/springcloudconfig%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="image"></p><h2>Server端</h2><p>注册到<code>eureka</code>的实例名：<code>weather-config-server</code></p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: weather-config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https://github.com/sunweiguo/spring-cloud-config-center</span><br><span class="line">          search-paths: config-repo</span><br><span class="line">          username: sunweiguo</span><br><span class="line">          password: xxx</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br><span class="line">server:</span><br><span class="line">  port: 8086</span><br></pre></td></tr></table></figure><p><code>config-repo</code>这个文件夹是由自己在github上创建的。在这个目录下新建一个文件：<code>weather-config-client-dev.properties</code>,里面的内容为<code>auther=oursnail.cn</code>(随便写点东西以供测试)</p><blockquote><p>仓库中的配置文件会被转换成web接口，访问可以参照以下的规则：</p><p>/{application}/{profile}[/{label}]</p><p>/{application}-{profile}.yml</p><p>/{label}/{application}-{profile}.yml</p><p>/{application}-{profile}.properties</p><p>/{label}/{application}-{profile}.properties</p></blockquote><p>我这里的<code>weather-config-client-dev.properties</code>,它的<code>application</code>是<code>weather-config-client</code>，<code>profile</code>是<code>dev</code>。<code>client</code>会根据填写的参数来选择读取对应的配置。</p><p><img src="http://bloghello.oursnail.cn/github%E4%BB%93%E5%BA%93%E9%87%8C%E7%9A%84springconfig%E7%9A%84%E5%80%BC.png" alt="image"></p><p>3、启动类</p><p>启动类添加<code>@EnableConfigServer</code>，激活对配置中心的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherEurekaClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WeatherEurekaClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此server端相关配置已经完成</p><p>4、测试</p><p>访问 <a href="http://localhost:8086/auther/dev" target="_blank" rel="noopener">http://localhost:8086/auther/dev</a> 返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;auther&quot;,</span><br><span class="line">&quot;profiles&quot;: [</span><br><span class="line">&quot;dev&quot;</span><br><span class="line">],</span><br><span class="line">&quot;label&quot;: null,</span><br><span class="line">&quot;version&quot;: &quot;ef1a6baeddce01d3956ba2a7181f66721959a10c&quot;,</span><br><span class="line">&quot;state&quot;: null,</span><br><span class="line">&quot;propertySources&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以读到<code>auther</code>里的内容，说明服务端配置成功。</p><h2>四、Client端</h2><p>注册到<code>eureka</code>的实例名：<code>weather-config-client</code></p><p>1、添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>2、配置文件</p><p>需要配置两个配置文件，<code>application.properties</code>和<code>bootstrap.properties</code></p><p><code>application.properties</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=weather-config-client</span><br><span class="line">server.port=8087</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.defaultZone: http://localhost:8761/eureka</span><br></pre></td></tr></table></figure><p><code>bootstrap.properties</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.config.name=weather-config-client</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">spring.cloud.config.uri=http://localhost:8086/</span><br><span class="line">spring.cloud.config.label=master</span><br></pre></td></tr></table></figure><p><code>spring.application.name</code>：对应<code>{application}</code>部分</p><p><code>spring.cloud.config.profile</code>：对应<code>{profile}</code>部分</p><p><code>spring.cloud.config.label</code>：对应git的分支。如果配置中心使用的是本地存储，则该参数无用</p><p><code>spring.cloud.config.uri</code>：配置中心的具体地址,就是server端地址</p><blockquote><p>特别注意：上面这些与spring-cloud相关的属性必须配置在bootstrap.properties中，config部分内容才能被正确加载。因为config的相关配置会先于application.properties，而bootstrap.properties的加载也是先于application.properties。</p></blockquote><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherEurekaClientApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;auther&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String auther;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">"oursnail.cn"</span>,auther);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果测试通过，那么获取内容成功。</p><p>但是我们通过网页的方式进行测试，我们会发现修改了github上的内容后，网页上的内容是不能立即刷新的。这比较头疼，可以通过一些途径去解决。这个自动刷新问题会在后面的实战项目中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;auther&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String auther;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> auther;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第十篇文章，服务拆分之后，配置文件就必然随着这些拆分的服务分散在各个服务器上，这对运营是一个灾难，用一个集中化的方式统一进行配置文件的配置与修改是必要的。本章介绍spring config的基本使用，但是还是存在一些小问题，在后面的实战环节中会解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>9.天气预报系统-API网关</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/9.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-API%E7%BD%91%E5%85%B3/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/9.天气预报系统-API网关/</id>
    <published>2019-02-21T03:27:40.435Z</published>
    <updated>2019-02-21T04:53:25.736Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第九篇文章，服务的注册、发现和消费都解决了，小系统就可以跑起来了，但是对于复杂的系统，一个统一的入口是必要的，下面将介绍网关是什么，它的重要性，并且介绍zuul组件的使用。</p><a id="more"></a><h2>一、背景</h2><p>理论上，客户端可以直接向微服务发送请求，每个微服务都有一个公开的URL，该URL将映射到微服务的负载均衡器，由它负责在可用实例之间分发请求。</p><p>但是我们知道在微服务架构风格中，一个大应用被拆分成为了多个小的服务系统提供出来，这些小的系统他们可以自成体系，也就是说这些小系统可以拥有自己的数据库，框架甚至语言等，这些小系统通常以提供 Rest Api 风格的接口来被 H5, Android, IOS 以及第三方应用程序调用。</p><p>但是在UI上进行展示的时候，我们通常需要在一个界面上展示很多数据，这些数据可能来自于不同的微服务中，举个例子。</p><p>在一个电商系统中，查看一个商品详情页，这个商品详情页包含商品的标题，价格，库存，评论等，这些数据对于后端来说可能是位于不同的微服务系统之中，可能我后台的系统是这样来拆分我的服务的：</p><p>产品服务 - 负责提供商品的标题，描述，规格等。<br>价格服务 - 负责对产品进行定价，价格策略计算，促销价等。<br>库存服务 - 负责产品库存。<br>评价服务 - 负责用户对商品的评论，回复等。<br>现在，商品详情页需要从这些微服务中拉取相应的信息，问题来了:</p><p>由于我们使用的服务系统架构，所以没办法像传统单体应用一样依靠数据库的 join 查询来得到最终结果，那么如何才能访问各个服务呢？这里就会引出以下几个问题：</p><h3>1. 客户端需求和微服务暴露的细粒度 API 不匹配</h3><p>经常有一个业务调用很多个服务，假如客户端发送许多请求，这在公网上可能会很低效，而且会使客户端代码变得更复杂。</p><h3>2. 服务使用的协议不是 Web 友好的</h3><p>有的服务可能使用二进制 RPC（比如 thrift），有的服务可能使用 AMQP 消息传递协议。不管哪种协议都不是浏览器友好或防火墙友好的，最好是内部使用。在防火墙之外，应用程序应该使用诸如 HTTP 和 WebSocket 之类的协议。</p><h3>3. 难重构</h3><p>随着时间推移可能想要更改系统划分成服务的方式。例如，合并两个服务或者将一个服务拆分成两个或更多服务。如果客户端与微服务直接通信，那么执行这类重构就很困难。</p><p>由于以上问题，客户端与微服务直接通信很少是合理的，更好的方法是使用 API 网关，由 API 网关作为后端服务系统的唯一入口。它封装了系统内部架构，为每个客户端提供一个定制的 API 。由它负责服务请求路由、组合及协议转换。有的 API 网关还有其它职责，如身份验证、监控、负载均衡、缓存等。</p><h2>二、API 网关</h2><blockquote><p>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。<br>API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。</p></blockquote><h3>单节点网关</h3><p><img src="http://bloghello.oursnail.cn/%E5%8D%95%E8%8A%82%E7%82%B9%E7%BD%91%E5%85%B3.png" alt="image"></p><h3>Backends for frontends 网关</h3><p><img src="http://bloghello.oursnail.cn/Backends%20for%20frontends%20%E7%BD%91%E5%85%B3.png" alt="image"></p><h2>三、API 网关的优缺点</h2><h3>1. 优点</h3><p>封装了应用程序的内部结构。客户端只需要同网关交互，而不必调用特定的服务（<strong>统一API入口</strong>）。API 网关为每一类客户端提供了特定的 API ，从而减少客户端与应用程序间的交互次数，简化客户端代码的处理（<strong>集合多个API</strong>）。</p><p>另外，可以避免内部信息泄露给外部。可以为微服务添加额外的安全层。支持混合通信协议。降低构建微服务的复杂性。</p><h3>2. 缺点</h3><p>增加了一个必须开发、部署和维护的高可用组件。还有一个风险是 API 网关变成了开发瓶颈。为了暴露每个微服务，开发人员必须更新 API 网关。API 网关的更新过程要尽可能地简单，否则为了更新网关，开发人员将不得不排队等待。不过，虽然有这些不足，但对于大多数现实世界的应用程序而言使用 API 网关是合理的。（<strong>在架构上需要额外考虑更多编排和管理；路由逻辑配置要进行统一的管理；可能引发单点故障</strong>）</p><h2>四、参考实现方案</h2><p>以上列出在 DIY 这个 API 网关时需要考虑的点，以及参考的技术实现。下面是几种目前比较流行的 API 网关搭建的技术方案供参考，后续文章将给出这些方案搭建的例子</p><p>1）Nginx + Lua实现负载均衡、限流、服务发现等功能</p><p>2）使用 spring cloud 技术栈，其中 zuul 就是用作 API 网关的</p><p>3）Mashape 的开源 API 网关 Kong</p><p>本次，使用<code>zuul</code>作为API网关。</p><h2>五、Zuul</h2><p>功能：认证、压测、金丝雀测试、动态路由、负载削减、安全、静态相应处理…</p><p><font color="red">注意：因为我到目前为止，springboot用的版本是2.1.x，但是呢，集成zuul的时候报错，查了一下，是zuul还不支持2.1.x的版本，所以我将demo:<code>weather-eureka-client=zuul</code>降级到了2.0.3版本。启动成功并且测试成功</font></p><p>首先是准备拿出之前的两个项目：<code>weather-eureka-server</code>和<code>weather-eureka-client</code>，启动，一个地址是8671，一个地址我设定为8081,基于<code>weather-eureka-client</code>新建一个项目：<code>weather-eureka-client-zuul</code>，改动如下：</p><p>首先将springboot版本降到2.0.x版本。在启动类上增加注解：<code>@EnableZuulProxy</code>，在yml文件中新增：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    hi:</span><br><span class="line">      path: /hi/**</span><br><span class="line">      serviceId: weather-eureka-client</span><br></pre></td></tr></table></figure><p>这里的含义是：定义一个名字叫做<code>hi</code>的路由规则（自定义），我们访问<code>/hi/**</code>这个路径的时候，就会转发到<code>weather-eureka-client</code>这个服务下的<code>**</code>路径。</p><p>比如我这里的<code>weather-eureka-client</code>有一个controller路径为&quot;hello&quot;，调用<code>localhost:8081/hello</code>就可以返回一个字符串。那么有了<code>zuul</code>配置之后，我可以访问<code>localhost:8082/hi/hello</code>也可以访问到这个路径了。</p><p>改造本系统：</p><p>新建一个项目：<code>msa-eureka-client-zuul</code>。主要是定义网关的路由。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: msa-eureka-client-zuul</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br><span class="line"># 一个是msa-weather-data-eureka，一个是msa-weather-ciy-eureka</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    city:</span><br><span class="line">      path: /city/**/</span><br><span class="line">      serviceId: msa-weather-city-eureka</span><br><span class="line">    data:</span><br><span class="line">      path: /data/**/</span><br><span class="line">      serviceId: msa-weather-data-eureka</span><br><span class="line">server:</span><br><span class="line">  port: 8085</span><br></pre></td></tr></table></figure><p>ok，下面我们就修改<code>msa-weather-collection-cureka-feign</code>和<code>msa-weather-report-feign</code>.复制为新的项目：<code>msa-weather-collection-cureka-feign-zuul</code>和<code>msa-weather-report-feign-zuul</code></p><p>以<code>msa-weather-report-feign-zuul</code>为例，其实他依托于两个服务:<code>msa-weather-data-eureka</code>和<code>msa-weather-ciy-eureka</code>，这两个我们只需要写在一个接口内，调用网关里定义的路由即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"msa-eureka-client-zuul"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取城市列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"city/cities"</span>)</span><br><span class="line">    <span class="function">List&lt;City&gt; <span class="title">listCity</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据城市ID获取天气</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"data/weather/cityId/&#123;cityId&#125;"</span>)</span><br><span class="line">    <span class="function">WeatherResponse <span class="title">getDataByCityId</span><span class="params">(@PathVariable(<span class="string">"cityId"</span>)</span> String cityId)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，这个<code>DataClient</code>就取代了之前的<code>cityClient</code>和<code>WeatherClient</code>。改造完成。</p><p>测试无问题。</p><p><img src="http://bloghello.oursnail.cn/%E9%9B%86%E6%88%90zuul%E6%B5%8B%E8%AF%95.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第九篇文章，服务的注册、发现和消费都解决了，小系统就可以跑起来了，但是对于复杂的系统，一个统一的入口是必要的，下面将介绍网关是什么，它的重要性，并且介绍zuul组件的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>8.天气预报系统-微服务的消费</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/8.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B6%88%E8%B4%B9/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/8.天气预报系统-微服务的消费/</id>
    <published>2019-02-21T03:27:31.800Z</published>
    <updated>2019-02-21T05:26:17.654Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第八篇文章，在解决了服务注册和发现两个问题之后，就要解决服务消费问题了。本节介绍feign的使用。</p><a id="more"></a><h2><font color="#337ab7">1.发现模式</font></h2><p>直连模式：</p><p>直接去连接某个url，比较简单粗暴，但是不能实现负载均衡和高可用，使用比较少。</p><p>客户端发现模式：</p><ul><li>服务实例启动后，将自己的位置信息提交到服务注册表</li><li>客户端从服务注册表进行查询，来获取可用的服务实例</li><li>客户端自行使用负载均衡算法从多个服务实例中选择一个</li></ul><p><img src="http://bloghello.oursnail.cn/18-11-23/96879161.jpg" alt="image"></p><p>服务端发现模式：</p><p>负载均衡的实现在服务端。而客户端发现模式的负载均衡由客户端来实现。</p><h2><font color="#337ab7">2.服务的消费者</font></h2><p><code>Apache HttpClient</code>：这个比较简单，不再赘述。</p><p><code>Ribbon</code>: 基于客户端负载均衡工具。可以基于Http或者Tcp实现负载均衡。</p><p>直接根据服务的名字来消费，具体是连到哪一个具体的ip去消费是不用管的，因为他已经在客户端上做了一定的负载均衡算法，由他的算法来决定。</p><p><code>Febin</code>:</p><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p><p>我们先来搞个demo测试一把！</p><h2><font color="#337ab7">3.Demo for Feign</font></h2><p>首先，我们之前的工作中已经由了一个<code>Eureka server</code>，再拿一个叫做<code>msa-weather-city-server</code>的服务来测试。这个服务的主要功能是获取城市信息。</p><h4>3.1 引入依赖、添加注解</h4><p>首先引入feign依赖，注意这里有个坑，我一开始没有指定版本号，死活无法导入<code>@EnableFeignClients</code>这个注解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientFeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>3.2 配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-weather-feign</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      feignName:</span><br><span class="line">        connectTimeout: 5000</span><br><span class="line">        readTimeout: 5000</span><br></pre></td></tr></table></figure><h4>3.3 定义feign接口</h4><p>定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务。比如在代码中调用了<code>msa-weather-city-eureka</code>服务的“/cities”接口来获取所有的城市列表，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"msa-weather-city-eureka"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cities"</span>)</span><br><span class="line">    <span class="function">String <span class="title">listCity</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>3.4 定义API来供浏览器调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CityClient cityClient;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"cities"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res = cityClient.listCity();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，启动服务中心<code>Eureka server</code>和服务提供方<code>msa-weather-city-server</code>以及本消费服务。再浏览器中访问对应的url：<a href="http://localhost:8080/cities%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E5%88%B0" target="_blank" rel="noopener">http://localhost:8080/cities就可以调用到</a><code>msa-weather-city-server</code>提供的服务。</p><p>至此，demo演示完毕。</p><h2><font color="#337ab7">4.用Feign继续完善天气项目</font></h2><p>有三个<code>TODO</code>项：</p><ul><li>数据采集微服务在天气数据同步任务中，依赖于城市数据API微服务</li><li>天气预报微服务查询天气信息，依赖于天气数据API微服务</li><li>天气预报微服务提供的城市列表，依赖于城市数据API微服务</li></ul><p>那么我们可以看出来，需要去集成Feign去消费的微服务只有两个：<code>msa-weather-collection-eureka</code>和<code>msa-weather-report-eureka</code>。我们将其改造为：<code>msa-weather-collection-eureka-feign</code>和<code>msa-weather-report-eureka-feign</code>.</p><p>这里就以<code>msa-weather-collection-eureka</code>为例，步骤基本与demo一样。首先是引入依赖，然后加上注解开启Feign功能。新建一个接口，还是获取城市列表。我只要指定好那个城市列表的微服务的名字和路径，就可以获取到了。不清楚直接看代码即可。</p><p><font color="red">那么在全部改好之后，我们启动这五个项目。但是我们要注意，先启动<code>weather-eureka-server</code>，来提供注册的服务。然后启动城市数据服务，因为天气数据采集要用到他。然后启动天气数据采集服务。然后一次启动天气数据API服务和天气预报UI显示服务。</font></p><p>那么我们访问天气预报UI对应的URL,以南京为例：<br><code>http://localhost:8083/report/cityId/101190101</code>，如果功能是正常的，标识微服务改造初步成功。</p><p><img src="http://bloghello.oursnail.cn/18-11-23/44111959.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第八篇文章，在解决了服务注册和发现两个问题之后，就要解决服务消费问题了。本节介绍feign的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>7.天气预报系统-微服务的注册和发现</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/7.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/7.天气预报系统-微服务的注册和发现/</id>
    <published>2019-02-21T03:27:23.002Z</published>
    <updated>2019-02-21T05:25:42.657Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第七篇文章，首先要解决的问题是服务注册和发现。本节介绍eureka的使用。</p><a id="more"></a><h2>1.什么是spring cloud</h2><p><code>Spring Cloud</code>是一系列框架的有序集合。它利用<code>Spring Boot</code>的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用<code>Spring Boot</code>的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过<code>Spring Boot</code>风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p>微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，<code>spring cloud</code>就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，<code>spring cloud</code>做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。</p><p>解决了分布式系统中的一些问题:配置管理、服务注册、服务发现、断路器、智能路由、负载均衡、服务间调用、一次性令牌、全局锁、领导选举、控制总线、思维导图、分布式会话、集群状态、分布式消息。。。</p><h2>2.spring cloud &amp; spring boot</h2><ul><li>SpringBoot是构建spring cloud架构的基石</li></ul><h2>3.spring cloud子项目</h2><p>参考这篇文章：<a href="http://www.ityouknow.com/springcloud/2017/05/01/simple-springcloud.html" target="_blank" rel="noopener">springcloud(一)：大话Spring Cloud</a></p><h2>4.Eureka</h2><h4>4.1.服务中心</h4><p>服务中心又称注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等，比如<code>dubbo admin</code>后台的各种功能。</p><p>有了服务中心调用关系会有什么变化，画几个简图来帮忙理解.</p><p>项目A调用项目B</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">项目A--&gt;项目B</span><br></pre></td></tr></table></figure><p>有了服务中心之后，任何一个服务都不能直接去掉用，都需要通过服务中心来调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">项目A--&gt;注册中心再去访问项目B</span><br></pre></td></tr></table></figure><p>由于各种服务都注册到了服务中心，就有了去做很多高级功能条件。比如几台服务提供相同服务来做均衡负载；监控服务器调用成功率来做熔断，移除服务列表中的故障点；监控服务调用时间来对不同的服务器设置不同的权重等等。</p><h4>4.2.Eureka</h4><ul><li><code>Spring Cloud</code> 封装了 <code>Netflix</code> 公司开发的 <code>Eureka</code> 模块来实现服务注册和发现。</li><li><code>Eureka Server</code> 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 <code>Eureka</code> 的客户端连接到 <code>Eureka Server</code>，并维持心跳连接。</li><li>这样系统的维护人员就可以通过 <code>Eureka Server</code> 来监控系统中各个微服务是否正常运行。</li><li><code>Spring Cloud</code> 的一些其他模块（比如<code>Zuul</code>）就可以通过 <code>Eureka Server</code> 来发现系统中的其他微服务，并执行相关的逻辑。</li><li>Eureka由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li></ul><p><img src="http://bloghello.oursnail.cn/18-11-22/15609057.jpg" alt="image"></p><p>其中有三个角色：</p><ul><li><code>Eureka Server</code>：提供服务注册和发现</li><li><code>Service Provider</code>服务提供方，将自身服务注册到<code>Eureka</code>，从而使服务消费方能够找到</li><li><code>Service Consumer</code>：服务消费方，从<code>Eureka</code>获取注册服务列表，从而能够消费服务</li></ul><h4>4.3.Eureka Server</h4><p>新建一个springboot项目。spring cloud已经帮我实现了服务注册中心，我们只需要很简单的几个步骤就可以完成。</p><p>演示的springboot版本是最新的<code>&lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</code>,springcloud也是最新的<code>&lt;version&gt;Finchley.RELEASE&lt;/version&gt;</code></p><p>1、pom中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Eureka server--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、添加启动代码中添加@EnableEurekaServer注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherEurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WeatherEurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、配置文件</p><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，在application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></pre></td></tr></table></figure><ul><li><code>eureka.client.register-with-eureka</code> ：表示是否将自己注册到Eureka Server，默认为true。</li><li><code>eureka.client.fetch-registry</code> ：表示是否从Eureka Server获取注册信息，默认为true。</li><li><code>eureka.client.serviceUrl.defaultZone</code> ：设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。</li><li></li></ul><p>启动工程后，访问：<a href="http://localhost:8761/" target="_blank" rel="noopener">http://localhost:8761/</a> ，可以看到下面的页面，其中还没有发现任何服务</p><p><img src="http://bloghello.oursnail.cn/18-11-22/31605865.jpg" alt="image"></p><h4>4.4.Eureka Client</h4><p>基本与上一个是类似的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br></pre></td></tr></table></figure><p>主要的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: weather-eureka-client</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br></pre></td></tr></table></figure><p>这样同时启动<code>Eureka Server</code>和<code>Eureka Client</code>两个工程。在网站中输入<code>localhost://8761</code>就可以看到注册到<code>Eureka Server</code>的实例了。</p><h2>5.本门实战</h2><p>将之前的四个微服务改造为eureka的客户端。</p><p>即将</p><p><code>mas-weather-collection-server</code></p><p><code>mas-weather-report-server</code></p><p><code>mas-weather-data-server</code></p><p><code>mas-weather-city-server</code></p><p>改为：</p><p><code>mas-weather-collection-eureka</code></p><p><code>mas-weather-report-eureka</code></p><p><code>mas-weather-data-eureka</code></p><p><code>mas-weather-city-eureka</code></p><p>改造过程十分简单，就是引入依赖，修改配置即可。</p><p>同时启动这四个微服务客户端和一个eureka服务端。</p><p>我们可以看到：</p><p><img src="http://bloghello.oursnail.cn/18-11-23/81797360.jpg" alt="image"></p><p>电脑要爆炸了~~~~~~</p><p>下面，这些微服务之间可以相互访问了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第七篇文章，首先要解决的问题是服务注册和发现。本节介绍eureka的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>6.天气预报系统-拆分本系统</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/6.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E6%8B%86%E5%88%86%E6%9C%AC%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/6.天气预报系统-拆分本系统/</id>
    <published>2019-02-21T03:27:13.131Z</published>
    <updated>2019-02-21T04:49:51.801Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第六篇文章，先初步拆分本系统为四个服务，还没有进行服务治理等，只是简单的业务拆分，为下一步做准备。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/%E5%9B%9B%E4%B8%AA%E5%BE%AE%E6%9C%8D%E5%8A%A1.png" alt="image"></p><h2>天气数据采集微服务</h2><p>这个微服务专门提供数据采集和定时更新功能，将数据存储在redis中。</p><p><img src="http://bloghello.oursnail.cn/msa-weather-collection-server.png" alt="image"></p><p>该服务的核心service中的方法是：<code>syncDataByCityId</code>，就是根据<code>cityId</code>来将数据同步进redis。</p><p>代码：<a href="https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/06/msa-weather-collection-server" target="_blank" rel="noopener">https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/06/msa-weather-collection-server</a></p><h2>天气数据API</h2><p>这个服务专门来提供天气数据的查询功能。</p><p>将前端页面以及定时、城市相关的代码全部剔除。只留下两个API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WeatherResponse <span class="title">getDataByCityId</span><span class="params">(String cityId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">WeatherResponse <span class="title">getDataByCityName</span><span class="params">(String cityName)</span></span>;</span><br></pre></td></tr></table></figure><p>代码：<a href="https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/06/msa-weather-data-server" target="_blank" rel="noopener">https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/06/msa-weather-data-server</a></p><h2>天气预报微服务</h2><p>本服务的主要功能为：用户通过浏览器来访问，可以返回一个天气预报的界面。</p><p>就将redis和定时任务相关的都删掉。我们只需要一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Weather <span class="title">getDataByCityId</span><span class="params">(String cityId)</span></span>;</span><br></pre></td></tr></table></figure><p>因为展示数据需要用到城市信息，但是此时还没有，所以需要自己去模拟一些数据去显示。</p><p>代码：<a href="https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/06/msa-weather-report-server" target="_blank" rel="noopener">https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/06/msa-weather-report-server</a></p><h2>城市数据API</h2><p>本服务只提供城市列表数据功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;City&gt; <span class="title">listCity</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>有的需要填充一些假数据之后，都可以独立运行。</p><p>代码：<a href="https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/06/msa-weather-city-server" target="_blank" rel="noopener">https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/06/msa-weather-city-server</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第六篇文章，先初步拆分本系统为四个服务，还没有进行服务治理等，只是简单的业务拆分，为下一步做准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>5.天气预报系统-服务拆分和业务建模</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/5.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%92%8C%E4%B8%9A%E5%8A%A1%E5%BB%BA%E6%A8%A1/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/5.天气预报系统-服务拆分和业务建模/</id>
    <published>2019-02-21T03:27:04.094Z</published>
    <updated>2019-02-21T04:36:58.528Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第五篇文章，在进行真正的业务拆分之前，我们来认识一下什么是SOA架构，什么是微服务。确定本系统拆分的几个部分。</p><a id="more"></a><h2>单体架构</h2><p>我们熟悉的单体MVC架构：</p><p>用户&lt;—&gt;表示层&lt;—&gt;业务层&lt;—&gt;数据访问层&lt;—&gt;数据库</p><p>单块结构的优缺点：</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>功能划分清楚</td><td>功能仍然太大</td></tr><tr><td>层次关系良好</td><td>支付周期变长</td></tr><tr><td>每一层独立</td><td>升级风险高</td></tr><tr><td>部署简单</td><td>维护成本增加</td></tr><tr><td>技术单一</td><td>可伸缩性差</td></tr><tr><td>用人成本低</td><td>监控困难</td></tr></tbody></table><h2>单体架构如何转化为微服务</h2><h4>什么是SOA？</h4><blockquote><p>SOA是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非采用进程内调用的方式进行通信。</p></blockquote><p>所以，<code>SOA</code>只是一种架构设计模式，<code>SOAP</code>，<code>REST</code>，<code>RPC</code>是根据这种设计模式构建出来的规范。其中<code>SOAP</code>通俗理解就是<code>http+xml</code>的形式，<code>REST</code>就是<code>http+json</code>的形式，<code>RPC</code>是基于<code>socket</code>的形式。<code>dubbo</code>就是典型的<code>RPC</code>框架，而<code>SpringCloud</code>就是遵守<code>REST</code>规范的生态系统。</p><h4>SOA VS 微服务</h4><blockquote><p>话说1979年，又是一个春天，莆田乡下的赤脚医生吴大牛被改革的春风吹的心潮澎湃，说干就干，吴大牛趁着夜色朦胧找大队支书汇报了汇报思想，第二天就承包了村卫生室，开启了自己的在医疗圈的传奇历程。</p><p>乡村诊所大家都知道，没什么复杂的东东，房子只有一间，一个大柜台中间隔开，一半是诊疗兼候诊区，一半是药房，看病就直接找医生，如果前面有人就自己找个位子坐下，排队等一会，秩序倒也井然，看完病了医生直接给抓药，然后下一个继续，也不需要护士和药剂师，吴大牛一个人全部包办。</p><p>辛辛苦苦忙碌了十年，时间来到了八九年，又是一个春天，昔日的单身汉吴大牛已成为十里八乡的知名人物，媳妇娶上了不说，家里还增加了一对双胞胎儿子，二层的小洋房也甚是气派。可是也有烦心事，尽管乡村诊所扩大到了两间，媳妇还偶尔能去帮帮忙，但是医生还是只有自己一个，天天从早忙到晚挣的都是一份钱，想多挣点怎么办？吴大牛日思夜想，还真给他想出来一招，怎么办，扩大规模，多招几个医生一起干。原来吴大牛只能治头疼脑热和跌打损伤，现在新招了一个医科大学的毕业生刘小明专治感冒发烧，又从邻村请来了老大夫李阿花专治妇科病，现在一个普通的小诊所就变成了有三个独立科室加一个公共药房（吴大牛媳妇负责）的小医院了，吴大牛是外科主任兼院长，收入那可比之前翻了三番。人逢喜事精神爽，大牛院长请县里的书法名家为新医院书写了牌匾–“博爱医院”，挑了一个黄道吉日正式挂了上去。</p><p>一晃十年过去了，又是一个春天，吴大牛的博爱医院已经发展到了内科外科妇科五官科骨科生殖科六个科室，每个科室3到5名医生不等，也耗费巨资购进了血夜化验B超等先进仪器，大牛院长也早已脱离了医疗一线，成为了专职的管理者，但是医院的大事小事大家都找他，就这三十多号员工搞的他每天是焦头烂额，想再扩大规模实在是有心无力了。要说还是大学生有水平，老部下刘小明给大牛院长献了一计，把各个科室独立出去，让各个科室主任自己管理，大牛院长只管科室之间的协调和医院发展的大事，这样既能调动基层的积极性，又能把大牛院长解放出来扩大生产抓大事谋大事，岂不妙哉？就这样，博爱医院的新一轮改革轰轰烈烈的展开了。</p><p>又是一个十年，又是一个春天，大牛院长已成为本地知名的企业家，博爱医院也发展到了二十三个科室数百名员工，发展中也出现了新问题，由于各个科室独立挂号、收费、化验，有的科室整天忙忙碌碌效益好，有的科室就相对平庸些，连分到的各种检查仪器都不能满负荷运行，整个医院养了不少闲人。这时候大牛院长视野也开阔了，请来了管理专家进行了顶层设计，把原来分散到各个科室的非核心服务全部收归集中管理，把原来二十三个挂号窗口整合为十个，二十三个收费窗口整合为八个，集中布设在一楼大厅为全院服务，还把分散在各个科室的检查仪器集中起来成立独立的检验科，也为全院服务，这样人人有活干，整个医院的服务能力又上了一个新台阶，这轮改革后博爱医院通过了各级部门的鉴定成为了远近驰名的三甲医院，吴大牛也换身一变成为了博爱集团的CEO兼董事长，下一步就准备IPO上市了。</p><p>说到这里大家可能有点糊涂，这个跟微服务有嘛关系？在孙老师看来，大牛诊所的1.0阶段就相当于软件开发的单体结构，一个程序员打天下，从头编到尾，很难做大做强。大牛诊所的2.0阶段就相当于软件开发的垂直结构，各科室按照业务划分，很容易横向扩展。博爱医院的1.0阶段就相当于软件开发的SOA结构，除了药房（数据库）外各个服务独立提供（科室主任负责），但需要大牛院长（ESB总线）来协调。博爱医院的2.0阶段就相当于软件开发的微服务结构，公共服务院内共享，科室主任管理功能弱化（只管医生业务），优点是扩容方便，哪个部门缺人直接加，不用看上下游，资源利用率高，人员和设备效率高。为什么要变呢？小诊所有小诊所的活法，大医院有大医院的骄傲。无他，天下熙熙，皆为利来；天下攘攘，皆为利往。</p></blockquote><h4>设计原则</h4><ul><li>拆分足够微：划分比较细，但是也不能太细，增加管理问题</li><li>轻量级通信：rest，rpc等方式在网络上通信</li><li>单一职责原则：高内聚，低耦合，确定服务边界</li></ul><h2>如何设计微服务系统</h2><p><font color="red"><b>服务拆分</b></font>----》<font color="red"><b>服务注册</b></font>----》<font color="red"><b>服务发现</b></font>----》<font color="red"><b>服务消费</b></font>(调用另外一个服务)----》<font color="red"><b>统一入口</b></font>(服务很多的时候需要有一个统一的入口)----》<font color="red"><b>配置管理</b></font>(管理每个服务的配置信息)----》<font color="red"><b>熔断机制</b></font>(保护系统避免崩溃)----》<font color="red"><b>自动扩展</b></font>(根据负荷自动扩展集群)</p><h2>微服务拆分的意义</h2><ul><li>易于实现</li><li>易于部署</li><li>易于维护</li><li>易于更新</li></ul><p>本天气预报系统可以拆分为：</p><ul><li>天气数据采集服务：数据采集和数据存储</li><li>天气预报服务：数据展示</li><li>天气数据API：数据查询</li><li>城市数据API：数据查询</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第五篇文章，在进行真正的业务拆分之前，我们来认识一下什么是SOA架构，什么是微服务。确定本系统拆分的几个部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>4.天气预报系统-前端样式</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/4.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/4.天气预报系统-前端样式/</id>
    <published>2019-02-21T03:26:55.091Z</published>
    <updated>2019-02-21T04:35:10.167Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第四篇文章，整一个前端的渲染引擎并且用bootstrap美化一下样式。</p><a id="more"></a><h2>Thymeleaf</h2><p>数据动态地渲染，这里采用<code>Thymeleaf</code>模板引擎。</p><p>首先是引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>后端的controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/report"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherReportController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IWeatherReportService weatherReportService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ICityDataService cityDataService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cityId/&#123;cityId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getReportByCityId</span><span class="params">(@PathVariable(<span class="string">"cityId"</span>)</span> String cityId, Model model) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Weather weather = weatherReportService.getDataByCityId(cityId);</span><br><span class="line">        model.addAttribute(<span class="string">"title"</span>,<span class="string">"蜗牛天气预报"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"cityId"</span>,cityId);</span><br><span class="line">        model.addAttribute(<span class="string">"cityList"</span>,cityDataService.listCity());</span><br><span class="line">        model.addAttribute(<span class="string">"report"</span>,weather);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"weather/report"</span>,<span class="string">"reportModel"</span>,model);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端的简单页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>蜗牛天气预报系统<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.title&#125;"</span>&gt;</span>snail<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--下拉框来选择城市--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">"city : $&#123;reportModel.cityList&#125;"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">th:value</span>=<span class="string">"$&#123;city.cityId&#125;"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">th:text</span>=<span class="string">"$&#123;city.cityName&#125;"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">th:selected</span>=<span class="string">"$&#123;city.cityId eq reportModel.cityId &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--显示一下选择后的城市的名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.city&#125;"</span>&gt;</span>城市名称<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--显示这个城市的一些基本天气状况--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    空气质量指数：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.aqi&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    当前温度：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.wendu&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    温馨提示：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.ganmao&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--显示未来几天的天气状况--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">"forecast : $&#123;reportModel.report.forecast&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.date&#125;"</span>&gt;</span>日期<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.type&#125;"</span>&gt;</span>天气类型<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.high&#125;"</span>&gt;</span>最高温度<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.low&#125;"</span>&gt;</span>最低温度<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.fengxiang&#125;"</span>&gt;</span>风向<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2><font color="red">注意</font></h2><p>这里修正一下了一下之前存在的一个小错误，就是请求天气的接口应该是：<a href="http://wthrcdn.etouch.cn/weather_mini?citykey=xxx" target="_blank" rel="noopener">http://wthrcdn.etouch.cn/weather_mini?citykey=xxx</a>  而我之前程序中写的是http://wthrcdn.etouch.cn/weather_mini?cityKey=xxx</p><p>就是这个citykey中的k，应该是小写。导致请求不到数据，前端直接报错。</p><h2>Bootstrap</h2><p>稍微美化一下页面。引入bootstrap。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">integrity</span>=<span class="string">"sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>蜗牛天气预报系统<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container controls-pane"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.title&#125;"</span>&gt;</span>snail<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"custom-select"</span> <span class="attr">id</span>=<span class="string">"selectCityId"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">"city : $&#123;reportModel.cityList&#125;"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">th:value</span>=<span class="string">"$&#123;city.cityId&#125;"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">th:text</span>=<span class="string">"$&#123;city.cityName&#125;"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">th:selected</span>=<span class="string">"$&#123;city.cityId eq reportModel.cityId &#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-success"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.city&#125;"</span>&gt;</span>城市名称<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            空气质量指数：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.aqi&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            当前温度：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.wendu&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            温馨提示：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.ganmao&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card  border-info"</span> <span class="attr">th:each</span>=<span class="string">"forecast : $&#123;reportModel.report.forecast&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-body text-info"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.date&#125;"</span>&gt;</span>日期<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text "</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.type&#125;"</span>&gt;</span>天气类型<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.high&#125;"</span>&gt;</span>最高温度<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.low&#125;"</span>&gt;</span>最低温度<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.fengxiang&#125;"</span>&gt;</span>风向<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.2.1.slim.min.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Optional JavaScript --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/js/weather/report.js&#125;"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中下拉框选中向后端请求每个城市数据的js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"#selectCityId"</span>).change(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> cityId = $(<span class="string">"#selectCityId"</span>).val();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'/report/cityId/'</span>+ cityId;</span><br><span class="line"><span class="built_in">window</span>.location.href = url;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后的效果：</p><p><img src="http://bloghello.oursnail.cn/%E8%9C%97%E7%89%9B%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%95%8C%E9%9D%A2.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第四篇文章，整一个前端的渲染引擎并且用bootstrap美化一下样式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>3.天气预报系统-天气数据同步</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/3.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/3.天气预报系统-天气数据同步/</id>
    <published>2019-02-21T03:26:45.737Z</published>
    <updated>2019-02-21T03:42:20.206Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第三篇文章，由于天气信息需要更新，所以我们需要一个定时器定时去获取一下最新的信息。由于本项目实现比较简单就可以用quartz来实现。</p><a id="more"></a><h2>quartz如何整合</h2><p>数据需要定时地刷新，不能等到用户来获取的时候才更新，这里用最常用的quartz定时器来实现。</p><p>首先时引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>下面定义一个执行的任务，先什么都不干，就打印一句话即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherDataSyncJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"天气数据同步任务开始"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面要定义配置类：</p><p>首先是要定义这个任务的细节：<code>JobDetail</code>，就是说我们配置的这个quartz里面的任务是谁？给他起个名字啥的。</p><p>后面个是定义触发器，决定了刚才定义的这个<code>JobDetail</code>多长时间执行一次。这里是为了模拟想过，定义了两秒就执行一次。那么我们启动项目后，看到的效果应该是每两秒打印一次日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个jobDetail,就是注册一个定时任务，具体如何执行时在WeatherDataSyncJob中定义</span></span><br><span class="line">    <span class="comment">//具体何时执行，是下面的Trigger定义</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetail <span class="title">weatherDataSyncDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(WeatherDataSyncJob.class).</span><br><span class="line">                withIdentity(<span class="string">"WeatherDataSyncJob"</span>).</span><br><span class="line">                storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//触发器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trigger <span class="title">weatherDataSyncTrigger</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder</span><br><span class="line">                    .simpleSchedule()</span><br><span class="line">                        .withIntervalInSeconds(<span class="number">2</span>)<span class="comment">//两秒去自动执行一次</span></span><br><span class="line">                            .repeatForever();</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger().forJob(weatherDataSyncDetail())</span><br><span class="line">                .withIdentity(<span class="string">"weatherDataSyncTrigger"</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>拉取城市信息</h2><p>网站： <a href="http://mobile.weather.com.cn/js/citylist.xml" target="_blank" rel="noopener">http://mobile.weather.com.cn/js/citylist.xml</a></p><p>比如我将江苏省的单独拿出来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span> <span class="attr">c1</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190101"</span> <span class="attr">d2</span>=<span class="string">"南京"</span> <span class="attr">d3</span>=<span class="string">"nanjing"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190102"</span> <span class="attr">d2</span>=<span class="string">"溧水"</span> <span class="attr">d3</span>=<span class="string">"lishui"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190103"</span> <span class="attr">d2</span>=<span class="string">"高淳"</span> <span class="attr">d3</span>=<span class="string">"gaochun"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190104"</span> <span class="attr">d2</span>=<span class="string">"江宁"</span> <span class="attr">d3</span>=<span class="string">"jiangning"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190105"</span> <span class="attr">d2</span>=<span class="string">"六合"</span> <span class="attr">d3</span>=<span class="string">"luhe"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190106"</span> <span class="attr">d2</span>=<span class="string">"江浦"</span> <span class="attr">d3</span>=<span class="string">"jiangpu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190107"</span> <span class="attr">d2</span>=<span class="string">"浦口"</span> <span class="attr">d3</span>=<span class="string">"pukou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190201"</span> <span class="attr">d2</span>=<span class="string">"无锡"</span> <span class="attr">d3</span>=<span class="string">"wuxi"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190202"</span> <span class="attr">d2</span>=<span class="string">"江阴"</span> <span class="attr">d3</span>=<span class="string">"jiangyin"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190203"</span> <span class="attr">d2</span>=<span class="string">"宜兴"</span> <span class="attr">d3</span>=<span class="string">"yixing"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190204"</span> <span class="attr">d2</span>=<span class="string">"锡山"</span> <span class="attr">d3</span>=<span class="string">"xishan"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190301"</span> <span class="attr">d2</span>=<span class="string">"镇江"</span> <span class="attr">d3</span>=<span class="string">"zhenjiang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190302"</span> <span class="attr">d2</span>=<span class="string">"丹阳"</span> <span class="attr">d3</span>=<span class="string">"danyang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190303"</span> <span class="attr">d2</span>=<span class="string">"扬中"</span> <span class="attr">d3</span>=<span class="string">"yangzhong"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190304"</span> <span class="attr">d2</span>=<span class="string">"句容"</span> <span class="attr">d3</span>=<span class="string">"jurong"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190305"</span> <span class="attr">d2</span>=<span class="string">"丹徒"</span> <span class="attr">d3</span>=<span class="string">"dantu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190401"</span> <span class="attr">d2</span>=<span class="string">"苏州"</span> <span class="attr">d3</span>=<span class="string">"suzhou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190402"</span> <span class="attr">d2</span>=<span class="string">"常熟"</span> <span class="attr">d3</span>=<span class="string">"changshu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190403"</span> <span class="attr">d2</span>=<span class="string">"张家港"</span> <span class="attr">d3</span>=<span class="string">"zhangjiagang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190404"</span> <span class="attr">d2</span>=<span class="string">"昆山"</span> <span class="attr">d3</span>=<span class="string">"kunshan"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190405"</span> <span class="attr">d2</span>=<span class="string">"吴中"</span> <span class="attr">d3</span>=<span class="string">"wuzhong"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190407"</span> <span class="attr">d2</span>=<span class="string">"吴江"</span> <span class="attr">d3</span>=<span class="string">"wujiang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190408"</span> <span class="attr">d2</span>=<span class="string">"太仓"</span> <span class="attr">d3</span>=<span class="string">"taicang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190501"</span> <span class="attr">d2</span>=<span class="string">"南通"</span> <span class="attr">d3</span>=<span class="string">"nantong"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190502"</span> <span class="attr">d2</span>=<span class="string">"海安"</span> <span class="attr">d3</span>=<span class="string">"haian"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190503"</span> <span class="attr">d2</span>=<span class="string">"如皋"</span> <span class="attr">d3</span>=<span class="string">"rugao"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190504"</span> <span class="attr">d2</span>=<span class="string">"如东"</span> <span class="attr">d3</span>=<span class="string">"rudong"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190507"</span> <span class="attr">d2</span>=<span class="string">"启东"</span> <span class="attr">d3</span>=<span class="string">"qidong"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190508"</span> <span class="attr">d2</span>=<span class="string">"海门"</span> <span class="attr">d3</span>=<span class="string">"haimen"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190509"</span> <span class="attr">d2</span>=<span class="string">"通州"</span> <span class="attr">d3</span>=<span class="string">"tongzhou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190601"</span> <span class="attr">d2</span>=<span class="string">"扬州"</span> <span class="attr">d3</span>=<span class="string">"yangzhou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190602"</span> <span class="attr">d2</span>=<span class="string">"宝应"</span> <span class="attr">d3</span>=<span class="string">"baoying"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190603"</span> <span class="attr">d2</span>=<span class="string">"仪征"</span> <span class="attr">d3</span>=<span class="string">"yizheng"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190604"</span> <span class="attr">d2</span>=<span class="string">"高邮"</span> <span class="attr">d3</span>=<span class="string">"gaoyou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190605"</span> <span class="attr">d2</span>=<span class="string">"江都"</span> <span class="attr">d3</span>=<span class="string">"jiangdu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190606"</span> <span class="attr">d2</span>=<span class="string">"邗江"</span> <span class="attr">d3</span>=<span class="string">"hanjiang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190701"</span> <span class="attr">d2</span>=<span class="string">"盐城"</span> <span class="attr">d3</span>=<span class="string">"yancheng"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190702"</span> <span class="attr">d2</span>=<span class="string">"响水"</span> <span class="attr">d3</span>=<span class="string">"xiangshui"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190703"</span> <span class="attr">d2</span>=<span class="string">"滨海"</span> <span class="attr">d3</span>=<span class="string">"binhai"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190704"</span> <span class="attr">d2</span>=<span class="string">"阜宁"</span> <span class="attr">d3</span>=<span class="string">"funing"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190705"</span> <span class="attr">d2</span>=<span class="string">"射阳"</span> <span class="attr">d3</span>=<span class="string">"sheyang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190706"</span> <span class="attr">d2</span>=<span class="string">"建湖"</span> <span class="attr">d3</span>=<span class="string">"jianhu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190707"</span> <span class="attr">d2</span>=<span class="string">"东台"</span> <span class="attr">d3</span>=<span class="string">"dongtai"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190708"</span> <span class="attr">d2</span>=<span class="string">"大丰"</span> <span class="attr">d3</span>=<span class="string">"dafeng"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190709"</span> <span class="attr">d2</span>=<span class="string">"盐都"</span> <span class="attr">d3</span>=<span class="string">"yandu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190801"</span> <span class="attr">d2</span>=<span class="string">"徐州"</span> <span class="attr">d3</span>=<span class="string">"xuzhou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190802"</span> <span class="attr">d2</span>=<span class="string">"铜山"</span> <span class="attr">d3</span>=<span class="string">"tongshan"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190803"</span> <span class="attr">d2</span>=<span class="string">"丰县"</span> <span class="attr">d3</span>=<span class="string">"fengxian"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190804"</span> <span class="attr">d2</span>=<span class="string">"沛县"</span> <span class="attr">d3</span>=<span class="string">"peixian"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190805"</span> <span class="attr">d2</span>=<span class="string">"邳州"</span> <span class="attr">d3</span>=<span class="string">"pizhou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190806"</span> <span class="attr">d2</span>=<span class="string">"睢宁"</span> <span class="attr">d3</span>=<span class="string">"suining"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190807"</span> <span class="attr">d2</span>=<span class="string">"新沂"</span> <span class="attr">d3</span>=<span class="string">"xinyi"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190901"</span> <span class="attr">d2</span>=<span class="string">"淮安"</span> <span class="attr">d3</span>=<span class="string">"huaian"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190902"</span> <span class="attr">d2</span>=<span class="string">"金湖"</span> <span class="attr">d3</span>=<span class="string">"jinhu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190903"</span> <span class="attr">d2</span>=<span class="string">"盱眙"</span> <span class="attr">d3</span>=<span class="string">"xuyi"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190904"</span> <span class="attr">d2</span>=<span class="string">"洪泽"</span> <span class="attr">d3</span>=<span class="string">"hongze"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190905"</span> <span class="attr">d2</span>=<span class="string">"涟水"</span> <span class="attr">d3</span>=<span class="string">"lianshui"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190906"</span> <span class="attr">d2</span>=<span class="string">"淮阴区"</span> <span class="attr">d3</span>=<span class="string">"huaiyinqu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101190908"</span> <span class="attr">d2</span>=<span class="string">"淮安区"</span> <span class="attr">d3</span>=<span class="string">"huaianqu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191001"</span> <span class="attr">d2</span>=<span class="string">"连云港"</span> <span class="attr">d3</span>=<span class="string">"lianyungang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191002"</span> <span class="attr">d2</span>=<span class="string">"东海"</span> <span class="attr">d3</span>=<span class="string">"donghai"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191003"</span> <span class="attr">d2</span>=<span class="string">"赣榆"</span> <span class="attr">d3</span>=<span class="string">"ganyu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191004"</span> <span class="attr">d2</span>=<span class="string">"灌云"</span> <span class="attr">d3</span>=<span class="string">"guanyun"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191005"</span> <span class="attr">d2</span>=<span class="string">"灌南"</span> <span class="attr">d3</span>=<span class="string">"guannan"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191101"</span> <span class="attr">d2</span>=<span class="string">"常州"</span> <span class="attr">d3</span>=<span class="string">"changzhou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191102"</span> <span class="attr">d2</span>=<span class="string">"溧阳"</span> <span class="attr">d3</span>=<span class="string">"liyang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191103"</span> <span class="attr">d2</span>=<span class="string">"金坛"</span> <span class="attr">d3</span>=<span class="string">"jintan"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191104"</span> <span class="attr">d2</span>=<span class="string">"武进"</span> <span class="attr">d3</span>=<span class="string">"wujin"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191201"</span> <span class="attr">d2</span>=<span class="string">"泰州"</span> <span class="attr">d3</span>=<span class="string">"taizhou"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191202"</span> <span class="attr">d2</span>=<span class="string">"兴化"</span> <span class="attr">d3</span>=<span class="string">"xinghua"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191203"</span> <span class="attr">d2</span>=<span class="string">"泰兴"</span> <span class="attr">d3</span>=<span class="string">"taixing"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191204"</span> <span class="attr">d2</span>=<span class="string">"姜堰"</span> <span class="attr">d3</span>=<span class="string">"jiangyan"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191205"</span> <span class="attr">d2</span>=<span class="string">"靖江"</span> <span class="attr">d3</span>=<span class="string">"jingjiang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191301"</span> <span class="attr">d2</span>=<span class="string">"宿迁"</span> <span class="attr">d3</span>=<span class="string">"suqian"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191302"</span> <span class="attr">d2</span>=<span class="string">"沭阳"</span> <span class="attr">d3</span>=<span class="string">"shuyang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191303"</span> <span class="attr">d2</span>=<span class="string">"泗阳"</span> <span class="attr">d3</span>=<span class="string">"siyang"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191304"</span> <span class="attr">d2</span>=<span class="string">"泗洪"</span> <span class="attr">d3</span>=<span class="string">"sihong"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">d</span> <span class="attr">d1</span>=<span class="string">"101191305"</span> <span class="attr">d2</span>=<span class="string">"宿豫"</span> <span class="attr">d3</span>=<span class="string">"suyu"</span> <span class="attr">d4</span>=<span class="string">"江苏"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实思路很简单，就是从xml文件中获取所有的城市信息，转换为城市列表对象。然后遍历城市中的id，就可以根据id拼接url去直接去调用天气的接口去查询天气，然后重新覆盖redis中的天气数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherDataSyncJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IWeatherDataService weatherDataService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ICityDataService cityDataService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"天气数据同步任务开始"</span>);</span><br><span class="line">        <span class="comment">//获取城市列表</span></span><br><span class="line">        List&lt;City&gt; cityList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cityList = cityDataService.listCity();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"获取城市列表失败！"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历城市id获取天气</span></span><br><span class="line">        <span class="keyword">for</span>(City city:cityList)&#123;</span><br><span class="line">            String cityId = city.getCityId();</span><br><span class="line">            log.info(<span class="string">"定时器更新了&#123;&#125;这个城市的天气信息"</span>, city.getCityName());</span><br><span class="line">            weatherDataService.syncDataByCityId(cityId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"天气数据同步任务结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体如何读取xml文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityDataServiceImpl</span> <span class="keyword">implements</span> <span class="title">ICityDataService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;City&gt; <span class="title">listCity</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//读取xml文件</span></span><br><span class="line">        Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"citylist.xml"</span>);</span><br><span class="line">        <span class="comment">//读取文件的buffer流</span></span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resource.getInputStream(),<span class="string">"UTF-8"</span>));</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String line = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((line = bf.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            buffer.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时数据已经读到buffer里了</span></span><br><span class="line">        bf.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//xml转换为java对象</span></span><br><span class="line">        CityList cityList = (CityList) XmlBuilder.xmlStrToObj(CityList.class,buffer.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cityList.getCityList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 【swg】.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/11/19 17:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DESC</span> xml转换为对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CONTACT</span> 317758022@qq.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">xmlStrToObj</span><span class="params">(Class&lt;?&gt; clazz,String xmlStr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object xmlObject = <span class="keyword">null</span>;</span><br><span class="line">        Reader reader = <span class="keyword">null</span>;</span><br><span class="line">        JAXBContext context = JAXBContext.newInstance(clazz);</span><br><span class="line">        <span class="comment">//xml转为对象的接口</span></span><br><span class="line">        Unmarshaller unmarshaller = context.createUnmarshaller();</span><br><span class="line"></span><br><span class="line">        reader = <span class="keyword">new</span> StringReader(xmlStr);</span><br><span class="line">        xmlObject = unmarshaller.unmarshal(reader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != reader)&#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xmlObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，解析xml我们用到了<code>JAXB</code>，他是什么呢？维基百科：</p><blockquote><p>JAXB（Java Architecture for XML Binding简称JAXB）允许Java开发人员将Java类映射为XML表示方式。JAXB提供两种主要特性：将一个Java对象序列化为XML，以及反向操作，将XML解析成Java对象。换句话说，JAXB允许以XML格式存储和读取数据，而不需要程序的类结构实现特定的读取XML和保存XML的代码。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第三篇文章，由于天气信息需要更新，所以我们需要一个定时器定时去获取一下最新的信息。由于本项目实现比较简单就可以用quartz来实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>2.天气预报系统-redis提升性能</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/2.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-redis%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/2.天气预报系统-redis提升性能/</id>
    <published>2019-02-21T03:26:36.808Z</published>
    <updated>2019-02-21T03:33:59.396Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第二篇文章，很显然，这个免费的接口能承受的并发是很低的，并且我们的服务器作为一个中转站去向这个接口请求数据也非常地耗时，于性能和稳定性都没有保障，所以我们需要redis作为缓存来提高性能。所以，我们需要用redis来重构一下。</p><a id="more"></a><p>先引入一下依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>思路很简单：缓存中有数据的时候，就直接从缓存中拿即可，若缓存中没有此数据，就去调用接口重新获取并且再存到缓存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_OUT = <span class="number">30</span>*<span class="number">60L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WeatherResponse <span class="title">doGetWeather</span><span class="params">(String uri)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先去缓存中查询，有就直接拿缓存中的数据，否则调用接口</span></span><br><span class="line">    String key = uri;</span><br><span class="line">    String strBody = <span class="keyword">null</span>;</span><br><span class="line">    WeatherResponse resp = <span class="keyword">null</span>;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    ValueOperations&lt;String,String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(stringRedisTemplate.hasKey(uri))&#123;</span><br><span class="line">        <span class="comment">//缓存有数据</span></span><br><span class="line">        log.info(<span class="string">"Redis has data!"</span>);</span><br><span class="line">        strBody = ops.get(key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//缓存没有数据</span></span><br><span class="line">        log.info(<span class="string">"Redis don't thas data!"</span>);</span><br><span class="line">        ResponseEntity&lt;String&gt; resString = restTemplate.getForEntity(uri,String.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(resString.getStatusCodeValue() == <span class="number">200</span>) &#123;</span><br><span class="line">            strBody = resString.getBody();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据写入缓存</span></span><br><span class="line">        ops.set(key,strBody,TIME_OUT, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resp = mapper.readValue(strBody,WeatherResponse.class);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        log.error(<span class="string">"Error!"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始可以将过期时间缩短一点，这里redis直接启动即可，默认端口是6379.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第二篇文章，很显然，这个免费的接口能承受的并发是很低的，并且我们的服务器作为一个中转站去向这个接口请求数据也非常地耗时，于性能和稳定性都没有保障，所以我们需要redis作为缓存来提高性能。所以，我们需要用redis来重构一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>1.天气预报系统-简单接口调用</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/1.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E7%AE%80%E5%8D%95%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/1.天气预报系统-简单接口调用/</id>
    <published>2019-02-21T03:20:32.695Z</published>
    <updated>2019-02-21T05:00:05.700Z</updated>
    
    <content type="html"><![CDATA[<p>慕课网的课程《从天气项目看 Spring Cloud 微服务治理》应该是入门spring cloud微服务最简单的实战视频了。这是学习的第一篇文章，因为业务很简单，就是获取天气并且展示出来，本节说明一下如何获取天气信息。代码详见尾部，本系列所有代码都分类保存再github上了。</p><a id="more"></a><h2>一、获取天气信息</h2><p>数据来源：</p><p><a href="http://wthrcdn.etouch.cn/weather_mini?citykey=xxx" target="_blank" rel="noopener">http://wthrcdn.etouch.cn/weather_mini?citykey=xxx</a></p><p>或者</p><p><a href="http://wthrcdn.etouch.cn/weather_mini?city=xxx" target="_blank" rel="noopener">http://wthrcdn.etouch.cn/weather_mini?city=xxx</a></p><p>首先我们如何做一个查询天气的接口呢？其实特别简单，就是用<code>HttpClient</code>这个客户端来调用以上的接口，就可以拿到数据了。</p><p>我们所需要做的工作也非常少，就是封装一下数据，请求一下参数即可。</p><p>请求的数据是json，我们这里准备好数据bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherResponse</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weather data;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span>  <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String aqi;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Forecast&gt; forecast;</span><br><span class="line">    <span class="keyword">private</span> String ganmao;</span><br><span class="line">    <span class="keyword">private</span> String wendu;</span><br><span class="line">    <span class="keyword">private</span> Yesterday yesterday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Forecast</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String high;</span><br><span class="line">    <span class="keyword">private</span> String fengli;</span><br><span class="line">    <span class="keyword">private</span> String low;</span><br><span class="line">    <span class="keyword">private</span> String fengxiang;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yesterday</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String high;</span><br><span class="line">    <span class="keyword">private</span> String fx;</span><br><span class="line">    <span class="keyword">private</span> String low;</span><br><span class="line">    <span class="keyword">private</span> String fl;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，数据载体已经好了，下面就是用<code>RestTemplate</code>调用<code>url</code>取获取天气信息，用上面的bean来封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherDataServiceImpl</span> <span class="keyword">implements</span> <span class="title">IWeatherDataService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统一接口前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEATHER_URI = <span class="string">"http://wthrcdn.etouch.cn/weather_mini?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeatherResponse <span class="title">getDataByCityId</span><span class="params">(String cityId)</span> </span>&#123;</span><br><span class="line">        String uri = WEATHER_URI + <span class="string">"citykey="</span>+cityId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doGetWeather(uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeatherResponse <span class="title">getDataByCityName</span><span class="params">(String cityName)</span> </span>&#123;</span><br><span class="line">        String uri = WEATHER_URI + <span class="string">"city="</span>+cityName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doGetWeather(uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据参数获取天气数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> WeatherResponse <span class="title">doGetWeather</span><span class="params">(String uri)</span></span>&#123;</span><br><span class="line">        ResponseEntity&lt;String&gt; resString = restTemplate.getForEntity(uri,String.class);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        WeatherResponse resp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String strBody = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(resString.getStatusCodeValue() == <span class="number">200</span>)&#123;</span><br><span class="line">            strBody = resString.getBody();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp = mapper.readValue(strBody,WeatherResponse.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再用一个controller来给一个接口即可。</p><h2>二、注意</h2><p>直接启动项目会报错：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.</span><br><span class="line">2018-11-19 15:19:54.732 ERROR 13924 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : </span><br><span class="line"></span><br><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Field restTemplate in com.swg.weatherbasic.service.impl.WeatherDataServiceImpl required a bean of type 'org.springframework.web.client.RestTemplate' that could not be found.</span><br><span class="line"></span><br><span class="line">The injection point has the following annotations:</span><br><span class="line">- @org.springframework.beans.factory.annotation.Autowired(required=true)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider defining a bean of type 'org.springframework.web.client.RestTemplate' in your configuration.</span><br></pre></td></tr></table></figure><p>我们可以看到提示信息是：<code>'org.springframework.web.client.RestTemplate' that could not be found.</code>,错误就很明显了，这个玩意根本就没有在spring中注册，怎么可以注入呢?</p><p>所以，我们需要向spring注册一下这个bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplateBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、彩蛋</h2><p>将此小项目作为一个小版本，直接保存到码云上。如何做呢？</p><p>其实很简单，先去码云上新建一个项目。然后在本地某一个文件夹下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx</span><br></pre></td></tr></table></figure><p>然后将我们的项目直接拷贝到这个文件夹下。执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -am &apos;weather-basic&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>这样就可以了。</p><p>代码地址：<a href="https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/01" target="_blank" rel="noopener">spring-cloud-weather-action----01</a></p><p>下面章节的代码依次类推，可能就不再赘述了。本项目的<code>springboot</code>版本是<code>2.1.0.RELEASE</code>，<code>spring cloud</code>用的是<code>Finchley.RELEASE</code>版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;慕课网的课程《从天气项目看 Spring Cloud 微服务治理》应该是入门spring cloud微服务最简单的实战视频了。这是学习的第一篇文章，因为业务很简单，就是获取天气并且展示出来，本节说明一下如何获取天气信息。代码详见尾部，本系列所有代码都分类保存再github上了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>java基础之ThreadLocal自问自答</title>
    <link href="http://yoursite.com/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/"/>
    <id>http://yoursite.com/2019/02/20/java-basic/java基础之ThreadLocal自问自答/</id>
    <published>2019-02-20T12:43:11.161Z</published>
    <updated>2019-02-20T12:43:24.438Z</updated>
    
    <content type="html"><![CDATA[<p>以问答的形式加深对threadlocal的理解，做到面试的镇定自若。</p><a id="more"></a><h3>问题1：ThreadLocal了解吗？您能给我说说他的主要用途吗？</h3><p>官方定位：<code>ThreadLocal</code>类用来<strong>提供线程内部的局部变量</strong>。这种变量在多线程环境下访问（通过<code>get</code>和<code>set</code>方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。</p><p>简单归纳就是：</p><ul><li><code>ThreadLocal</code>的作用是提供线程内的局部变量</li><li>这种变量在线程的生命周期内起作用</li><li>不同的线程之间不会相互干扰</li></ul><h3>问题2：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？</h3><p>通常，如果我不去看源代码的话，我猜<code>ThreadLocal</code>是这样子设计的：每个<code>ThreadLocal</code>类都创建一个<code>Map</code>，然后用线程的ID <code>threadID</code>作为<code>Map</code>的<code>key</code>，要存储的局部变量作为<code>Map</code>的<code>value</code>，这样就能达到各个线程的值隔离的效果。这是最简单的设计方法，JDK最早期的<code>ThreadLocal</code>就是这样设计的。</p><p>但是，JDK后面优化了设计方案，现时JDK8 <code>ThreadLocal</code>的设计是：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>哈希表，这个哈希表的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>才是真正要存储的值<code>Object</code>。</p><p><img src="http://xiaozhao.oursnail.cn/iKjk3GS.png" alt="image"></p><p><strong>那么为什么不用上面个设计呢？多简单啊！</strong></p><p>如果用Map来做的话，只能是用<code>thread</code>+<code>threadlocal</code>计算出来作为<code>key</code>，毕竟我存的不一定只有一个变量。那么不用他的时候，如何清理呢？只能是手动<code>remove</code>掉，但是一方面很麻烦，另一方面代码很丑陋，最后一方面是在<code>remove</code>的时候突然出现问题，那么就可能导致内存泄漏。</p><p><strong>新的设计的好处：</strong></p><p>当<code>Thread</code>销毁之后，对应的<code>ThreadLocalMap</code>也会随之销毁，能减少内存的使用。</p><p>假设当前<code>thread</code>一直活着（比如赖在线程池中），有些无用的<code>threadlocal</code>对象怎么清理呢？</p><p><code>key</code>是一个软引用指向<code>ThreadLocal</code>实例，特性是下一次gc的时候就会被回收掉了，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>.</p><p><code>key</code>回收掉了，<code>value</code>值还在啊，这个怎么回收！！！</p><p><code>ThreadLocal</code>的<code>get</code>和<code>set</code>方法每次调用时，如果发现当前的<code>entry</code>的<code>key</code>为<code>null</code>（也就是被回收掉了），最终会调用<code>expungeStaleEntry(int staleSlot)</code>方法，该方法会把哈希表当前位置的无用数据清理掉（当然还有别的操作）。</p><p>但是最佳实践还是每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据,确保不会出现内存泄漏问题。</p><h3>问题3：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set(T value)，获取get()，删除remove()等操作。</h3><p>具体的代码就不贴了，核心代码都已经看过了。这里简单总结一下。</p><ul><li>调用<code>get()</code><ul><li>获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</li><li>判断当前的<code>ThreadLocalMap</code>是否存在,如果存在，则以当前的<code>ThreadLocal</code> 为 <code>key</code>，调用<code>ThreadLocalMap</code>中的<code>getEntry</code>方法获取对应的存储实体 <code>e</code>。找到对应的存储实体 <code>e</code>，获取存储实体 <code>e</code> 对应的 <code>value</code>值，即为我们想要的当前线程对应此<code>ThreadLocal</code>的值，返回结果值。</li><li>如果不存在，则证明此线程没有维护的<code>ThreadLocalMap</code>对象，调用<code>setInitialValue</code>方法进行初始化。返回<code>setInitialValue</code>初始化的值。</li></ul></li><li>调用<code>set(T value)</code><ul><li>获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</li><li>判断当前的<code>ThreadLocalMap</code>是否存在：</li><li>如果存在，则调用<code>map.set</code>设置此实体<code>entry</code>。</li><li>如果不存在，则调用<code>createMap</code>进行<code>ThreadLocalMap</code>对象的初始化，并将此实体<code>entry</code>作为第一个值存放至<code>ThreadLocalMap</code>中。</li></ul></li><li>调用<code>remove()</code><ul><li>获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</li><li>判断当前的<code>ThreadLocalMap</code>是否存在， 如果存在，则调用<code>map.remove</code>，以当前<code>ThreadLocal</code>为<code>key</code>删除对应的实体<code>entry</code>。</li></ul></li></ul><h3>问题4：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗?</h3><p><code>ThreadLocalMap</code>的底层实现是一个定制的自定义<code>HashMap</code>哈希表，核心组成元素有：</p><ul><li><code>Entry[] table</code>：底层哈希表 <code>table</code>,必要时需要进行扩容，底层哈希表 <code>table.length</code> 长度必须是2的n次方。</li><li><code>int size</code>：实际存储键值对元素个数 <code>entries</code></li><li><code>int threshold</code>：下一次扩容时的阈值，阈值 <code>threshold = len(table) * 2 / 3</code>。当 <code>size &gt;= threshold</code> 时，遍历<code>table</code>并删除<code>key</code>为<code>null</code>的元素，如果删除后<code>size &gt;= threshold*3/4</code>时，需要对<code>table</code>进行扩容</li></ul><p>其中<code>Entry[] table</code>哈希表存储的核心元素是<code>Entry</code>，<code>Entry</code>包含：</p><ul><li><code>ThreadLocal&lt;?&gt; k</code>：当前存储的<code>ThreadLocal</code>实例对象</li><li><code>Object value</code>：当前 <code>ThreadLocal</code> 对应储存的值<code>value</code></li></ul><p>需要注意的是，此<code>Entry</code>继承了弱引用 <code>WeakReference</code>，所以在使用<code>ThreadLocalMap</code>时，发现<code>key == null</code>，则意味着此<code>key ThreadLocal</code>不在被引用，需要将其从<code>ThreadLocalMap</code>哈希表中移除。</p><h3>问题5：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？</h3><p>参考上一篇<a href="http://fourcolor.oursnail.cn/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">文章</a>。</p><h3>问题6：ThreadLocal和synchronized的区别?</h3><p><code>ThreadLocal</code>和<code>synchronized</code>关键字都用于处理多线程并发访问变量的问题，只是二者处理问题的角度和思路不同。</p><ul><li><code>ThreadLocal</code>是一个<code>Java</code>类,通过对当前线程中的局部变量的操作来解决不同线程的变量访问的冲突问题。所以，<code>ThreadLocal</code>提供了线程安全的共享对象机制，每个线程都拥有其副本。</li><li><code>Java</code>中的<code>synchronized</code>是一个保留字，它依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。此时，被用作“锁机制”的变量时多个线程共享的。</li><li>同步机制(<code>synchronized</code>关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而<code>ThreadLocal</code>采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响.</li></ul><h3>问题7：ThreadLocal在现时有什么应用场景？</h3><p>总的来说<code>ThreadLocal</code>主要是解决2种类型的问题：</p><ul><li>解决并发问题：使用<code>ThreadLocal</code>代替<code>synchronized</code>来保证线程安全。同步机制采用了“以时间换空间”的方式，而<code>ThreadLocal</code>采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li><li>解决数据存储问题：<code>ThreadLocal</code>为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。如一个<code>Parameter</code>对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用<code>ThreadLocal</code>解决。</li></ul><p>一般的<code>Web</code>应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程<code>ThreadLocal</code>是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，<code>ThreadLocal</code>比直接使用<code>synchronized</code>同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p><h3>总结</h3><ul><li><code>ThreadLocal</code>提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</li><li><code>ThreadLocal</code>的设计是：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>哈希表，这个哈希表的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>才是真正要存储的值<code>Object</code>。</li><li>对<code>ThreadLocal</code>的常用操作实际是对线程<code>Thread</code>中的<code>ThreadLocalMap</code>进行操作。</li><li><code>ThreadLocalMap</code>的底层实现是一个定制的自定义哈希表，<code>ThreadLocalMap</code>的阈值<code>threshold</code> = <code>底层哈希表table的长度 len * 2 / 3</code>，当实际存储元素个数<code>size</code> 大于或等于 阈值<code>threshold的 3/4</code> 时<code>size &gt;= threshold*3/4</code>，则对底层哈希表数组<code>table</code>进行扩容操作。</li><li><code>ThreadLocalMap</code>中的哈希表<code>Entry[] table</code>存储的核心元素是<code>Entry</code>，存储的<code>key</code>是<code>ThreadLocal</code>实例对象，<code>value</code>是<code>ThreadLocal</code> 对应储存的值<code>value</code>。需要注意的是，此<code>Entry</code>继承了弱引用 <code>WeakReference</code>，所以在使用<code>ThreadLocalMap</code>时，发现<code>key == null</code>，则意味着此<code>key ThreadLocal</code>不在被引用，需要将其从<code>ThreadLocalMap</code>哈希表中移除。</li><li><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收。所以，在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。如果我们不主动调用上述操作，则会导致内存泄露。</li><li>为了安全地使用<code>ThreadLocal</code>，必须要像每次使用完锁就解锁一样，在每次使用完<code>ThreadLocal</code>后都要调用<code>remove()</code>来清理无用的<code>Entry</code>。这在操作在使用线程池时尤为重要。</li><li><code>ThreadLocal</code>和<code>synchronized</code>的区别：同步机制(<code>synchronized</code>关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而<code>ThreadLocal</code>采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。</li><li><code>ThreadLocal</code>主要是解决2种类型的问题：A. 解决并发问题：使用<code>ThreadLocal</code>代替同步机制解决并发问题。B. 解决数据存储问题：如一个<code>Parameter</code>对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用<code>ThreadLocal</code>解决。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以问答的形式加深对threadlocal的理解，做到面试的镇定自若。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之ThreadLocal内存泄漏问题</title>
    <link href="http://yoursite.com/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/20/java-basic/java基础之ThreadLocal内存泄漏问题/</id>
    <published>2019-02-20T12:39:46.248Z</published>
    <updated>2019-02-20T12:39:58.818Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是面试重灾区，分为两篇来讲解其中的用法和原理。这是第二篇。</p><a id="more"></a><h2>一、前言</h2><p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用 <code>ThreadLocal</code>，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析 <code>ThreadLocal</code> 内存泄漏的问题:</p><ul><li><code>ThreadLocal</code> 实现原理</li><li><code>ThreadLocal</code>为什么会内存泄漏</li><li><code>ThreadLocal</code> 最佳实践</li></ul><h2>二、ThreadLocal 实现原理</h2><p>这部分内容上一篇已经详细讲解完毕，这里谨作为一个回顾或者总结吧！</p><p><img src="http://xiaozhao.oursnail.cn/iKjk3GS.png" alt="image"></p><p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 指向 <code>ThreadLocal</code> 实例本身，<code>value</code> 指向真正需要存储的 <code>Object</code>，这个值真实保存在线程实例上的。</p><p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 <code>GC</code> 时会被回收。</p><p>这里一定要注意，<code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。我们从<code>get</code>和<code>set</code>代码中可以看到<code>ThreadLocalMap</code>的<code>key</code>是<code>ThreadLocal</code> 实例本身。</p><p><img src="http://bloghello.oursnail.cn/javabasic14-2.png" alt="image"></p><h2>三、ThreadLocal为什么会内存泄漏</h2><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>,如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 <code>GC</code> 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p><p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get(),set(),remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p><p>但是这些被动的预防措施并不能保证不会内存泄漏：</p><ul><li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>的生命周期，可能导致的内存泄漏</li><li>分配使用了<code>ThreadLocal</code>又不再调用<code>get(),set(),remove()</code>方法，那么就会导致内存泄漏。</li></ul><h2>四、为什么使用弱引用</h2><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析<code>ThreadLocal</code>使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p><ul><li><strong>key 使用强引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li><li><strong>key 使用弱引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set,get，remove</code>的时候会被清除。</li></ul><p>比较两种情况，我们可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用<code>ThreadLocal</code>不会内存泄漏，对应的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set,get,remove</code>的时候会被清除。</p><p>因此，<code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</p><h2>五、ThreadLocal 最佳实践</h2><p>综合上面的分析，我们可以理解<code>ThreadLocal</code>内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p><p>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。<br>在使用线程池的情况下，没有及时清理<code>ThreadLocal</code>，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用<code>ThreadLocal</code>就跟加锁完要解锁一样，用完就清理。</p><p>整理自：</p><ul><li><a href="https://blog.xiaohansong.com/ThreadLocal-memory-leak.html" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal是面试重灾区，分为两篇来讲解其中的用法和原理。这是第二篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之ThreadLocal详解</title>
    <link href="http://yoursite.com/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/20/java-basic/java基础之ThreadLocal详解/</id>
    <published>2019-02-20T12:31:57.745Z</published>
    <updated>2019-02-20T12:39:42.852Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是面试重灾区，但是好像我没遇到过有人问，尴尬脸，不过我们不能做砧板上的鱼肉静静等待宰割，分为两篇来讲解其中的用法和原理。这是第一篇。</p><a id="more"></a><h2>一、ThreadLocal简介</h2><p><code>ThreadLocal</code>类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过<code>get</code>或<code>set</code>方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，<code>ThreadLocal</code>实例通常来说都是<code>private static</code>类型。</p><p><code>ThreadLocal</code>类提供了四个对外开放的接口方法，这也是用户操作<code>ThreadLocal</code>类的基本方法：</p><ul><li><code>void set(Object value)</code>设置当前线程的线程局部变量的值。</li><li><code>public Object get()</code>该方法返回当前线程所对应的线程局部变量。</li><li><code>public void remove()</code>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li><li><code>protected Object initialValue()</code>返回该线程局部变量的初始值，该方法是一个<code>protected</code>的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用<code>get()</code>或<code>set(Object)</code>时才执行，并且仅执行1次，<code>ThreadLocal</code>中的缺省实现直接返回一个<code>null</code>。</li></ul><blockquote><p>一个简单的小例子来感受ThreadLocal到底是什么以及怎么用：</p></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic14-1.png" alt="image"></p><blockquote><p>运行结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-0</span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line">Thread-1</span><br><span class="line">Chinese</span><br><span class="line">English</span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>可以，看出虽然多个线程对同一个变量进行访问，但是由于<code>threadLocal</code>变量由<code>ThreadLocal</code> 修饰，则不同的线程访问的就是该线程设置的值，这里也就体现出来<code>ThreadLocal</code>的作用。</p><p>当使用<code>ThreadLocal</code>维护变量时，<code>ThreadLocal</code>为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><h2>二、扒开JDK threadlocal神秘面纱</h2><p>threadlocal的原理图为：</p><p><img src="http://xiaozhao.oursnail.cn/iKjk3GS.png" alt="image"></p><p>那<code>ThreadLocal</code>内部是如何为每一个线程维护变量副本的呢？到底是什么原理呢？</p><p>先来看一下<code>ThreadLocal</code>的<code>set()</code>方法的源码是如何实现的：</p><p><img src="http://bloghello.oursnail.cn/javabasic14-2.png" alt="image"></p><p>我们看到，首先通过<code>getMap(Thread t)</code>方法获取一个和当前线程相关的<code>ThreadLocalMap</code>，然后将变量的值设置到这个<code>ThreadLocalMap</code>对象中，当然如果获取到的<code>ThreadLocalMap</code>对象为空，就通过<code>createMap</code>方法创建。</p><p>我们再往下面去一点，比如<code>map.set</code>方法到底是怎么实现的？</p><p><img src="http://bloghello.oursnail.cn/javabasic14-3.png" alt="image"></p><p>结合上面的图，其实我们可以发现，数据并不是放在所谓的<code>Map</code>集合中，而是放进了一个<code>Entry</code>数组中，这个<code>entry</code>索引是上面计算好的，<code>entry</code>的<code>key</code>是指向<code>threadLocal</code>的一个软引用，<code>value</code>是指向真实数据的一个强引用，以后再获取的时候，再以同样的方式计算得到索引下标即可。</p><blockquote><p>上面代码出现的 ThreadLocalMap 是什么？</p></blockquote><p><strong><code>ThreadLocalMap</code>是<code>ThreadLocal</code>类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的<code>ThreadLocalMap</code>副本，它所存储的值，只能被当前线程读取和修改。</strong></p><p>我们深入看一下<code>getMap</code>和<code>createMap</code>的实现</p><p><code>getMap</code>:</p><p><img src="http://bloghello.oursnail.cn/javabasic14-4.png" alt="image"></p><p><code>createMap</code>:</p><p><img src="http://bloghello.oursnail.cn/javabasic14-5.png" alt="image"></p><p>代码非常直白，就是获取和设置<code>Thread</code>内的一个叫<code>threadLocals</code>的变量，而这个变量的类型就是<code>ThreadLocalMap</code>，这样进一步验证了上文中的观点：<strong>每个线程都有自己独立的<code>ThreadLocalMap</code>对象</strong>。</p><p><code>Thread</code>源码中的<code>threadLocals</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic14-6.png" alt="image"></p><p>我们接着看<code>ThreadLocal</code>中的<code>get</code>方法如下</p><p><img src="http://bloghello.oursnail.cn/javabasic14-7.png" alt="image"></p><ul><li>第一步 先获通过<code>Thread.currentThread（）</code>取当前线程</li><li>第二步 然后获取当前线程的<code>threadLocals</code>属性</li><li>第三步 在<code>threadLocals</code>属性里获取<code>Entry</code>实例</li><li>第四部 从<code>Entry</code>实例的<code>value</code>属性里获取到最后所要的<code>Object</code>对象</li></ul><p>接下来讨论一下上面出现的<code>ThreadLocalMap</code>类以及<code>Entry</code>类，直接贴源码</p><p><img src="http://bloghello.oursnail.cn/javabasic14-8.png" alt="image"></p><p><code>Entry</code>是<code>ThreadLocalMap</code>的内部类，而且<code>ThreadLocalMap</code>里拥有一个类型为<code>Entry[]</code>的<code>table</code>属性，而且每个线程实例有自己的<code>ThreadLocalMap</code>。到这里结论已经很明显了：<strong>负责保存<code>ThreadLocal</code>的<code>key</code>和<code>value</code>根本就不是一个<code>Map</code>类型，而是一个<code>Entry</code>数组!</strong></p><p><code>Entry</code>继承<code>WeakReference</code>，因此继承拥有一个弱引用<code>referent</code>，而且自身也有一个<code>value</code>属性。<code>Entry</code>利用<code>referent</code>来保存<code>threadLocal</code>实例的弱引用，利用<code>value</code>保存<code>Object</code>的强引用。至于为什么一个是强引用，一个是弱引用，我们在下一篇中来探讨。</p><p>最后的问题是怎样在<code>Entry</code>数组里定位我们需要的<code>Entry</code>呢?其实上面在set的时候已经大概知道了，现在再来看看代码吧：</p><p><img src="http://bloghello.oursnail.cn/javabasic14-9.png" alt="image"></p><p>留意<code>key.threadLocalHashCode</code>这个属性，<code>Entry</code>在保存进<code>Entry[]</code>数组之前，会利用<code>ThreadLocal</code>的引用计算出一个<code>hash</code>值，然后利用这个<code>hash</code>值作为下标定位到<code>Entry[]</code>数组的某个位置；</p><p><img src="http://xiaozhao.oursnail.cn/thread_specific_storage_custom.png" alt="image"></p><p>原理总结：<code>ThreadLocal</code>类并没有一个<code>Map</code>来保存数据，数据都是保存在线程实例上的；客户端访问<code>ThreadLocal</code>实例的<code>get</code>方法，<code>get</code>方法通过<code>Thread.getCurrentThread</code>获得当前线程的实例，从而获得当前线程的<code>ThreadLocalMap</code>对象，而<code>ThreadLocalMap</code>里包含了一个<code>Entry</code>数组，里面的每个<code>Entry</code>保存了<code>ThreadLocal</code>引用以及<code>Object</code>引用，<code>Entry</code>的<code>referent</code>保存<code>ThreadLocal</code>的弱引用，<code>Entry</code>的<code>value</code>保存<code>Object</code>的强引用。</p><h2>三、threadLoca应用</h2><blockquote><p><code>threadlocal</code>实现的可复用的耗时统计工具<code>Profiler</code></p></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic14-10.png" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-0耗时： 1000</span><br><span class="line">Thread-1耗时： 1999</span><br></pre></td></tr></table></figure><blockquote><p><code>threadLocal</code>实现数据库连接线程隔离</p></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic14-11.png" alt="image"></p><p>通过调用<code>ConnectionManager.getConnection()</code>方法，每个线程获取到的，都是和当前线程绑定的那个<code>Connection</code>对象，第一次获取时，是通过<code>initialValue()</code>方法的返回值来设置值的。通过<code>ConnectionManager.setConnection(Connection conn)</code>方法设置的<code>Connection</code>对象，也只会和当前线程绑定。这样就实现了<code>Connection</code>对象在多个线程中的完全隔离。</p><p>在<code>Spring</code>容器中管理多线程环境下的<code>Connection</code>对象时，采用的思路和以上代码非常相似。</p><h2>四、threadLocal缺陷</h2><p><code>ThreadLocal</code>变量的这种隔离策略，也不是任何情况下都能使用的。</p><p>如果多个线程并发访问的对象实例只能创建那么一个，那就没有别的办法了，老老实实的使用同步机制吧。</p><p>下一篇探讨<code>ThreadLocal</code> 内存泄漏问题。</p><p>参考：</p><ul><li><a href="http://vence.github.io/2016/05/28/threadlocal-info" target="_blank" rel="noopener">深入理解ThreadLocal</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal是面试重灾区，但是好像我没遇到过有人问，尴尬脸，不过我们不能做砧板上的鱼肉静静等待宰割，分为两篇来讲解其中的用法和原理。这是第一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之NIO</title>
    <link href="http://yoursite.com/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BNIO/"/>
    <id>http://yoursite.com/2019/02/20/java-basic/java基础之NIO/</id>
    <published>2019-02-20T06:37:00.275Z</published>
    <updated>2019-02-20T06:46:15.922Z</updated>
    
    <content type="html"><![CDATA[<p>为了限制篇幅，关于IO这一块的内容，已经从本笔记中移除，具体还是另外看笔记，这里主要还是介绍NIO。</p><a id="more"></a><h2>一、NIO</h2><p>非阻塞的输入/输出 (<code>NIO</code>) 库是在 <code>JDK 1.4</code> 中引入的。<code>NIO</code> 弥补了原来的 <code>I/O</code> 的不足，提供了高速的、面向块的 <code>I/O</code>。</p><h2>1.1 阻塞I/O通信模型</h2><p>假如现在你对阻塞I/O已有了一定了解，我们知道阻塞I/O在调用<code>InputStream.read()</code>方法时是阻塞的，它会一直等到数据到来时（或超时）才会返回；同样，在调用<code>ServerSocket.accept()</code>方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。阻塞I/O的通信模型示意图如下：</p><p><img src="http://xiaozhao.oursnail.cn/%E9%98%BB%E5%A1%9EIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="image"></p><p>缺点：</p><ol><li>当客户端多时，会创建大量的处理线程。且每个线程都要占用栈空间和一些CPU时间</li><li>阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。</li></ol><h2>1.2 java NIO原理及通信模型</h2><p>下面是<code>java NIO</code>的工作原理：</p><ol><li>由一个专门的线程来处理所有的 IO 事件，并负责分发。</li><li>事件驱动机制：事件到的时候触发，而不是同步的去监视事件。</li><li>线程通讯：线程之间通过 <code>wait</code>,<code>notify</code> 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。</li></ol><p><img src="http://xiaozhao.oursnail.cn/NIO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="image"></p><p><code>Java NIO</code>的服务端只需启动一个专门的线程来处理所有的 <code>IO</code> 事件，这种通信模型是怎么实现的呢？<code>java NIO</code>采用了双向通道（<code>channel</code>）进行数据传输，而不是单向的流（<code>stream</code>），在通道上可以注册我们感兴趣的事件。一共有以下四种事件：</p><table><thead><tr><th>事件名</th><th>对应值</th></tr></thead><tbody><tr><td>服务端接收客户端连接事件</td><td>SelectionKey.OP_ACCEPT(16)</td></tr><tr><td>客户端连接服务端事件</td><td>SelectionKey.OP_CONNECT(8)</td></tr><tr><td>读事件</td><td>SelectionKey.OP_READ(1)</td></tr><tr><td>写事件</td><td>SelectionKey.OP_WRITE(4)</td></tr></tbody></table><p>服务端和客户端各自维护一个管理通道的对象，我们称之为<code>selector</code>，该对象能检测一个或多个通道 (<code>channel</code>) 上的事件。我们以服务端为例，如果服务端的<code>selector</code>上注册了读事件，某时刻客户端给服务端发送了一些数据，阻塞<code>I/O</code>这时会调用<code>read()</code>方法阻塞地读取数据，而<code>NIO</code>的服务端会在<code>selector</code>中添加一个读事件。服务端的处理线程会轮询地访问<code>selector</code>，如果访问<code>selector</code>时发现有感兴趣的事件到达，则处理这些事件，如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达为止。下面是我理解的<code>java NIO</code>的通信模型示意图：</p><p><img src="http://xiaozhao.oursnail.cn/NIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="image"></p><h2>二、关于阻塞与非阻塞，同步与非同步的理解</h2><p>我们都知道常见的IO有四种方式，同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。然而对于同步和阻塞的理解却一直很模糊。</p><h4>2.1 同步与异步</h4><ul><li>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</li><li>而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</li><li>我们可以用打电话（同步）和发短信（异步）来很好的比喻同步与异步操作。</li></ul><h4>2.2 阻塞和非阻塞</h4><ul><li>阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。</li><li>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。</li><li>虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。</li></ul><h4>2.3 什么是阻塞IO？什么是非阻塞IO？</h4><p>在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。</p><p>通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。</p><p>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：</p><ul><li>查看数据是否就绪；</li><li>进行数据拷贝（内核将数据拷贝到用户线程）。</li></ul><p>那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于<font color="#ff0000">第一个阶段</font>，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p><p><font color="#ff0000">Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</font></p><h4>2.4 什么是同步IO？什么是异步IO？</h4><p>我们知道了，阻塞和非阻塞是判断数据是否就绪时如何处理，即IO操作的第一阶段。</p><p>那么什么是同步IO和异步IO呢？</p><p>我们知道，同步是打电话，异步是发短信，打电话需要等到电话通了才能进行下一步，发短信就不用操心那么多了，我发出去就行了，至于什么时候发送、如何发送以及如何保证我这个短信一定能发出去，我是不管的。</p><p>同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。</p><blockquote><p>描述的是用户线程与内核的交互方式：</p></blockquote><ul><li>同步是指用户线程发起 I/O 请求后需要等待或者轮询内核 I/O操作完成后才能继续执行；</li><li>异步是指用户线程发起I/O请求后仍继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</li></ul><h2>三、Channel（通道）</h2><p>通道，顾名思义，就是通向什么的道路，为某个提供了渠道。在传统IO中，我们要读取一个文件中的内容，通常是像下面这样读取的：</p><p><img src="http://bloghello.oursnail.cn/javabbasic13-1.png" alt="image"></p><p>这里的<code>InputStream</code>实际上就是为读取文件提供一个通道的。<br>因此可以将<code>NIO</code> 中的<code>Channel</code>同传统IO中的<code>Stream</code>来类比，但是要注意，传统IO中，<code>Stream</code>是单向的，比如<code>InputStream</code>只能进行读取操作，<code>OutputStream</code>只能进行写操作。而<code>Channel</code>是双向的，既可用来进行读操作，又可用来进行写操作。</p><p>通道包括以下类型：</p><ul><li><code>FileChannel</code>：从文件中读写数据；</li><li><code>DatagramChannel</code>：通过 UDP 读写网络中数据；</li><li><code>SocketChannel</code>：通过 TCP 读写网络中数据；</li><li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 <code>SocketChannel</code></li></ul><p>下面给出通过<code>FileChannel</code>来向文件中写入数据的一个例子：</p><p><img src="http://bloghello.oursnail.cn/javabasic13-2.png" alt="image"></p><h2>四、Buffer（缓冲区）</h2><p><code>Buffer</code>（缓冲区），是<code>NIO</code>中非常重要的一个东西，在<code>NIO</code>中所有数据的读和写都离不开<code>Buffer</code>。比如上面的一段代码中，读取的数据时放在<code>byte</code>数组当中，而在<code>NIO</code>中，读取的数据只能放在<code>Buffer</code>中。同样地，写入数据也是先写入到<code>Buffer</code>中。</p><p><img src="http://xiaozhao.oursnail.cn/NIOBuffer.jpg" alt="image"></p><p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入<code>Buffer</code>中，然后将<code>Buffer</code>中的内容写入通道。服务端这边接收数据必须通过<code>Channel</code>将数据读入到<code>Buffer</code>中，然后再从<code>Buffer</code>中取出数据来处理。</p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>如果是对于文件读写，上面几种<code>Buffer</code>都可能会用到。但是对于网络读写来说，用的最多的是<code>ByteBuffer</code>。</p><h2>五、缓冲区状态变量</h2><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 <code>position</code> 为 0，而 <code>limit = capacity = 8</code>。<code>capacity</code> 变量不会改变，下面的讨论会忽略它。</p><p><img src="http://xiaozhao.oursnail.cn/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="image"></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 <code>position</code> 移动设置为 5，<code>limit</code> 保持不变。</p><p><img src="http://xiaozhao.oursnail.cn/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="image"></p><p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 <code>flip()</code> 方法，这个方法将 <code>limit</code> 设置为当前 <code>position</code>，并将 <code>position</code> 设置为 0。</p><blockquote><p>buffer中的flip方法涉及到bufer中的Capacity,Position和Limit三个概念。其中Capacity在读写模式下都是固定的，就是我们分配的缓冲大小,Position类似于读写指针，表示当前读(写)到什么位置,Limit在写模式下表示最多能写入多少数据，此时和Capacity相同，在读模式下表示最多能读多少数据，此时和缓存中的实际数据大小相同。在写模式下调用flip方法，那么limit就设置为了position当前的值(即当前写了多少数据),postion会被置为0，以表示读操作从缓存的头开始读。也就是说调用flip之后，读写指针指到缓存头部，并且设置了最多只能读出之前写入的数据长度(而不是整个缓存的容量大小)。</p></blockquote><p><img src="http://xiaozhao.oursnail.cn/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="image"></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 <code>position</code> 设为 4。</p><p><img src="http://xiaozhao.oursnail.cn/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="image"></p><p>⑤ 最后需要调用 <code>clear()</code> 方法来清空缓冲区，此时 <code>position</code> 和 <code>limit</code> 都被设置为最初位置。</p><p><img src="http://xiaozhao.oursnail.cn/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="image"></p><h2>六、文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p><p><img src="http://bloghello.oursnail.cn/javabasic13-3.png" alt="image"></p><h2>七、Selector（选择器）</h2><p>可以说它是<code>NIO</code>中最关键的一个部分，<code>Selector</code>的作用就是用来轮询每个注册的<code>Channel</code>，一旦发现<code>Channel</code>有注册的事件发生，便获取事件然后进行处理。</p><p><img src="http://xiaozhao.oursnail.cn/4d930e22-f493-49ae-8dff-ea21cd6895dc.png" alt="image"></p><p>用单线程处理一个<code>Selector</code>，然后通过<code>Selector.select()</code>方法来获取到达事件，在获取了到达事件之后，就可以逐个地对这些事件进行响应处理。</p><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。</p><p>下面从编程的角度具体来看看选择器是如何实现的。</p><h3>7.1 创建选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3>7.2 将通道注册到选择器上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li><code>SelectionKey.OP_CONNECT</code></li><li><code>SelectionKey.OP_ACCEPT</code></li><li><code>SelectionKey.OP_READ</code></li><li><code>SelectionKey.OP_WRITE</code></li></ul><p>它们在 <code>SelectionKey</code> 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3>7.3 监听事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure><p>使用 <code>select()</code> 来监听事件到达，它会一直阻塞直到有至少一个事件到达。</p><h3>7.4 获取到达的事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>7.5 事件循环</h3><p>因为一次 <code>select()</code> 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>八、流与块</h2><p><code>I/O</code> 与 <code>NIO</code> 最重要的区别是数据打包和传输的方式，<code>I/O</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据。</p><p>面向流的 <code>I/O</code> 一次处理一个字节数据，一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 <code>I/O</code> 通常相当慢。</p><p>面向块的 <code>I/O</code> 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 <code>I/O</code> 缺少一些面向流的 <code>I/O</code> 所具有的优雅性和简单性。</p><p><code>I/O</code> 包和 <code>NIO</code> 已经很好地集成了，<code>java.io.*</code> 已经以 <code>NIO</code> 为基础重新实现了，所以现在它可以利用 <code>NIO</code> 的一些特性。例如，<code>java.io.*</code> 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h2>九、一个完整 NIO 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuffer data = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">"hello world"</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>十、NIO和IO的主要区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>无</td><td>选择器</td></tr></tbody></table><ul><li>面向流与面向缓冲</li></ul><blockquote><p>Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p></blockquote><ul><li>阻塞与非阻塞IO</li></ul><blockquote><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p></blockquote><ul><li>选择器（Selectors）</li></ul><blockquote><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p></blockquote><h2>十一、总结</h2><ul><li><code>NIO</code>其实实现的是一个IO的多路复用，用<code>select</code>来同时监听多个<code>channel</code>，本质上还是同步阻塞的，需要<code>select</code>不断监听端口。但是对于IO各个通道来说就是可以看做是异步。</li><li>基本可以认为 “NIO = I/O多路复用 + 非阻塞式I/O”，大部分情况下是单线程，但也有超过一个线程实现NIO的情况</li><li>我们可以用打电话（同步）和发短信（异步）来很好的比喻同步与异步操作</li><li>阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。</li><li>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。两种方式各有优劣。</li><li>传统IO中，<code>Stream</code>是单向的，比如<code>InputStream</code>只能进行读取操作，<code>OutputStream</code>只能进行写操作。而<code>Channel</code>是双向的，既可用来进行读操作，又可用来进行写操作。</li><li>在<code>NIO</code>中，读取的数据只能放在<code>Buffer</code>中。同样地，写入数据也是先写入到<code>Buffer</code>中。缓冲区有三个状态变量：<code>capacity</code>：最大容量；<code>position</code>：当前已经读写的字节数；<code>limit</code>：还可以读写的字节数。</li><li>Selector的作用就是用来轮询每个注册的Channel，一旦发现Channel有注册的事件发生，便获取事件然后进行处理.</li><li>NIO和IO的主要区别。</li><li>NIO适用场景</li></ul><blockquote><p>服务器需要支持超大量的长时间连接。比如10000个连接以上，并且每个客户端并不会频繁地发送太多数据。例如总公司的一个中心服务器需要收集全国便利店各个收银机的交易信息，只需要少量线程按需处理维护的大量长期连接。</p></blockquote><ul><li>BIO适用场景</li></ul><blockquote><p>适用于连接数目比较小，并且一次发送大量数据的场景，这种方式对服务器资源要求比较高，并发局限于应用中。</p></blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3916526.html" target="_blank" rel="noopener">Java NIO：浅析I/O模型</a></li><li><a href="https://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">NIO与传统IO的区别</a></li><li><a href="https://troywu0.gitbooks.io/spark/content/java-io%E6%B5%81.html" target="_blank" rel="noopener">Java NIO：NIO概述</a></li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20IO" target="_blank" rel="noopener">Java I/O</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了限制篇幅，关于IO这一块的内容，已经从本笔记中移除，具体还是另外看笔记，这里主要还是介绍NIO。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Socket基础</title>
    <link href="http://yoursite.com/2019/02/20/Socket%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/20/Socket基础/</id>
    <published>2019-02-20T03:39:29.748Z</published>
    <updated>2019-02-20T06:25:05.442Z</updated>
    
    <content type="html"><![CDATA[<p>学习I/O几种常见模型以及select、poll、epoll三种多路复用的具体实现。</p><a id="more"></a><h2>一、I/O 模型</h2><p>一个输入操作，即我们常说的读取一个文件，通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。我们看到，这是一个比较麻烦的过程，可能是性能出现瓶颈的地方。</p><p><code>Unix</code> 下有五种 <code>I/O</code> 模型：</p><ul><li>阻塞式 <code>I/O</code></li><li>非阻塞式 <code>I/O</code></li><li><code>I/O</code> 复用（<code>select</code> 和 <code>poll</code>）</li><li>信号驱动式 <code>I/O</code>（<code>SIGIO</code>）</li><li>异步 <code>I/O</code>（<code>AIO</code>）</li></ul><h3>1.1 阻塞式 I/O</h3><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p>下图中，<code>recvfrom</code> 用于接收 <code>Socket</code> 传来的数据，并复制到应用进程的缓冲区 <code>buf</code> 中。这里把 <code>recvfrom()</code> 当成系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure><p><img src="http://xiaozhao.oursnail.cn/%E9%98%BB%E5%A1%9E%E5%BC%8FIO1.png" alt="image"></p><h3>1.2 非阻塞式 I/O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 <code>I/O</code> 是否完成，这种方式成为轮询（<code>polling</code>）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><p><img src="http://xiaozhao.oursnail.cn/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO1.png" alt="image"></p><h3>1.3 I/O 复用</h3><p>使用 <code>select</code> 或者 <code>poll</code> 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 <code>recvfrom</code> 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 <code>Event Driven I/O</code>，即事件驱动 I/O。</p><p>如果一个 <code>Web</code> 服务器没有 I/O 复用，那么每一个 <code>Socket</code> 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><p><img src="http://xiaozhao.oursnail.cn/IO%E5%A4%8D%E7%94%A81.png" alt="image"></p><h3>1.4 信号驱动 I/O</h3><p>应用进程使用 <code>sigaction</code> 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 <code>SIGIO</code> 信号，应用进程收到之后在信号处理程序中调用 <code>recvfrom</code> 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><p><img src="http://xiaozhao.oursnail.cn/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO1.png" alt="image"></p><h3>1.5 异步 I/O</h3><p>进行 <code>aio_read</code> 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E6%AD%A5IO1.png" alt="image"></p><h3>1.6 同步 I/O 与异步 I/O</h3><ul><li>同步 I/O：应用进程在调用 <code>recvfrom</code> 操作时会阻塞。</li><li>异步 I/O：不会阻塞。</li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p><h3>1.7 五大 I/O 模型比较</h3><p>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的：将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p><p><img src="http://xiaozhao.oursnail.cn/%E4%BA%94%E5%A4%A7IO%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%831.png" alt="image"></p><h2>二、select/poll/epoll</h2><p>这三个都是 I/O 多路复用的具体实现，<code>select</code> 出现的最早，之后是 <code>poll</code>，再是 <code>epoll</code>。</p><h3>2.1 select</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-1.png" alt="image"></p><p><code>fd_set</code> 表示描述符集合类型，有三个参数：<code>readset</code>、<code>writeset</code> 和 <code>exceptset</code>，分别对应读、写、异常条件的描述符集合。</p><p><code>timeout</code> 参数告知内核等待所指定描述符中的任何一个就绪可花多少时间；</p><p>成功调用返回结果大于 0；出错返回结果为 -1；超时返回结果为 0。</p><p>每次调用 <code>select</code> 都需要将 <code>fd_set \*readfds, fd_set \*writefds, fd_set \*exceptfds</code> 链表内容全部从应用进程缓冲复制到内核缓冲。</p><p>返回结果中内核并没有声明 <code>fd_set</code> 中哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程需要遍历所有的 <code>fd_set</code>。</p><p><code>select</code> 最多支持 1024 个描述符，其中 1024 由内核的 <code>FD_SETSIZE</code> 决定。如果需要打破该限制可以修改 <code>FD_SETSIZE</code>，然后重新编译内核。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-2.png" alt="image"></p><h3>2.2 poll</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-3.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic12-4.png" alt="image"></p><p>它和 <code>select</code> 功能基本相同。同样需要每次将描述符从应用进程复制到内核，<code>poll</code> 调用返回后同样需要进行轮询才能知道哪些描述符已经准备好。</p><p><code>poll</code> 取消了 1024 个描述符数量上限，但是数量太大以后不能保证执行效率，因为复制大量内存到内核十分低效，所需时间与描述符数量成正比。</p><p><code>poll</code> 在描述符的重复利用上比 <code>select</code> 的 <code>fd_set</code> 会更好。</p><p>如果在多线程下，如果一个线程对某个描述符调用了 <code>poll</code> 系统调用，但是另一个线程关闭了该描述符，会导致 <code>poll</code> 调用结果不确定，该问题同样出现在 <code>select</code> 中。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-5.png" alt="image"></p><h3>2.3 epoll</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-6.png" alt="image"></p><p><code>epoll</code> 仅仅适用于 <code>Linux OS</code>。</p><p>它是 <code>select</code> 和 <code>poll</code> 的增强版，更加灵活而且没有描述符数量限制。</p><p>它将用户关心的描述符放到内核的一个事件表中，从而只需要在用户空间和内核空间拷贝一次。</p><p><code>select</code> 和 <code>poll</code> 方式中，进程只有在调用一定的方法后，内核才对所有监视的描述符进行扫描。而 <code>epoll</code> 事先通过 <code>epoll_ctl()</code> 来注册描述符，一旦基于某个描述符就绪时，内核会采用类似 <code>callback</code> 的回调机制，迅速激活这个描述符，当进程调用 <code>epoll_wait()</code> 时便得到通知。</p><p>新版本的 <code>epoll_create(int size)</code> 参数 <code>size</code> 不起任何作用，在旧版本的 <code>epoll</code> 中如果描述符的数量大于 <code>size</code>，不保证服务质量。</p><p><code>epoll_ctl()</code> 执行一次系统调用，用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理。</p><p><code>epoll_wait()</code> 取出在内核中通过链表维护的 I/O 准备好的描述符，将他们从内核复制到应用进程中，不需要像 <code>select/poll</code> 对注册的所有描述符遍历一遍。</p><p><code>epoll</code> 对多线程编程更有友好，同时多个线程对同一个描述符调用了 <code>epoll_wait()</code> 也不会产生像 <code>select/poll</code> 的不确定情况。或者一个线程调用了 <code>epoll_wait</code> 另一个线程关闭了同一个描述符也不会产生不确定情况。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-7.png" alt="image"></p><h2>三、select 和 poll 比较</h2><h3>3.1 功能</h3><p>它们提供了几乎相同的功能，但是在一些细节上有所不同：</p><ul><li><code>select</code> 会修改 <code>fd_set</code> 参数，而 <code>poll</code> 不会；</li><li><code>select</code> 默认只能监听 1024 个描述符，如果要监听更多的话，需要修改 <code>FD_SETSIZE</code> 之后重新编译；</li><li><code>poll</code> 提供了更多的事件类型。</li></ul><h3>3.2 速度</h3><p><code>poll</code> 和 <code>select</code> 在速度上都很慢。</p><ul><li>它们都采取轮询的方式来找到 I/O 完成的描述符，如果描述符很多，那么速度就会很慢；</li><li><code>select</code> 只使用每个描述符的 3 位，而 poll 通常需要使用 64 位，因此 <code>poll</code> 需要复制更多的内核空间。</li></ul><h3>3.3 可移植性</h3><p>几乎所有的系统都支持 <code>select</code>，但是只有比较新的系统支持 <code>poll</code>。</p><h2>四、eopll 工作模式</h2><p><code>epoll_event</code> 有两种触发模式：<code>LT</code>（<code>level trigger</code>）和 <code>ET</code>（<code>edge trigger</code>）。</p><h3>4.1 LT 模式</h3><p>当 <code>epoll_wait()</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 <code>epoll_wait()</code> 时，会再次响应应用程序并通知此事件。是默认的一种模式，并且同时支持 <code>Blocking</code> 和 <code>No-Blocking</code>。</p><h3>4.2 ET 模式</h3><p>当 <code>epoll_wait()</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 <code>epoll_wait()</code> 时，不会再次响应应用程序并通知此事件。很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 <code>No-Blocking</code>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h2>五、select poll epoll 应用场景</h2><p>很容易产生一种错觉认为只要用 <code>epoll</code> 就可以了，<code>select poll</code> 都是历史遗留问题，并没有什么应用场景，其实并不是这样的。</p><h3>5.1 select 应用场景</h3><p><code>select() poll() epoll_wait()</code> 都有一个 <code>timeout</code>参数，在 <code>select()</code> 中 <code>timeout</code> 的精确度为 1ns，而 <code>poll()</code> 和 <code>epoll_wait()</code> 中则为 1ms。所以 <code>select</code> 更加适用于实时要求更高的场景，比如核反应堆的控制。</p><p><code>select</code> 历史更加悠久，它的可移植性更好，几乎被所有主流平台所支持。</p><h3>5.2 poll 应用场景</h3><p><code>poll</code> 没有最大描述符数量的限制，如果平台支持应该采用 <code>poll</code> 且对实时性要求并不是十分严格，而不是 <code>select</code>。</p><p>需要同时监控小于 1000 个描述符。那么也没有必要使用 <code>epoll</code>，因为这个应用场景下并不能体现 <code>epoll</code> 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的。因为 <code>epoll</code> 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 <code>epoll_ctl()</code> 进行系统调用，频繁系统调用降低效率。<code>epoll</code> 的描述符存储在内核，不容易调试。</p><h3>5.3 epoll 应用场景</h3><p>程序只需要运行在 <code>Linux</code> 平台上，有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p><h2>六、对比</h2><p>举例说明：老师收学生作业，相当于应用层调用I/O操作。</p><p>1、老师逐个收学生作业，学生没有做完，只能阻塞等待，收了之后，再去收下一个学生的作业。这显然存在性能问题。</p><p>2、怎么解决上面的问题？<br>老师找个班长，班长负责收作业，班长的做法是：遍历问学生作业写好了吗，写好的，收起来交给老师。休息一会，再去遍历。。。<br>这个班长就是<code>select</code>。</p><blockquote><p>存在问题</p></blockquote><ul><li>这个班长还有一个能力问题，最多只能管理1024个学生。</li><li>很多学生的作业没有写好，而且短时间写不好，班长还是不停地遍历去问，影响效率。</li></ul><blockquote><p>怎么解决问题1班长的能力问题？</p></blockquote><ul><li>换一个能力更强的班长，可以管理更多的学生，这个班长就是<code>poll</code>。</li></ul><blockquote><p>怎么解决问题1、2，存在的能力问题和效率问题？</p></blockquote><ul><li>换一个能力超级强的班长，可以管理无限多的学生，同时班长的做法是：遍历一次所有的学生，如果作业没有写完，告诉学生写好之后，放在一个固定的地方。这样的话，班长只需要定期到这个地方取作业就好了。这就是<code>epoll</code>。</li></ul><p>参考：</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Socket.md" target="_blank" rel="noopener">socket</a></li><li><a href="https://www.cnblogs.com/java2016/p/5538018.html" target="_blank" rel="noopener">理解 select poll epoll</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习I/O几种常见模型以及select、poll、epoll三种多路复用的具体实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>java基础之泛型下</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8B/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之泛型下/</id>
    <published>2019-02-19T13:12:22.961Z</published>
    <updated>2019-02-19T13:26:22.648Z</updated>
    
    <content type="html"><![CDATA[<p>本节继续讨论泛型相关的知识。</p><a id="more"></a><h2>6、泛型上下边界</h2><p>我们再来讨论讨论通配符。</p><p>通配符有2种：</p><ul><li>无边界通配符，用<code>&lt;?&gt;</code>表示。</li><li>有边界通配符，用<code>&lt;? extends Object&gt;</code>或者<code>&lt;? super Object&gt;</code>来表示。（<code>Object</code>仅仅是一个示例）</li></ul><h5>6.1 无边界</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 合法</span></span><br><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;?&gt;(); <span class="comment">// 不合法</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;?&gt;(); <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><p>对于带有通配符的引用变量，是不能调用具有与泛型参数有关的方法的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(1); // 编译不通过</span><br><span class="line">list.get(0); // 编译通过</span><br><span class="line">int size = list.size(); // 由于size()方法中不含泛型参数，所以可以在通配符变量中调用</span><br></pre></td></tr></table></figure><p>总结起来，无边界通配符主要用做引用，可以调用与泛型参数无关的方法，不能调用参数中包含泛型参数的方法。</p><h5>6.2 有边界</h5><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><ul><li>上边界通配，用&lt;? extends 类型&gt;表示。其语法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends 类型<span class="number">1</span>&gt; x = <span class="keyword">new</span> ArrayList&lt;类型<span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure><p>其中，类型2就只能是类型1或者是类型1的子类。下面代码验证合法性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; x = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//由于Integer是Number的子类，这是合法的</span></span><br><span class="line">List&lt;? extends Number&gt; x = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//由于String不是Number的子类，这是不合法的</span></span><br></pre></td></tr></table></figure><ul><li>下边界通配，用&lt;? super 类型&gt;表示。其语法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> 类型<span class="number">1</span>&gt; x = <span class="keyword">new</span> ArrayList&lt;类型<span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure><p>其中，类型2就只能是类型1或者是类型1的超类。下面代码有验证合法性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> ArrayList&lt;Number&gt;(); <span class="comment">//由于Number是Integer的超类，这是合法的</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//由于String不是Integer的超类，这是不合法的</span></span><br></pre></td></tr></table></figure><p>那么到底什么时候使用下边界通配，什么时候使用上边界通配呢？首先考虑一下怎样才能保证不会发生运行时异常，这是泛型要解决的首要问题，通过前面的内容可以看到，任何可能导致类型转换异常的操作都无法编译通过。</p><ul><li>⭐上边界通配：可以保证存放的实际对象至多是上边界指定的类型，那么在读取对象时，我们总是可以放心地将对象赋予上边界类型的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">List&lt;? extends Number&gt; list2 = list1;</span><br><span class="line">Number a = list2.get(<span class="number">0</span>); <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><ul><li>⭐下边界通配：可以保证存放的实际对象至少是下边界指定的类型，那么在存入对象时，我们总是可以放心地将下边界类型的对象存入泛型对象中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list3.add(<span class="number">1</span>);</span><br><span class="line">list3.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p></blockquote><ul><li>如果你想从一个数据类型里获取数据，使用 ? extends 通配符。</li><li>如果你想把对象写入一个数据结构里，使用 ? super 通配符。</li><li>如果你既想存，又想取，那就别用通配符。</li></ul><p>对于泛型方法添加上下边界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>7、泛型的原理</h2><h5>7.1 类型擦除</h5><p><font color="#ff0000">Java中的泛型是通过类型擦除来实现的</font>。<strong>所谓类型擦除，是指通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。</strong></p><p>下面通过两个例子来证明在编译时确实发生了类型擦除。</p><p>例1分别创建实际类型为<code>String</code>和<code>Integer</code>的<code>ArrayList</code>对象，通过<code>getClass()</code>方法获取两个实例的类，最后判断这个实例的类是相等的，证明两个实例共享同一个类。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-1.png" alt="image"></p><p>例2创建一个只能存储<code>Integer</code>的<code>ArrayList</code>对象，在<code>add</code>一个整型数值后，利用反射调用<code>add(Object o)</code> <code>add</code>一个<code>asd</code>字符串，此时运行代码不会报错，运行结果会打印出1和asd两个值。这时再里利用反射调用<code>add(Integer o)</code>方法，运行会抛出<code>codeNoSuchMethodException</code>异常。这充分证明了在编译后，擦除了<code>Integer</code>这个泛型信息，只保留了原始类型。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-2.png" alt="image"></p><h5>7.2 自动类型转换</h5><p>上一节上说到了类型擦除，Java编译器会擦除掉泛型信息。那么调用<code>ArrayList</code>的<code>get()</code>最终返回的必然会是一个<code>Object</code>对象，但是我们在源代码并没有写过<code>Object</code>转成<code>Integer</code>的代码，为什么就能“直接”将取出来的对象赋予一个<code>Integer</code>类型的变量呢（如下面的代码第12行）？</p><p><img src="http://bloghello.oursnail.cn/javabasic11-3.png" alt="image"></p><p><font color="#ff0000">实际上，Java的泛型除了类型擦除之外，还会自动生成<code>checkcast</code>指令进行强制类型转换</font>。上面的代码中的main方法编译后所对应的字节码如下。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-4.png" alt="image"></p><p>看到第26行代码就是将<code>Object</code>类型的对象强制转换为<code>Integer</code>的指令。我们完全可以将上面的代码转换为下面的代码，它所实现的效果跟上面的泛型是一模一样的。既然泛型也需要进行强制转换，所以泛型并不会提供运行时效率，不过可以大大降低编程时的出错概率。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-5.png" alt="image"></p><h2>8、简单总结</h2><h3>8.1 类型擦除(Type Erasure)</h3><ul><li>Java 的泛型是在编译器层次实现的。</li><li>在编译生成的字节码中不包含泛型中的类型参数，类型参数会在编译时去掉。</li><li>例如：<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在编译后都变成 <code>List</code>。</li><li>类型擦除的基本过程：将代码中的类型参数替换为具体的类，同时去掉 <code>&lt;&gt;</code> 的内容。</li></ul><h3>8.2 泛型的优势</h3><ul><li>编译时更强大的类型检测。</li></ul><p>例如如下代码：方法传入一个<code>String</code>对象，传出一个<code>String</code> 对象，并强制转换为<code>Integer</code>对象。这段代码编译可以通过，因为都是<code>Object</code>的子类，但是运行时会产生<code>ClassCastException</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-6.png" alt="image"></p><p>而如果通过泛型来实现，则会在编译时进行类型的检测。例如如下代码：会产生编译错误。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-7.png" alt="image"></p><ul><li>提供自动和隐式的类型转换</li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-8.png" alt="image"></p><h3>8.3 <code>&lt;T&gt;</code> VS <code>&lt;?&gt;</code></h3><p>不同点：</p><ul><li><code>&lt;T&gt;</code>用于泛型的定义，例如<code>class MyGeneric&lt;T&gt; {...}</code></li><li><code>&lt;?&gt;</code>用于泛型的声明，即泛型的使用，例如<code>MyGeneric&lt;?&gt; g = new MyGeneric&lt;&gt;()</code>;</li></ul><p>相同点：都可以指定上界和下界:</p><p><img src="http://bloghello.oursnail.cn/javabasic11-9.png" alt="image"></p><h3>8.4 <code>&lt;?&gt;</code>不同于<code>&lt;Object&gt;</code></h3><ul><li>指定未知类型，如<code>List&lt;?&gt;</code>。<code>List&lt;?&gt;</code>不等于<code>List&lt;Object&gt;</code></li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-10.png" alt="image"></p><p><code>String</code>是<code>Object</code>的子类，但是<code>List&lt;String&gt;</code>不是<code>List&lt;Object&gt;</code>的子类。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-11.png" alt="image"></p><p>如果将<code>List&lt;Object&gt;</code>换成<code>List&lt;?&gt;</code>，则可以编译通过。</p><p>注意：</p><ul><li>相同参数类型的泛型类的继承关系取决于泛型类自身的继承结构。<br>例如<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code>的子类</li><li>当类型声明中使用通配符<code>?</code>时，其子类型可以在两个维度上扩展。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如 Collection&lt;? extends Number&gt;</span><br><span class="line">在维度<span class="number">1</span>上扩展：List&lt;? extends Number&gt;</span><br><span class="line">在维度<span class="number">2</span>上扩展：Collection&lt;Integer&gt;</span><br></pre></td></tr></table></figure><h2>9、Java泛型中<code>List</code>、<code>List&lt;Object&gt;</code>、<code>List&lt;?&gt;</code>的区别</h2><ul><li><code>List</code>：原生态类型</li><li><code>List&lt;Object&gt;</code>：参数化的类型，表明<code>List</code>中可以<strong>容纳任意类型的对象</strong></li><li><code>List&lt;?&gt;</code>：无限定通配符类型，表示<strong>只能包含某一种未知对象类型</strong></li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-12.png" alt="image"></p><p>我们创建了一个<code>List&lt;String&gt;</code>类型的对象<code>strings</code>，再把它赋给原生态类型<code>List</code>，这是可以的。但是第5行中尝试把它传递给<code>List&lt;Object&gt;</code>时，出现了一个类型不相容错误，注意，这是一个编译期错误。</p><p>这是因为泛型有子类型化的规则：</p><p><code>List&lt;String&gt;</code>是原生态类型<code>List</code>的一个子类型。虽然<code>String</code>是<code>Object</code>的子类型，但是由于泛型是不可协变的，<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，所以这里的传递无法通过编译。</p><p><code>List&lt;Object&gt;</code>唯一特殊的地方只是<code>Object</code>是所有类型的超类，由于泛型的不可协变性，它只能表示<code>List</code>中可以容纳所有类型的对象，却不能表示任何参数类型的<code>List&lt;E&gt;</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-13.png" alt="image"></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">sss</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>List&lt;Object&gt;</code>:表示可用装载任意类型的对象，如上面最后一个例子，但是他不能接受<code>List&lt;String&gt;</code>的替换，因为不具有继承性，并且<code>List&lt;Object&gt;</code>如果可以被<code>List&lt;String&gt;</code>，就不符合原则了，因为<code>List&lt;String&gt;</code>只能接受String类型的对象。</li><li><code>List&lt;?&gt;</code>:解决上面表面有继承关系的List的赋值问题，还有就是，他是用作声明能接收一种未知对象类型，而不是大杂烩啥都能接收。</li><li><code>List</code>：原始类型，啥都没有限制。个人认为与<code>List&lt;Object&gt;</code>类似，但是又没有继承的限制。即啥类型都可以接收。</li></ul><h2>10、参考</h2><ul><li><a href="http://hinylover.space/2016/06/25/relearn-java-generic-1/" target="_blank" rel="noopener">http://hinylover.space/2016/06/25/relearn-java-generic-1/</a></li><li><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">java 泛型详解</a></li><li><a href="https://www.cnblogs.com/rese-t/p/8158870.html" target="_blank" rel="noopener">https://www.cnblogs.com/rese-t/p/8158870.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节继续讨论泛型相关的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之泛型上</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8A/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之泛型上/</id>
    <published>2019-02-19T13:11:29.452Z</published>
    <updated>2019-02-19T13:13:56.474Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章全面介绍Java泛型中的基础及原理。本节主要介绍什么是泛型、泛型的核心特性、泛型与继承注意点、泛型与多态的原理以及泛型的使用。</p><a id="more"></a><h2>1、什么是泛型以及为什么用泛型</h2><p>直接上例子进行说明：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-1.png" alt="image"></p><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>为什么会出现这种问题呢？</p><ul><li>集合本身无法对其存放的对象类型进行限定，可以涵盖Java中的所有类型。缺口太大，导致各种蛇、蚁、虫、鼠通通都可以进来。</li></ul><ul><li>由于我们要使用的实际存放类型的方法，所以不可避免地要进行类型转换。小对象转大对象很容易，大对象转小对象则有很大的风险，因为在编译时，我们无从得知对象真正的类型。</li></ul><p>泛型就是为了解决这类问题而诞生的。</p><h2>2、泛型的特性</h2><h5>2.1 泛型只在编译阶段有效</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-2.png" alt="image"></p><p>输出结果：类型相同</p><blockquote><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。<font color="#ff0000"><strong>也就是说Java中的泛型，只在编译阶段有效</strong>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</font></p></blockquote><p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p><h5>2.2 泛型的兼容性</h5><p>Java编译器是向后兼容的，也就是低版本的源代码可以用高版本编译器进行编译。下面来看看那些兼容性代码。</p><blockquote><ol><li>引用和实例化都不包含泛型信息。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-3.png" alt="image"></p><p>上面的这段代码是可以通过编译的，这是JDK1.4之前的写法，所以可以验证JDK1.5之后的编译器是可以兼容JDK1.4之前的源代码的。不过，笔者在JDK1.8.x版本的编译器进行编译时，会抛出如下所示的警告信息。很显然，如果类被定义成泛型类，但是在实际使用时不使用泛型特性，这是不推荐的做法！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注: Compatibility.java使用了未经检查或不安全的操作。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>引用使用泛型，实例化不使用泛型。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-4.png" alt="image"></p><p>上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告。</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>引用不使用泛型，实例化使用泛型。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-5.png" alt="image"></p><p>上面的这段代码可以编译通过，其效果与1（不使用泛型）完全一致。结合2、3可以知道，编译时只能做引用的类型检查，而无法检查引用所指向对象的实际类型。</p><h2>3、泛型与继承</h2><p>在使用泛型时，引用的参数类型与实际对象的参数类型要保持一致（通配符除外），就算两个参数类型是继承关系也是不允许的。看看下面的2行代码，它们均不能通过编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); <span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>下面来探讨一下为什么不能这么做。</p><ul><li>第1种情况，如果这种代码可以通过编译，那么调用<code>get()</code>方法返回的对象应该是<code>String</code>，但它实际上可以存放任意<code>Object</code>类型的对象，这样在调用类型转换指令时会抛出<code>ClassCastException</code>。</li><li>第2种情况。虽然<code>String</code>类型的对象转换为<code>Object</code>不会有任何问题，但是这有什么意义呢？我们原本想要用<code>String</code>对象的方法，但最终将其赋予了一个<code>Object</code>类型的引用。如果需要使用<code>String</code>中的某些方法，必须将<code>Object</code>强制转换为<code>String</code>。这样不会抛出异常，但是却违背了泛型设计的初衷。</li></ul><h2>4、泛型与多态</h2><p>下面来考虑一下泛型中多态问题。普通类型的多态是通过继承并重写父类的方法来实现的，泛型也不例外，下面是一个泛型多态示例。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic10-7.png" alt="image"></p><p>上面定义了一个泛型父类和一个实际参数为<code>String</code>类型的子类，并“重写”了<code>set(T)</code>和<code>get()</code>方法。<code>Son</code>类中的<code>@Override</code>注解也清楚地显示这是一个重写方法，最终执行的结果如下，与想象中的结果完全一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am father, t=hello world</span><br><span class="line">I am son.</span><br></pre></td></tr></table></figure><p>真的这么简单么？虽然表面上（源代码层面）来看，泛型多态与普通类的多态并无二样，但是其内部的实时原理却大相径庭。</p><p>泛型类<code>Father</code>在编译后会擦除泛型信息，所有的泛型参数都会用<code>Object</code>类替代。实际上，<code>Father</code>编译后的字节码与下面的代码完全一致。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-8.png" alt="image"></p><p><code>Son</code>类的与最终会变为：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-9.png" alt="image"></p><p><code>Father</code>和<code>Son</code>类的<code>set()</code>方法的参数类型不一样，所以，这并不是方法重写，而是方法重载！但是，如果是重载，那么<code>Son</code>类就应该会继承<code>Father</code>类的<code>set(Object)</code>方法，也就是<code>Son</code>会同时包含<code>set(String)</code>和<code>set(Object)</code>，下面来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son son = <span class="keyword">new</span> Son();</span><br><span class="line">son.set(<span class="string">"test"</span>);</span><br><span class="line">son.set(<span class="keyword">new</span> Object()); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>当<code>set</code>一个<code>Object</code>对象时，编译无法通过。这就很奇怪了，感觉跟之前学到的知识是相悖的。我们原本想通过重写方法来实现多态，但由于泛型的类型擦除，却最终变成了重载，所以类型擦除与多态有了矛盾。那么Java是怎么解决这个问题的呢？还是从字节码中找答案吧。<code>Son</code>类最终的编译结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.String)</span></span>;         <span class="comment">// 我们重写的方法</span></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">get</span><span class="params">()</span></span>;              <span class="comment">// 我们重写的方法</span></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;              <span class="comment">// 编译器生成的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;          <span class="comment">// 编译器生成的方法</span></span><br><span class="line">    ...</span><br><span class="line">    2: checkcast     #39                 // class java/lang/String</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><font color="#ff0000">⭐这里面多了一个<code>Object get()</code>方法和<code>set(Object)</code>方法，这两个方法在<code>Son</code>类源代码里面并不存在，这是编译器为了解决泛型的多态问题而自动生成的方法，称为“桥方法”。这两个方法的签名与<code>Father</code>类中的两个方法的签名完全一致，这才是真正的方法重写。也就是说，子类真正重写的我们看不到的桥方法，啊，多么痛的领悟！！！<code>@Override</code>注解只是假象，让人误以为他们真的是重写方法。</font></p><p>再看看<code>set(Object)</code>桥方法的实现细节，先将<code>Object</code>对象强制转换为<code>String</code>对象，然后调用<code>Son</code>中的<code>set(String)</code>方法。饶了一个圈，最终才回到我们“重写”的方法。<code>main</code>方法中原本调用父类的<code>set(Object)</code>方法，由于子类通过桥方法重写了这个方法，所以最终的调用顺序是：<code>set(Object)</code> -&gt; <code>set(String)</code>。</p><p>与<code>set(Object)</code>桥方法的意义不同，<code>Object get()</code>并不仅仅解决泛型与重写的冲突，而更具有一般性。看看下面的代码，这是一个普通类的继承:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralFather</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralSon</span> <span class="keyword">extends</span> <span class="title">GeneralFather</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的返回类型是父类的返回类型的子类，这是允许的，这种特性叫做Java返回值的协变性。而协变性的实现方法就是上面所述的桥方法。</p><p>这里还会有疑惑，<code>set</code>方法可以通过参数类型来确定调用的方法。但是，参数一样而返回值不一样是不能重载的。如果我们在源代码中通过编写<code>String get()</code>和<code>Object get()</code>方法是无法通过编译的。虽然，编译器无法通过编译，但是JVM是可以编写这两种方法的，它调用方法时，将返回值也作为方法签名的一部分。有种只许州官放火，不许百姓点灯的感觉。可以看到，JVM做了不少我们认为不合法的事情，所以如果不深入研究底层原理，有些问题根本解释不了。</p><h2>5、泛型的使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法.</p><h5>5.1 泛型类</h5><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：<code>List</code>、<code>Set</code>、<code>Map</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-10.png" alt="image"></p><p>下面进行实例化：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-11.png" alt="image"></p><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 123456</span><br><span class="line">12-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-12.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/泛型测试: key is 111111</span><br><span class="line">D/泛型测试: key is 4444</span><br><span class="line">D/泛型测试: key is 55.55</span><br><span class="line">D/泛型测试: key is false</span><br></pre></td></tr></table></figure><h5>5.2 泛型接口</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-13.png" alt="image"></p><p>当实现泛型接口的类，未传入泛型实参时：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-14.png" alt="image"></p><p>当实现泛型接口的类，传入泛型实参时：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-15.png" alt="image"></p><h5>5.3 泛型通配符</h5><p><font color="#ff0000">我们知道<code>Ingeter</code>是<code>Number</code>的一个子类，同时我们也验证过<code>Generic&lt;Ingeter&gt;</code>与<code>Generic&lt;Number&gt;</code>实际上是相同的一种基本类型。那么问题来了，在使用<code>Generic&lt;Number&gt;</code>作为形参的方法中，能否使用<code>Generic&lt;Ingeter&gt;</code>的实例传入呢？在逻辑上类似于<code>Generic&lt;Number&gt;</code>和<code>Generic&lt;Ingeter&gt;</code>是否可以看成具有父子关系的泛型类型呢？</font></p><p>为了弄清楚这个问题，我们使用<code>Generic&lt;T&gt;</code>这个泛型类继续看下面的例子：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-16.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic10-17.png" alt="image"></p><p>通过提示信息我们可以看到<code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。由此可以看出:<font color="#ff0000"><strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong></font>。</p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理<code>Generic&lt;Integer&gt;</code>类型的类，这显然与java中的多态理念相违背。因此我们需要一个在逻辑上可以表示同时是<code>Generic&lt;Integer&gt;</code>和<code>Generic&lt;Number&gt;</code>父类的引用类型。由此类型通配符应运而生。</p><p>我们可以将上面的方法改一下：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-18.png" alt="image"></p><p>类型通配符一般是使用<code>'?'</code>代替具体的类型实参，注意，<font color="#ff0000"><strong>此处’?'是类型实参，而不是类型形参</strong></font> 。重要说三遍！此处<code>'?'</code>是类型实参，而不是类型形参 ！ 此处<code>'?'</code>是类型实参，而不是类型形参 ！再直白点的意思就是，此处的<code>'?'</code>和<code>Number</code>、<code>String</code>、<code>Integer</code>一样都是一种实际的类型，可以把<code>'?'</code>看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是<code>'?'</code>；当操作类型时，不需要使用类型的具体功能时，只使用<code>Object</code>类中的功能。那么可以用<code>'?'</code>通配符来表示未知类型。</p><h5>5.4 泛型方法</h5><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-19.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));</span><br></pre></td></tr></table></figure><p>再对泛型方法进行一个比较，加深理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = key；</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//必须要声明E才行</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">setKey</span><span class="params">(E key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = (T)key;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">    <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>5.5 泛型方法与可变参数</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-20.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure><h5>5.6 静态方法与泛型</h5><p><strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</strong></p><p><img src="http://bloghello.oursnail.cn/javabasic10-21.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章全面介绍Java泛型中的基础及原理。本节主要介绍什么是泛型、泛型的核心特性、泛型与继承注意点、泛型与多态的原理以及泛型的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
