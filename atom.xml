<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>但行好事，莫问前程；前路有光，莫忘初心。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-13T13:57:31.258Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-018-移动零</title>
    <link href="http://yoursite.com/2020/01/13/leetcode-array/leetcode-018-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/01/13/leetcode-array/leetcode-018-移动零/</id>
    <published>2020-01-13T13:57:09.425Z</published>
    <updated>2020-01-13T13:57:31.258Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十八道题目是移动零，对应leetcode的题号为283。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p>说明:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h2>解题思路</h2><p>一个简单的思路是复制一个等长的数组，然后前面放非零元素即可，不过题目说明不能拷贝额外的数组空间。那么其实没有这个辅助数组，按照这个思想也是一样的。</p><p>我们只需要遍历数组，把非零元素逐个往前面放即可，最后没有放慢的地方全部赋予零即可。这样既保证了非零元素的相对顺序，又不需要开拓新数组。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length)&#123;</span><br><span class="line">            nums[j++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗 :37.8 MB, 在所有 Java 提交中击败了95.42%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十八道题目是移动零，对应leetcode的题号为283。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-017-缺失数字</title>
    <link href="http://yoursite.com/2020/01/12/leetcode-array/leetcode-017-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/12/leetcode-array/leetcode-017-缺失数字/</id>
    <published>2020-01-12T07:32:41.470Z</published>
    <updated>2020-01-13T13:50:13.849Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十七道题目是存在缺失数字，对应leetcode的题号为268。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 … n 中没有出现在序列中的那个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>首先这道题目一定要先明确数组的定义，这个数组很特别，是[0,1,2…n]这种数组，虽然是乱序的，但是数组一旦排序后就是很紧凑的逐一增加的数组，只不过中间一定少一个元素，我们需要找出来。</p><p>那么显然，常规思路是对数组进行排序，然后逐一比较相邻的两个数只差是否为1，也可以用索引下标去判断是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] != i)&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums.length;</span><br></pre></td></tr></table></figure><p>或者也可以用map来做，首先全部装进map中，然后根据数组的特性，遍历i=0到i=nums.length，如果其中遍历不到的数字，就是我们要返回的不存在的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) set.add(nums[i]);   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)</span><br><span class="line">    <span class="keyword">if</span>(!set.contains(i))&#123;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>不过这么特殊的数组，一定是有特殊的解法的，仔细想想，以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4，3，0，1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>为例，其索引是[0,1,2,3]，那么我们可以根据异或的思想来做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 1 = 0</span><br><span class="line">0 ^ 1 = 1</span><br></pre></td></tr></table></figure><p>那么[4,3,0,1]和[0,1,2,3]做异或，其实可以分解为：3<sup>3，0</sup>0，1^1，我们只需要想办法把4给异或掉，那么就剩下了2，那么结果就是2了（下面主要还是考虑正常情况，如果出现的数组为[0,1,2,3]这种不缺的，那么程序会返回4，这点可以根据情况去斟酌改变，不过不影响核心思想，不必纠结）。</p><p>对于[4,3,0,1]这个数组，我们第一步就用nums.length去和4做抵消。因为数组中最大的数字按照题意必然就是n。</p><p>好了，此时其他所有的n-1个数都互相抵消了，自然就剩下缺失的那个数字了，再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p>数组为[9,6,4,2,3,5,7,0,1]，索引数组为[0,1,2,3,4,5,6,7,8,9]，那么第一步是9^9=0，然后1，2，3，4，5，6，7都可以找到对应的索引异或掉，最终就剩下8了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果遇到0-n都存在的情况，这里就直接返回n+1这个数字即可，因为这种情况题目没有说明如果返回</span></span><br><span class="line">        <span class="keyword">int</span> res = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :1 ms, 在所有 Java 提交中击败了91.92%的用户</span><br><span class="line">内存消耗 :39.6 MB, 在所有 Java 提交中击败了96.09%的用户</span><br></pre></td></tr></table></figure><p>还有一种方法是加减，其实思想跟异或是一样的思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十七道题目是存在缺失数字，对应leetcode的题号为268。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-016-存在重复元素2</title>
    <link href="http://yoursite.com/2020/01/12/leetcode-array/leetcode-016-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/"/>
    <id>http://yoursite.com/2020/01/12/leetcode-array/leetcode-016-存在重复元素2/</id>
    <published>2020-01-12T06:28:19.665Z</published>
    <updated>2020-01-12T06:28:30.621Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十六道题目是存在重复元素2，对应leetcode的题号为219。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p><p>中文题目描述有问题。。。英文题的翻译应该是：「二者差的绝对值不超过 k 即可」，但是题目中的却是「二者差的绝对值最大为 k」。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1], k = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,0,1,1], k = 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [99,99],k=2</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>第一个想到的是暴力解法，双层for循环去逐个寻找，一旦找到满足条件的就停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略非空等判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[j] &amp;&amp; Math.abs(i-j) &lt;= k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果不理想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :303 ms, 在所有 Java 提交中击败了21.49%的用户</span><br><span class="line">内存消耗 :41.2 MB, 在所有 Java 提交中击败了96.84%的用户</span><br></pre></td></tr></table></figure><p>其实可以借助map来实现，按照经验，一般的数组查找题目都可以利用map来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span> || nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map，key存储元素值nums[i]，value存储索引i</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//map中存在说明元素相等，此时判断索引距离是否小于等于k，是则找到了，不是继续努力</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]) &amp;&amp; Math.abs(i-map.get(nums[i]))&lt;=k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这一步就说明找不到了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效率得到了大幅的提升，虽然用了额外的O(n)的空间，不过空间换时间往往是值得的，也是提升算法效率的一个捷径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :12 ms, 在所有 Java 提交中击败了93.50%的用户</span><br><span class="line">内存消耗 :43 MB, 在所有 Java 提交中击败了82.02%的用户</span><br></pre></td></tr></table></figure><p>不过这个方法是否可以简单点写？我在题解中看到用set来实现的，思路十分简单：</p><ul><li>遍历数组，对于每个元素做以下操作：<ul><li>在散列表中搜索当前元素，如果找到了就返回 true。</li><li>在散列表中插入当前元素。</li><li>如果当前散列表的大小超过了 k， 删除散列表中最旧的元素。</li></ul></li></ul><p>最后一步很关键，只要set的长度大于k了，那么最旧的元素也就失去了去查询的意义，直接去除掉，并且这样做的好处是，控制一个set的窗口大小，查询上只需要对这k个元素查询即可，某种意义上来说提高了一定的查询效率，虽然也不大。最后就是set的实现代码比map的实现代码要简单点^^。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(set.size() == k+<span class="number">1</span>)&#123;</span><br><span class="line">                set.remove(nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道为什么，提交几遍，这种方式执行用时比map要长。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十六道题目是存在重复元素2，对应leetcode的题号为219。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-015-存在重复元素</title>
    <link href="http://yoursite.com/2020/01/10/leetcode-array/leetcode-015-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/01/10/leetcode-array/leetcode-015-存在重复元素/</id>
    <published>2020-01-10T14:04:49.514Z</published>
    <updated>2020-01-10T14:40:41.964Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十五道题目是存在重复元素，对应leetcode的题号为217。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>寻找重复元素的思路，比暴力解法还直接进入我脑海的思路还是Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过执行效率并不满意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :14 ms, 在所有 Java 提交中击败了43.49%的用户</span><br><span class="line">内存消耗 :43.6 MB, 在所有 Java 提交中击败了85.01%的用户</span><br></pre></td></tr></table></figure><p>不过这道题目也没想出其他什么快速的思路，翻了下评论和题解区，也都大同小异，不过这题写法上可以用hashset来精简下，不过看过java容器的同学一定直到hashset的本质就是hashmap.</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十五道题目是存在重复元素，对应leetcode的题号为217。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-014-旋转数组</title>
    <link href="http://yoursite.com/2020/01/09/leetcode-array/leetcode-014-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/09/leetcode-array/leetcode-014-旋转数组/</id>
    <published>2020-01-09T14:05:01.228Z</published>
    <updated>2020-01-09T14:05:45.941Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十四道题目是旋转数组，对应leetcode的题号为189。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p><h2>解题思路</h2><p>第一个思路是我以前用的，就是要求循环数组，那么就可以变换思路：</p><p>比如数组为[1,2,3,4]</p><p>我组装新的数组：[1,2,3,4,1,2,3,4]</p><p>那么k=0时对应的是[1,2,3,4]，那么从index=(4-0)处开始读取，所以还是[1,2,3,4]；</p><p>k=1时对应的是[4,1,2,3]，那么从index=(4-1)处开始读取，所以是[4,1,2,3]；</p><p>…</p><p>当k=4的时候，又跟k=0的情况一样了，那么其实k=4<em>i的时候都跟k=0一样，k=4</em>i+1的时候都跟k=1一样，所以计算的时候对k%length一下就是通用情况了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个长度为两倍的数组，存储两个nums，循环k个其实就是从这大数组中寻找对应的位置读取出来即可</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">            temp[i] = nums[i%nums.length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于k其实是一个循环的数字，比如数组长度为4时，k=1和k=5效果是一样的，所以我只计算一种情况即可</span></span><br><span class="line">        <span class="keyword">int</span> index = nums.length-k%nums.length;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始赋值，读取指定的数组区间的数字就是我们需要的数组序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length+index;i++)&#123;</span><br><span class="line">            nums[j++] = temp[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :1 ms, 在所有 Java 提交中击败了81.21%的用户</span><br><span class="line">内存消耗 :37.8 MB, 在所有 Java 提交中击败了92.59%的用户</span><br></pre></td></tr></table></figure><p>不过题目最后说有很多种算法，尤其是原地算法，上一种算法开辟了一个新数组，因此还需要想想办法如何原地实现。</p><p>假设 n=7n=7 且 k=3k=3 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                  : 1 2 3 4 5 6 7</span><br><span class="line">反转所有数字后             : 7 6 5 4 3 2 1</span><br><span class="line">反转前 k 个数字后          : 5 6 7 4 3 2 1</span><br><span class="line">反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果</span><br></pre></td></tr></table></figure><p>规律就是：先反转整个数组，然后反转前面k个，最后反转最后n-k个，即可返回会最终的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :1 ms, 在所有 Java 提交中击败了81.21%的用户</span><br><span class="line">内存消耗 :37.3 MB, 在所有 Java 提交中击败了95.41%的用户</span><br></pre></td></tr></table></figure><p>代码如下：</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        nums = reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        nums = reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        nums = reverse(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十四道题目是旋转数组，对应leetcode的题号为189。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-013-多数元素</title>
    <link href="http://yoursite.com/2020/01/08/leetcode-array/leetcode-013-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/01/08/leetcode-array/leetcode-013-多数元素/</id>
    <published>2020-01-08T14:15:32.376Z</published>
    <updated>2020-01-08T14:15:47.299Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十三道题目是多数元素，对应leetcode的题号为169。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>题目提示说一定存在那个多数的数，因此我们不要想其他复杂的情形了，只要专注于找这个数即可。第一个想到的思路是用MAP来存储元素和元素出现的个数，一旦某个元素的个数达标就返回结果，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个元素的时候，直接返回第一个元素即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用map存储，key存储nums[i]，value存储个数，逐一比较的过程中判断哪个元素个数大于一半就返回</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(nums[i]) &gt; nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里说明找不到，不过按照题意，是一定可以找到的</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过发现时间复杂度比较高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :27 ms, 在所有 Java 提交中击败了15.28%的用户</span><br><span class="line">内存消耗 :39.8 MB, 在所有 Java 提交中击败了93.22%的用户</span><br></pre></td></tr></table></figure><p>经过翻答案，发现了一个比较好的方法，那就是大名鼎鼎的摩尔投票法，基本思想为：我们假设这样一个场景，在一个游戏中，分了若干个队伍，有一个队伍的人数超过了半数。所有人的战力都相同，不同队伍的两个人遇到就是同归于尽，同一个队伍的人遇到当然互不伤害。这样经过充分时间的游戏后，最后的结果是确定的，一定是超过半数的那个队伍留在了最后。</p><p>其实一样，经过这种抵消计数，最终能留下来的一定就是数量大于一半的数字了，效果的提升也很明显：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :2 ms, 在所有 Java 提交中击败了87.08%的用户</span><br><span class="line">内存消耗 :43 MB, 在所有 Java 提交中击败了81.15%的用户</span><br></pre></td></tr></table></figure><p>代码见下面。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//count专门来计数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//res作为对比的数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//count为0说明前面都抵消了，前面的已经没有对比价值了，重新开始继续比</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == res)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还可以通过排序来做，排完序后，数量大于一半的数字，一定会出现在数组的中间位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十三道题目是多数元素，对应leetcode的题号为169。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-012-两数之和2-输入有序数组</title>
    <link href="http://yoursite.com/2020/01/07/leetcode-array/leetcode-012-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/07/leetcode-array/leetcode-012-两数之和2-输入有序数组/</id>
    <published>2020-01-07T14:22:05.939Z</published>
    <updated>2020-01-07T14:24:55.299Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十二道题目是两数之和2-输入有序数组，对应leetcode的题号为167。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>因为是有序数据，那么就比较简单了，一头一尾前后夹逼即可。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//定义一头一尾的指针，前后夹逼试探</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[low] + numbers[high] == target)&#123;</span><br><span class="line">                <span class="comment">//注意下返回结果是数组下标+1</span></span><br><span class="line">                res[<span class="number">0</span>] = low + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = high + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[low] + numbers[high] &lt; target)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十二道题目是两数之和2-输入有序数组，对应leetcode的题号为167。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-011-买卖股票的最佳时机2</title>
    <link href="http://yoursite.com/2020/01/05/leetcode-array/leetcode-011-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2/"/>
    <id>http://yoursite.com/2020/01/05/leetcode-array/leetcode-011-买卖股票的最佳时机2/</id>
    <published>2020-01-05T11:16:49.059Z</published>
    <updated>2020-01-05T11:17:03.884Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十一道题目是买卖股票的最佳时机2，对应leetcode的题号为122。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>同一天的股票可以买入再卖出，也可以卖出再买入。因此只要今天的价格比昨天高，我们就买入昨天的再卖出今天的。也就是贪心的思想，只要今天比昨天好，今天就卖出。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])&#123;</span><br><span class="line">                max += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十一道题目是买卖股票的最佳时机2，对应leetcode的题号为122。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-010-买卖股票的最佳时机</title>
    <link href="http://yoursite.com/2020/01/05/leetcode-array/leetcode-010-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/01/05/leetcode-array/leetcode-010-买卖股票的最佳时机/</id>
    <published>2020-01-05T11:16:01.306Z</published>
    <updated>2020-01-05T11:16:33.061Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十道题目是买卖股票的最佳时机，对应leetcode的题号为121。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出时间需要大于买入时间。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>这个题目的思路为：寻找当天的最大受益值（prices[i]-min），然后在所有天的最大收益中取出最大值就是本题的结果。并且注意min的值也要不断去判断获取。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、数组为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、max记录最大值，min记录数据中的最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//3、开始寻找最大的收益max和最小的值min</span></span><br><span class="line">        <span class="comment">//max为当前索引的值减去min就是第i天的最大收益，最终max记录的就是某天的最大收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            max = Math.max(max,prices[i] - min);</span><br><span class="line">            min = Math.min(min,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十道题目是买卖股票的最佳时机，对应leetcode的题号为121。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-009-杨辉三角2</title>
    <link href="http://yoursite.com/2020/01/05/leetcode-array/leetcode-009-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/"/>
    <id>http://yoursite.com/2020/01/05/leetcode-array/leetcode-009-杨辉三角2/</id>
    <published>2020-01-04T16:30:11.064Z</published>
    <updated>2020-01-04T16:33:41.160Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第九道题目是杨辉三角2，对应leetcode的题号为119。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你可以优化你的算法到 O(k) 空间复杂度吗？</p><h2>解题思路</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意本题的rowIndex是从0开始计算的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放最终结果的集合</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//每一行结果存放</span></span><br><span class="line">        List&lt;Integer&gt; rowList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将杨辉三角的结构以二维数组来描述，方便进行三角的构建</span></span><br><span class="line">        <span class="comment">//此时默认数组所有元素都是0</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[rowIndex+<span class="number">1</span>][rowIndex+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//开始构建每一行的数组的数据，并且最终放到list中返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">            rowList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//每一行的第一个元素都是1</span></span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            rowList.add(arr[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//开始从每一行的第二个元素计算，如何计算呢？其实就是依靠上一行元素进行计算的，公式为：</span></span><br><span class="line">            <span class="comment">//arr[i][j] = arr[i-1][j-1] + arr[i-1][j]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j-<span class="number">1</span>] + arr[i-<span class="number">1</span>][j];</span><br><span class="line">                rowList.add(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是第rowindex行了，则直接返回即可</span></span><br><span class="line">            <span class="keyword">if</span>(i == rowIndex)&#123;</span><br><span class="line">                <span class="keyword">return</span> rowList;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(rowList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了程序不会报错，返回集合的最后一个元素</span></span><br><span class="line">        <span class="keyword">return</span> res.get(res.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何达到O(K)的空间复杂度呢？其实没必要用一个数组来存储所有的元素，可以用一个list来存放上一行的数据，见下面代码：</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意本题的rowIndex是从0开始计算的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//curr用来存放当前行元素</span></span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//pre用来存放上一行元素</span></span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">            curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="comment">//根据规律，每一行第一个元素和第i个元素都是为1</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || j == i)&#123;</span><br><span class="line">                    curr.add(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    curr.add(pre.get(j-<span class="number">1</span>)+pre.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新pre指向curr，用于下一行循环，即保存了新的上一行数据用于下一行的计算，节省了空间复杂度</span></span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>结语</h2><p>杨辉三角作为一个经典题目，在大学学习编程的时候或许就遇到过这个问题，其实还有很多很多的优化方案，希望自己以后能够多扩展思路，不能为了做题而做题，因此，总有一天我会回来的，将这道题目优化到底。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第九道题目是杨辉三角2，对应leetcode的题号为119。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-008-杨辉三角</title>
    <link href="http://yoursite.com/2020/01/05/leetcode-array/leetcode-008-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>http://yoursite.com/2020/01/05/leetcode-array/leetcode-008-杨辉三角/</id>
    <published>2020-01-04T16:29:22.377Z</published>
    <updated>2020-01-10T14:40:40.214Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第八道题目是杨辉三角，对应leetcode的题号为118。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>见注释。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1</span></span><br><span class="line"><span class="comment">*  1 1</span></span><br><span class="line"><span class="comment">*  1 2 1</span></span><br><span class="line"><span class="comment">*  1 3 3 1</span></span><br><span class="line"><span class="comment">*  1 4 6 4 1</span></span><br><span class="line"><span class="comment">*  1 5 10 10 5 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="comment">//存放最终结果的集合</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//每一行结果存放</span></span><br><span class="line">        List&lt;Integer&gt; rowList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将杨辉三角的结构以二维数组来描述，方便进行三角的构建</span></span><br><span class="line">        <span class="comment">//此时默认数组所有元素都是0</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[numRows][numRows];</span><br><span class="line">        <span class="comment">//开始构建每一行的数组的数据，并且最终放到list中返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            rowList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//每一行的第一个元素都是1</span></span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            rowList.add(arr[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//开始从每一行的第二个元素计算，如何计算呢？其实就是依靠上一行元素进行计算的，公式为：</span></span><br><span class="line">            <span class="comment">//arr[i][j] = arr[i-1][j-1] + arr[i-1][j]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j-<span class="number">1</span>] + arr[i-<span class="number">1</span>][j];</span><br><span class="line">                rowList.add(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这每一行的数据已经处理完毕，添加到最终的集合中即可</span></span><br><span class="line">            res.add(rowList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第八道题目是杨辉三角，对应leetcode的题号为118。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-007-合并两个有序数组</title>
    <link href="http://yoursite.com/2020/01/03/leetcode-array/leetcode-007-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/03/leetcode-array/leetcode-007-合并两个有序数组/</id>
    <published>2020-01-03T15:19:15.896Z</published>
    <updated>2020-01-03T15:22:04.404Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第七道题目是合并两个有序数组，对应leetcode的题号为88。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>这道题目，其实就是归并排序的思想，简单说明就是：两个指针，分别指向两个有序数组的最后一位，两两比较，把大的一个拎出来，并且大的那个指针往前移动一格继续比较。比较到最后，必然有一个先到头，另一个没到头的指针，前面所有元素就是两个数组中最小的有序部分，直接挪到排序后数组的最前面就可以了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>,j = n-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//归并排序的思想，从后往前慢慢比较、填充</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                nums1[index--] = nums1[i--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[index--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//剩下的元素，要么nums1还没比完要么nums2还没比完，直接将剩下没比完的数据复制到nums1的前面即可</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[index--] = nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[index--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第七道题目是合并两个有序数组，对应leetcode的题号为88。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-006-加一</title>
    <link href="http://yoursite.com/2020/01/03/leetcode-array/leetcode-006-%E5%8A%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/01/03/leetcode-array/leetcode-006-加一/</id>
    <published>2020-01-03T14:46:16.988Z</published>
    <updated>2020-01-03T14:46:30.468Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第六道题目是加一，对应leetcode的题号为66。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>一开始琢磨半天，没看懂是啥玩意。不过如果再写一个示例就明确了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,9,9]</span><br><span class="line">输出: [2,0,0]</span><br><span class="line">解释: 输入数组表示数字 200。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,9,9]</span><br><span class="line">输出: [1,0,0,0]</span><br><span class="line">解释: 输入数组表示数字 1000。</span><br></pre></td></tr></table></figure><p>其实就是说，一个数组表示的非负整数去加一后的结果再去以一个数组来表示。由于是非负整数，那么如果第一位就是0的话，那必定就是0了，这题的难点就在于可能某个数在加一之后会增加一位，比如999是三位数，加一后就变成四位数了。那么原来长度为3的数组就不能容纳下这个长度为4的数据了。</p><p>这一道题目的思路比较巧妙，我们从最后一个数字来判断是否为9，如果不是，那么直接最后一位加一即可结束，如果最后一位是9，那么就需要改为0，然后继续判断倒数第二位，同理，倒数第二位如果不是9则加一结束，否则置为0继续往前判断。</p><p>如果在for循环中一直没出来，那么就说明提供的数字全是9，此时就需要新建一个数组了，长度为原数组加一，然后第一位置为1即可，因为其他位默认为0。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="comment">//1、非空判断</span></span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">9</span>)&#123;</span><br><span class="line">                <span class="comment">//2、此时只需要加一就是我们需要的最终结果，直接return</span></span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//3、走到这里说明此时第i个元素是9，那么按照进位加一则为0，进行下一轮的判断</span></span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、如果走到这里，说明digits里面所有元素都是9，则新建数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第六道题目是加一，对应leetcode的题号为66。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-005-最大子序和</title>
    <link href="http://yoursite.com/2020/01/02/leetcode-array/leetcode-005-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://yoursite.com/2020/01/02/leetcode-array/leetcode-005-最大子序和/</id>
    <published>2020-01-02T14:47:00.980Z</published>
    <updated>2020-01-02T14:48:05.748Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第五道题目是移除元素，对应leetcode的题号为53。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>这道题目可以利用贪心算法的思想来解决，时间复杂度为O(n)，所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。</p><p>那么我们可以从头开始往后试，定义一个值叫sum，这个sum专门来计算连续子数组的和，因为贪心嘛，追求的是最好每次sum都在逐渐增加，但是呢，实际上我又不能每次都管增加的，有的时候会适当下降是为了下一个元素的猛增。因此其实也不贪心，标准设置为0，只要sum不小于0我就一直往后加，一旦小于0，那么此时sum包含的子数组串已经失去意义了，就从新的位置重新计算sum。在这过程中，一直与最大值做比较，从而在局部的最优解中逐渐获取到全局最优解。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//收益是正的，则加上当前值再去试试</span></span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果sum加上当前的值都小于0了，干脆sum就改为当前值再继续往后试</span></span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//res记录的就是最大的和</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt; res)&#123;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题其实是动态规划的典型题目（上面个代码是用贪心角度来说的，其实吧，跟下面的动态规划也没啥大区别，不过姑且分开吧，因为动态规划是有其强烈的自身标识的，即可以用一个表达式来表达出求解规律）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] 定义为数组nums 中已num[i] 结尾的最大连续子串和， 则有：</span><br><span class="line">dp[i] = max(dp[i-1] + nums[i], num[i]);</span><br></pre></td></tr></table></figure><p>其实就是说，【前面比较的结果+当前值】与【当前值】做比较，谁大就取谁。其实跟上面所谓的贪心思路是不是差不多？实际上，这种看起来思路是清晰一点的，掌握了动态规划还是可以写出来的，不过上面的贪心是需要一定的功力才能写出来（我觉得）。</p><p>用一个临时数组来存放遍历过程中的最大值，最后取这个临时数组最大值即可，时间复杂度O(n)，空间复杂度O(n)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//给dp数组的第一个元素也赋予上值，dp后续的元素就是存放的当前遍历到的最大值</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//动态规划的核心思想：要么取当前值，要么就取以前的最优结果+当前值</span></span><br><span class="line">            <span class="comment">//其实就是看前面算出来的最大值跟当前值结合是否能增大收益</span></span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; max)&#123;</span><br><span class="line">                max = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不需要数组，因为我们可以发现，我们每次只关心dp数组的最后一个有效值，因此我们想办法用一个变量把最后一个有效值保存下来即可。见最终提交代码：</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放最大和</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//用temp来代替数组，减少空间复杂度</span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//a存放的就是之前的dp[i-1]+nums[i]</span></span><br><span class="line">            <span class="keyword">int</span> a = temp + nums[i];</span><br><span class="line">            <span class="comment">//b存放的就是nums[i]</span></span><br><span class="line">            <span class="keyword">int</span> b = nums[i];</span><br><span class="line">            <span class="comment">//maxTemp记录此次比较的最大值</span></span><br><span class="line">            <span class="keyword">int</span> maxTemp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//刷新temp的值，如果a大，那么temp刷新为dp[i-1]+nums[i]</span></span><br><span class="line">            <span class="comment">//如果b大，那么temp刷新为nums[i]，temp就相当于dp[i]里面的值，只是我们不关心i之前的值了，所以只要存下dp[i]的值就够了</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">                maxTemp = a;</span><br><span class="line">                temp = a;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxTemp = b;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//刷新max的值，使得max每次都保存最大值</span></span><br><span class="line">            <span class="keyword">if</span>(maxTemp &gt; max)&#123;</span><br><span class="line">                max = maxTemp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第五道题目是移除元素，对应leetcode的题号为53。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-004-搜索插入位置</title>
    <link href="http://yoursite.com/2020/01/01/leetcode-array/leetcode-004-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/01/01/leetcode-array/leetcode-004-搜索插入位置/</id>
    <published>2020-01-01T12:42:42.816Z</published>
    <updated>2020-01-01T12:43:04.388Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第四道题目是移除元素，对应leetcode的题号为35。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>其实最简单的方式是直接遍历有序数组，因为这个题目并没有要求要把target插入到数组指定位置，只需要返回需要插入的索引即可，那我们直接一个一个往后寻找即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//当遇到跟目标值相等则返回其索引</span></span><br><span class="line">            <span class="comment">//当没有相等的，那么返回的索引即第一个比目标值大的位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这一步，要么返回0，要么说明target被插入到数据最后一个位置了</span></span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过当数据量很大的时候，比如这个有序数组有几十万数据，那么从头遍历的效率会比较低，那么就需要有一定的跳跃来减少不必要的查询，那么由于是有序数组，第一个想到的必然就是二分查找法，直接能把搜索的返回缩小为原来的一半，有效提高效率。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length-<span class="number">1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找着？那么返回left即可，因为走到这一步的上一步的时候，left和right相等，此时target是介于left-1和left的值的中间的，那么target插入到left位置即可</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第四道题目是移除元素，对应leetcode的题号为35。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-003-移除元素</title>
    <link href="http://yoursite.com/2019/12/31/leetcode-array/leetcode-003-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/12/31/leetcode-array/leetcode-003-移除元素/</id>
    <published>2019-12-31T14:32:04.623Z</published>
    <updated>2019-12-31T14:33:44.130Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第三道题目是移除元素，对应leetcode的题号为27。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><blockquote><p>给定 nums = [3,2,2,3], val = 3,</p><p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p><p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>注意这五个元素可为任意顺序。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h2>解题思路</h2><p>有了上一题的经验，这一题比较简单，其实还是两个指针，第一个指针指向的位置前面所有元素应该都不与val相等（不包含i所指向的位置）；第二个指针负责遍历，一旦遍历到与val不相等的，就往i位置插入即可，然后i后移一格，等待插入下一个不等于val的值。最终返回的就是i的值。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != val)&#123;</span><br><span class="line">                nums[i++] = nums[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以下写法等同于上面写法</span></span><br><span class="line">        <span class="comment">// int i=0;</span></span><br><span class="line">        <span class="comment">// for(int j=0;j&lt;nums.length;j++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[j] != val)&#123;</span></span><br><span class="line">        <span class="comment">//         nums[i++] = nums[j];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第三道题目是移除元素，对应leetcode的题号为27。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-002-删除排序数组中的重复项</title>
    <link href="http://yoursite.com/2019/12/30/leetcode-array/leetcode-002-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/12/30/leetcode-array/leetcode-002-删除排序数组中的重复项/</id>
    <published>2019-12-30T14:37:04.329Z</published>
    <updated>2019-12-31T14:33:17.158Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二道题目是删除排序数组中的重复项，对应leetcode的题号为26。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><ul><li>示例 1:</li></ul><blockquote><p>给定数组 nums = [1,1,2],</p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><ul><li>示例 2:</li></ul><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>说明:</p></blockquote><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">or (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">   print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>根据题目要求，只能原地进行排除，并且还是一个排序的数组，那么肯定需要两个指针来实现，一个指针负责掌管前面已经不重复的元素索引，后者负责遍历所有元素，只要有不重复的，那么就将j所在的元素赋予给i后面一个位置的元素，然后i和j分别后移一位即可。那么到最后，i指向的元素以及前面所有元素都是不重复的。最终j遍历到数据结束为止。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分析数组为空或者只有一个元素的情况，返回数组长度即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">0</span> || nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针，i指向的元素，前面都是确定不重复的，最后返回长度的时候即（i+1）就是i所有不重复元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length)&#123;</span><br><span class="line">            <span class="comment">//不相等的时候，则将j的元素赋予给i+1后面一个元素，并且各自后移一位</span></span><br><span class="line">            <span class="comment">//比如[1,2]，此时将j=1的值赋给i=1的值即可，最后数组还是[1,2]</span></span><br><span class="line">            <span class="comment">//比如[1,1,2]，第一步是进入else即j=2，下一步j=2赋予给i=1，那么数组最终为[1,2,2]，返回i+1即2即可。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[j])&#123;</span><br><span class="line">                <span class="comment">//这一行是本题精华，j指向的元素挪到i后面一个元素，i和j分别加一</span></span><br><span class="line">                nums[++i] = nums[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//相等，那么j后移一位即可</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二道题目是删除排序数组中的重复项，对应leetcode的题号为26。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>关于CNAME</title>
    <link href="http://yoursite.com/2019/12/28/miscellany/21%E5%85%B3%E4%BA%8ECNAME/"/>
    <id>http://yoursite.com/2019/12/28/miscellany/21关于CNAME/</id>
    <published>2019-12-28T14:43:28.093Z</published>
    <updated>2019-12-28T14:56:40.207Z</updated>
    
    <content type="html"><![CDATA[<p>关于cname一直都知道名词，但是不知道具体作用，看到一篇比较好的文章，转载下来。</p><a id="more"></a><p>当你上网时，在地址栏输入：<code>www.baidu.com</code> 的时候，你知道弹出的那个百度首页是从哪里来的吗？</p><p>对，是从网站服务器调取过来的，这个过程是通过域名解析获得IP地址后，然后向网站服务器发送请求，网站服务器做出响应，最后再将这个网页发送到你的浏览器。</p><p>再详细一点的描述是，每个域名（<code>www.baidu.com</code>）背后实际上是有个地址，这个地址代表的是网站服务器的地址。在互联网上，域名的存在只是便于记忆，它背后真实的识别方式是IP地址。</p><p>当我们在浏览器上输入域名后，我们的电脑会通过一个叫<code>DNS</code>的系统去解析这个域名，并获得IP地址。</p><div class="tip">DNS（Domain Name System[域名系统])，万维网上作为域名和IP地址相互映射的一个[分布式数据库]能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</div><p>这个过程中还会涉及到域名指向的设置，我们知道域名是有顶级域名（<code>baidu.com</code>)，二级域名（<code>www.baidu.com</code>)之分的，当多个域名都指向一个网站服务器上时，需要将这些子域名（顶级域名下面的二级域名、三级域名都称之为子域名）设置并指向自己的网站服务器上的，这个动作一般称之为A记录，又称IP指向。</p><div class="tip">A (Address) 记录是用来指定域名对应的IP地址记录。</div><p>说到这里实际上就会产生一个问题，就是当服务器需要更换时，这些原本指向这台服务器的域名就需要重新设置，并指向新的服务器，这样就会产生比较大的工作量。</p><p>说到这我们就要来说下<code>CNAME</code>。</p><div class="tip">CNAME：即别名记录。这种记录允许您将多个名字映射到另外一个域名。</div><p>简单来说，A记录就是把一个域名解析到一个IP地址，而<code>CNAME</code>记录就是把域名解析到另外一个域名。</p><p>比如<code>www.baidu.com</code>，这个二级域名解析到的是一个服务器的IP地址，比如<code>8.8.8.8</code>，而<code>CNAME</code>是将新域名，比如：<code>a.www.baidu.com</code>解析到另外一个域名，比如：<code>www.baidu.com</code>。</p><p>当新域名产生后都指向<code>CNAME</code>域名后，在发生服务器需要更换或者迁移时，就只需要把<code>www.baidu.com</code>这个域名做重新设置就可以了，这样就减少了很多工作量。</p><p><code>CNAME</code>在<code>CDN</code>中的应用<br><code>CNAME</code>的应用还远不止于此，在<code>CDN</code>（内容分发网络）上也是不可缺少的一环。</p><p><code>CDN</code>的主要功能是将原本离用户比较远的源站服务器，通过丰富的节点（缓存服务器）放到离用户最近的地方，实现用户对互联网上资源的快速访问。</p><p>这个快速访问的过程就需要<code>CNAME</code>的参与。</p><p>原理是这样的：</p><p>用户向浏览器提供要访问的域名，浏览器对域名进行解析，由于 <code>CDN</code> 参与后，对域名解析过程进行了调整，解析的结果不再是一个IP地址，而是该域名对应的 <code>CNAME</code> 。</p><p>但 <code>CNAME</code> 无法完成最终内容的获取，所以，浏览器需要再次对获得的 <code>CNAME</code> 进行解析，以得到实际的 IP 地址。在此过程中，<code>CDN</code>会根据用户的实际地理位置信息解析对应的 IP 地址，使得用户能就近访问。</p><p>这个过程中， <code>CNAME</code>的主要作用是配合<code>CDN</code>的负载均衡系统将<code>CNAME</code>背后对应的节点IP分配给不同的用户去访问。</p><p>总的来讲， <code>CNAME</code>提供了单一服务器和海量服务器的在管理<br>访问上的灵活性。单一服务器的场景下，通过将大量子域名指向到<code>CNAME</code>，再由 <code>CNAME</code> 指向到单一域名，解决了服务器更换、迁移带来的大量域名重新指向的问题。</p><p>另一方面，<code>CNAME</code>配合负载均衡系统，还可以实现将大量访问需求通过<code>CNAME</code>指向到多台服务器，以提高用户访问的速度。</p><p>作者：诺曼底的救赎<br>链接：<a href="https://www.jianshu.com/p/65757b5c0762" target="_blank" rel="noopener">https://www.jianshu.com/p/65757b5c0762</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于cname一直都知道名词，但是不知道具体作用，看到一篇比较好的文章，转载下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-001-两数之和</title>
    <link href="http://yoursite.com/2019/12/25/leetcode-array/leetcode-001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/12/25/leetcode-array/leetcode-001-两数之和/</id>
    <published>2019-12-25T13:14:28.347Z</published>
    <updated>2020-01-05T11:22:40.392Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。刷题网站为leetcode的中文版：<a href="%E5%8A%9B%E6%89%A3">https://leetcode-cn.com/problemset/all/</a>第一道题目是两数之和，对应leetcode的题号为1。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><blockquote><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><h2>解题思路</h2><p>第一次想到的思路是双层循环暴力找出两个条件的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                   res[<span class="number">0</span>] = i;</span><br><span class="line">                   res[<span class="number">1</span>] = j;</span><br><span class="line">                   <span class="keyword">return</span> res;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何提到执行效率呢？降低时间复杂度，此时可以接用java中的<code>HashMap</code>数据结构来辅助我们，因为我们知道，这个数据接口可以帮助我们很快地找到对应的元素，那么思路就是：将数据的值作为<code>key</code>，其索引值作为<code>value</code>，那么我们可以根据<code>key</code>来找另一个<code>key</code>，比如我遍历数组到第一个数字2，那么此时<code>map</code>里面存储的是<code>map&lt;2,0&gt;</code>，那么我下次就可以去寻找有没有<code>map&lt;7,x&gt;</code>这样的数据，有的话那就直接返回了，没有则继续去找，直到找不到为止。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(target-nums[i]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数组值为key，索引为value</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。刷题网站为leetcode的中文版：&lt;a href=&quot;%E5%8A%9B%E6%89%A3&quot;&gt;https://leetcode-cn.com/problemset/all/&lt;/a&gt;第一道题目是两数之和，对应leetcode的题号为1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>关于多CPU和多核CPU的区别</title>
    <link href="http://yoursite.com/2019/11/17/miscellany/20%E5%85%B3%E4%BA%8E%E5%A4%9ACPU%E5%92%8C%E5%A4%9A%E6%A0%B8CPU%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/17/miscellany/20关于多CPU和多核CPU的区别/</id>
    <published>2019-11-17T06:36:55.195Z</published>
    <updated>2019-11-17T06:37:05.467Z</updated>
    
    <content type="html"><![CDATA[<p>编写多线程程序的时候，可能没怎么注意一些硬件架构上的区别，从而无法达到机器的最大性能，造成资源的浪费。这里我们一起来探讨下多CPU和多核CPU的区别，帮助我们更好地理解计算机如何工作的。</p><a id="more"></a><h2>一、cpu架构和工作原理</h2><p>冯偌伊曼将计算机构成分为：运算器，控制器，存储器，输入设备和输出设备。现在计算机都是基于冯偌伊曼结构进行升级改造而已。运算器和控制器封装到一起，加上寄存器组和cpu内部总线构成中央处理器（CPU）。cpu的根本任务，就是执行指令，对计算机来说，都是0，1组成的序列，cpu从逻辑上可以划分为3个模块：控制单元、运算单元和存储单元。这三个部分由cpu总线连接起来。</p><p><img src="http://bloghello.oursnail.cn/tcp1-1.png" alt="image"></p><p>CPU的运行原理就是：控制单元在时序脉冲的作用下，将指令计数器里所指向的指令地址(这个地址是在内存里的)送到地址总线上去，然后CPU将这个地址里的指令读到指令寄存器进行译码。对于执行指令过程中所需要用到的数据，会将数据地址也送到地址总线，然后CPU把数据读到CPU的内部存储单元(就是内部寄存器)暂存起来，最后命令运算单元对数据进行处理加工。周而复始，一直这样执行下去。</p><h2>二、多核cpu和多cpu</h2><p>多个物理CPU，CPU通过总线进行通信，效率比较低：</p><p><img src="http://bloghello.oursnail.cn/tcp1-2.png" alt="image"></p><p>多核CPU，不同的核通过<code>L2 cache</code>进行通信，存储和外设通过总线与CPU通信：</p><p><img src="http://bloghello.oursnail.cn/tcp1-3.png" alt="image"></p><p>上面提到的<code>L2 cache</code>是啥呢？这就扯到了CPU缓存了。CPU缓存是位于CPU与内存之间的临时数据交换器，它的容量比内存小的多但是交换速度却比内存要快得多。CPU缓存一般直接跟CPU芯片集成或位于主板总线互连的独立芯片上。</p><p><img src="http://bloghello.oursnail.cn/tcp1-4.png" alt="image"></p><p>随着多核CPU的发展，CPU缓存通常分成了三个级别：<code>L1</code>，<code>L2</code>，<code>L3</code>。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。<code>L1</code> 是最接近CPU的, 它容量最小（例如：32K），速度最快，每个核上都有一个 <code>L1</code> 缓存，<code>L1</code> 缓存每个核上其实有两个 <code>L1</code> 缓存, 一个用于存数据的 <code>L1d Cache</code>（<code>Data Cache</code>），一个用于存指令的 <code>L1i Cache</code>（<code>Instruction Cache</code>）。<code>L2</code> 缓存 更大一些（例如：256K），速度要慢一些, 一般情况下每个核上都有一个独立的<code>L2</code> 缓存; <code>L3</code> 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 <code>L3</code> 缓存。</p><p>读取数据过程。就像数据库缓存一样，首先在最快的缓存中找数据，如果缓存没有命中(<code>Cache miss</code>) 则往下一级找, 直到三级缓存都找不到时，向内存要数据。一次次地未命中，代表取数据消耗的时间越长。</p><p>计算过程。程序以及数据被加载到主内存；指令和数据被加载到CPU的高速缓；CPU执行指令，把结果写到高速缓存；高速缓存中的数据写回主内存。</p><h2>三、进程和线程</h2><p>关于进程和线程说的比较多，下面简略列举：</p><ol><li>进程是资源分配的最小单位，一个程序有至少一个进程。线程是程序执行的最小单位。一个进程有至少一个线程。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li></ol><h2>四、进程和线程在多核cpu，多cpu中的运行关系</h2><p><strong>多cpu的运行，对应进程的运行状态；多核cpu的运行，对应线程的运行状态。</strong></p><p>操作系统会拆分CPU为一段段时间的运行片，轮流分配给不同的程序。对于多cpu，多个进程可以并行在多个cpu中计算，当然也会存在进程切换；对于单cpu，多个进程在这个单cpu中是并发运行，根据时间片读取上下文+执行程序+保存上下文。同一个进程同一时间段只能在一个cpu中运行，如果进程数小于cpu数，那么未使用的cpu将会空闲。</p><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。<br>对于多核cpu，进程中的多线程并行执行，执行过程中存在线程切换，线程切换开销较小。对于单核cpu，多线程在单cpu中并发执行，根据时间片切换线程。同一个线程同一时间段只能在一个cpu内核中运行，如果线程数小于cpu内核数，那么将有多余的内核空闲。</p><h2>五、总结</h2><ol><li>单CPU中进程只能是并发，多CPU计算机中进程可以并行。</li><li>单CPU单核中线程只能并发，单CPU多核中线程可以并行。</li><li>无论是并发还是并行，使用者来看，看到的是多进程，多线程。</li></ol><p>转载自：<a href="https://www.cnblogs.com/valjeanshaw/p/11469514.html" target="_blank" rel="noopener">进程，线程与多核，多cpu之间的关系</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写多线程程序的时候，可能没怎么注意一些硬件架构上的区别，从而无法达到机器的最大性能，造成资源的浪费。这里我们一起来探讨下多CPU和多核CPU的区别，帮助我们更好地理解计算机如何工作的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
</feed>
