<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>但行好事，莫问前程；前路有光，莫忘初心。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-04T16:33:41.160Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-009-杨辉三角2</title>
    <link href="http://yoursite.com/2020/01/05/leetcode-array/leetcode-009-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/"/>
    <id>http://yoursite.com/2020/01/05/leetcode-array/leetcode-009-杨辉三角2/</id>
    <published>2020-01-04T16:30:11.064Z</published>
    <updated>2020-01-04T16:33:41.160Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第九道题目是杨辉三角2，对应leetcode的题号为119。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你可以优化你的算法到 O(k) 空间复杂度吗？</p><h2>解题思路</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意本题的rowIndex是从0开始计算的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放最终结果的集合</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//每一行结果存放</span></span><br><span class="line">        List&lt;Integer&gt; rowList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将杨辉三角的结构以二维数组来描述，方便进行三角的构建</span></span><br><span class="line">        <span class="comment">//此时默认数组所有元素都是0</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[rowIndex+<span class="number">1</span>][rowIndex+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//开始构建每一行的数组的数据，并且最终放到list中返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">            rowList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//每一行的第一个元素都是1</span></span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            rowList.add(arr[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//开始从每一行的第二个元素计算，如何计算呢？其实就是依靠上一行元素进行计算的，公式为：</span></span><br><span class="line">            <span class="comment">//arr[i][j] = arr[i-1][j-1] + arr[i-1][j]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j-<span class="number">1</span>] + arr[i-<span class="number">1</span>][j];</span><br><span class="line">                rowList.add(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是第rowindex行了，则直接返回即可</span></span><br><span class="line">            <span class="keyword">if</span>(i == rowIndex)&#123;</span><br><span class="line">                <span class="keyword">return</span> rowList;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(rowList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了程序不会报错，返回集合的最后一个元素</span></span><br><span class="line">        <span class="keyword">return</span> res.get(res.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何达到O(K)的空间复杂度呢？其实没必要用一个数组来存储所有的元素，可以用一个list来存放上一行的数据，见下面代码：</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意本题的rowIndex是从0开始计算的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//curr用来存放当前行元素</span></span><br><span class="line">        List&lt;Integer&gt; curr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//pre用来存放上一行元素</span></span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">            curr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="comment">//根据规律，每一行第一个元素和第i个元素都是为1</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || j == i)&#123;</span><br><span class="line">                    curr.add(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    curr.add(pre.get(j-<span class="number">1</span>)+pre.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新pre指向curr，用于下一行循环，即保存了新的上一行数据用于下一行的计算，节省了空间复杂度</span></span><br><span class="line">            pre = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>结语</h2><p>杨辉三角作为一个经典题目，在大学学习编程的时候或许就遇到过这个问题，其实还有很多很多的优化方案，希望自己以后能够多扩展思路，不能为了做题而做题，因此，总有一天我会回来的，将这道题目优化到底。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第九道题目是杨辉三角2，对应leetcode的题号为119。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-008-杨辉三角</title>
    <link href="http://yoursite.com/2020/01/05/leetcode-array/leetcode-008-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>http://yoursite.com/2020/01/05/leetcode-array/leetcode-008-杨辉三角/</id>
    <published>2020-01-04T16:29:22.377Z</published>
    <updated>2020-01-04T16:30:31.101Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第八道题目是杨辉三角，对应leetcode的题号为118。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2>解题思路</h2><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1</span></span><br><span class="line"><span class="comment">*  1 1</span></span><br><span class="line"><span class="comment">*  1 2 1</span></span><br><span class="line"><span class="comment">*  1 3 3 1</span></span><br><span class="line"><span class="comment">*  1 4 6 4 1</span></span><br><span class="line"><span class="comment">*  1 5 10 10 5 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="comment">//存放最终结果的集合</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//每一行结果存放</span></span><br><span class="line">        List&lt;Integer&gt; rowList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将杨辉三角的结构以二维数组来描述，方便进行三角的构建</span></span><br><span class="line">        <span class="comment">//此时默认数组所有元素都是0</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[numRows][numRows];</span><br><span class="line">        <span class="comment">//开始构建每一行的数组的数据，并且最终放到list中返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            rowList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//每一行的第一个元素都是1</span></span><br><span class="line">            arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            rowList.add(arr[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//开始从每一行的第二个元素计算，如何计算呢？其实就是依靠上一行元素进行计算的，公式为：</span></span><br><span class="line">            <span class="comment">//arr[i][j] = arr[i-1][j-1] + arr[i-1][j]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                arr[i][j] = arr[i-<span class="number">1</span>][j-<span class="number">1</span>] + arr[i-<span class="number">1</span>][j];</span><br><span class="line">                rowList.add(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这每一行的数据已经处理完毕，添加到最终的集合中即可</span></span><br><span class="line">            res.add(rowList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第八道题目是杨辉三角，对应leetcode的题号为118。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-007-合并两个有序数组</title>
    <link href="http://yoursite.com/2020/01/03/leetcode-array/leetcode-007-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/03/leetcode-array/leetcode-007-合并两个有序数组/</id>
    <published>2020-01-03T15:19:15.896Z</published>
    <updated>2020-01-03T15:22:04.404Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第七道题目是合并两个有序数组，对应leetcode的题号为88。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>这道题目，其实就是归并排序的思想，简单说明就是：两个指针，分别指向两个有序数组的最后一位，两两比较，把大的一个拎出来，并且大的那个指针往前移动一格继续比较。比较到最后，必然有一个先到头，另一个没到头的指针，前面所有元素就是两个数组中最小的有序部分，直接挪到排序后数组的最前面就可以了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>,j = n-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//归并排序的思想，从后往前慢慢比较、填充</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                nums1[index--] = nums1[i--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[index--] = nums2[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//剩下的元素，要么nums1还没比完要么nums2还没比完，直接将剩下没比完的数据复制到nums1的前面即可</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[index--] = nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[index--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第七道题目是合并两个有序数组，对应leetcode的题号为88。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-006-加一</title>
    <link href="http://yoursite.com/2020/01/03/leetcode-array/leetcode-006-%E5%8A%A0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/01/03/leetcode-array/leetcode-006-加一/</id>
    <published>2020-01-03T14:46:16.988Z</published>
    <updated>2020-01-03T14:46:30.468Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第六道题目是加一，对应leetcode的题号为66。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>一开始琢磨半天，没看懂是啥玩意。不过如果再写一个示例就明确了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,9,9]</span><br><span class="line">输出: [2,0,0]</span><br><span class="line">解释: 输入数组表示数字 200。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,9,9]</span><br><span class="line">输出: [1,0,0,0]</span><br><span class="line">解释: 输入数组表示数字 1000。</span><br></pre></td></tr></table></figure><p>其实就是说，一个数组表示的非负整数去加一后的结果再去以一个数组来表示。由于是非负整数，那么如果第一位就是0的话，那必定就是0了，这题的难点就在于可能某个数在加一之后会增加一位，比如999是三位数，加一后就变成四位数了。那么原来长度为3的数组就不能容纳下这个长度为4的数据了。</p><p>这一道题目的思路比较巧妙，我们从最后一个数字来判断是否为9，如果不是，那么直接最后一位加一即可结束，如果最后一位是9，那么就需要改为0，然后继续判断倒数第二位，同理，倒数第二位如果不是9则加一结束，否则置为0继续往前判断。</p><p>如果在for循环中一直没出来，那么就说明提供的数字全是9，此时就需要新建一个数组了，长度为原数组加一，然后第一位置为1即可，因为其他位默认为0。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="comment">//1、非空判断</span></span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="keyword">null</span> || digits.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">9</span>)&#123;</span><br><span class="line">                <span class="comment">//2、此时只需要加一就是我们需要的最终结果，直接return</span></span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//3、走到这里说明此时第i个元素是9，那么按照进位加一则为0，进行下一轮的判断</span></span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、如果走到这里，说明digits里面所有元素都是9，则新建数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第六道题目是加一，对应leetcode的题号为66。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-005-最大子序和</title>
    <link href="http://yoursite.com/2020/01/02/leetcode-array/leetcode-005-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://yoursite.com/2020/01/02/leetcode-array/leetcode-005-最大子序和/</id>
    <published>2020-01-02T14:47:00.980Z</published>
    <updated>2020-01-02T14:48:05.748Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第五道题目是移除元素，对应leetcode的题号为53。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>这道题目可以利用贪心算法的思想来解决，时间复杂度为O(n)，所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。</p><p>那么我们可以从头开始往后试，定义一个值叫sum，这个sum专门来计算连续子数组的和，因为贪心嘛，追求的是最好每次sum都在逐渐增加，但是呢，实际上我又不能每次都管增加的，有的时候会适当下降是为了下一个元素的猛增。因此其实也不贪心，标准设置为0，只要sum不小于0我就一直往后加，一旦小于0，那么此时sum包含的子数组串已经失去意义了，就从新的位置重新计算sum。在这过程中，一直与最大值做比较，从而在局部的最优解中逐渐获取到全局最优解。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//收益是正的，则加上当前值再去试试</span></span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果sum加上当前的值都小于0了，干脆sum就改为当前值再继续往后试</span></span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//res记录的就是最大的和</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt; res)&#123;</span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题其实是动态规划的典型题目（上面个代码是用贪心角度来说的，其实吧，跟下面的动态规划也没啥大区别，不过姑且分开吧，因为动态规划是有其强烈的自身标识的，即可以用一个表达式来表达出求解规律）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] 定义为数组nums 中已num[i] 结尾的最大连续子串和， 则有：</span><br><span class="line">dp[i] = max(dp[i-1] + nums[i], num[i]);</span><br></pre></td></tr></table></figure><p>其实就是说，【前面比较的结果+当前值】与【当前值】做比较，谁大就取谁。其实跟上面所谓的贪心思路是不是差不多？实际上，这种看起来思路是清晰一点的，掌握了动态规划还是可以写出来的，不过上面的贪心是需要一定的功力才能写出来（我觉得）。</p><p>用一个临时数组来存放遍历过程中的最大值，最后取这个临时数组最大值即可，时间复杂度O(n)，空间复杂度O(n)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//给dp数组的第一个元素也赋予上值，dp后续的元素就是存放的当前遍历到的最大值</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//动态规划的核心思想：要么取当前值，要么就取以前的最优结果+当前值</span></span><br><span class="line">            <span class="comment">//其实就是看前面算出来的最大值跟当前值结合是否能增大收益</span></span><br><span class="line">            dp[i] = Math.max(dp[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; max)&#123;</span><br><span class="line">                max = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不需要数组，因为我们可以发现，我们每次只关心dp数组的最后一个有效值，因此我们想办法用一个变量把最后一个有效值保存下来即可。见最终提交代码：</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放最大和</span></span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//用temp来代替数组，减少空间复杂度</span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//a存放的就是之前的dp[i-1]+nums[i]</span></span><br><span class="line">            <span class="keyword">int</span> a = temp + nums[i];</span><br><span class="line">            <span class="comment">//b存放的就是nums[i]</span></span><br><span class="line">            <span class="keyword">int</span> b = nums[i];</span><br><span class="line">            <span class="comment">//maxTemp记录此次比较的最大值</span></span><br><span class="line">            <span class="keyword">int</span> maxTemp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//刷新temp的值，如果a大，那么temp刷新为dp[i-1]+nums[i]</span></span><br><span class="line">            <span class="comment">//如果b大，那么temp刷新为nums[i]，temp就相当于dp[i]里面的值，只是我们不关心i之前的值了，所以只要存下dp[i]的值就够了</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">                maxTemp = a;</span><br><span class="line">                temp = a;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxTemp = b;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//刷新max的值，使得max每次都保存最大值</span></span><br><span class="line">            <span class="keyword">if</span>(maxTemp &gt; max)&#123;</span><br><span class="line">                max = maxTemp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第五道题目是移除元素，对应leetcode的题号为53。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-004-搜索插入位置</title>
    <link href="http://yoursite.com/2020/01/01/leetcode-array/leetcode-004-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/01/01/leetcode-array/leetcode-004-搜索插入位置/</id>
    <published>2020-01-01T12:42:42.816Z</published>
    <updated>2020-01-01T12:43:04.388Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第四道题目是移除元素，对应leetcode的题号为35。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>其实最简单的方式是直接遍历有序数组，因为这个题目并没有要求要把target插入到数组指定位置，只需要返回需要插入的索引即可，那我们直接一个一个往后寻找即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//当遇到跟目标值相等则返回其索引</span></span><br><span class="line">            <span class="comment">//当没有相等的，那么返回的索引即第一个比目标值大的位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这一步，要么返回0，要么说明target被插入到数据最后一个位置了</span></span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过当数据量很大的时候，比如这个有序数组有几十万数据，那么从头遍历的效率会比较低，那么就需要有一定的跳跃来减少不必要的查询，那么由于是有序数组，第一个想到的必然就是二分查找法，直接能把搜索的返回缩小为原来的一半，有效提高效率。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length-<span class="number">1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找着？那么返回left即可，因为走到这一步的上一步的时候，left和right相等，此时target是介于left-1和left的值的中间的，那么target插入到left位置即可</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第四道题目是移除元素，对应leetcode的题号为35。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-003-移除元素</title>
    <link href="http://yoursite.com/2019/12/31/leetcode-array/leetcode-003-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/12/31/leetcode-array/leetcode-003-移除元素/</id>
    <published>2019-12-31T14:32:04.623Z</published>
    <updated>2019-12-31T14:33:44.130Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第三道题目是移除元素，对应leetcode的题号为27。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:</p><blockquote><p>给定 nums = [3,2,2,3], val = 3,</p><p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例 2:</p><blockquote><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p><p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>注意这五个元素可为任意顺序。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h2>解题思路</h2><p>有了上一题的经验，这一题比较简单，其实还是两个指针，第一个指针指向的位置前面所有元素应该都不与val相等（不包含i所指向的位置）；第二个指针负责遍历，一旦遍历到与val不相等的，就往i位置插入即可，然后i后移一格，等待插入下一个不等于val的值。最终返回的就是i的值。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != val)&#123;</span><br><span class="line">                nums[i++] = nums[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以下写法等同于上面写法</span></span><br><span class="line">        <span class="comment">// int i=0;</span></span><br><span class="line">        <span class="comment">// for(int j=0;j&lt;nums.length;j++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[j] != val)&#123;</span></span><br><span class="line">        <span class="comment">//         nums[i++] = nums[j];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第三道题目是移除元素，对应leetcode的题号为27。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-002-删除排序数组中的重复项</title>
    <link href="http://yoursite.com/2019/12/30/leetcode-array/leetcode-002-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/12/30/leetcode-array/leetcode-002-删除排序数组中的重复项/</id>
    <published>2019-12-30T14:37:04.329Z</published>
    <updated>2019-12-31T14:33:17.158Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二道题目是删除排序数组中的重复项，对应leetcode的题号为26。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><ul><li>示例 1:</li></ul><blockquote><p>给定数组 nums = [1,1,2],</p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><ul><li>示例 2:</li></ul><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>说明:</p></blockquote><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">or (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">   print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>根据题目要求，只能原地进行排除，并且还是一个排序的数组，那么肯定需要两个指针来实现，一个指针负责掌管前面已经不重复的元素索引，后者负责遍历所有元素，只要有不重复的，那么就将j所在的元素赋予给i后面一个位置的元素，然后i和j分别后移一位即可。那么到最后，i指向的元素以及前面所有元素都是不重复的。最终j遍历到数据结束为止。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分析数组为空或者只有一个元素的情况，返回数组长度即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">0</span> || nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针，i指向的元素，前面都是确定不重复的，最后返回长度的时候即（i+1）就是i所有不重复元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length)&#123;</span><br><span class="line">            <span class="comment">//不相等的时候，则将j的元素赋予给i+1后面一个元素，并且各自后移一位</span></span><br><span class="line">            <span class="comment">//比如[1,2]，此时将j=1的值赋给i=1的值即可，最后数组还是[1,2]</span></span><br><span class="line">            <span class="comment">//比如[1,1,2]，第一步是进入else即j=2，下一步j=2赋予给i=1，那么数组最终为[1,2,2]，返回i+1即2即可。</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[j])&#123;</span><br><span class="line">                <span class="comment">//这一行是本题精华，j指向的元素挪到i后面一个元素，i和j分别加一</span></span><br><span class="line">                nums[++i] = nums[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//相等，那么j后移一位即可</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二道题目是删除排序数组中的重复项，对应leetcode的题号为26。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>关于CNAME</title>
    <link href="http://yoursite.com/2019/12/28/miscellany/21%E5%85%B3%E4%BA%8ECNAME/"/>
    <id>http://yoursite.com/2019/12/28/miscellany/21关于CNAME/</id>
    <published>2019-12-28T14:43:28.093Z</published>
    <updated>2019-12-28T14:56:40.207Z</updated>
    
    <content type="html"><![CDATA[<p>关于cname一直都知道名词，但是不知道具体作用，看到一篇比较好的文章，转载下来。</p><a id="more"></a><p>当你上网时，在地址栏输入：<code>www.baidu.com</code> 的时候，你知道弹出的那个百度首页是从哪里来的吗？</p><p>对，是从网站服务器调取过来的，这个过程是通过域名解析获得IP地址后，然后向网站服务器发送请求，网站服务器做出响应，最后再将这个网页发送到你的浏览器。</p><p>再详细一点的描述是，每个域名（<code>www.baidu.com</code>）背后实际上是有个地址，这个地址代表的是网站服务器的地址。在互联网上，域名的存在只是便于记忆，它背后真实的识别方式是IP地址。</p><p>当我们在浏览器上输入域名后，我们的电脑会通过一个叫<code>DNS</code>的系统去解析这个域名，并获得IP地址。</p><div class="tip">DNS（Domain Name System[域名系统])，万维网上作为域名和IP地址相互映射的一个[分布式数据库]能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</div><p>这个过程中还会涉及到域名指向的设置，我们知道域名是有顶级域名（<code>baidu.com</code>)，二级域名（<code>www.baidu.com</code>)之分的，当多个域名都指向一个网站服务器上时，需要将这些子域名（顶级域名下面的二级域名、三级域名都称之为子域名）设置并指向自己的网站服务器上的，这个动作一般称之为A记录，又称IP指向。</p><div class="tip">A (Address) 记录是用来指定域名对应的IP地址记录。</div><p>说到这里实际上就会产生一个问题，就是当服务器需要更换时，这些原本指向这台服务器的域名就需要重新设置，并指向新的服务器，这样就会产生比较大的工作量。</p><p>说到这我们就要来说下<code>CNAME</code>。</p><div class="tip">CNAME：即别名记录。这种记录允许您将多个名字映射到另外一个域名。</div><p>简单来说，A记录就是把一个域名解析到一个IP地址，而<code>CNAME</code>记录就是把域名解析到另外一个域名。</p><p>比如<code>www.baidu.com</code>，这个二级域名解析到的是一个服务器的IP地址，比如<code>8.8.8.8</code>，而<code>CNAME</code>是将新域名，比如：<code>a.www.baidu.com</code>解析到另外一个域名，比如：<code>www.baidu.com</code>。</p><p>当新域名产生后都指向<code>CNAME</code>域名后，在发生服务器需要更换或者迁移时，就只需要把<code>www.baidu.com</code>这个域名做重新设置就可以了，这样就减少了很多工作量。</p><p><code>CNAME</code>在<code>CDN</code>中的应用<br><code>CNAME</code>的应用还远不止于此，在<code>CDN</code>（内容分发网络）上也是不可缺少的一环。</p><p><code>CDN</code>的主要功能是将原本离用户比较远的源站服务器，通过丰富的节点（缓存服务器）放到离用户最近的地方，实现用户对互联网上资源的快速访问。</p><p>这个快速访问的过程就需要<code>CNAME</code>的参与。</p><p>原理是这样的：</p><p>用户向浏览器提供要访问的域名，浏览器对域名进行解析，由于 <code>CDN</code> 参与后，对域名解析过程进行了调整，解析的结果不再是一个IP地址，而是该域名对应的 <code>CNAME</code> 。</p><p>但 <code>CNAME</code> 无法完成最终内容的获取，所以，浏览器需要再次对获得的 <code>CNAME</code> 进行解析，以得到实际的 IP 地址。在此过程中，<code>CDN</code>会根据用户的实际地理位置信息解析对应的 IP 地址，使得用户能就近访问。</p><p>这个过程中， <code>CNAME</code>的主要作用是配合<code>CDN</code>的负载均衡系统将<code>CNAME</code>背后对应的节点IP分配给不同的用户去访问。</p><p>总的来讲， <code>CNAME</code>提供了单一服务器和海量服务器的在管理<br>访问上的灵活性。单一服务器的场景下，通过将大量子域名指向到<code>CNAME</code>，再由 <code>CNAME</code> 指向到单一域名，解决了服务器更换、迁移带来的大量域名重新指向的问题。</p><p>另一方面，<code>CNAME</code>配合负载均衡系统，还可以实现将大量访问需求通过<code>CNAME</code>指向到多台服务器，以提高用户访问的速度。</p><p>作者：诺曼底的救赎<br>链接：<a href="https://www.jianshu.com/p/65757b5c0762" target="_blank" rel="noopener">https://www.jianshu.com/p/65757b5c0762</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于cname一直都知道名词，但是不知道具体作用，看到一篇比较好的文章，转载下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-001-两数之和</title>
    <link href="http://yoursite.com/2019/12/25/leetcode-array/leetcode-001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/12/25/leetcode-array/leetcode-001-两数之和/</id>
    <published>2019-12-25T13:14:28.347Z</published>
    <updated>2019-12-31T14:32:59.993Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第一道题目是两数之和，对应leetcode的题号为1。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><blockquote><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><h2>解题思路</h2><p>第一次想到的思路是双层循环暴力找出两个条件的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                   res[<span class="number">0</span>] = i;</span><br><span class="line">                   res[<span class="number">1</span>] = j;</span><br><span class="line">                   <span class="keyword">return</span> res;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何提到执行效率呢？降低时间复杂度，此时可以接用java中的<code>HashMap</code>数据结构来辅助我们，因为我们知道，这个数据接口可以帮助我们很快地找到对应的元素，那么思路就是：将数据的值作为<code>key</code>，其索引值作为<code>value</code>，那么我们可以根据<code>key</code>来找另一个<code>key</code>，比如我遍历数组到第一个数字2，那么此时<code>map</code>里面存储的是<code>map&lt;2,0&gt;</code>，那么我下次就可以去寻找有没有<code>map&lt;7,x&gt;</code>这样的数据，有的话那就直接返回了，没有则继续去找，直到找不到为止。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(target-nums[i]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数组值为key，索引为value</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第一道题目是两数之和，对应leetcode的题号为1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>关于多CPU和多核CPU的区别</title>
    <link href="http://yoursite.com/2019/11/17/miscellany/20%E5%85%B3%E4%BA%8E%E5%A4%9ACPU%E5%92%8C%E5%A4%9A%E6%A0%B8CPU%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/17/miscellany/20关于多CPU和多核CPU的区别/</id>
    <published>2019-11-17T06:36:55.195Z</published>
    <updated>2019-11-17T06:37:05.467Z</updated>
    
    <content type="html"><![CDATA[<p>编写多线程程序的时候，可能没怎么注意一些硬件架构上的区别，从而无法达到机器的最大性能，造成资源的浪费。这里我们一起来探讨下多CPU和多核CPU的区别，帮助我们更好地理解计算机如何工作的。</p><a id="more"></a><h2>一、cpu架构和工作原理</h2><p>冯偌伊曼将计算机构成分为：运算器，控制器，存储器，输入设备和输出设备。现在计算机都是基于冯偌伊曼结构进行升级改造而已。运算器和控制器封装到一起，加上寄存器组和cpu内部总线构成中央处理器（CPU）。cpu的根本任务，就是执行指令，对计算机来说，都是0，1组成的序列，cpu从逻辑上可以划分为3个模块：控制单元、运算单元和存储单元。这三个部分由cpu总线连接起来。</p><p><img src="http://bloghello.oursnail.cn/tcp1-1.png" alt="image"></p><p>CPU的运行原理就是：控制单元在时序脉冲的作用下，将指令计数器里所指向的指令地址(这个地址是在内存里的)送到地址总线上去，然后CPU将这个地址里的指令读到指令寄存器进行译码。对于执行指令过程中所需要用到的数据，会将数据地址也送到地址总线，然后CPU把数据读到CPU的内部存储单元(就是内部寄存器)暂存起来，最后命令运算单元对数据进行处理加工。周而复始，一直这样执行下去。</p><h2>二、多核cpu和多cpu</h2><p>多个物理CPU，CPU通过总线进行通信，效率比较低：</p><p><img src="http://bloghello.oursnail.cn/tcp1-2.png" alt="image"></p><p>多核CPU，不同的核通过<code>L2 cache</code>进行通信，存储和外设通过总线与CPU通信：</p><p><img src="http://bloghello.oursnail.cn/tcp1-3.png" alt="image"></p><p>上面提到的<code>L2 cache</code>是啥呢？这就扯到了CPU缓存了。CPU缓存是位于CPU与内存之间的临时数据交换器，它的容量比内存小的多但是交换速度却比内存要快得多。CPU缓存一般直接跟CPU芯片集成或位于主板总线互连的独立芯片上。</p><p><img src="http://bloghello.oursnail.cn/tcp1-4.png" alt="image"></p><p>随着多核CPU的发展，CPU缓存通常分成了三个级别：<code>L1</code>，<code>L2</code>，<code>L3</code>。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。<code>L1</code> 是最接近CPU的, 它容量最小（例如：32K），速度最快，每个核上都有一个 <code>L1</code> 缓存，<code>L1</code> 缓存每个核上其实有两个 <code>L1</code> 缓存, 一个用于存数据的 <code>L1d Cache</code>（<code>Data Cache</code>），一个用于存指令的 <code>L1i Cache</code>（<code>Instruction Cache</code>）。<code>L2</code> 缓存 更大一些（例如：256K），速度要慢一些, 一般情况下每个核上都有一个独立的<code>L2</code> 缓存; <code>L3</code> 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 <code>L3</code> 缓存。</p><p>读取数据过程。就像数据库缓存一样，首先在最快的缓存中找数据，如果缓存没有命中(<code>Cache miss</code>) 则往下一级找, 直到三级缓存都找不到时，向内存要数据。一次次地未命中，代表取数据消耗的时间越长。</p><p>计算过程。程序以及数据被加载到主内存；指令和数据被加载到CPU的高速缓；CPU执行指令，把结果写到高速缓存；高速缓存中的数据写回主内存。</p><h2>三、进程和线程</h2><p>关于进程和线程说的比较多，下面简略列举：</p><ol><li>进程是资源分配的最小单位，一个程序有至少一个进程。线程是程序执行的最小单位。一个进程有至少一个线程。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li></ol><h2>四、进程和线程在多核cpu，多cpu中的运行关系</h2><p><strong>多cpu的运行，对应进程的运行状态；多核cpu的运行，对应线程的运行状态。</strong></p><p>操作系统会拆分CPU为一段段时间的运行片，轮流分配给不同的程序。对于多cpu，多个进程可以并行在多个cpu中计算，当然也会存在进程切换；对于单cpu，多个进程在这个单cpu中是并发运行，根据时间片读取上下文+执行程序+保存上下文。同一个进程同一时间段只能在一个cpu中运行，如果进程数小于cpu数，那么未使用的cpu将会空闲。</p><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。<br>对于多核cpu，进程中的多线程并行执行，执行过程中存在线程切换，线程切换开销较小。对于单核cpu，多线程在单cpu中并发执行，根据时间片切换线程。同一个线程同一时间段只能在一个cpu内核中运行，如果线程数小于cpu内核数，那么将有多余的内核空闲。</p><h2>五、总结</h2><ol><li>单CPU中进程只能是并发，多CPU计算机中进程可以并行。</li><li>单CPU单核中线程只能并发，单CPU多核中线程可以并行。</li><li>无论是并发还是并行，使用者来看，看到的是多进程，多线程。</li></ol><p>转载自：<a href="https://www.cnblogs.com/valjeanshaw/p/11469514.html" target="_blank" rel="noopener">进程，线程与多核，多cpu之间的关系</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写多线程程序的时候，可能没怎么注意一些硬件架构上的区别，从而无法达到机器的最大性能，造成资源的浪费。这里我们一起来探讨下多CPU和多核CPU的区别，帮助我们更好地理解计算机如何工作的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>07kafka消费者-下</title>
    <link href="http://yoursite.com/2019/10/04/kafka/07kafka%E6%B6%88%E8%B4%B9%E8%80%85-%E4%B8%8B/"/>
    <id>http://yoursite.com/2019/10/04/kafka/07kafka消费者-下/</id>
    <published>2019-10-04T03:16:52.986Z</published>
    <updated>2019-10-04T03:17:21.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bloghello.oursnail.cn/kafka1-15.jpg" alt="image"></p><p>之前学习了如何进行消费位移的提交，正是有了消费位移的持久化，才能使消费者在关闭、崩溃或者遇到再均衡的时候，可以让接替的消费者根据存储的消费位移继续继续进行消费。</p><a id="more"></a><h2>一、指定位移消费</h2><p>当一个新的消费组建立的时候，它根本没有可以查找的消费位移；或者消费组内的一个新消费者订阅了一个新的主题，此时没有可以查找的消费位移；当<code>_consumer_offsets</code>主题中有关这个消费组的位移信息过期而被删除后，他也没有可以查找的消费位移。</p><p>在kafka中，每当消费者找不到所记录的消费位移时，就会根据消费者客户端参数<code>auto.offset.reset</code>的配置来决定从何处开始消费，默认值为<code>latest</code>，表示从分区末尾开始消费消息。如果配置成<code>earliest</code>，那么消费者就会从起始处开始消费。如果配置为<code>none</code>，表示当出现查不到消费位移的时候，既不从最新的消息位置处开始消费，也不从最早的消息位置处开始消费，此时会报出<code>NoOffsetForPartitionException</code>异常。</p><p>如果能够找到消费位移，那么配置成<code>none</code>也不会出现任何异常。如果配置的不是<code>latest</code>或者<code>earliest</code>或者<code>node</code>，就会报出<code>ConfigException</code>异常。</p><p>到目前为止，我们知道消息的拉取时根据<code>poll</code>方法的逻辑来处理的，对于我们来说是一个黑盒，无法精确控制其消费的起始位置。提供的<code>auto.offset.reset</code>参数也只能在找不到位移或者位移越界的情况下粗粒度地从开头或者末尾开始消费。有的时候我们需要一种更细粒度的掌控，可以让我们从特定的位移处开始拉取消息。下面<code>seek</code>方法隆重登场，让我们得以追前消费或回溯消费。</p><p>具体定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(TopicPartition partition,<span class="keyword">long</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p><code>partition</code>表示分区，<code>offset</code>参数用来指定从分区的哪个位置开始消费。下面为一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">consumer.poll(Duration.ofMillis(<span class="number">2000</span>));<span class="comment">// ①</span></span><br><span class="line">Set&lt;TopicPartition&gt; assignment = consumer.assignment();<span class="comment">// ②</span></span><br><span class="line">System.out.println(assignment);</span><br><span class="line"><span class="keyword">for</span> (TopicPartition tp : assignment) &#123;</span><br><span class="line">    consumer.seek(tp, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//        consumer.seek(new TopicPartition(topic,0),10);</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="comment">//consume the record.</span></span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.offset() + <span class="string">":"</span> + record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭐⭐<strong>如果将第①行改为<code>consumer.poll(Duration.ofMillis(0));</code>，会发现<code>seek()</code>方法并未有任何作用，因为当<code>poll</code>方法的参数为0时，此方法会立刻返回，那么<code>poll</code>方法内部进行分区分配的逻辑就会来不及实施。也就是说，消费者此时并未分配到任何分区，就会导致②中<code>assignment</code>是个空列表，后续的代码不会执行。</strong></p><p>那么这里分配的<code>timeout</code>参数设置未多少合适呢？太短则使分配分区的动作失败，太长又有可能造成一些不必要的等待。一个好的解决方法就是判断到分区分配成功为止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">consumer.poll(Duration.ofMillis(<span class="number">2000</span>));<span class="comment">// ①</span></span><br><span class="line">Set&lt;TopicPartition&gt; assignment = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// 如果不为0，说明已经成功分配到了分区</span></span><br><span class="line"><span class="keyword">while</span>(assignment.size == <span class="number">0</span>)&#123;</span><br><span class="line">    consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">    assignment = consumer.assignment();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(assignment);</span><br><span class="line"><span class="keyword">for</span> (TopicPartition tp : assignment) &#123;</span><br><span class="line">    consumer.seek(tp, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//        consumer.seek(new TopicPartition(topic,0),10);</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="comment">//consume the record.</span></span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.offset() + <span class="string">":"</span> + record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未分配到分区执行<code>seek()</code>方法，就会报出<code>IllegalStateException</code>异常。如果消费组内的消费者在启动的时候能够找到消费位移，除非发生位移越界，否则<code>auto.offset.reset</code>参数并不会奏效，此时如果想指定从开头或者末尾开始消费，就需要<code>seek()</code>方法的帮助了。下面使从分区末尾开始消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">Set&lt;TopicPartition&gt; assignment = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (assignment.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">    assignment = consumer.assignment();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// endOffsets()就是获取指定分区的末尾的消息位置</span></span><br><span class="line">Map&lt;TopicPartition, Long&gt; offsets = consumer.endOffsets(assignment);</span><br><span class="line"><span class="keyword">for</span> (TopicPartition tp : assignment) &#123;</span><br><span class="line">    consumer.seek(tp, offsets.get(tp) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(assignment);</span><br><span class="line">System.out.println(offsets);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="comment">//consume the record.</span></span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(record.offset() + <span class="string">":"</span> + record.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>endOffsets()</code>对应的就是<code>beginningOffsets()</code>方法。起始<code>KafkaConsumer</code>中直接提供了<code>seekToBeginning()</code>方法和<code>seekToEnd()</code>方法来实现这两个功能。这两个方法的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seekToBeginning</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seekToEnd</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span>;</span><br></pre></td></tr></table></figure><p>当然了，消费位移可以存储在任何介质，比如数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"><span class="comment">//省略poll()方法以及assignment的逻辑</span></span><br><span class="line"><span class="keyword">for</span>(TopicPartition tp: assignment)&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = getOffsetFromDB(tp);<span class="comment">//从DB中读取消费位移</span></span><br><span class="line">    consumer.seek(tp, offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords =</span><br><span class="line">                records.records(partition);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords) &#123;</span><br><span class="line">            <span class="comment">//process the record.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> lastConsumedOffset = partitionRecords</span><br><span class="line">                .get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">         <span class="comment">//将消费位移存储在DB中</span></span><br><span class="line">        storeOffsetToDB(partition, lastConsumedOffset+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>seek()</code>方法为我们提供了从特定位置读取消息的能力，我们可以通过这个方法来向前跳过若干消息，也可以通过这个方法来向后回溯瑞干消息，这样为消息的消费提供了很大的灵活性。<code>seek()</code>方法也为我们提供了将消费位移保存在外部存储介质的能力，还可以通过再均衡监听器来提供更加精准的消费能力。</p><h2>二、再均衡</h2><p>再均衡是指：分区的所属权从一个消费者转移到另一个消费者的行为，它为消费组具备高可用性和伸缩性提供保障，使我们可以既方便又安全地删除消费组内的消费者或者添加消费者。</p><p>不过在再均衡发生期间，消费组内的消费者是无法读取消息的，也就是说，在再均衡发生期间的这一小段时间内，消费组会变得不可用。</p><p>另外，当一个分区被重新分配给另一个消费者时，消费者当前的状态也会丢失。比如消费者消费完某个分区中的一部分消息时还没有来得及提交消费位移就发生了再均衡操作，之后这个分区又被分配到了消费组内的另一个消费者，原来被消费完的那部分消息又被重新消费一遍，也就是发生了重复消费。</p><p>所以，一般情况下，应尽量避免不必要的再均衡的发生。</p><p>在之前说明<code>subscribe()</code>方法时提及再均衡监听器<code>ConsumerRebalanceListener</code>，再均衡监听器用来设定再均衡动作前后的一些准备工作或收尾动作。它是一个接口，有两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span></span><br></pre></td></tr></table></figure><p>这个方法会在再均衡开始之前和消费者停止读取消息之后被调用。可以通过这个回调方法来处理消费位移的提交，以此来避免一些不必要的重复消费现象的发生。<code>partitions</code>表示再均衡前所分配到的分区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span></span><br></pre></td></tr></table></figure><p>这个方法会在重新分配分区之后和消费者开始读取消费之前被调用。<code>partitions</code>表示再均衡后所分配到的分区。</p><h2>三、消费者拦截器</h2><p>生产者有拦截器，消费者也有拦截器，主要在消费到消息或在提交位移时进行一些定制化的操作。</p><p>消费者拦截器需要自定义实现<code>org.apache.kafka.clients.consumer.ConsumerInterceptor</code>接口。包含3个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic ConsumerRecords&lt;String, String&gt; <span class="title">onConsume</span><span class="params">(ConsumerRecords&lt;String, String&gt; records)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><code>KafkaConsumer</code>会在<code>poll()</code>方法返回之前调用拦截器的<code>onConsume</code>方法来对消息进行相应的定制化操作，比如修改返回的消息内容、按照某种规则过滤消息。这个方法如果发生异常，那么会被捕获并记录到日志里，但是异常不会向上传递。</p><p><code>KafkaConsumer</code>会在提交消费位移之后调用拦截器的<code>onCommit</code>方法，可以使用这个方法来记录跟踪所提交的位移消息。</p><p>在某些业务场景中会对消息设置一个有效期的属性，如果某条消息在既定的时间窗口内无法到达，则被视为无效，它也就不需要再被继续处理了。下面为一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerInterceptorTTL</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">ConsumerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_INTERVAL = <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerRecords&lt;String, String&gt; <span class="title">onConsume</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ConsumerRecords&lt;String, String&gt; records)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before:"</span> + records);</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;String, String&gt;&gt;&gt; newRecords</span><br><span class="line">                = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TopicPartition tp : records.partitions()) &#123;</span><br><span class="line">            <span class="comment">//根据分区分类消息</span></span><br><span class="line">            List&lt;ConsumerRecord&lt;String, String&gt;&gt; tpRecords = records.records(tp);</span><br><span class="line">            <span class="comment">//存放未过期的消息</span></span><br><span class="line">            List&lt;ConsumerRecord&lt;String, String&gt;&gt; newTpRecords = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//判断是否过期</span></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : tpRecords) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now - record.timestamp() &lt; EXPIRE_INTERVAL) &#123;</span><br><span class="line">                    newTpRecords.add(record);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!newTpRecords.isEmpty()) &#123;</span><br><span class="line">                newRecords.put(tp, newTpRecords);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConsumerRecords&lt;&gt;(newRecords);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span> </span>&#123;</span><br><span class="line">        offsets.forEach((tp, offset) -&gt;</span><br><span class="line">                System.out.println(tp + <span class="string">":"</span> + offset.offset()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在消费者中也有拦截链的概念，和生产者的拦截链一样，也是按照<code>interceptor.classes</code>参数配置的拦截器的顺序来一一执行的（配置的时候，各个拦截器之间用逗号隔开）。同样也要提防副作用的发生。如果在拦截器中某个拦截器执行失败，那么下一个拦截器会接着从上一个执行成功的拦截器继续执行。</p><h2>四、多线程实现</h2><p><code>KafkaProducer</code>是线程安全的，<code>KafkaConsumer</code>是非线程安全的。<code>KafkaConsumer</code>中定义了一个<code>acquire()</code>方法，用来检测当前是否只有一个线程在操作，若有其他线程正在操作会抛出<code>ConcurrentModificationException</code>异常。<code>KafkaConsumer</code>的每个公用方法在执行之前都会调用<code>acquire</code>方法，至于<code>wakeup</code>是个例外。</p><p><code>acquire</code>跟我们通常说的锁（<code>synchronized</code>或<code>lock</code>等）不同，它不会造成阻塞等待，我们可以将其看作一个轻量级锁，它仅通过线程操作计数标记的方式来检测线程是否发生了并发操作，以此保证只有一个线程在操作。</p><p><code>KafkaConsumer</code>非线程安全并非意味着我们在消费消息的时候只能以单线程的方式执行，我们可以通过多线程的方式来实现消息消费，多线程的目的是为了提高整体的消费能力。多线程的实现方式有多种，第一种也是最常见的方式：线程封闭，即为每个线程实例化一个<code>KafkaConsumer</code>对象。</p><p><img src="http://bloghello.oursnail.cn/kafka7-4.png" alt="image"></p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstMultiConsumerThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">"topic-demo"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String groupId = <span class="string">"group.demo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList);</span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);</span><br><span class="line">        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = initConfig();</span><br><span class="line">        <span class="keyword">int</span> consumerThreadNum = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumerThreadNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> KafkaConsumerThread(props, topic).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> KafkaConsumer&lt;String, String&gt; kafkaConsumer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">KafkaConsumerThread</span><span class="params">(Properties props, String topic)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">            <span class="keyword">this</span>.kafkaConsumer.subscribe(Arrays.asList(topic));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">                            kafkaConsumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">                    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                        <span class="comment">//process record.</span></span><br><span class="line">                        System.out.println(record.value());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                kafkaConsumer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对消息的处理很快，那么<code>poll</code>拉起的频次也会更高，进而整体消费的性能也会提升；不过，如果消息处理比较慢，比如进行一个事务性操作，或者等待一个RPC的同步相应，那么<code>poll</code>频次就会降低，造成整体消费性能的下降。这边考虑优化，提升整体性能，将处理消息模块改成多线程的实现方式。</p><p><img src="http://bloghello.oursnail.cn/kafka7-5.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdMultiConsumerThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">"topic-demo"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String groupId = <span class="string">"group.demo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, brokerList);</span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId);</span><br><span class="line">        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = initConfig();</span><br><span class="line">        KafkaConsumerThread consumerThread = <span class="keyword">new</span> KafkaConsumerThread(props, topic,</span><br><span class="line">                Runtime.getRuntime().availableProcessors());</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> KafkaConsumer&lt;String, String&gt; kafkaConsumer;</span><br><span class="line">        <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threadNumber;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">KafkaConsumerThread</span><span class="params">(Properties props, String topic, <span class="keyword">int</span> threadNumber)</span> </span>&#123;</span><br><span class="line">            kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">            kafkaConsumer.subscribe(Collections.singletonList(topic));</span><br><span class="line">            <span class="keyword">this</span>.threadNumber = threadNumber;</span><br><span class="line">            executorService = <span class="keyword">new</span> ThreadPoolExecutor(threadNumber, threadNumber,</span><br><span class="line">                    <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1000</span>),</span><br><span class="line">                    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">                            kafkaConsumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">                    <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                        executorService.submit(<span class="keyword">new</span> RecordsHandler(records));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                kafkaConsumer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordsHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> ConsumerRecords&lt;String, String&gt; records;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RecordsHandler</span><span class="params">(ConsumerRecords&lt;String, String&gt; records)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.records = records;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//处理records.</span></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RecordsHandler</code>就是用来处理消息的，<code>KafkaConsumerThread</code>类对应的是一个消费线程，里面通过线程池的方式来调用<code>RecordsHandler</code>处理一批批的消息。注意<code>KafkaConsumerThread</code>中的<code>ThreadPoolExecutor</code>里的最后一个参数设置的是<code>CallerRunsPolicy</code>，这样可以防止线程池的总体消费能力根本不上<code>poll</code>拉取的能力，从而导致异常现象的发生。这个方法具有横向扩展能力，可以通过开启多个<code>KafkaConsumerThread</code>实例来进一步提高整体的消费能力。</p><p>下表总结了两种方法的优缺点：</p><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>方法1</strong>(每个线程维护一个KafkaConsumer)</td><td>①方便实现<br>②速度较快，因为不需要任何线程间交互<br>③易于维护分区内的消息顺序</td><td>①更多的TCP连接开销(每个线程都要维护若干个TCP连接)<br>②consumer数受限于topic分区数，扩展性差<br>③频繁请求导致吞吐量下降<br>④线程自己处理消费到的消息可能会导致超时，从而造成rebalance</td></tr><tr><td><strong>方法2</strong> (单个(或多个)consumer，多个worker线程)</td><td>①可独立扩展consumer数和worker数，伸缩性好</td><td>①实现麻烦<br>②通常难于维护分区内的消息顺序<br>③处理链路变长，导致难以保证提交位移的语义正确性</td></tr></tbody></table><p>对于第二种方式，消息的顺序性不能保证，考虑使用一个共享变量<code>offsets</code>来参与提交。每一个处理消息的<code>RecordHandler</code>类在处理完消息后都将对应的消费位移保存到共享变量<code>offsets</code>中（注意，这里的offsers是一个map结构，即&lt;分区，offset&gt;的结构），每次消费完分区消息后，就记录一下。这里为防止出现并发问题，需要对<code>offsers</code>的读写进行加锁处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/kafka1-15.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前学习了如何进行消费位移的提交，正是有了消费位移的持久化，才能使消费者在关闭、崩溃或者遇到再均衡的时候，可以让接替的消费者根据存储的消费位移继续继续进行消费。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>06kafka消费者-中</title>
    <link href="http://yoursite.com/2019/09/22/kafka/06kafka%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%AD/"/>
    <id>http://yoursite.com/2019/09/22/kafka/06kafka消费者中/</id>
    <published>2019-09-22T10:24:22.741Z</published>
    <updated>2019-09-22T10:24:37.820Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bloghello.oursnail.cn/kafka1-15.jpg" alt="image"></p><p>下面继续探讨kafka的消费者，正如上篇文章最后所说，消费者的逻辑牵涉到很多内容，并不是简单地死循环获取消息那么简单。本篇文章着重介绍消费者中比较重要的概念：消费位移。</p><a id="more"></a><h2>一、消费位移概念</h2><p>对于kafka中的分区所言，它的每条消息都有唯一的offset，用来表示消息在分区中对应的位置。可以翻译成”偏移量“，也可以翻译为”位移“。这里做个约定：对于消息在分区中的位置，我们将offset称为“偏移量”；对于消费者消费到的位置，将offset称为“位移”或“消费位移”。当然，不区分也是可以的，因为毕竟这个offset是唯一的，一条消息在分区中的offset是固定的。</p><p>消费位移需要持久化，为什么呢？</p><h2>二、消费位移持久化</h2><p>我们知道，每次调用<code>poll</code>方法时，它返回的时还没有被消费过的消息集（前提时消息已经存储在kafka上了），要做到这一点，就需要记录上一次消费时的消费位移。并且这个消费位移必须持久化保存，而不是单单保存在内存中，否则消费者重启之后就无法知晓之前的消费位移。</p><p>再考虑一种情况，当有新的消费者加入时，那么必然有再均衡的动作，对于同一分区而言，它可能在再均衡动作之后分配给新的消费者，如果不持久化消费位移，那么这个新的消费者也无法知晓之前的消费位移。</p><p>在旧消费者客户端中，消费位移是存储在<code>zookeeper</code>中的，而在新消费者客户端中，消费位移是存储在<code>kafka</code>内部的主题<code>_consumer_offsets</code>中。这里把消费位移存储起来（持久化）的动作称为“提交”，消费者在消费完消息后需要执行消费位移的提交。</p><p><img src="http://bloghello.oursnail.cn/kafka7-1.png" alt="image"></p><p>上图中<code>X</code>表示某一次拉取操作中此分区消息的最大消息偏移量，也就是说，此时消费者的消费位移为<code>X</code>，图中用<code>lastConsumedOffset</code>来表示。</p><p>⭐不过需要明确的是，当前消费者需要提交的消费位移是<code>X+1</code>而不是<code>X</code>。对应的是图中<code>positition</code>，它表示下一条需要拉取的消息的位置。</p><p>此外，消费者中还有一个<code>committed offset</code>的概念，表示已经提交过的消费位移。</p><p><code>KafkaConsumer</code>类提供了<code>position(TopicPartition)</code>和<code>commited(TopicPartition)</code>两个方法来分别获取上面所说的<code>position</code>和<code>committed offset</code>的值。这两个方法的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">position</span><span class="params">(TopicPartition partition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> offsetAndMetadata <span class="title">committed</span><span class="params">(TopicPartition partition)</span></span></span><br></pre></td></tr></table></figure><p>上面提到了三个名词：<code>lastConsumedOffset</code>、<code>committed offset</code>以及<code>positition</code>。他们的关系是：一般情况下，<code>committed offset</code>=<code>positition</code>=<code>lastConsumedOffset</code>+1。不过<code>committed offset</code>与<code>positition</code>并不是一直相同。这个情况下面会体现。</p><p>位移的提交时机也有讲究，可能会造成重复消费和消息丢失的现象</p><ul><li>拉取到消息之后就进行位移提交， 若消费到一半时宕机，则造成<strong>消息丢失</strong>现象</li><li>消费完所有消息后在进行位移提交， 若消费到一半时宕机，则造成<strong>重复消费</strong>现象</li></ul><p><img src="http://bloghello.oursnail.cn/kafka7-2.png" alt="image"></p><p>如上图所示，当前<code>poll</code>操作所拉取的消息集为[x+2,x+7]，x+2代表上一次提交的消费位移，说明已经完成了x+1之前（包括x+1）的所有消息的消费。x+5表示当前正在处理的位置，如果拉取到消息之后就进行了位移提交，即提交了x+8，那么当前消费x+5的时候遇到了异常，在故障恢复之后，我们重新拉取的消息是从x+8开始的。也就是说。x+5和x+7之间的消息未能被消费，便发生了消息丢失现象。</p><p>再考虑另一种情形，位移提交的动作是在消费完所有拉取到的消息之后才执行的，那么当消费x+5的时候遇到了异常，在故障恢复之后，我们重新拉取的消息是从x+2开始的，也就是说，x+2和x+4之间的消息又重新消费了一遍，故而发生了重复消费的现象。</p><h2>三、自动位移提交</h2><p><code>Kafka</code>默认的消费位移提交方式是自动提交（定期）。<code>enable.auto.commit</code>默认为<code>true</code>，这个默认的自动提交不是每消费一条消息旧提交一次，而是定期提交;</p><p><code>auto.commit.interval.ms</code>配置提交的周期，默认为5秒。自动提交的动作是在<code>poll()</code>方法的逻辑中完成的，会在每次拉取请求之间检查是否可以进行位移提交。</p><p>在默认情况下，消费者每隔5秒会将拉取到的每个分区中最大的消息位移进行提交。自动位移提交的动作是在<code>poll</code>方法的逻辑里面完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一轮轮询的位移。</p><p>位移自动提交很简便，免去了复杂的位移提交逻辑，让编码更简洁，但是随之而来的是重复消费和消息丢失的问题。</p><ul><li>重复消费： 消费到一半时宕机，而尚未提交，则造成重复消费</li><li>消息丢失：如图线程A进行拉取消息到缓存，线程B从缓存中处理逻辑。 若线程B处理到一半时宕机，那么下次恢复时又从【X+7】开始拉取，造成了【x+4】-【X+7】消息的丢失</li></ul><p><img src="http://bloghello.oursnail.cn/kafka7-3.png" alt="image"></p><p>重复消费比较好理解，因为自动提交是一种延时提交，在自动提交位移前消费者崩溃了，那么必然会从上一次位移提交的地方开始重新消费，我们可以通过减少位移提交的时间间隔来减少重复消息的窗口大小，但不能避免消息重复的问题，还会使位移提交更加频繁。那么如果理解消息丢失呢？</p><p>如上图所示，假设线程A不断拉取消息存到本地缓存，比如<code>BlockingQueue</code>中，另一个处理线程B从缓存中读取消息并进行相应的逻辑处理。</p><p>现在假设进行到了y+1次拉取，以及第m次位移提交的时候，也就是说X+7之前的位移已经确认提交了，处理线程B还在处理X+4的消息，此时如果线程B发生异常，恢复后会从第m次位移提交处，即X+7的地方开始拉取消息。那么X+3至X+7之间的消息就丢失了。</p><h2>四、手动提交</h2><p>可以看出自动提交编码简单但会出现消息丢失和重复消费现象，并且无法做到精确的位移管理，因此<code>Kafka</code>还提供了 手动提交的方式。通常不是拉取到消息就算消费完成了，而是当我们通过这条消息完成一系列业务处理后，才认为消息被成功消费。开启手动提交需要<code>enable.auto.commit</code>设置为<code>false</code>.</p><p>手动提交可分为同步提交和异步提交。 即<code>commitSync()</code>和<code>commitAsync()</code>两种方式</p><p>以下是同步提交示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#拉取所有消息并处理后进行同步提交</span><br><span class="line"><span class="keyword">while</span> (running.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        <span class="comment">//do some logical processing.</span></span><br><span class="line">    &#125;</span><br><span class="line">    consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例是对拉取的每一条消息做相应的处理，然后对整个消息集做同步提交。也可以改为批量处理+批量提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#批量处理+批量提交</span><br><span class="line"><span class="keyword">int</span> minBatchSize = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">while</span> (running.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">    buffer.add(record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buffer.size() &gt;= minBatchSize) &#123;</span><br><span class="line">        <span class="comment">//do some logical processing with buffer.</span></span><br><span class="line">        consumer.commitSync();</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码改为：先将消息存入缓存<code>buffer</code>，当消息积累足够多的时候在进行批量的处理和批量提交。以上两个示例都存在重复消费的问题，即如果在业务逻辑处理完之后，并且在同步位移提交之前，程序出现了崩溃，那么待恢复后只能从上一次位移提交的地方拉取消息，由此造成重复消费。</p><p>如果想寻求更细粒度、更精准的提交，需要使用另一个含参方法，如下例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#带参数的同步位移提交，可控制提交的offset，该案例为每消费一条就提交一次</span><br><span class="line"><span class="keyword">while</span> (running.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        <span class="comment">//do some logical processing.</span></span><br><span class="line">        <span class="keyword">long</span> offset = record.offset();</span><br><span class="line">        TopicPartition partition =</span><br><span class="line">        <span class="keyword">new</span> TopicPartition(record.topic(), record.partition());</span><br><span class="line">        consumer.commitSync(Collections</span><br><span class="line">            .singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(offset + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法提供了<code>offset</code>参数，用来提交指定分区的位移。无参的<code>commitSync()</code>方法只能提交当前批次对应的<code>position</code>值。如果需要提交一个中间值，比如上述代码中每消费一条消息就提交一次位移，就可以使用这个方法。</p><p>实际应用中，很少有这种每消费一条消息就提交一次消费位移的必要场景。<code>commitSync()</code>本身是同步执行的，会耗费一定的性能，更多的时候是按照分区的粒度划分提交位移的界限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#按分区粒度同步提交消费位移，每处理完一个分区就提交一次</span><br><span class="line"><span class="keyword">while</span> (running.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : partitionRecords) &#123;</span><br><span class="line">            <span class="comment">//do some logical processing.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> lastConsumedOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">        consumer.commitSync(Collections.singletonMap(partition,<span class="keyword">new</span> OffsetAndMetadata(lastConsumedOffset + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步提交在执行的时候消费者线程不会被阻塞，可能在提交消费位移的结果还未返回之前就开始了新一轮的拉取操作。异步提交可以使消费者的性能得到一定的增强。有三个重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#异步提交，可指定提交完成后的回调函数</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">(OffsetCommitCallback callback)</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitAsync</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback callback)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>callback</code>参数，提供了一个异步提交的回调函数，当位移提交完成后会回调<code>OffsetCommitCallback</code>中的<code>onComplete</code>方法。</p><p>异步提交也存在重复消费的问题。如果先提交了【X+2】，再提交【X+8】。如果后者提交成功而前者提交失败。 如果此时前者进行重试提交，那么成功后会造成数据的重复消费。</p><p>对于异步提交可以设置一个递增的序号维护异步提交的顺序，如当位移提交失败需要重试提交时，对比所提交的位移和维护的序号大小，如果前者小于后者，就不需要再重复提交了。如果两者相等，则可以进行重试提交。</p><h2>五、控制或关闭消费</h2><p><code>KafkaConsumer</code>提供了对消费速度进行控制的方法，在某些应用场景下我们可能需要暂停某些分区的消费而先消费其他分区，当达到一定条件时可以再恢复这些分区的消费。<code>KafkaConsumer</code>提供了暂停<code>pause()</code>和恢复<code>resume()</code>某些分区的消费。</p><p>之前的示例中都是使用一个<code>while</code>循环来包裹住<code>poll()</code>方法及相应的消费逻辑，如果优雅地退出这个循环呢？</p><p>之前的代码中并不是以<code>while(true)</code>来简单包裹，而是<code>while(isRunning.get())</code>的方式，这样可以通过在其他地方设定<code>isRunning.set(false)</code>来退出<code>while</code>循环。</p><p>还有一种方式是调用<code>KafkaConsumer</code>的<code>wakeup()</code>方法，<code>wakeup()</code>方法是<code>KafkaConsumer</code>中唯一可以从其他线程里安全调用的方法（<code>KafkaConsumer</code>是非线程安全的），调用<code>wakeup()</code>方法后可以退出<code>poll()</code>的逻辑，并抛出<code>WakeupException</code>的异常，我们不需要处理它，它只是一种跳出循环的方式。</p><p>跳出循环后一定要显式地执行关闭动作以释放运行过程中占用的各种资源，包括内存资源、<code>Socket</code>连接等。<code>KafkaConsumer</code>提供了<code>close()</code>方法来实现关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Duration timeout)</span></span></span><br><span class="line"><span class="function">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit timeunit)</span></span></span><br></pre></td></tr></table></figure><p>第二种方法是通过<code>timeout</code>参数来设定关闭方法的最长执行时间，有些内部的关闭逻辑会耗费一定的时间，比如设置了自动提交消费位移，这里还会做一次位移提交的动作。而第一个方法中没有<code>timeout</code>参数，这并不意味着会无限制等待，内部设定最多等待30秒。第三种方法已过时，可以不关心。</p><p>那么一个相对比较完整的消费程序可以参考以下的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(running.get())&#123;</span><br><span class="line">        <span class="comment">// consumer.poll()</span></span><br><span class="line">        <span class="comment">// process the record</span></span><br><span class="line">        <span class="comment">// commit offset</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(WakeupException e)&#123;</span><br><span class="line">    <span class="comment">// ignore the error</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// do some logic process</span></span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// maybe commit offset</span></span><br><span class="line">    comsumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/kafka1-15.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面继续探讨kafka的消费者，正如上篇文章最后所说，消费者的逻辑牵涉到很多内容，并不是简单地死循环获取消息那么简单。本篇文章着重介绍消费者中比较重要的概念：消费位移。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>05kafka消费者-上</title>
    <link href="http://yoursite.com/2019/09/01/kafka/05kafka%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8A/"/>
    <id>http://yoursite.com/2019/09/01/kafka/05kafka消费者上/</id>
    <published>2019-09-01T11:32:53.161Z</published>
    <updated>2019-09-01T11:45:19.302Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bloghello.oursnail.cn/kafka1-15.jpg" alt="image"></p><p>学习完生产者，下面自然就是消费者。消费者要学习的内容比生产者要多，本篇主要聚焦于消费者/消费组的基本概念以及客户端的基本开发（包括如何订阅主题和分区、如何消费消息）。</p><a id="more"></a><h2>一、消费者和消费组</h2><p>在学习消费者消费消息之前，需要先了解消费者和消费组的关系。</p><p>消费者负责订阅<code>kafka</code>的主题，并且可以从订阅的主题上拉取消息。与其他一些消息中间件不同的是：在<code>kafka</code>的消费理念中还有一层消费组的概念，每个消费者都有一个对应的消费组。<strong>当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者</strong>。</p><p>消费者以组的名义订阅主题，主题有多个分区，消费者组中有多个消费者实例，那么消费者实例和分区之间的对应关系是怎样的呢？</p><p>换句话说，就是组中的每一个消费者负责那些分区，这个分配关系是如何确定的呢？如下图示例：</p><p><img src="http://bloghello.oursnail.cn/kafka6-1.png" alt="image"></p><p>这是<code>kafka</code>的默认规则，分配结果为消费组A的每个消费者分到两个分区，消费组B每一个消费者分到一个分区，两个消费组之间互不影响。</p><p>也就是说：消费者组订阅这个主题，意味着主题下的所有分区都会被组中的消费者消费到，如果按照从属关系来说的话就是，主题下的每个分区只从属于组中的一个消费者，不可能出现组中的两个消费者负责同一个分区。</p><p>话说回来，假设一个消费组内多个消费者负责同一个分区，那么会有什么问题呢？</p><p>我们知道，<code>Kafka</code>它在设计的时候就是要保证分区下消息的顺序，也就是说消息在一个分区中的顺序是怎样的，那么消费者在消费的时候看到的就是什么样的顺序，那么要做到这一点就首先要保证消息是由消费者主动拉取的（<code>pull</code>），其次还要保证一个分区只能由一个消费者负责。</p><p>倘若，一个消费组内两个消费者负责同一个分区，那么就意味着两个消费者同时读取分区的消息，会造成两个问题：</p><ul><li>重复消息处理：<code>C1</code>才读到2，<code>C1</code>还没处理完，<code>C2</code>又可能去读2去处理，则会造成很多浪费，因为这就相当于多线程读取同一个消息，会造成消息处理的重复</li><li>不能保证消息顺序：一个线程在处理1，还没处理完，另一个线程已经处理到3，此时1处理完了，那么消费的处理顺序就不对了</li></ul><p>下面我们看看当消费组内的消费者个数变化时对应的分区分配演变如下：（默认的<code>RangeAssinor</code>为例）</p><p><img src="http://bloghello.oursnail.cn/kafka6-2.png" alt="image"></p><p>我们可以看到，当增加消费者的时候，每个消费者分到的分区就会动态地减少，可以利用这个消费者-消费组模型来扩展消费能力。但是我们不能一味地增加消费者，如果消费者过多，出现了消费者个数大于分区个数的情况，就会有消费者分配不到任何分区。</p><p><img src="http://bloghello.oursnail.cn/kafka6-3.png" alt="image"></p><p>此外，<code>kafka</code>同时支持两种消息投递模式也是得益于消费者与消费组模型：点对点(<code>P2P</code>)模式和发布/订阅(<code>Pub</code>/<code>Sub</code>)模式。</p><p>简单介绍一下点对点模式：基于队列，消息生产者发送消息到队列，消息消费者从队列中接收消息。</p><p>下面简单介绍一下发布订阅模式：定义了如何向一个内容节点发布和订阅消息，这个内容节点成为主题，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息。主题使得消息的订阅者和发布者互相保持独立，不需要进行接触可保证消息的传递，发布订阅模式在消息的一对多广播时采用。</p><p>前面说了，<code>kafka</code>支持这两种模式：</p><ul><li>⭐<strong>如果所有消费者都隶属于同一个消费组</strong>，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，相当于点对点模式</li><li>⭐<strong>如果所有的消费者都隶属于不同的消费组</strong>，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，相当于发布/订阅模式的应用</li></ul><p>每一个消费者只隶属于一个消费组。消息发送时可指定消费者组， 消费者客户端通过<code>group.id</code>配置消费者组名称，默认为空字符串。</p><h2>二、消费者客户端开发</h2><p>注意<code>KafkaConsumer</code>是非线程安全的，以下为一个简单的消费者客户端的代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">"topic-demo"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String groupId = <span class="string">"group.demo"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean isRunning = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">        props.put(<span class="string">"group.id"</span>, groupId);</span><br><span class="line">        props.put(<span class="string">"client.id"</span>, <span class="string">"consumer.client.id.demo"</span>);</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = initConfig();</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">                        consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">                <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"topic = "</span> + record.topic()</span><br><span class="line">                            + <span class="string">", partition = "</span> + record.partition()</span><br><span class="line">                            + <span class="string">", offset = "</span> + record.offset());</span><br><span class="line">                    System.out.println(<span class="string">"key = "</span> + record.key()</span><br><span class="line">                            + <span class="string">", value = "</span> + record.value());</span><br><span class="line">                    <span class="comment">//do something to process record.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"occur exception "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Kafka</code>的消费逻辑</p><ul><li>配置消费者客户端参数及创建相应消费者实例</li><li>订阅主题</li><li>拉取消息并消费</li><li>提交消费位移（后面会讲）</li><li>关闭消费者实例</li></ul><p>以上的一些参数配置跟生产者端很类似，这里多一个<code>group.id</code>和<code>client.id</code>两个参数。前者为消费组，后者为标识客户端的<code>id</code>，如果不设置则默认生成一个非空字符串，内容形式如：<code>consumer-1</code>、<code>consumer-2</code>等。</p><h2>三、订阅主题和分区</h2><p>消费者可以订阅一个或多个主题，上述示例用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(topic));</span><br></pre></td></tr></table></figure><p>来订阅了一个主题。如果前后两次订阅了不同的主题，那么消费者以最后一次的为准。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(topic1);</span><br><span class="line">consumer.subscribe(topic2);</span><br></pre></td></tr></table></figure><p>那么消费者最终订阅的是<code>topic2</code>，而不是<code>topic1</code>，也不是<code>topic1</code>和<code>topic2</code>的并集。</p><p>还可以用正则表达式的方式订阅，形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Pattern.compile(<span class="string">"topic-.*"</span>));</span><br></pre></td></tr></table></figure><p>消费者不仅可以通过<code>KafkaConsumer.subscribe()</code>的方法订阅主题，还可以直接订阅某些主题的特定分区，在<code>KafkaConsumer</code>中提供了<code>assign()</code>方法来实现这些功能。此方法的具体定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span></span></span><br></pre></td></tr></table></figure><p>这个方法只接收一个参数<code>partitions</code>，用来指定需要订阅的分区集合。这个<code>TopicPartition</code>类定义的部分内容为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartition</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tipic;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TopicPartition</code>类中只有两个属性，分别代表分区所属的主题和自身的分区编号，这个类可以和我们通常说的主题-分区的概念映射起来。</p><p>具体的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.assign(Arrays.asList(<span class="keyword">new</span> TopicPartition(<span class="string">"topic-demo"</span>,<span class="number">0</span>)));</span><br></pre></td></tr></table></figure><p>可能会有疑问：如果我们事先不知道主题中有多少个分区怎么办？<code>KafkaConsumer</code>中的<code>partitionsFor()</code>方法可以用来查询指定主题的元数据信息，<code>partitionsFor()</code>方法具体定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;PartitionInfo&gt; <span class="title">partitionsFor</span><span class="params">(String topic)</span></span></span><br></pre></td></tr></table></figure><p><code>PartitionInfo</code>类型即为主题的分区元数据信息，此类的主要结构为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionInfo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;<span class="comment">//主题名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> partition;<span class="comment">//分区编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> node leader;<span class="comment">//leader副本所在的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> node[] replicas;<span class="comment">//AR集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> node[] inSyncReplicas;<span class="comment">//ISR集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> node[] offlineReplicas;<span class="comment">//OSR集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>partitionsFor()</code>方法可以订阅主题全部分区的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;PartitionInfo&gt; partitionInfos = consumer.partitionsFor(topic);</span><br><span class="line"><span class="keyword">if</span> (partitionInfos != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(PartitionInfo tpInfo : partitionInfos)&#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> TopicPartition(tpInfo.topic,tpInfo.partition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer.assign(partitions);</span><br></pre></td></tr></table></figure><p>上面介绍了三种订阅的方式：集合订阅的方式<code>subscribe(Collection)</code>、正则表达式订阅方式<code>subscribe(Pattern)</code>、<br>指定分区的订阅方式<code>assign(Collection)</code>，分别代表了三种不同的订阅状态：<code>AUTO_TOPICS</code>、<code>AUTO_PATTERN</code>和<code>USER_ASSIGNED</code>（如果没有订阅则状态为<code>NONE</code>）。<strong>这三种状态是互斥的</strong>，在一个消费者中只能使用其中的一种，否则会报出<code>IllegalStateException</code>异常。</p><p>他们之间还有一个区别：<strong><code>subscribe</code>订阅主题时具有自动再平衡（后面会讲）的功能</strong>，在多个消费者的情况下可以根据分区策略来自动分配各个消费者与分区的关系，当消费组内的消费者增加或减少时，分区分配关系会自动调整，以实现消费负载均衡及故障自动转移；而<code>assign</code>不具备消费者自动均衡的功能。从源码可以看到<code>subscribe()</code>重载方法里有一个参数类型为<code>ConsumerRebalanceListener</code>，这个是用来设置相应的再均衡监听器的，后面还会再次说明。</p><h2>四、消息消费</h2><p><code>kafka</code>中的消费是基于拉模式的。</p><p>消息的消费一般有两种模式：推模式和拉模式。推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来拉取消息。</p><p>我们从第二节的代码可以看到，<code>kafka</code>的消息消费是一个不断轮询的过程，消费者所要做的就是重复调用<code>poll</code>方法，而<code>poll</code>方法返回的是订阅的主题或分区上的一组消息。</p><p>对于<code>poll</code>而言，如果某些分区中没有可供消费的消息，那么此分区对应的消息拉取的结果就为空；如果所有分区都没有可供消费的消息，那么<code>poll</code>返回空的消息集合。</p><p><code>poll()</code>方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(Duration timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><code>timeout</code>参数是超时时间参数，用来控制<code>poll</code>的阻塞时间，在消费者的缓冲区中没有可用数据时会发生阻塞。注意参数类型为<code>Duration</code>，他是JDK8中新增的一个与时间有关的类型。可用利用<code>Duration</code>中的<code>ofMillis()</code>、<code>ofSeconds()</code>、<code>ofMinutes()</code>、<code>ofHours</code>等多种不同的方法指定不同的时间单位，灵活性更强。老的方式是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>明显时间单位只能用固定的毫秒，因此被标注为了<code>@Deprecated</code>，推荐用新的方式。</p><p><code>timeout</code>的设置取决于应用程序对响应速度的要求，比如需要在多长时间内将控制权移交给执行轮询的应用线程。可以直接将<code>timeout</code>设置为0，这样<code>poll</code>方法就会立刻返回，而不管是否已经拉取到消息。</p><p>再看在第二节一开始示例的代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        System.out.println(<span class="string">"topic = "</span> + record.topic()</span><br><span class="line">                + <span class="string">", partition = "</span> + record.partition()</span><br><span class="line">                + <span class="string">", offset = "</span> + record.offset());</span><br><span class="line">        System.out.println(<span class="string">"key = "</span> + record.key()</span><br><span class="line">                + <span class="string">", value = "</span> + record.value());</span><br><span class="line">        <span class="comment">//do something to process record.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实它是将订阅的主题中所有的消息都收到了，<strong>那么我们能不能以分区的维度进行消费呢</strong>？这一点很有用，在手动提交位移时尤为明显。关于提交位移下一节再详述。<code>ConsumerRecords</code>类提供了一个<code>records(TopicPartition)</code>方法来获取消息集中指定分区的消息，此方法的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ConsumerRecord&lt;K,V&gt;&gt; records(TopicPartition partition)</span><br></pre></td></tr></table></figure><p>下面为按照分区的维度对消息进行消费代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">            consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span>(TopicPartition tp : records.partitions())&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records.records(tp)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"partition = "</span> + record.partition()</span><br><span class="line">                + <span class="string">", value = "</span> + record.value());</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>records.partitions()</code>用来获取消息集中所有分区。<strong>那我们能不能以主题的维度进行消费呢</strong>？<code>ConsumerRecords</code>提供了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;ConsumerRecord&lt;K,V&gt;&gt; records(String topic)</span><br></pre></td></tr></table></figure><p>下面为按照主题的维度对消息进行消费代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; topicList = Arrays.asList(topic1,topic2);</span><br><span class="line">consumer.subscribe(Arrays.asList(topicList));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records =</span><br><span class="line">                consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span>(String topic : topicList)&#123;</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records.records(topic)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"partition = "</span> + record.partition()</span><br><span class="line">                    + <span class="string">", value = "</span> + record.value());</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，可以简单认为<code>poll</code>方法只是拉取一下消息而已，不过内部逻辑并不简单，它涉及消费位移、消费者协调器、组协调器、消费者的选举、分区分配的分发、再均衡的逻辑、心跳等内容。下面的文章再去继续探讨。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/kafka1-15.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;学习完生产者，下面自然就是消费者。消费者要学习的内容比生产者要多，本篇主要聚焦于消费者/消费组的基本概念以及客户端的基本开发（包括如何订阅主题和分区、如何消费消息）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>04kafka生产者</title>
    <link href="http://yoursite.com/2019/08/27/kafka/04kafka%E7%94%9F%E4%BA%A7%E8%80%85/"/>
    <id>http://yoursite.com/2019/08/27/kafka/04kafka生产者/</id>
    <published>2019-08-27T13:59:22.952Z</published>
    <updated>2019-08-29T12:23:18.612Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bloghello.oursnail.cn/kafka1-15.jpg" alt="image"></p><p>在完成kafka的入门以及基本的操作之后，相信已经对kafka有了基本认识，下面我们一起从kafka的生产者开始，深入学习一下。</p><a id="more"></a><h2>一、一个简单的生产者示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerAnalysis</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注1：brokerList可以写多个，中间用逗号隔开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">"topic-demo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">        <span class="comment">//注2：消息在发送到broker之前需要将key和value序列化成字节数组</span></span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>,</span><br><span class="line">                <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties props = initConfig();</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">"hello, Kafka!"</span>);</span><br><span class="line">        producer.send(record);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，<code>KafkaProducer</code>是线程安全的，可以在多个线程中共享单个<code>KafkaProducer</code>实例，也可以将<code>KafkaProducer</code>实例进行池化来供其他线程调用。</strong></p><ul><li>生产逻辑的几个步骤：<ul><li>配置生产者客户端参数并创建生产者实例</li><li>构建待发送消息</li><li>发送消息</li><li>关闭生产者实例</li></ul></li></ul><p>注意，我们发送消息的时候，可以指定消息的<code>topic</code>、<code>partition</code>、<code>headers</code>、<code>key</code>、<code>value</code>等字段。</p><ul><li><code>topic</code>：消息要发往的主题，不赘述</li><li><code>partition</code>：消息要发往的分区号，不赘述</li><li><code>headers</code>：指消息的头部，<code>Kafka 0.11.x</code>版本才引入此属性，它大多来设定一些与应用相关的信息，基本不用管他。</li><li><code>key</code>：指消息的键，它可以用来计算分区号进而可以让消息发往特定的分区，消息可以以主题进行分类，也可以用<code>key</code>进行二次归类，同一个<code>key</code>的消息会被划分到同一个分区。，有<code>key</code>的消息可以支持日志压缩功能。</li><li><code>value</code>：指消息体，一般不为空，如果为空则表示特定的消息-墓碑消息，后续介绍。</li></ul><h2>二、发送消息的三种模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>发后即忘</strong><ul><li>只管发送消息，不关心信息是否正确到达。</li><li>优点：性能最高，吞吐量大</li><li>缺点：会造成数据丢失，可靠性低</li></ul></li><li><strong>同步</strong><ul><li>发送消息后返回<code>Future</code>对象，调用<code>get()</code>方法时阻塞等待，直到发送成功或出现异常</li><li>优点：可靠性高，如有异常可处理或进行消息重发</li><li>缺点：性能低，造成阻塞</li></ul></li><li><strong>异步</strong><ul><li>发送消息时指定回调函数，<code>Kafka</code>在返回响应时会调用该函数实现异步的发送确认。</li><li>在同一个分区中，如果消息<code>record1</code>比<code>record2</code>先发送，那么它会保证<code>callback1</code>在<code>callback2</code>之前调用。</li></ul></li></ul><p>这里推荐使用第三种即回调函数的方式来实现，但是针对<code>send()</code>方法的返回值是<code>Future</code>可能会有疑问：<code>Future</code>本身就是可以用作异步的逻辑处理。这样做不是不行，只不过<code>Future</code>里的<code>get()</code>方法在何时调用，以及怎么调用都是需要面对的问题，消息不停地发送，那么诸多消息的<code>Future</code>对象的处理难免会引起代码处理逻辑的混乱。因此推荐使用<code>Callback</code>这种回调函数的方式来处理，要么发送成功，要么抛出异常，回调函数示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">producer.send(record,<span class="keyword">new</span> callback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span>!=e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.printf(metadata.topic()+<span class="string">"-"</span>+metadata.partition()+<span class="string">"-"</span>+metadata.offset());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，<code>metadata</code>和<code>e</code>是互斥的，消息发送成功时，<code>metadata</code>不为<code>null</code>而<code>e</code>为<code>null</code>；消息发送异常时，<code>metadata</code>为<code>null</code>为<code>e</code>不为<code>null</code>；</p><p>再来说说<code>Future</code>对象，它表示一个任务的生命周期，并提供了相应的方法来判断任务是否已经完成或取消，以及获取任务的结果和取消任务等。我们可以使用<code>Future</code>中的<code>get(long timeout,TimeUtil unit)</code>方法实现可超时的阻塞。</p><p><code>KafkaProducer</code>中一般会发生两种异常：可重试的异常和不可重试的异常。常见的可重试异常有：</p><ul><li><code>NetworkException</code>：表示网络异常，有可能由于网络瞬间故障而导致的异常，可以通过重试解决</li><li><code>LeaderNotAvailableException</code>表示分区的<code>leader</code>副本不可用，这个异常通常发生在<code>leader</code>副本下线而新的<code>leader</code>副本选举完成之前，重试之后可以重新恢复。</li></ul><p>不可重试的异常：比如<code>RecordTooLargeException</code>异常，暗示了所发送的消息太大，<code>KafkaProducer</code>对此不会进行任何重试，直接抛出异常。</p><h2>三、发送者整体架构原理分析</h2><p>整体架构如下：</p><p><img src="http://bloghello.oursnail.cn/kafka5-1.png" alt="image"></p><p>主要分为两个线程，一个主线程，一个发送线程，我们从左向右一一说明。</p><p>消息在发送到<code>kafka</code>之前，可能需要经历拦截器、序列化器和分区器。对应着图中是左边主线程中干的事情。下面一一介绍一下。</p><blockquote><p>1.拦截器</p></blockquote><p>拦截器早在<code>Kafka0.10.0.0</code>中已经引入的功能，一共有两种拦截器：生产者拦截器和消费者拦截器。这里当然主要关注生产者拦截器。</p><p>生产者拦截器既可以在消息发送之前做一些准备工作，比如按照某个规则过滤不符合要求的消息、修改消息的内容等，也可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。</p><p>下面给出一个简单示例，<code>onSend()</code>方法给每条消息加一个前缀<code>prefix1-</code>，并且通过<code>onAcknowledgement</code>开统计发送消息的成功率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerInterceptorPrefix</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> sendSuccess = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> sendFailure = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ProducerRecord&lt;String, String&gt; record)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String modifiedValue = <span class="string">"prefix1-"</span> + record.value();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord&lt;&gt;(record.topic(),</span><br><span class="line">                record.partition(), record.timestamp(),</span><br><span class="line">                record.key(), modifiedValue, record.headers());</span><br><span class="line"><span class="comment">//        if (record.value().length() &lt; 5) &#123;</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return record;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            RecordMetadata recordMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sendSuccess++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendFailure++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> successRatio = (<span class="keyword">double</span>) sendSuccess / (sendFailure + sendSuccess);</span><br><span class="line">        System.out.println(<span class="string">"[INFO] 发送成功率="</span></span><br><span class="line">                + String.format(<span class="string">"%f"</span>, successRatio * <span class="number">100</span>) + <span class="string">"%"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; map)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光有这个还不够，还需要在<code>KafkaProducer</code>的配置参数<code>interceptor.classes</code>中指定这个拦截器，此参数的默认值为“”，示例为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">properties.put(ProducerConfig.INTERCEPTOR_CLASSED_CONFIG,</span><br><span class="line">        ProducerInterceptorPrefix.class.getName());</span><br></pre></td></tr></table></figure><p>当然了，也可以指定多个拦截器形成拦截链，多个的拦截器之间用逗号隔开，并且是有顺序的，排在前面的先执行。</p><p>总结一下就是：消息一发出首先就是经过拦截器链处理消息，如果消息发送失败会调用<code>onAcknowledgement</code>方法，这个方法优先于用户设定的<code>Callback</code>之前执行。一般情况下，拦截器是用不到的。</p><blockquote><p>2.序列化器</p></blockquote><p>关于序列化，没什么好说的，总结为以下三句话：</p><ul><li>生产者使用序列化器将对象转换为字节数组，才能通过网络发送给Kafka</li><li>消费者使用反序列化其把Kafka中收到的字节数组转换为相应的对象。</li><li>因此生产者的序列化器和消费者使用的反序列化器要一一对应。</li></ul><blockquote><p>3.分区器</p></blockquote><p>上面介绍了拦截器和序列化器，一般情况下拦截器是不需要的，序列化器是必需的，消息经过序列化之后就需要确定它发往的分区，如果消息<code>ProducerRecord</code>中指定了<code>partition</code>字段，那么就不需要分区器了，因为<code>partition</code>就是要发往的分区号。</p><p>如果消息<code>ProducerRecord</code>中没有指定<code>partition</code>字段，就需要依赖分区器，根据<code>key</code>这个字段来计算<code>partition</code>的值，分区器的作用就是为消息分配分区。此时有两种情况：</p><ul><li><code>key</code>为<code>null</code>：那么消息将以轮询的方式发往主题内各个可用分区</li><li><code>key</code>不为<code>null</code>：默认的分区器会对<code>key</code>进行哈希（采用<code>MurmurHash2</code>算法，具备高运算性能即低碰撞率），最终根据得到的哈希值来计算分区号，拥有相同的<code>key</code>的消息会被写入同一个分区下</li></ul><div class="tip">注意：如果`key`不为`null`则计算处的分区号是所有分区号中的任意一个；如果`key`为`null`并且有可用分区时，那么计算得到的分区号仅为可用分区中的任意一个，注意两者之间的区别。</div><p>好了，至此介绍了拦截器、序列化器以及分区器的作用之后，之后又会发生什么呢？</p><p>不得不再把整体架构图拿过来了：</p><p><img src="http://bloghello.oursnail.cn/kafka5-1.png" alt="image"></p><p>我们可用看到，整个生产者客户端由两个线程协调运行，这两个线程分别为主线程和<code>Sender</code>线程。</p><h2>四、主线程</h2><p>在主线程中由<code>kafkaProducer</code>创建消息，然后通过可能的拦截器、序列化器和分区器的作用之后缓存到<strong>消息累加器</strong>（<code>RecordAccumulator</code>，也成为消息收集器）。<code>Sender</code>线程负责从<code>RecordAccumulator</code>中获取消息并将其发送到<code>Kafka</code>中。</p><p><code>RecordAccumulator</code>主要用来缓存消息以便<code>Sender</code>线程可用批量发送，进而减少网络传输的资源损耗以提升性能。<code>RecordAccumulator</code>缓存消息的可以通过<code>buffer.memory</code>进行配置，默认为32兆。</p><p>主线程中发送过来的消息都会被追加到<code>RecordAccumulator</code>的某个<strong>双端队列</strong>中，在<code>RecordAccumulator</code>的内部每个分区都维护了一个双端队列，队列中的内容就是<code>ProducerBatch</code>，即<code>Deque&lt;ProducerBatch&gt;</code>。</p><p><strong>消息写入缓存时，追加到双端队列的尾部；<code>Sender</code>线程获取消息时，从双端队列的头部读取。</strong></p><p>注意这里的<code>ProducerBatch</code>不是<code>ProducerRecord</code>，后者是一条消息，前者可以包含一个或多个<code>ProducerRecord</code>，即<code>ProducerBatch</code>是一个消息批次，<code>ProducerRecord</code>只是一条消息而已。<code>ProducerBatch</code>中包含多条<code>ProducerRecord</code>是为了使字节的使用更加紧凑，与此同时可以减少网络请求以提升整体的吞吐量。</p><p><code>ProducerBatch</code>与<code>batch.size</code>参数有一定的关系。当一条消息<code>ProducerRecord</code>流入<code>RecordAccumulator</code>时，会先寻找与消息分区所对应的双端队列（如果没有则新建），再从这个双端队列的尾部获取一个<code>ProducerBatch</code>（如果没有则新建），查看<code>ProducerBatch</code>中是否还可以写入这个<code>ProducerRecord</code>，如果可以则写入，如果不可以则需要创建一个新的<code>ProducerBatch</code>。</p><p>在新建<code>ProducerBatch</code>的时候评估这条消息是否超过<code>batch.size</code>参数的大小，如果不超过，就以<code>batch.size</code>参数的大小来创建<code>ProducerBatch</code>，这样在使用完这段内存区域之后，可以通过<code>BufferPool</code>的管理来进行复用；如果超过，就以评估的大小来创建<code>ProducerBatch</code>，这段内存区域不会被复用。</p><p>如果消息总是大于<code>batch.size</code>的大小，那么就会频繁地在内存中创建和释放这段区域，时比较浪费资源的。因此，<code>batch.size</code>的参数比较重要，默认是16K，我们可以适当调大以便多缓存一些消息。</p><h2>五、Sender线程</h2><p><code>Sender</code>从<code>RecordAccumulator</code>中获取缓存的消息之后，会进一步将原来<code>&lt;分区，Deque&lt;ProducerBatch&gt;&gt;</code>的保存形式转变成<code>&lt;node，List&lt;ProducerBatch&gt;&gt;</code>的形式，其中<code>node</code>表示kafka集群的<code>broker</code>节点。</p><p>对于网络连接来说，生产者客户端是与具体的<code>broker</code>节点建立的连接，也就是向具体的<code>broker</code>节点发送消息，而并不关心消息属于哪一个分区；而对于<code>KafkaProducer</code>的应用逻辑来说，我们只关注向哪个分区发送哪些消息，所以需要在这里做一个应用逻辑层面到IO层面的转换。</p><p>在转成<code>&lt;node，List&lt;ProducerBatch&gt;&gt;</code>的形式之后，<code>Sender</code>还会进一步封装成<code>&lt;node,Request&gt;</code>的形式，这样就可以将<code>Request</code>请求发往各个<code>node</code>了，这里的<code>Request</code>指kafka的各种协议请求，对于消息发送而言就是指具体的<code>producerRequest</code>，更多与kafka协议相关的内容后面章节再讨论。</p><p>请求从<code>Sender</code>线程发往kafka之前还会保存到<code>InFlightRequests</code>中，<code>InFlightRequests</code>保存对象的具体形式为<code>Map&lt;nodeId,Deque&lt;Request&gt;&gt;</code>，它的主要作用是缓存了已经发出去但还没收到响应的请求。<code>InFlightRequests</code>可以通过配置参数限制每个连接（客户端和kafka之间的连接）最多的缓存的请求数。默认值为5，即每个连接最多缓存5个未响应的请求，超过该数值之后就不能向这个连接发送更多的请求了，除非有缓存的请求收到了响应。通过比较<code>Deque&lt;Request&gt;</code>的<code>size</code>参数大小可以判断对应的<code>node</code>是否已经堆积了很多未响应的消息，如果堆积了很多，说明这个<code>node</code>节点负载比较大或者网络连接有问题，再继续对其发请求会增大超时的可能。</p><h2>六、元数据的更新</h2><p>我们使用如下的方式创建了一条消息<code>producerRecord</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">"hello, Kafka!"</span>);</span><br></pre></td></tr></table></figure><p>我们只知道主题的名称，对于其他的必要信息一无所知。<code>KafkaProducer</code>要将此消息追加到指定主题的某个分区所对应的<code>leader</code>副本之前，首先需要知道主题的分区数量，然后经过计算得到（或者直接指定）目标分区，之后<code>KafkaProducer</code>需要知道目标分区的<code>leader</code>副本所在的<code>broker</code>节点的地址、端口等信息才能建立连接，最终才能将消息发送到kafka。这一过程需要的信息属于元数据信息。</p><p>元数据是指Kafka集群中的元数据，这些元数据记录了集群中有哪些主题，这些主题有哪些分区，每个分区的<code>leader</code>副本分配在哪个节点上，<code>follwer</code>副本分配在哪些节点上，哪些副本在<code>AR</code>,<code>ISR</code>集合中，集群有哪些节点，控制节点又是哪一个等信息。</p><p>与此同时，我们知道<code>bootstrap.servers</code>参数只需要配置部分kafka节点的地址即可，不需要配置所有<code>broker</code>节点的地址，因为客户端可以自己发现其他<code>broker</code>节点的地址，这一过程属于元数据相关的更新操作；分区数量及<code>leader</code>副本的分布都会动态地变化，客户端需要动态捕捉这些变化。这里想说的是，在客户端的内部会进行元数据的更新操作（计算元数据都没变过，但是超过一段时间也会自动更新），当客户端需要更新元数据时，会挑选 <code>InFlightRequests</code> 中当前负载最小的节点发送更新元数据请求。</p><p>元数据虽然由<code>Sender</code>线程负责更新，但是主线程也需要读取这些信息，因此数据同步问题也要考虑，使用<code>synchronized</code>和<code>final</code>保证。</p><h2>七、重要的生产者参数</h2><ul><li><code>acks</code> : <strong>用来指定分区中必须要有多少个副本收到这条消息，这样生产者才认为消息写入成功</strong><ul><li>取值为1 : 只要<code>leader</code>副本成功写入消息，就会收到kafka的成功响应</li><li>取值为0： 不需要等待任何服务器响应，写入就认为成功</li><li>取值为-1或all：需要等待<code>ISR</code>中的所有副本都成功写入消息，才会收到kafka的成功响应</li></ul></li><li><code>max.request.size</code><ul><li>限制生产者客户端能发送消息最大值</li></ul></li><li><code>retires</code> 、<code>retry.backoff.ms</code><ul><li>配置生产者重试次数 、 两次重试的时间间隔</li></ul></li><li><code>max.in.flight.requests.per.connection</code><ul><li>默认值为5，即每个连接最多只能缓存5个未响应的请求。</li><li>当此参数 &gt; 1 ，则会因为重发而出现错序的问题</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/kafka1-15.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;在完成kafka的入门以及基本的操作之后，相信已经对kafka有了基本认识，下面我们一起从kafka的生产者开始，深入学习一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>SpringTask的基本使用</title>
    <link href="http://yoursite.com/2019/08/10/miscellany/19SpringTask%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/08/10/miscellany/19SpringTask的基本使用/</id>
    <published>2019-08-10T04:34:16.666Z</published>
    <updated>2019-08-10T04:35:03.049Z</updated>
    
    <content type="html"><![CDATA[<p>工作中经常会用到定时任务，有的用<code>linux</code>的<code>crontab</code>来实现系统级别的定时调用，当然这种只能调用脚本，不能在我们的程序中实现高度灵活的配置。定时任务的实现有很多，我之前也做过一些笔记，因为在分布式应用中，定时需要小心处理，否则会很容易地出现数据错乱，因此出现了很多适用于分布式场景定时器。当然分布式不在本文讨论范围，这里只想聊聊简单的单机应用，而且是最简单的<code>Spring Task</code>。</p><img src="http://bloghello.oursnail.cn/suibi4-1.png" width="300"><a id="more"></a><h2>一、基本使用</h2><p>使用起来十分简单，在ssm的工程中不需要额外引入其他的依赖即可使用。因为已经在<code>Spring-Context</code>中集成。</p><p><img src="http://bloghello.oursnail.cn/suibi4-2.png" alt="image"></p><p>第一步是配置文件中开启定时任务的注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入spring task定时任务--&gt;</span><br><span class="line">&lt;task:annotation-driven/&gt;</span><br></pre></td></tr></table></figure><p>在头部引入相应的DTD约束文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task=&quot;http://www.springframework.org/schema/task&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/task</span><br><span class="line">http://www.springframework.org/schema/task/spring-task-3.0.xsd</span><br></pre></td></tr></table></figure><p>配置方面就结束了。</p><p>下面写一个定时任务吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔一分钟从数据库读取一下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 0/1 * * * ? "</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getIntervalFromDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"一分钟执行一次~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这里的<code>cron</code>表达式，相信大家都知道了，按照一定的匹配规则即可实现比较复杂的定时场景。当然，可以使用可视化的页面来配置：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p><h2>二、另一种实现：Timer</h2><p>在这个最简单的应用中，就是实现每隔几分钟来做一些事情的简单场景，还可以使用JDK自带的<code>Timer</code>来实现。下面给出一个最简单的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// scheduledExecutionTime() 返回此任务最近开始执行的时间</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date(<span class="keyword">this</span>.scheduledExecutionTime());</span><br><span class="line">        System.out.println(<span class="string">"timeTask run "</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从现在开始每间隔 1000 ms 计划执行一个任务</span></span><br><span class="line">timer.schedule(timerTask, <span class="number">0</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><code>Timer</code> 可以按计划执行重复的任务或者定时执行指定任务，这是因为 <code>Timer</code> 内部利用了一个后台线程 <code>TimerThread</code> 有计划地执行指定任务。</p><ul><li><code>Timer</code>：是一个实用工具类，该类用来调度一个线程(<code>schedule a thread</code>)，使它可以在将来某一时刻执行。 <code>Java</code> 的 <code>Timer</code> 类可以调度一个任务运行一次或定期循环运行。 <code>Timer tasks should complete quickly.</code> 即定时器中的操作要尽可能花费短的时间。</li><li><code>TimerTask</code>：一个抽象类，它实现了 <code>Runnable</code> 接口。我们需要扩展该类以便创建自己的 <code>TimerTask</code> ，这个 <code>TimerTask</code> 可以被 <code>Timer</code> 调度。</li></ul><p>内部的实现原理还是有点意思的，后面有时间来扒一扒它的实现原理。既然Timer这么简单为什么我不用呢？当然了，在这里我觉得<code>Spring Task</code>更简单。</p><h2>三、Timer存在的问题</h2><p>有一个显著问题是：<code>Timer</code>在执行定时任务时只会创建一个线程，所以如果存在多个任务（task1和task2），且任务时间过长，超过了两个任务的间隔时间，那么就不再那么准时了。因为只有一个线程，线程需要排队，前面一个线程未及时执行完毕，势必会影响后续的任务执行。</p><p>第二个问题是：如果<code>TimerTask</code>抛出<code>RuntimeException</code>，<code>Timer</code>会停止所有任务的运行。</p><p>如果不引入Spring如何解决上述问题呢？这个时候<code>ScheduledExecutorService</code>闪亮登场，利用线程池来调度任务，不会出现一个任务延迟导致第二个任务无法准时执行的问题，并且在<code>ScheduledExecutorService</code>调度两个任务的时候，其中一个任务抛出异常不影响第二个任务的正常执行。</p><p>具体的对比可以参见文章<a href="https://blog.csdn.net/lmj623565791/article/details/27109467" target="_blank" rel="noopener">Java 并发专题 ： Timer的缺陷 用ScheduledExecutorService替代</a></p><p>因此，尽量避免使用<code>Timer</code>要成为我们的共识啦。优秀的那么多，何必用这个呢？</p><p>当然，还有开源的定时器可以使用，功能更加强大，整合也不难。比如<code>quartz</code>和为分布式而生的<code>Elastic-Job</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中经常会用到定时任务，有的用&lt;code&gt;linux&lt;/code&gt;的&lt;code&gt;crontab&lt;/code&gt;来实现系统级别的定时调用，当然这种只能调用脚本，不能在我们的程序中实现高度灵活的配置。定时任务的实现有很多，我之前也做过一些笔记，因为在分布式应用中，定时需要小心处理，否则会很容易地出现数据错乱，因此出现了很多适用于分布式场景定时器。当然分布式不在本文讨论范围，这里只想聊聊简单的单机应用，而且是最简单的&lt;code&gt;Spring Task&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;http://bloghello.oursnail.cn/suibi4-1.png&quot; width=&quot;300&quot;&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>03linux下玩kafka</title>
    <link href="http://yoursite.com/2019/08/05/kafka/03linux%E4%B8%8B%E7%8E%A9kafka/"/>
    <id>http://yoursite.com/2019/08/05/kafka/03linux下玩kafka/</id>
    <published>2019-08-05T14:17:00.071Z</published>
    <updated>2019-08-27T11:58:04.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bloghello.oursnail.cn/kafka1-15.jpg" alt="image"></p><p>为了方便对<a href="https://github.com/sunweiguo/SpringBoot-pratice" target="_blank" rel="noopener">实习生小课题</a>中kafka方便调试，我决定在自己的腾讯云服务器上部署一个单机kafka，其实跟本地windows没啥区别，不过还是做一下记录吧。服务器环境是centod7.3。</p><a id="more"></a><h2>第一步-安装JDK</h2><p>安装jdk1.8或以上版本。由于现在下载jdk都需要先注册，<strong>而注册内容令人不适</strong>，所以这里贴出一个我的百度云下载地址，方便大家使用，包含了exe和tar两个版本。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1Yb7s1hFJ2FvqVs1lH6E7WQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1Yb7s1hFJ2FvqVs1lH6E7WQ</a></p></blockquote><blockquote><p>提取码：3chj</p></blockquote><p>具体安装可以参考我之前写过的笔记：</p><ul><li><a href="http://note.youdao.com/noteshare?id=1f381a88b65ec929aeabe5d4f1e19410&amp;sub=9498380F23CC43EC8157E02937BD7032" target="_blank" rel="noopener">基于virtualbox+centos6.9的服务器搭建</a></li><li><a href="http://note.youdao.com/noteshare?id=9c306f8357a166d2fb7ee896536876e8&amp;sub=AB01BCDCCB03439B9436A6B2F57D1202" target="_blank" rel="noopener">阿里云centos7.3部署本项目</a></li></ul><h2>第二步-安装kafka</h2><blockquote><p>1.解压：tar -zxvf kafka_2.12-2.2.0.tgz</p><p>2.修改 kafka-server 的配置文件：</p><p>-----2.1 vim /usr/local/kafka/config/server.properties</p><p>-----2.2 broker.id=1</p><p>-----2.3 log.dir=/data/kafka/logs-1</p><p>3.来到bin目录下，后台启动ZK：./zookeeper-server-start.sh -daemon …/config/zookeeper.properties</p><p>4.后台启动KAFKA：./kafka-server-start.sh -daemon …/config/server.properties</p><p>5.创建topic：./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</p><p>6.查看topic列表：./kafka-topics.sh --list --zookeeper localhost:2181</p><p>7.启动生产者：./kafka-console-producer.sh --broker-list localhost:9092 --topic test</p><p>8.启动消费者：./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</p></blockquote><p>在服务器上搞一切OK，我们开放安全组对9092的端口，在本地试一把呢？结果报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: No entry found for connection 1</span><br></pre></td></tr></table></figure><p>解决方法是主机的kafka配置文件(<code>$KAFKA_HOME/config/server.properties</code>)中:添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advertised.listeners=PLAINTEXT://$IP_A:9092(默认这个key所在行是注释掉的)</span><br></pre></td></tr></table></figure><p>其中<code>$IP_A</code>可以是主机的<code>IP</code>或者<code>hostname</code>.</p><p>关于如何在windows下搞，请参考我的博客：<a href="https://sunweiguo.github.io/2019/06/13/kafka/03windows%E4%B8%8Bkafka%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">windows下kafka的基本使用</a></p><p>以上参考了博文：<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a>，不过我发现他有一点点错误，并且他遇到的问题我没遇到。我遇到的问题他可能也没尝试到^^。</p><p><img src="http://bloghello.oursnail.cn/kafka2-1.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/kafka1-15.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了方便对&lt;a href=&quot;https://github.com/sunweiguo/SpringBoot-pratice&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;实习生小课题&lt;/a&gt;中kafka方便调试，我决定在自己的腾讯云服务器上部署一个单机kafka，其实跟本地windows没啥区别，不过还是做一下记录吧。服务器环境是centod7.3。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>02windows下kafka的基本使用</title>
    <link href="http://yoursite.com/2019/06/13/kafka/02windows%E4%B8%8Bkafka%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/06/13/kafka/02windows下kafka的基本使用/</id>
    <published>2019-06-13T13:14:46.677Z</published>
    <updated>2019-08-27T11:57:57.870Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bloghello.oursnail.cn/kafka1-15.jpg" alt="image"></p><p>最近公司用kafka，本地需要测试测试，本地为windows环境，因此学习一下windows下对kafka的基本操作，便于代码的调试，也是作为知识的记录。</p><a id="more"></a><h2>环境准备</h2><ul><li>JDK8自行下载</li><li><a href="http://kafka.apache.org/downloads.html" target="_blank" rel="noopener">kafka下载</a>【我自己用的是以前下载的版本，为 kafka_2.11-2.1.0.tgz 这个版本，直接下载解压即可】</li></ul><h2>KafKA使用</h2><p>由于是windows环境，解压之后我们的注意点是<code>kafka_2.11-2.1.0\bin\windows</code>目录。</p><p><img src="http://bloghello.oursnail.cn/kafka3-1.jpg" alt="image"></p><h5>启动ZK</h5><p>在此目录下打开cmd，执行命令<code>zookeeper-server-start.bat ..\..\config\zookeeper.properties</code>，如下图表示启动成功：</p><p><img src="http://bloghello.oursnail.cn/kafka3-2.jpg" alt="image"></p><h5>启动KAFKA</h5><p>依旧在目录下打开cmd，执行命令<code>kafka-server-start.bat ..\..\config\server.properties</code>，如下图表示启动成功：</p><p><img src="http://bloghello.oursnail.cn/kafka3-3.jpg" alt="image"></p><h5>测试Kafka命令</h5><ul><li>创建一个主题</li></ul><blockquote><p>kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic TOPIC的名称</p></blockquote><ul><li>查看创建的主题列表</li></ul><blockquote><p>kafka-topics.bat --list --zookeeper localhost:2181</p></blockquote><p>我这里新建一个叫做<code>test</code>的topic作为实验。</p><p><img src="http://bloghello.oursnail.cn/kafka3-4.jpg" alt="image"></p><ul><li>启动生产者：</li></ul><blockquote><p>kafka-console-producer.bat --broker-list localhost:9092 --topic test</p></blockquote><ul><li>启动消费者：</li></ul><blockquote><p>kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning</p></blockquote><p>此时可以从控制台输入信息，待消费者即可接收到生产者发布的消息。</p><p><img src="http://bloghello.oursnail.cn/kafka3-5.jpg" alt="image"></p><p>至此，最基本的操作介绍完毕！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/kafka1-15.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近公司用kafka，本地需要测试测试，本地为windows环境，因此学习一下windows下对kafka的基本操作，便于代码的调试，也是作为知识的记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>01kafka入门</title>
    <link href="http://yoursite.com/2019/06/08/kafka/01kafka%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/06/08/kafka/01kafka入门/</id>
    <published>2019-06-08T14:24:50.804Z</published>
    <updated>2019-08-27T12:38:46.718Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://bloghello.oursnail.cn/kafka1-15.jpg" alt="image"></p><p>本系列博客主要以《深入理解kafka核心设计和实践原理》和《kafka权威指南》这两本书为基础深入学习kafka的使用和原理。</p><p>我们或多或少都听说过<code>kafka</code>，为了深入学习一下<code>kafka</code>，本文作为学习的第一篇文章，主要目标是搞清楚<code>kafka</code>的基本概念，因为<code>kafka</code>涉及一些专用名词，只有先了解这些名词，才有可能理解<code>kafka</code>的设计思想。</p><a id="more"></a><h2>一、为什么要学习kafka</h2><p>目前，<code>kafka</code>的定位是一个分布式流处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。截止到写本文的时间：2019年08月21号，已经到了2.3版本，<code>kafka</code>也成为后端程序猿或者大数据程序猿不可不学习的一个重要中间件。它有三大特点：</p><ul><li>消息系统</li></ul><p>市面上有很多的消息中间件，这些消息中间件的主要功能是：系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复等功能。但是<code>kafka</code>不仅包含这些内容，还提供大多数消息中间件不能实现的：<strong>消息顺序性保障和回溯消费等功能</strong>。</p><ul><li>存储系统</li></ul><p><code>Kafka</code><strong>支持消息的持久化</strong>，相比于其他内存存储系统有较高的保障性，并且提供多副本机制，避免某一台服务器挂掉而导致消息丢失。并且支持长期的数据存储，只需要将数据保存策略设置为永久或者启用主题的日志压缩功能即可。</p><ul><li>流式处理平台</li></ul><p><code>kafka</code>的定位日渐提高，它不是仅仅可以作为消息中间件，它的目标实际是为流式处理框架提供可靠的数据来源。还提供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作。</p><p>以上就是<code>kafka</code>与其他的消息中间件的区别（优势），下面来一起入门<code>kafka</code>的基本概念吧。</p><h2>二、kafka基本概念</h2><p>入门一个新的知识，首先需要知道它是啥，用来干啥，下面就是要知道它涉及的基本概念，才能为接下来的深入学习和使用打下良好基础，本文先来缕一缕最基本且最重要的概念。</p><p>一个典型的<code>kafka</code>架构包若干<code>Producer</code>、若干<code>Broker</code>、若干<code>Consumer</code>，以及一个<code>Zookeeper</code>集群。</p><p><img src="http://bloghello.oursnail.cn/kafka1-10.png" alt=""></p><p>有的小伙伴会问ZK在里面的角色是啥？为什么在玩<code>kafka</code>的时候需要先启动一个ZK？其实ZK在<code>kafka</code>中主要负责集群元数据的管理、控制器的选举等操作。关于什么是元数据，我这里简单说明一下:</p><p>元数据就是描述数据的数据。初次看到这个表述有点懵，其实简单来说，就像是手机或者电脑的参数，比如像素多少千万、处理器多少HZ等，这些数据都是用来描述手机的，整个参数合起来，我们大概就知道这个手机的配置如何。阮一峰的一篇<a href="http://www.ruanyifeng.com/blog/2007/03/metadata.html" target="_blank" rel="noopener">文章</a>说得可能详细一点，不妨去看看。</p><p>关于控制器的选举，可能难懂一点，会在后续的内容中说明。</p><p>回到上图，我们可以看到<code>kafka</code>的一个工作方式：<code>Producer</code>将消息发送到<code>Broker</code>中并持久化到磁盘，而<code>Consumer</code>负责从<code>Broker</code>订阅并消费消息。</p><p>注意，上面提到了三个专业名词：<code>Producer</code>,<code>Broker</code>以及<code>Consumer</code>。这个是三个最基本的术语，意义也很简单，下面一一阐述。</p><ol><li><code>Producer</code>即生产者，就是发送消息的一方，负责创建消息，然后投递到<code>kafka</code>。</li><li><code>Consumer</code>即消费者，就是接收消息的一方，负责连接到<code>kafka</code>上并接收消息。</li><li><code>Broker</code>即服务代理节点，<code>Broker</code>可以简单看作一个独立的<code>kafka</code>服务节点或者<code>kafka</code>服务实例，通常情况下，可以将<code>Broker</code>看作一台<code>Kakfa</code>服务器，前提是这个服务器上只部署了一个<code>kafka</code>，所以简单来说，<code>broker</code>就是一个<code>kafka</code>实例。</li></ol><p>在<code>kafka</code>中还有两个重要的概念：主题(<code>Topic</code>)和分区(<code>partition</code>)。</p><p><code>kafka</code>中的消息以主题为单位进行分类，生产者负责将消息发送到特定的主题下，消费者可以订阅相关的主题去消费。</p><p>主题是一个抽象的概念，可以细分为多个分区。他们的关系是：一个主题可以分为多个分区，一个分区只属于一个主题。那么分区是啥呢？</p><p>简单来说，就是这个主题的所有消息在物理上可以分为多块进行存储，这个块就可以理解为分区了。那么不难理解的是：每个分区上的消息不一样，所有分区的消息加起来就是一个主题的所有消息。</p><p>分区在存储层面可以看作是一个可追加的日志文件，消息在被追加到分区日志文件的时候就会分配一个特定的偏移量(<code>offset</code>)，这个玩意很重要，就是标识这个分区下某个消息的顺序，并且是这个消息的唯一标识。<strong>注意，<code>offset</code>不能跨越分区，即<code>kafka</code>保证的顺序性是在一个分区内所有消息的顺序性，而不是整个<code>topic</code>下所有消息的顺序性</strong>。</p><p><img src="http://bloghello.oursnail.cn/kafka1-11.png" alt=""></p><p>上图所示就是表示一个抽象概念的<code>topic</code>下的所有消息可以分为多个分区进行存储。每个分区的消息按照<code>offset</code>进行顺序追加存储。分区可以在不同的<code>broker</code>上，也就是说，<strong>一个<code>topic</code>下的数据可以分布在不同的服务器上，显而易见，这样做的好处是可以提高吞吐量，因为我可以起多个生产者/消费者去不同的分区消费，达到并行处理的效果</strong>。</p><p>分区个数可以在创建主题的时候指定，也可以在主题创建之后去修改分区的数量，注意分区的数量只能增加不能减少。</p><h2>三、副本机制</h2><p>上面介绍了最基本也是最重要的概念，概念相对来说比较清晰，下面来说说副本机制。<code>kafka</code>引入多副本机制，可以提高容灾能力。</p><p>同一分区的不同副本理论上保存是相同的消息（同一时刻，副本之间并非完全一样），副本之间是“一主多从”的关系，其中<code>leader</code>副本负责处理读写请求，而<code>follow</code>副本只负责与<code>leader</code>副本的消息同步。副本处于不同的<code>broker</code>中，而<code>leader</code>副本出现故障时，从<code>follow</code>副本中重新选举新的<code>leader</code>副本对外提供服务。<code>kafka</code>通过多副本机制实现了故障的自动转移，当<code>kafka</code>集群中某个<code>broker</code>失效时仍然能保证服务可用。</p><p>这里举个例子，<code>kafka</code>集群中有4个<code>broker</code>，某个主题有3个分区，假设副本因子时3，则每个分区便有一个<code>leader</code>副本和两个<code>follow</code>副本。<code>follow</code>副本中的消息相对<code>leader</code>副本中的消息有一定的滞后性。</p><p><img src="http://bloghello.oursnail.cn/kafka1-12.png" alt=""></p><p>当然，<code>kafak</code>的消费端也有容灾机制，当某个消费者宕机，只要记录了消费的<code>offset</code>，就可用从指定的<code>offset</code>处重新消费，不会造成消息的丢失。</p><p>分区中所有的副本统称为<code>AR</code>，所有与<code>leader</code>副本保持一定程度同步的副本组成<code>ISR</code>，<code>ISR</code>是<code>AR</code>的子集，消息会先发送到<code>leader</code>副本，然后<code>follow</code>副本才能从<code>leader</code>副本中拉取消息进行同步。与<code>leader</code>副本同步滞后过多的副本组成<code>OSR</code>，由此可见：<code>AR</code>=<code>ISR</code>+<code>OSR</code>。在正常情况下，所有的<code>follow</code>副本都应该与<code>leader</code>副本保持一定程度的同步，即<code>AR</code>=<code>ISR</code>，<code>OSR</code>集合为空。</p><p><code>leader</code>副本负责维护和跟踪<code>ISR</code>集合中所有<code>follow</code>副本的滞后状态，当<code>follow</code>副本落后太多或者失效时，<code>leader</code>副本会把它从<code>ISR</code>集合中剔除。如果<code>OSR</code>集合中有<code>follow</code>副本追上了<code>leader</code>副本，那么<code>leader</code>副本就会把它从<code>OSR</code>集合中转移到<code>ISR</code>集合中。</p><p>默认情况下，当<code>leader</code>副本发生故障时，只有在<code>ISR</code>集合中的副本才有资格被选举为新的<code>leader</code>，而在<code>OSR</code>集合中的副本原则上没有机会（除非修改相应的配置参数）。</p><p>此外，还有两个名词值得关注：</p><ul><li><code>HW</code>（<code>High WaterMark</code>）: 高水位， 用来标记一个特定的消息偏移量，消费者只能拉取到这个<code>offset</code>之前的消息（可见性）</li><li><code>LEO</code>( <code>Log End Offset</code>) : 标志着当前日志文件中下一条待写入消息的<code>offset</code> 。 <strong>分区<code>ISR</code>集合中的每个副本都维护自身的<code>LEO</code>，而<code>ISR</code>集合中的最小<code>LEO</code>为分区的<code>HW</code>，对消费者而言只能消费<code>HW</code>之前的消息</strong>。</li></ul><p>对此记住一点，<strong>这两个都是指最后一条的下一条的位置而不是指最后一条的位置</strong>。</p><p><img src="http://bloghello.oursnail.cn/kafka1-14.png" alt=""></p><p>当消息写入<code>leader</code>副本之后，<code>follow</code>副本会发送拉取请求来拉取消息以进行消息同步。在同步的过程中，不同的<code>follow</code>副本同步效率不尽相同，此时各个<code>follow</code>的<code>LEO</code>也就不一样，这个时候<code>HW</code>就是最小的<code>LEO</code>，那么消费者能消费到的消息就是这个<code>HW</code>之前的消息。</p><p>说白点就是，这种方式保证消费者消费到的是当前<code>follow</code>副本中同步最慢的那个消息，可以看出，<code>Kafka</code>的复制机制既不是完全的同步复制，也不是单纯的异步复制，同步复制要求所有能工作的<code>follow</code>副本都要复制完，这条消息才会被确认已成功提交，这种复制方式极大地影响了性能；异步复制方式下，<code>follow</code>副本异步地从<code>leader</code>副本中复制数据，数据只要被<code>leader</code>副本写入就认为已成功提交，这种方式下，如果<code>leader</code>副本突然宕机但是<code>follow</code>副本还没有复制完，则会造成数据丢失。<code>kafka</code>这种<code>ISR</code>的方式有效地权衡了数据可靠性和性能之间的关系。</p><p>下面介绍基本的使用，包括<code>topic</code>的查看、创建，生产者的启动以及消费者的启动等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/kafka1-15.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;本系列博客主要以《深入理解kafka核心设计和实践原理》和《kafka权威指南》这两本书为基础深入学习kafka的使用和原理。&lt;/p&gt;
&lt;p&gt;我们或多或少都听说过&lt;code&gt;kafka&lt;/code&gt;，为了深入学习一下&lt;code&gt;kafka&lt;/code&gt;，本文作为学习的第一篇文章，主要目标是搞清楚&lt;code&gt;kafka&lt;/code&gt;的基本概念，因为&lt;code&gt;kafka&lt;/code&gt;涉及一些专用名词，只有先了解这些名词，才有可能理解&lt;code&gt;kafka&lt;/code&gt;的设计思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>实现动态切换多数据源及其原理分析</title>
    <link href="http://yoursite.com/2019/05/23/miscellany/18.%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/23/miscellany/18.实现动态切换多数据源及其原理分析/</id>
    <published>2019-05-23T13:21:19.712Z</published>
    <updated>2019-05-23T14:00:47.457Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中可能会遇到多个库的连接，那么一个库就是一个数据源，在程序中如何快速动态地切换数据源呢？本文来探讨一下spring提供的AbstractRoutingDataSource实现方案。</p><a id="more"></a><h2>实现</h2><p>比如我有三个数据源，分别交<code>DATASOURCE_A</code>、<code>DATASOURCE_B</code>、<code>DATASOURCE_C</code>，我假设默认是<code>DATASOURCE_A</code>，此时我需要用B来查询，我理想的效果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要切换数据源</span></span><br><span class="line">CustomerContextHolder.setCustomerType(CustomerContextHolder.DATASOURCE_B);</span><br><span class="line"></span><br><span class="line">List&lt;xxx&gt; xxxList = xxxService.getList();</span><br><span class="line">System.out.println(<span class="string">"====xxxList："</span>+xxxList.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行以后需要清除，否则后续的请求是继续在切换后的数据源中</span></span><br><span class="line">CustomerContextHolder.clearCustomerType();</span><br></pre></td></tr></table></figure><p>当我想用C的时候，直接一样的套路，也就是说只需要两行代码就可以实现数据源的自由切换，如何达到这种效果呢？</p><p>首先，数据源的定义肯定是要有的，我在xml中定义三个数据源，即<code>dataSource</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一的dataSource --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dynamicDataSource"</span> <span class="attr">class</span>=<span class="string">"com.xxx.DynamicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetDataSources"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--通过不同的key决定用哪个dataSource --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">"dataSource_A"</span> <span class="attr">key</span>=<span class="string">"dataSource_A"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">"dataSource_B"</span> <span class="attr">key</span>=<span class="string">"dataSource_B"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">"dataSource_C"</span> <span class="attr">key</span>=<span class="string">"dataSource_C"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置默认的dataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultTargetDataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource_A"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 1. 数据源 : dataSource_A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource_A"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://ip:port/db_A?useUnicode=true&amp;amp;characterEncoding=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 初始化连接大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"120"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大空闲 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最小空闲 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 获取连接最大等待时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"60000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 2. 数据源 : dataSource_B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource_B"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://ip:port/db_B?useUnicode=true&amp;amp;characterEncoding=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 初始化连接大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"120"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大空闲 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最小空闲 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 获取连接最大等待时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"60000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3. 数据源 : dataSource_B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource_C"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://ip:port/db_C?useUnicode=true&amp;amp;characterEncoding=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 初始化连接大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"120"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大空闲 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"30"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最小空闲 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 获取连接最大等待时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"60000"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注入dynamicDataSource即动态数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dynamicDataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他的配置文件全部略。此时我需要新建一个类去继承<code>AbstractRoutingDataSource</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CustomerContextHolder.getCustomerType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我就可以根据这个返回值即key来找到对应的数据源。这里用到了<code>ThreadLocal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerContextHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_SOURCE_A = <span class="string">"dataSource_A"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_SOURCE_B = <span class="string">"dataSource_B"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_SOURCE_C = <span class="string">"dataSource_C"</span>;</span><br><span class="line"><span class="comment">// 用ThreadLocal来设置当前线程使用哪个dataSource</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; contextHolder = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置数据源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCustomerType</span><span class="params">(String customerType)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"=========切换数据源："</span>+customerType);</span><br><span class="line">contextHolder.set(customerType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCustomerType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String dataSource = contextHolder.get();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(dataSource)) &#123;</span><br><span class="line">    <span class="comment">//默认数据源</span></span><br><span class="line"><span class="keyword">return</span> DATA_SOURCE_A;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除数据源，防止内存泄漏</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearCustomerType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">contextHolder.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，动态在多数据源中切换功能完成。问题是我为什么重写了<code>determineCurrentLookupKey()</code>就可以切换数据源了呢？</p><h2>原理</h2><p>多数据源还是比较头疼的，因为我们自己玩往往都是一个数据源，比如<code>spring</code>和<code>mybatis</code>结合的项目，我们在<code>spring</code>配置中往往是配置一个<code>dataSource</code>来连接数据库，然后绑定给<code>sessionFactory</code>，在<code>dao</code>层代码中再指定<code>sessionFactory</code>来进行数据库操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataSource ---&gt; sessionFactory ---&gt; dao层实现类</span><br></pre></td></tr></table></figure><p>这是单数据源<code>dataSource</code>结构，但是缺点很明显，不支持多个数据源，于是我们再改进一下，让它支持多数据源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataSource1 ---&gt; sessionFactory1 ---&gt;</span><br><span class="line">                                     ---&gt; dao层实现</span><br><span class="line">dataSource2 ---&gt; sessionFactory2 ---&gt;</span><br></pre></td></tr></table></figure><p>这种结构实现了多数据源，但是缺点也很明显，具有多个<code>SessionFactory</code>，不具有灵活性，而且太笨重了。如果再加一个数据源，就需要再加一个<code>SessionFactory</code>。</p><p>顾名思义，<code>SessionFactory</code>，就是用来创建<code>session</code>会话的工厂。如果存在多个<code>Sessionfactory</code> 那么<code>Session</code>是不是就乱套了，因此这种架构不可取。那么下面这种架构就应用而生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataSource1 ---&gt; </span><br><span class="line">                ---&gt; dynamicDataSource ---&gt; sessionFactory --&gt; dao层实现</span><br><span class="line">dataSource2 ---&gt;</span><br></pre></td></tr></table></figure><p><code>Spring</code>的<code>AbstractRoutingDataSource</code>就是采用这种架构。</p><p><code>AbstractRoutingDataSource</code> 的设计源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展<code>Spring</code>的<code>AbstractRoutingDataSource</code>抽象类（该类充当了<code>DataSource</code>的路由中介, 能有在运行时, 根据某种<code>key</code>值来动态切换到真正的<code>DataSource</code>上。）</p><p>从上可以看出它继承了<code>AbstractDataSource</code>，而<code>AbstractDataSource</code>不就是<code>javax.sql.DataSource</code>的子类吗，So我们可以分析下它的<code>getConnection</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;       </span><br><span class="line">    <span class="keyword">return</span> determineTargetDataSource().getConnection();   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span>  <span class="keyword">throws</span> SQLException </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> determineTargetDataSource().getConnection(username, password);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取连接的方法中，重点是<code>determineTargetDataSource</code>方法，看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">Object lookupKey = determineCurrentLookupKey();</span><br><span class="line">DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line"><span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段源码的重点在于<code>determineCurrentLookupKey()</code>方法，这是<code>AbstractRoutingDataSource</code>类中的一个抽象方法，而它的返回值是你所要用的数据源<code>dataSource</code>的<code>key</code>值，有了这个<code>key</code>值，<code>resolvedDataSource</code>（这是个map,由配置文件中设置好后存入的）就从中取出对应的<code>DataSource</code>，如果找不到，就用配置默认的数据源。</p><p>因此我们需要重写<code>AbstractRoutingDataSource</code>类的抽象方法<code>determineCurrentLookupKey()</code>，这样就可以实现数据源的动态切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CustomerContextHolder.getCustomerType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中可能会遇到多个库的连接，那么一个库就是一个数据源，在程序中如何快速动态地切换数据源呢？本文来探讨一下spring提供的AbstractRoutingDataSource实现方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
</feed>
