<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-13T05:43:42.627Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01-UML(统一建模语言)</title>
    <link href="http://yoursite.com/2019/03/13/design-pattern/01-UML(%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80)/"/>
    <id>http://yoursite.com/2019/03/13/design-pattern/01-UML(统一建模语言)/</id>
    <published>2019-03-13T05:36:51.688Z</published>
    <updated>2019-03-13T05:43:42.627Z</updated>
    
    <content type="html"><![CDATA[<p>在开始系统学习设计模式之前，先学习一下UML类图的表示方法，在阅读各种源码的时候，要想快速摸清框架结构的话，一个好的方式就是查看它的类图，了解里面的骨架，找到核心开始攻克。本文来极速入门UML类图。</p><a id="more"></a><h2>一、什么是UML类图</h2><p>用于表示类、接口、实例等之间相互的静态关系</p><h2>二、箭头方向的含义</h2><p>一般情况下是从子指向父。</p><h2>三、继承和实现</h2><p>典型的特征是<strong>空心三角箭头</strong>。其中，实线代表继承父类，虚线代表实现接口。关于继承和实现，我们都太熟悉了，就不再赘述了。</p><p><img src="http://bloghello.oursnail.cn/pattern1-1.png" alt="image"></p><h2>四、聚合和组合</h2><p>典型特征是<strong>菱形箭头</strong>。聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上。</p><p><img src="http://bloghello.oursnail.cn/pattern1-2.png" alt="image"></p><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成。</p><p><img src="http://bloghello.oursnail.cn/pattern1-3.png" alt="image"></p><p>我们一定要注意区分它们两者，首先说明一下，组合的依赖关系强于聚合。我们可以将聚合关系理解为：整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><p>我们可以将组合关系理解为：组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><p>聚合可以这样说：大雁聚合成大雁群；组合可以这样说：鸟儿与翅膀，两者生死与共。</p><p>之间依赖关系强则用实心菱形。</p><p>关于组合关系中常见的数字表达含义，假设有A类和B类，数字标记在A类侧,表明系统在某一时刻，B的实例可以与A的xx个实例相关：</p><ul><li><code>0..1</code>    0或1个实例</li><li><code>0..*</code>    0或多个实例</li><li><code>1..1</code>    1个实例</li><li><code>1</code>       只能由一个实例</li><li><code>1..*</code>    至少有一个实例</li></ul><h2>五、关联和依赖</h2><p>是一个<strong>普通箭头</strong>。关联关系是用一条实线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；注意，强调的是一种天然的静态关系，是不可改变的固有关系，所以是实线。</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；</p><p>在代码中，关联对象通常是以成员变量的形式实现的；</p><p><img src="http://bloghello.oursnail.cn/pattern1-4.png" alt="image"></p><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><p><img src="http://bloghello.oursnail.cn/pattern1-5.png" alt="image"></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p>在代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还可以“使用”对方的方法和属性；</p><h2>六、一个类如何表示？</h2><p><img src="http://bloghello.oursnail.cn/uml1-2.png" alt="image"></p><h2>七、从整体来看一张UML类图</h2><p><img src="http://bloghello.oursnail.cn/uml1-3.png" alt="image"></p><p>我们看到，氧气和水都是以参数的形式传递进来，所以是变化的，因此是依赖关系，因此是带箭头的虚线。</p><p>鸟和翅膀不可分割，因此是组合关系，因此是实心菱形。</p><p>大雁聚合成大雁群，就像盘子盛放东西一样，是一种聚合关系，因此是空心菱形。</p><p>企鹅需要严寒的气候，这是天然的关系，企鹅不会突然说我想去非洲，因为它适应不了，所以这种天然的关系是关联关系，因此是带箭头的实线。</p><p>鸟是动物的子类，因此是空心三角实线。</p><p>大雁会飞，所以可以实线飞翔的接口，因此是空心三角虚线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开始系统学习设计模式之前，先学习一下UML类图的表示方法，在阅读各种源码的时候，要想快速摸清框架结构的话，一个好的方式就是查看它的类图，了解里面的骨架，找到核心开始攻克。本文来极速入门UML类图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题50-数组中的重复数字】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9850-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题50-数组中的重复数字】/</id>
    <published>2019-03-13T04:21:38.825Z</published>
    <updated>2019-03-13T04:21:59.717Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十题。</p><a id="more"></a><h2>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2>解题思路</h2><p>比较好想的是用一个map来存储和判断。</p><p>但是吧这个问题确实是可以不用额外的O(n)的空间，不过理解上就会难一点，所以还是用map来解决吧。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(numbers[i]))&#123;</span><br><span class="line">            map.put(numbers[i],<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(numbers[i],map.get(numbers[i])+<span class="number">1</span>);</span><br><span class="line">            duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题49-把字符串转换成整数】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9849-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题49-把字符串转换成整数】/</id>
    <published>2019-03-13T04:21:05.834Z</published>
    <updated>2019-03-13T04:29:25.133Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十九题。</p><a id="more"></a><h2>题目描述</h2><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><h2>解题思路</h2><p>主要就是处理一下符号位，以及判断是否有非法字符，最后转换为整数即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(str.trim().length() == <span class="number">0</span> || <span class="keyword">null</span> == str)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.只有一个元素的情况</span></span><br><span class="line">        <span class="keyword">if</span>(str.trim().length() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.toCharArray()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> c-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不是数字的话，那肯定是非法的了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.下面长度都大于1，先拿到首位的符号看是不是负数，是的话记录一下</span></span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span> isMinus = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            isMinus = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.逐个判断，合法则拼接为一个整数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i &lt; ch.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; (ch[i] == <span class="string">'+'</span> || ch[i] == <span class="string">'-'</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch[i] &lt; <span class="string">'0'</span> || ch[i] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = <span class="number">10</span> * res + (ch[i]-<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isMinus ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题48-不用加减乘除做加法】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9848-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题48-不用加减乘除做加法】/</id>
    <published>2019-03-13T04:20:28.729Z</published>
    <updated>2019-03-13T04:20:53.930Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十八题。</p><a id="more"></a><h2>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h2>解题思路</h2><p>首先看十进制是如何做的： 5+7=12，三步走：</p><p>第一步：相加各位的值，不算进位，得到2。</p><p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p><p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p><p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。</p><p>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1 ^ num2;</span><br><span class="line">            num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题47-求1+2+3+...+n】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9847-%E6%B1%821+2+3+...+n%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题47-求1+2+3+...+n】/</id>
    <published>2019-03-13T04:19:57.090Z</published>
    <updated>2019-03-13T04:20:15.663Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十七题。</p><a id="more"></a><h2>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h2>解题思路</h2><p>这道题目确实不大好想，是一个蛋疼的问题，看了看答案，才知道用<code>&amp;&amp;</code>和递归来实现。对递归熟悉的话，这个程序就非常好理解了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="comment">//利用&amp;&amp;的短路特性</span></span><br><span class="line">        <span class="comment">//n=0的时候，停止递归，否则一直加</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = (sum&gt;<span class="number">0</span>) &amp;&amp; ((sum+=Sum_Solution(--n))&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题46-孩子们的游戏】</title>
    <link href="http://yoursite.com/2019/03/13/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9846-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/13/剑指offer/【面试题46-孩子们的游戏】/</id>
    <published>2019-03-13T04:19:20.781Z</published>
    <updated>2019-03-13T04:19:42.753Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十六题。</p><a id="more"></a><h2>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数…这样下去…直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!<sup>_</sup>)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><h2>解题思路</h2><p>这道题目可以用<code>LinkedList</code>来模拟这个环，只需要每次找到的第m-1编号的小朋友（注意，由于是环，所以需要余上小朋友的数量），找到了之后就剔除，不断地循环，直到还剩一个。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            index = (index + m - <span class="number">1</span>)% list.size();</span><br><span class="line">            list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list.size() == <span class="number">1</span> ? list.get(<span class="number">0</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Git基本原理</title>
    <link href="http://yoursite.com/2019/03/12/miscellany/16git%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/12/miscellany/16git基本原理/</id>
    <published>2019-03-12T09:18:22.158Z</published>
    <updated>2019-03-12T11:25:52.657Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们对git并不陌生，全球最大的同性交友网站github是程序猿们的最爱，这里只有你想不到的，没有你找不到的，各种资源应有尽有，免去了从浏览器中找到若干垃圾的麻烦。因此熟悉git也成为程序猿标配，本文来简单说说git的基本操作和基本原理。</p><a id="more"></a><h2>一、Git工作流程</h2><p><img src="http://bloghello.oursnail.cn/zaji17-1.png" alt="image"></p><p>这四个区域的名字如下:</p><ul><li>Workspace：工作区</li></ul><blockquote><p>程序员进行开发改动的地方，是你当前看到的，也是最新的。平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。</p></blockquote><ul><li>Index / Stage：暂存区</li></ul><blockquote><p><code>.git</code>目录下的<code>index</code>文件, 暂存区会记录<code>git add</code>添加文件的相关信息(文件名、大小、<code>timestamp</code>…)，不保存文件实体, 通过id指向每个文件实体。</p><p>可以使用<code>git status</code>查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。<br>当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过<code>git add</code>先提交到暂存区，被git管理。</p></blockquote><ul><li>Repository：仓库区（或本地仓库）</li></ul><blockquote><p><code>git commit</code>后同步<code>index</code>的目录树到本地仓库，方便从下一步通过<code>git push</code>同步本地仓库与远程仓库的同步。</p></blockquote><ul><li>Remote：远程仓库</li></ul><blockquote><p>远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p></blockquote><p><strong>总结一下：</strong></p><ul><li>任何对象都是在工作区中诞生和被修改；</li><li>任何修改都是从进入<code>index</code>区才开始被版本控制；</li><li>只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；</li><li>与协作者分享本地的修改，可以把它们<code>push</code>到远程仓库来共享。</li></ul><p>下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。</p><p><img src="http://bloghello.oursnail.cn/zaji17-2.png" alt="image"></p><h2>二、常用git命令</h2><p><img src="http://bloghello.oursnail.cn/zaji17-3.png" alt="image"></p><p>看不清可以拖动图片到新的页面打开。我们从关键字入手git常用命令。</p><h2>2.1 HEAD</h2><p><code>HEAD</code>，它始终指向当前所处分支的最新的提交(commit)点。你所处的分支变化了，或者产生了新的提交点，<code>HEAD</code>就会跟着改变。</p><p><img src="http://bloghello.oursnail.cn/zaji17-4.png" alt="image"></p><h2>2.2 add和commit</h2><p><img src="http://bloghello.oursnail.cn/zaji17-5.png" alt="image"></p><p><code>add</code>相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git add .</td><td>添加当前目录的所有文件到暂存区</td></tr><tr><td>git add [dir]</td><td>添加指定目录到暂存区，包括子目录</td></tr><tr><td>git add [file]</td><td>添加指定文件到暂存区</td></tr></tbody></table><p><code>commit</code>相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的<code>HEAD</code>向后移动一个提交点。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git commit -m [message]</td><td>提交暂存区到本地仓库，message代表说明信息</td></tr><tr><td>git commit [file] -m [message]</td><td>提交暂存区的指定文件到本地仓库</td></tr><tr><td>git commit --amend -m [message]</td><td>使用一次新的commit，替代上一次提交</td></tr></tbody></table><h2>2.3 branch</h2><p><img src="http://bloghello.oursnail.cn/zaji17-8.png" alt="image"></p><p>涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git branch</td><td>列出所有本地分支</td></tr><tr><td>git branch -r</td><td>列出所有远程分支</td></tr><tr><td>git branch -a</td><td>列出所有本地分支和远程分支</td></tr><tr><td>git branch [branch-name]</td><td>新建一个分支，但依然停留在当前分支</td></tr><tr><td>git branch -b [branch-name]</td><td>新建一个分支，并切换到该分支</td></tr><tr><td>git branch --track [branch] remote-branch[]</td><td>新建一个分支，与指定的远程分支建立追踪关系</td></tr><tr><td>git checkout [branch-name]</td><td>切换到指定分支，并更新工作区</td></tr><tr><td>git branch -d [branch-name]</td><td>删除分支</td></tr><tr><td>git push origin --delete [branch-name]</td><td>删除远程分支</td></tr></tbody></table><h2>2.4 merge</h2><p><img src="http://bloghello.oursnail.cn/zaji17-10.png" alt="image"></p><p><code>merge</code>命令把不同的分支合并起来。如上图，在实际开放中，我们可能从<code>master</code>分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的<code>commit</code>记录，最后开发完成需要合入<code>master</code>中，这便用到了<code>merge</code>。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git fetch [remote]</td><td>merge之前先拉一下远程仓库最新代码</td></tr><tr><td>git merge [branch]</td><td>合并指定分支到当前分支</td></tr></tbody></table><p>一般在<code>merge</code>之后，会出现<code>conflict</code>，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。</p><p>就是说同一个代码两个人都进行了修改，那么必然需要通过人工的沟通协调最终选择一个统一的版本。</p><h2>2.5 reset</h2><p><img src="http://bloghello.oursnail.cn/zaji17-12.png" alt="image"></p><p>reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git reset --soft [commit]</td><td>只改变提交点，暂存区和工作区的内容都不改变</td></tr><tr><td>git reset --mixed [commit]</td><td>改变提交点，同时改变暂存区的内容</td></tr><tr><td>git reset --hard [commit]</td><td>暂存区和工作区的内容都会被修改到与提交点完全一致的状态</td></tr><tr><td>git reset --hard HEAD</td><td>让工作区回到上次提交的状态</td></tr></tbody></table><p>还有一个叫做<code>git revert</code>,与<code>git reset</code>的区别是：</p><p><img src="http://bloghello.oursnail.cn/zaji17-14.png" alt="image"></p><p><code>git reset</code> 是把<code>HEAD</code>向后移动了一下，而<code>git revert</code>是<code>HEAD</code>继续前进，只是新的<code>commit</code>的内容和要<code>revert</code>的内容正好相反，能够抵消要被<code>revert</code>的内容。</p><h5>2.6 push</h5><p>上传本地仓库分支到远程仓库分支，实现同步。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git push [remote] [branch]</td><td>上传本地指定分支到远程仓库</td></tr><tr><td>git push [remote] --force</td><td>强行推送当前分支到远程仓库，即使有冲突</td></tr><tr><td>git push [remote] --all</td><td>推送所有分支到远程仓库</td></tr></tbody></table><h2>2.7 其他命令</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>git status</td><td>显示有变更的文件</td></tr><tr><td>git log</td><td>显示当前分支的版本历史</td></tr><tr><td>git diff</td><td>显示暂存区和工作区的差异</td></tr><tr><td>git diff HEAD</td><td>显示工作区与当前分支最新commit之间的差异</td></tr><tr><td>git cherry-pick [commit]</td><td>选择一个commit合并进当前分支</td></tr></tbody></table><p>整理自：<a href="https://mp.weixin.qq.com/s?__biz=MzUwOTQ1NTAzNA==&amp;mid=2247483714&amp;idx=2&amp;sn=a7893d7306025dc35ca0fb2678003795&amp;chksm=f910be97ce673781f259bb353b3802818eb64e2cb9b06390290374c3d95d139f32d8acb710e8&amp;mpshare=1&amp;scene=1&amp;srcid=1220thpAb37YI9AJFiDH0rMA#rd" target="_blank" rel="noopener">一篇文章让你读懂Git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们对git并不陌生，全球最大的同性交友网站github是程序猿们的最爱，这里只有你想不到的，没有你找不到的，各种资源应有尽有，免去了从浏览器中找到若干垃圾的麻烦。因此熟悉git也成为程序猿标配，本文来简单说说git的基本操作和基本原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(下)</title>
    <link href="http://yoursite.com/2019/03/12/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(%E4%B8%8B)/"/>
    <id>http://yoursite.com/2019/03/12/design-pattern/单例模式(下)/</id>
    <published>2019-03-12T05:54:29.390Z</published>
    <updated>2019-03-12T05:59:06.727Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中简单介绍了几种单例模式的实现，并且简单处理了一下如何抗反序列化，但是路漫漫，反射攻击等还在等着我们，本文深入探讨反射攻击以及枚举单例是如何实现完美单例的。</p><a id="more"></a><h2>一、反射攻击</h2><p>还是以饿汉模式实现的单例模式类来实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法忽略，跟本章无关</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Class objectClass = HungrySingleton.class;</span><br><span class="line">        Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//普通获取的对象</span></span><br><span class="line">        HungrySingleton instance = HungrySingleton.getGetInstance();</span><br><span class="line">        <span class="comment">//根据构造器反射构建的对象</span></span><br><span class="line">        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance == newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，就是通过反射拿到这个类的私有构造器，然后利用这个构造器去创建这个类的对象。运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@1540e19d</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@677327b6</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>那么可以进行反射的一些防御，因为是饿汉，在类加载之后就已经创建好实例对象了，所以我们可以在构造器种进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射调用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: 单例构造器禁止反射调用</span><br></pre></td></tr></table></figure><p>对于声明静态属性或者用静态内部类的这两种方式，因为类加载的时候，实例就会生成好，所以可以用这种方式进行防御。但是对于不是在类加载时期就加载类对象的模式，就不一定行了，跟具体的时序有关（主要看在反射创建对象的时候是不是已经存在了实例对象）。</p><p>即使添加复杂逻辑，比如用标记位来判断等手段都是不行的，因为反射的威力不仅可以修改构造器，还可以修改一个类的属性，所以是没有意义的。</p><h2>二、Enum枚举单例</h2><p>为了解决反射攻击以及序列化反序列化问题，推荐适用枚举单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumInstance &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其进行序列化和反序列化测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        EnumInstance instance = EnumInstance.getInstance();</span><br><span class="line">        instance.setData(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singletonFile"</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"singletonFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        <span class="comment">//获取反序列化后的对象</span></span><br><span class="line">        EnumInstance newInstance = (EnumInstance) ois.readObject();</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(instance.getData());</span><br><span class="line">        System.out.println(newInstance.getData());</span><br><span class="line">        System.out.println(instance.getData() == newInstance.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@378bf509</span><br><span class="line">java.lang.Object@378bf509</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>原理是：还是要看<code>ObjectInputStream</code>对枚举是如何处理的，我们循着这个路径：</p><p>点开<code>(EnumInstance) ois.readObject();</code>中的<code>readObject()</code>方法，显示：</p><p><img src="http://bloghello.oursnail.cn/pattern14-1.png" alt="image"></p><p>点进去，找到枚举这一个类型：</p><p><img src="http://bloghello.oursnail.cn/pattern14-2.png" alt="image"></p><p>点进<code>readEnum</code>这个方法：</p><p><img src="http://bloghello.oursnail.cn/pattern14-3.png" alt="image"></p><p>我们看到是根据枚举的名字来生成枚举对象的，枚举的名字是唯一的，所以反序列化后还是原来的那个对象实例。解决了序列化和反序列化的问题。下面来看看是如何防止反射攻击的：</p><p>我们还是跟以前一样去获取枚举的构造器试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance.class;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>获取构造器的时候直接抛出异常了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br></pre></td></tr></table></figure><p>为什么获取不到枚举的无参构造器呢？</p><p>我们进入Enum源码，发现里面只有一个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就拿这个有参构造器去尝试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance.class;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">EnumInstance instance = (EnumInstance) constructor.newInstance(<span class="string">"swg"</span>,<span class="number">666</span>);</span><br></pre></td></tr></table></figure><p>但是我们会发现，根据构造器去创建实例对象的时候报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br></pre></td></tr></table></figure><p>报错信息说，不能反射创建枚举对象。原因是：</p><p><img src="http://bloghello.oursnail.cn/pattern14-4.png" alt="image"></p><p>判断如果是枚举类型，就抛出这个异常。ok，这里就解决了反射攻击。</p><p>经过jad反编译之后，我们可以看到这个枚举类是一个final类型，表明不能被继承；构造器私有，不能被new，最重要的是，针对我们创建的实例：</p><p><img src="http://bloghello.oursnail.cn/pattern14-5.png" alt="image"></p><p>说明是在类加载的时候就去创建了，类似于饿汉模式。</p><h2>三、容器单例</h2><p>容器启动的时候，可以将一些单例实例放进map中来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInstance</span><span class="params">(String key,Object instance)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断key不为空，instance也不为空</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            map.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在问题，多线程情况下，两个线程t1和t2，t1线程先塞入一个&lt;“key”,1&gt;，此时t2进来，立即塞入同样的&lt;“key”,2&gt;，那么此时t2返回2,t1也会返回1，造成了数据的混乱。</p><h2>四、ThreadLocal</h2><p>本地线程，是线程隔离的，保证一个线程的实例唯一。</p><p>这属于带引号的单例模式，不赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中简单介绍了几种单例模式的实现，并且简单处理了一下如何抗反序列化，但是路漫漫，反射攻击等还在等着我们，本文深入探讨反射攻击以及枚举单例是如何实现完美单例的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(上)</title>
    <link href="http://yoursite.com/2019/03/12/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(%E4%B8%8A)/"/>
    <id>http://yoursite.com/2019/03/12/design-pattern/单例模式(上)/</id>
    <published>2019-03-12T05:51:21.975Z</published>
    <updated>2019-03-12T05:59:04.324Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式看似十分简单，不就是唯一性嘛！但是当单例模式遇上多线程，遇上序列化，遇上反射的时候，一切就变得有点麻烦了，因为单例不仅要在生成的时候全局唯一，也要支持序列化反序列化后的唯一，还需要抵抗住反射的攻击。分为两截文章进行探讨，本文是上篇。</p><a id="more"></a><h2>一、定义</h2><ul><li>保证一个类只有一个实例，并提供一个全局访问点</li><li>创建型</li><li>对于单例的适用场景是不必多说了</li><li>单例模式的优点也是很明显的了：只有一个实例，减少内存开销</li><li>缺点也很明显：不易扩展</li><li>单例的关键词：私有构造器、线程安全、延迟加载、序列化和反序列化安全、防止反射攻击</li></ul><h2>二、懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在线程安全的问题，解决方法是：<code>synchronized</code>，但是这种排队执行，是比较慢的。下面进行优化。</p><h2>三、双重锁检查–禁止指令重排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazyDoubleCheckSingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazyDoubleCheckSingleton();<span class="comment">//2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要用<code>volatile</code>关键字，来防止指令重排序。因为<code>instance = new LazyDoubleCheckSingleton();</code>这一步可以分为三个步骤：</p><ul><li>第一步：分配内存给对象</li><li>第二步：初始化对象</li><li>第三步：设置instance指向刚刚分配的内存地址</li></ul><p>这个时候，第二步和第三步执行顺序可能会被颠倒。</p><p>比如第一个线程t1，进来了，执行new，即先指向内存，但是对象还没有初始化完成，这个时候instance已经不为null，但是还没有初始化成功。</p><p>此时假设恰好t1时间片执行结束，t2进来了，首先判断是否为Null，因为不为null，所以直接返回这个还没有初始化好的instance，这个时候，针对这个线程t2系统就要报异常了。</p><p>此时，t2线程不影响t1线程继续执行，再去初始化一下对象，返回初始化好的instance.</p><p>加上<code>volatile</code>关键字之后，每个线程就都可以看到这个共享内存中的最新状态了，保证了内存可见性。并且禁止指令重排序，不会出现上述指令排序出现的问题。</p><p>用<code>volatile</code>关键字修饰的共享变量，在进行写操作的时候，将当前缓存行的数据写回到系统内存（共享内存）中，这个写回系统内存的操作会使其他线程缓存的这个变量值失效，所以他们需要去系统内存去同步数据。</p><p>这样，既兼顾了性能，又兼顾了线程安全。</p><h2>四、允许重排序–禁止其他线程看到重排序</h2><p>采用静态内部类的方式。原理如下。</p><p>假设有一个类叫A：</p><ul><li>A类实例被创建</li><li>A类中声明的静态方法被调用</li><li>A类中声明的一个静态成员被赋值</li><li>A类中声明的一个静态成员被使用，并且这个成员不是常量成员</li><li>如果A类为顶级类，并且A类中有嵌套的断言语句（不常用）</li></ul><p>根据java语言规范，其中任何一种情况首次发生，这个类就会立即被初始化。</p><p>那么，我们执行<code>InnerClass.instance</code>这句话的时候，就是调用了这个内部类的静态成员，所以此时这个静态内部类立即被初始化。</p><p><img src="http://bloghello.oursnail.cn/patten13-1.png" alt="image"></p><p>JVM在类的初始化阶段（class加载后，线程使用前），这个阶段会执行类的初始化，<strong>JVM会先获取一个锁</strong>，这个锁可以同步多个线程对一个类的初始化，基于这个特性，可以实现基于静态内部类的延迟加载、线程安全的方案。</p><p>那么，由于存在一把初始化锁，只能有一个线程执行初始化，即使静态内部类中存在重排序，也不会有任何问题，因为其他线程压根看不到，进不来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassLazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassLazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassLazySingleton instance = <span class="keyword">new</span> StaticInnerClassLazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取这个单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassLazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>五、饿汉式</h2><p>类加载的时候就完成了初始化，没有延迟加载(final static修饰的变量会在JVM准备阶段就完全确定了)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将初始化对象放到静态块中，达到一样的效果。</p><h2>六、序列化和反序列化破坏单例模式及解决</h2><p>用上一个饿汉来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//获取单例对象</span></span><br><span class="line">    HungrySingleton instance = HungrySingleton.getGetInstance();</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singletonFile"</span>));</span><br><span class="line">    oos.writeObject(instance);</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"singletonFile"</span>);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">//获取反序列化后的对象</span></span><br><span class="line">    HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    System.out.println(instance);</span><br><span class="line">    System.out.println(newInstance);</span><br><span class="line">    System.out.println(instance == newInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@568db2f2</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>反序列化后就破坏了单例。<font color="red">原因是在<code>ObjectInputStream</code>中，有段逻辑判断这个类是不是<code>implements Serializable</code>，是的话就用反射构建的对象，是新的实例。</font></p><p>此时如果将<code>HungrySingleton</code>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新增一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>为什么呢？在上面反序列化的反射过程中生成了一个新的对象obj之后，下面还有一个判断：</p><p><img src="http://bloghello.oursnail.cn/pattern13-2.png" alt="image"></p><p>这里<code>hasReadResolveMethod</code>这个方法，具体如下：</p><p><img src="http://bloghello.oursnail.cn/pattern13-3.png" alt="image"></p><p>就是说，加入这个类实现了序列化接口，并且有<code>readResolve()</code>这个方法，就返回true.</p><p>就会执行下面的<code>desc.invokeReadResolve(obj)</code>这句，这句其实就是利用反射去调用<code>HungrySingleton</code>类中的<code>readResolve()</code>方法，拿到了原来里面的对象实例。所以就解决了这个问题。</p><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式看似十分简单，不就是唯一性嘛！但是当单例模式遇上多线程，遇上序列化，遇上反射的时候，一切就变得有点麻烦了，因为单例不仅要在生成的时候全局唯一，也要支持序列化反序列化后的唯一，还需要抵抗住反射的攻击。分为两截文章进行探讨，本文是上篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题45-扑克牌顺子】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题45-扑克牌顺子】/</id>
    <published>2019-03-12T04:17:37.594Z</published>
    <updated>2019-03-12T04:17:58.116Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十五题。</p><a id="more"></a><h2>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张<sup>_</sup>)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2>解题思路</h2><p>要组成顺子，我们想一想最简单的情况，就是四个王再搭一个任意牌，这五张牌必然是顺子。</p><p>那么到底如何判断是不是顺子呢？</p><p>一个关键点是0的个数，就是王的个数。另一个关键点是非0元素之间的差值和。</p><p>如果这个差值的和大于王的个数，那么王是无法填补里面的间隙的，那么就形不成顺子了。</p><p>下面举个简单的例子。比如有五张牌，分别是1，3，4，5，0，那么0可以作为2，可以作为顺子，此时0 的个数是1，而间隙是(3-1-1)+(4-3-1)+(5-4-1)=1（注意，数组要先排序，所以此时数组是0,1,3,4,5）,而0不要参与计算。此时0的个数为1，差值也为1，所以0可以来填补这个间隙，所以可以作为顺子。</p><p>再来看一个例子：0,0,1,5,6，0的个数为2，间隙为(5-1-1)+(6-5-1)=3,此时3&gt;2，所以无法用0来填补，所以无法构成顺子。</p><p>最后就是注意，如果存在对子，那么肯定就不是顺子了。</p><p>分析完毕。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//零的个数，即王的个数</span></span><br><span class="line">        <span class="keyword">int</span> zeroNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排序后元素之间的差值</span></span><br><span class="line">        <span class="keyword">int</span> gapNum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组排序</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//统计王的个数，统计到一个就重新循环，因为不需要参与后面的差值计算</span></span><br><span class="line">            <span class="comment">//也不需要对比是不是顺子</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是王，并且还是对子，那肯定不是顺子了</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是王，计算一下两两的差值，最后与王的个数做比较</span></span><br><span class="line">            gapNum += numbers[i+<span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//差值小于王的个数，说明可以用王来构成顺子</span></span><br><span class="line">        <span class="keyword">if</span>(gapNum &lt;= zeroNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题44-翻转单词顺序列】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9844-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题44-翻转单词顺序列】/</id>
    <published>2019-03-12T04:17:02.063Z</published>
    <updated>2019-03-12T04:17:22.703Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十四题。</p><a id="more"></a><h2>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h2>解题思路</h2><p>比较简单的思路是从尾到头遍历数组，依次拼接起来。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.trim().length() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] strArr = str.split(<span class="string">" "</span>);</span><br><span class="line">        </span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=strArr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                res += strArr[i] + <span class="string">" "</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += strArr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题43-左旋转字符串】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9843-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题43-左旋转字符串】/</id>
    <published>2019-03-12T04:16:33.394Z</published>
    <updated>2019-03-12T04:16:52.779Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十三题。</p><a id="more"></a><h2>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h2>解题思路</h2><p>我们可以用一个比较巧妙的方法实现这种循环左移，比如将&quot;abc&quot;拼接成&quot;abcabc&quot;，此时如果要循环左移一位，应该变成&quot;bca&quot;，那么我通过截取&quot;abcabc&quot;来获得，怎么截取呢？很简单，就是截取n-n+length这个长度即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制字符串，比如"abc"复制为`abcabc`</span></span><br><span class="line">        String s = str + str;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="comment">//算出偏移量</span></span><br><span class="line">        n = n%len;</span><br><span class="line">        <span class="comment">//开始从n截取，截取到len+n</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(n,len+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题42-和为S的两个数字】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9842-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题42-和为S的两个数字】/</id>
    <published>2019-03-12T04:15:59.338Z</published>
    <updated>2019-03-12T04:16:21.820Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十二题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>输出描述:</p><blockquote><p>对应每个测试案例，输出两个数，小的先输出。</p></blockquote><h2>解题思路</h2><p>满足递增，设两个头尾两个指针i和j，</p><p>若ai + aj == sum，就是答案（相差越远乘积越小）</p><p>若ai + aj &gt; sum，aj肯定不是答案之一（前面已得出 i 前面的数已是不可能），j -= 1</p><p>若ai + aj &lt; sum，ai肯定不是答案之一（前面已得出 j 后面的数已是不可能），i += 1</p><p>第一组符合条件的也是乘积最小的，数学可以证明，所以我们找到第一个即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = array.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[low] + array[high] == sum)&#123;</span><br><span class="line">                res.add(array[low]);</span><br><span class="line">                res.add(array[high]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[low] + array[high] &gt; sum)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题41-和为S的连续正数序列】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9841-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题41-和为S的连续正数序列】/</id>
    <published>2019-03-12T04:15:25.526Z</published>
    <updated>2019-03-12T04:15:48.037Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十一题。</p><a id="more"></a><h2>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p>输出描述:</p><blockquote><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p></blockquote><h2>解题思路</h2><p>可以采取类似于窗口滑动的思想，慢慢找。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小</span></span><br><span class="line">        <span class="keyword">int</span> plow = <span class="number">1</span>,phigh = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(phigh &gt; plow)&#123;</span><br><span class="line">            <span class="comment">//由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2</span></span><br><span class="line">            <span class="keyword">int</span> cur = (phigh + plow) * (phigh - plow + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//相等，那么就将窗口范围的所有数添加进结果集</span></span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=plow;i&lt;=phigh;i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                plow++;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，那么右边窗口右移一下</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; sum)&#123;</span><br><span class="line">                phigh++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，那么左边窗口右移一下</span></span><br><span class="line">                plow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CSS之定位</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之定位/</id>
    <published>2019-03-11T14:04:48.644Z</published>
    <updated>2019-03-11T14:08:18.177Z</updated>
    
    <content type="html"><![CDATA[<p>本文来研究一下第三个重点：定位。</p><a id="more"></a><h2>绝对定位和相对定位</h2><p>绝对定位的主要特性是不占空间。</p><p><img src="http://bloghello.oursnail.cn/html8-1.png" alt="image"></p><p>但是相对定位是占空间的。</p><p><img src="http://bloghello.oursnail.cn/html8-2.png" alt="image"></p><p>我们看到，占用的是原来的空间。说明相对定位的话，原有的空间会给它保留住，实际占用的空间仍然是原来的，而不是现在移动后的。</p><h2>嵌套子元素</h2><p><img src="http://bloghello.oursnail.cn/html8-3.png" alt="image"></p><p>我们可以发现，如果子元素用的是绝对定位，那么定位是跟父元素没有关系的，而是与浏览器边框有关。此时如何做到跟着父元素一起动呢?最简单的方法是将子元素改为相对定位。</p><p>改为相对定位确实可以解决这个问题，但是有的时候我们需要子元素不占用空间，那么怎么办呢？一般情况下，我们给父元素一个定位信息，一般是相对定位，然后子元素是绝对定位，这样子元素就不会占用空间，并且子元素的位置是相对父元素动的。</p><p>为什么父元素要是相对定位呢？因为父元素一般都是需要占用空间的。一举两得，所以口则是子绝父相。</p><p><img src="http://bloghello.oursnail.cn/html8-4.png" alt="image"></p><p>此时就做到子元素相对于父元素定位了。</p><p>固定定位就是<code>fixed</code>，那么网页内容再多一直往下滑，它依然不动。</p><p>简单总结一下，就是相对定位是占空间的，绝对定位是不占空间的。默认情况下，绝对定位是相对于浏览器边框的，但是如果是父子关系，并且父元素设置<code>relative</code>子元素设置<code>absolute</code>的话，子元素就是相对于父元素进行排版。固定定位就是钉死不动。默认情况下是<code>static</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来研究一下第三个重点：定位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS之浮动</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之浮动/</id>
    <published>2019-03-11T13:11:04.888Z</published>
    <updated>2019-03-11T13:11:40.613Z</updated>
    
    <content type="html"><![CDATA[<p>本文来研究一下第二个重点：浮动。</p><a id="more"></a><h2>浮动</h2><p><img src="http://bloghello.oursnail.cn/html7-1.png" alt="image"></p><p>那么我们如何让他变成一行呢？之前已经说过了，可以用<code>inline-block</code>来实现：</p><p><img src="http://bloghello.oursnail.cn/html7-2.png" alt="image"></p><p>但是我们发现，有该死的间隙存在。此时就需要用到我的浮动了。什么是浮动，顾名思义，就是浮在上面，下面来直观感受一下：</p><p><img src="http://bloghello.oursnail.cn/html7-3.png" alt="image"></p><p>我们会发现，一个加了浮动，一个没有加的话，那么这两个在排版的时候是互相不冲突的，也就是说，浮动的元素根本就不占用标准元素的空间，所以这两者重叠在了一起。浮动就像是飞机，而不是浮动的就是汽车，汽车与汽车之间是互斥的，但是汽车与飞机之间不互斥，下面我们再来解决上面存在间隙的问题，我们只需要将这两个元素全部置为向左浮动即可。</p><p><img src="http://bloghello.oursnail.cn/html7-4.png" alt="image"></p><p>那么既然已经是浮动的元素了，这个元素是属于谁的呢？也就是说，是属于整个body还是属于父元素的呢？如果是属于父元素的话，那么就非常好了，我可以调整好父元素的位置之后，里面的子元素采用浮动来置为一行。我们来测试一下。</p><p><img src="http://bloghello.oursnail.cn/html7-5.png" alt="image"></p><p>这说明确实是属于父元素的。</p><h2>一些问题</h2><p><img src="http://bloghello.oursnail.cn/html7-6.png" alt="image"></p><p>此时下面的<code>div</code>直接就将第一个<code>outer</code>给顶掉了，这不是我们想要的结果。结果方案有三种。</p><p><img src="http://bloghello.oursnail.cn/html7-7.png" alt="image"></p><p>可能有的时候需要用第三种，因为第一种方法有的时候父元素会隐藏掉多出来的子元素。有的时候我们不想隐藏，就需要用到这个方法。</p><p><img src="http://bloghello.oursnail.cn/html7-8.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来研究一下第二个重点：浮动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS之盒子模型</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之盒子模型/</id>
    <published>2019-03-11T12:15:10.754Z</published>
    <updated>2019-03-11T12:16:13.769Z</updated>
    
    <content type="html"><![CDATA[<p>盒子模型是比较基础但是比较重要的一点，本文来简单了解一下。</p><a id="more"></a><h2>盒子模型</h2><p><img src="http://bloghello.oursnail.cn/html6-1.png" alt="image"></p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。<br>下面的图片说明了盒子模型(Box Model)：</p><p><img src="http://bloghello.oursnail.cn/html6-2.png" alt="image"></p><p>由上面我知道了：最终元素的总宽度计算公式是这样的：</p><ul><li>总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距</li></ul><p>元素的总高度最终计算公式是这样的：</p><ul><li>总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距</li></ul><p>简单了解了盒子模型之后，我们看到这个margin是在盒子的最外面，那么两个这样的盒子相邻的话可能会出一些问题。</p><p>比如两个盒子一上一下放，两个都设置margin，那么这两者之间上下间隔会是多少呢？是两者的margin之和吗？</p><p>⭐经过验证，间隔是以大的那个为准，而不是两者之和。</p><p>那对于内部嵌套的情况呢？</p><p><img src="http://bloghello.oursnail.cn/html6-5.png" alt="image"></p><p>看起来好像没什么问题，都是符合我们一开始的期望的。但是去掉父盒子中的<code>padding</code>或者同时删除掉<code>padding</code>和<code>border</code>会是什么样子呢？</p><p><img src="http://bloghello.oursnail.cn/html6-6.png" alt="image"></p><p>好像子中<code>margin</code>的设置没什么作用了，此时我增大一下<code>margin</code>：</p><p><img src="http://bloghello.oursnail.cn/html6-4.png" alt="image"></p><p>（删除掉<code>border</code>效果也一样），效果就是两者同时下移了。这就很奇怪了，用比较专业的词汇来说，就是这两者的<code>margin</code>咋合并了呢？这里确实是合并了，<code>div</code>距离最上面的距离由其中较大的<code>margin</code>的值决定。</p><p>解决方法是什么呢？正如上面第一种显示的，要么加一个<code>border</code>要么加一个<code>padding</code>.</p><p><img src="http://bloghello.oursnail.cn/html6-7.png" alt="image"></p><p>还有一种方式是在父元素上增加<code>overflow</code>，顾名思义就是溢出的意思。</p><p><img src="http://bloghello.oursnail.cn/html6-8.png" alt="image"></p><p>这也可以解决边框合并问题。我们稍微来看一下这个溢出是啥意思。起始就是说，如果子元素不在这个父元素范围内了，就直接不显示了。我们也可以显示，调整为<code>auto</code>模式即可，就可以下拉看到子元素了。</p><p><img src="http://bloghello.oursnail.cn/html6-9.png" alt="image"></p><p>我们来稍微总结一下，盒子模型的计算方法跟<code>margin</code>决定的外边距，<code>border</code>决定的边框宽度，<code>padding</code>决定的内边距以及实际内容相关。</p><p>然后就是存在外边距合并的问题，一个是上下关系，一个是嵌套关系。重点是嵌套关系，要解除外边距合并问题，第一个比较可行的方案是给父元素添加一个白色的边框，一个是给父元素增加<code>overflow</code>。那个<code>padding</code>是不大好用的，毕竟增加了<code>padding</code>之后整个父元素的宽度或者高度都变化了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;盒子模型是比较基础但是比较重要的一点，本文来简单了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS之图片</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之图片/</id>
    <published>2019-03-11T08:00:21.455Z</published>
    <updated>2019-03-11T08:02:15.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文来说一说图片相关的一些处理以及精灵图。</p><a id="more"></a><h2>图片</h2><p><img src="http://bloghello.oursnail.cn/html5-1.png" alt="image"></p><p>这就是简单放一张图片，但是我们发现，当图片比我们设定的div要小的时候，它会自动复制取铺满整个div。如果我们仅仅显示原来的图片，不要它铺开呢？</p><p><img src="http://bloghello.oursnail.cn/html5-2.png" alt="image"></p><p>这样就不会重复显示了，那我们能不能移动移动这个图片呢？</p><p><img src="http://bloghello.oursnail.cn/html5-3.png" alt="image"></p><p>注意，正数是让它往左往右移动。这个有什么用呢？这就要说一说精灵图了。</p><p>还可以用<code>background-repeat: repeat-x;</code>表示横向自动填充。</p><h2>精灵图</h2><p>什么是精灵图呢？</p><p>我们去腾讯游戏的官网看一下：</p><p><img src="http://bloghello.oursnail.cn/html5-4.png" alt="image"></p><p>我们注意到有很多的小图标，这些小图片特点是数量多，并且很小。为了减轻与服务器交互带来的不必要的开销，可以将这些小图标全部放在一张大图上，要用哪个图标通过上面说过的<code>background-position</code>来指定即可。</p><p><img src="http://bloghello.oursnail.cn/html5-5.png" alt="image"></p><p>比如我想只显示那个奖杯。</p><p><img src="http://bloghello.oursnail.cn/html5-6.png" alt="image"></p><p>慢慢移动到这个位置就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来说一说图片相关的一些处理以及精灵图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【面试题40-数组中只出现一次的数字】</title>
    <link href="http://yoursite.com/2019/03/11/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/11/剑指offer/【面试题40-数组中只出现一次的数字】/</id>
    <published>2019-03-11T05:31:34.199Z</published>
    <updated>2019-03-11T05:38:40.213Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十题。</p><a id="more"></a><h2>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><h2>解题思路</h2><p>一种简单的思路，可以想到用<code>HashSet</code>这种数据结构来存，重复的就立即剔除，剩下的就是不重复的两个数字，将其取出即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.isEmpty() &amp;&amp; set.contains(array[i]))&#123;</span><br><span class="line">                set.remove(array[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这边处理的不够好</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(set.size() == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Integer i:set)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        num1[<span class="number">0</span>] = list.get(<span class="number">0</span>);</span><br><span class="line">        num2[<span class="number">0</span>] = list.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于题目中说除了两个单个数字外，其他的都出现偶数次。我们需要从这句话入手，寻求更优的解决思路。</p><p>我们知道，位运算中异或的性质是：两个相同数字异或=0，不相同的话肯定不为0，一个数和0异或还是它本身。</p><p>这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。</p><p>有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。</p><p>我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。</p><p>我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。</p><p>现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【解决思路】：从简单的场景想起，假设一个数组中只有一个独特元素，其他出现次数都为2</span></span><br><span class="line">        <span class="comment">//如何快速找出这个独特元素呢？那就是从头到尾两两异或，由于相同的数异或为0，则认为是抵消</span></span><br><span class="line">        <span class="comment">//一直到最后，结果必然就是这个独特元素</span></span><br><span class="line">        <span class="comment">//那么找出两个来也是这个思路，核心就是要将这两个独特的数分离开，下面详细介绍</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            num1[<span class="number">0</span>] = num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//整个数组从头两两异或，最终的结果必然是两个不同数字的异或结果</span></span><br><span class="line">        <span class="comment">//因为相同的数字两两异或之后为0</span></span><br><span class="line">        <span class="comment">//0和任意一个数异或还是这个数本身</span></span><br><span class="line">        <span class="keyword">int</span> len = array.length, index = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            sum ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//java中int类型占4个字节，即32个bit</span></span><br><span class="line">        <span class="comment">//从左开始找到这个异或结果第一个为1的索引</span></span><br><span class="line">        <span class="keyword">while</span>((sum&amp;<span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">32</span>)&#123;</span><br><span class="line">            sum = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以这个索引处是否为1作为判定标准，就将两个不同的数分离开了</span></span><br><span class="line">        <span class="comment">//下面就是分两批不停地疑惑，就会得到这两个不同的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//这样就可以分别找到index处为1的独特解以及为0的独特解</span></span><br><span class="line">            <span class="keyword">if</span>(isBit(array[i],index))&#123;</span><br><span class="line">                num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断num的index（从左往右看）是否为1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        num = num &gt;&gt; index;</span><br><span class="line">        <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题39-平衡二叉树】</title>
    <link href="http://yoursite.com/2019/03/11/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9839-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/11/剑指offer/【面试题39-平衡二叉树】/</id>
    <published>2019-03-11T05:31:24.909Z</published>
    <updated>2019-03-11T05:33:04.296Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第三十九题。</p><a id="more"></a><h2>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><h2>解题思路</h2><p>首先明确平衡二叉树的概念，就是数的最大高度和最小高度差不超过1.根据上一题我们得到灵感，我们可以分别求出左右子树的最大深度，然后对他们两进行比较即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取左右子树的最大高度</span></span><br><span class="line">        <span class="keyword">int</span> left = judge(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = judge(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两边高度不超过1即可</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left-right) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judge</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = judge(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = judge(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第三十九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
