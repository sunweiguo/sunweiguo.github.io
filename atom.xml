<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>但行好事，莫问前程；前路有光，莫忘初心。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-11T14:01:55.445Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot集成WebService</title>
    <link href="http://yoursite.com/2020/04/11/miscellany/22SpringBoot%E9%9B%86%E6%88%90WebService/"/>
    <id>http://yoursite.com/2020/04/11/miscellany/22SpringBoot集成WebService/</id>
    <published>2020-04-11T14:00:15.546Z</published>
    <updated>2020-04-11T14:01:55.445Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目要用到webservice，我自己用springboot来整合试了下，遂有了下述的记录。</p><a id="more"></a><h2>1.什么是webservice</h2><p>简单来说,<code>webservice</code>就是远程调用技术,也叫<code>XML Web Service</code>. <code>WebService</code>是一种可以接收从<code>Internet</code>或者<code>Intranet上</code>的其它系统中传递过来的请求，轻量级的独立的通讯技术。。</p><p>XML：(<code>Extensible Markup Language</code>)扩展型可标记语言。面向短期的临时数据处理、面向万维网络，是SOAP的基础。</p><p>SOAP：(<code>Simple Object Access Protocol</code>)简单对象存取协议。是<code>XML Web Service</code> 的通信协议。当用户通过UDDI找到你的WSDL描述文档后，他通过可以SOAP调用你建立的Web服务中的一个或多个操作。SOAP是XML文档形式的调用方法的规范，它可以支持不同的底层接口，像HTTP(S)或者SMTP。</p><p>WSDL：(<code>Web Services Description Language</code>) WSDL 文件是一个 XML 文档，用于说明一组 SOAP 消息以及如何交换这些消息。大多数情况下由软件自动生成和使用。</p><p>我们一般是在具体平台开发 webservice 接口，以及调用 webservice 接口，每种开发语言都有自己的 webservice 实现框架。比如 Java 就有 Apache Axis1、Apache Axis2、Codehaus XFire、Apache CXF、Apache Wink、Jboss RESTEasyd 等等。其中 Apache CXF 用的比较多，它也可以和 Spring Boot 整合。</p><h2>2、集成webservice</h2><p>1、新建一个<code>springboot</code>项目，引入相关依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--lombok--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2、服务端接口定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地访问的地址为：http://localhost:8088/ContentDeployResult</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebService</span>(name = <span class="string">"ContentDeployResult"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CDNResponse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@WebMethod</span></span><br><span class="line">    <span class="function">CommonXmlResponse <span class="title">ContentDeployResult</span><span class="params">(@WebParam(name = <span class="string">"CMSID"</span>, targetNamespace = <span class="string">"iptv"</span>)</span> String CMSID,</span></span><br><span class="line"><span class="function">                                          @<span class="title">WebParam</span><span class="params">(name = <span class="string">"SOPID"</span>, targetNamespace = <span class="string">"iptv"</span>)</span> String SOPID,</span></span><br><span class="line"><span class="function">                                          @<span class="title">WebParam</span><span class="params">(name = <span class="string">"CorrelateID"</span>, targetNamespace = <span class="string">"iptv"</span>)</span> String CorrelateID,</span></span><br><span class="line"><span class="function">                                          @<span class="title">WebParam</span><span class="params">(name = <span class="string">"ResultCode"</span>, targetNamespace = <span class="string">"iptv"</span>)</span> Integer ResultCode,</span></span><br><span class="line"><span class="function">                                          @<span class="title">WebParam</span><span class="params">(name = <span class="string">"ErrorDescription"</span>, targetNamespace = <span class="string">"iptv"</span>)</span> String ErrorDescription,</span></span><br><span class="line"><span class="function">                                          @<span class="title">WebParam</span><span class="params">(name = <span class="string">"ResultFileURL"</span>, targetNamespace = <span class="string">"iptv"</span>)</span> String ResultFileURL,</span></span><br><span class="line"><span class="function">                                          @<span class="title">WebParam</span><span class="params">(name = <span class="string">"XMLURLQC"</span>, targetNamespace = <span class="string">"iptv"</span>)</span> String XMLURLQC, <span class="comment">//xml MD5摘要</span></span></span><br><span class="line"><span class="function">                                          @<span class="title">WebParam</span><span class="params">(name = <span class="string">"Encrypt"</span>, targetNamespace = <span class="string">"iptv"</span>)</span> String Encrypt)</span>; <span class="comment">//加密校验字符串// );</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、服务端接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDNResponseImpl</span> <span class="keyword">implements</span> <span class="title">CDNResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonXmlResponse <span class="title">ContentDeployResult</span><span class="params">(String CMSID,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String SOPID,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String CorrelateID,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Integer ResultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String ErrorDescription,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String ResultFileURL,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String XMLURLQC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String Encrypt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、封装传递进来的参数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、对参数进行校验</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、处理CDN回调的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、cxf 服务配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhjt.cms.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhjt.cms.intf.webservice.cdn.CDNResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.Bus;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.bus.spring.SpringBus;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.jaxws.EndpointImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.transport.servlet.CXFServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Endpoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CxfConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CDNResponse cdnResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入servlet  bean name不能dispatcherServlet 否则会覆盖dispatcherServlet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"cxfServlet"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;CXFServlet&gt; <span class="title">cxfServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean&lt;&gt;(<span class="keyword">new</span> CXFServlet(),<span class="string">"/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = Bus.DEFAULT_BUS_ID)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringBus <span class="title">springBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringBus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册WebServiceDemoService接口到webservice服务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"ContentDeployResult"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Endpoint <span class="title">sweptPayEndpoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EndpointImpl endpoint = <span class="keyword">new</span> EndpointImpl(springBus(), cdnResponse);</span><br><span class="line">        endpoint.publish(<span class="string">"/ContentDeployResult"</span>);</span><br><span class="line">        <span class="keyword">return</span> endpoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、启动项目，用soapui来模拟请求即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目要用到webservice，我自己用springboot来整合试了下，遂有了下述的记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-035-使用最小花费爬楼梯</title>
    <link href="http://yoursite.com/2020/03/01/leetcode-array/leetcode-035-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2020/03/01/leetcode-array/leetcode-035-使用最小花费爬楼梯/</id>
    <published>2020-02-29T16:08:27.615Z</published>
    <updated>2020-02-29T16:08:40.838Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第三十五道题目是使用最小花费爬楼梯，对应leetcode的题号为764。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="%E7%B4%A2%E5%BC%95%E4%BB%8E0%E5%BC%80%E5%A7%8B">i</a>。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost = [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>解体思路还是看的别人的，虽然动态规划的思想之前也学习过，过了很久还是写不出来，感慨万千，还是先继续学习别人的写法吧：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/solution/cong-meng-bi-dao-ti-jie-de-quan-guo-cheng-by-keepa/" target="_blank" rel="noopener">从懵逼到题解的全过程</a></p><p><img src="http://bloghello.oursnail.cn/leetcode35-1.png" alt="image"></p><p>其实题解给我最大的提示是：动态规划其实就是个打表格法。即用一个表格来不停记录子问题的答案。需要不断地训练才能用的得心应手。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;dp.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i-<span class="number">2</span>],dp[i-<span class="number">1</span>]) + cost[i-<span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        dp[dp.length-<span class="number">1</span>] = Math.min(dp[dp.length-<span class="number">3</span>],dp[dp.length-<span class="number">2</span>]) + <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第三十五道题目是使用最小花费爬楼梯，对应leetcode的题号为764。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-034-寻找数组的中心索引</title>
    <link href="http://yoursite.com/2020/02/20/leetcode-array/leetcode-034-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2020/02/20/leetcode-array/leetcode-034-寻找数组的中心索引/</id>
    <published>2020-02-20T14:32:56.180Z</published>
    <updated>2020-02-20T14:33:31.497Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第三十四道题目是寻找数组的中心索引，对应leetcode的题号为724。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。</p><p>我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">输出: -1</span><br><span class="line">解释: </span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>nums 的长度范围为 [0, 10000]。</li><li>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</li></ul><h2>解题思路</h2><p>最简单的思路一定是遍历数组，不断计算左右两边的元素和，一旦相等就结束，返回索引，这个索引就是符合条件的最左边的索引。具体见代码注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从左向右遍历数据，求解元素【左边左右元素】之和以及【右边所有元素之和】</span></span><br><span class="line">        <span class="comment">// 注意特殊情况，比如[-1,-1,-1,0,1,1]，那么此时程序应该返回0，因为第一元素后面所有元素和为0，第一个元素的左边没有元素，默认为0</span></span><br><span class="line">        <span class="comment">// 那么就要考虑边界问题，从第0个元素出发的时候，左边的sum一开始必然为0</span></span><br><span class="line">        <span class="comment">// 当移动到最后一个元素的时候，右边的sum也必然为0，这两个特殊情况直接在sum函数中进行了单独处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum(nums,<span class="number">0</span>,i-<span class="number">1</span>) == sum(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一个元素左边没有元素，直接返回0即可</span></span><br><span class="line">        <span class="keyword">if</span>(end &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个元素右边没有元素，直接返回0即可</span></span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两边都有元素的时候，正常计算即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            res += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行结果：通过 显示详情</span><br><span class="line">执行用时 :576 ms, 在所有 Java 提交中击败了5.06%的用户</span><br><span class="line">内存消耗 :42.7 MB, 在所有 Java 提交中击败了30.37%的用户</span><br></pre></td></tr></table></figure><p>双层for循环，时间复杂度为O(n^2)，空间复杂度为O(1)。效率太低，着手进行优化。</p><p>想到的第二个优化思路为：其实我没必要同时计算左边和以及右边和，只需要计算左边和即可，因为我很容易能计算出数组的所有元素和，那么就很好计算出所谓中心索引两边的和应该是多少，那么我只要去判断这两个和是否相等即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 计算剔除当前元素后，两边和如何相等，那么应该等于什么值</span></span><br><span class="line">            <span class="comment">// 这个值必须是整数，因为我们这里是整数数组，如果都不是整数了，那肯定加不出来这个值，直接continue掉计算下一个</span></span><br><span class="line">            <span class="keyword">if</span>((sum-nums[i])%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> midSumValue = (sum-nums[i])/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 这个时候只需要计算左边的元素即可</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                temp += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == midSumValue)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行结果：通过 显示详情</span><br><span class="line">执行用时 :97 ms, 在所有 Java 提交中击败了25.64%的用户</span><br><span class="line">内存消耗 :42.8 MB, 在所有 Java 提交中击败了30.37%的用户</span><br></pre></td></tr></table></figure><p>嗯，效率已经提高了很多了，但是总体上的效果不尽人意，还要提升！刚才的一个思路是：先求和sum，然后剔除当前元素nums[i]，然后除以2，得到应该等于的值叫midSumValue ，计算当前元素i之前所有元素之和是否等于midSumValue 。</p><p>那么其实这里是可以做优化的，没必要每次起一个for循环去计算i左边所有元素的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个temp就是代表i左边所有元素的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 计算剔除当前元素后，两边和如何相等，那么应该等于什么值</span></span><br><span class="line">            <span class="comment">// 这个值必须是整数，因为我们这里是整数数组，如果都不是整数了，那肯定加不出来这个值，直接continue掉计算下一个</span></span><br><span class="line">            <span class="keyword">if</span>((sum-nums[i])%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                temp += nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> midSumValue = (sum-nums[i])/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp == midSumValue)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            temp += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度已经降到了O(n)，执行效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行结果：通过 显示详情</span><br><span class="line">执行用时 :2 ms, 在所有 Java 提交中击败了82.52%的用户</span><br><span class="line">内存消耗 :42.5 MB, 在所有 Java 提交中击败了30.37%的用户</span><br></pre></td></tr></table></figure><p>总感觉代码有点冗余，那么能不能反过来想呢，即【左边元素求和*2+当前元素的值】，如果等于sum，不就是表示当前元素满足这个中心索引的要求么。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 先根据【左边元素求和*2+当前元素的值】计算等不等于sum</span></span><br><span class="line">            <span class="keyword">if</span>(temp*<span class="number">2</span>+nums[i] == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再对temp进行调整，因为要保证temp的值是i之前的元素，当i=0的时候，temp就应该是0；当i=1的时候，temp=nums[0]</span></span><br><span class="line">            temp += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码简洁了很多，因为乘法代替除法减少了一步是否为小数的判断。运行效果基本一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行结果：通过 显示详情</span><br><span class="line">执行用时 :2 ms, 在所有 Java 提交中击败了82.52%的用户</span><br><span class="line">内存消耗 :42.5 MB, 在所有 Java 提交中击败了30.37%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第三十四道题目是寻找数组的中心索引，对应leetcode的题号为724。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-033-1比特与2比特字符</title>
    <link href="http://yoursite.com/2020/02/16/leetcode-array/leetcode-033-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/02/16/leetcode-array/leetcode-033-1比特与2比特字符/</id>
    <published>2020-02-16T13:18:03.678Z</published>
    <updated>2020-02-16T13:19:20.714Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第三十三道题目是1比特与2比特字符，对应leetcode的题号为717。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。</p><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits = [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits = [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>1 &lt;= len(bits) &lt;= 1000.</li><li>bits[i] 总是0 或 1.</li></ul><h2>解题思路</h2><p>分析一下题目，0可以用一比特来表示，10或11可以用两比特来表示。某个数组元素总为1或0，以[1,0,0]为例，1不能单独作为一个比特，必须跟0或1结合才行，那么10才符合条件，那么还剩一个0，这个0用一比特表示，那么这个数组就符合条件，因为题目要求最后一个字符为一比特字符。</p><p>比如[1,1,1,0]，这个就不符合，为什么呢？因为同理，第一个1必须结合0或1才行，此时11为两比特，那么前两个1已经被占用，这个时候用第三个1，同理，10才行，那么此时11和10全部用完，说明最后一个0不能作为一比特来用了。</p><p>所以这道题目理解的关键就是，数组从前往后，遇到1就要占两位，遇到0就占一位。按照上面的规则一直判断，如果最后还能胜一个0说明符合条件，如果最后不剩了，那么就不符合条件。那么就是判断咯，1则加2，0则加1，理解了这个思想后，就可以写代码了，注意判断count的结束条件，不是判断到最后一位，而是倒数第二位。时间复杂度为O(N)，空间复杂度为O(1)。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断到最后一个元素之前即可，注意边界，不能判断到最后一个，最后一个元素没有意义，还会导致程序判断有误</span></span><br><span class="line">        <span class="keyword">while</span>(count &lt; bits.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果开头是0.那么这一位必定是用一比特来表示</span></span><br><span class="line">            <span class="keyword">if</span>(bits[count] == <span class="number">0</span>)&#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果开头是1，那么这一位必定是两比特</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bits[count] == <span class="number">1</span>)&#123;</span><br><span class="line">                count += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数结束</span></span><br><span class="line">        <span class="comment">// 此时如果索引等于最后一个元素，说明还剩最后一位，结合题意最后一位必为0，那么此时必定符合条件</span></span><br><span class="line">        <span class="comment">// 比如1，0，0，那么此时count=3-1=2，符合条件</span></span><br><span class="line">        <span class="comment">// 如果直接已经到数组的最后一位的后面，说明倒数第二位为1，此时最后两个数字结合成了两比特，不符合条件</span></span><br><span class="line">        <span class="comment">// 比如1，1，1，0.此时count=4-1!=4，不符合条件</span></span><br><span class="line">        <span class="keyword">return</span> count == bits.length-<span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第三十三道题目是1比特与2比特字符，对应leetcode的题号为717。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-032-数组的度</title>
    <link href="http://yoursite.com/2020/02/14/leetcode-array/leetcode-032-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/"/>
    <id>http://yoursite.com/2020/02/14/leetcode-array/leetcode-032-数组的度/</id>
    <published>2020-02-14T15:15:13.294Z</published>
    <updated>2020-02-14T15:21:45.180Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第三十二道题目是数组的度，对应leetcode的题号为697。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。</p><p>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 2, 3, 1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">输入数组的度是2，因为元素1和2的出现频数最大，均为2.</span><br><span class="line">连续子数组里面拥有相同度的有如下所示:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">最短连续子数组[2, 2]的长度为2，所以返回2.</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2,3,1,4,2]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>nums.length 在1到50,000区间范围内。</li><li>nums[i] 是一个在0到49,999范围内的整数。</li></ul><h2>解题思路</h2><p>对于这一题，我的思路很朴素：遍历数组找到出现次数最多的元素们，然后一一比较这些元素们对应在原数组中的最短序列，找出其中最短的即可。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先找到出现最多次数的数字，用hashmap来找，map记录元素以及其出现次数</span></span><br><span class="line">        <span class="comment">//记录出现的最多次数</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i]) &gt; maxCount)&#123;</span><br><span class="line">                maxCount = map.get(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据最多次数去寻找对应的元素</span></span><br><span class="line">        List&lt;Integer&gt; valueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) == maxCount)&#123;</span><br><span class="line">                valueList.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去遍历原数组，找到最短的子数组</span></span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer value : valueList)&#123;</span><br><span class="line">            <span class="keyword">int</span> begin = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;nums.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == value &amp;&amp; begin &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    begin = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == value &amp;&amp; end &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    end = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res == -<span class="number">1</span>)&#123;</span><br><span class="line">                    res = j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = j-i+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(temp &lt; res)&#123;</span><br><span class="line">                        res = temp;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == -<span class="number">1</span> ? <span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第三十二道题目是数组的度，对应leetcode的题号为697。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-031-最长连续递增序列</title>
    <link href="http://yoursite.com/2020/02/13/leetcode-array/leetcode-031-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2020/02/13/leetcode-array/leetcode-031-最长连续递增序列/</id>
    <published>2020-02-13T12:44:37.769Z</published>
    <updated>2020-02-13T12:45:16.719Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第三十一道题目是最长连续递增序列，对应leetcode的题号为674。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure><p>注意：数组长度不会超过10000。</p><h2>解题思路</h2><p>这一题是比较经典的题目，思路比较简单，就是遍历数组并且记录连续递增序列的长度，最终返回最大的即可。详细见代码和注释。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终的最大长度</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 计数，默认为1</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 开始遍历数组，如果当前元素大于前一个元素则count++并记录max</span></span><br><span class="line">        <span class="comment">// 要是小于说明这个递增序列中止了，还原count的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; max)&#123;</span><br><span class="line">                    max = count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; max ? count : max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第三十一道题目是最长连续递增序列，对应leetcode的题号为674。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-030-非递减数列</title>
    <link href="http://yoursite.com/2020/02/10/leetcode-array/leetcode-030-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/2020/02/10/leetcode-array/leetcode-030-非递减数列/</id>
    <published>2020-02-10T13:40:11.300Z</published>
    <updated>2020-02-10T13:41:14.110Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第三十道题目是非递减数列，对应leetcode的题号为665。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,2,3]</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,2,1]</span><br><span class="line">输出: False</span><br><span class="line">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</span><br></pre></td></tr></table></figure><p>说明:  n 的范围为 [1, 10,000]。</p><h2>解题思路</h2><p>只调整一次元素就成为非递减序列？我们考虑简单情况，比如示例的[4,2,3]，此时我们知道只需要调整4即可，比如[2,2,3]即可满足非递减序列要求，那么这个序列是符合条件的。但是[4,2,1]就不行，按照刚才的做法，第一步是[2,2,1]，但是此时第二个元素还是大于第三个元素，因此还要调整一次才符合，那么这个序列就不符合条件。</p><p>显然，这里的关键点是判断前一个元素是否大于后一个元素。一旦有此时就需要进行调整了。</p><p>不过如何调整呢？这里就稍微要注意点了，分为两种情况。以[i-1,i.i+1]为例，此时i处元素大于i+1处元素的：</p><ul><li>当i-1大于i+1元素的时候，比如[3,4,1]这里的策略是将1调整为4（这是比较简单的调整策略，调整为5的话可能会加重后续的调整），调整之后变成[3,4,4]即可满足</li><li>当i-1小于i+1元素的时候，比如[1,4,3]这里策略是将4调小为3，变成[1,3,3]即可满足条件</li></ul><p>具体见代码。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果第一个元素大于第二个元素，那么为了保证非递减的特性，向下调整第一个元素不大于第二个元素即可</span></span><br><span class="line">        <span class="comment">// 比如4 2 3 那么第一步就应该调整4为2即 2 2 3（不要纠结调整为1等其他数字，这里调整的时候策略是相等，因为相等就满足非递减了）</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>])&#123;</span><br><span class="line">            nums[<span class="number">0</span>] = nums[<span class="number">1</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+<span class="number">1</span>&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> right = nums[i+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果当前元素大于后面一个元素，那么需要分两种情况讨论</span></span><br><span class="line">            <span class="comment">// 比如1 4 3这种情况，为了保证非递减，只能调小第二个元素4，至少减为3才满足条件</span></span><br><span class="line">            <span class="comment">// 比如3 4 1这种情况，为了保证非递减，只能调大第三个元素3，至少增为4才满足条件</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; right)&#123;</span><br><span class="line">                <span class="comment">// 先count++，判断count是否大于1了，大于1说明不止一处需要调整，直接返回false</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对应3 4 1这种情况</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 对应1 4 3这种情况</span></span><br><span class="line">                    nums[i] = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第三十道题目是非递减数列，对应leetcode的题号为665。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-029-子数组最大平均数1</title>
    <link href="http://yoursite.com/2020/02/05/leetcode-array/leetcode-029-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B01/"/>
    <id>http://yoursite.com/2020/02/05/leetcode-array/leetcode-029-子数组最大平均数1/</id>
    <published>2020-02-05T12:19:22.937Z</published>
    <updated>2020-02-05T12:21:31.687Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十九道题目是子数组最大平均数 I，对应leetcode的题号为643。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出: 12.75</span><br><span class="line">解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>1 &lt;= k &lt;= n &lt;= 30,000。</li><li>所给数据范围 [-10,000，10,000]。</li></ul><h2>解题思路</h2><p>比较简单的思路就是暴力解法，从头开始k个k个地算结果，最终比较出最大的结果即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//max中存储结果</span></span><br><span class="line">        <span class="keyword">double</span> max = -Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+k&lt;=nums.length)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+k;j++)&#123;</span><br><span class="line">                    temp += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">double</span>)temp/k &gt; max)&#123;</span><br><span class="line">                    max = (<span class="keyword">double</span>)temp/k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :430 ms, 在所有 Java 提交中击败了21.91%的用户</span><br><span class="line">内存消耗 :41.8 MB, 在所有 Java 提交中击败了22.89%的用户</span><br></pre></td></tr></table></figure><p>不过能不能优化下呢？很显然在循环中对于temp的求解发生了重复，其实更新的只是一头一尾的数据，中间还是一样的，那么借用滑动窗口的思想进行优化下。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先算出第一组的平均数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> max = (<span class="keyword">double</span>)sum/k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//计算窗口内的值，即i-k+1到i之间的数字，一直往后滑动</span></span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">double</span> res = (<span class="keyword">double</span>)sum/k;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; max)&#123;</span><br><span class="line">                max = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果得到了明显的提升，执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :7 ms, 在所有 Java 提交中击败了43.33%的用户</span><br><span class="line">内存消耗 :40.7 MB， 在所有 Java 提交中击败了76.93%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十九道题目是子数组最大平均数 I，对应leetcode的题号为643。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-028-三个数的最大乘积</title>
    <link href="http://yoursite.com/2020/02/04/leetcode-array/leetcode-028-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/02/04/leetcode-array/leetcode-028-三个数的最大乘积/</id>
    <published>2020-02-04T13:54:45.335Z</published>
    <updated>2020-02-04T13:59:32.054Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十八道题目是三个数的最大乘积，对应leetcode的题号为628。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</li><li>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</li></ul><h2>解题思路</h2><p>这个题目要注意还有负数的存在。那么首先排序，然后结果也只有两种情况，第一种情况就是最后的三个数相乘，第二种情况就是前面两个数和最后一个数相乘。</p><ol><li>考虑全是负数的情况：那么最大乘积就是最大的三个数之积</li><li>全是负数+一个零的情况:最大的乘积其实就是0，只要这个0参与计算就得到结果</li><li>考虑有负数有正数的情况：最大的乘积是最小的两个负数乘以最大的正数即可</li><li>考虑全是正数的情况：必然是最大的三个正数之积</li></ol><p>综上考虑，其实就是比较两种计算结果就可以得到最大乘积了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> lastIndex = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只需要考虑两种情况，从中取出最大值即可</span></span><br><span class="line">        <span class="keyword">int</span> res1 = (nums[<span class="number">0</span>])*(nums[<span class="number">1</span>])*((nums[lastIndex]));</span><br><span class="line">        <span class="keyword">int</span> res2 = (nums[lastIndex-<span class="number">2</span>])*(nums[lastIndex-<span class="number">1</span>])*(nums[lastIndex]);</span><br><span class="line">        <span class="keyword">return</span> res1&gt;res2 ? res1 : res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十八道题目是三个数的最大乘积，对应leetcode的题号为628。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-027-种花问题</title>
    <link href="http://yoursite.com/2020/02/02/leetcode-array/leetcode-027-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/02/leetcode-array/leetcode-027-种花问题/</id>
    <published>2020-02-02T13:31:19.089Z</published>
    <updated>2020-02-04T13:58:57.720Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十七道题目是种花问题，对应leetcode的题号为605。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>数组内已种好的花不会违反种植规则。</li><li>输入的数组长度范围为 [1, 20000]。</li><li>n 是非负整数，且不会超过输入数组的大小。</li></ul><h2>解题思路</h2><p>此题思路比较清晰，其实连续三个0的时候就可以种一朵花。即i-1,i,i+1这三个地方元素都是0才行，不过判断完之后需要将i位置元素置为1，否则会造成后续程序的错误判断。需要考虑下边界，尤其是i+1不要越界。</p><p>看到一个优化的思路，就是两边各加一个空花盆避免越界，简化代码。具体思路见代码注释。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化计数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//n=0表示不种花，那么必定符合条件，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑只有一个花盆的情况</span></span><br><span class="line">        <span class="keyword">if</span>(flowerbed.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑前两个花盆都是0的情况，判断了之后，第一个花盆置为1，否则会影响后续的判断</span></span><br><span class="line">        <span class="keyword">if</span>(flowerbed[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; flowerbed[<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            flowerbed[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑通用情况，只要i处可以放，就计数加一，并且将i处置为1，将这个花盆预占住</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;flowerbed.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i-<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i+<span class="number">1</span> &lt;= flowerbed.length-<span class="number">1</span> &amp;&amp; flowerbed[i+<span class="number">1</span>] == <span class="number">0</span>) || i+<span class="number">1</span> &gt; flowerbed.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//count与n比较，count小于等于n的时候就满足条件</span></span><br><span class="line">        <span class="keyword">return</span> n &lt;= count ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十七道题目是种花问题，对应leetcode的题号为605。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-026-最短无序连续子数组</title>
    <link href="http://yoursite.com/2020/01/31/leetcode-array/leetcode-026-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/31/leetcode-array/leetcode-026-最短无序连续子数组/</id>
    <published>2020-01-31T13:52:42.369Z</published>
    <updated>2020-02-04T13:56:45.120Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十六道题目是最短无序连续子数组，对应leetcode的题号为581。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure><p>说明 :</p><ul><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li></ul><h2>解题思路</h2><p>要找中间未排好序的子数组，其实可以将问题简化，假设我们有了一个排好序的数组，那么看下他们两者的差别就直到需要排序哪一段了。那么思路就很清晰了：重新整一个排好序的数组，两个数组开始一头一尾地比较，哪个不一样了那么就是需要排序的边界。两边边界一比较就出来答案了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拷贝一个一毛一样的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] newArray = Arrays.copyOf(nums,nums.length);</span><br><span class="line">        <span class="comment">//对新数组进行排序</span></span><br><span class="line">        Arrays.sort(newArray);</span><br><span class="line">        <span class="comment">//两个数组逐个对比，一个从头开始比直到不一样的那个数，一个从尾巴开始比直到不一样的那个数</span></span><br><span class="line">        <span class="comment">//这两个数的中间就是需要排序的区域</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != newArray[i])&#123;</span><br><span class="line">                low = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != newArray[i])&#123;</span><br><span class="line">                high = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high&gt;low ? high-low+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十六道题目是最短无序连续子数组，对应leetcode的题号为581。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-025-重塑矩阵</title>
    <link href="http://yoursite.com/2020/01/28/leetcode-array/leetcode-025-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/01/28/leetcode-array/leetcode-025-重塑矩阵/</id>
    <published>2020-01-28T14:32:50.983Z</published>
    <updated>2020-02-04T13:56:33.737Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十五道题目是重塑矩阵，对应leetcode的题号为566。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p><p>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</p><p>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</p><p>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>给定矩阵的宽和高范围在 [1, 100]。</li><li>给定的 r 和 c 都是正数。</li></ul><h2>解题思路</h2><p>基本思想就是遍历原数组，从上到下，从左到右遍历一遍，把所有元素逐个挪到一个新的数组中即可。因此要保证元素数量一样才能重塑，否则返回原数组。</p><p>那么我们只需要遍历原数组即可，一个一个地往新数组塞。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="comment">//判断是否能重塑</span></span><br><span class="line">        <span class="keyword">if</span>(r*c != nums.length * nums[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个新数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                arr[row][col] = nums[i][j];</span><br><span class="line">                <span class="comment">//如果变量col遍历到了最后一列，那么就换行再去从头开始赋值</span></span><br><span class="line">                <span class="keyword">if</span>(col == c-<span class="number">1</span>)&#123;</span><br><span class="line">                    row++;</span><br><span class="line">                    col = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    col++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十五道题目是重塑矩阵，对应leetcode的题号为566。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-024-数组拆分I</title>
    <link href="http://yoursite.com/2020/01/21/leetcode-array/leetcode-024-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/"/>
    <id>http://yoursite.com/2020/01/21/leetcode-array/leetcode-024-数组拆分I/</id>
    <published>2020-01-21T13:49:36.330Z</published>
    <updated>2020-02-04T13:56:20.182Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十四道题目是数组拆分 I，对应leetcode的题号为561。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>对应leetcode的题号为561。</p><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><p>提示:</p><ul><li>n 是正整数,范围在 [1, 10000].</li><li>数组中的元素范围在 [-10000, 10000].</li></ul><h2>解题思路</h2><p>这道题目最简单的思路其实不好想，看了题解才恍然大悟。</p><p>摘自评论区一个比较通俗的解释：</p><blockquote><p>这道题有点田忌赛马的影子，这道题的关键就是谁与谁组队相比较的问题，由于求最大的值，所以我们要尽可能的保留大的值，假如按照最大+最小，第二大+第二小，就会直接把最大和第二大的数舍去了，如果最大与第二大组队就可以保留第二大的数字，以此类推，我们只需要排序之后，相邻之间组队就可以留下最大的值</p></blockquote><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十四道题目是数组拆分 I，对应leetcode的题号为561。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-023-数组中的K-diff数对</title>
    <link href="http://yoursite.com/2020/01/18/leetcode-array/leetcode-023-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9/"/>
    <id>http://yoursite.com/2020/01/18/leetcode-array/leetcode-023-数组中的K-diff数对/</id>
    <published>2020-01-18T13:19:44.543Z</published>
    <updated>2020-01-18T13:20:16.145Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十三道题目是数组中的K-diff数对，对应leetcode的题号为532。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 1, 4, 1, 5], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:[1, 2, 3, 4, 5], k = 1</span><br><span class="line">输出: 4</span><br><span class="line">解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 3, 1, 5, 4], k = 0</span><br><span class="line">输出: 1</span><br><span class="line">解释: 数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li><li>数组的长度不超过10,000。</li><li>所有输入的整数的范围在 [-1e7, 1e7]。</li></ul><h2>解题思路</h2><p>这一题可以用两数之和的方法来做，比如当前数位i，那么我只要找到i+k的数字即可（这里好好想下要不要考虑i-k的情况 ^^，其实这里用加k就是巧妙地避开了重复性问题和相减可能是负数等问题）。具体见代码。</p><p>不过还有一种思路是先对数组进行排序，然后用两个指针去逐个寻找，利用与k的差值不停地移动左右两个指针。此方法实现上略显繁琐了，因为需要考虑连续重复数字的情况。代码直接从评论区复制而来。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试用例竟然出现了k=-1的情况...</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将所有的数字以及出现的次数保存到一个map中</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//与两数之和题目的思路一样，逐个去找相差k的数，为了避免重复，只需要找比自己大k的数字即可</span></span><br><span class="line">        <span class="comment">//这里需要特殊处理下k=0的情况，k=0说明需要找重复的数字有几对，那么就是找map中出现次数大于1的数字个数即可</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(index) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(index+k) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间上利用了一个map，因此空间复杂度为O(N)，时间上相当于遍历了两次数组，因此时间复杂度为O(N)。</p><p>排序+双指针的做法，是一个很棒的思路，加了点注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">//先对数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//左右指针，分别从0和1开始出发遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次都要保证right在left的右边，因此边界上只需要考虑right是否出界即可</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="comment">//计算差值与k进行比较，小于k那么right加一，大于k那么left加一，相等则同时加一并计数加一</span></span><br><span class="line">            <span class="keyword">int</span> t = nums[right] - nums[left];</span><br><span class="line">            <span class="keyword">if</span> (t &lt; k) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; k) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                right++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//排除连续相等的重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; len &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; left &lt; len &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//始终保证right在left的右边</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt;= left) &#123;</span><br><span class="line">                right = left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于存在排序，时间复杂度至少是O(NlogN)级别。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十三道题目是数组中的K-diff数对，对应leetcode的题号为532。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-022-斐波那契数</title>
    <link href="http://yoursite.com/2020/01/17/leetcode-array/leetcode-022-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/17/leetcode-array/leetcode-022-斐波那契数/</id>
    <published>2020-01-17T15:04:57.412Z</published>
    <updated>2020-01-18T13:19:26.903Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十二道题目是斐波那契数，对应leetcode的题号为509。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>给定 N，计算 F(N)。</p><p></p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure><p></p><p>提示：</p><p>0 ≤ N ≤ 30</p><h2>解题思路</h2><p>斐波那契数是我们的老朋友了，是一道经典的入门递归的题目。并且基于递归版本去改为非递归版本提高执行效率。递归版本很好写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span> || N == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(N-<span class="number">2</span>) + fib(N-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们知道递归的本质是调用了系统栈，优点是代码简洁，缺点是由于存在大量重复的计算，效率很低。本题的N最大为30还能不超时，再大点这个解法必超时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :11 ms, 在所有 Java 提交中击败了33.63%的用户</span><br><span class="line">内存消耗 :33 MB, 在所有 Java 提交中击败了37.58%的用户</span><br></pre></td></tr></table></figure><p>以下是完成斐波那契数计算的经典方法，用三个变量来承载前两个数字，从而计算出当前的数。就不再赘述分析啦。时间复杂度为O(n)，空间复杂度为O(1)。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span> || N == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十二道题目是斐波那契数，对应leetcode的题号为509。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-021-最大连续1的个数</title>
    <link href="http://yoursite.com/2020/01/17/leetcode-array/leetcode-021-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/17/leetcode-array/leetcode-021-最大连续1的个数/</id>
    <published>2020-01-17T14:42:21.076Z</published>
    <updated>2020-01-17T14:43:55.205Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十一道题目是最大连续1的个数，对应leetcode的题号为485。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个二进制数组， 计算其中最大连续1的个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,0,1,1,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入的数组只包含 0 和1。</span><br><span class="line">输入数组的长度是正整数，且不超过 10,000。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>这一题的思路就是遍历数组，如果为1就不停计数，遇到0就中断掉，不断记录计数值从而找出最大值。</p><ul><li>时间复杂度：O(N)。N 值是数组的长度。</li><li>空间复杂度：O(1)，仅仅使用了 count 和 max。</li></ul><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//max记录最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录连续1的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//为1就计数，否则就置零，中间不断比较记录最大个数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; max)&#123;</span><br><span class="line">                max = count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :3 ms, 在所有 Java 提交中击败了72.76%的用户</span><br><span class="line">内存消耗 :39.2 MB, 在所有 Java 提交中击败了94.95%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十一道题目是最大连续1的个数，对应leetcode的题号为485。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-020-找到所有数组中消失的数字</title>
    <link href="http://yoursite.com/2020/01/15/leetcode-array/leetcode-020-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/15/leetcode-array/leetcode-020-找到所有数组中消失的数字/</id>
    <published>2020-01-15T13:56:18.028Z</published>
    <updated>2020-01-15T13:56:50.240Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十道题目是找到所有数组中消失的数字，对应leetcode的题号为448。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>对应leetcode的题号为448。</p><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>一个比较简单的思路是用Set来去重，然后一一去找不存在的那个数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num=<span class="number">1</span>;num&lt;=nums.length;num++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num))&#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法需要遍历两次数组，时间复杂度显然是O(n)级别(<code>HashSet</code>是基于散列表实现的，元素没有顺序；<code>add</code>、<code>remove</code>、<code>contains</code>方法的时间复杂度为O(1))，空间复杂度也显然是O(n)级别。执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :34 ms, 在所有 Java 提交中击败了12.12%的用户</span><br><span class="line">内存消耗 :52.8 MB, 在所有 Java 提交中击败了78.32%的用户</span><br></pre></td></tr></table></figure><p>还可以用一个额外的标记数组来实现，即遍历原数组，然后将遍历的数字，对应到标记数组的索引处置为1，这样最后为0的元素就是原数组不存在的数字。不过题目要求不使用额外空间，如何来实现呢？</p><p>因为数组还是特殊的数组，是指定范围内的一串数字，中间有缺失的，也有重复的，那么对于这种类型的数组，我们还是可以利用数组索引来做。比如对于数字1，那么我们就在索引为(1-1)的地方做个标记表示这个数字存在；对于数字7，就在(7-1)的地方做个标记表示这个数字存在。那么可以很容易想到，对于某个不存在的数字比如5，那么对应(5-1)的地方一定是没有标记的，就很容易被找出来了。按照这个思想，我们就可以找到不用额外空间的解题思路。</p><p>以<code>[4,3,2,7,8,2,3,1]</code>为例，我们遍历数字，将其索引位置的数字置为负数。比如这里的4，那么我就将(4-1)处的数字置为相反数，即<code>[4,3,2,-7,8,2,3,1]</code>，第二步是3，那么数组变成<code>[4,3,-2,-7,8,2,3,1]</code>，第三步是2，数组变成<code>[4,-3,-2,-7,8,2,3,1]</code>；第四步是7，数组变成<code>[4,-3,-2,-7,8,2,-3,1]</code>；第五步是8，数组变成<code>[4,-3,-2,-7,8,2,-3,-1]</code>；第六步是2，这个时候是关键，因为2之前出现过并且已经将索引(2-1)的地方置为相反数了，此时不需要再取相反数；第七步是-3，这个时候也是关键，我们取的实际上还是3，即绝对值，然后发现索引(3-1)处已经是负数了就不去相反数；最后的-1也是同理。</p><p>所以为什么这里取相反数，实际上就是因为我们既要用负数来标记，也需要可以取绝对值从而得到原数组中的原来的值来继续判断，因此相反数是最合适的一个选择了。时间复杂度明显是O(n)，空间复杂度为O(1)。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//根据元素的绝对值找到对应的数组索引下标，注意要减一，因为数字是从1开始，而索引是从0开始</span></span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果发现索引处的元素大于零就取相反数，否则就不要再动了</span></span><br><span class="line">            <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[index] = nums[index] * (-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面走完以后，只要出现过的数字，那么对应的索引一定是负数；反之为正数的说明为不存在的数字，挑出来即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :9 ms, 在所有 Java 提交中击败了48.07%的用户</span><br><span class="line">内存消耗 :48.5 MB, 在所有 Java 提交中击败了90.51%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十道题目是找到所有数组中消失的数字，对应leetcode的题号为448。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-019-第三大的数</title>
    <link href="http://yoursite.com/2020/01/14/leetcode-array/leetcode-019-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/14/leetcode-array/leetcode-019-第三大的数/</id>
    <published>2020-01-14T14:06:14.708Z</published>
    <updated>2020-01-14T14:09:52.615Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十九道题目是第三大的数，对应leetcode的题号为414。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 第三大的数是 1.</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 第三大的数不存在, 所以返回最大的数 2 .</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><br></pre></td></tr></table></figure><p>存在两个值为2的数，它们都排第二。</p><h2>解题思路</h2><p>思路一：</p><ol><li>维护一个只有3个元素的TreeSet，如果大于三个元素就就把Set中的最小最小值remove掉。</li><li>最后如果Set中元素小于3就返回Set最大值，否则返回最小值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer elem : nums) &#123;</span><br><span class="line">            set.add(elem);</span><br><span class="line">            <span class="keyword">if</span> (set.size() &gt; <span class="number">3</span>) set.remove(set.first());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> set.size() &lt; <span class="number">3</span> ? set.last() : set.first();   <span class="comment">// set.last() 里面最大的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><ol><li>用三个变量来存放第一大，第二大，第三大的元素的变量，分别为one, two, three，初始化为Integer.MIN_VALUE；</li><li>遍历数组，若该元素比one大则往后顺移一个元素，比two大则往往后顺移一个元素，比three大则赋值个three；</li><li>最后得到第三大的元素，若没有则返回第一大的元素。</li></ol><p>其中需要一个细节，就是如下示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2]输出2</span><br></pre></td></tr></table></figure><p>这个可以理解，因为有效的只有1和2，那么按照题意没有第三大的数字就返回最大的元素即可。不过当出现下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,-2147483648]输出-2147483648</span><br></pre></td></tr></table></figure><p>也可以理解，因为-2147483648确实就是第三大数字，不过这个数字比较特殊，是java的整型类型最小的数字，即<code>Integer.MIN_VALUE</code>，那么如果不对这个数字做个处理，而是简单粗暴地判断第三大元素是<code>Integer.MIN_VALUE</code>就会出错。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//只有一个元素的时候，没有第三大的数字，直接返回唯一的元素即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有两个数组的时候，也没有第三大的数字，直接返回最大值即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一大数字</span></span><br><span class="line">        <span class="keyword">int</span> firstMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//第二大数字</span></span><br><span class="line">        <span class="keyword">int</span> secondMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//第三大数字</span></span><br><span class="line">        <span class="keyword">int</span> thirdMax = Integer.MIN_VALUE; </span><br><span class="line">        <span class="comment">//计数，看实际不一样的数字有几个</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//其中需要注意数组是否出现过Integer.MIN_VALUE，出现过就count++下，只要加一次</span></span><br><span class="line">        <span class="keyword">boolean</span> minflag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == Integer.MIN_VALUE &amp;&amp; minflag)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                minflag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; firstMax)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                thirdMax = secondMax;</span><br><span class="line">                secondMax = firstMax;</span><br><span class="line">                firstMax = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != firstMax &amp;&amp; nums[i] &gt; secondMax)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                thirdMax = secondMax;</span><br><span class="line">                secondMax = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != firstMax &amp;&amp; nums[i] != secondMax &amp;&amp; nums[i] &gt; thirdMax)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                thirdMax = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当计数大于3时，说明数组有有效的第三大数字，返回thirdmax即可，否则返回数组的最大值即可</span></span><br><span class="line">        <span class="keyword">return</span> count &gt;= <span class="number">3</span> ? thirdMax : firstMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十九道题目是第三大的数，对应leetcode的题号为414。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-018-移动零</title>
    <link href="http://yoursite.com/2020/01/13/leetcode-array/leetcode-018-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/01/13/leetcode-array/leetcode-018-移动零/</id>
    <published>2020-01-13T13:57:09.425Z</published>
    <updated>2020-01-13T14:04:11.523Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十八道题目是移动零，对应leetcode的题号为283。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p>说明:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h2>解题思路</h2><p>一个简单的思路是复制一个等长的数组，然后前面放非零元素即可，不过题目说明不能拷贝额外的数组空间。那么其实没有这个辅助数组，按照这个思想也是一样的。</p><p>我们只需要遍历数组，把非零元素逐个往前面放即可，最后没有放满的地方全部赋予零即可。这样既保证了非零元素的相对顺序，又不需要开拓新数组。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length)&#123;</span><br><span class="line">            nums[j++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗 :37.8 MB, 在所有 Java 提交中击败了95.42%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十八道题目是移动零，对应leetcode的题号为283。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-017-缺失数字</title>
    <link href="http://yoursite.com/2020/01/12/leetcode-array/leetcode-017-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/12/leetcode-array/leetcode-017-缺失数字/</id>
    <published>2020-01-12T07:32:41.470Z</published>
    <updated>2020-01-15T14:01:23.604Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十七道题目是存在缺失数字，对应leetcode的题号为268。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 … n 中没有出现在序列中的那个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>首先这道题目一定要先明确数组的定义，这个数组很特别，是[0,1,2…n]这种数组，虽然是乱序的，但是数组一旦排序后就是很紧凑的逐一增加的数组，只不过中间一定少一个元素，我们需要找出来。</p><p>那么显然，常规思路是对数组进行排序，然后逐一比较相邻的两个数只差是否为1，也可以用索引下标去判断是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] != i)&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums.length;</span><br></pre></td></tr></table></figure><p>或者也可以用map来做，首先全部装进map中，然后根据数组的特性，遍历i=0到i=nums.length，如果其中遍历不到的数字，就是我们要返回的不存在的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) set.add(nums[i]);   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)</span><br><span class="line">    <span class="keyword">if</span>(!set.contains(i))&#123;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>不过这么特殊的数组，一定是有特殊的解法的，仔细想想，以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4，3，0，1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>为例，其索引是[0,1,2,3]，那么我们可以根据异或的思想来做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 1 = 0</span><br><span class="line">0 ^ 1 = 1</span><br></pre></td></tr></table></figure><p>那么[4,3,0,1]和[0,1,2,3]做异或，其实可以分解为：3 ^ 3，0 ^ 0，1 ^ 1，我们只需要想办法把4给异或掉，那么就剩下了2，那么结果就是2了（下面主要还是考虑正常情况，如果出现的数组为[0,1,2,3]这种不缺的，那么程序会返回4，这点可以根据情况去斟酌改变，不过不影响核心思想，不必纠结）。</p><p>对于[4,3,0,1]这个数组，我们第一步就用nums.length去和4做抵消。因为数组中最大的数字按照题意必然就是n。</p><p>好了，此时其他所有的n-1个数都互相抵消了，自然就剩下缺失的那个数字了，再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p>数组为[9,6,4,2,3,5,7,0,1]，索引数组为[0,1,2,3,4,5,6,7,8,9]，那么第一步是9 ^ 9=0，然后1，2，3，4，5，6，7都可以找到对应的索引异或掉，最终就剩下8了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果遇到0-n都存在的情况，这里就直接返回n+1这个数字即可，因为这种情况题目没有说明如果返回</span></span><br><span class="line">        <span class="keyword">int</span> res = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :1 ms, 在所有 Java 提交中击败了91.92%的用户</span><br><span class="line">内存消耗 :39.6 MB, 在所有 Java 提交中击败了96.09%的用户</span><br></pre></td></tr></table></figure><p>还有一种方法是加减，其实思想跟异或是一样的思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十七道题目是存在缺失数字，对应leetcode的题号为268。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
