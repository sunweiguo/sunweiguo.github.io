<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>但行好事，莫问前程；前路有光，莫忘初心。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-05T12:19:30.254Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-029-子数组最大平均数 I</title>
    <link href="http://yoursite.com/2020/02/05/leetcode-array/leetcode-029-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I/"/>
    <id>http://yoursite.com/2020/02/05/leetcode-array/leetcode-029-子数组最大平均数 I/</id>
    <published>2020-02-05T12:19:22.937Z</published>
    <updated>2020-02-05T12:19:30.254Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十九道题目是子数组最大平均数 I，对应leetcode的题号为643。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出: 12.75</span><br><span class="line">解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>1 &lt;= k &lt;= n &lt;= 30,000。</li><li>所给数据范围 [-10,000，10,000]。</li></ul><h2>解题思路</h2><p>比较简单的思路就是暴力解法，从头开始k个k个地算结果，最终比较出最大的结果即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//max中存储结果</span></span><br><span class="line">        <span class="keyword">double</span> max = -Double.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+k&lt;=nums.length)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+k;j++)&#123;</span><br><span class="line">                    temp += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">double</span>)temp/k &gt; max)&#123;</span><br><span class="line">                    max = (<span class="keyword">double</span>)temp/k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :430 ms, 在所有 Java 提交中击败了21.91%的用户</span><br><span class="line">内存消耗 :41.8 MB, 在所有 Java 提交中击败了22.89%的用户</span><br></pre></td></tr></table></figure><p>不过能不能优化下呢？很显然在循环中对于temp的求解发生了重复，其实更新的只是一头一尾的数据，中间还是一样的，那么借用滑动窗口的思想进行优化下。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先算出第一组的平均数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> max = (<span class="keyword">double</span>)sum/k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//计算窗口内的值，即i-k+1到i之间的数字，一直往后滑动</span></span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">double</span> res = (<span class="keyword">double</span>)sum/k;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; max)&#123;</span><br><span class="line">                max = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果得到了明显的提升，执行的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :7 ms, 在所有 Java 提交中击败了43.33%的用户</span><br><span class="line">内存消耗 :40.7 MB， 在所有 Java 提交中击败了76.93%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十九道题目是子数组最大平均数 I，对应leetcode的题号为643。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-028-三个数的最大乘积</title>
    <link href="http://yoursite.com/2020/02/04/leetcode-array/leetcode-028-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"/>
    <id>http://yoursite.com/2020/02/04/leetcode-array/leetcode-028-三个数的最大乘积/</id>
    <published>2020-02-04T13:54:45.335Z</published>
    <updated>2020-02-04T13:59:32.054Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十八道题目是三个数的最大乘积，对应leetcode的题号为628。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</li><li>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</li></ul><h2>解题思路</h2><p>这个题目要注意还有负数的存在。那么首先排序，然后结果也只有两种情况，第一种情况就是最后的三个数相乘，第二种情况就是前面两个数和最后一个数相乘。</p><ol><li>考虑全是负数的情况：那么最大乘积就是最大的三个数之积</li><li>全是负数+一个零的情况:最大的乘积其实就是0，只要这个0参与计算就得到结果</li><li>考虑有负数有正数的情况：最大的乘积是最小的两个负数乘以最大的正数即可</li><li>考虑全是正数的情况：必然是最大的三个正数之积</li></ol><p>综上考虑，其实就是比较两种计算结果就可以得到最大乘积了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> lastIndex = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//只需要考虑两种情况，从中取出最大值即可</span></span><br><span class="line">        <span class="keyword">int</span> res1 = (nums[<span class="number">0</span>])*(nums[<span class="number">1</span>])*((nums[lastIndex]));</span><br><span class="line">        <span class="keyword">int</span> res2 = (nums[lastIndex-<span class="number">2</span>])*(nums[lastIndex-<span class="number">1</span>])*(nums[lastIndex]);</span><br><span class="line">        <span class="keyword">return</span> res1&gt;res2 ? res1 : res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十八道题目是三个数的最大乘积，对应leetcode的题号为628。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-027-种花问题</title>
    <link href="http://yoursite.com/2020/02/02/leetcode-array/leetcode-027-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/02/leetcode-array/leetcode-027-种花问题/</id>
    <published>2020-02-02T13:31:19.089Z</published>
    <updated>2020-02-04T13:58:57.720Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十七道题目是种花问题，对应leetcode的题号为605。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>数组内已种好的花不会违反种植规则。</li><li>输入的数组长度范围为 [1, 20000]。</li><li>n 是非负整数，且不会超过输入数组的大小。</li></ul><h2>解题思路</h2><p>此题思路比较清晰，其实连续三个0的时候就可以种一朵花。即i-1,i,i+1这三个地方元素都是0才行，不过判断完之后需要将i位置元素置为1，否则会造成后续程序的错误判断。需要考虑下边界，尤其是i+1不要越界。</p><p>看到一个优化的思路，就是两边各加一个空花盆避免越界，简化代码。具体思路见代码注释。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化计数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//n=0表示不种花，那么必定符合条件，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑只有一个花盆的情况</span></span><br><span class="line">        <span class="keyword">if</span>(flowerbed.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑前两个花盆都是0的情况，判断了之后，第一个花盆置为1，否则会影响后续的判断</span></span><br><span class="line">        <span class="keyword">if</span>(flowerbed[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; flowerbed[<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            flowerbed[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑通用情况，只要i处可以放，就计数加一，并且将i处置为1，将这个花盆预占住</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;flowerbed.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i-<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i+<span class="number">1</span> &lt;= flowerbed.length-<span class="number">1</span> &amp;&amp; flowerbed[i+<span class="number">1</span>] == <span class="number">0</span>) || i+<span class="number">1</span> &gt; flowerbed.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//count与n比较，count小于等于n的时候就满足条件</span></span><br><span class="line">        <span class="keyword">return</span> n &lt;= count ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十七道题目是种花问题，对应leetcode的题号为605。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-026-最短无序连续子数组</title>
    <link href="http://yoursite.com/2020/01/31/leetcode-array/leetcode-026-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/31/leetcode-array/leetcode-026-最短无序连续子数组/</id>
    <published>2020-01-31T13:52:42.369Z</published>
    <updated>2020-02-04T13:56:45.120Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十六道题目是最短无序连续子数组，对应leetcode的题号为581。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是最短的，请输出它的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure><p>说明 :</p><ul><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li></ul><h2>解题思路</h2><p>要找中间未排好序的子数组，其实可以将问题简化，假设我们有了一个排好序的数组，那么看下他们两者的差别就直到需要排序哪一段了。那么思路就很清晰了：重新整一个排好序的数组，两个数组开始一头一尾地比较，哪个不一样了那么就是需要排序的边界。两边边界一比较就出来答案了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拷贝一个一毛一样的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] newArray = Arrays.copyOf(nums,nums.length);</span><br><span class="line">        <span class="comment">//对新数组进行排序</span></span><br><span class="line">        Arrays.sort(newArray);</span><br><span class="line">        <span class="comment">//两个数组逐个对比，一个从头开始比直到不一样的那个数，一个从尾巴开始比直到不一样的那个数</span></span><br><span class="line">        <span class="comment">//这两个数的中间就是需要排序的区域</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != newArray[i])&#123;</span><br><span class="line">                low = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != newArray[i])&#123;</span><br><span class="line">                high = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high&gt;low ? high-low+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十六道题目是最短无序连续子数组，对应leetcode的题号为581。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-025-重塑矩阵</title>
    <link href="http://yoursite.com/2020/01/28/leetcode-array/leetcode-025-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/2020/01/28/leetcode-array/leetcode-025-重塑矩阵/</id>
    <published>2020-01-28T14:32:50.983Z</published>
    <updated>2020-02-04T13:56:33.737Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十五道题目是重塑矩阵，对应leetcode的题号为566。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p><p>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</p><p>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</p><p>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>给定矩阵的宽和高范围在 [1, 100]。</li><li>给定的 r 和 c 都是正数。</li></ul><h2>解题思路</h2><p>基本思想就是遍历原数组，从上到下，从左到右遍历一遍，把所有元素逐个挪到一个新的数组中即可。因此要保证元素数量一样才能重塑，否则返回原数组。</p><p>那么我们只需要遍历原数组即可，一个一个地往新数组塞。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="comment">//判断是否能重塑</span></span><br><span class="line">        <span class="keyword">if</span>(r*c != nums.length * nums[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个新数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                arr[row][col] = nums[i][j];</span><br><span class="line">                <span class="comment">//如果变量col遍历到了最后一列，那么就换行再去从头开始赋值</span></span><br><span class="line">                <span class="keyword">if</span>(col == c-<span class="number">1</span>)&#123;</span><br><span class="line">                    row++;</span><br><span class="line">                    col = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    col++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十五道题目是重塑矩阵，对应leetcode的题号为566。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-024-数组拆分I</title>
    <link href="http://yoursite.com/2020/01/21/leetcode-array/leetcode-024-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/"/>
    <id>http://yoursite.com/2020/01/21/leetcode-array/leetcode-024-数组拆分I/</id>
    <published>2020-01-21T13:49:36.330Z</published>
    <updated>2020-02-04T13:56:20.182Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十四道题目是数组拆分 I，对应leetcode的题号为561。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>对应leetcode的题号为561。</p><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><p>提示:</p><ul><li>n 是正整数,范围在 [1, 10000].</li><li>数组中的元素范围在 [-10000, 10000].</li></ul><h2>解题思路</h2><p>这道题目最简单的思路其实不好想，看了题解才恍然大悟。</p><p>摘自评论区一个比较通俗的解释：</p><blockquote><p>这道题有点田忌赛马的影子，这道题的关键就是谁与谁组队相比较的问题，由于求最大的值，所以我们要尽可能的保留大的值，假如按照最大+最小，第二大+第二小，就会直接把最大和第二大的数舍去了，如果最大与第二大组队就可以保留第二大的数字，以此类推，我们只需要排序之后，相邻之间组队就可以留下最大的值</p></blockquote><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十四道题目是数组拆分 I，对应leetcode的题号为561。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-023-数组中的K-diff数对</title>
    <link href="http://yoursite.com/2020/01/18/leetcode-array/leetcode-023-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9/"/>
    <id>http://yoursite.com/2020/01/18/leetcode-array/leetcode-023-数组中的K-diff数对/</id>
    <published>2020-01-18T13:19:44.543Z</published>
    <updated>2020-01-18T13:20:16.145Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十三道题目是数组中的K-diff数对，对应leetcode的题号为532。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 1, 4, 1, 5], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:[1, 2, 3, 4, 5], k = 1</span><br><span class="line">输出: 4</span><br><span class="line">解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 3, 1, 5, 4], k = 0</span><br><span class="line">输出: 1</span><br><span class="line">解释: 数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li><li>数组的长度不超过10,000。</li><li>所有输入的整数的范围在 [-1e7, 1e7]。</li></ul><h2>解题思路</h2><p>这一题可以用两数之和的方法来做，比如当前数位i，那么我只要找到i+k的数字即可（这里好好想下要不要考虑i-k的情况 ^^，其实这里用加k就是巧妙地避开了重复性问题和相减可能是负数等问题）。具体见代码。</p><p>不过还有一种思路是先对数组进行排序，然后用两个指针去逐个寻找，利用与k的差值不停地移动左右两个指针。此方法实现上略显繁琐了，因为需要考虑连续重复数字的情况。代码直接从评论区复制而来。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试用例竟然出现了k=-1的情况...</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将所有的数字以及出现的次数保存到一个map中</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//与两数之和题目的思路一样，逐个去找相差k的数，为了避免重复，只需要找比自己大k的数字即可</span></span><br><span class="line">        <span class="comment">//这里需要特殊处理下k=0的情况，k=0说明需要找重复的数字有几对，那么就是找map中出现次数大于1的数字个数即可</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(index) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(index+k) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间上利用了一个map，因此空间复杂度为O(N)，时间上相当于遍历了两次数组，因此时间复杂度为O(N)。</p><p>排序+双指针的做法，是一个很棒的思路，加了点注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">//先对数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//左右指针，分别从0和1开始出发遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次都要保证right在left的右边，因此边界上只需要考虑right是否出界即可</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="comment">//计算差值与k进行比较，小于k那么right加一，大于k那么left加一，相等则同时加一并计数加一</span></span><br><span class="line">            <span class="keyword">int</span> t = nums[right] - nums[left];</span><br><span class="line">            <span class="keyword">if</span> (t &lt; k) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; k) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                right++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//排除连续相等的重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; len &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; left &lt; len &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//始终保证right在left的右边</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt;= left) &#123;</span><br><span class="line">                right = left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于存在排序，时间复杂度至少是O(NlogN)级别。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十三道题目是数组中的K-diff数对，对应leetcode的题号为532。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-022-斐波那契数</title>
    <link href="http://yoursite.com/2020/01/17/leetcode-array/leetcode-022-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/17/leetcode-array/leetcode-022-斐波那契数/</id>
    <published>2020-01-17T15:04:57.412Z</published>
    <updated>2020-01-18T13:19:26.903Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十二道题目是斐波那契数，对应leetcode的题号为509。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>给定 N，计算 F(N)。</p><p></p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2.</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3.</span><br></pre></td></tr></table></figure><p></p><p>提示：</p><p>0 ≤ N ≤ 30</p><h2>解题思路</h2><p>斐波那契数是我们的老朋友了，是一道经典的入门递归的题目。并且基于递归版本去改为非递归版本提高执行效率。递归版本很好写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span> || N == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(N-<span class="number">2</span>) + fib(N-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我们知道递归的本质是调用了系统栈，优点是代码简洁，缺点是由于存在大量重复的计算，效率很低。本题的N最大为30还能不超时，再大点这个解法必超时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :11 ms, 在所有 Java 提交中击败了33.63%的用户</span><br><span class="line">内存消耗 :33 MB, 在所有 Java 提交中击败了37.58%的用户</span><br></pre></td></tr></table></figure><p>以下是完成斐波那契数计算的经典方法，用三个变量来承载前两个数字，从而计算出当前的数。就不再赘述分析啦。时间复杂度为O(n)，空间复杂度为O(1)。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(N &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span> || N == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十二道题目是斐波那契数，对应leetcode的题号为509。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-021-最大连续1的个数</title>
    <link href="http://yoursite.com/2020/01/17/leetcode-array/leetcode-021-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/17/leetcode-array/leetcode-021-最大连续1的个数/</id>
    <published>2020-01-17T14:42:21.076Z</published>
    <updated>2020-01-17T14:43:55.205Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十一道题目是最大连续1的个数，对应leetcode的题号为485。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个二进制数组， 计算其中最大连续1的个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,0,1,1,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入的数组只包含 0 和1。</span><br><span class="line">输入数组的长度是正整数，且不超过 10,000。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>这一题的思路就是遍历数组，如果为1就不停计数，遇到0就中断掉，不断记录计数值从而找出最大值。</p><ul><li>时间复杂度：O(N)。N 值是数组的长度。</li><li>空间复杂度：O(1)，仅仅使用了 count 和 max。</li></ul><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//max记录最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录连续1的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//为1就计数，否则就置零，中间不断比较记录最大个数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; max)&#123;</span><br><span class="line">                max = count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :3 ms, 在所有 Java 提交中击败了72.76%的用户</span><br><span class="line">内存消耗 :39.2 MB, 在所有 Java 提交中击败了94.95%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十一道题目是最大连续1的个数，对应leetcode的题号为485。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-020-找到所有数组中消失的数字</title>
    <link href="http://yoursite.com/2020/01/15/leetcode-array/leetcode-020-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/15/leetcode-array/leetcode-020-找到所有数组中消失的数字/</id>
    <published>2020-01-15T13:56:18.028Z</published>
    <updated>2020-01-15T13:56:50.240Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第二十道题目是找到所有数组中消失的数字，对应leetcode的题号为448。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>对应leetcode的题号为448。</p><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>一个比较简单的思路是用Set来去重，然后一一去找不存在的那个数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num=<span class="number">1</span>;num&lt;=nums.length;num++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num))&#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法需要遍历两次数组，时间复杂度显然是O(n)级别(<code>HashSet</code>是基于散列表实现的，元素没有顺序；<code>add</code>、<code>remove</code>、<code>contains</code>方法的时间复杂度为O(1))，空间复杂度也显然是O(n)级别。执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :34 ms, 在所有 Java 提交中击败了12.12%的用户</span><br><span class="line">内存消耗 :52.8 MB, 在所有 Java 提交中击败了78.32%的用户</span><br></pre></td></tr></table></figure><p>还可以用一个额外的标记数组来实现，即遍历原数组，然后将遍历的数字，对应到标记数组的索引处置为1，这样最后为0的元素就是原数组不存在的数字。不过题目要求不使用额外空间，如何来实现呢？</p><p>因为数组还是特殊的数组，是指定范围内的一串数字，中间有缺失的，也有重复的，那么对于这种类型的数组，我们还是可以利用数组索引来做。比如对于数字1，那么我们就在索引为(1-1)的地方做个标记表示这个数字存在；对于数字7，就在(7-1)的地方做个标记表示这个数字存在。那么可以很容易想到，对于某个不存在的数字比如5，那么对应(5-1)的地方一定是没有标记的，就很容易被找出来了。按照这个思想，我们就可以找到不用额外空间的解题思路。</p><p>以<code>[4,3,2,7,8,2,3,1]</code>为例，我们遍历数字，将其索引位置的数字置为负数。比如这里的4，那么我就将(4-1)处的数字置为相反数，即<code>[4,3,2,-7,8,2,3,1]</code>，第二步是3，那么数组变成<code>[4,3,-2,-7,8,2,3,1]</code>，第三步是2，数组变成<code>[4,-3,-2,-7,8,2,3,1]</code>；第四步是7，数组变成<code>[4,-3,-2,-7,8,2,-3,1]</code>；第五步是8，数组变成<code>[4,-3,-2,-7,8,2,-3,-1]</code>；第六步是2，这个时候是关键，因为2之前出现过并且已经将索引(2-1)的地方置为相反数了，此时不需要再取相反数；第七步是-3，这个时候也是关键，我们取的实际上还是3，即绝对值，然后发现索引(3-1)处已经是负数了就不去相反数；最后的-1也是同理。</p><p>所以为什么这里取相反数，实际上就是因为我们既要用负数来标记，也需要可以取绝对值从而得到原数组中的原来的值来继续判断，因此相反数是最合适的一个选择了。时间复杂度明显是O(n)，空间复杂度为O(1)。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//根据元素的绝对值找到对应的数组索引下标，注意要减一，因为数字是从1开始，而索引是从0开始</span></span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果发现索引处的元素大于零就取相反数，否则就不要再动了</span></span><br><span class="line">            <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[index] = nums[index] * (-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面走完以后，只要出现过的数字，那么对应的索引一定是负数；反之为正数的说明为不存在的数字，挑出来即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :9 ms, 在所有 Java 提交中击败了48.07%的用户</span><br><span class="line">内存消耗 :48.5 MB, 在所有 Java 提交中击败了90.51%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第二十道题目是找到所有数组中消失的数字，对应leetcode的题号为448。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-019-第三大的数</title>
    <link href="http://yoursite.com/2020/01/14/leetcode-array/leetcode-019-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
    <id>http://yoursite.com/2020/01/14/leetcode-array/leetcode-019-第三大的数/</id>
    <published>2020-01-14T14:06:14.708Z</published>
    <updated>2020-01-14T14:09:52.615Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十九道题目是第三大的数，对应leetcode的题号为414。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 第三大的数是 1.</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 第三大的数不存在, 所以返回最大的数 2 .</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><br></pre></td></tr></table></figure><p>存在两个值为2的数，它们都排第二。</p><h2>解题思路</h2><p>思路一：</p><ol><li>维护一个只有3个元素的TreeSet，如果大于三个元素就就把Set中的最小最小值remove掉。</li><li>最后如果Set中元素小于3就返回Set最大值，否则返回最小值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer elem : nums) &#123;</span><br><span class="line">            set.add(elem);</span><br><span class="line">            <span class="keyword">if</span> (set.size() &gt; <span class="number">3</span>) set.remove(set.first());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> set.size() &lt; <span class="number">3</span> ? set.last() : set.first();   <span class="comment">// set.last() 里面最大的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：</p><ol><li>用三个变量来存放第一大，第二大，第三大的元素的变量，分别为one, two, three，初始化为Integer.MIN_VALUE；</li><li>遍历数组，若该元素比one大则往后顺移一个元素，比two大则往往后顺移一个元素，比three大则赋值个three；</li><li>最后得到第三大的元素，若没有则返回第一大的元素。</li></ol><p>其中需要一个细节，就是如下示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2]输出2</span><br></pre></td></tr></table></figure><p>这个可以理解，因为有效的只有1和2，那么按照题意没有第三大的数字就返回最大的元素即可。不过当出现下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,-2147483648]输出-2147483648</span><br></pre></td></tr></table></figure><p>也可以理解，因为-2147483648确实就是第三大数字，不过这个数字比较特殊，是java的整型类型最小的数字，即<code>Integer.MIN_VALUE</code>，那么如果不对这个数字做个处理，而是简单粗暴地判断第三大元素是<code>Integer.MIN_VALUE</code>就会出错。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//只有一个元素的时候，没有第三大的数字，直接返回唯一的元素即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有两个数组的时候，也没有第三大的数字，直接返回最大值即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一大数字</span></span><br><span class="line">        <span class="keyword">int</span> firstMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//第二大数字</span></span><br><span class="line">        <span class="keyword">int</span> secondMax = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//第三大数字</span></span><br><span class="line">        <span class="keyword">int</span> thirdMax = Integer.MIN_VALUE; </span><br><span class="line">        <span class="comment">//计数，看实际不一样的数字有几个</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//其中需要注意数组是否出现过Integer.MIN_VALUE，出现过就count++下，只要加一次</span></span><br><span class="line">        <span class="keyword">boolean</span> minflag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == Integer.MIN_VALUE &amp;&amp; minflag)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                minflag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; firstMax)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                thirdMax = secondMax;</span><br><span class="line">                secondMax = firstMax;</span><br><span class="line">                firstMax = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != firstMax &amp;&amp; nums[i] &gt; secondMax)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                thirdMax = secondMax;</span><br><span class="line">                secondMax = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] != firstMax &amp;&amp; nums[i] != secondMax &amp;&amp; nums[i] &gt; thirdMax)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                thirdMax = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当计数大于3时，说明数组有有效的第三大数字，返回thirdmax即可，否则返回数组的最大值即可</span></span><br><span class="line">        <span class="keyword">return</span> count &gt;= <span class="number">3</span> ? thirdMax : firstMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十九道题目是第三大的数，对应leetcode的题号为414。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-018-移动零</title>
    <link href="http://yoursite.com/2020/01/13/leetcode-array/leetcode-018-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>http://yoursite.com/2020/01/13/leetcode-array/leetcode-018-移动零/</id>
    <published>2020-01-13T13:57:09.425Z</published>
    <updated>2020-01-13T14:04:11.523Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十八道题目是移动零，对应leetcode的题号为283。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p>说明:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h2>解题思路</h2><p>一个简单的思路是复制一个等长的数组，然后前面放非零元素即可，不过题目说明不能拷贝额外的数组空间。那么其实没有这个辅助数组，按照这个思想也是一样的。</p><p>我们只需要遍历数组，把非零元素逐个往前面放即可，最后没有放满的地方全部赋予零即可。这样既保证了非零元素的相对顺序，又不需要开拓新数组。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums.length)&#123;</span><br><span class="line">            nums[j++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户</span><br><span class="line">内存消耗 :37.8 MB, 在所有 Java 提交中击败了95.42%的用户</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十八道题目是移动零，对应leetcode的题号为283。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-017-缺失数字</title>
    <link href="http://yoursite.com/2020/01/12/leetcode-array/leetcode-017-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/01/12/leetcode-array/leetcode-017-缺失数字/</id>
    <published>2020-01-12T07:32:41.470Z</published>
    <updated>2020-01-15T14:01:23.604Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十七道题目是存在缺失数字，对应leetcode的题号为268。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 … n 中没有出现在序列中的那个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>首先这道题目一定要先明确数组的定义，这个数组很特别，是[0,1,2…n]这种数组，虽然是乱序的，但是数组一旦排序后就是很紧凑的逐一增加的数组，只不过中间一定少一个元素，我们需要找出来。</p><p>那么显然，常规思路是对数组进行排序，然后逐一比较相邻的两个数只差是否为1，也可以用索引下标去判断是否存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] != i)&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums.length;</span><br></pre></td></tr></table></figure><p>或者也可以用map来做，首先全部装进map中，然后根据数组的特性，遍历i=0到i=nums.length，如果其中遍历不到的数字，就是我们要返回的不存在的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) set.add(nums[i]);   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length; i++)</span><br><span class="line">    <span class="keyword">if</span>(!set.contains(i))&#123;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>不过这么特殊的数组，一定是有特殊的解法的，仔细想想，以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4，3，0，1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>为例，其索引是[0,1,2,3]，那么我们可以根据异或的思想来做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 1 = 0</span><br><span class="line">0 ^ 1 = 1</span><br></pre></td></tr></table></figure><p>那么[4,3,0,1]和[0,1,2,3]做异或，其实可以分解为：3 ^ 3，0 ^ 0，1 ^ 1，我们只需要想办法把4给异或掉，那么就剩下了2，那么结果就是2了（下面主要还是考虑正常情况，如果出现的数组为[0,1,2,3]这种不缺的，那么程序会返回4，这点可以根据情况去斟酌改变，不过不影响核心思想，不必纠结）。</p><p>对于[4,3,0,1]这个数组，我们第一步就用nums.length去和4做抵消。因为数组中最大的数字按照题意必然就是n。</p><p>好了，此时其他所有的n-1个数都互相抵消了，自然就剩下缺失的那个数字了，再举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p>数组为[9,6,4,2,3,5,7,0,1]，索引数组为[0,1,2,3,4,5,6,7,8,9]，那么第一步是9 ^ 9=0，然后1，2，3，4，5，6，7都可以找到对应的索引异或掉，最终就剩下8了。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果遇到0-n都存在的情况，这里就直接返回n+1这个数字即可，因为这种情况题目没有说明如果返回</span></span><br><span class="line">        <span class="keyword">int</span> res = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :1 ms, 在所有 Java 提交中击败了91.92%的用户</span><br><span class="line">内存消耗 :39.6 MB, 在所有 Java 提交中击败了96.09%的用户</span><br></pre></td></tr></table></figure><p>还有一种方法是加减，其实思想跟异或是一样的思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十七道题目是存在缺失数字，对应leetcode的题号为268。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-016-存在重复元素2</title>
    <link href="http://yoursite.com/2020/01/12/leetcode-array/leetcode-016-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/"/>
    <id>http://yoursite.com/2020/01/12/leetcode-array/leetcode-016-存在重复元素2/</id>
    <published>2020-01-12T06:28:19.665Z</published>
    <updated>2020-01-12T06:28:30.621Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十六道题目是存在重复元素2，对应leetcode的题号为219。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p><p>中文题目描述有问题。。。英文题的翻译应该是：「二者差的绝对值不超过 k 即可」，但是题目中的却是「二者差的绝对值最大为 k」。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1], k = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,0,1,1], k = 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [99,99],k=2</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>第一个想到的是暴力解法，双层for循环去逐个寻找，一旦找到满足条件的就停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略非空等判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[j] &amp;&amp; Math.abs(i-j) &lt;= k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果不理想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :303 ms, 在所有 Java 提交中击败了21.49%的用户</span><br><span class="line">内存消耗 :41.2 MB, 在所有 Java 提交中击败了96.84%的用户</span><br></pre></td></tr></table></figure><p>其实可以借助map来实现，按照经验，一般的数组查找题目都可以利用map来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span> || nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map，key存储元素值nums[i]，value存储索引i</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//map中存在说明元素相等，此时判断索引距离是否小于等于k，是则找到了，不是继续努力</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]) &amp;&amp; Math.abs(i-map.get(nums[i]))&lt;=k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这一步就说明找不到了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效率得到了大幅的提升，虽然用了额外的O(n)的空间，不过空间换时间往往是值得的，也是提升算法效率的一个捷径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :12 ms, 在所有 Java 提交中击败了93.50%的用户</span><br><span class="line">内存消耗 :43 MB, 在所有 Java 提交中击败了82.02%的用户</span><br></pre></td></tr></table></figure><p>不过这个方法是否可以简单点写？我在题解中看到用set来实现的，思路十分简单：</p><ul><li>遍历数组，对于每个元素做以下操作：<ul><li>在散列表中搜索当前元素，如果找到了就返回 true。</li><li>在散列表中插入当前元素。</li><li>如果当前散列表的大小超过了 k， 删除散列表中最旧的元素。</li></ul></li></ul><p>最后一步很关键，只要set的长度大于k了，那么最旧的元素也就失去了去查询的意义，直接去除掉，并且这样做的好处是，控制一个set的窗口大小，查询上只需要对这k个元素查询即可，某种意义上来说提高了一定的查询效率，虽然也不大。最后就是set的实现代码比map的实现代码要简单点^^。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(set.size() == k+<span class="number">1</span>)&#123;</span><br><span class="line">                set.remove(nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道为什么，提交几遍，这种方式执行用时比map要长。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十六道题目是存在重复元素2，对应leetcode的题号为219。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-015-存在重复元素</title>
    <link href="http://yoursite.com/2020/01/10/leetcode-array/leetcode-015-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/01/10/leetcode-array/leetcode-015-存在重复元素/</id>
    <published>2020-01-10T14:04:49.514Z</published>
    <updated>2020-01-10T14:40:41.964Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十五道题目是存在重复元素，对应leetcode的题号为217。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>寻找重复元素的思路，比暴力解法还直接进入我脑海的思路还是Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过执行效率并不满意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :14 ms, 在所有 Java 提交中击败了43.49%的用户</span><br><span class="line">内存消耗 :43.6 MB, 在所有 Java 提交中击败了85.01%的用户</span><br></pre></td></tr></table></figure><p>不过这道题目也没想出其他什么快速的思路，翻了下评论和题解区，也都大同小异，不过这题写法上可以用hashset来精简下，不过看过java容器的同学一定直到hashset的本质就是hashmap.</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十五道题目是存在重复元素，对应leetcode的题号为217。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-014-旋转数组</title>
    <link href="http://yoursite.com/2020/01/09/leetcode-array/leetcode-014-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/09/leetcode-array/leetcode-014-旋转数组/</id>
    <published>2020-01-09T14:05:01.228Z</published>
    <updated>2020-01-09T14:05:45.941Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十四道题目是旋转数组，对应leetcode的题号为189。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p>说明:</p><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。</p><h2>解题思路</h2><p>第一个思路是我以前用的，就是要求循环数组，那么就可以变换思路：</p><p>比如数组为[1,2,3,4]</p><p>我组装新的数组：[1,2,3,4,1,2,3,4]</p><p>那么k=0时对应的是[1,2,3,4]，那么从index=(4-0)处开始读取，所以还是[1,2,3,4]；</p><p>k=1时对应的是[4,1,2,3]，那么从index=(4-1)处开始读取，所以是[4,1,2,3]；</p><p>…</p><p>当k=4的时候，又跟k=0的情况一样了，那么其实k=4<em>i的时候都跟k=0一样，k=4</em>i+1的时候都跟k=1一样，所以计算的时候对k%length一下就是通用情况了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个长度为两倍的数组，存储两个nums，循环k个其实就是从这大数组中寻找对应的位置读取出来即可</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">            temp[i] = nums[i%nums.length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于k其实是一个循环的数字，比如数组长度为4时，k=1和k=5效果是一样的，所以我只计算一种情况即可</span></span><br><span class="line">        <span class="keyword">int</span> index = nums.length-k%nums.length;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开始赋值，读取指定的数组区间的数字就是我们需要的数组序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;nums.length+index;i++)&#123;</span><br><span class="line">            nums[j++] = temp[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :1 ms, 在所有 Java 提交中击败了81.21%的用户</span><br><span class="line">内存消耗 :37.8 MB, 在所有 Java 提交中击败了92.59%的用户</span><br></pre></td></tr></table></figure><p>不过题目最后说有很多种算法，尤其是原地算法，上一种算法开辟了一个新数组，因此还需要想想办法如何原地实现。</p><p>假设 n=7n=7 且 k=3k=3 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始数组                  : 1 2 3 4 5 6 7</span><br><span class="line">反转所有数字后             : 7 6 5 4 3 2 1</span><br><span class="line">反转前 k 个数字后          : 5 6 7 4 3 2 1</span><br><span class="line">反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --&gt; 结果</span><br></pre></td></tr></table></figure><p>规律就是：先反转整个数组，然后反转前面k个，最后反转最后n-k个，即可返回会最终的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :1 ms, 在所有 Java 提交中击败了81.21%的用户</span><br><span class="line">内存消耗 :37.3 MB, 在所有 Java 提交中击败了95.41%的用户</span><br></pre></td></tr></table></figure><p>代码如下：</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        nums = reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        nums = reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        nums = reverse(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十四道题目是旋转数组，对应leetcode的题号为189。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-013-多数元素</title>
    <link href="http://yoursite.com/2020/01/08/leetcode-array/leetcode-013-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2020/01/08/leetcode-array/leetcode-013-多数元素/</id>
    <published>2020-01-08T14:15:32.376Z</published>
    <updated>2020-01-08T14:15:47.299Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十三道题目是多数元素，对应leetcode的题号为169。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>题目提示说一定存在那个多数的数，因此我们不要想其他复杂的情形了，只要专注于找这个数即可。第一个想到的思路是用MAP来存储元素和元素出现的个数，一旦某个元素的个数达标就返回结果，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个元素的时候，直接返回第一个元素即可</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用map存储，key存储nums[i]，value存储个数，逐一比较的过程中判断哪个元素个数大于一半就返回</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                map.put(nums[i],map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(nums[i]) &gt; nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里说明找不到，不过按照题意，是一定可以找到的</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过发现时间复杂度比较高：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :27 ms, 在所有 Java 提交中击败了15.28%的用户</span><br><span class="line">内存消耗 :39.8 MB, 在所有 Java 提交中击败了93.22%的用户</span><br></pre></td></tr></table></figure><p>经过翻答案，发现了一个比较好的方法，那就是大名鼎鼎的摩尔投票法，基本思想为：我们假设这样一个场景，在一个游戏中，分了若干个队伍，有一个队伍的人数超过了半数。所有人的战力都相同，不同队伍的两个人遇到就是同归于尽，同一个队伍的人遇到当然互不伤害。这样经过充分时间的游戏后，最后的结果是确定的，一定是超过半数的那个队伍留在了最后。</p><p>其实一样，经过这种抵消计数，最终能留下来的一定就是数量大于一半的数字了，效果的提升也很明显：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行用时 :2 ms, 在所有 Java 提交中击败了87.08%的用户</span><br><span class="line">内存消耗 :43 MB, 在所有 Java 提交中击败了81.15%的用户</span><br></pre></td></tr></table></figure><p>代码见下面。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//count专门来计数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//res作为对比的数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//count为0说明前面都抵消了，前面的已经没有对比价值了，重新开始继续比</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                res = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == res)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还可以通过排序来做，排完序后，数量大于一半的数字，一定会出现在数组的中间位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十三道题目是多数元素，对应leetcode的题号为169。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-012-两数之和2-输入有序数组</title>
    <link href="http://yoursite.com/2020/01/07/leetcode-array/leetcode-012-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/01/07/leetcode-array/leetcode-012-两数之和2-输入有序数组/</id>
    <published>2020-01-07T14:22:05.939Z</published>
    <updated>2020-01-07T14:24:55.299Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十二道题目是两数之和2-输入有序数组，对应leetcode的题号为167。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>因为是有序数据，那么就比较简单了，一头一尾前后夹逼即可。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//定义一头一尾的指针，前后夹逼试探</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[low] + numbers[high] == target)&#123;</span><br><span class="line">                <span class="comment">//注意下返回结果是数组下标+1</span></span><br><span class="line">                res[<span class="number">0</span>] = low + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = high + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[low] + numbers[high] &lt; target)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十二道题目是两数之和2-输入有序数组，对应leetcode的题号为167。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-011-买卖股票的最佳时机2</title>
    <link href="http://yoursite.com/2020/01/05/leetcode-array/leetcode-011-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2/"/>
    <id>http://yoursite.com/2020/01/05/leetcode-array/leetcode-011-买卖股票的最佳时机2/</id>
    <published>2020-01-05T11:16:49.059Z</published>
    <updated>2020-01-05T11:17:03.884Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十一道题目是买卖股票的最佳时机2，对应leetcode的题号为122。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>同一天的股票可以买入再卖出，也可以卖出再买入。因此只要今天的价格比昨天高，我们就买入昨天的再卖出今天的。也就是贪心的思想，只要今天比昨天好，今天就卖出。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])&#123;</span><br><span class="line">                max += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十一道题目是买卖股票的最佳时机2，对应leetcode的题号为122。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-010-买卖股票的最佳时机</title>
    <link href="http://yoursite.com/2020/01/05/leetcode-array/leetcode-010-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/01/05/leetcode-array/leetcode-010-买卖股票的最佳时机/</id>
    <published>2020-01-05T11:16:01.306Z</published>
    <updated>2020-01-05T11:16:33.061Z</updated>
    
    <content type="html"><![CDATA[<p>刷题之旅从数组类型的题目开始。第十道题目是买卖股票的最佳时机，对应leetcode的题号为121。</p><p><img src="http://bloghello.oursnail.cn/leetcode123.jpg" alt="image"></p><a id="more"></a><h2>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出时间需要大于买入时间。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2>解题思路</h2><p>这个题目的思路为：寻找当天的最大受益值（prices[i]-min），然后在所有天的最大收益中取出最大值就是本题的结果。并且注意min的值也要不断去判断获取。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、数组为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、max记录最大值，min记录数据中的最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//3、开始寻找最大的收益max和最小的值min</span></span><br><span class="line">        <span class="comment">//max为当前索引的值减去min就是第i天的最大收益，最终max记录的就是某天的最大收益</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            max = Math.max(max,prices[i] - min);</span><br><span class="line">            min = Math.min(min,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷题之旅从数组类型的题目开始。第十道题目是买卖股票的最佳时机，对应leetcode的题号为121。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://bloghello.oursnail.cn/leetcode123.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
