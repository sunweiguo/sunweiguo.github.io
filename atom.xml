<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-23T08:17:46.045Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zookeeper笔记8-典型应用场景详解</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B08-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记8-典型应用场景详解/</id>
    <published>2019-02-23T08:17:03.090Z</published>
    <updated>2019-02-23T08:17:46.045Z</updated>
    
    <content type="html"><![CDATA[<p>本章对于zk的应用场景和解决方案进行详细的介绍。</p><a id="more"></a><h2>一、从应用程序的角度看ZooKeeper</h2><p><img src="http://bloghello.oursnail.cn/18-12-9/13282729.jpg" alt="image"></p><p>ZNode之间的层级关系就像文件系统的目录结构一样，但和传统的磁盘文件系统不同的是全量数据都存储在内存中，以此来实现提高服务器吞吐、减少延迟的目的，从这一点来说应用只应该存储控制信息和配置信息到ZNode，而不应该用它来存储大量数据。</p><p>ZNode可以分为持久节点和临时节点两类。持久节点是指一旦该ZNode被创建了，除非主动进行删除操作，这个节点就会一直存在；而临时节点的生命周期会和客户端会话绑定在一起，一旦客户端会话失效其所创建的所有临时节点都会被删除。</p><p>ZK还支持客户端创建节点时指定一个特殊的SEQUENTIAL属性，这个节点被创建的时候ZK会自动在其节点名后面追加上一个整形数字，该数字是一个由服务端维护的自增数字，以此实现创建名称自增的顺序节点。</p><h2>二、监听器Watcher</h2><p>Watcher是ZK中很重要的特性，ZK允许用户在指定节点上注册一些Watcher，在该节点相关特定事件（比如节点添加、删除、子节点变更等）发生时Watcher会监听到，ZK服务端会将事件通知到感兴趣的客户端上去，该机制是ZK实现分布式协调服务的重要特性。</p><p>通知的时候服务端只会告诉客户端一个简单的事件（通知状态、事件类型、节点路径）而不包含具体的变化信息（如原始数据及变更后的数据），客户端如要具体信息再次主动去重新获取数据；此外，无论是服务端还是客户端，只要Watcher被触发ZK就会将其删除，因此在Watcher的使用上需要反复注册，这样轻量的设计有效减轻了服务端压力，如果Watcher一直有效，节点更新频繁时服务端会不断向客户端发送通知，对网络及服务端性能影响会非常大。</p><h2>三、典型应用场景</h2><h3>3.1 数据发布/订阅（以Dubbo注册中心为例）</h3><p>Dubbo是阿里集团开源的分布式服务框架，致力于提供高性能和透明化的远程服务调用解决方案和基于服务框架展开的完整SOA服务治理方案。</p><p>其中服务自动发现是最核心的模块之一，该模块提供基于注册中心的目录服务，使服务消费方能够动态的查找服务提供方，让服务地址透明化，同时服务提供方可以平滑的对机器进行扩容和缩容，其注册中心可以基于提供的外部接口来实现各种不同类型的注册中心，例如数据库、ZK和Redis等。接下来看一下基于ZK实现的Dubbo注册中心。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/10130945.jpg" alt="image"></p><ul><li><code>/dubbo</code>: 这是Dubbo在ZK上创建的根节点。</li><li><code>/dubbo/com.foo.BarService</code>: 这是服务节点，代表了Dubbo的一个服务。</li><li><code>/dubbo/com.foo.BarService/Providers</code>: 这是服务提供者的根节点，其子节点代表了每个服务的真正提供者。</li><li><code>/dubbo/com.foo.BarService/Consumers</code>: 这是服务消费者的根节点，其子节点代表了没一个服务的真正消费者</li><li>Dubbo基于ZK实现注册中心的工作流程：<ul><li>服务提供者：在初始化启动的时候首先在<code>/dubbo/com.foo.BarService/Providers</code>节点下创建一个子节点，同时写入自己的url地址，代表这个服务的一个提供者。</li><li>服务消费者：在启动的时候读取并订阅ZooKeeper上<code>/dubbo/com.foo.BarService/Providers</code>节点下的所有子节点，并解析所有提供者的url地址类作为该服务的地址列表，开始发起正常调用。同时在Consumers节点下创建一个临时节点，写入自己的url地址，代表自己是BarService的一个消费者</li><li>监控中心：监控中心是Dubbo服务治理体系的重要一部分，它需要知道一个服务的所有提供者和订阅者及变化情况。监控中心在启动的时候会通过ZK的<code>/dubbo/com.foo.BarService</code>节点来获取所有提供者和消费者的url地址，并注册Watcher来监听其子节点变化情况</li></ul></li></ul><p><strong>所有服务提供者在ZK上创建的节点都是临时节点</strong>，利用的是临时节点的生命周期和客户端会话绑定的特性，一旦提供者机器挂掉无法对外提供服务时该临时节点就会从ZK上摘除，这样服务消费者和监控中心都能感知到服务提供者的变化。</p><h3>3.2 命名服务</h3><p>命名服务也是分布式系统中比较常见的一类场景，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象，其中较为常见的是一些分布式服务框架中的服务地址列表，通过使用命名服务客户端应用能够指定名字来获取资源的实体、服务地址和提供者的信息等。</p><h3>3.3 Master选举</h3><p>当前系统的mater节点挂了怎么办？那就要重新选出一个master来。</p><p>ZK创建节点时有一个重要的特性，利用ZK的强一致性能够很好的保证在分布式高并发情况下节点的创建一定能够保证全局唯一，即ZK会保证客户端无法重复创建一个已经存在的数据节点。也就是说同时有多个客户端请求创建同一个节点最终一定只有一个客户端能够请求创建成功，利用这个特性就能很容易的在分布式环境中进行Master选举了。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/39480696.jpg" alt="image"></p><p>进行Master选举时客户端启动后可以向ZK请求创建一个临时节点，例如<code>/master_election/master</code>。在多个客户端创建时只有一个能创建成功，那么这个创建成功的客户端所在的机器就成为了Master。</p><p>同时其他没有创建成功的客户端都可以在节点<code>/master_election</code>上注册一个子节点变更的Watcher来监控当前Master是否在线，一旦发现Master挂了临时节点会被删除，其它客户端会收到通知，开始重新进行Master选举。</p><h3>3.4 分布式锁</h3><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同系统或同一系统不同机器之间共享了同一资源，那访问这些资源时通常需要一些互斥手段来保证一致性，这种情况下就需要用到分布式锁了。</p><p>接下来看下使用ZK如何实现排他锁。排他锁的核心是如何保证当前有且只有一个事务获得锁，并且锁被释放后所有等待获取锁的事务能够被通知到。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/33804933.jpg" alt="image"></p><p>和Master选举类似，在需要获取排他锁时，所有客户端都会试图在<code>/exclusive_lock</code>下创建临时子节点<code>/exclusive_lock/lock</code>，最终只有一个客户端能创建成功，该客户端就获取到了锁。</p><p>同时没有获取到锁的客户端需要到<code>/exclusive_lock</code>节点上注册一个子节点变更的Watcher监听，用于实时监听lock节点的变更情况。</p><p><code>/exclusive_lock/lock</code>是一个临时节点，在一下两种情况下都有可能释放锁：</p><ul><li>当获取锁的客户端挂掉，ZK上的该节点会被删除</li><li>正常执行完业务逻辑之后客户端会主动将自己创建的临时节点删除。</li></ul><p>无论在什么情况下删除了lock临时节点ZK都会通知在<code>/exclusive_lock</code>节点上注册了子节点变更Watcher监听的客户端，重新发起锁的获取。</p><h3>3.5 分布式屏障</h3><p>分布式屏障，举个栗子，在大规模分布式并行计算的场景下，最终的合并计算需要基于很多并行计算的子结果来进行，即系统需要满足特定的条件，一个队列的元素必须都聚齐之后才能进行后续处理，否则一直等待。看下如何用ZK来支持这种场景。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/11515311.jpg" alt="image"></p><p>开始时<code>/queue_barrier</code>是一个存在的节点，数据内容赋值为一个数字n来代表满足条件的机器总数，例如n=10表示只有当<code>/queue_barrier</code>节点下的子节点数量达到10后才会打开屏障继续处理。</p><p>然后所有的客户端都会到<code>/queue_barrier</code>节点下创建一个临时节点，如<code>/queue_barrier/192.168.0.1</code>。创建完节点之后根据以下步骤来确定执行顺序:</p><ul><li>1、调用获取节点数据的api获取<code>/queue_barrier</code>节点的内容：10</li><li>2、调用获取子节点总数的api获取<code>/queue_barrier</code>下的所有子节点，并且注册对子节点变更的Watcher监听</li><li>3、统计子节点个数</li><li>4、如果子节点个数小于10则继续等待，否则打开屏障继续处理</li><li>5、接收到Watcher通知后，重复步骤2</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章对于zk的应用场景和解决方案进行详细的介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记7-ZK的基本操作以及权限控制</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B07-ZK%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记7-ZK的基本操作以及权限控制/</id>
    <published>2019-02-23T07:46:23.228Z</published>
    <updated>2019-02-23T07:48:52.697Z</updated>
    
    <content type="html"><![CDATA[<p>说了那么久的理论，但是其实对于大多数人来说，会用才是王道，在会用的基础上再去深入探讨原理可能是最佳的实践方式，但是对于笔记来说，先原理再实践可能更为稳妥，本文介绍zk最基本的一些操作，比如查看节点、增加一个节点、Watch机制以及ACL权限控制等基本命令，最后还介绍了一下为了方便而产生的四字命令。</p><a id="more"></a><h2>基本数据模型</h2><ul><li>树形结构，每个节点成为znode，它可以有子节点，也可以有数据</li><li>临时节点和永久节点，临时节点在客户端断开后消失</li><li>每个zk节点都有各自的版本号，可以通过命令行来显示节点信息</li><li>每当节点数据发生变化，那么该节点的版本号会累加（<strong>乐观锁</strong>）</li><li>删除/修改过时节点，版本号不匹配则会报错</li><li>每个zk节点存储的数据不宜过大，几k即可</li><li>节点可以设置acl，可以通过权限来限制用户的访问</li></ul><h2>zk的作用</h2><ul><li>master选举，保证集群是高可用的</li><li>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器</li><li>发布与订阅，dubbo发布者把数据存在znode上，订阅者可以读取这个数据</li><li>分布式锁</li><li>集群管理，集群中保证数据的强一致性</li></ul><h2>zk的基本操作</h2><ul><li><code>ls /</code> 显示根节点名称</li><li><code>ls2 /</code> 显示了根节点的状态信息（stat也可以看状态）</li><li><code>get /</code> 拿出节点的数据和信息</li><li><code>create [-s] [-e] path data acl</code> 创建节点，如果是默认创建，则是非顺序的、 持久的节点。加上-e则是临时节点；加上-s表示顺序节点</li><li><strong>【注1】</strong>：如果是持久节点，状态信息中的ephemeralOwner=0x0；临时节点的这个属性，是后面一串比较长的字符</li><li><strong>【注2】</strong>：客户端断开连接了，一段时间之后，那么临时节点就会消失（主要是有个时效，超出这个时间还不收到来自客户端的心跳包则才认定客户端挂了）</li><li><strong>【注3】</strong>：在加上-s后，创建的节点会重命名为一个累加的名称</li><li><code>set path newData</code> 每次修改值后<code>dataVersion</code>数据版本号会增1</li><li><strong>【注4】</strong>：如何实现乐观锁？<code>set path data version</code>,就是说带上版本号，如果这个版本不对应，那么就修改失败</li><li><code>delete path version</code> 删除节点</li></ul><h2>watcher机制</h2><ul><li>针对每个节点的操作，都会有一个监督者<code>watcher</code></li><li>当监控的某个对象(znode)发生了变化，则触发watcher事件</li><li>zk中watcher是一次性的，触发后立即销毁（用其他的开源客户端开源让其不会销毁，重复触发）</li><li>父节点以及他的子孙们的 增 删 改 都能够触发其watcher</li><li>针对不同类型的事件，触发的watcher事件也不同：<ul><li>（子）节点创建事件</li><li>（子）节点删除事件</li><li>（子）节点数据变化事件</li></ul></li><li>通过<code>get path [watch]</code>或者<code>stat path [watch]</code>或者<code>ls path [watch]</code>都可以设置watcher</li><li>父节点 增 删 改 操作触发watcher</li><li>子节点 增 删 改 操作触发watcher</li></ul><h3>【创建父节点触发】：NodeCreated</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 24] stat /hello watch  </span><br><span class="line">Node does not exist: /hello</span><br><span class="line">[zk: localhost:2181(CONNECTED) 25] create /hello world</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">Created /hello</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeCreated path:/hello</span><br></pre></td></tr></table></figure><h3>【修改父节点数据触发】：NodeDataChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 26] stat /hello watch</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 27] get /hello</span><br><span class="line">world</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 28] set /hello lalala</span><br><span class="line"></span><br><span class="line">WATCHER::cZxid = 0x300000011</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/helloctime = Sat Dec 08 20:00:53 CST 2018</span><br></pre></td></tr></table></figure><h3>【删除父节点触发】：NodeDeleted</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 32] get /hello watch</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 33] delete /hello</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">[zk: localhost:2181(CONNECTED) 34]</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDeleted path:/hello</span><br></pre></td></tr></table></figure><h3>【创建子节点触发】：ls为父节点设置watcher，创建子节点触发NodeChildrenChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 52] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 53] create /hello world</span><br><span class="line">Created /hello</span><br><span class="line">[zk: localhost:2181(CONNECTED) 54] ls /hello watch</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 55] create /hello/helloson worldson</span><br><span class="line"></span><br><span class="line">WATCHER::Created /hello/helloson</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/hello</span><br></pre></td></tr></table></figure><h3>【删除子节点触发】：ls为父节点设置watcher，删除子节点触发NodeChildrenChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 56] ls /hello</span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 57] ls /hello watch</span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 58] delete /hello/helloson</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">[zk: localhost:2181(CONNECTED) 59]</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/hello</span><br></pre></td></tr></table></figure><h3>【更新子节点触发】：ls为父节点设置watcher，更新子节点不触发事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 59] ls /hello</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 60] create /hello/helloson worldson</span><br><span class="line">Created /hello/helloson</span><br><span class="line">[zk: localhost:2181(CONNECTED) 61] ls /hello watch </span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 62] set /hello/helloson worldsonhahaha</span><br><span class="line">cZxid = 0x300000020</span><br><span class="line">ctime = Sat Dec 08 20:15:05 CST 2018</span><br><span class="line">mZxid = 0x300000021</span><br><span class="line">mtime = Sat Dec 08 20:16:06 CST 2018</span><br><span class="line">pZxid = 0x300000020</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 14</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 63] get /hello/helloson</span><br><span class="line">worldsonhahaha</span><br></pre></td></tr></table></figure><p>就算是设置成<code>ls /hello/helloson watch</code>也不行。只有这样才可以触发watcher:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 72] get /swg/swgson watch</span><br><span class="line">8080</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 74] set /swg/swgson 7070</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">cZxid = 0x300000024</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/swg/swgsonctime = Sat Dec 08 20:18:53 CST 2018</span><br></pre></td></tr></table></figure><p>为什么更新子节点的时候ls不行，但是get就行呢？客户端要想收到更新子节点内容的消息的话，不能通过子节点的事件来触发，必须把子节点当作父节点来做。然而<code>ls path [watch] ：查询指定路径下的子节点</code>所以是针对的子节点，所以不能触发这个事件；而<code>get path [watch] : 查询指定节点中的数据，如果节点中有数据</code>或者<code>stat path [watch] : 查询指定节点的一些描述信息</code>这些直接是操作这个节点，把这个节点当作是父节点，所以能起作用。</p><h2>watcher使用场景</h2><p>Watcher是ZK中很重要的特性，ZK允许用户在指定节点上注册一些Watcher，在该节点相关特定事件（比如节点添加、删除、子节点变更等）发生时Watcher会监听到，ZK服务端会将事件通知到感兴趣的客户端上去，该机制是ZK实现分布式协调服务的重要特性。</p><p>通知的时候服务端只会告诉客户端一个简单的事件（通知状态、事件类型、节点路径）而不包含具体的变化信息（如原始数据及变更后的数据），客户端如要具体信息再次主动去重新获取数据；此外，无论是服务端还是客户端，只要Watcher被触发ZK就会将其删除，因此在Watcher的使用上需要反复注册，这样轻量的设计有效减轻了服务端压力，如果Watcher一直有效，节点更新频繁时服务端会不断向客户端发送通知，对网络及服务端性能影响会非常大。</p><p>比如统一资源配置。</p><h2>ACL 权限控制列表</h2><ul><li>针对节点可以设置相关读写等权限，目的是为了保障数据安全性</li><li>权限permissions可以指定不同的权限范围以及角色</li><li><code>getAcl</code>：获取某个节点的acl权限信息</li><li><code>setAcl</code>：设置某个节点的acl权限信息</li><li><code>addauth</code>：注册某个用户，要把某个用户的用户名和密码输入到系统中进行注册，用户才能登陆。</li><li>默认权限：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 76] getAcl /swg</span><br><span class="line">&apos;world,&apos;anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure><ul><li>ACL构成：zk的acl通过[scheme🆔permissions]来构成权限列表，其中<code>scheme</code>指采用的某种权限机制；<code>id</code>指允许访问的用户；<code>permissions</code>指权限组合字符串</li><li><code>scheme</code>：主要是四种<ul><li><code>world</code>：<code>world</code>下只有一个<code>id</code>，即只有一个用户，也就是<code>anyone</code>，那么组合的写法就是<code>world:anyone:[permissions]</code></li><li><code>auth</code>：代表认证登陆，需要注册用户有权限就可以，形式为<code>auth:user:password:[permissions]</code>,密码是明文</li><li><code>degest</code>：需要对密码加密才能访问，组合形式为<code>digest:username:BASE64(SHA(password)):[permissions]</code>，密码是加密的</li><li><code>ip</code>：当设置为ip指定的ip地址，此时限制ip进行访问，比如<code>ip:192.168.1.1:[permissions]</code></li><li><code>super</code>：代表超级管理员，拥有所有权限</li></ul></li><li><code>id</code>：代表允许访问的用户</li><li><code>permissions</code>：<ul><li><code>c</code>：create,创建当前节点的子节点权限</li><li><code>r</code>：read,获取当前节点或者子节点列表</li><li><code>w</code>：write,设置当前节点的数据</li><li><code>d</code>：delete，删除子节点</li><li><code>a</code>：admin，是比较高的权限，可以去设置和修改权限，即拥有分配权限的权限</li></ul></li></ul><ul><li><code>world:anyone:cdrwa</code>：对于默认权限，我们可以修改他的权限字符串，如<code>setAcl path world:anyone:crwa</code></li><li><code>auth</code>和<code>digest</code>：先<code>addauth digest username:password（明文密码）</code>注册用户,然后<code>setAcl path auth:username:password（明文密码）:cdrwa</code>就可以设置ACL了。再去<code>getAcl path</code>查询到的密码时加密后的。</li><li><code>digest</code>：要先退出刚才的<code>auth</code>的账号，直接重启当前客户端即可。<code>setAcl path digest:username:password（密文密码）:cdrwa</code>。再去<code>getAcl path</code>查询到的密码时加密后的。此时访问、删除、创建节点比如<code>get path</code>是需要登陆的，即先<code>addauth digest username:password（明文密码）</code>登陆。</li><li><code>ip</code>：<code>setAcl path ip:192.168.1.1:cdrwa</code></li><li><code>super</code>：最高权限，修改<code>zkServer.sh</code>增加super管理员，重启<code>zkServer.sh</code>。到<code>bin</code>目录下修改<code>zkServer.sh</code>增加配置：</li></ul><p>找到这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup $JAVA &quot;-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;&quot; &quot;-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;&quot;</span><br></pre></td></tr></table></figure><p>在后面继续添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=username:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</span><br></pre></td></tr></table></figure><h2>ACL常用使用场景</h2><ul><li>开发/测试环境分离，开发者无权限操作测试库的节点，只能看。比如分为开发节点和测试节点。</li><li>生产环境上控制指定ip的服务可以访问相关节点防止混乱</li></ul><h2>zk四字命令</h2><ul><li>zk可以通过它自身提供的简写命令来和服务器进行交互</li><li>需要使用到 <code>nc</code> 命令，<code>yum install nc</code></li><li><code>echo [command] | nc [ip] [port]</code><ul><li>【stat】查看zk的状态信息，以及是单机还是集群状态：<code>echo stat | nc ip或者localhost 2181</code></li><li>【ruok】查看当前zkServer是否启动，正常返回imok：<code>echo ruok | nc ip 2181</code></li><li>【dump】列出未经处理的会话和临时节点：<code>echo dump | nc ip 2181</code></li><li>【conf】查看服务配置</li><li>【cons】展示连接到服务器的客户端信息</li><li>【envi】环境变量，显示jdk和zk等环境变量的信息</li><li>【mntr】监控zk健康信息</li><li>【wchs】展示watch的信息</li><li>【wchc】与【wchp】：分别展示session与watch及path与watcher的信息，默认这两个命令是不能访问的，需要将他们列入白名单才行</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说了那么久的理论，但是其实对于大多数人来说，会用才是王道，在会用的基础上再去深入探讨原理可能是最佳的实践方式，但是对于笔记来说，先原理再实践可能更为稳妥，本文介绍zk最基本的一些操作，比如查看节点、增加一个节点、Watch机制以及ACL权限控制等基本命令，最后还介绍了一下为了方便而产生的四字命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记6-zk安装和集群搭建</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B06-zk%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记6-zk安装和集群搭建/</id>
    <published>2019-02-23T07:24:59.806Z</published>
    <updated>2019-02-23T07:25:21.850Z</updated>
    
    <content type="html"><![CDATA[<p>本章会回顾一下ZAB协议，然后介绍一下集群搭建的配置文件。</p><a id="more"></a><h2>前言</h2><p>回顾一下<code>ZAB</code>协议。<code>Zab</code>协议包括两个核心：</p><p><strong>第一，原子广播</strong></p><p>客户端提交事务请求时<code>Leader</code>节点为每一个请求生成一个事务<code>Proposal</code>，将其发送给集群中所有的<code>Follower</code>节点，收到过半<code>Follower</code>的反馈后开始对事务进行提交。</p><p>这也导致了<code>Leader</code>崩溃后可能会出现数据不一致的情况，ZAB使用了崩溃恢复来处理数字不一致问题；</p><p>消息广播使用了TCP协议进行通讯所有保证了接受和发送事务的顺序性。广播消息时<code>Leader</code>节点为每个事务<code>Proposal</code>分配一个全局递增的<code>ZXID</code>（事务ID），每个事务<code>Proposal</code>都按照<code>ZXID</code>顺序来处理；</p><p><code>Leader</code>节点为每一个<code>Follower</code>节点分配一个队列按事务<code>ZXID</code>顺序放入到队列中，且根据队列的规则FIFO来进行事务的发送。</p><p><code>Follower</code>节点收到事务<code>Proposal</code>后会将该事务以事务日志方式写入到本地磁盘中，成功后反馈<code>Ack</code>消息给<code>Leader</code>节点。</p><p>收到过半<code>ACK</code>反馈之后，同时向所有的<code>Follower</code>节点广播<code>Commit</code>消息，<code>Follower</code>节点收到<code>Commit</code>后开始对事务进行提交；</p><p><strong>第二，Master选举</strong></p><p>里面用的算法叫做：<code>Fast Leader Election</code>。</p><ul><li><code>epoch</code>：选举轮数,即周期，就是之前说的逻辑时钟<code>logicClock</code></li><li><code>Zxid</code>: <code>Zxid</code> 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，针对客户端每一个事务请求，计数器加 1；而高 32 位则代表 <code>Leader</code> 周期 <code>epoch</code> 的编号，每个当选产生一个新的 <code>Leader</code> 服务器，就会从这个 <code>Leader</code> 服务器上取出其本地日志中最大事务的<code>ZXID</code>，并从中读取 <code>epoch</code> 值，然后加 1，以此作为新的 <code>epoch</code>，并将低 32 位从 0 开始计数。</li></ul><p><strong>成为leader的条件</strong></p><ul><li>选<code>epoch</code>最大的</li><li><code>epoch</code>相等，选 <code>zxid</code> 最大的</li><li><code>epoch</code>和<code>zxid</code>都相等，选择<code>server id</code>最大的（就是我们配置<code>zoo.cfg</code>中的<code>myid</code>）</li></ul><p><strong>选举的基本步骤</strong></p><ol><li>每个从节点都向其他节点发送选自身为<code>Leader</code>的<code>Vote</code>投票请求，等待回复；</li><li>从节点接受到的<code>Vote</code>如果比自身的大（ZXID更新）时则投票，并更新自身的<code>Vote</code>，否则拒绝投票；</li><li>每个从节点中维护着一个投票记录表，当某个节点收到过半的投票时，结束投票并把该从节点选为<code>Leader</code>，投票结束；</li></ol><p>具体一点的步骤：</p><ul><li>1、发起一轮投票选举，推举自己作为<code>leader</code>，通知所有的服务器，等待接收外部选票。</li><li>2、只要当前服务器状态为<code>LOOKING</code>，进入循环，不断地读取其它<code>Server</code>发来的通知、进行比较、更新自己的投票、发送自己的投票、统计投票结果，直到<code>leader</code>选出或出错退出。具体做法：<ul><li>2.1 如果发送过来的逻辑时钟大于目前的逻辑时钟，那么说明这是更新的一次选举投票，此时更新本机的逻辑时钟（<code>logicalclock</code>），清空投票箱（因为已经过期没有用了）调用<code>totalOrderPredicate</code>函数判断对方的投票是否优于当前的投票（见下面代码），是的话用对方推荐的<code>leader</code>更新下一次的投票，否则使用初始的投票（投自己），调用<code>sendNotifications()</code> 通知所有服务器我的选择，跳到2.4。</li><li>2.2 如果对方处于上轮投票，不予理睬，回到2。</li><li>2.3 如果对方也处于本轮投票，调用<code>totalOrderPredicate</code>函数判断对方的投票是否优于当前的投票，是的话更新当前的投票，否则使用初始的投票（投自己）并新生成<code>notification</code>消息放入发送队列。调用<code>sendNotifications()</code> 通知所有服务器我的选择。</li><li>2.4 将收到的投票放入自己的投票箱中。</li><li>2.5 调用计票器的<code>containsQuorum</code>函数，判断所推荐的leader是否得到集群多数人的同意，如果得到多数人同意，那么还需等待一段时间，看是否有比当前更优的提议，如果没有，则认为投票结束。根据投票结果修改自己的状态。以上任何一条不满足，则继续循环。</li></ul></li></ul><p>关于<code>totalOrderPredicate</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">totalOrderPredicate</span><span class="params">(<span class="keyword">long</span> newId, <span class="keyword">long</span> newZxid, <span class="keyword">long</span> newEpoch, <span class="keyword">long</span> curId, <span class="keyword">long</span> curZxid, <span class="keyword">long</span> curEpoch)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    LOG.debug(<span class="string">"id: "</span> + newId + <span class="string">", proposed id: "</span> + curId + <span class="string">", zxid: 0x"</span> +</span><br><span class="line">    </span><br><span class="line">            Long.toHexString(newZxid) + <span class="string">", proposed zxid: 0x"</span> + Long.toHexString(curZxid));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用计票器判断当前server的权重是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(self.getQuorumVerifier().getWeight(newId) == <span class="number">0</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Epoch、zxid、id来比较两个候选leader</span></span><br><span class="line">    <span class="keyword">return</span> ((newEpoch &gt; curEpoch) ||</span><br><span class="line">    </span><br><span class="line">            ((newEpoch == curEpoch) &amp;&amp;</span><br><span class="line">    </span><br><span class="line">            ((newZxid &gt; curZxid) || ((newZxid == curZxid) &amp;&amp; (newId &gt; curId)))));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>总结起来就是一句话：若干个节点，第一次都是投给自己；后面就是，尽量向数据最新的节点靠拢，可以理解为：每个节点贫富有差距，富有的节点让贫穷的节点投自己一票，那么贫穷的节点会接受，反之不行，那么最先拿到超过一半的贫穷的节点的投票，就成为leader。（贫穷与富有都是相对的，越富有越可能成为leader）。</strong></p><h2>zk集群搭建</h2><p>首先准备三份解压文件，每一份中都新建一个叫<code>data</code>的文件夹：里面新建一个叫做myid的文件，第一个写1，后面递增。</p><p>每一份中配置文件改为<code>zoo.cfg</code>。zk1对应的zoo.cfg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick 心跳检测时间</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line"># 集群启动后，相互连接，如果在initLimit*tickTime时间内没有连接成功，那么认为连接失败</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># Masrer和slave之间或者slave和slave之间的数据同步时间，在syncLimit*tickTime是按内没有返回一个ACk，则</span><br><span class="line"># 认为该节点宕机，如果是Master宕机了，就要重新选举了</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 数据存放的目录，这是我新建的</span><br><span class="line">dataDir=D:/zookeeper1-3.4.10/data</span><br><span class="line"># dataLogDir = xx</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># 客户端连接集群的端口号</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第一个端口是数据同步的端口号  第二个端口是选举的端口号</span><br><span class="line">server.1=127.0.0.1:2887:3887</span><br><span class="line">server.2=127.0.0.1:2888:3888</span><br><span class="line">server.3=127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure><p>后面一次递增这个<code>clientPort</code>和<code>data</code>文件夹位置。</p><p>依次启动即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章会回顾一下ZAB协议，然后介绍一下集群搭建的配置文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记5-ZAB协议</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B05-ZAB%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记5-ZAB协议/</id>
    <published>2019-02-23T07:09:59.185Z</published>
    <updated>2019-02-23T07:20:23.561Z</updated>
    
    <content type="html"><![CDATA[<p>在zookeeper中其实使用的ZAB协议来实现数据的一致性，并且主要依靠的是leader和follower这两种角色控制数据的一致性，而leader是里面最重要的一个角色，它是主要负责写操作的节点，然后与其他的follower进行数据同步，所以我们也要保证leader宕机的时候要快速选举出新的leader并且进行数据恢复。</p><a id="more"></a><h2>一、前言</h2><p>ZooKeeper是一个分布式协调服务，可用于服务发现、分布式锁、分布式领导选举、配置管理等。</p><p><strong>这一切的基础，都是ZooKeeper提供了一个类似于Linux文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。</strong></p><p>既然是一个文件系统，就不得不提ZooKeeper是如何保证数据的一致性的。本节将将介绍ZooKeeper如何保证数据一致性，如何进行领导选举，以及数据监控/通知机制的语义保证。</p><h2>二、ZAB-原子广播（重点）</h2><p><code>ZooKeeper</code>集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种：</p><ul><li><code>Leader</code>： 一个<code>ZooKeeper</code>集群同一时间只会有一个实际工作的<code>Leader</code>，它会发起并维护与各<code>Follwer</code>及<code>Observer</code>间的心跳。所有的写操作必须要通过<code>Leader</code>完成再由<code>Leader</code>将写操作广播给其它服务器。</li><li><code>Follower</code>： 一个<code>ZooKeeper</code>集群可能同时存在多个<code>Follower</code>，它会响应<code>Leader</code>的心跳。<code>Follower</code>可直接处理并返回客户端的读请求，同时会将写请求转发给<code>Leader</code>处理，并且负责在<code>Leader</code>处理写请求时对请求进行投票。</li><li><code>Observer</code>： 角色与<code>Follower</code>类似，但是无投票权。</li></ul><p><img src="http://bloghello.oursnail.cn/18-12-4/8438336.jpg" alt="image"></p><p><font color="red">为了保证写操作的一致性与可用性，ZooKeeper专门设计了一种名为原子广播（ZAB）的支持崩溃恢复的一致性协议。基于该协议，ZooKeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。</font></p><p>根据ZAB协议，所有的写操作都必须通过<code>Leader</code>完成，<code>Leader</code>写入本地日志后再复制到所有的<code>Follower</code>节点。</p><p>一旦<code>Leader</code>节点无法工作，ZAB协议能够自动从<code>Follower</code>节点中重新选出一个合适的替代者，即新的<code>Leader</code>，该过程即为领导选举。该领导选举过程，是ZAB协议中最为重要和复杂的过程。</p><h3>1、写Leader</h3><p>通过Leader进行写操作流程如下图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/18727361.jpg" alt="image"></p><p>由上图可见，通过<code>Leader</code>进行写操作，主要分为五步：</p><ul><li>客户端向<code>Leader</code>发起写请求</li><li><code>Leader</code>将写请求以<code>Proposal</code>的形式发给所有<code>Follower</code>并等待<code>ACK</code></li><li><code>Follower</code>收到<code>Leader</code>的<code>Proposal</code>后返回<code>ACK</code></li><li><code>Leader</code>得到过半数的<code>ACK</code>（<code>Leader</code>对自己默认有一个<code>ACK</code>）后向所有的<code>Follower</code>和<code>Observer</code>发送<code>Commmit</code></li><li><code>Leader</code>将处理结果返回给客户端</li></ul><p><font color="red">这里要注意：</font></p><ul><li><code>Leader</code>并不需要得到<code>Observer</code>的<code>ACK</code>，即<code>Observer</code>无投票权</li><li><code>Leader</code>不需要得到所有<code>Follower</code>的<code>ACK</code>，只要收到过半的<code>ACK</code>即可，同时<code>Leader</code>本身对自己有一个<code>ACK</code>。上图中有4个<code>Follower</code>，只需其中两个返回<code>ACK</code>即可，因为(2+1) / (4+1) &gt; 1/2</li><li><code>Observer</code>虽然无投票权，但仍须同步<code>Leader</code>的数据从而在处理读请求时可以返回尽可能新的数据</li></ul><h3>2、写Follower/Observer</h3><p>通过<code>Follower</code>/<code>Observer</code>进行写操作流程如下图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/92869076.jpg" alt="image"></p><p>从上图可见：</p><ul><li><code>Follower</code>/<code>Observer</code>均可接受写请求，但不能直接处理，而需要将写请求转发给<code>Leader</code>处理</li><li>除了多了一步请求转发，其它流程与直接写<code>Leader</code>无任何区别</li></ul><h2>3、读操作</h2><p><code>Leader</code>/<code>Follower</code>/<code>Observer</code>都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。</p><p><img src="http://bloghello.oursnail.cn/18-12-4/63826294.jpg" alt="image"></p><p>由于处理读请求不需要服务器之间的交互，<code>Follower</code>/<code>Observer</code>越多，整体可处理的读请求量越大，也即读性能越好。</p><p><font color="red">在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个事务Proposal分配一个全局单调递增的唯一ID，我们称之为事务ID(即ZXID)。由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的先后顺序进行排序和处理。</font></p><p>具体的，在消息广播过程中，<code>Leader</code>服务器会为每个<code>Follower</code>服务器都<font color="red">各自分配一个单独的队列</font>，然后将需要广播的事务<code>Proposal</code>依次放入这些队列中取，并且根据FIFO策略进行消息发送。每一个<code>Follower</code>服务器在接收到这个事务<code>Proposal</code>之后，都会首先将其以事务日志的形式写入本地磁盘中，并且成功写入后反馈给<code>Leader</code>服务器一个Ack相应。当<code>Leader</code>服务器接收到过半数<code>Follower</code>的Ack响应后，就会广播一个<code>Commit</code>消息给所有的<code>Follower</code>服务器以通知其进行事务提交，同时<code>Leader</code>自身也会完成对事务的提交，而每个<code>Follower</code>服务器在接收到<code>Commit</code>消息后，也会完成对事务的提交。</p><p><font color="red">然而，在这种简化的二阶段提交模型下，无法处理Leader服务器崩溃退出而带来的数据不一致问题，因此ZAB协议添加了崩溃恢复模式来解决这个问题</font>。另外，整个消息广播协议是基于有FIFO特性的TCP协议来进行网络通信的，因此很容易地保证消息广播过程中消息接收和发送的顺序性。</p><p>在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的<code>Leader</code>服务器。因此，ZAB协议需要一个高效且可靠的<code>Leader</code>选举算法，从而确保能够快速选举出新的<code>Leader</code>。同时，<code>Leader</code>选举算法不仅仅需要让<code>Leader</code>自己知道其自身已经被选举为<code>Leader</code>，同时还需要让集群中的所有其他服务器也快速地感知到选举产生的新的<code>Leader</code>服务器。<font color="red">崩溃恢复主要包括Leader选举和数据恢复两部分</font>，下面将详细讲解<code>Leader</code>选举和数据恢复流程。</p><h2>三、支持的领导选举算法</h2><p>在3.4.10版本中，默认值为3，也即基于TCP的<code>FastLeaderElection</code>。另外三种算法已经被弃用，并且有计划在之后的版本中将它们彻底删除而不再支持。</p><p>何时触发选举？</p><p>选举<code>Leader</code>不是随时选举的，毕竟选举有产生大量的通信，造成网络IO的消耗。因此下面情况才会出现选举：</p><ul><li>集群启动</li><li>服务器处于寻找<code>Leader</code>状态</li><li>当服务器处于<code>LOOKING</code>状态时，表示当前没有<code>Leader</code>，需要进入选举流程</li><li>崩溃恢复</li><li><code>Leader</code>宕机</li><li>网络原因导致过半节点与<code>Leader</code>心跳中断</li></ul><p>下面学习一下<code>FastLeaderElection</code>的原理。</p><h2>四、名词解释</h2><h3>1、myid</h3><p>每个<code>ZooKeeper</code>服务器，都需要在数据文件夹下创建一个名为<code>myid</code>的文件，该文件包含整个<code>ZooKeeper</code>集群唯一的ID（整数）。例如，某<code>ZooKeeper</code>集群包含三台服务器，<code>hostname</code>分别为<code>zoo1</code>、<code>zoo2</code>和<code>zoo3</code>，其<code>myid</code>分别为1、2和3，则在配置文件中其ID与<code>hostname</code>必须一一对应，如下所示。在该配置文件中，server.后面的数据即为<code>myid</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=zoo1:2888:3888</span><br><span class="line">server.2=zoo2:2888:3888</span><br><span class="line">server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure><ul><li>第1个端口是通信和数据同步端口，默认是2888</li><li>第2个端口是投票端口，默认是3888</li></ul><p>数小的向数大的发起TCP连接。比如有3个节点，myid文件内容分别为1,2,3。zk集群的tcp连接顺序是1向2发起TCP连接，2向3发起TCP连接。如果有n个节点，那么tcp连接顺序也以此类推。这样整个zk集群就会连接起来</p><h3>2、zxid</h3><p>类似于<code>RDBMS</code>中的事务ID，用于标识一次更新操作的<code>Proposal ID</code>。为了保证顺序性，该<code>zxid</code>必须<strong>单调递增</strong>。因此<code>ZooKeeper</code>使用一个64位的数来表示，<strong>高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加一。低32位为该epoch内的序号，每次epoch变化，<strong>都将低32位的序号重置</strong></strong>。这样保证了<code>zxid</code>的全局递增性。</p><h3>3、服务器状态</h3><ul><li><code>LOOKING</code> 不确定<code>Leader</code>状态。该状态下的服务器认为当前集群中没有<code>Leader</code>，会发起<code>Leader</code>选举。</li><li><code>FOLLOWING</code> 跟随者状态。表明当前服务器角色是<code>Follower</code>，并且它知道<code>Leader</code>是谁。</li><li><code>LEADING</code> 领导者状态。表明当前服务器角色是<code>Leader</code>，它会维护与<code>Follower</code>间的心跳。</li><li><code>OBSERVING</code> 观察者状态。表明当前服务器角色是<code>Observer</code>，与<code>Folower</code>唯一的不同在于不参与选举，也不参与集群写操作时的投票。</li></ul><h3>4、选票数据结构</h3><p>每个服务器在进行领导选举时，会发送如下关键信息：</p><ul><li><code>logicClock</code> 每个服务器会维护一个自增的整数，名为<code>logicClock</code>，它表示这是该服务器发起的第多少轮投票</li><li><code>state</code> 当前服务器的状态</li><li><code>self_id</code> 当前服务器的myid</li><li><code>self_zxid</code> 当前服务器上所保存的数据的最大zxid</li><li><code>vote_id</code> 被推举的服务器的myid</li><li><code>vote_zxid</code> 被推举的服务器上所保存的数据的最大zxid</li></ul><h2>五、leader的判定标准</h2><ul><li>数据新旧程度，只有拥有最新数据的节点才能有机会成为<code>Leader</code>，通过<code>zxid</code>的大小来表示数据的新，<code>zxid</code>越大代表数据越新</li><li><code>myid</code>:集群启动时，会在<code>data</code>目录下配置<code>myid</code>文件，里面的数字代表当前zk服务器节点的编号.当zk服务器节点数据一样新时， <code>myid</code>中数字越大的就会被选举成<code>Leader</code></li><li>当集群中已经有<code>Leader</code>时，新加入的节点不会影响原来的集群</li><li>投票数量，只有得到集群中多半的投票，才能成为<code>Leader</code>，多半即：n/2+1,其中n为集群中的节点数量</li></ul><h2>六、Leader选举流程</h2><h3>1、自增选举轮次</h3><p><code>ZooKeeper</code>规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的<code>logicClock</code>进行自增操作。</p><h3>2、发送初始化选票</h3><p>每个服务器最开始都是通过广播把票投给自己。</p><h3>4、更新选票</h3><p>根据选票<code>logicClock</code> -&gt; <code>vote_zxid</code> -&gt; <code>vote_id</code>依次判断</p><h5>4.1 判断选举轮次收到外部投票后，首先会根据投票信息中所包含的logicClock来进行不同处理：</h5><p><strong>外部投票的logicClock &gt; 自己的logicClock：</strong><br>说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的<code>logicClock</code>更新为收到的<code>logicClock</code>，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去;</p><p><strong>外部投票的logicClock &lt; 自己的logicClock：</strong><br>当前服务器直接忽略该投票，继续处理下一个投票;</p><p><strong>外部投票的logickClock = 自己的：</strong> 进行下一步的进行选票PK。</p><h5>4.2 选票PK是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比：</h5><p>若<code>logicClock</code>一致，则对比二者的<code>vote_zxid</code>。</p><p>若外部投票的<code>vote_zxid</code>比较大，则将自己的票中的<code>vote_zxid</code>与<code>vote_myid</code>更新为收到的票中的<code>vote_zxid</code>与<code>vote_myid</code>并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(<code>self_myid</code>, <code>self_zxid</code>)相同的选票，则直接覆盖</p><p>若二者<code>vote_zxid</code>一致，则比较二者的<code>vote_myid</code>。</p><p>若外部投票的<code>vote_myid</code>比较大，则将自己的票中的<code>vote_myid</code>更新为收到的票中的<code>vote_myid</code>并广播出去，另外将收到的票及自己更新后的票放入自己的票箱</p><h3>5、统计选票</h3><p>如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。</p><h3>6、更新服务器状态</h3><p>投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为<code>LEADING</code>，否则将自己的状态更新为<code>FOLLOWING</code>。</p><h2>七、图示Leader选举流程</h2><p><img src="http://bloghello.oursnail.cn/18-12-4/35769576.jpg" alt="image"></p><p>说明：</p><p>图中箭头上的(1,1,0) 三个数依次代表</p><ul><li>该选票的服务器的<code>LogicClock</code>（即投票轮数）;</li><li>被推荐的服务器的<code>myid</code> (即<code>vote_myid</code>);</li><li>被推荐的服务器的最大事务ID(即<code>vote_zxid</code>)；</li></ul><p>(1, 1)表示：</p><ul><li>投票服务器<code>myid</code>(即<code>self_myid</code>)</li><li>被推荐的服务器的<code>myid</code> (即<code>vote_myid</code>)</li></ul><p>所以(1,1,0)在这里的意思是：第一轮投票中，投给server 1，并且自己的最大事务ID都是0(这里可能会比较乱，ZXID可用这样理解：前32位是年号，比如万历年间；后32位是多少年，比如万历15年)，我们这里先不考虑年号的更迭，就假设这个投票发生在万历15年这一年，并且只考虑第一轮投票。即(1,vote_id,0)，所以暂时只考虑中间个数字。后面接受外部选票的时候，我们只要关注中间个数字即可，比如(1,2,0)说明是投给server 2的。</p><p>这里的示例只考虑第一轮，并且ZXID就是0.</p><h3>第一步：自增选票轮次&amp;初始化选票&amp;发送初始化选票</h3><p>首先，三台服务器自增选举轮次将<code>LogicClock=1</code>；然后初始化选票，清空票箱；最后发起初始化投票给自己将各自的票通过广播的形式投个自己并保存在自己的票箱里。</p><p>所以都是自己投给自己一票(1,1,0),(1,2,0),(1,3,0)</p><p>投完票之后的状态时(1,1),(2,2),(3,3)</p><h3>第二步：接受外部投票&amp;更新选票</h3><p>以<code>Server 1</code> 为例，分别经历 <code>Server 1 PK Server 2</code> 和 <code>Server 1 PK Server 3</code> 过程</p><h5>Server 1 PK Server 2</h5><p><code>Server 1</code> 接收到<code>Server 2</code>的选票(1,2,0) 表示投给<code>server 2</code>.</p><p>这时<code>Server 1</code>将自身的选票轮次和<code>Server 2</code> 的选票轮次比较，发现<code>LogicClock=1</code>相等，接着<code>Server 2</code>比较比较最大事务ID，发现也<code>zxid=0</code>也相等，最后比较各自的<code>myid</code>，发现<code>Server 2</code>的<code>myid=2</code> 大于自己的<code>myid=1</code>；</p><p>根据选票PK规则，<code>Server 1</code>将自己的选票由 (1, 1) 更正为 (1, 2)，表示选举<code>Server 2</code>为<code>Leader</code>，然后将自己的新选票 (1, 2)广播给 <code>Server 2</code> 和 <code>Server 3</code>，同时更新票箱子中自己的选票并保存<code>Server 2</code>的选票，至此<code>Server 1</code>票箱中的选票为(1, 2) 和 (2, 2)；</p><p><code>Server 2</code>收到<code>Server 1</code>的选票同样经过轮次比较和选票PK后确认自己的选票保持不变，并更新票箱中<code>Server 1</code>的选票由(1, 1)更新为(1, 2)，注意此次<code>Server 2</code>自己的选票并没有改变所有不用对外广播自己的选票。</p><p>此时便认为已经选出了<code>Leader</code>。但是这里可能会等一会看看有没有最优的情况，可能就会来到下面一步。</p><h5>Server 1 PK Server 3</h5><p><code>Server 1</code> 接收到<code>Server 3</code>的选票(1,3,0) 表示投给<code>server 3</code>.</p><p>根据<code>Server 1 PK Server 2</code>的流程类推，<code>Server 1</code>自己的选票由(1, 2)更新为(1, 3), 同样更新自己的票箱并广播给<code>Server 2</code> 和 <code>Server 3</code>；</p><p><code>Server 2</code>再次接收到<code>Server 1</code>的选票(1, 3)时经过比较后根据规则也要将自己的选票从(1, 2)更新为(1, 3), 并更新票箱里自己的选票和<code>Server 1</code>的选票，同时向<code>Server 1</code>和 <code>Server 3</code>广播；</p><p>同理 <code>Server 2</code> 和 <code>Server 3</code>也会经历上述投票过程，依次类推，<code>Server 1</code> 、<code>Server 2</code> 和<code>Server 3</code> 在俩俩之间在经历多次选举轮次比较和选票PK后最终确定各自的选票。</p><p>最后更新服务器状态：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/82571929.jpg" alt="image"></p><p>选票确定后服务器根据自己票箱中的选票确定各自的角色和状态，票箱中超过半数的选票投给自己的则为<code>Leader</code>，更新自己的状态为<code>LEADING</code>，否则为<code>Follower</code>角色，状态为<code>FOLLOWING</code>，成为<code>Leader</code>的服务器要主动向<code>Follower</code>发送心跳包，<code>Follower</code>做出<code>ACK</code>回应，以维持他们之间的长连接。</p><ul><li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener">https://dbaplus.cn/news-141-1875-1.html</a></li><li><a href="https://www.jianshu.com/p/3fec1f8bfc5f" target="_blank" rel="noopener">https://www.jianshu.com/p/3fec1f8bfc5f</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在zookeeper中其实使用的ZAB协议来实现数据的一致性，并且主要依靠的是leader和follower这两种角色控制数据的一致性，而leader是里面最重要的一个角色，它是主要负责写操作的节点，然后与其他的follower进行数据同步，所以我们也要保证leader宕机的时候要快速选举出新的leader并且进行数据恢复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记4-Zookeeper介绍</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B04-Zookeeper%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记4-Zookeeper介绍/</id>
    <published>2019-02-23T03:12:26.405Z</published>
    <updated>2019-02-23T03:15:16.676Z</updated>
    
    <content type="html"><![CDATA[<p>关于zookeeper最基本的介绍已经在笔记一中介绍了。不再赘述。ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。本文再来稍微深入一点介绍一下zookeeper的一些特性。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/18-12-3/61282486.jpg" alt="image"></p><ul><li>1、 <strong>配置维护</strong>：在分布式系统中，一般会把服务部署到n台机器上，服务配置文件都是相同的，如果配置文件的配置选项发生了改变，那我们就得一台一台的去改动。这时候zookeeper就起作用了，可以把zk当成一个高可用的配置存储器，把这样配置的事情交给zk去进行管理，将集群的配置文件拷贝到zookeeper的文件系统的某个节点上，然后用zk监控所有分布式系统里的配置文件状态，一旦发现有配置文件发生了变化，那么每台服务器同步zk的配置文件，zk同时保证同步操作的原子性，确保每个服务器的配置文件都能被更新。</li><li>2、 <strong>命名服务</strong>：在分布式应用中，通常需要一个完整的命名规则，既能够产生唯一的名称又便于人识别和记住。Zk就提供了这种服务，类似于域名和ip之间对应关系，域名容易记住，通过名称来获取资源和服务的地址，提供者等信息。</li><li>3、 <strong>分布式锁</strong>：分布式程序分布在不同主机上的进程对互斥资源进行访问的时候需要加锁。这样理解：很多分布式系统有多个服务窗口，但是某个时刻只让一个服务去干活，当这台服务器出问题的时候锁释放，里脊fail over到另外的服务。举例子，比如去某个地方办理证件的时候，只能有一个窗口对你服务，如果这个窗口的柜员有急事走了，那么系统或者经理给你指定另外一个窗口继续服务。</li><li>4、 <strong>集群管理</strong>：分布式集群中，经常会由于各种原因，比如硬件故障，网络问题，有些节点挂掉、有些节点加进来。这个时候机器需要感知到变化，然后根据变化做出对应的决策，那么zk就实现了类似这种集群的管理。</li></ul><h2>一、特性</h2><ul><li><strong>顺序一致性</strong>：<br>从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到ZooKeeper中。</li><li><strong>原子性</strong>：<br>所有事务请求的结果在集群中所有机器上的应用情况是一致的，也就是说要么整个集群所有集群都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</li><li><strong>单一视图</strong>：<br>无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性</strong>：<br>一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</li><li><strong>实时性</strong>：<br>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</li></ul><h2>二、集群角色</h2><p>最典型集群模式： Master/Slave 模式（主备模式）。在这种模式中，通常 Master服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p><p>但是，在 ZooKeeper 中没有选择传统的  Master/Slave 概念，而是引入以下三种角色：</p><ul><li>Leader</li><li>Follower</li><li>Observer</li></ul><p><img src="http://bloghello.oursnail.cn/18-12-3/61465262.jpg" alt="image"></p><p><code>zookeeper-server status</code>可以看当前节点的ZooKeeper是什么角色。</p><p>ZooKeeper默认只有Leader和Follower两种角色，没有Observer角色。</p><p>ZooKeeper集群的所有机器通过一个Leader选举过程来选定一台被称为『Leader』的机器，Leader服务器为客户端提供读和写服务。</p><p>Follower和Observer都能提供读服务，不能提供写服务。两者唯一的区别在于，Observer机器不参与Leader选举过程，也不参与写操作的『过半写成功』策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。</p><p><img src="http://bloghello.oursnail.cn/18-12-3/74661512.jpg" alt="image"></p><p>系统模型如图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-3/19717816.jpg" alt="image"></p><h2>三、关于<code>ZooKeeper</code>的一些重要概念</h2><ul><li><code>ZooKeeper</code>本身就是一个分布式程序（<strong>只要半数以上节点存活，<code>ZooKeeper</code>就能正常服务</strong>）</li><li>为了保证高可用，最好是以集群形态来部署<code>ZooKeeper</code>，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么<code>ZooKeeper</code>本身仍然是可用的。</li><li><code>ZooKeeper</code>将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持<code>znode</code>中存储的数据量较小的进一步原因）。</li><li><strong><code>ZooKeeper</code>是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。</strong>（“读”多于“写”是协调服务的典型场景。）</li><li><code>ZooKeeper</code>有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个<code>ZNode</code>被创建了，除非主动进行<code>ZNode</code>的移除操作，否则这个<code>ZNode</code>将一直保存在<code>Zookeeper</code>上。</li><li><code>ZooKeeper</code>底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提交数据节点监听服务。</li></ul><p>只要半数以上节点存活，<code>ZooKeeper</code>就能正常服务，<font color="red">这也解释了为什么集群个数一般是奇数</font>。</p><p>我们知道在<code>Zookeeper</code>中<code>Leader</code>选举算法采用了<code>Zab</code>协议。<code>Zab</code>核心思想是当多数<code>Server</code>写成功，则任务数据写成功。</p><p>①如果有3个<code>Server</code>，则最多允许1个<code>Server</code>挂掉。</p><p>②如果有4个<code>Server</code>，则同样最多允许1个<code>Server</code>挂掉。</p><p>既然3个或者4个<code>Server</code>，同样最多允许1个<code>Server</code>挂掉，那么它们的可靠性是一样的，所以选择奇数个<code>ZooKeeper Server</code>即可，这里选择3个<code>Server</code>。</p><h2>四、会话</h2><p><code>Session</code>是指客户端会话，在讲解客户端会话之前，我们先来了解下客户端连接。在<code>ZooKeeper</code>中，一个客户端连接是指客户端和<code>ZooKeeper</code>服务器之间的TCP长连接。<code>ZooKeeper</code>对外的服务端口默认是2181，客户端启动时，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测和服务器保持有效的会话，也能够向<code>ZooKeeper</code>服务器发送请求并接受响应，同时还能通过该连接接收来自服务器的<code>Watch</code>事件通知。</p><p><code>Session</code>的<code>SessionTimeout</code>值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>SessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个<code>sessionID</code>。由于<code>sessionID</code> 是<code>Zookeeper</code>会话的一个重要标识，许多与会话相关的运行机制都是基于这个<code>sessionID</code>的，因此，无论是哪台服务器为客户端分配的<code>sessionID</code>，都务必保证全局唯一。</p><h2>五、数据节点</h2><p><code>Zookeeper</code>将所有数据存储在内存中，数据模型是一棵树（<code>Znode Tree</code>)，由斜杠（/）的进行分割的路径，就是一个<code>Znode</code>，例如<code>/foo/path1</code>。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p><h2>六、Watcher</h2><p><code>Watcher</code>（事件监听器），是<code>Zookeeper</code>中的一个很重要的特性。<code>Zookeeper</code>允许用户在指定节点上注册一些<code>Watcher</code>，并且在一些特定事件触发的时候，<code>ZooKeeper</code>服务端会将事件通知到感兴趣的客户端上去，该机制是<code>Zookeeper</code>实现分布式协调服务的重要特性。</p><h2>七、版本</h2><p>在前面我们已经提到，<code>Zookeeper</code>的每个<code>ZNode</code>上都会存储数据，对应于每个<code>ZNode</code>，<code>Zookeeper</code>都会为其维护一个叫作<code>Stat</code>的数据结构，<code>Stat</code>中记录了这个<code>ZNode</code>的三个数据版本，分别是<code>version</code>（当前ZNode的版本）、<code>cversion</code>（当前ZNode子节点的版本）和 <code>cversion</code>（当前ZNode的ACL版本）。</p><p><code>Zookeeper</code>采用<code>ACL</code>（<code>AccessControlLists</code>）策略来进行权限控制，类似于<code>UNIX</code>文件系统的权限控制。</p><ul><li>CREATE: 创建子节点的权限。</li><li>READ: 获取节点数据和子节点列表的权限。</li><li>WRITE：更新节点数据的权限。</li><li>DELETE: 删除子节点的权限。</li><li>ADMIN: 设置节点ACL的权限。</li></ul><p>注意：<code>CREATE</code> 和 <code>DELETE</code> 都是针对子节点的权限控制。</p><p>下一节先说说ZAB协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于zookeeper最基本的介绍已经在笔记一中介绍了。不再赘述。ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。本文再来稍微深入一点介绍一下zookeeper的一些特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记3-paxos算法</title>
    <link href="http://yoursite.com/2019/02/22/zookeeper/Zookeeper%E7%AC%94%E8%AE%B03-paxos%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/22/zookeeper/Zookeeper笔记3-paxos算法/</id>
    <published>2019-02-22T08:34:47.187Z</published>
    <updated>2019-02-22T08:38:28.648Z</updated>
    
    <content type="html"><![CDATA[<p>有人说一千个人就有一千个paxos算法理解，算法本身晦涩难懂，如何快速生动理解paxos核心要点一直是一个老大难的问题，本文集结多篇文章精华，算是理顺了其中的门道。</p><a id="more"></a><h2>一、paxos解决了什么问题</h2><p>在上一章节中，我们着重提到了解决一致性问题的两种协议：2PC和3PC。但是在分布式环境中，这两种协议都无法真正实现一致性(分布式的一致性问题其实主要是指分布式系统中的数据一致性问题。所以，为了保证分布式系统的一致性，就要保证分布式系统中的数据是一致的。)</p><p>分布式系统中的节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。基于消息传递通信模型的分布式系统，不可避免的会发生以下错误：</p><ul><li>进程可能会慢、被杀死或者重启</li><li>消息可能会延迟、丢失、重复</li></ul><p>（在基础 Paxos 场景中，先不考虑可能出现消息篡改即拜占庭错误的情况）</p><p><strong>⭐Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。</strong></p><p>那么我们可用形象地理解为：Paxos可以说是一个民主选举的算法——大多数节点的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的节点同意。取值一旦确定将不再更改，并且可以被获取到(不可变性，可读取性)。</p><h2>二、典型场景</h2><p>一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。</p><p>所以，<strong>paxos算法主要解决的问题就是如何保证分布式系统中各个节点都能执行一个相同的操作序列</strong>。</p><p><img src="http://bloghello.oursnail.cn/18-12-2/77123681.jpg" alt="image"></p><p>上图中，C1是一个客户端，N1、N2、N3是分布式部署的三个服务器，初始状态下N1、N2、N3三个服务器中某个数据的状态都是S0。当客户端要向服务器请求处理操作序列：op1–op2–op3时（op表示operation）</p><p>如果想保证在处理完客户端的请求之后，N1、N2、N3三个服务器中的数据状态都能从S0变成S1并且一致的话（或者没有执行成功，还是S0状态），就要保证N1、N2、N3在接收并处理操作序列op1–op2–op3时，严格按照规定的顺序正确执行opi，要么全部执行成功，要不就全部都不执行。</p><p>所以，针对上面的场景，paxos解决的问题就是如何依次确定不可变操作opi的取值，也就是确定第i个操作什么，在确定了opi的内容之后，就可以让各个副本执行opi操作。</p><h2>三、paxos算法</h2><h3>1、算法涉及的主要角色：</h3><ul><li>Proposer：提议者，提出议案(同时存在一个或者多个，他们各自发出提案)</li><li>Acceptor：接受者，收到议案后选择是否接受</li><li>Learner：最终决策学习者，只学习正确的决议</li><li>Client：产生议题者，发起新的请求</li></ul><p><img src="http://bloghello.oursnail.cn/18-12-3/34413307.jpg" alt="image"></p><p>主要的角色就是“提议者”和“接受者”。先有提议，再来表决。（注：实际应用中，可以将一堆服务器任意指定角色，一部分做“提议者”、一部分做“接受者”，也可以指定特定的服务器做“提议者”，剩下的都是“接受者”。）</p><p><code>Proposer</code>就像<code>Client</code>的代理人，由<code>Proposer</code>拿着<code>Client</code>的议题去向<code>Acceptor</code>提议，让<code>Acceptor</code>来做出决策。</p><p>这幅图表示的是角色之间的逻辑关系，每一种角色就代表了一种节点类型。在物理部署环节，可以把每一种角色都部署在一台物理机器上，也可以组合任何两种或者多种角色部署在一台物理机器上，甚至于，把这四种角色都部署在同一台物理机器上也是可以的。</p><h3>2、关于这两阶段的理解</h3><p>从一个故事说起。</p><p>从前，在国王Leslie Lamport的统治下，有个黑暗的希腊城邦叫paxos。城邦里有3类人，</p><ul><li>决策者</li><li>提议者</li><li>群众</li></ul><p>虽然这是一个黑暗的城邦但是很民主，按照议会民主制的政治模式制订法律，群众有什么建议和意见都可以写提案交给提议者，提议者会把提案交给决策者来决策，决策者有奇数个，为什么要奇数个？很简单因为决策的方式很无脑，少数服从多数。最后决策者把刚出炉的决策昭告天下，群众得知决策结果。</p><p>等一下，那哪里黑暗呢？问题就出在“提议者会把提案交给决策者来决策”，那么多提案决策者先决策谁的？谁给的钱多就决策谁的。</p><p>那这样会有几个问题，决策者那么多，怎么保证最后决策的是同一个提案，以及怎么保证拿到所有提议者中最高的报价。</p><p>聪明又贪婪的决策者想到了一个办法：分两阶段报价</p><p><strong>第一阶段</strong>：</p><ul><li>决策者接受所有比他当前持有报价高的报价，且不会通知之前报价的人</li><li>提议者给所有(一半以上即可)决策者报价，若有人比自己报价高就加价，有半数以上决策者接受自己报价就停止报价。</li></ul><p>一旦某个提议者收到了所有决策者中一半以上的人同意的回复。就会进入第二阶段。</p><p><strong>第二阶段</strong>：</p><p>提议者去找收过自己钱的大佬签合同，这里有3种情况：</p><ul><li>很多大佬收了别人更高的价，达不到一半人数了，只好回去拿钱继续贿赂，回到第一阶段重新升级;</li><li>大佬收到的最高报价是自己的，美滋滋，半数以上成功签合同，提案成功;</li><li>提议者回去拿钱回来继续贿赂的时候发现合同已经被签了且半数以上都签了这个提案，不干了，赶快把自己的提案换成已经签了的提案，再去提给所有大佬，看看能不能分一杯羹遇见还没签的大佬。</li></ul><p>最后一步就是让所有节点知道这个过半通过的提议是什么，从而达到最终的一致。</p><h2>三、深化理解</h2><p>假设有两个“提议者”和三个“接受者”。下面这一坨的内容一开始如果看不明白不要紧，立即转到下面的图示过程，看懂图示再回过头来就会理解了。</p><ul><li>怎么明确意见领袖呢？通过编号。每个“提议者”在第一阶段先报个号，谁的号大，谁就是意见领袖。如果不好理解，可以想象为贿选。每个提议者先拿着钞票贿赂一圈“接受者”，谁给的钱多，第二阶段“接受者”就听谁的。<strong>意见领袖理解为贿赂中胜出的“提议者”即可</strong>。</li><li>有个跟选举常识不一样的地方，<strong>就是每个“提议者”不会执着于让自己的提议通过，而是每个“提议者”会执着于让提议尽快达成一致意见</strong>。所以，为了这个目标，如果“提议者”在贿选的时候，发现“接受者”已经接受过前面意见领袖的提议了，即便“提议者”贿选成功，也会默默的把自己的提议改为前面意见领袖的提议。所以一旦贿赂成功，胜出的“提议者”再提出提议，提议内容也是前面意见领袖的提议（这样，在谋求尽早形成多数派的路上，又前进了一步）。</li><li>钱的多少很重要，如果钱少了，无论在第一还是第二阶段“接受者”都不会鸟你，直接拒绝。</li><li>上面讲到，如果“提议者”在贿选时，发现前面已经有意见领袖的提议，那就将自己的提议默默改成前面意见领袖的提议。这里有一种情况，如果你是“提议者”，在贿赂的时候，“接受者1”跟你说“他见过的意见领袖的提议是方案1”，而“接受者2”跟你说“他见过的意见领袖提议是方案2”，你该怎么办？这时的原则也很简单，还是：钱的多少很重要！你判断一下是“接受者1”见过的意见领袖有钱，还是“接受者2”见过的意见领袖有钱？如何判断呢？因为“接受者”在被“提议者”贿赂的时候，自己会记下贿赂的金额。所以当你贿赂“接受者”时，一旦你给的贿赂多而胜出，“接受者”会告诉你两件事情：a.前任意见领袖的提议内容（如果有的话），b.前任意见领袖当时贿赂了多少钱。这样，再面对刚才的情景时，你只需要判断一下“接受者1”和“接受者2”告诉你的信息中，哪个意见领袖当时给的钱多，那你就默默的把自己的提议，改成那个意见领袖的提议。</li><li>在整个选举过程中，每个人谁先来谁后到，“接受者”什么时间能够接到“提议者”的信息，是完全不可控的。所以很可能一个意见领袖已经产生了，但是由于这个意见领袖的第二阶段刚刚开始，绝大部分“接受者”还没有收到这个意见领袖的提议。结果，这时突然冲进来了一个新的土豪“提议者”，那么这个土豪“提议者”也是有机会让自己的提议胜出的！这时就形成了一种博弈：a.上一个意见领袖要赶在土豪“提议者”贿赂到“接受者”前，赶到“接受者”面前让他接受自己的提议，否则会因为自己的之前贿赂的钱比土豪少而被拒绝。b.土豪“提议者”要赶在上一个意见领袖将提议传达给“接受者”前，贿赂到“接受者”，否则土豪“提议者”即便贿赂成功，也要默默的将自己的提议改为前任意见领袖的提议。这整个博弈的过程，最终就看这两个“提议者”谁的进展快了。但最终一定会有一个意见领袖，先得到多数“接受者”的认可，那他的提议就胜出了。这一块不理解就看下面的分解说明。</li></ul><p>1）首先“提议者1”贿赂了3个“接受者”</p><p><img src="http://bloghello.oursnail.cn/zk3-1.png" alt="image"></p><p>2）3个“接受者”记录下贿赂金额，因为目前只有一个“提议者”出价，因此$1就是最高的了，所以“接受者”们返回贿赂成功。此外，因为没有任何先前的意见领袖提出的提议，因此“接受者”们告诉“提议者1”没有之前接受过的提议（自然也就没有上一个意见领袖的贿赂金额了）。</p><p>假如此时由于贿赂的人数超过了一半，那么第一阶段成功，准备进入第二阶段，就是正式签合同，签超过半数的合同才真正表示本轮成功。</p><p><img src="http://bloghello.oursnail.cn/zk3-2.png" alt="image"></p><p>3）“提议者1”发现有超过一半人接受了自己的贿赂，下面就要真正发起提议了，先向“接受者1”提出了自己的提议：1号提议，并告知自己之前已贿赂$1。</p><p><img src="http://bloghello.oursnail.cn/zk3-3.png" alt="image"></p><p>4）“接受者1”检查了一下，目前记录的贿赂金额就是$1，于是接受了这一提议，并把1号提议记录在案。</p><p><img src="http://bloghello.oursnail.cn/zk3-4.png" alt="image"></p><p>5）在“提议者1”向“接受者2”“接受者3”发起提议前，土豪“提议者2”出现，他开始用$2贿赂“接受者1”与“接受者2”。</p><p><img src="http://bloghello.oursnail.cn/zk3-5.png" alt="image"></p><p>6）“接受者1”与“接受者2”立刻被收买，将贿赂金额改为$2。但是，不同的是：“接受者1”告诉“提议者2”,之前我已经接受过1号提议了，同时1号提议的“提议者”贿赂过$1；而，“接受者2”告诉“提议者2”，之前没有接受过其他意见领袖的提议，也没有上一个意见领袖的贿赂金额。</p><p><img src="http://bloghello.oursnail.cn/zk3-6.png" alt="image"></p><p>7）这时，“提议者1”回过神来了，他向“接受者2”和“接受者3”发起1号提议，并带着信息“我前期已经贿赂过$1”。</p><p><img src="http://bloghello.oursnail.cn/zk3-7.png" alt="image"></p><p>8）“接受者2”“接受者3”开始答复：“接受者2”检查了一下自己记录的贿赂金额，然后表示，已经有人出价到$2了，而你之前只出到$1，不接受你的提议，再见。但“接受者3”检查了一下自己记录的贿赂金额，目前记录的贿赂金额就是$1，于是接受了这一提议，并把1号提议记录在案。</p><p><img src="http://bloghello.oursnail.cn/zk3-8.png" alt="image"></p><p>9）到这里，“提议者1”已经得到两个接受者的赞同，已经得到了多数“接受者”的赞同。于是“提议者1”确定1号提议最终通过。</p><p>10）此时“提议者2”发现1号提议已经被通过了，为了最快达成一致，那么他就默默地将自己的提议也改为与1号提议一致，然后开始向“接受者1”“接受者2”发起提议（提议内容仍然是1号提议），并带着信息：之前自己已贿赂过$2。</p><p><img src="http://bloghello.oursnail.cn/zk3-9.png" alt="image"></p><p>11）这时“接受者1”“接受者2”收到“提议者2”的提议后，照例先比对一下贿赂金额，比对发现“提议者2”之前已贿赂$2，并且自己记录的贿赂金额也是$2，所以接受他的提议，也就是都接受1号提议。</p><p><img src="http://bloghello.oursnail.cn/zk3-10.png" alt="image"></p><p>12）于是，“提议者2”也拿到了多数派的意见，最终通过的也是1号提议。</p><p>回到上面的第5）步，如果“提议者2”第一次先去贿赂“接受者2”“接受者3”会发生什么？那很可能1号提议就不会成为最终选出的提议。因为当“提议者2”先贿赂到了“接受者2”“接受者3”，那等“提议者1”带着议题再去找这两位的时候，就会因为之前贿赂的钱少（$1&lt;$2）而被拒绝。所以，这也就是刚才讲到可能存在博弈的地方：a.“提议者1”要赶在“提议者2”贿赂到“接受者2”“接受者3”之前，让“接受者2”“接受者3”接受自己的意见，否则“提议者1”会因为钱少而被拒绝；b.“提议者2”要赶在“提议者1”之前贿赂到“接受者”，否则“提议者2”即便贿赂成功，也要默默的将自己的提议改为“提议者1”的提议。但你往后推演会发现，无论如何，总会有一个“提议者”的提议获得多数票而胜出。</p><h2>五、总结</h2><p>好啦，故事到这里基本讲述完了，咱们来总结一下，其实Paxos算法就下面这么几个原则：</p><ul><li>Paxos算法包括两个阶段：第一个阶段主要是贿选，还没有提出提议；第二个阶段主要根据第一阶段的结果，明确接受谁的提议，并明确提议的内容是什么（这个提议可能是贿选胜出“提议者”自己的提议，也可能是前任意见领袖的提议，具体是哪个提议，见下面第3点原则）。</li><li>编号（贿赂金额）很重要，无论在哪个阶段，编号（贿赂金额）小的，都会被鄙视（被拒绝）。</li><li>在第一阶段中，一旦“接受者”已经接受了之前意见领袖的提议，那后面再来找这个“接受者”的“提议者”，即便在贿赂中胜出，也要被洗脑，默默将自己的提议改为前任意见领袖的提议，然后他会在第二阶段提出该提议（也就是之前意见领袖的提议，以力争让大家的意见趋同）。如果“接受者”之前没有接受过任何提议，那贿选胜出的“提议者”就可以提出自己的提议了。</li></ul><p>还有一个问题需要考量，假如<code>proposer A</code>发起ID为n的提议，在提议未完成前<code>proposer B</code>又发起ID为n+1的提议，在n+1提议未完成前<code>proposer C</code>又发起ID为n+2的提议…… 如此<code>acceptor</code>不能完成决议、形成活锁(<code>livelock</code>)，虽然这不影响一致性，但我们一般不想让这样的情况发生。解决的方法是从<code>proposer</code>中选出一个<code>leader</code>，提议统一由<code>leader</code>发起。</p><ul><li><a href="https://www.zhihu.com/question/19787937" target="_blank" rel="noopener">如何浅显易懂地解说 Paxos 的算法？</a></li><li><a href="https://zhuanlan.zhihu.com/p/44997221" target="_blank" rel="noopener">共识算法之：Paxos</a></li><li><a href="http://blog.51cto.com/9587671/2286358" target="_blank" rel="noopener">讲一个关于paxos的故事</a></li><li><a href="https://zhuanlan.zhihu.com/p/21895686" target="_blank" rel="noopener">浅显易懂地解读Paxos算法</a></li><li><a href="http://www.cnblogs.com/bangerlee/p/5655754.html" target="_blank" rel="noopener">分布式系统理论进阶 - Paxos</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有人说一千个人就有一千个paxos算法理解，算法本身晦涩难懂，如何快速生动理解paxos核心要点一直是一个老大难的问题，本文集结多篇文章精华，算是理顺了其中的门道。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记2-2PC&amp;3PC</title>
    <link href="http://yoursite.com/2019/02/22/zookeeper/Zookeeper%E7%AC%94%E8%AE%B02-2PC&amp;3PC/"/>
    <id>http://yoursite.com/2019/02/22/zookeeper/Zookeeper笔记2-2PC&amp;3PC/</id>
    <published>2019-02-22T03:21:19.880Z</published>
    <updated>2019-02-22T03:25:43.424Z</updated>
    
    <content type="html"><![CDATA[<p>很多人对解决分布式系统中一致性问题的难度还没有一个直观的感受，本节详细讲解分布式系统中一致性面临的种种挑战，并且详细说明2PC和3PC这些比较简单的解决方案的原理和存在的问题，为后面引出zk的解决方案做铺垫。</p><a id="more"></a><h2>一、前言</h2><p>分布式系统中，一致性问题是一个比较重要的问题，zookeeper解决的就是分布式系统的一致性问题。下面我们从一致性问题、特定条件下解决一致性问题的两种方法(2PC、3PC)入门，了解最基础的分布式系统理论。</p><h2>二、一致性</h2><p>何为一致性问题？简单而言，一致性问题就是相互独立的节点之间如何达成一项决议的问题。分布式系统中，进行数据库事务提交(commit transaction)、Leader选举、序列号生成等都会遇到一致性问题。这个问题在我们的日常生活中也很常见，比如牌友怎么商定几点在哪打几圈麻将.</p><p>假设一个具有N个节点的分布式系统，当其满足以下条件时，我们说这个系统满足一致性：</p><ul><li><strong>全认同(agreement):</strong> 所有N个节点都认同一个结果</li><li><strong>值合法(validity)</strong>: 该结果必须由N个节点中的节点提出</li><li><strong>可结束(termination)</strong>: 决议过程在一定时间内结束，不会无休止地进行下去</li></ul><p>有人可能会说，决定什么时候在哪搓搓麻将，4个人商量一下就ok，这不很简单吗？</p><p>但就这样看似简单的事情，分布式系统实现起来并不轻松，因为它面临着上一节所说的这些问题：</p><ul><li><strong>消息传递异步无序(asynchronous)</strong>: 现实网络不是一个可靠的信道，存在消息延时、丢失，节点间消息传递做不到同步有序(synchronous)</li><li><strong>节点宕机(fail-stop)</strong>: 节点持续宕机，不会恢复</li><li><strong>节点宕机恢复(fail-recover)</strong>: 节点宕机一段时间后恢复，在分布式系统中最常见</li><li><strong>网络分化(network partition)</strong>: 网络链路出现问题，将N个节点隔离成多个部分</li><li><strong>拜占庭将军问题(byzantine failure)</strong>: 节点或宕机或逻辑失败，甚至不按套路出牌抛出干扰决议的信息</li></ul><p>假设现实场景中也存在这样的问题，我们看看结果会怎样：</p><blockquote><p>第一种情况：</p><p>我: 老王，今晚7点老地方，搓够48圈不见不散！</p><p>……</p><p>(第二天凌晨3点) 隔壁老王: 没问题！       // 消息延迟</p><p>我: ……</p><hr><p>第二种情况：</p><p>我: 小张，今晚7点老地方，搓够48圈不见不散！</p><p>小张: No ……</p><p>(两小时后……)</p><p>小张: No problem！                     // 宕机节点恢复</p><p>我: ……</p><hr><p>第三种情况：</p><p>我: 老李头，今晚7点老地方，搓够48圈不见不散！</p><p>老李: 必须的，大保健走起！               // 拜占庭将军</p><p>(这是要打麻将呢？还是要大保健？还是一边打麻将一边大保健……)</p></blockquote><p>还能不能一起愉快地玩耍…</p><p>正如上节所说，在分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）中最多只能满足两个。那么，第三个是一定要满足的了。那么强一致性和高可用必定不能同时满足。</p><p>对于一致性，2PC、3PC是相对简单的解决强一致性问题的协议，下面我们就来了解2PC和3PC。</p><h2>三、协调者</h2><p>在分布式系统中，每一个机器节点虽然都能明确的知道自己执行的事务是成功还是失败，但是却无法知道其他分布式节点的事务执行情况。因此，当一个事务要跨越多个分布式节点的时候（比如，淘宝下单流程，下单系统和库存系统可能就是分别部署在不同的分布式节点中），为了保证该事务可以满足ACID，就要引入一个协调者（Cooradinator）。其他的节点被称为参与者（Participant）。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。</p><h2>四、2PC(二阶提交)</h2><p>顾名思义它分成两个阶段，先由一方进行提议(<code>propose</code>)并收集其他节点的反馈(<code>vote</code>)，再根据反馈决定提交(<code>commit</code>)或中止(<code>abort</code>)事务。我们将提议的节点称为协调者(<code>coordinator</code>)，其他参与决议节点称为参与者(<code>participants</code>, 或<code>cohorts</code>)。</p><p>在阶段1中，协调者发起一个提议，分别问询各参与者是否接受。只要有一个参与者没有准备好就中止。</p><p><strong>值得注意的是，二阶段提交协议的第一阶段准备阶段不仅仅是回答YES or NO，还是要执行事务操作的，只是执行完事务操作，并没有进行commit还是roolback</strong>。也就是说，一旦事务执行之后，在没有执行commit或者roolback之前，<strong>资源是被锁定的。这会造成阻塞</strong>。</p><blockquote><p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p><p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息(用于失败时的回滚)和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p><p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p></blockquote><p>在阶段2中，协调者根据参与者的反馈，提交或中止事务，如果参与者全部同意则提交，只要有一个参与者不同意就中止。释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><p><img src="http://bloghello.oursnail.cn/18-12-2/40570941.jpg" alt="image"></p><p>问题：</p><blockquote><p>1、<strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p><p>2、<strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p><p>3、<strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p><p>二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p></blockquote><p>为了解决这些问题，衍生出了对2PC的改进3PC。我们接下来看看3PC是如何解决这些问题的。</p><h2>五、3PC(三阶段提交)</h2><p><strong>3PC最关键要解决的是单点和阻塞。</strong></p><p>所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。在第一阶段，只是询问所有参与者是否可可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行<code>commit</code>或者<code>rollback</code>。</p><p><img src="http://bloghello.oursnail.cn/18-12-2/7007072.jpg" alt="image"></p><h4>5.1 CanCommit阶段</h4><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><p>但是此时不执行事务的操作，也就时说不会锁住资源。</p><h4>5.2 PreCommit阶段</h4><p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。此时会执行事务操作和将undo和redo信息记录到事务日志中。如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><h4>5.3 doCommit阶段</h4><p>加入协调接收到所有参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p><p>协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><p><strong>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</strong></p><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。</p><p>但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><h2>六、总结</h2><p>了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， <code>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.</code> 意即世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人对解决分布式系统中一致性问题的难度还没有一个直观的感受，本节详细讲解分布式系统中一致性面临的种种挑战，并且详细说明2PC和3PC这些比较简单的解决方案的原理和存在的问题，为后面引出zk的解决方案做铺垫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记1-CAP和BASE理论</title>
    <link href="http://yoursite.com/2019/02/22/zookeeper/Zookeeper%E7%AC%94%E8%AE%B01-CAP%E5%92%8CBASE%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/02/22/zookeeper/Zookeeper笔记1-CAP和BASE理论/</id>
    <published>2019-02-22T02:48:24.749Z</published>
    <updated>2019-02-22T02:49:36.371Z</updated>
    
    <content type="html"><![CDATA[<p>随着应用规模的迅速扩张，单台机器的部署已经难以支撑用户大规模、高并发的请求了， 因此服务化、集群化、分布式概念应运而生。 然而， 集群的维护和多节点应用程序的协作运行远比单机模式复杂，需要顾及到的细节问题实在太多，比如说同一分配置在多台机器上的同步， 客户端程序实时感知服务机状态，应用与应用之间的公共资源的互斥访问等等一系列的问题。zookeeper能够给我们非常完美的解决这些问题，zookeeper天生的就是为解决分布式协调服务这个问题而来。</p><a id="more"></a><h2>一、前言</h2><p>学习<code>zookeeper</code>才算是真正跨进分布式这个大门。比较经典的应用是可以作为<code>dubbo</code>推荐的注册中心。</p><p>首先，我们必须要明确几个我们之前可能不会遇到的但是在分布式系统中又很常见的问题：</p><ul><li>网络相当可靠</li><li>延迟为0</li><li>传输带宽是无限的</li><li>网络相当安全</li><li>拓扑结构不会改变</li><li>必须要有一个管理员</li><li>传输成本为0</li><li>网络同质化</li></ul><p>总结起来，分布式系统中最常出现的问题是：通信异常，表现为网络通信成功，失败和超时；节点故障，包括宕机和OOM。</p><h2>二、Zookeeper是什么</h2><p>官方解释：</p><blockquote><p>它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p></blockquote><p>上面的解释有点抽象，简单来说<strong>zookeeper=文件系统+监听通知机制</strong>。我们这里拿比较简单的分布式应用配置管理为例来说明。</p><p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到<code>zookeeper</code>上去，保存在 <code>zookeeper</code> 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 <code>zookeeper</code> 的通知，然后从 <code>zookeeper</code> 获取新的配置信息应用到系统中。</p><p><img src="http://bloghello.oursnail.cn/18-12-2/72299928.jpg" alt="image"></p><h2>三、Zookeeper设计目的</h2><ul><li>1、最终一致性：<code>client</code>不论连接到哪个<code>Server</code>，展示给它都是同一个视图，这是<code>zookeeper</code>最重要的性能。</li><li>2、可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。</li><li>3、实时性：<code>Zookeeper</code>保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，<code>Zookeeper</code>不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用<code>sync()</code>接口。</li><li>4、等待无关（wait-free）：慢的或者失效的<code>client</code>不得干预快速的<code>client</code>的请求，使得每个<code>client</code>都能有效的等待。</li><li>5、原子性：更新只能成功或者失败，没有中间状态。</li><li>6、顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li></ul><h2>四、CAP理论</h2><p>指的是在一个分布式系统中，不可能同时满足<code>Consistency</code>（一致性）、 <code>Availability</code>（可用性）、<code>Partition tolerance</code>（分区容错性）这三个基本需求，最多只能满足其中的两项。</p><ul><li>1、一致性：<br>指数据在多个副本之间是否能够保持一致的特性。当执行数据更新操作后，仍然保证系统数据处于一致的状态。</li><li>2、可用性（高可用）：<br>系统提供的服务必须一直处于可用的状态。对于用户的每一个操作请求总是能够在“有限的时间内”返回结果。这个有限时间是系统设计之初就指定好的系统运行指标。返回的结果指的是系统返回用户的一个正常响应结果，而不是“out ot memory error”之类的系统错误信息。</li><li>3、分区容错性（数据分片）：<br>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。组成分布式系统的每个节点的加入与退出都可以看成是一个特殊的网络分区。</li></ul><p>一个分布式系统无法同时满足这三个条件，只能满足两个，意味着我们要抛弃其中的一项，如下图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-2/16526528.jpg" alt="image"></p><ul><li>1、CA，放弃P：将所有数据都放在一个分布式节点上。这同时放弃了系统的可扩展性。</li><li>2、CP，放弃A：一旦系统遇到故障时，受影响的服务器需要等待一段时间，在恢复期间无法对外提供正常的服务。</li><li>3、AP，放弃C：这里的放弃一致性是指放弃数据强一致性，而保留数据的最终一致性。系统无法实时保持数据的一致，但承诺在一个限定的时间窗口内，数据最终能够达到一致的状态。</li></ul><p>对于分布式系统而言，分区容错性是一个最基本的要求，因为分布式系统中的组件必然需要部署到不通的节点，必然会出现子网络，在分布式系统中，网络问题是必定会出现的异常。因此分布式系统只能在C（一致性）和A（可用性）之间进行权衡。</p><h2>五、BASE理论</h2><p><code>Basically Available</code>（基本可用）、<code>Soft-state</code>（ 软状态/柔性事务）、<code>Eventual Consistency</code>（最终一致性）。是基于CAP定理演化而来，是对CAP中一致性和可用性权衡的结果。</p><p>核心思想：即使无法做到强一致性，但每个业务根据自身的特点，采用适当的方式来使系统达到最终一致性。</p><ul><li>1、基本可用：<br>指分布式系统在出现故障的时候，允许损失部分可用性，保证核心可用。但不等价于不可用。比如：搜索引擎0.5秒返回查询结果，但由于故障，2秒响应查询结果；网页访问过大时，部分用户提供降级服务，等。</li><li>2、软状态：<br>软状态是指允许系统存在中间状态，并且该中间状态不会影响系统整体可用性。即允许系统在不同节点间副本同步的时候存在延时。</li><li>3、最终一致性：<br>系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，不需要实时保证系统数据的强一致性。最终一致性是弱一致性的一种特殊情况。</li></ul><p>BASE理论面向的是大型高可用可扩展的分布式系统，通过牺牲强一致性来获得可用性。ACID是传统数据库常用的概念设计，追求强一致性模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着应用规模的迅速扩张，单台机器的部署已经难以支撑用户大规模、高并发的请求了， 因此服务化、集群化、分布式概念应运而生。 然而， 集群的维护和多节点应用程序的协作运行远比单机模式复杂，需要顾及到的细节问题实在太多，比如说同一分配置在多台机器上的同步， 客户端程序实时感知服务机状态，应用与应用之间的公共资源的互斥访问等等一系列的问题。zookeeper能够给我们非常完美的解决这些问题，zookeeper天生的就是为解决分布式协调服务这个问题而来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot通用知识深入--切面、异常、单元测试</title>
    <link href="http://yoursite.com/2019/02/21/miscellany/SupringBoot%E9%80%9A%E7%94%A8%E7%9F%A5%E8%AF%86%E6%B7%B1%E5%85%A5--%E5%88%87%E9%9D%A2%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/02/21/miscellany/SupringBoot通用知识深入--切面、异常、单元测试/</id>
    <published>2019-02-21T13:35:00.787Z</published>
    <updated>2019-02-22T02:08:54.400Z</updated>
    
    <content type="html"><![CDATA[<p>对于小白来说，下面的知识都是满满的干货，值得好好学习，具体的视频是学习的廖师兄的<a href="http://www.imooc.com/learn/810" target="_blank" rel="noopener">Spring Boot进阶之Web进阶</a>，值得一看，下面是笔记总结。</p><a id="more"></a><h2>一、面向切面编程</h2><p><img src="http://bloghello.oursnail.cn/zaji16-1.png" alt="image"></p><p>访问 <code>localhost:8080/dev/add</code> 日志打印结果是：</p><p><img src="http://bloghello.oursnail.cn/zaji16-2.png" alt="image"></p><h2>二、校验和返回结果封装</h2><p>1、首先是在<code>student</code>类中对<code>username</code>增加注解：<code>@NotNull(message = &quot;用户名不能为空&quot;)</code></p><p>2、在增加一个学生的方法上进行参数的验证：</p><p><img src="http://bloghello.oursnail.cn/zaji16-3.png" alt="image"></p><p>3、在http工具上输入</p><blockquote><p><a href="http://localhost:8080/dev/add?username=hello&amp;age=10" target="_blank" rel="noopener">http://localhost:8080/dev/add?username=hello&amp;age=10</a></p></blockquote><p>返回正确信息，即学生的json流：{“id”:5,“username”:“hello”,“age”:10}</p><p>如果不传<code>username</code>，即必填的那一项不给，则发生异常：</p><blockquote><p><a href="http://localhost:8080/dev/add?age=10" target="_blank" rel="noopener">http://localhost:8080/dev/add?age=10</a></p></blockquote><p>返回信息为：用户名不能为空</p><p>4、我们会发现，正确返回是新添加学生的json格式，错误返回就是一个字符串，这样对于前台来说是无法处理的，所以需要一个封装类来包装一下。</p><p><img src="http://bloghello.oursnail.cn/zaji16-4.png" alt="image"></p><p>5、下面对controller层进行改造，返回统一的格式。</p><p><img src="http://bloghello.oursnail.cn/zaji16-5.png" alt="image"></p><p>6、controller曾进行结果封装的时候，发现代码重复，进行优化。</p><p>新建一个工具类，用来封装结果。</p><p><img src="http://bloghello.oursnail.cn/zaji16-6.png" alt="image"></p><p>继而改造controller:</p><p><img src="http://bloghello.oursnail.cn/zaji16-7.png" alt="image"></p><p>结果与上面一致。</p><h2>三、统一异常处理</h2><p>如果service层业务逻辑是：</p><p><img src="http://bloghello.oursnail.cn/zaji16-8.png" alt="image"></p><p>1、我们第一个想到的方案可能是给每一种情况加上一个标记，controller层根据标记的不同进行不同的返回处理：</p><p>service层方法：</p><p><img src="http://bloghello.oursnail.cn/zaji16-9.png" alt="image"></p><p>相应的controller层为：</p><p><img src="http://bloghello.oursnail.cn/zaji16-10.png" alt="image"></p><p>对于逻辑比较简单的情况下，是可以到达我们的预期效果，但是一旦业务量逻辑复杂度高一点，就会非常地混乱。解决方案是统一异常处理。</p><p>2、加上异常处理</p><p>service层处理为:</p><p><img src="http://bloghello.oursnail.cn/zaji16-11.png" alt="image"></p><p>controller层处理为:</p><p><img src="http://bloghello.oursnail.cn/zaji16-12.png" alt="image"></p><p>返回结果为：</p><p><img src="http://bloghello.oursnail.cn/zaji16-13.png" alt="image"></p><p>显然格式都是不统一的，解决方案是对默认的exception返回信息再进行一次封装。</p><p>3、修改exception返回信息格式：</p><p>新建一个handle类：</p><p><img src="http://bloghello.oursnail.cn/zaji16-14.png" alt="image"></p><p>但是对于这种方式，如果我想让上小学的学硕状态码为100,上初中的学生的状态码为101，就无法实现了。解决方案：自定义异常。</p><p>4、自定义异常</p><p>新建一个异常类：</p><p><img src="http://bloghello.oursnail.cn/zaji16-15.png" alt="image"></p><p>在<code>service</code>层抛出异常为<code>throw new StudentException(100,&quot;还在上小学&quot;)</code>。</p><p>在刚才写的默认异常处理类中进行判断处理：</p><p><img src="http://bloghello.oursnail.cn/zaji16-16.png" alt="image"></p><p>这样，当属于小学生时，状态码为100,当属于初中生时，状态码为101，就区分开了。当不属于这个异常的异常，就会抛出未知错误。这样也不好，最好用日志将未知错误打印出来。</p><p>5、系统异常(默认异常处理):</p><p><img src="http://bloghello.oursnail.cn/zaji16-17.png" alt="image"></p><p>到现在仍然存在一些问题：状态码与状态信息都是自己在程序中临时定义的，是不规范的行为，需要有一个地方统一管理，便于区分和防止混乱重复。</p><p>6、枚举定义异常状态</p><p><img src="http://bloghello.oursnail.cn/zaji16-18.png" alt="image"></p><p>改造service层：</p><p><img src="http://bloghello.oursnail.cn/zaji16-19.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/zaji16-20.png" alt="image"></p><p>这样就完成了异常的统一管理。</p><h2>四、springboot测试</h2><p>1、对于service层的测试<br>创建：方法名右击—go to–test</p><p><img src="http://bloghello.oursnail.cn/zaji16-21.png" alt="image"></p><p>2、对于controller层的api的测试</p><p><img src="http://bloghello.oursnail.cn/zaji16-22.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于小白来说，下面的知识都是满满的干货，值得好好学习，具体的视频是学习的廖师兄的&lt;a href=&quot;http://www.imooc.com/learn/810&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot进阶之Web进阶&lt;/a&gt;，值得一看，下面是笔记总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>10.Sleuth服务追踪</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/10.Sleuth%E6%9C%8D%E5%8A%A1%E8%BF%BD%E8%B8%AA/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/10.Sleuth服务追踪/</id>
    <published>2019-02-21T08:27:32.524Z</published>
    <updated>2019-02-21T08:38:13.508Z</updated>
    
    <content type="html"><![CDATA[<p>在以前，所有的东西放在一起打包，放到服务器上也就不管了，但是到了分布式场景下，可能一个请求要经过十几个服务的周转，如果不进行链路的追踪，这些对于我们来说都是透明的，那么哪个节点存在问题或者存在超时隐患我们都是很难知道的，因此服务追踪是我们必须要做的一样事情。</p><a id="more"></a><h2>一、为什么需要进行分布式链路追踪springcloud-sleuth呢？</h2><p>随着分布式系统越来越复杂，你的一个请求发过发过去，各个微服务之间的跳转，有可能某个请求某一天压力太大了，一个请求过去没响应，一个请求下去依赖了三四个服务，但是你去不知道哪一个服务出来问题，这时候我是不是需要对微服务进行追踪呀？监控一个请求的发起，从服务之间传递之间的过程，我最好记录一下，记录每一个的耗时多久，一旦出了问题，我们就可以针对性的进行优化，是要增加节点，减轻压力，还是服务继续拆分，让逻辑更加简单点呢？这时候springcloud-sleuth集成zipkin能帮我们解决这些服务追踪问题。</p><h2>二、创建工程</h2><p>本工程的<code>Spring Boot</code>的版本为<code>1.5.8</code>，<code>Spring Cloud</code>版本为<code>Dalston.RELEASE</code>。包含了<code>eureka-server</code>工程，作为服务注册中心，<code>eureka-server</code>的创建过程这里不重复；<code>zipkin-server</code>作为链路追踪服务中心，负责存储链路数据；<code>gateway-service</code>作为服务网关工程，负责请求的转发,同时它也作为链路追踪客户端，负责产生数据，并上传给<code>zipkin-service</code>；<code>user-service</code>为一个应用服务，对外暴露API接口，同时它也作为链路追踪客户端，负责产生数据。</p><h3>1.构建eureka-server</h3><p>这个服务就比较简单了，就是eureka的服务端，用来注册服务。见代码<code>eureka-server</code>.</p><h3>2.构建zipkin-server</h3><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--eureka服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--zipkin服务端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--显示的页面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主函数上打上两个注解开启<code>ZipkinServer</code>的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableZipkinServer</span></span><br></pre></td></tr></table></figure><p>配置文件上也很简单，注册到<code>eureka</code>上和指定好启动的端口即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br><span class="line">server:</span><br><span class="line">  port: 9411</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: zipkin-server</span><br></pre></td></tr></table></figure><h3>3.构建user-service</h3><p>新建一个工程，取名为<code>user-service</code>，作为应用服务，对外暴露API接口.</p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打上<code>eureka</code>注解。配置文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: user-service</span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http://localhost:9411</span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      percentage: 1.0</span><br></pre></td></tr></table></figure><p><code>Zipkin Server</code>地址为<code>http://localhost:9411</code>。<br><code>spring.sleuth.sampler.percentage</code>为1.0,即100%的概率将链路的数据上传给<code>Zipkin Server</code>，在默认的情况下，该值为0.1.</p><p>测试的api为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello user!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>4.构建gateway-service</h3><p>新建一个名为<code>gateway-service</code>工程，这个工程作为服务网关，将请求转发到<code>user-service</code>，作为<code>Zipkin</code>客户端，需要将链路数据上传给<code>Zipkin Server</code>，同时它也作为<code>Eureka Client</code>。</p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka/</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: gateway-service</span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      percentage: 1.0</span><br><span class="line">  zipkin:</span><br><span class="line">    base-url: http://localhost:9411</span><br><span class="line"></span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    api-a:</span><br><span class="line">      path: /user-api/**</span><br><span class="line">      serviceId: user-service</span><br></pre></td></tr></table></figure><p>以<code>“/user-api/**”</code>开头的Uri请求，转发到服务名为 <code>user-service</code> 的服务</p><h2>三、演示效果</h2><p>完整的项目搭建完毕，依次启动<code>eureka-server</code>、<code>zipkin-server</code>、<code>user-service</code>、<code>gateway-service</code>。在浏览器上访问http://localhost:8081/user-api/user/hi</p><p>访问http://localhost:9411，即访问Zipkin的展示界面，界面显示如图所示：</p><p><img src="http://bloghello.oursnail.cn/sleuth%E6%95%88%E6%9E%9C1.png" alt="image"></p><p>这个界面主要用来查找服务的调用情况，可以根据服务名、开始时间、结束时间、请求消耗的时间等条件来查找。点击“Find Traces”按钮，界面如图所示。从图可知服务的调用情况，比如服务调用时间、服务的消耗时间，服务调用的链路情况。</p><p>点击<code>Dependences</code>按钮，可以查看服务的依赖关系，在本案例中，<code>gateway-service</code>将请求转发到了<code>user-service</code>，它们的依赖关系如图：</p><p><img src="http://bloghello.oursnail.cn/sleuth%E6%95%88%E6%9E%9C2.png" alt="image"></p><p>参考文章：<a href="https://blog.csdn.net/forezp/article/details/76795269" target="_blank" rel="noopener">Spring Cloud Sleuth进阶实战</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在以前，所有的东西放在一起打包，放到服务器上也就不管了，但是到了分布式场景下，可能一个请求要经过十几个服务的周转，如果不进行链路的追踪，这些对于我们来说都是透明的，那么哪个节点存在问题或者存在超时隐患我们都是很难知道的，因此服务追踪是我们必须要做的一样事情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>9.Stream消息驱动</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/9.Stream%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/9.Stream消息驱动/</id>
    <published>2019-02-21T08:26:42.981Z</published>
    <updated>2019-02-21T08:27:23.578Z</updated>
    
    <content type="html"><![CDATA[<p>对于MQ我们并不陌生，市面上也有形形色色的MQ，各有各的特点，原理上多多少少有一点区别，那么在进行MQ的更换的时候可能会出现代码的大片修改，这显然是很不好的，有没有一种方式来屏蔽掉这种MQ间的差异呢？这就引出了今天讨论的主角：Spring Cloud Stream.</p><a id="more"></a><h2>一、为什么需要SpringCloud Stream消息驱动呢？</h2><p>比方说我们用到了<code>RabbitMQ</code>和<code>Kafka</code>，由于这两个消息中间件的架构上的不同，像<code>RabbitMQ</code>有<code>exchange</code>，<code>kafka</code>有<code>Topic</code>，<code>partitions</code>分区，这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，</p><p>后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候<code>springcloud Stream</code>给我们提供了一种解耦合的方式。</p><p><img src="http://bloghello.oursnail.cn/SpringCloudStream%E6%9E%B6%E6%9E%84.png" alt="image"></p><p><code>Spring Cloud Stream</code>由一个中间件中立的核组成。应用通过<code>Spring Cloud Stream</code>插入的<code>input</code>(相当于消费者<code>consumer</code>，它是从队列中接收消息的)和<code>output</code>(相当于生产者<code>producer</code>，它是从队列中发送消息的。)通道与外界交流。</p><p>通道通过指定中间件的<code>Binder</code>实现与外部代理连接。业务开发者不再关注具体消息中间件，只需关注<code>Binder</code>对应用程序提供的抽象概念来使用消息中间件实现业务即可。</p><p>Binder:</p><p>通过定义绑定器作为中间层，实现了应用程序与消息中间件(<code>Middleware</code>)细节之间的隔离。通过向应用程序暴露统一的<code>Channel</code>通道，使得应用程序不需要再考虑各种不同的消息中间件的实现。当需要升级消息中间件，或者是更换其他消息中间件产品时，我们需要做的就是更换对应的<code>Binder</code>绑定器而不需要修改任何应用逻辑 。甚至可以任意的改变中间件的类型而不需要修改一行代码。目前只提供了<code>RabbitMQ</code>和<code>Kafka</code>的<code>Binder</code>实现。</p><p><code>Springcloud Stream</code>还有个好处就是像<code>Kafka</code>一样引入了一点分区的概念，像<code>RabbitMQ</code>不支持分区的队列，你用了<code>SpringCloud Stream</code>技术，它就会帮<code>RabbitMQ</code>引入了分区的特性，<code>SpringCloud Stream</code>就是天然支持分区的，我们用起来还是很方便的。</p><h2>二、简单的演示</h2><p>首先我们要新建三个项目，分别是<code>spring-cloud-stream</code>，<code>spring-cloud-stream1</code>，<code>spring-cloud-stream2</code>，其中<code>spring-cloud-stream</code>作为生产者进行发消息模块，<code>spring-cloud-stream-1</code>，<code>spring-cloud-stream-2</code>作为消息接收模块。</p><h3>第一步：</h3><p>对于这三个项目，都要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.swg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-producer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-cloud-stream-producer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Elmhurst.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3>第二步：</h3><p>对于<code>spring-cloud-stream</code>，是信息的生产方，配置文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: producer</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      kafka:</span><br><span class="line">        binder:</span><br><span class="line">          #Kafka的消息中间件服务器</span><br><span class="line">          brockers: localhost:9092</span><br><span class="line">          #Zookeeper的节点，如果集群，后面加,号分隔</span><br><span class="line">          zk-nodes: localhost:2181</span><br><span class="line">          #如果设置为false,就不会自动创建Topic 有可能你Topic还没创建就直接调用了。</span><br><span class="line">          auto-create-topics: true</span><br><span class="line">      bindings:</span><br><span class="line">        #这里用stream给我们提供的默认output，后面会讲到自定义output</span><br><span class="line">        output:</span><br><span class="line">          #消息发往的目的地</span><br><span class="line">          destination: stream-demo</span><br><span class="line">          #消息发送的格式，接收端不用指定格式，但是发送端要</span><br><span class="line">          content-type: text/plain</span><br></pre></td></tr></table></figure><p>这里指定了kafka和zk的地址，最终的是，指定了我们要用的<code>output</code>，就是消息的生产通道，这里用的是自定义。下面指定了消息的目的地。</p><p>发送的程序<code>SendService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(Source.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Source source;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        source.output().send(MessageBuilder.withPayload(msg).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是接口一个字符串，然后把消息通过<code>output</code>发送到指定的目的地。<code>@EnableBinding(Source.class)</code>这个注解给我们绑定消息通道的，Source是Stream给我们提供的，可以点进去看源码，可以看到output和input,这和配置文件中的output，input对应的。</p><p>最后就是浏览器传入值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SendService sendService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/send/&#123;msg&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@PathVariable(<span class="string">"msg"</span>)</span> String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送了。。。"</span>+msg);</span><br><span class="line">        sendService.sendMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>第三步：</h3><p>消息的发送端已经搞好了，下面配置消息的消费端。配置文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer_1</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      kafka:</span><br><span class="line">        binder:</span><br><span class="line">          brockers: localhost:9092</span><br><span class="line">          zk-nodes: localhost:2181</span><br><span class="line">          auto-create-topics: true</span><br><span class="line">      bindings:</span><br><span class="line">        #input是接收，注意这里不能再像前面一样写output了</span><br><span class="line">        input:</span><br><span class="line">          destination: stream-demo</span><br></pre></td></tr></table></figure><p>接收的service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息接受端，stream给我们提供了Sink,Sink源码里面是绑定input的，要跟我们配置文件的imput关联的。</span></span><br><span class="line"><span class="meta">@EnableBinding</span>(Sink.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecieveService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)<span class="comment">//其实就是@StreamListener(“input”)，监听这个通道有没有消息过来，有就消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recieve</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====="</span>+payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>第四步</h3><p>启动kafka和zk，上一章已经讲过了如何启动。打开浏览器输入对应的url进行测试，看两个消费端是否都可以打印出来传入的信息。</p><h3>总结</h3><p>其实上面的一个流程就可以概括为下面一张图：</p><p><img src="http://bloghello.oursnail.cn/stream%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>一个是产品的生产者，一个是商店消费者，生产者将产品通过通道，这里就是<code>Source</code>中默认的<code>output</code>，将产品发送到<code>binder</code>中，给他一个<code>topic</code>，告诉消费者这个消息的名字(位置，这里是<code>stream-demo</code>)。消费者通过监听<code>Sink</code>中的默认的<code>input</code>通道来看看有没有自己感兴趣的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    String OUTPUT = <span class="string">"output"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Output</span>(<span class="string">"output"</span>)</span><br><span class="line">    <span class="function">MessageChannel <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sink</span> </span>&#123;</span><br><span class="line">    String INPUT = <span class="string">"input"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Input</span>(<span class="string">"input"</span>)</span><br><span class="line">    <span class="function">SubscribableChannel <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，最基本的一个消息的生产消费流程就走完了。</p><h2>三、自定义消息通道</h2><p>到现在为止，我们进行了一个简单的消息发送和接收，用的是<code>Stream</code>给我们提供的默认<code>Source</code>，<code>Sink</code>，接下来我们要自己进行自定义，这种方式在工作中还是用的比较多的，因为我们要往不同的消息通道发消息，</p><p>必然不能全都叫input,output的，那样的话就乱套了，因此首先自定义一个接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by cong on 2018/5/28.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MySource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Output</span>(<span class="string">"myOutput"</span>)</span><br><span class="line">    <span class="function">MessageChannel <span class="title">myOutput</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是将默认的<code>Source</code>里的<code>output</code>改个名字而已，十分简单，在配置文件中指定通道的地方就要响应地修改为我们自己定义的通道就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7888</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: producer</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      kafka:</span><br><span class="line">        binder:</span><br><span class="line">#Kafka的消息中间件服务器</span><br><span class="line">          brockers: localhost:9092</span><br><span class="line">#Zookeeper的节点，如果集群，后面加,号分隔</span><br><span class="line">          zk-nodes: localhost:2181</span><br><span class="line">#如果设置为false,就不会自动创建Topic 有可能你Topic还没创建就直接调用了。</span><br><span class="line">          auto-create-topics: true</span><br><span class="line">      bindings:</span><br><span class="line">#自定义output</span><br><span class="line">        myOutput:</span><br><span class="line">#消息发往的目的地</span><br><span class="line">            destination: stream-demo</span><br><span class="line">#消息发送的格式，接收端不用指定格式，但是发送端要</span><br><span class="line">            content-type: text/plain</span><br></pre></td></tr></table></figure><p>下面发送消息的时候，就是注入我们自己定义的<code>source</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(MySource.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MySource source;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        source.myOutput().send(MessageBuilder.withPayload(msg).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者同样如此，就是改一下<code>Sink</code>的名字即可。</p><h2>四、消息中转站</h2><p>这是一个比较有意思的功能，就是消息经过中间一个加工一下，再传给下一个消费者。就是一个链式的调用。</p><p>那么，我们这里改造一下<code>spring-cloud-stream-consumer-1</code>为<code>spring-cloud-stream-trans</code>:</p><p>第一步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7889</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer_1</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      kafka:</span><br><span class="line">        binder:</span><br><span class="line">          brockers: localhost:9092</span><br><span class="line">          zk-nodes: localhost:2181</span><br><span class="line">          auto-create-topics: true</span><br><span class="line">      bindings:</span><br><span class="line">#input是接收，注意这里不能再像前面一样写output了</span><br><span class="line">          input:</span><br><span class="line">            destination: stream-demo</span><br><span class="line"> #进行消息中转处理后，在进行转发出去           </span><br><span class="line">          output:</span><br><span class="line">            destination: stream-demo-trans</span><br></pre></td></tr></table></figure><p>第二步：接着在新建一个消息中转类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hjc.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Processor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.annotation.ServiceActivator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableBinding</span>(Processor.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransFormService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ServiceActivator</span>(inputChannel = Processor.INPUT,outputChannel = Processor.OUTPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object payload)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消息中转站："</span>+payload);</span><br><span class="line">        <span class="keyword">return</span> payload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得要将拷贝过来的工程中的<code>SendService</code>里面的注解全部删除掉，要不然程序启动会报错。</p><p>接着要修改消息中转站发送消息出去的接收端springcloud-stream2的配置,<code>input</code>的值改为<code>stream-demo-trans</code>即可。</p><h2>五、消息分组</h2><p>我们都是一端发消息，两个消息接受者都接收到了，但是有时候有些业务场景我只想让其中一个消息接收者接收到消息，那么该怎么办呢？</p><p><code>Group</code>，如果使用过 <code>Kafka</code> 的读者并不会陌生。<code>Spring Cloud Stream</code> 的这个分组概念的意思基本和 <code>Kafka</code> 一致。微服务中动态的缩放同一个应用的数量以此来达到更高的处理能力是非常必须的。对于这种情况，同一个事件防止被重复消费，</p><p>只要把这些应用放置于同一个 <code>group</code> 中，就能够保证消息只会被其中一个应用消费一次。不同的组是可以消费的，同一个组内会发生竞争关系，只有其中一个可以消费。</p><p>修改消费段的配置文件，将他们都配置到同一个组下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 7889</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer_1</span><br><span class="line">  cloud:</span><br><span class="line">    stream:</span><br><span class="line">      kafka:</span><br><span class="line">        binder:</span><br><span class="line">          brockers: localhost:9092</span><br><span class="line">          zk-nodes: localhost:2181</span><br><span class="line">          auto-create-topics: true</span><br><span class="line">      bindings:</span><br><span class="line">          #input是接收，注意这里不能再像前面一样写output了</span><br><span class="line">          input:</span><br><span class="line">            destination: stream-demo</span><br><span class="line">            #分组的组名</span><br><span class="line">            group: group</span><br></pre></td></tr></table></figure><p>可以看到<code>springcloud-stream1</code>和<code>springcloud-stream2</code>是属于同一组的。<code>springcloud-stream</code>模块的发的消息只能被<code>springcloud-stream1</code>或<code>springcloud-stream2</code>其中一个接收到，这样避免了重复消费。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于MQ我们并不陌生，市面上也有形形色色的MQ，各有各的特点，原理上多多少少有一点区别，那么在进行MQ的更换的时候可能会出现代码的大片修改，这显然是很不好的，有没有一种方式来屏蔽掉这种MQ间的差异呢？这就引出了今天讨论的主角：Spring Cloud Stream.&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>8.Bus消息总线</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/8.Bus%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/8.Bus消息总线/</id>
    <published>2019-02-21T08:10:31.419Z</published>
    <updated>2019-02-21T08:33:10.534Z</updated>
    
    <content type="html"><![CDATA[<p>为了实现依次redresh自动刷新所有服务的配置文件，所以需要引入消息总线进行消息的通知，本文主要采用kafka作为消息队列来实现，当然了，rabbitMQ也是比较简单的。</p><a id="more"></a><h2>一、前言</h2><p>注：本篇文章是基于<code>spring boot 2.x</code>，主要参考 <a href="https://www.cnblogs.com/huangjuncong/p/9077099.html" target="_blank" rel="noopener">SpringCloud实战8-Bus消息总线</a> 这篇文章而写。但是他的版本比较低，有一两个坑需要注意。</p><p>上一篇我们讲到，我们如果要去更新所有微服务的配置，在不重启的情况下去更新配置，只能依靠<code>spring cloud config</code>了，但是，是我们要一个服务一个服务的发送post请求，我们能受的了吗？</p><p>虽然这比之前的没配置中心好多了，那但是我们如何继续避免挨个挨个的向服务发送Post请求来告知服务你的配置信息改变了，需要及时修改内存中的配置信息呢？</p><p>这时候我们就不要忘记消息队列的发布订阅模型。让所有为服务来订阅这个事件，当这个事件发生改变了，就可以通知所有微服务去更新它们的内存中的配置信息。这时Bus消息总线就能解决，你只需要在<code>springcloud Config Server</code>端发出<code>refresh</code>，就可以触发所有微服务更新了。</p><p>如下架构图所示：</p><p><img src="http://bloghello.oursnail.cn/Spring-cloud-1-1.jpg" alt="image"></p><p>根据此图我们可以看出利用Spring Cloud Bus做配置更新的步骤:</p><ul><li>1、提交代码触发post给客户端A发送bus/refresh</li><li>2、客户端A接收到请求从Server端更新配置并且发送给Spring Cloud Bus</li><li>3、Spring Cloud bus接到消息并通知给其它客户端</li><li>4、其它客户端接收到通知，请求Server端获取最新配置</li><li>5、全部客户端均获取到最新的配置</li></ul><p><code>Spring Cloud Bus</code>除了支持<code>RabbitMQ</code>的自动化配置之外，还支持现在被广泛应用的<code>Kafka</code>。在本文中，我们将搭建一个Kafka的本地环境，并通过它来尝试使用<code>Spring Cloud Bus</code>对<code>Kafka</code>的支持，实现消息总线的功能。</p><h2>二、Kafka</h2><p><code>Kafka</code>使用<code>Scala</code>实现，被用作LinkedIn的活动流和运营数据处理的管道，现在也被诸多互联网企业广泛地用作为数据流管道和消息系统。</p><p>Kafak架构图如下:</p><p><img src="http://bloghello.oursnail.cn/kafka%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="image"></p><p><code>Kafka</code>是基于消息发布/订阅模式实现的消息系统，其主要设计目标如下：</p><ol><li><strong>消息持久化</strong>：以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。</li><li><strong>高吞吐</strong>：在廉价的商用机器上也能支持单机每秒100K条以上的吞吐量</li><li><strong>分布式</strong>：支持消息分区以及分布式消费，并保证分区内的消息顺序</li><li><strong>跨平台</strong>：支持不同技术平台的客户端（如：Java、PHP、Python等）</li><li><strong>实时性</strong>：支持实时数据处理和离线数据处理</li><li><strong>伸缩性</strong>：支持水平扩展</li></ol><p><code>Kafka</code>中涉及的一些基本概念：</p><ol><li><strong>Broker</strong>：Kafka集群包含一个或多个服务器，这些服务器被称为Broker。</li><li><strong>Topic</strong>：逻辑上同Rabbit的Queue队列相似，每条发布到Kafka集群的消息都必须有一个Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个Broker上，但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li><strong>Partition</strong>：Partition是物理概念上的分区，为了提供系统吞吐率，在物理上每个Topic会分成一个或多个Partition，每个Partition对应一个文件夹（存储对应分区的消息内容和索引文件）。</li><li><strong>Producer</strong>：消息生产者，负责生产消息并发送到Kafka Broker。</li><li><strong>Consumer</strong>：消息消费者，向Kafka Broker读取消息并处理的客户端。</li><li><strong>Consumer Group</strong>：每个Consumer属于一个特定的组（可为每个Consumer指定属于一个组，若不指定则属于默认组），组可以用来实现一条消息被组内多个成员消费等功能。</li></ol><p>可以从<code>kafka</code>的架构图看到<code>Kafka</code>是需要<code>Zookeeper</code>支持的，你需要在你的<code>Kafka</code>配置里面指定<code>Zookeeper</code>在哪里，它是通过<code>Zookeeper</code>做一些可靠性的保证，做<code>broker</code>的主从，我们还要知道<code>Kafka</code>的消息是以<code>topic</code>形式作为组织的，<code>Producers</code>发送<code>topic</code>形式的消息，<br><code>Consumer</code>是按照组来分的，所以，一组<code>Consumers</code>都会接收同样的<code>topic</code>形式的消息。在服务端，它还做了一些分片，那么一个<code>Topic</code>可能分布在不同的分片上面，方便我们拓展部署多个机器，<code>Kafka</code>是天生分布式的。</p><p>首先是要下载对应的kafka：<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.1.0/kafka_2.11-2.1.0.tgz" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=/kafka/2.1.0/kafka_2.11-2.1.0.tgz</a></p><p>解压之后进去/bin/windows/目录下：</p><p>首先启动<code>zookeeper</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\zookeeper-server-start.bat D:\kafka_2.11-2.1.0\config\zookeeper.properties</span><br></pre></td></tr></table></figure><p>如果出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令语法不正确。</span><br><span class="line">错误: 找不到或无法加载主类 Files\Java\jdk1.8.0_121\lib\dt.jar;C:\Program</span><br><span class="line">PS D:\kafka_2.11-2.1.0\bin\windows&gt; .\zookeeper-server-start.bat D:\kafka_2.11-2.1.0\config/zookeeper.properties</span><br></pre></td></tr></table></figure><p>方法是：</p><blockquote><p>首先我们进到下载好的Kafka目录中kafka_2.11-1.1.0\bin\windows 下编辑kafka-run-class.bat如下：</p><p>找到这条配置 如下：</p><p>set COMMAND=%JAVA% %KAFKA_HEAP_OPTS% %KAFKA_JVM_PERFORMANCE_OPTS% %KAFKA_JMX_OPTS% %KAFKA_LOG4J_OPTS% -cp %CLASSPATH% %KAFKA_OPTS% %*</p><p>可以看到%CLASSPATH%没有双引号，</p><p>因此用双引号括起来，不然启动不起来的，报你JDK没安装好，修改后如下：</p><p>set COMMAND=%JAVA% %KAFKA_HEAP_OPTS% %KAFKA_JVM_PERFORMANCE_OPTS% %KAFKA_JMX_OPTS% %KAFKA_LOG4J_OPTS% -cp “%CLASSPATH%” %KAFKA_OPTS% %*</p></blockquote><p>后面启动<code>kafka</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\kafka-server-start.bat D:\kafka_2.11-2.1.0\config\server.properties</span><br></pre></td></tr></table></figure><p>这两者配置文件直接默认即可。启动成功之后，就放那吧！</p><h2>消息总线</h2><p>在上一章的<code>spring-cloud-config-server</code>以及<code>client</code>继续集成。<code>spring boot</code>版本是<code>2.0.3.RELEASE</code>.</p><p>第一步：<code>spring cloud config</code>服务端和客户端(搞两个客户端)都要引入<code>kafka</code>依赖，以<code>config server</code>端为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Eureka client--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--config server--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--kafka MQ--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：配置文件(服务端)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8085</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https://github.com/sunweiguo/spring-cloud-config-center.git</span><br><span class="line">          username: sunweiguo</span><br><span class="line">          password: xxxxxxxxx</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: bus-refresh</span><br></pre></td></tr></table></figure><p>注意，在1.x版本中一般配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#是否需要权限拉取，默认是true,如果不false就不允许你去拉取配置中心Server更新的内容</span><br><span class="line">management:</span><br><span class="line">  security:</span><br><span class="line">    enabled: false</span><br></pre></td></tr></table></figure><p>而在2.x版本中已经把这个改掉了。所以要注意。不配置的话会报错405.可以尝试去掉，用postman测试一把。</p><p>第三步：添加注解</p><p>在服务端和客户端的启动函数上都增加一条注解<code>@RefreshScope</code></p><p>ok,至此，集成完毕。消息总线的功能就有了。</p><p>启动全部工程。修改git上的内容。然后发现客户端都没更新。下面启动postman来对<code>config server</code>发送一条post请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:8085/actuator/bus-refresh</span><br></pre></td></tr></table></figure><p>再刷新浏览器，就会发现所有的客户端都自动更新了。我们也可以指定要刷新的客户端具体实例或者通配符符合的客户端。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了实现依次redresh自动刷新所有服务的配置文件，所以需要引入消息总线进行消息的通知，本文主要采用kafka作为消息队列来实现，当然了，rabbitMQ也是比较简单的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>7.Config分布式配置管理</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/7.Config%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/7.Config分布式配置管理/</id>
    <published>2019-02-21T07:34:17.162Z</published>
    <updated>2019-02-21T07:34:58.033Z</updated>
    
    <content type="html"><![CDATA[<p>关于集中的配置管理已经在 <a href="http://fourcolor.oursnail.cn/2019/02/21/weather-for-spring-cloud/10.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E9%9B%86%E4%B8%AD%E5%8C%96%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">10.天气预报系统-集中化配置</a> 中详细介绍了。本文为了方便引出问题，所以重新介绍一下它的基本使用。</p><a id="more"></a><h2>服务端</h2><p>第一步：新建一个工程，引入相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Eureka client--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--config--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudConfigServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8085</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https://github.com/sunweiguo/spring-cloud-config-center.git</span><br><span class="line">          username: sunweiguo</span><br><span class="line">          password: *********</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br></pre></td></tr></table></figure><p>第四步：在这个仓库里新建两个文件<code>cloud-config-dev.properties</code>和<code>cloud-config-test.properties</code>，里面有一些简单内容：<code>name=sunweiguo-dev</code>和<code>name=sunweiguo-test</code></p><p>第四步：启动配置的服务端</p><p>浏览器输入：<code>http://localhost:8085/cloud-config-dev.properties</code>，如果可以看到里面配置的内容，那么就配置成功了。</p><h2>客户端</h2><p>第一步：新建一个sb项目，引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Eureka client--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--健康监控包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：添加注解使其注册到eureka上，不再赘述</p><p>第三步：配置文件</p><p>注意，这里必须是<code>bootstrap.yml</code>，他的优先级别比<code>application.yml</code>要高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8086</span><br><span class="line"># 这个cloud-config要与git上的文件名一致，文件的命名规则在开头的链接中已经详细介绍了</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloud-config</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      profile: dev </span><br><span class="line">      discovery:</span><br><span class="line">        service-id: config-server # 致命服务端</span><br><span class="line">        enabled: true</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;  # 这是一个2.x的坑，需要配置这个暴露所有端点，否则refresh报404</span><br></pre></td></tr></table></figure><p>第四步：写一个简单的controller来显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello."</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步：在浏览器中输入对应的url看是否显示正确，下面就是在git上修改一下对应的文件内容。我们会发现，服务端上面已经更新了，但是客户端没有更新。那么就需要我们手动去触发他更新</p><p>第六步：打开<code>postman</code>工具。输入Url：<code>localhost:8086/actuator/refresh</code></p><p>如果返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &quot;config.client.version&quot;,</span><br><span class="line">    &quot;name&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么表示更新成功。此时再刷新之前的页面，会发现客户端的内容已经同步过来了。</p><h2>总结</h2><p>我们实现了将配置文件放在git上集中管理，但是在修改中心仓库中的配置后，客户端是没有更新的，后来我们用更新包手动去更新，虽然不用重启服务，但是还是比较麻烦。那么，如何避免，对每个服务发送post请求去更新呢？</p><p>其实很简单，就是利用发布订阅的原理，利用消息来通知从而触发更新，是比较好的方式。下一节介绍消息总线。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于集中的配置管理已经在 &lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/21/weather-for-spring-cloud/10.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E9%9B%86%E4%B8%AD%E5%8C%96%E9%85%8D%E7%BD%AE/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;10.天气预报系统-集中化配置&lt;/a&gt; 中详细介绍了。本文为了方便引出问题，所以重新介绍一下它的基本使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>6.Zuul网关服务</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/6.Zuul%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/6.Zuul网关服务/</id>
    <published>2019-02-21T07:17:20.055Z</published>
    <updated>2019-02-21T07:20:36.016Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="http://fourcolor.oursnail.cn/2019/02/21/weather-for-spring-cloud/9.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-API%E7%BD%91%E5%85%B3/" target="_blank" rel="noopener">9.天气预报系统-API网关</a> 中已经对API网关进行了详细的介绍。基础的概念就不再赘述了。下面着重看一下zuul中如何实现过滤器。</p><a id="more"></a><h2>基本使用</h2><p>第一步:创建一个springboot工程，引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Eureka client--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--zuul--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步：在启动函数上增加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEurekaZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudEurekaZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    service-hi:</span><br><span class="line">      path: /service-hi/**/</span><br><span class="line">      serviceId: service-hi</span><br><span class="line">server:</span><br><span class="line">  port: 8084</span><br></pre></td></tr></table></figure><p>主要就是配置路由规则，以<code>service-hi</code>为前缀的都去<code>serivce-hi</code>为名字的服务下找对应的映射。</p><p>这样，就完成了基本的整合。启动其他的项目：<code>spring-cloud-eureka-server-1</code>,<code>spring-cloud-eureka-server-2</code>,<code>spring-cloud-eureka-client-1</code>,<code>spring-cloud-eureka-client-1</code>.</p><p>在我的<code>spring-cloud-eureka-client-1</code>有一个路径叫<code>localhost:8080/test</code>返回一个字符串。那么此时用网关来访问的话应该是：<code>localhost:8084/service-hi/test</code>.</p><h2>过滤器</h2><p>新建一个类，假设我们要检验token，如果token为空，就返回未授权。</p><p>TokenFilter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pre 在路由表寻找路由时生效</span></span><br><span class="line">    <span class="comment">//routing 找到路由开始进行请求转发时生效</span></span><br><span class="line">    <span class="comment">//error 出错时生效</span></span><br><span class="line">    <span class="comment">//post routing或者error之后最后阶段生效</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//越小，优先级越高</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//true表示过滤器生效</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = context.getRequest();</span><br><span class="line">        String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(token == <span class="keyword">null</span>)&#123;</span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            context.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            context.setResponseBody(<span class="string">"unsutherized"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要将其注册到spring：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TokenFilter <span class="title">tokenFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TokenFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次访问<code>localhost:8084/service-hi/test</code>时，显示<code>unsutherized</code>，当访问<code>localhost:8084/service-hi/test?token=123</code>时访问通过。</p><p>如果在<code>run()</code>中出现异常，但是这个异常不能抛出来显示在页面上。那么如何在页面上如何显示呢？在<code>catch</code>的代码中这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.set(error.status_code,<span class="number">401</span>);</span><br><span class="line">context.set(<span class="string">"error.exception"</span>,e);</span><br><span class="line">context.set(<span class="string">"error.message"</span>,<span class="string">"提示信息"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/21/weather-for-spring-cloud/9.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-API%E7%BD%91%E5%85%B3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;9.天气预报系统-API网关&lt;/a&gt; 中已经对API网关进行了详细的介绍。基础的概念就不再赘述了。下面着重看一下zuul中如何实现过滤器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>4.Hystrix请求合并</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/4.Hystrix%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/4.Hystrix请求合并/</id>
    <published>2019-02-21T07:07:39.993Z</published>
    <updated>2019-02-21T07:30:09.947Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务架构中，我们将一个项目拆分成很多个独立的模块，这些独立的模块通过远程调用来互相配合工作，但是，在高并发情况下，通信次数的增加会导致总的通信时间增加，同时，线程池的资源也是有限的，高并发环境会导致有大量的线程处于等待状态，进而导致响应延迟，为了解决这些问题，我们需要来了解Hystrix的请求合并。</p><a id="more"></a><h2>一、请求合并</h2><p>hystrix中的请求合并，就是利用一个合并处理器，将对同一个服务发起的连续请求合并成一个请求进行处理(这些连续请求的时间窗默认为10ms)，在这个过程中涉及到的一个核心类就是<code>HystrixCollapser</code>。</p><p>请求不合并之前：</p><p>下图展示了在未使用<code>HystrixCollapser</code>请求合并器之前的线程使用情况。可以看到当服务消费者同时对<code>USER-SERVICE</code>的<code>/users/{id}</code>接口发起了五个请求时，会向该依赖服务的独立线程池中申请五个线程来完成各自的请求操作。</p><p><img src="http://bloghello.oursnail.cn/hystrix%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B61.png" alt="image"></p><p>而在使用了<code>HystrixCollapser</code>请求合并器之后，相同情况下的线程占用如下图所示。由于同一时间发生的五个请求处于请求合并器的一个时间窗内，这些发向<code>/users/{id}</code>接口的请求被请求合并器拦截下来，并在合并器中进行组合，然后将这些请求合并成一个请求发向USER-SERVICE的批量接口<code>/users?ids={ids}</code>，在获取到批量请求结果之后，通过请求合并器再将批量结果拆分并分配给每个被合并的请求。从图中我们可以看到以来，通过使用请求合并器有效地减少了对线程池中资源的占用。所以在资源有效并且在短时间内会产生高并发请求的时候，为避免连接不够用而引起的延迟可以考虑使用请求合并器的方式来处理和优化。</p><p><img src="http://bloghello.oursnail.cn/hystrix%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B62.png" alt="image"></p><p>本着简单的目的，所以非注解的方式我就没做。具体参考文章：<a href="https://blog.csdn.net/u012702547/article/details/78213270" target="_blank" rel="noopener">Spring Cloud中Hystrix的请求合并</a></p><h3>1.1 服务提供者</h3><p>首先是需要服务提供者提供两个接口，一个是返回集合，模拟在同一时间多个线程同时来请求书籍信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getbooks"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">books</span><span class="params">(String ids)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ids&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span> + ids);</span><br><span class="line">    ArrayList&lt;Book&gt; books = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    books.add(<span class="keyword">new</span> Book(<span class="string">"《李自成》"</span>, <span class="number">55</span>, <span class="string">"姚雪垠"</span>, <span class="string">"人民文学出版社"</span>));</span><br><span class="line">    books.add(<span class="keyword">new</span> Book(<span class="string">"中国文学简史"</span>, <span class="number">33</span>, <span class="string">"林庚"</span>, <span class="string">"清华大学出版社"</span>));</span><br><span class="line">    books.add(<span class="keyword">new</span> Book(<span class="string">"文学改良刍议"</span>, <span class="number">33</span>, <span class="string">"胡适"</span>, <span class="string">"无"</span>));</span><br><span class="line">    books.add(<span class="keyword">new</span> Book(<span class="string">"ids"</span>, <span class="number">22</span>, <span class="string">"helloworld"</span>, <span class="string">"haha"</span>));</span><br><span class="line">    <span class="keyword">return</span> books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>1.2 服务消费者</h3><p>首先在BookService中添加两个方法用来调用服务提供者提供的接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"test11"</span>,collapserProperties = &#123;<span class="meta">@HystrixProperty</span>(name =<span class="string">"timerDelayInMilliseconds"</span>,value = <span class="string">"100"</span>)&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Book&gt; <span class="title">test10</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">test11</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test9---------"</span>+ids+<span class="string">"Thread.currentThread().getName():"</span> + Thread.currentThread().getName());</span><br><span class="line">    Book[] books = restTemplate.getForObject(<span class="string">"http://SERVICE-HI/getbooks?ids=&#123;1&#125;"</span>, Book[].class, StringUtils.join(ids, <span class="string">","</span>));</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(books);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>test10</code>方法上添加<code>@HystrixCollapser</code>注解实现请求合并，用<code>batchMethod</code>属性指明请求合并后的处理方法，<code>collapserProperties</code>属性指定其他属性:<strong>为请求合并器设置了时间延迟属性，合并器会在该时间窗内收集获取单个Book的请求并在时间窗结束时进行合并组装成单个批量请求</strong>。</p><h3>1.3 调用消费服务</h3><p>下面就是直接调用<code>test10</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/books"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">    Future&lt;Book&gt; f1 = bookService.test10(<span class="number">1l</span>);</span><br><span class="line">    Future&lt;Book&gt; f2 = bookService.test10(<span class="number">2l</span>);</span><br><span class="line">    Future&lt;Book&gt; f3 = bookService.test10(<span class="number">3l</span>);</span><br><span class="line">    Book b1 = f1.get();</span><br><span class="line">    Book b2 = f2.get();</span><br><span class="line">    Book b3 = f3.get();</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    Future&lt;Book&gt; f4 = bookService.test10(<span class="number">4l</span>);</span><br><span class="line">    Book b4 = f4.get();</span><br><span class="line">    System.out.println(<span class="string">"b1&gt;&gt;&gt;"</span>+b1);</span><br><span class="line">    System.out.println(<span class="string">"b2&gt;&gt;&gt;"</span>+b2);</span><br><span class="line">    System.out.println(<span class="string">"b3&gt;&gt;&gt;"</span>+b3);</span><br><span class="line">    System.out.println(<span class="string">"b4&gt;&gt;&gt;"</span>+b4);</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>1.4 运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test9---------[3, 1, 2]Thread.currentThread().getName():hystrix-BookService-6</span><br><span class="line">test9---------[4]Thread.currentThread().getName():hystrix-BookService-7</span><br><span class="line">b1&gt;&gt;&gt;com.swg.springcloudeureka.Book@5a901d44</span><br><span class="line">b2&gt;&gt;&gt;com.swg.springcloudeureka.Book@3305e39</span><br><span class="line">b3&gt;&gt;&gt;com.swg.springcloudeureka.Book@2282567c</span><br><span class="line">b4&gt;&gt;&gt;com.swg.springcloudeureka.Book@52e7b4ea</span><br></pre></td></tr></table></figure><p>前三个请求会进行合并，即1，2，3三个id被合并到一个list中传给<code>test11</code>，第四个请求会单独执行.</p><h2>二、总结</h2><p>请求合并的优点小伙伴们已经看到了，多个请求被合并为一个请求进行一次性处理，可以有效节省网络带宽和线程池资源，但是，有优点必然也有缺点，设置请求合并之后，本来一个请求可能5ms就搞定了，但是现在必须再等10ms看看还有没有其他的请求一起的，这样一个请求的耗时就从5ms增加到15ms了，不过，如果我们要发起的命令本身就是一个高延迟的命令，那么这个时候就可以使用请求合并了，因为这个时候时间窗的时间消耗就显得微不足道了，另外高并发也是请求合并的一个非常重要的场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务架构中，我们将一个项目拆分成很多个独立的模块，这些独立的模块通过远程调用来互相配合工作，但是，在高并发情况下，通信次数的增加会导致总的通信时间增加，同时，线程池的资源也是有限的，高并发环境会导致有大量的线程处于等待状态，进而导致响应延迟，为了解决这些问题，我们需要来了解Hystrix的请求合并。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>3.Hystrix请求熔断服务降级</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/3.Hystrix%E8%AF%B7%E6%B1%82%E7%86%94%E6%96%AD%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/3.Hystrix请求熔断服务降级/</id>
    <published>2019-02-21T06:58:40.400Z</published>
    <updated>2019-02-21T07:01:12.362Z</updated>
    
    <content type="html"><![CDATA[<p>基本的介绍和基本的演示都已经在<a href="http://fourcolor.oursnail.cn/2019/02/21/weather-for-spring-cloud/11.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">11.天气预报系统-熔断机制</a>中说明和演示了。下面来说点不一样的东西吧！</p><a id="more"></a><h2>一、前言</h2><p>比如拿我上一章中的代码，我们将<code>spring-eureka-ribbon</code>升级为<code>spring-cloud-ribbon-hystrix</code>:</p><p>无非是引入依赖，主函数添加一个允许熔断的声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloServie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hiService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://SERVICE-HI/hello?name="</span>+name,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloFallBack</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;font color='red'&gt;error&lt;/font&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们的fallBack方法的参数必须与被注解的方法的参数一致，否则会报错。</p><p>启动项目：<code>spring-cloud-eureka-server-1</code>,<code>spring-cloud-eureka-server-2</code>,<code>spring-cloud-eureka-client-1</code>,<code>spring-cloud-eureka-client-2</code>,<code>spring-cloud-ribbon-hystrix</code>.</p><p>然后关闭一个client，看是否触发服务降级，显示红色的error.</p><h2>二、用法进阶-实现异步消费</h2><p>我们不用<code>@HystrixCommand</code>注解来实现上面个功能。代码见<code>spring-cloud-eureka-ribbon-hystrix-02</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloServiceCommand command = <span class="keyword">new</span> HelloServiceCommand(<span class="string">"hello"</span>,restTemplate);</span><br><span class="line">        String res = command.execute();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中核心的<code>HelloServiceCommand</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServiceCommand</span><span class="params">(String commandGroupKey,RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(commandGroupKey));</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://SERVICE-HI/hello?name='swg'"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;font color='red'&gt;error&lt;/font&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以用代码实现上面的注解的功能。</p><p>我们可以发现，<code>run()</code>方法里调用其他的服务（多个），如果是串行执行，那么时间是所有服务执行时间之和。那么，有没有办法使他并行执行呢？达到一种NIO的效果。</p><p>NIO的两个实现方式：<code>Future</code>将来式和<code>Callable</code>回调式，这里使用将来式。</p><p>其实核心就是<code>Future&lt;String&gt; future = command.queue();</code>，让这个方法自己另开一个线程去默默执行，本线程还继续往下，等我想到结果的时候，再去调用<code>String res = future.get();</code>阻塞地获取结果，如果结果已经准备好了，那么就直接拿到。</p><p>在代码<code>spring-cloud-eureka-ribbon-hystrix-03</code>中的<code>controller</code>中进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    HelloServiceCommand command = <span class="keyword">new</span> HelloServiceCommand(<span class="string">"hello"</span>,restTemplate);</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    Future&lt;String&gt; future = command.queue();</span><br><span class="line">    System.out.println(<span class="string">"start"</span>);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - now);</span><br><span class="line">    String res = future.get();</span><br><span class="line">    <span class="keyword">long</span> last = System.currentTimeMillis()-end;</span><br><span class="line">    System.out.println(last);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的目的就是看调用<code>command.queue()</code>之后会不会阻塞本线程的执行，我们让被<code>restTemplate</code>调用的方法睡眠一会：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span>String name) <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法开始执行。。。"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">800</span>);</span><br><span class="line">    System.out.println(<span class="string">"方法执行结束。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hi "</span>+ name +<span class="string">",you are from "</span> + port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">1</span><br><span class="line">817</span><br></pre></td></tr></table></figure><p>就是说将执行其他服务这个操作异步到了另外一个线程中执行，本线程立即执行下面的逻辑。这样，提高了效率。</p><p>好了，用非注解的方式来实现了一下NIO的实现方式，那么肯定还是使用注解比较方便，那么基于注解的话，我们如何实现<code>future</code>的方式来执行呢？代码<code>spring-cloud-eureka-ribbon-hystrix-04</code></p><p>我们只需要将原来的<code>HelloServiceImpl</code>中的<code>hiService</code>方法改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.command.AsyncResult;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallBack"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hiService</span><span class="params">(String name)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Future&lt;String&gt; future = <span class="keyword">new</span> AsyncResult&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://SERVICE-HI/hello?name="</span>+name,String.class).getBody();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> future.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以实现这种异步的方式调用了。</p><h2>三、观察者模式来实现</h2><p><img src="http://bloghello.oursnail.cn/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%9D%A5%E7%BB%93%E5%90%88hystrix.png" alt="image"></p><p>订阅者来监听自己感兴趣的事件，可以实现多个请求集中处理。</p><p>代码不想去搞了…</p><h2>四、总结</h2><p>这里主要是实现熔断的功能，一开始的<code>@HystrixCommand</code>+<code>fallback</code>，到后面自己用<code>HystrixCommand</code>代码实现的，再到后来用<code>Future</code>来实现异步消费，到最后介绍的用观察者模式来实现的方式<code>HystrixObserverCommand</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本的介绍和基本的演示都已经在&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/21/weather-for-spring-cloud/11.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;11.天气预报系统-熔断机制&lt;/a&gt;中说明和演示了。下面来说点不一样的东西吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>2.Ribbon客户端负载均衡</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/2.Ribbon%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/2.Ribbon客户端负载均衡/</id>
    <published>2019-02-21T05:58:39.663Z</published>
    <updated>2019-02-21T06:12:37.370Z</updated>
    
    <content type="html"><![CDATA[<p>在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。</p><a id="more"></a><h2><font color="#337ab7">一、前言</font></h2><p>Spring Cloud Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具，它基于 Netflix Ribbon 实现。 通过 Spring Cloud 的封装， 可以让我们轻松地将面向服务的 REST 模板请求自动转换成客户端负载均衡的服务调用。Spring Cloud Ribbon 虽然只是一个工具类框架，它不像服务注册中心、 配置中心、 API 网关那样需要独立部署， 但是它几乎存在于每一个Spring Cloud 构建的微服务和基础设施中。 因为微服务间的调用，API 网关的请求转发等内容实际上都是通过Ribbon 来实现的，包括后续我们将要介绍的 Feign, 它也是基于 Ribbon实现的工具。</p><h2><font color="#337ab7">二、Ribbon</font></h2><p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。</p><p>而之前用的nginx来实现负载均衡，他是一种服务端的负载均衡。</p><p>集成Ribbon也是比较简单的。新建一个项目<code>spring-cloud-eureka-ribbon</code></p><h3><font color="#337ab7">2.1 引入依赖：</font></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><font color="#337ab7">2.2 然后就是注册一个专门负载均衡的一个客户端：</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringCloudEurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在工程的启动类中,通过<code>@EnableDiscoveryClient</code>向服务中心注册；并且向程序的ioc注入一个<code>bean</code>: <code>restTemplate</code>;并通过<code>@LoadBalanced</code>注解表明这个<code>restRemplate</code>开启负载均衡的功能。</p><h3><font color="#337ab7">2.3 配置文件</font></h3><p>就是向注册中心集群注册而已。所以，上章中提到的Eureka两个服务端要启动起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-ribbon</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br></pre></td></tr></table></figure><h3><font color="#337ab7">2.4 测试的controller</font></h3><p>这个ribbon来接收请求，然后由他来决定转发到哪个服务。</p><p>所以这里要启动起来两个服务，让我来实际调用，我们就给他一个最简单的功能：打印出来端口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hi "</span>+ name +<span class="string">",you are from "</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我的ribbon中写一个controller作为一个统一的入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHelloServie helloServie;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span>String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloServie.hiService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的service就是用刚才定义的<code>restTemplate</code>来根据服务实例的名称去发起调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloServie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hiService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://SERVICE-HI/hello?name="</span>+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><font color="#337ab7">2.5 页面测试</font></h3><p>浏览器输入<code>http://localhost:8082/hello?name=sunweiguo</code>，不停地刷新，我们会看到轮流显示：</p><p><code>hi sunweiguo,you are from 8080</code>和<code>hi sunweiguo,you are from 8081</code>这两句，说明负载均衡已经生效，并且算法是轮询。当然，我们也可以用其他的负载均衡算法。这里就不做演示了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>1.Eureka服务治理</title>
    <link href="http://yoursite.com/2019/02/21/spring-cloud-modules/1.Eureka%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/21/spring-cloud-modules/1.Eureka服务治理/</id>
    <published>2019-02-21T05:22:47.428Z</published>
    <updated>2019-02-21T05:27:16.278Z</updated>
    
    <content type="html"><![CDATA[<p>在上一系列中，我们以最简单的业务场景急速入门了微服务，当然了，忽略了很多的细节，作为入门是可以的，但是真正使用的时候，还是需要了解很多额外的使用知识，所以本系列就孕育而生，即在上一系列的基础上继续强化，加深对spring cloud的使用理解。本章首先还是介绍eureka服务注册和发现组件，因为它是微服务的基石。</p><a id="more"></a><p>关于<code>Eureka</code>的基本使用，在另外一篇文章中详细介绍了：<a href="http://fourcolor.oursnail.cn/2019/02/21/weather-for-spring-cloud/7.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0/" target="_blank" rel="noopener">7.天气预报系统-微服务的注册和发现</a>，不再赘述。本章学习如何搭建一个<code>eureka</code>高可用集群。</p><h2><font color="#337ab7">一、前言</font></h2><p>首先来看看<code>Eureka</code>高可用的架构。</p><p><img src="http://bloghello.oursnail.cn/eureka%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="image"></p><p>其中，续约是指：服务端维持一个有过期时间的服务列表，当客户端访问一次，我就刷新一下过期时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 90秒不来续约就剔除</span><br><span class="line">lease-expiration-duration-in-seconds: 90</span><br><span class="line"># 每隔30秒自动续约一次</span><br><span class="line">lease-renewal-interval-in-seconds: 30</span><br></pre></td></tr></table></figure><p>在客户端也可以设置一个定时任务，每隔多长时间去请求一下服务器，刷新一下服务列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认每隔30去请求一下服务器</span><br><span class="line">registry-fetch-interval-seconds: 30</span><br></pre></td></tr></table></figure><h2><font color="#337ab7">二、总结</font></h2><p><code>Eureka</code>包含两个组件：<code>Eureka Server</code> 和 <code>Eureka Client</code>，它们的作用如下：</p><ul><li><code>Eureka Client</code>是一个Java客户端，用于简化与<code>Eureka Server</code>的交互；</li><li><code>Eureka Server</code>提供服务发现的能力，各个微服务启动时，会通过<code>Eureka Client</code>向<code>Eureka Server</code>进行注册自己的信息（例如网络信息），<code>Eureka Server</code>会存储该服务的信息；</li><li>微服务启动后，会周期性地向<code>Eureka Server</code>发送心跳（默认周期为30秒）以续约自己的信息。如果<code>Eureka Server</code>在一定时间内没有接收到某个微服务节点的心跳，<code>Eureka Server</code>将会注销该微服务节点（默认90秒）；</li><li>每个<code>Eureka Server</code>同时也是<code>Eureka Client</code>，多个<code>Eureka Server</code>之间通过复制的方式完成服务注册表的同步；</li><li><code>Eureka Client</code>会缓存<code>Eureka Server</code>中的信息。即使所有的<code>Eureka Server</code>节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。</li></ul><h2><font color="#337ab7">三、集群配置</font></h2><p>Server1端配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8762/eureka</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br></pre></td></tr></table></figure><p>Server2端配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8762</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br></pre></td></tr></table></figure><p>就是说两个<code>server</code>互相注册。形成一个<code>server</code>集群。</p><p>client1配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-client</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br></pre></td></tr></table></figure><p>client2也是如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-client</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka,http://localhost:8762/eureka</span><br></pre></td></tr></table></figure><p>分别启动之后，我们会看到效果：</p><p><img src="http://bloghello.oursnail.cn/eureka%E9%9B%86%E7%BE%A4%E6%95%88%E6%9E%9C.png" alt="image"></p><p>关于本系列的所有代码，将按照1-10的章节依次存放在：<a href="https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-modules" target="_blank" rel="noopener">https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-modules</a> 后面不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一系列中，我们以最简单的业务场景急速入门了微服务，当然了，忽略了很多的细节，作为入门是可以的，但是真正使用的时候，还是需要了解很多额外的使用知识，所以本系列就孕育而生，即在上一系列的基础上继续强化，加深对spring cloud的使用理解。本章首先还是介绍eureka服务注册和发现组件，因为它是微服务的基石。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springcloud组件系统学习" scheme="http://yoursite.com/tags/springcloud%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>11.天气预报系统-熔断机制</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/11.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/11.天气预报系统-熔断机制/</id>
    <published>2019-02-21T03:28:01.816Z</published>
    <updated>2019-02-21T04:58:12.298Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第十一篇文章，某个服务一旦出现不可用，可能会牵连整个系统造成雪崩，或者有的时候资源需要聚集在核心业务上，非核心业务就可以适当地关闭，此时就是需要有一种机制来实现系统保护和服务降级的功能。本章介绍hystrix组件。</p><a id="more"></a><h2>一、定义</h2><p>保护系统的一种方式，当请求超出阈值，把真实的服务接口断开，可能只是返回给你一个默认值。这样，掐断了自己的服务，又可以给用户一个响应。</p><blockquote><p>对该服务的调用执行熔断，对于后续请求，不再继续调用该目标服务，而是直接返回，从而可以快速释放资源。</p></blockquote><p>熔断器好处：系统稳定、减少性能损耗、及时响应、阈值可配置</p><p>熔断这一概念来源于电子工程中的断路器（Circuit Breaker）。在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。</p><p>这种牺牲局部，保全整体的措施就叫做熔断。</p><p>如果不采取熔断措施，我们的系统会怎样呢？我们来看一个栗子。当前系统中有A，B，C三个服务，服务A是上游，服务B是中游，服务C是下游。它们的调用链如下：</p><p><img src="http://bloghello.oursnail.cn/%E7%86%94%E6%96%AD%E8%A7%A3%E9%87%8A1.png" alt="image"></p><p>一旦下游服务C因某些原因变得不可用，积压了大量请求，服务B的请求线程也随之阻塞。线程资源逐渐耗尽，使得服务B也变得不可用。紧接着，服务A也变为不可用，整个调用链路被拖垮。</p><p><img src="http://bloghello.oursnail.cn/%E7%86%94%E6%96%AD%E8%A7%A3%E9%87%8A2.png" alt="image"></p><p>像这种调用链路的连锁故障，叫做<b>雪崩</b>。</p><p>正所谓刮骨疗毒，壮士断腕。在这种时候，就需要我们的熔断机制来挽救整个系统。</p><p><img src="http://bloghello.oursnail.cn/%E7%86%94%E6%96%AD%E8%A7%A3%E9%87%8A3.png" alt="image"></p><ol><li><strong><font color="red">开启熔断</font></strong>:在固定时间窗口内，接口调用超时比率达到一个阈值，会开启熔断。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的默认方法，达到服务降级的效果。</li><li><strong><font color="red">熔断恢复</font></strong>:熔断不可能是永久的。当经过了规定时间之后，服务将从熔断状态回复过来，再次接受调用方的远程调用。</li></ol><h2>二、熔断和降级</h2><ol><li>在股票市场，熔断这个词大家都不陌生，是指当股指波幅达到某个点后，交易所为控制风险采取的暂停交易措施。相应的，服务熔断一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护。</li><li>大家都见过女生旅行吧，大号的旅行箱是必备物，平常走走近处绰绰有余，但一旦出个远门，再大的箱子都白搭了，怎么办呢？常见的情景就是把物品拿出来分分堆，比了又比，最后一些非必需品的就忍痛放下了，等到下次箱子够用了，再带上用一用。而服务降级，就是这么回事，整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。</li></ol><blockquote><p>降级白话理解：比如在公司 遇到贵宾要来 就把一些不重要的常规接待暂停 把这些资源供给招待贵宾 之前有个淘宝的分享 比如双11 把订单评论和收藏等功能在这一天暂停 把这些资源分给其它关键服务 比如下单</p></blockquote><p>所以从上述分析来看，两者其实从有些角度看是有一定的类似性的：</p><ol><li><strong><font color="red">目的很一致</font></strong>，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；</li><li><strong><font color="red">最终表现类似</font></strong>，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；</li><li><strong><font color="red">粒度一般都是服务级别</font></strong>，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；</li><li><strong><font color="red">自治性要求很高</font></strong>，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；</li></ol><p>而两者的区别也是明显的：</p><ol><li><strong><font color="red">触发原因不太一样</font></strong>，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</li><li><strong><font color="red">管理目标的层次不太一样</font></strong>，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</li></ol><h2>三、Spring Cloud Hystrix</h2><p>Spring Cloud Hystrix是基于Netflix的开源框架Hystrix实现，该框架实现了服务熔断、线程隔离等一系列服务保护功能。对于熔断机制的实现，Hystrix设计了三种状态：</p><p><img src="http://bloghello.oursnail.cn/Hystrix%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81.png" alt="image"></p><ol><li><strong><font color="red">熔断关闭状态（Closed）</font></strong>：服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制。</li><li><strong><font color="red">熔断开启状态（Open）</font></strong>：在固定时间窗口内（Hystrix默认是10秒），接口调用出错比率达到一个阈值（Hystrix默认为50%），会进入熔断开启状态。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法。</li><li><strong><font color="red">半熔断状态（Half-Open）</font></strong>：在进入熔断开启状态一段时间之后（Hystrix默认是5秒），熔断器会进入半熔断状态。所谓半熔断就是尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。</li></ol><p>集成Hystrix也是很简单的：</p><p>demo的改造的基础是<code>eureka-client-feign</code>,将其改造为<code>eureka-client-feign-hystrix</code></p><p>1、引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、添加注解@EnableCircuitBreaker，启用Hystrix</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientFeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在controller方法上增加注解@HystrixCommand</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CityClient cityClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"cities"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"defaultCities"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res = cityClient.listCity();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defaultCities</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"City Data Server is down!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><p>启动eureka和城市数据服务，再启动本服务，是正常的。</p><p><img src="http://bloghello.oursnail.cn/hystrix%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F.png" alt="image"></p><p>那么，我们将城市数据服务关闭，看看有没有返回我们指定的默认值。</p><p><img src="http://bloghello.oursnail.cn/hystrix%E6%B5%8B%E8%AF%95%E5%BC%82%E5%B8%B8.png" alt="image"></p><h2>四、改造本系统</h2><p>在demo中，用<code>@HystrixCommand</code>注解中的熔断时执行的方法来实现异常情况下的默认返回。现在我们要改造<code>msa-weather-report-eureka-feign-gateway</code>，将其改造为<code>msa-weather-report-eureka-feign-gateway-hystrix</code>，我们用新的方式，直接在<code>DataClient</code>这个接口里面声明触发熔断时回调的类<code>DataClientFallback.class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"msa-eureka-client-zuul"</span>,fallback = DataClientFallback.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取城市列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"city/cities"</span>)</span><br><span class="line">    <span class="function">List&lt;City&gt; <span class="title">listCity</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据城市ID获取天气</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"data/weather/cityId/&#123;cityId&#125;"</span>)</span><br><span class="line">    <span class="function">WeatherResponse <span class="title">getDataByCityId</span><span class="params">(@PathVariable(<span class="string">"cityId"</span>)</span> String cityId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体这个回调的类里面时这样写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class DataClientFallback implements DataClient &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;City&gt; listCity() throws Exception &#123;</span><br><span class="line">        List&lt;City&gt; cityList = new ArrayList&lt;&gt;();</span><br><span class="line">        City city = new City();</span><br><span class="line">        city.setCityId(&quot;101190101&quot;);</span><br><span class="line">        city.setCityName(&quot;默认的南京&quot;);</span><br><span class="line"></span><br><span class="line">        cityList.add(city);</span><br><span class="line">        return cityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public WeatherResponse getDataByCityId(String cityId) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果城市数据服务挂了，就默认返回一下我这里设置的城市；如果获取天气信息的服务挂了，我们就直接返回null;</p><p>那么，我们就相当于在feign中启用hystrix，就需要在配置文件中增加配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><p>因为如果根据城市id获取天气信息的服务不可用时，我们默认直接返回null，显示页面啥都不显示时不好的，所以我们需要在前端判断一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--不为空时--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"$&#123;reportModel.report&#125; != null"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-success"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.city&#125;"</span>&gt;</span>城市名称<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            空气质量指数：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.aqi&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            当前温度：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.wendu&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            温馨提示：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;reportModel.report.ganmao&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card  border-info"</span> <span class="attr">th:each</span>=<span class="string">"forecast : $&#123;reportModel.report.forecast&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card-body text-info"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.date&#125;"</span>&gt;</span>日期<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text "</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.type&#125;"</span>&gt;</span>天气类型<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.high&#125;"</span>&gt;</span>最高温度<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.low&#125;"</span>&gt;</span>最低温度<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"card-text"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;forecast.fengxiang&#125;"</span>&gt;</span>风向<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为空时，说明熔断器生效，直接显示提示信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">"$&#123;reportModel.report&#125; == null"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">           天气数据API服务暂不可用！</span><br><span class="line">       <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面就来测试一把吧！</p><p>首先时完全正常的情况，各个服务都可用：</p><p>启动如下服务：redis,<code>weather-sureka-server</code>,<code>msa-weather-city-eureka</code>,<code>msa-weather-collection-eureka-feign-gateway</code>,<code>msa-weather-data-eureka</code>,<code>msa-weather-report-eureka-feign-gateway-hystrix</code>,<code>msa-eureka-client-zuul</code>这六个服务：</p><p><img src="http://bloghello.oursnail.cn/%E9%9B%86%E6%88%90hystrix%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%83%85%E5%86%B5.png" alt="image"></p><p>正常的话，就会看到之前的页面：<a href="http://localhost:8083/report/cityId/101190101" target="_blank" rel="noopener">http://localhost:8083/report/cityId/101190101</a></p><p>城市数据服务不可用，熔断器生效：</p><p>关闭城市数据服务<code>msa-weather-city-eureka</code>，造成服务不可用的现象。看页面显示是否只有我塞进去的假数据。</p><p><img src="http://bloghello.oursnail.cn/%E9%9B%86%E6%88%90hystrix%E7%9A%84%E6%9C%8D%E5%8A%A1-%E6%96%AD%E5%BC%80%E5%9F%8E%E5%B8%82%E6%95%B0%E6%8D%AE.png" alt="image"></p><p>天气数据服务不可用，熔断器生效：</p><p>关闭天气数据API服务<code>msa-weather-data-eureka</code>.看页面是否显示服务暂不可用的提示信息。</p><p>报了一个空指针错误，原因是<code>msa-weather-report-eureka-feign-gateway-hystrix</code>中<code>WeatherReportServiceImpl</code>中的方法原来是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherReportServiceImpl</span> <span class="keyword">implements</span> <span class="title">IWeatherReportService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WeatherClient weatherClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weather <span class="title">getDataByCityId</span><span class="params">(String cityId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weatherClient.getDataByCityId(cityId).getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，要做一下判空操作，否则是不能调用<code>getData()</code>这个方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherReportServiceImpl</span> <span class="keyword">implements</span> <span class="title">IWeatherReportService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataClient dataClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Weather <span class="title">getDataByCityId</span><span class="params">(String cityId)</span> </span>&#123;</span><br><span class="line">        WeatherResponse res = dataClient.getDataByCityId(cityId);</span><br><span class="line">        Weather weather = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="keyword">null</span>)&#123;</span><br><span class="line">            weather = res.getData();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weather;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子，重新启动天气预报UI服务。就可以看到效果啦！</p><p><img src="http://bloghello.oursnail.cn/%E9%9B%86%E6%88%90hystrix%E7%9A%84%E6%9C%8D%E5%8A%A1-%E6%96%AD%E5%BC%80%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E6%9C%8D%E5%8A%A1.png" alt="image"></p><p>这样，本系统集成<code>hystrix</code>就成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第十一篇文章，某个服务一旦出现不可用，可能会牵连整个系统造成雪崩，或者有的时候资源需要聚集在核心业务上，非核心业务就可以适当地关闭，此时就是需要有一种机制来实现系统保护和服务降级的功能。本章介绍hystrix组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>10.天气预报系统-集中化配置</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/10.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E9%9B%86%E4%B8%AD%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/10.天气预报系统-集中化配置/</id>
    <published>2019-02-21T03:27:51.810Z</published>
    <updated>2019-02-21T04:56:11.030Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习的第十篇文章，服务拆分之后，配置文件就必然随着这些拆分的服务分散在各个服务器上，这对运营是一个灾难，用一个集中化的方式统一进行配置文件的配置与修改是必要的。本章介绍spring config的基本使用，但是还是存在一些小问题，在后面的实战环节中会解决。</p><a id="more"></a><h2>一、背景</h2><p>随着线上项目变的日益庞大，每个项目都散落着各种配置文件，如果采用分布式的开发模式，需要的配置文件随着服务增加而不断增多。某一个基础服务信息变更，都会引起一系列的更新和重启，运维苦不堪言也容易出错。配置中心便是解决此类问题的灵丹妙药。</p><p>我们需要一个外部的、集中化的一个配置中心。</p><h2>二、配置分类</h2><ul><li>按配置的来源划分</li></ul><p>主要有源代码、文件、数据库连接、远程调用等</p><ul><li>按配置的环境划分</li></ul><p>主要有开发环境、测试环境、预发布环境、生产环境等。</p><ul><li>按配置的集成阶段划分</li></ul><p>编译时、打包时和运行时</p><ul><li>按配置的加载方式划分</li></ul><p>启动加载和动态加载</p><h2>三、Spring Cloud Config</h2><p>在我们了解<code>spring cloud config</code>之前，我可以想想一个配置中心提供的核心功能应该有什么</p><ul><li>提供服务端和客户端支持</li><li>集中管理各环境的配置文件</li><li>配置文件修改之后，可以快速的生效</li><li>可以进行版本管理</li><li>支持大的并发查询</li><li>支持各种语言</li></ul><p><code>Spring Cloud Config</code>可以完美的支持以上所有的需求。</p><p><strong>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。Spring cloud使用git或svn存放配置文件，默认情况下使用git.</strong></p><p><img src="http://bloghello.oursnail.cn/springcloudconfig%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="image"></p><h2>Server端</h2><p>注册到<code>eureka</code>的实例名：<code>weather-config-server</code></p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: weather-config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https://github.com/sunweiguo/spring-cloud-config-center</span><br><span class="line">          search-paths: config-repo</span><br><span class="line">          username: sunweiguo</span><br><span class="line">          password: xxx</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8761/eureka</span><br><span class="line">server:</span><br><span class="line">  port: 8086</span><br></pre></td></tr></table></figure><p><code>config-repo</code>这个文件夹是由自己在github上创建的。在这个目录下新建一个文件：<code>weather-config-client-dev.properties</code>,里面的内容为<code>auther=oursnail.cn</code>(随便写点东西以供测试)</p><blockquote><p>仓库中的配置文件会被转换成web接口，访问可以参照以下的规则：</p><p>/{application}/{profile}[/{label}]</p><p>/{application}-{profile}.yml</p><p>/{label}/{application}-{profile}.yml</p><p>/{application}-{profile}.properties</p><p>/{label}/{application}-{profile}.properties</p></blockquote><p>我这里的<code>weather-config-client-dev.properties</code>,它的<code>application</code>是<code>weather-config-client</code>，<code>profile</code>是<code>dev</code>。<code>client</code>会根据填写的参数来选择读取对应的配置。</p><p><img src="http://bloghello.oursnail.cn/github%E4%BB%93%E5%BA%93%E9%87%8C%E7%9A%84springconfig%E7%9A%84%E5%80%BC.png" alt="image"></p><p>3、启动类</p><p>启动类添加<code>@EnableConfigServer</code>，激活对配置中心的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherEurekaClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WeatherEurekaClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此server端相关配置已经完成</p><p>4、测试</p><p>访问 <a href="http://localhost:8086/auther/dev" target="_blank" rel="noopener">http://localhost:8086/auther/dev</a> 返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;name&quot;: &quot;auther&quot;,</span><br><span class="line">&quot;profiles&quot;: [</span><br><span class="line">&quot;dev&quot;</span><br><span class="line">],</span><br><span class="line">&quot;label&quot;: null,</span><br><span class="line">&quot;version&quot;: &quot;ef1a6baeddce01d3956ba2a7181f66721959a10c&quot;,</span><br><span class="line">&quot;state&quot;: null,</span><br><span class="line">&quot;propertySources&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以读到<code>auther</code>里的内容，说明服务端配置成功。</p><h2>四、Client端</h2><p>注册到<code>eureka</code>的实例名：<code>weather-config-client</code></p><p>1、添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>2、配置文件</p><p>需要配置两个配置文件，<code>application.properties</code>和<code>bootstrap.properties</code></p><p><code>application.properties</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=weather-config-client</span><br><span class="line">server.port=8087</span><br><span class="line"></span><br><span class="line">eureka.client.service-url.defaultZone: http://localhost:8761/eureka</span><br></pre></td></tr></table></figure><p><code>bootstrap.properties</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.config.name=weather-config-client</span><br><span class="line">spring.cloud.config.profile=dev</span><br><span class="line">spring.cloud.config.uri=http://localhost:8086/</span><br><span class="line">spring.cloud.config.label=master</span><br></pre></td></tr></table></figure><p><code>spring.application.name</code>：对应<code>{application}</code>部分</p><p><code>spring.cloud.config.profile</code>：对应<code>{profile}</code>部分</p><p><code>spring.cloud.config.label</code>：对应git的分支。如果配置中心使用的是本地存储，则该参数无用</p><p><code>spring.cloud.config.uri</code>：配置中心的具体地址,就是server端地址</p><blockquote><p>特别注意：上面这些与spring-cloud相关的属性必须配置在bootstrap.properties中，config部分内容才能被正确加载。因为config的相关配置会先于application.properties，而bootstrap.properties的加载也是先于application.properties。</p></blockquote><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherEurekaClientApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;auther&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String auther;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">"oursnail.cn"</span>,auther);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果测试通过，那么获取内容成功。</p><p>但是我们通过网页的方式进行测试，我们会发现修改了github上的内容后，网页上的内容是不能立即刷新的。这比较头疼，可以通过一些途径去解决。这个自动刷新问题会在后面的实战项目中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;auther&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String auther;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> auther;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习的第十篇文章，服务拆分之后，配置文件就必然随着这些拆分的服务分散在各个服务器上，这对运营是一个灾难，用一个集中化的方式统一进行配置文件的配置与修改是必要的。本章介绍spring config的基本使用，但是还是存在一些小问题，在后面的实战环节中会解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
