<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-23T07:15:50.428Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式事务解决方案思考</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/10分布式事务解决方案思考/</id>
    <published>2019-01-23T07:14:45.099Z</published>
    <updated>2019-01-23T07:15:50.428Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，最头疼的就是分布式事务问题，处理起来一定要小心翼翼。由于没有此方面实战，本文就从理论上看看比较好的分布式事务处理方案。</p><a id="more"></a><h2>什么是分布式事务</h2><p>众所周知，数据库能实现本地事务，也就是在同一个数据库中，你可以允许一组操作要么全都正确执行，要么全都不执行。这里特别强调了<strong>本地事务</strong>，也就是目前的数据库只能支持同一个数据库中的事务。但现在的系统往往采用微服务架构，业务系统拥有独立的数据库，因此就出现了<strong>跨多个数据库的事务需求</strong>，这种事务即为“分布式事务”。那么在目前数据库不支持跨库事务的情况下，我们应该如何实现分布式事务呢？</p><p>比如用户下单过程。当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：</p><ul><li>用户通过商品系统浏览商品，他看中了某一项商品，便点击下单</li><li>此时订单系统会生成一条订单</li><li>订单创建成功后，支付系统提供支付功能</li><li>当支付完成后，由积分系统为该用户增加积分</li></ul><p>上述步骤2、3、4需要在一个事务中完成。对于传统单体应用而言，实现事务非常简单，只需将这三个步骤放在一个方法A中，再用Spring的<code>@Transactional</code>注解标识该方法即可。Spring通过数据库的事务支持，保证这些步骤要么全都执行完成，要么全都不执行。但在这个微服务架构中，这三个步骤涉及三个系统，涉及三个数据库，此时我们必须在数据库和应用系统之间，通过某项黑科技，实现分布式事务的支持。</p><h2>方案1：基于可靠消息服务的分布式事务</h2><p><img src="http://bloghello.oursnail.cn/mama11-1.png" alt="image"></p><ul><li>在系统A处理任务A前，首先向消息中间件发送一条消息</li><li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li><li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li><li>系统A收到确认应答后，则可以开始处理任务A；</li><li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。<br>但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li><li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li><li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li></ul><p>上述过程中，如果任务A处理失败，那么需要进入回滚流程:</p><ul><li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li><li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li></ul><p>上面所介绍的<code>Commit</code>和<code>Rollback</code>都属于理想情况，但在实际系统中，<code>Commit</code>和<code>Rollback</code>指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是超时询问机制。</p><p>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的<code>Commit</code>或<code>Rollback</code>指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p><ul><li>提交  若获得的状态是“提交”，则将该消息投递给系统B。</li><li>回滚  若获得的状态是“回滚”，则直接将条消息丢弃。</li><li>处理中  若获得的状态是“处理中”，则继续等待。</li></ul><p>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p><p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。</p><p>注意，这个方案需要消息队列具有事务消息的能力，阿里的<code>RocketMQ</code>可以实现这个目标。其他的MQ还不行。</p><h2>方案2：最大努力通知（定期校对）</h2><p><img src="http://bloghello.oursnail.cn/mama11-2.png" alt="image"></p><ul><li>上游系统在完成任务后，向消息中间件同步地发送一条消息，确保消息中间件成功持久化这条消息，然后上游系统可以去做别的事情了；</li><li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；</li><li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</li></ul><p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p><ul><li>消息中间件向下游系统投递消息失败</li><li>上游系统向消息中间件发送消息失败</li></ul><p>对于第一种情况，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，<strong>如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“定期校对”</strong>。</p><p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p><p>对于第二种情况，需要在上游系统中建立消息重发机制。<strong>可以在上游系统建立一张本地消息表，并将 任务处理过程 和 向本地消息表中插入消息 这两个步骤放在一个本地事务中完成</strong>。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。</p><p>如果这两步都执行成功，那么该本地事务就完成了。<strong>接下来会有一个专门的消息发送者不断地发送本地消息表中的消息</strong>，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p><p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过重试机制+定期校对实现分布式事务，但相比于第一种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p><p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。还有其他的一些解决思路，这里就暂时只描述这些。后续再学习。</p><p>参考自：<a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">https://juejin.im/post/5aa3c7736fb9a028bb189bca</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式系统中，最头疼的就是分布式事务问题，处理起来一定要小心翼翼。由于没有此方面实战，本文就从理论上看看比较好的分布式事务处理方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>库存扣减问题</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/09库存扣减问题/</id>
    <published>2019-01-23T07:09:02.844Z</published>
    <updated>2019-01-23T07:10:26.873Z</updated>
    
    <content type="html"><![CDATA[<p>库存扣减问题一直是秒杀中最关键的一个点。如果把控不好，扣成负数，那可就麻烦了，如么如何保证不会出现超卖还能保证性能呢？</p><a id="more"></a><h2>一、扣减库存问题分析</h2><p>在提交订单的时候，要扣减库存，对于sql，是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>首先这条sql存在超卖问题，很有可能会减成负数。可能会改成如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span> <span class="keyword">and</span> stock &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样好像解决了超卖问题。但是引入了新的问题。由于库存牵涉进货、补货等系统，所以是个独立的服务。</p><p>并且，比如我是通过MQ去通知库存进行扣减库存，但是由于网络抖动，请求扣减库存没有结果，这个时候可能需要进行重试。重试之后，可能成功了，这个时候，有可能这两次都成功了。那么，一个用户买一样东西，但是库存扣了两遍。这就是幂等。如果不做幂等处理，重试会出现上述这种致命问题。</p><p>那么如何做到幂等呢？</p><p>实际上就是追求数据一致性。那么就可以考虑锁来保证，比如我这里用乐观锁来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> stock,<span class="keyword">version</span> <span class="keyword">from</span> t_stock;</span><br><span class="line">if(stock &gt; 用户购买数量)</span><br><span class="line">    <span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span> = last_version</span><br></pre></td></tr></table></figure><p>但是，一旦出现并发，那么可能这个用户是执行update失败的，所以还需要去重试(guava retry或者spring retry都可以优雅地实现重试)，直到成功或者库存已经不足。</p><p>那么，在少量并发的情况下，可以考虑乐观锁，要不然会大量失败，此时需要用悲观锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_stock <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">下面执行<span class="keyword">update</span>操作。。。</span><br></pre></td></tr></table></figure><p>在一个事务内，第一句为<code>select for update</code>，那么这一行数据就会被本线程锁住，整个事务执行完才能允许其他线程进来。</p><p>存在的问题：一个线程锁住这行数据，那么其他线程都要等待，效率很低。</p><p>那么，如何保证数据一致性，还可以提高效率呢？</p><p>对于扣减库存，往往是先在redis中进行扣减库存。redis是单线程，是高速串行执行，不存在并发问题。</p><p>如果是单机redis，可以在同一个事务中保证一次性执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch stock</span><br><span class="line">multi</span><br><span class="line">if stock &gt; count</span><br><span class="line">    stock = stock - count;</span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/mama8-1.png" alt="image"></p><p>但是不能在集群中用（分布在不同节点上时），所以用watch不通用。</p><p>redis都是原子操作，比如自增:incrby，用这个就可以判断库存是否够。就是所谓的redis预减库存。</p><p>但是在实际中，库存表里有两个字段：库存和锁定库存。</p><p>锁定库存是表示多少用户真正下单了，但是还没有支付。锁定库存+库存=总库存，等用户真正支付之后，就可以将锁定库存减掉。那么，此时，redis中需要存库存和锁定库存这两个值，上面单一的原子操作就不行了。</p><p>解决方案：redis+lua</p><p>为什么要用lua呢？可以用lua将一系列操作封装起来执行，输入自己的参数即可。lua脚本在redis中执行是串行的、原子性的。</p><p>OK，下面就实战一波：根据skuId查询缓存中的库存值。</p><h2>二、查询库存（设置库存）</h2><p>首先，我们要明确一点，redis中的库存初始值是由后台的系统人工提前配置好的，在进行商品销售时（用户下单时），直接从redis中先进行库存的扣减。</p><p>这里呢，我们没有进行初始化，而是在程序中进行判断：如果redis已经有了这个库存值，就将他查询出来返回；否则，就去数据库查询，然后对redis进行初始化。</p><p>这里的一个问题是：如果存在并发问题，但是我们初始化两个值（库存值和库存锁定值），这里采用lua脚本，在lua脚本中完成初始化，并且对于两个用户同时进行初始化库存的问题，可以在lua中进行判断,因为redis是单线程，lua也是单线程，不用担心会同时初始化两次。</p><p>下面首先写一个接口，根据skuid查询库存(库存和锁定库存)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/query/&#123;skuId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult&lt;Stock&gt; <span class="title">queryStock</span><span class="params">(@PathVariable <span class="keyword">long</span> skuId)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;Stock&gt;  result = <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"库存查询成功"</span>);</span><br><span class="line">    Stock stock = <span class="keyword">new</span> Stock();</span><br><span class="line">    stock.setSkuId(skuId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stockCount = stockService.queryStock(skuId);</span><br><span class="line"></span><br><span class="line">    stock.setStock(stockCount);</span><br><span class="line">    result.setData(stock);</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queryStock</span><span class="params">(<span class="keyword">long</span> skuId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先查redis</span></span><br><span class="line">    Stock stock ;</span><br><span class="line">    String stockKey = Constants.CACHE_PRODUCT_STOCK+<span class="string">":"</span>+skuId;</span><br><span class="line">    String stockLockKey = Constants.CACHE_PRODUCT_STOCK_LOCK+<span class="string">":"</span>+skuId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只需要查询一个即可，比如我这里只查询库存就行</span></span><br><span class="line">    Object stockObj = redisTemplate.opsForValue().get(stockKey);</span><br><span class="line">    Integer stockInRedis = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">if</span>(stockObj!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stockInRedis = Integer.valueOf(stockObj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有，那么我就需要将数据库中的数据初始化到redis中</span></span><br><span class="line">    <span class="keyword">if</span>(stockInRedis==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//去数据库查询 然后对redis进行初始化</span></span><br><span class="line">        stock = stockMapper.selectBySkuId(skuId);</span><br><span class="line">        <span class="comment">//两个key和两个库存值通过lua脚本塞到redis中</span></span><br><span class="line">        <span class="comment">//这里如果发生两个用户并发初始化redis，脚本中会进行判断，如果已经初始化了，脚本就会停止执行</span></span><br><span class="line">        <span class="comment">// 设置库存不应该在这配置，应该是后台管理系统进行设置，所以正常情况下，这里redis中应该是必然存在的</span></span><br><span class="line">        <span class="comment">//如果是在后台配置，就没有必要这么复杂了</span></span><br><span class="line">        redisUtils.skuStockInit(stockKey,stockLockKey,stock.getStock().toString(),stock.getLockStock().toString());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockInRedis;<span class="comment">//缓存中有就直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存结果可能会返回设置不成功，所以还是返回数据库查询结果</span></span><br><span class="line">    <span class="keyword">return</span> stock.getStock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个工具类为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看redis是否已经初始化好库存初始值，没有就初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_CACHE_LUA =</span><br><span class="line">        <span class="string">"local stock = KEYS[1] "</span> +</span><br><span class="line">                <span class="string">"local stock_lock = KEYS[2] "</span> +</span><br><span class="line">                <span class="string">"local stock_val = tonumber(ARGV[1]) "</span> +</span><br><span class="line">                <span class="string">"local stock_lock_val = tonumber(ARGV[2]) "</span> +</span><br><span class="line">                <span class="string">"local is_exists = redis.call(\"EXISTS\", stock) "</span> +</span><br><span class="line">                <span class="string">"if is_exists == 1  then "</span> +</span><br><span class="line">                <span class="string">"   return 0 "</span> +</span><br><span class="line">                <span class="string">"else  "</span> +</span><br><span class="line">                <span class="string">"   redis.call(\"SET\", stock, stock_val) "</span> +</span><br><span class="line">                <span class="string">"   redis.call(\"SET\", stock_lock, stock_lock_val) "</span> +</span><br><span class="line">                <span class="string">"   return 1 "</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 缓存sku库存 以及锁定库存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">skuStockInit</span><span class="params">(String stockKey,String stockLockKey,String stock,String stockLock)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用jedis去执行lua脚本 输入的参数要注意顺序 都是写死的 第一组是key，第二组是stock</span></span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(STOCK_CACHE_LUA, Collections.unmodifiableList(Arrays.asList(stockKey,stockLockKey))</span><br><span class="line">                ,Collections.unmodifiableList(Arrays.asList(stock, stockLock)));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (EXCUTE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于lua脚本进行稍微的解释一下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//第一组数据是key数组；第二组数据是args数组，是与key数组对应的值，就是库存</span><br><span class="line">//我们这里第一组为[stockKey,stockLockKey],就是存在redis中的名字，这里是在service层中定义好了</span><br><span class="line">//第二组为[<span class="number">50</span>,<span class="number">0</span>]，这个值就是可以从数据库表t_stock中查询出来的</span><br><span class="line">//因为执行这段lua脚本的话，说明redis中没有缓存的数据，所以需要先查询数据库，然后将缓存设置好</span><br><span class="line">//lua中定义变量用<span class="keyword">local</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> stock = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> stock_lock = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> stock_val = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> stock_lock_val = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">//再查询一遍缓存是否存在，防止两个线程同时进来设置缓存</span><br><span class="line">//存在就不用设置缓存了，否则就设置缓存</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> is_exists = redis.call(<span class="string">"EXISTS"</span>, stock)</span><br><span class="line"><span class="keyword">if</span> is_exists == <span class="number">1</span>  <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">"SET"</span>, stock, stock_val)</span><br><span class="line">    redis.call(<span class="string">"SET"</span>, stock_lock, stock_lock_val)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那么，启动工程<code>mama-buy-stock</code>：假如我去查询skuId=1的商品：</p><p><img src="http://bloghello.oursnail.cn/mama8-2.png" alt="image"></p><p>第一次库存不存在，那么就会去查询数据库：</p><p><img src="http://bloghello.oursnail.cn/mama8-3.png" alt="image"></p><p>我们再来看看redis中的数据：</p><p><img src="http://bloghello.oursnail.cn/mama8-4.png" alt="image"></p><h2>三、扣减库存</h2><p>下面来看看扣减库存是如何实现的。因为提交订单后，往往是不止一件商品的，往往购物车内有很多件商品，同时过来，假设有五件商品，但是其中只有一件暂时没有库存了，那么我还是希望其他的四件商品能够卖出去，只是没有库存的商品就不算钱了。所以扣减库存用一个map来装，即<code>Map&lt;skuId,count&gt;</code></p><p>controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/reduce"</span>)</span><br><span class="line"><span class="keyword">public</span> ApiResult&lt;Map&lt;Long,Integer&gt;&gt; reduceStock(<span class="meta">@RequestBody</span> List&lt;StockReduce&gt; stockReduceList)&#123;</span><br><span class="line">    ApiResult result = <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"库存扣减成功"</span>);</span><br><span class="line">    Map&lt;Long,Integer&gt; resultMap =  stockService.reduceStock(stockReduceList);</span><br><span class="line">    result.setData(resultMap);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Long, Integer&gt; <span class="title">reduceStock</span><span class="params">(List&lt;StockReduce&gt; stockReduceList)</span> </span>&#123;</span><br><span class="line">    Map&lt;Long, Integer&gt; resultMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历去减redis中库存，增加锁定库存</span></span><br><span class="line">    stockReduceList.stream().forEach(param -&gt; &#123;</span><br><span class="line">        String stockKey = Constants.CACHE_PRODUCT_STOCK+<span class="string">":"</span>+param.getSkuId();</span><br><span class="line">        String stockLockKey = Constants.CACHE_PRODUCT_STOCK_LOCK+<span class="string">":"</span>+param.getSkuId();</span><br><span class="line">        Object result = redisUtils.reduceStock(stockKey,</span><br><span class="line">                                               stockLockKey,</span><br><span class="line">                                               param.getReduceCount().toString(),<span class="comment">//incrby一个负数，就是减</span></span><br><span class="line">                                               String.valueOf(Math.abs(param.getReduceCount())));<span class="comment">//incrby一个正数，就是加</span></span><br><span class="line">        <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Long)&#123;</span><br><span class="line">            <span class="comment">//库存不存在或者不足 扣减失败 sku下单失败 记录下来</span></span><br><span class="line">            resultMap.put(param.getSkuId(),-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> List)&#123;</span><br><span class="line">            <span class="comment">//扣减成功 记录扣减流水</span></span><br><span class="line">            List resultList =  ((List) result);</span><br><span class="line">            <span class="keyword">int</span> stockAftChange =  ((Long)resultList.get(<span class="number">0</span>)).intValue();</span><br><span class="line">            <span class="keyword">int</span> stockLockAftChange = ((Long) resultList.get(<span class="number">1</span>)).intValue();</span><br><span class="line">            StockFlow stockFlow = <span class="keyword">new</span> StockFlow();</span><br><span class="line">            stockFlow.setOrderNo(param.getOrderNo());</span><br><span class="line">            stockFlow.setSkuId(param.getSkuId());</span><br><span class="line">            stockFlow.setLockStockAfter(stockLockAftChange);</span><br><span class="line">            stockFlow.setLockStockBefore(stockLockAftChange+param.getReduceCount());</span><br><span class="line">            stockFlow.setLockStockChange(Math.abs(param.getReduceCount()));</span><br><span class="line">            stockFlow.setStockAfter(stockAftChange);</span><br><span class="line">            stockFlow.setStockBefore(stockAftChange+Math.abs(param.getReduceCount()));</span><br><span class="line">            stockFlow.setStockChange(param.getReduceCount());</span><br><span class="line">            stockFlowMapper.insertSelective(stockFlow);</span><br><span class="line">            resultMap.put(param.getSkuId(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于redis的操作，基本与上一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>   扣减库存lua脚本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> 0  key不存在 错误   -1 库存不足  返回list  扣减成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_REDUCE_LUA=</span><br><span class="line">        <span class="string">"local stock = KEYS[1]\n"</span> +</span><br><span class="line">                <span class="string">"local stock_lock = KEYS[2]\n"</span> +</span><br><span class="line">                <span class="string">"local stock_change = tonumber(ARGV[1])\n"</span> +</span><br><span class="line">                <span class="string">"local stock_lock_change = tonumber(ARGV[2])\n"</span> +</span><br><span class="line">                <span class="string">"local is_exists = redis.call(\"EXISTS\", stock)\n"</span> +</span><br><span class="line">                <span class="string">"if is_exists == 1 then\n"</span> +</span><br><span class="line">                <span class="string">"    local stockAftChange = redis.call(\"INCRBY\", stock,stock_change)\n"</span> +</span><br><span class="line">                <span class="string">"    if(stockAftChange&lt;0) then\n"</span> +</span><br><span class="line">                <span class="string">"        redis.call(\"DECRBY\", stock,stock_change)\n"</span> +</span><br><span class="line">                <span class="string">"        return -1\n"</span> +</span><br><span class="line">                <span class="string">"    else \n"</span> +</span><br><span class="line">                <span class="string">"        local stockLockAftChange = redis.call(\"INCRBY\", stock_lock,stock_lock_change)\n"</span> +</span><br><span class="line">                <span class="string">"        return &#123;stockAftChange,stockLockAftChange&#125;\n"</span> +</span><br><span class="line">                <span class="string">"    end "</span> +</span><br><span class="line">                <span class="string">"else \n"</span> +</span><br><span class="line">                <span class="string">"    return 0\n"</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reduceStock</span><span class="params">(String stockKey,String stockLockKey,String stockChange,String stockLockChange)</span></span>&#123;</span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(STOCK_REDUCE_LUA, Collections.unmodifiableList(Arrays.asList(stockKey,stockLockKey))</span><br><span class="line">                ,Collections.unmodifiableList(Arrays.asList(stockChange, stockLockChange)));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，一旦数据库发生异常，那么就会回滚，但是redis中是无法回滚的。这个问题不用担心，因为数据库发生异常是及其严重的问题，是很少会发生的，一旦发生，只需要去这个流水的表中去查看情况，然后去执行脚本去初始化这个redis即可。所以是可以补救的。</p><p>但是接口的幂等性还没有做。重复尝试调用这个接口（通常是发生在MQ的失败重传机制，客户端的连续点击一般是可以避免的），可能会重复减redis库存并且重复地去插入流水记录。这个问题该如何解决呢？</p><h2>四、redis分布式锁来实现幂等性</h2><p>主流的方案，比如有用一张表来控制，比如以这个orderID为唯一主键，一旦插入成功，就可以根据这个唯一主键的存在与否判断是否为重复请求（也就是说，这里的扣减库存和插入去重表放在一个事务里，去重表中有一个字段为orderId，全局唯一不重复，用唯一索引进行约束，那么插入的时候判断这个去重表是否可以插入成功，如果不成功，那么数据库操作全部回滚）。</p><p>可以用redis分布式锁给这个订单上锁。以订单id为锁，不会影响其他线程来扣减库存，所以不影响性能。</p><p>针对这个订单，第一次肯定是可以去扣减库存的，但是第二次再接收到这个请求，那么就要返回已经成功了，不要再重复扣减。</p><p>对于<code>reduceStock()</code>这个方法最前面增加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止扣减库存时MQ正常重试时的不幂等</span></span><br><span class="line"><span class="comment">//以订单ID 加个缓存锁 防止程序短时间重试 重复扣减库存 不用解锁 自己超时</span></span><br><span class="line">Long orderNo = stockReduceList.get(<span class="number">0</span>).getOrderNo();</span><br><span class="line"><span class="keyword">boolean</span> lockResult = redisUtils.distributeLock(Constants.ORDER_RETRY_LOCK+orderNo.toString(),orderNo.toString(),<span class="number">300000</span>);</span><br><span class="line"><span class="keyword">if</span>(!lockResult)&#123;</span><br><span class="line">    <span class="comment">//锁定失败 重复提交 返回一个空map</span></span><br><span class="line">    <span class="keyword">return</span>  Collections.EMPTY_MAP;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long EXCUTE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**lua脚本  在redis中 lua脚本执行是串行的 原子的 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNLOCK_LUA=</span><br><span class="line">        <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> +</span><br><span class="line">                <span class="string">"   return redis.call('del', KEYS[1]) "</span> +</span><br><span class="line">                <span class="string">"else "</span> +</span><br><span class="line">                <span class="string">"   return 0 "</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 获取分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">distributeLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span></span>&#123;</span><br><span class="line">    String result = redisTemplate.execute((RedisCallback&lt;String&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        JedisCommands commands = (JedisCommands)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> commands.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);<span class="comment">//一条命令实现setnx和setexpire这些操作，原子性</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 释放分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseDistributelock</span><span class="params">(String lockKey, String requestId)</span></span>&#123;</span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(UNLOCK_LUA, Collections.singletonList(lockKey), Collections.singletonList(requestId));<span class="comment">//lua脚本中原子性实现：get查询和delete删除这两个操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (EXCUTE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里不需要我们主动去释放分布式锁，只要设置一个大于重试时间的过期时间即可。让它自己删除。</p><p>注意redis在集群下做分布式锁，最好要用Redission。这里如果用于集群，如何lua脚本在一个事务里同时操作多个key的时候，如果要保证这个事务生效，就需要保证这几个key都要在同一个节点上。但是，比如我们这里的两个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK = <span class="string">"product:stock"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK_LOCK = <span class="string">"product:stock:lock"</span>;</span><br></pre></td></tr></table></figure><p>因为我们这里要同时对库存和锁定库存这两个key进行操作，需要放在一个事务内执行，不处理的话，一旦他们不在一个节点，那么事务就不会生效，解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK = <span class="string">"&#123;product:stock&#125;"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK_LOCK = <span class="string">"&#123;product:stock&#125;:lock"</span>;</span><br></pre></td></tr></table></figure><p>如果加上花括号，那么在进行计算hash值的时候，他们两就会是一样的，会被投放到同一个slot中，自然就保证了在同一个节点上。</p><h2>五、测试一下</h2><p><img src="http://bloghello.oursnail.cn/mama8-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mama8-5.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mama8-7.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;库存扣减问题一直是秒杀中最关键的一个点。如果把控不好，扣成负数，那可就麻烦了，如么如何保证不会出现超卖还能保证性能呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>ELK平台搭建</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/08ELK平台搭建/</id>
    <published>2019-01-23T07:02:24.093Z</published>
    <updated>2019-01-23T07:04:59.931Z</updated>
    
    <content type="html"><![CDATA[<p>因为要完成产品的全文搜索这个功能，所以需要准备一下ES的环境。本节安装ELK。</p><p>ELK由Elasticsearch、Logstash和Kibana三部分组件组成。</p><a id="more"></a><h2>前言</h2><p><img src="http://bloghello.oursnail.cn/mama6-2.png" alt="image"></p><p><code>Elasticsearch</code>是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，<code>restful</code>风格接口，多数据源，自动搜索负载等。<br>简单来说，他是个全文搜索引擎，可以快速地储存、搜索和分析海量数据。</p><p><code>Logstash</code>是一个完全开源的工具，它可以把分散的、多样化的日志日志，或者是其他数据源的数据信息进行收集、分析、处理，并将其存储供以后使用。</p><p><code>Kibana</code>是一个开源的分析和可视化平台，设计用于和<code>Elasticsearch</code>一起工作。</p><p>你用<code>Kibana</code>来搜索，查看，并和存储在<code>Elasticsearch</code>索引中的数据进行交互。</p><p>你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。</p><p><code>Kibana</code>使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示<code>Elasticsearch</code>查询的变化。</p><h2>一、安装ES</h2><h3>1.1 首先是安装JDK：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line"></span><br><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;</span><br><span class="line"></span><br><span class="line">tar xzf jdk-8u141-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h3>1.2 添加环境变量：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">JAVA_HOME=/opt/jdk1.8.0_141</span><br><span class="line">JAVA_JRE=$JAVA_HOME/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h3>1.3 下载6.2.4版本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.tar.gz</span><br><span class="line">tar -xzvf elasticsearch-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf elasticsearch-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line">mv elasticsearch-6.2.4 elasticsearch</span><br></pre></td></tr></table></figure><h3>1.4 配置sysctl.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#修改sysctl配置</span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"> </span><br><span class="line">#添加如下配置</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"> </span><br><span class="line">#让配置生效</span><br><span class="line">sysctl -p</span><br><span class="line"> </span><br><span class="line">#查看配置的数目</span><br><span class="line">sysctl -a|grep vm.max_map_count</span><br></pre></td></tr></table></figure><h3>1.5 elasticsearch从5.0版本之后不允许root账户启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#添加用户</span><br><span class="line">adduser dev</span><br><span class="line"> </span><br><span class="line">#设定密码</span><br><span class="line">passwd dev</span><br><span class="line"> </span><br><span class="line">#添加权限</span><br><span class="line">chown -R dev /opt/elasticsearch</span><br><span class="line"> </span><br><span class="line">#切换用户</span><br><span class="line">su dev</span><br><span class="line"> </span><br><span class="line">#查看当前用户</span><br><span class="line">who am i</span><br><span class="line"> </span><br><span class="line">#启动</span><br><span class="line">./elasticsearch/bin/elasticsearch</span><br><span class="line"> </span><br><span class="line">#后台启动</span><br><span class="line">./elasticsearch/bin/elasticsearch -d</span><br></pre></td></tr></table></figure><h3>1.6 配置limits.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line"> </span><br><span class="line">把</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"> </span><br><span class="line">改为</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line"> </span><br><span class="line">#切换用户</span><br><span class="line">su dev</span><br><span class="line"> </span><br><span class="line">#查看配置是否生效</span><br><span class="line">ulimit -Hn</span><br></pre></td></tr></table></figure><h3>1.7 配置所有用户访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><h3>1.8 添加一下内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><h3>1.9 重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep elastic</span><br><span class="line">kill -9 xxxx</span><br></pre></td></tr></table></figure><h3>1.10 测试：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200/</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;MmiaBfA&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;zjX-q5PDRLyrWMy5TiBDkw&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.2.4&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;ccec39f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2018-04-12T20:37:28.497551Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;7.2.1&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就说明成功了。</p><h2>二、安装Kibana 6.2.4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">mv kibana-6.2.4-linux-x86_64 kibana</span><br><span class="line"></span><br><span class="line">vim /opt/kibana/config/kibana.yml</span><br></pre></td></tr></table></figure><h3>2.1 添加以下内容：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.url: &quot;http://127.0.0.1:9200&quot;</span><br></pre></td></tr></table></figure><h3>2.2 切换到bin目录下，启动即可。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#不能关闭终端</span><br><span class="line">./kibana  </span><br><span class="line"></span><br><span class="line">#可关闭终端</span><br><span class="line">nohup ./kibana &amp;</span><br></pre></td></tr></table></figure><h3>2.3 开放防火墙和安全组对应的这个端口</h3><p>浏览器访问：<a href="http://106.14.163.235:5601" target="_blank" rel="noopener">http://106.14.163.235:5601</a> 看到一个控制台页面就成功啦。</p><p><img src="http://bloghello.oursnail.cn/mama6-1.png" alt="image"></p><h3>2.4 关闭这个进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ps -ef|grep kibana</span><br><span class="line"> </span><br><span class="line">ps -ef|grep 5601</span><br><span class="line"> </span><br><span class="line">都找不到 </span><br><span class="line"> </span><br><span class="line">尝试 使用 fuser -n tcp 5601</span><br><span class="line"> </span><br><span class="line">kill -9  端口</span><br><span class="line"> </span><br><span class="line">启动即可 ./kibana</span><br><span class="line"></span><br><span class="line">或者去这个目录下的.out日志中可以看到看到它占用的pid</span><br></pre></td></tr></table></figure><h2>三、logstash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf logstash-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line"># 重命名</span><br><span class="line">mv logstash-6.2.4.tar.gz logstash</span><br><span class="line"></span><br><span class="line"># 进入</span><br><span class="line">cd logstash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个配置文件 我这里是mysqltones.conf</span><br><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">      jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/mama-buy-trade&quot;</span><br><span class="line">      jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">      jdbc_password =&gt; &quot;root&quot;</span><br><span class="line"></span><br><span class="line">      jdbc_driver_library =&gt; &quot;/opt/logstash/mysql-connector-java-5.1.46-bin.jar&quot;</span><br><span class="line">      # the name of the driver class for mysql</span><br><span class="line">      jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">      jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">      jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line"></span><br><span class="line">      # mysql文件, 也可以直接写SQL语句在此处，如下：</span><br><span class="line">      statement =&gt; &quot;SELECT * from t_product&quot;</span><br><span class="line">      # statement_filepath =&gt; &quot;/opt/logstash/conf/jdbc.sql&quot;</span><br><span class="line"></span><br><span class="line">      # 这里类似crontab,可以定制定时操作，比如每10分钟执行一次同步(分 时 天 月 年)</span><br><span class="line">      schedule =&gt; &quot;*/10 * * * *&quot;</span><br><span class="line">      type =&gt; &quot;jdbc&quot;</span><br><span class="line"></span><br><span class="line">      # 是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中</span><br><span class="line">      record_last_run =&gt; &quot;true&quot;</span><br><span class="line"></span><br><span class="line">      # 是否需要记录某个column 的值,如果record_last_run为真,可以自定义我们需要 track 的 column 名称，此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.</span><br><span class="line">      use_column_value =&gt; &quot;true&quot;</span><br><span class="line"></span><br><span class="line">      # 如果 use_column_value 为真,需配置此参数. track 的数据库 column 名,该 column 必须是递增的. 一般是mysql主键</span><br><span class="line">      tracking_column =&gt; &quot;id&quot;</span><br><span class="line"></span><br><span class="line">      last_run_metadata_path =&gt; &quot;/opt/logstash/conf/last_id&quot;</span><br><span class="line"></span><br><span class="line">      # 是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录</span><br><span class="line">      clean_run =&gt; &quot;false&quot;</span><br><span class="line"></span><br><span class="line">      # 是否将 字段(column) 名称转小写</span><br><span class="line">      lowercase_column_names =&gt; &quot;false&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 此处我不做过滤处理</span><br><span class="line">filter &#123;&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    # 输出到elasticsearch的配置</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        index =&gt; &quot;jdbc&quot;</span><br><span class="line"></span><br><span class="line">        # 将&quot;_id&quot;的值设为mysql的autoid字段</span><br><span class="line">        document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">        template_overwrite =&gt; true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 这里输出调试，正式运行时可以注释掉</span><br><span class="line">    stdout &#123;</span><br><span class="line">        codec =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">./bin/logstash -f ./mysqltones.conf</span><br></pre></td></tr></table></figure><p>看到这个就说明成功了：</p><p><img src="http://bloghello.oursnail.cn/mama6-3.png" alt="image"></p><h2>安装mysql数据库</h2><p>这一步要在执行logstash之前搞定，我的是阿里云centos7.3版本，mysql版本是5.7，安装过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 下载MySQL源安装包: </span><br><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"></span><br><span class="line"># 安装MySQL源：</span><br><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm </span><br><span class="line"></span><br><span class="line"># 检查MySQL源安装情况： </span><br><span class="line">yum repolist enabled | grep &quot;mysql.*-community.*&quot;</span><br><span class="line"></span><br><span class="line"># 安装MySQL: </span><br><span class="line">yum install mysql-community-server</span><br><span class="line"></span><br><span class="line"># 启动MySQL: </span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"># 查看MySQL状态: </span><br><span class="line">systemctl status mysqld</span><br><span class="line"></span><br><span class="line"># 设置开机启动MySQL：</span><br><span class="line">systemctl enable mysqld </span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 查找并修改MySQL默认密码（注意密码要符合规范，否则会失败）：</span><br><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log </span><br><span class="line"></span><br><span class="line">mysql -uroot -p </span><br><span class="line"></span><br><span class="line">alter user root@localhost identified by &apos;你的新密码&apos;;</span><br><span class="line"></span><br><span class="line"># 远程连接测试添加远程账户：</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;用户&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"># 立即生效：</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># 退出MySQL：</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 最后远程将数据给导入数据库</span><br></pre></td></tr></table></figure><h2>安装分词器</h2><p><code>ik_max_word</code>是分词比较细腻的一款，我们就用它来做分词，首先需要安装一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接安装</span><br><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.4/elasticsearch-analysis-ik-6.2.4.zip</span><br><span class="line"> </span><br><span class="line"># 重新启动ES</span><br><span class="line">ps -ef | grep elastic</span><br><span class="line">kill -9 xxxx</span><br><span class="line">su dev</span><br><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><p>对这个分词器在<code>kibana</code>中进行测试：</p><p><img src="http://bloghello.oursnail.cn/mama6-5.png" alt="image"></p><p>下面结合数据库模拟一下：</p><p><img src="http://bloghello.oursnail.cn/mama6-4.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为要完成产品的全文搜索这个功能，所以需要准备一下ES的环境。本节安装ELK。&lt;/p&gt;
&lt;p&gt;ELK由Elasticsearch、Logstash和Kibana三部分组件组成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Curator</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/07Curator实现分布式锁/</id>
    <published>2019-01-23T06:57:33.756Z</published>
    <updated>2019-01-23T07:00:42.083Z</updated>
    
    <content type="html"><![CDATA[<p>从技术角度出发，注册一个网站，再高并发的时候，有可能出现用户名重复这样的问题（虽然一般情况下不会出现这种问题），如何解决呢？</p><a id="more"></a><p>从数据库角度，对于单表，我可以用<code>select .. for update</code>悲观锁实现，或者用version这种乐观锁的思想。</p><p>更好的方法是将这个字段添加唯一索引，用数据库来保证不会重复。一旦插入重复，那么就会抛出异常，程序就可以捕获到。</p><p>但是，加入我们这里分表了，以上都是针对单表，第一种方案是锁表，不行，设置唯一索引是没有用。怎么办呢？</p><p>解决方案：用ZK做一个分布式锁。</p><p>首先准备一个ZK客户端，用的是<code>Curator</code>来连接我们的ZK：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">getZkClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        CuratorFrameworkFactory.Builder builder= CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(parameters.getZkHost())</span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">        CuratorFramework framework = builder.build();</span><br><span class="line">        framework.start();</span><br><span class="line">        <span class="keyword">return</span> framework;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册用一个分布式锁来控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    InterProcessLock lock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock = <span class="keyword">new</span> InterProcessMutex(zkClient, Constants.USER_REGISTER_DISTRIBUTE_LOCK_PATH);</span><br><span class="line">        <span class="keyword">boolean</span> retry = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">3000</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                <span class="comment">//查询重复用户</span></span><br><span class="line">                User repeatedUser = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">                <span class="keyword">if</span>(repeatedUser!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> MamaBuyException(<span class="string">"用户邮箱重复"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line">                user.setNickname(<span class="string">"码码购用户"</span>+user.getEmail());</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">                <span class="comment">//跳出循环</span></span><br><span class="line">                retry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可以适当休息一会...也可以设置重复次数，不要无限循环</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (retry);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">"用户注册异常"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span>  e;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lock != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">                log.info(user.getEmail()+Thread.currentThread().getName()+<span class="string">"释放锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路非常简单，就是先尝试上锁，即<code>acquire</code>，但是有可能失败，所以这里用一个超时时间，即<code>3000ms</code>之内上不了锁就失败，进入下一次循环。最后释放锁即可。</p><p>ok，这里要来说说ZK实现分布式锁了。这里用了开源客户端<code>Curator</code>，他对于实现分布式锁进行了封装，但是，我还是想了解一下它的实现原理：</p><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>也就是说，最小的那个节点就是Leader，进来判断是不是为那个节点，是的话就可以获取到锁，反之不行。</p><blockquote><p>为什么不能通过大家一起创建节点，如果谁成功了就算获取到了锁。 多个client创建一个同名的节点，如果节点谁创建成功那么表示获取到了锁，创建失败表示没有获取到锁。</p></blockquote><p>答：使用临时顺序节点可以保证获得锁的公平性，及谁先来谁就先得到锁，这种方式是随机获取锁，会造成无序和饥饿。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从技术角度出发，注册一个网站，再高并发的时候，有可能出现用户名重复这样的问题（虽然一般情况下不会出现这种问题），如何解决呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Spring Session</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/06Spring%20Session/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/06Spring Session/</id>
    <published>2019-01-23T06:40:34.693Z</published>
    <updated>2019-01-23T06:52:48.614Z</updated>
    
    <content type="html"><![CDATA[<p>在单体应用中，我们经常用http session去管理用户信息，但是到了分布式环境下，显然是不行的，因为session对于不同的机器是隔离的，而http本身是无状态的，那么就无法判断出用户在哪一个服务器上登陆的。这个时候就需要有一个独立的地方存储用户session。spring session可以做到无代码侵入的方式实现分布式session存储。</p><a id="more"></a><p>在<code>spring boot</code>开发中，我们先注册相应<code>bean</code>并且打开相应的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span> <span class="comment">//(maxInactiveIntervalInSeconds = 604800)//session超时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpSessionStrategy <span class="title">httpSessionStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> HeaderHttpSessionStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisConnectionFactory connectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line"></span><br><span class="line">        String redisHost = parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> redisPort = Integer.valueOf(parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        connectionFactory.setTimeout(<span class="number">2000</span>);</span><br><span class="line">        connectionFactory.setHostName(redisHost);</span><br><span class="line">        connectionFactory.setPort(redisPort);</span><br><span class="line"><span class="comment">//        connectionFactory.setPassword(parameters.getRedisAuth());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，这样子其实就配置好了，一开始我也云里雾里的，这是啥玩意？</p><p>其实官网的文档中讲的是最准确的。所以还是官网看看吧！</p><p>ok，来spring session的官网(<a href="https://spring.io/projects/spring-session" target="_blank" rel="noopener">https://spring.io/projects/spring-session</a>)来看看把，我们来看看1.3.4GA版本的文档(<a href="https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest</a>).</p><p>spring session可以存在很多介质中，比如我们的数据源，比如redis，甚至是mongodb等。但是我们常用的是存在redis中，结合redis的过期机制来做。</p><p>所以其实我们只要关心如何跟redis整合，以及restful接口。</p><p>我们可以看到一开始文档就告诉我们要配置一下<code>HttpSessionStrategy</code>和存储介质。从<code>HttpSessionStrategy</code>语义就能大致看出配置的是它的策略，是基于<code>header</code>的策略。这个是什么意思，下面会提到。</p><p><img src="http://bloghello.oursnail.cn/mama4-1.png" alt="image"></p><p>那么我们就来看看文档吧！</p><p><img src="http://bloghello.oursnail.cn/mama4-2.png" alt="image"></p><p>好了，我们知道了它的基本原理，下面来看看是如何在restful接口中实现用户session的管理的：</p><p><img src="http://bloghello.oursnail.cn/mama4-3.png" alt="image"></p><p>也就是说要想在restful接口应用中用这种方式，直接告诉spring session:<code>return new HeaderHttpSessionStrategy();</code>即可。进入源码我们就会知道，它默认给这个header里面放置的一条类似于token的名字是<code>private String headerName = &quot;x-auth-token&quot;;</code>。</p><p>那么在用户登陆成功之后，到底存到是什么呢，先来看看响应数据的header里面是什么：</p><p><img src="http://bloghello.oursnail.cn/mama4-4.png" alt="image"></p><p>这一串数字正好可以跟redis中对应上，我们可以先来redis中看看到底在里面存储了啥玩意：</p><p><img src="http://bloghello.oursnail.cn/mama4-5.png" alt="image"></p><p>我们已经看到了想要看到的一串字符串，这里解释一下<code>redis</code>中存储的东西：</p><ul><li><code>spring:session</code>是默认的<code>Redis HttpSession</code>前缀（<code>redis</code>中，我们常用’:’作为分割符）</li><li>每一个<code>session</code>都会有三个相关的<code>key</code>，第一个<code>key</code>(<code>spring:session:sessions:37...</code>)最为重要，它是一个<code>HASH</code>数据结构，将内存中的<code>session</code>信息序列化到了<code>redis</code>中。如本项目中用户信息,还有一些<code>meta</code>信息，如创建时间，最后访问时间等。</li><li>另外两个key，一个是<code>spring:session:expiration</code>，还有一个是<code>spring:session:sessions:expires</code>，前者是一个SET类型，后者是一个STRING类型，可能会有读者发出这样的疑问，redis自身就有过期时间的设置方式TTL，为什么要额外添加两个key来维持session过期的特性呢？redis清除过期key的行为是一个异步行为且是一个低优先级的行为，用文档中的原话来说便是，可能会导致session不被清除。于是引入了专门的expiresKey，来专门负责session的清除，包括我们自己在使用redis时也需要关注这一点。</li></ul><p>这样子，就可以用独立的<code>redis</code>来存储用户的信息，通过前端传来的<code>header</code>里面的<code>token</code>，就可以到<code>redis</code>拿出当前登陆用户的信息了。</p><p>OK，在解决了<code>spring session</code>的问题之后，下面就可以来实现登陆啦：</p><p>controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult <span class="title">login</span><span class="params">(@RequestBody @Valid User user, HttpSession session)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;UserElement&gt; result = <span class="keyword">new</span> ApiResult&lt;&gt;(Constants.RESP_STATUS_OK,<span class="string">"登录成功"</span>);</span><br><span class="line"></span><br><span class="line">    UserElement ue= userService.login(user);</span><br><span class="line">    <span class="keyword">if</span>(ue != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(Constants.REQUEST_USER_SESSION) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            session.setAttribute(Constants.REQUEST_USER_SESSION,ue);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setData(ue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就跟以前一样，将session直接存进去就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserElement <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    UserElement ue = <span class="keyword">null</span>;</span><br><span class="line">    User userExist = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">    <span class="keyword">if</span>(userExist != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//对密码与数据库密码进行校验</span></span><br><span class="line">        <span class="keyword">boolean</span> result = passwordEncoder.matches(user.getPassword(),userExist.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"密码错误"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//校验全部通过，登陆通过</span></span><br><span class="line">            ue = <span class="keyword">new</span> UserElement();</span><br><span class="line">            ue.setUserId(userExist.getId());</span><br><span class="line">            ue.setEmail(userExist.getEmail());</span><br><span class="line">            ue.setNickname(userExist.getNickname());</span><br><span class="line">            ue.setUuid(userExist.getUuid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在单体应用中，我们经常用http session去管理用户信息，但是到了分布式环境下，显然是不行的，因为session对于不同的机器是隔离的，而http本身是无状态的，那么就无法判断出用户在哪一个服务器上登陆的。这个时候就需要有一个独立的地方存储用户session。spring session可以做到无代码侵入的方式实现分布式session存储。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID生成策略</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/05分布式ID生成策略/</id>
    <published>2019-01-23T06:33:29.648Z</published>
    <updated>2019-01-23T06:50:27.571Z</updated>
    
    <content type="html"><![CDATA[<p>分布式环境下如何保证ID的不重复呢？一般我们可能会想到用UUID来实现嘛。但是UUID一般可以获取当前时间的毫秒数再加点随机数，但是在高并发下仍然可能重复。最重要的是，如果我要用这种UUID来生成分表的唯一ID的话，重复不谈，这种随机的字符串对于我们的innodb存储引擎的插入效率是很低的。所以我们生成的ID如果作为主键，最好有两种特性：分布式唯一和有序。</p><a id="more"></a><p>唯一性就不用说了，有序保证了对索引字段的插入的高效性。我们来具体看看<code>ShardingJDBC</code>的分布式ID生成策略是如何保证。</p><h3>snowflake算法</h3><p><img src="http://bloghello.oursnail.cn/mama5-10.png" alt="image"></p><p><code>sharding-jdbc</code>的分布式ID采用<code>twitter</code>开源的<code>snowflake</code>算法，不需要依赖任何第三方组件，这样其扩展性和维护性得到最大的简化；但是<code>snowflake</code>算法的缺陷（<strong>强依赖时间，如果时钟回拨，就会生成重复的ID</strong>）。</p><p>雪花算法是由<code>Twitter</code>公布的分布式主键生成算法，<strong>它能够保证不同进程主键的不重复性，以及相同进程主键的有序性</strong>。</p><p><strong>在同一个进程中</strong>，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。例如MySQL的Innodb存储引擎的主键。</p><p>使用雪花算法生成的主键，二进制表示形式包含4部分，从高位到低位分表为：1bit符号位、41bit时间戳位、10bit工作进程位以及12bit序列号位。</p><p>雪花算法主键的详细结构见下图。</p><p><img src="http://bloghello.oursnail.cn/mama5-1.png" alt="image"></p><ul><li>符号位(1bit)</li></ul><p>预留的符号位，恒为零。</p><ul><li>时间戳位(41bit)</li></ul><p>41位的时间戳可以容纳的毫秒数是2的41次幂，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。通过计算可知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);</span><br></pre></td></tr></table></figure><p>结果约等于69.73年。<code>ShardingSphere</code>的雪花算法的时间纪元从2016年11月1日零点开始，可以使用到2086年，相信能满足绝大部分系统的要求。</p><ul><li>工作进程位(10bit)</li></ul><p>该标志在Java进程内是唯一的，如果是分布式应用部署应保证每个工作进程的id是不同的。该值默认为0，可通过调用静态方法<code>DefaultKeyGenerator.setWorkerId()</code>设置。</p><ul><li>序列号位(12bit)</li></ul><p>该序列是用来在同一个毫秒内生成不同的ID。如果在这个毫秒内生成的数量超过4096(2的12次幂)，那么生成器会等待到下个毫秒继续生成。</p><h2>时钟回拨</h2><p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为0，可通过调用静态方法<code>DefaultKeyGenerator.setMaxTolerateTimeDifferenceMilliseconds()</code>设置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式环境下如何保证ID的不重复呢？一般我们可能会想到用UUID来实现嘛。但是UUID一般可以获取当前时间的毫秒数再加点随机数，但是在高并发下仍然可能重复。最重要的是，如果我要用这种UUID来生成分表的唯一ID的话，重复不谈，这种随机的字符串对于我们的innodb存储引擎的插入效率是很低的。所以我们生成的ID如果作为主键，最好有两种特性：分布式唯一和有序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>springMVC全局异常+spring包扫描包隔离+spring事务传播</title>
    <link href="http://yoursite.com/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
    <id>http://yoursite.com/2019/01/22/miscellany/04springMVC全局异常+spring包扫描包隔离+spring事务传播/</id>
    <published>2019-01-22T13:16:15.370Z</published>
    <updated>2019-01-22T13:58:51.605Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，springMVC全局异常+spring包扫描包隔离+spring事务传播这三个不可能不会遇到。下面来好好说说他们吧。</p><a id="more"></a><h2>1、全局异常引入原因</h2><p>假设在我们的<code>login.do</code>的<code>controller</code>方法中第一行增加一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>重新启动服务器进行用户登录操作，那么就会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    com.swg.controller.portal.UserController.login(UserController.java:<span class="number">37</span>)</span><br><span class="line">    ...其他的堆栈信息</span><br></pre></td></tr></table></figure><p>这些信息会直接显示在网页上，如果是关于数据库的错误，同样，会详细地将数据库中的字段都显示在页面上，这对于我们的项目来说是存在很大的安全隐患的。这个时候，需要用全局异常来处理，如果发生异常，我们就对其进行拦截，并且在页面上显示我们给出的提示信息。</p><h2>2、引入全局异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"exception:&#123;&#125;"</span>,httpServletRequest.getRequestURI(),e);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> MappingJacksonJsonView());</span><br><span class="line">        mv.addObject(<span class="string">"status"</span>,ResponseEnum.ERROR.getCode());</span><br><span class="line">        mv.addObject(<span class="string">"msg"</span>,<span class="string">"接口异常，详情请查看日志中的异常信息"</span>);</span><br><span class="line">        mv.addObject(<span class="string">"data"</span>,e.toString());</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，再执行登陆操作之后，就不会在页面上直接显示异常信息了。有效地屏蔽了关键信息。</p><h2>3、spring和springmvc配置文件的优化</h2><h5>3.1 包隔离优化</h5><p>在编写全局异常之前，先进行了包隔离和优化，一期中的扫描包的写法是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--springmvc:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>即<code>spring</code>和<code>springmvc</code>扫描包下面的所有的<code>bean</code>和<code>controller</code>.优化后的代码配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#spring</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将controller的扫描排除掉--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#springmvc</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg.controller"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加白名单，只扫描controller，总之要将service给排除掉即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做的原因是：<code>Spring</code>和<code>SpringMVC</code>是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题。</p><p><img src="http://bloghello.oursnail.cn/zaji4-1.png" alt="image"></p><p>针对包扫描只要记住以下几点即可：</p><ul><li><code>spring</code>是父容器，<code>springmvc</code>是子容器，子容器可以访问父容器的<code>bean</code>,父容器不能访问子容器的<code>bean</code>。</li><li>只有顶级容器（<code>spring</code>）才有加强的事务能力，而<code>springmvc</code>容器的<code>service</code>是没有的。</li><li>如果<code>springmvc</code>不配置包扫描的话，页面404.</li></ul><h5>3.2 事务的传播机制</h5><p>针对事务，不得不展开说明spring事务的几种传播机制了。在 <code>spring</code> 的 <code>TransactionDefinition</code> 接口中一共定义了七种事务传播属性：</p><ol><li><code>PROPAGATION_REQUIRED</code> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择（默认）。</li><li><code>PROPAGATION_SUPPORTS</code> – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li><code>PROPAGATION_MANDATORY</code> – 支持当前事务，如果当前没有事务，就抛出异常。</li><li><code>PROPAGATION_REQUIRES_NEW</code> – 新建事务，如果当前存在事务，把当前事务挂起。</li><li><code>PROPAGATION_NOT_SUPPORTED</code> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><code>PROPAGATION_NEVER</code> – 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><code>PROPAGATION_NESTED</code> – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与<code>PROPAGATION_REQUIRED</code>类似的操作。</li></ol><h2>4、补充</h2><p><code>Spring</code>默认情况下，会对运行期例外(<code>RunTimeException</code>)，即<code>uncheck</code>异常，进行事务回滚。如果遇到<code>checked</code>异常就不回滚。如何改变默认规则：</p><ul><li>让<code>checked</code>例外也回滚：在整个方法前加上 <code>@Transactional(rollbackFor=Exception.class)</code></li><li>让<code>unchecked</code>例外不回滚： <code>@Transactional(notRollbackFor=RunTimeException.class)</code></li><li>不需要事务管理的(只查询的)方法：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li></ul><h2>5、那么什么是嵌套事务呢？</h2><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫做<code>save point</code>，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点在于那个<code>save point</code>，看以下几个问题：</p><p><strong>问题1：如果子事务回滚，会发生什么？</strong></p><p>父事务会回到进入子事务前建立的<code>save point</code>，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>问题2：如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚，为什么呢？因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理/</p><p><strong>问题3：父事务先提交，然后子事务再提交；还是子事务先提交，然后父事务再提交呢？</strong></p><p>答案是第二种情况，子事务是父事务的一部分，由父事务同意提交。</p><h2>6、spring配置文件的一些理解：</h2><blockquote><p>容器</p></blockquote><p>在<code>Spring</code>整体框架的核心概念中，容器是核心思想，就是用来管理<code>Bean</code>的整个生命周期的，而在一个项目中，容器不一定只有一个，<code>Spring</code>中可以包括多个容器，而且容器有上下层关系，目前最常见的一种场景就是在一个项目中引入<code>Spring</code>和<code>SpringMVC</code>这两个框架，那么它其实就是两个容器，<code>Spring</code>是父容器，<code>SpringMVC</code>是其子容器，并且在<code>Spring</code>父容器中注册的<code>Bean</code>对于<code>SpringMV</code>C容器中是可见的，而在<code>SpringMVC</code>容器中注册的<code>Bean</code>对于<code>Spring</code>父容器中是不可见的，也就是子容器可以看见父容器中的注册的<code>Bean</code>，反之就不行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.springmvc.test"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用统一的如下注解配置来对<code>Bean</code>进行批量注册，而不需要再给每个<code>Bean</code>单独使用<code>xml</code>的方式进行配置。</p><p>从<code>Spring</code>提供的参考手册中我们得知该配置的功能是扫描配置的<code>base-package</code>包下的所有使用了<code>@Component</code>注解的类，并且将它们自动注册到容器中，同时也扫描<code>@Controller</code>，<code>@Service</code>，<code>@Respository</code>这三个注解，因为他们是继承自<code>@Component</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。以下配置会默认声明了<code>@Required</code>、<code>@Autowired</code>、 <code>@PostConstruct</code>、<code>@PersistenceContext</code>、<code>@Resource</code>、<code>@PreDestroy</code>等注解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个是<code>SpringMVC</code>必须要配置的，因为它声明了<code>@RequestMapping</code>、<code>@RequestBody</code>、<code>@ResponseBody</code>等。并且，该配置默认加载很多的参数绑定方法，比如<code>json</code>转换解析器等。</p><h2>7、总结</h2><p>在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的<code>Bean</code>：<code>Spring</code>父容器负责所有其他非<code>@Controller</code>注解的<code>Bean</code>的注册，而<code>SpringMVC</code>只负责<code>@Controller</code>注解的<code>Bean</code>的注册，使得他们各负其责、明确边界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，springMVC全局异常+spring包扫描包隔离+spring事务传播这三个不可能不会遇到。下面来好好说说他们吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>redis实现分布式锁</title>
    <link href="http://yoursite.com/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/01/22/miscellany/03redis实现分布式锁/</id>
    <published>2019-01-22T12:56:51.338Z</published>
    <updated>2019-01-22T14:04:14.345Z</updated>
    
    <content type="html"><![CDATA[<p>为了讲解redis分布式锁，我将引入一个场景：定时关单。因为往往订单服务是一个集群，那么定时器会同时触发这些集群去取消订单，显然是浪费机器资源的，所以目的是：只让其中一台机器去执行取消订单即可。这里可以用分布式锁来实现。</p><a id="more"></a><p>项目是从练手项目中截取出来的，框架是基于<code>SSM</code>的<code>XML</code>形式构成，所以下面还涉及一点<code>XMl</code>对于定时器<code>spring schedule</code>的配置内容。</p><h2>1、引入目标</h2><p>定时自动对超过两个小时还未支付的订单对其进行取消，并且重置库存。</p><h2>2、配置</h2><p>首先是<code>spring</code>配置文件引入<code>spring-schedule</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task"</span><br><span class="line">...</span><br><span class="line">http://www.springframework.org/schema/task</span><br><span class="line">http://www.springframework.org/schema/task/spring-task.xsd</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>补充：针对<code>applicationContext-datasource.xml</code>中的<code>dataSource</code>读取配置文件的信息无法展现的问题，在<code>spring</code>的配置文件中增加一条配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:datasource.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2>3、定时调度代码</h2><p>此代码的主要功能是：定时调用取消订单服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseOrderTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍的时候执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">        <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">        orderService.closeOrder(hour);</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@Component</code>一定要加，否则<code>spring</code>扫描不到。</p></blockquote><blockquote><p><code>close.order.task.time.hour</code> 也是配置在<code>snailmall.properties</code>中的，这里配置的是默认的2，即两个小时，下订单超过两个小时仍然不支付，就取消该订单。</p></blockquote><p>对于<code>orderService</code>里面的具体方法：</p><p>这里是关单的具体逻辑，细节是行锁。这段代码只要知道他是具体关单的逻辑即可，不需要仔细了解代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">    Date closeDateTime = DateUtils.addHours(<span class="keyword">new</span> Date(),-hour);</span><br><span class="line">    <span class="comment">//找到状态为未支付并且下单时间是早于当前检测时间的两个小时的时间,就将其置为取消</span></span><br><span class="line">    <span class="comment">//SELECT &lt;include refid="Base_Column_List"/&gt; from mmall_order WHERE  status = #&#123;status&#125; &lt;![CDATA[ and create_time &lt;= #&#123;date&#125; ]]&gt; order by create_time desc</span></span><br><span class="line">    List&lt;Order&gt; orderList = orderMapper.selectOrderStatusByCreateTime(Const.OrderStatusEnum.NO_PAY.getCode(),DateTimeUtil.dateToStr(closeDateTime));</span><br><span class="line">    <span class="keyword">for</span>(Order order:orderList)&#123;</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo());</span><br><span class="line">        <span class="keyword">for</span>(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">            <span class="comment">//一定要用主键where条件，防止锁表。同时必须是支持MySQL的InnoDB.</span></span><br><span class="line">            Integer stock = productMapper.selectStockByProductId(orderItem.getProductId());</span><br><span class="line">            <span class="keyword">if</span>(stock == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新产品库存</span></span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.setId(orderItem.getProductId());</span><br><span class="line">            product.setStock(stock+orderItem.getQuantity());</span><br><span class="line">            productMapper.updateByPrimaryKeySelective(product);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭order</span></span><br><span class="line">        <span class="comment">//UPDATE mmall_order set status = 0 where id = #&#123;id&#125;</span></span><br><span class="line">        orderMapper.closeOrderByOrderId(order.getId());</span><br><span class="line">        log.info(<span class="string">"关闭订单OrderNo:&#123;&#125;"</span>,order.getOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>debug</code>启动项目，一分钟后就会自动执行<code>closeOrderTaskV1</code>方法了。找一个未支付的订单，进行相应测试。</p><h2>4、存在的问题</h2><p>经过实验发现，同时部署两台<code>tomcat</code>服务器，执行定时任务的时候是两台都同时执行的，显然不符合我们集群的目标，我们只需要在同一时间只有一台服务器执行这个定时任务即可。那么解决方案就是引入<code>redis</code>分布式锁。</p><p><code>redis</code>实现分布式锁，核心命令式<code>setnx</code>命令。所以阅读下面，您需要对<code>redis</code>分布式锁的基本实现原理必须要先有一定的认识才行。</p><h2>5、第一种方案</h2><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V1.png" alt="image"></p><ul><li><p>第一步：<code>setnx</code>进去，如果成功，说明塞入<code>redis</code>成功，抢占到锁</p></li><li><p>第二步：抢到锁之后，先设置一下过期时间，即后面如果执行不到<code>delete</code>，也会将这个锁自动释放掉，防止死锁</p></li><li><p>第三步：关闭订单，删除<code>redis</code>锁</p></li><li><p>存在的问题：如果因为<code>tomcat</code>关闭或<code>tomcat</code>进程在执行<code>closeOrder()</code>方法的时候，即还没来得及设置锁的过期时间的时候，这个时候会造成死锁。需要改进。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个版本，在突然关闭tomcat的时候有可能出现死锁</span></span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="comment">//设置锁，value是用当前时间+timeout进行设置的</span></span><br><span class="line">    <span class="keyword">long</span> timeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>));</span><br><span class="line">    Long setnxResult = RedisShardPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">    <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() ==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//说明被当前的tomcat进程抢到锁，下面就可以关闭订单</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给锁一个过期时间，如果因为某个原因导致下面的锁没有被删除，造成死锁</span></span><br><span class="line">    RedisShardPoolUtil.expire(lockName,<span class="number">50</span>);</span><br><span class="line">    log.info(<span class="string">"获取&#123;&#125;，ThreadName:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">    orderService.closeOrder(hour);</span><br><span class="line">    <span class="comment">//关闭订单之后就立即删除这个锁</span></span><br><span class="line">    RedisShardPoolUtil.del(lockName);</span><br><span class="line">    log.info(<span class="string">"释放&#123;&#125;，ThreadName:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName());</span><br><span class="line">    System.out.println(<span class="string">"============================================="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>6、改进</h2><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V2.png" alt="image"></p><p>图看不清，可以重新打开一个窗口看。具体的逻辑代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="comment">//设置锁，value是用当前时间+timeout进行设置的</span></span><br><span class="line">    <span class="keyword">long</span> timeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>));</span><br><span class="line">    Long setnxResult = RedisShardPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">    <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() ==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//说明被当前的tomcat进程抢到锁，下面就可以关闭订单</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//在没有拿到锁的情况下，也要进行相应的判断，确保不死锁</span></span><br><span class="line">        String lockValueStr = RedisShardPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        <span class="comment">//如果判断锁是存在的并且现在已经超时了，那么我们这个进程就有机会去占有这把锁</span></span><br><span class="line">        <span class="keyword">if</span>(lockValueStr != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr))&#123;</span><br><span class="line">            <span class="comment">//当前进程进行get set操作，拿到老的key，再塞进新的超时时间</span></span><br><span class="line">            String getSetResult = RedisShardPoolUtil.getset(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">            <span class="comment">//如果拿到的是空的，说明老的锁已经释放，那么当前进程有权占有这把锁进行操作；</span></span><br><span class="line">            <span class="comment">//如果拿到的不是空的，说明老的锁仍然占有，并且这次getset拿到的key与上面查询get得到的key一样的话，说明没有被其他进程刷新，那么本进程还是有权占有这把锁进行操作</span></span><br><span class="line">            <span class="keyword">if</span>(getSetResult == <span class="keyword">null</span> || (getSetResult != <span class="keyword">null</span> &amp;&amp; StringUtils.equals(lockValueStr,getSetResult)))&#123;</span><br><span class="line">                closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125;            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样两次的防死锁措施，不仅可以防止死锁，还可以提高效率。</p><h2>7、扩展</h2><h6>mysql四种事务隔离机制</h6><ol><li><code>read uncommitted</code>:读取未提交内容</li></ol><p>两个线程，其中一个线程执行了更新操作，但是没有提交，另一个线程在事务内就会读到该线程未提交的数据。</p><ol start="2"><li><code>read committed</code>:读取提交内容（不可重复读）</li></ol><p>针对第一种情况，一个线程在一个事务内不会读取另一个线程未提交的数据了。但是，读到了另一个线程更新后提交的数据，也就是说重复读表的时候，数据会不一致。显然这种情况也是不合理的，所以叫不可重复读。</p><ol start="3"><li><code>repeatable read</code>:可重复读（默认）</li></ol><p>可重复读，显然解决2中的问题，即一个线程在一个事务内不会再读取到另一个线程提交的数据，保证了该线程在这个事务内的数据的一致性。</p><p>对于某些情况，这种方案会出现幻影读，他对于更新操作是没有任何问题的了，但是对于插入操作，有可能在一个事务内读到新插入的数据（但是MySQL中用多版本并发控制机制解决了这个问题），所以默认使用的就是这个机制，没有任何问题。</p><ol start="4"><li><code>serializable</code>:序列化</li></ol><p>略。</p><h6>存储引擎</h6><p><code>MySQL</code>默认使用的是<code>InnoDB</code>，支持事务。还有例如<code>MyISAM</code>,这种存储引擎不支持事务，只支持只读操作，在用到数据的修改的地方，一般都是用默认的<code>InnoDB</code>存储引擎。</p><h6>索引的一个注意点</h6><p>一般类型为<code>normal</code>和<code>unique</code>，用<code>btree</code>实现，对于联合索引(字段1和字段2)，在执行查询的时候，例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> 字段<span class="number">1</span>=<span class="string">"xxx"</span> ...</span><br></pre></td></tr></table></figure><p>是可以利用到索引的高性能查询的，但是如果是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> 字段<span class="number">2</span>=<span class="string">"xxx"</span> ...</span><br></pre></td></tr></table></figure><p>效率跟普通的查询时一样的，因为用索引进行查询，最左边的那个字段必须要有，否则无效。</p><p>扩展的内容知识顺便提一下，在数据库这一块，会详细介绍一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了讲解redis分布式锁，我将引入一个场景：定时关单。因为往往订单服务是一个集群，那么定时器会同时触发这些集群去取消订单，显然是浪费机器资源的，所以目的是：只让其中一台机器去执行取消订单即可。这里可以用分布式锁来实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Redisson实现Redis分布式锁原理</title>
    <link href="http://yoursite.com/2019/01/22/miscellany/02Redisson%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/01/22/miscellany/02Redisson实现Redis分布式锁/</id>
    <published>2019-01-22T12:01:10.086Z</published>
    <updated>2019-01-22T13:14:53.211Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以自己来实现一个<a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">redis分布式锁</a>，但是如何用Redisson优雅地实现呢？本文探讨一下它的原理。</p><a id="more"></a><p>用<code>Redisson</code>来实现分布式锁异常地简单，形如：</p><p><img src="http://bloghello.oursnail.cn/ziji2-1.png" alt="image"></p><p>还支持<code>redis</code>单实例、<code>redis</code>哨兵、<code>redis cluster</code>、<code>redis master-slave</code>等各种部署架构，都可以给你完美实现。</p><h2>加锁</h2><p>原理图：</p><p><img src="http://bloghello.oursnail.cn/zaji2-2.png" alt="image"></p><p>现在某个客户端要加锁。如果该客户端面对的是一个<code>redis cluster</code>集群，他首先会根据hash节点选择一台机器。紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</p><p><img src="http://bloghello.oursnail.cn/zaji2-3.png" alt="image"></p><p>为啥要用lua脚本呢？因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的<strong>原子性</strong>。</p><p>解释一下这段脚本的意思。</p><p>这里的<code>KEYS[1]</code>代表的是你加锁的那个key的名字。这个key就是我们常看到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"myLock"</span>);</span><br></pre></td></tr></table></figure><p>中的<code>myLock</code>，我就是对这个key进行加锁。</p><p>这里的<code>ARGV[1]</code>代表的就是锁key的默认生存时间，默认30秒。<code>ARGV[2]</code>代表的是加锁的客户端的ID:比如<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code></p><p>第一段if判断语句，就是相当于用<code>exists myLock</code>命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：<code>hset myLock</code>。</p><p>执行完<code>hest</code>之后，设置了一个hash数据结构：<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</code>，这行命令执行后，会出现一个类似下面的数据结构：</p><p><img src="http://bloghello.oursnail.cn/zaji2-4.png" alt="image"></p><p>紧接着会执行<code>pexpire myLock 30000</code>命令，设置myLock这个锁key的生存时间是30秒。好了，到此为止，ok，加锁完成了。</p><h2>锁互斥</h2><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？很简单，第一个if判断会执行<code>exists myLock</code>，发现myLock这个锁key已经存在了。接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p><p>所以这个客户端2两个if都不能进入，只能执行最后的<code>pttl myLock</code>，返回值代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p><h2>watch dog自动延期机制</h2><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个<code>watch dog</code>看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><h2>可重入加锁机制</h2><p>看一下代码，相同的客户进来，会进入第二个if，会执行<code>hincrby</code>，即增1，那么这个hash结构就会变成：</p><p><img src="http://bloghello.oursnail.cn/zaji2-5.png" alt="image"></p><h2>释放锁</h2><p>如果执行<code>lock.unlock()</code>，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：<code>del myLock</code>命令，从redis里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。</p><p>这就是所谓的分布式锁的开源Redisson框架的实现机制。</p><h2>存在的问题</h2><p>其实上面那种方案最大的问题，就是如果你对某个<code>redis master</code>实例，写入了myLock这种锁key的value，此时会异步复制给对应的<code>master slave</code>实例。</p><p>但是复制的这个过程中一旦发生<code>redis master</code>宕机，主备切换，<code>redis slave</code>变为了<code>redis master</code>。</p><p>假设客户端1在<code>redis master</code>上获得锁，然后主机宕机，<code>redis slave</code>成为新的<code>redis master</code>，但是还未同步到<code>redis slave</code>上，但是客户端1已经觉得自己获取到了锁。</p><p>此时，客户端2来尝试加锁的时候，在新的<code>redis master</code>上完成了加锁，此时就会发生多个客户端完成对一个key的加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</p><p>所以这个就是<code>redis cluster</code>，或者是<code>redis master-slave</code>架构的主从异步复制导致的redis分布式锁的最大缺陷：在<code>redis master</code>实例宕机的时候，可能导致多个客户端同时完成加锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们可以自己来实现一个&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;redis分布式锁&lt;/a&gt;，但是如何用Redisson优雅地实现呢？本文探讨一下它的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>spring事务的传播行为</title>
    <link href="http://yoursite.com/2019/01/22/miscellany/01%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/"/>
    <id>http://yoursite.com/2019/01/22/miscellany/01事务的传播行为/</id>
    <published>2019-01-22T12:01:09.977Z</published>
    <updated>2019-01-23T06:23:33.211Z</updated>
    
    <content type="html"><![CDATA[<p>经常听到别人说事务传播行为，那到底什么是事务的传播行为呢？</p><a id="more"></a><h2>1.什么是事务？</h2><p>在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。</p><p>这里注意，其实事务就是数据库才能保证的，所以抛开数据库层面来谈事务本身就是不存在的，所以事务的概念就是数据库一系列操作的一个完整单元。</p><h2>2.什么是ACID？</h2><p>ACID是指数据库管理系统在写入或更新资料的过程中，为保证事务是正确可靠的，所必须具备的四个特性：原子性、一致性、隔离性、持久性。</p><ul><li><p><code>Atomicity</code>：一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><code>Consistency</code>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p></li><li><p><code>Isolation</code>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔<br>离分为不同级别，包括读未提交(<code>Read uncommitted</code>)、读提交(<code>read committed</code>)、可重复读(<code>repeatable read</code>)和串行化(<code>Serializable</code>)。</p></li><li><p><code>Durability</code>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h2>3.spring事务传播行为</h2><p>在我们用SSM开发项目的时候，我们一般都是将事务设置在<code>Service</code>层 那么当我们调用<code>Service</code>层的一个方法的时候它能够保证我们的这个方法中执行的所有的对数据库的更新操作保持在一个事务中，在事务层里面调用的这些方法要么全部成功，要么全部失败。那么事务的传播特性也是从这里说起的。</p><div class="tip"><重点1> 如果你在你的`Service`层的这个方法中，除了调用了`Dao`层的方法之外，还调用了本类的其他的`Service`方法，那么在调用其他的`Service`方法的时候，这个事务是怎么规定的呢，我必须保证我在我方法里调用的这个方法与我本身的方法处在同一个事务中，否则如果保证事物的一致性。事务的传播特性就是解决这个问题的.</重点1></div><p>在Spring中有针对传播特性的多种配置我们大多数情况下只用其中的一种:<code>PROPGATION_REQUIRED</code>：这个配置项的意思是说当我调用<code>service</code>层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个<code>service</code>层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务。这个工作使由Spring来帮助我们完成的。</p><div class="tip"><重点2> 默认情况下当发生`RuntimeException`的情况下，事务才会回滚，所以要注意一下：如果你在程序发生错误的情况下，有自己的异常处理机制定义自己的`Exception`，必须从`RuntimeException`类继承，这样事务才会回滚！</重点2></div><h2>4.事务隔离级别</h2><ul><li>1、<code>Serializable</code>：最严格的级别，事务串行执行，资源消耗最大；</li><li>2、<code>REPEATABLE READ</code>：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。</li><li>3、<code>READ COMMITTED</code>:大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。</li><li>4、<code>Read Uncommitted</code>：保证了读取过程中不会读取到非法数据。</li></ul><h2>5.总结</h2><p>本文的重点是在于理解事务的传播行为这个概念，从事务的概念，到事务的ACID介绍，引出事务传播传播行为和隔离级别这两个概念加以理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常听到别人说事务传播行为，那到底什么是事务的传播行为呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://yoursite.com/2019/01/22/java-collection/12.ConcurrentHashMap/"/>
    <id>http://yoursite.com/2019/01/22/java-collection/12.ConcurrentHashMap/</id>
    <published>2019-01-22T09:49:11.237Z</published>
    <updated>2019-01-22T11:40:00.121Z</updated>
    
    <content type="html"><![CDATA[<p>对于并发场景下，推荐使用线程安全的 concurrentHashMap ，而不是 HashMap 或者是 HashTable .concurrentHashMap在JDK7和JDK8中的实现原理是不一样的。本文分别对其核心思想和方法进行阐述。</p><a id="more"></a><h2>一、JDK7实现</h2><p><code>ConcurrentHashMap</code> 的内部细分了若干个小的 <code>HashMap</code> ，称之为段（ <code>SEGMENT</code> ）。 <code>ConcurrentHashMap</code> 是一个 <code>Segment</code> 数组，<code>Segment</code> 通过继承 <code>ReentrantLock</code> 来进行加锁，所以每次需要加锁的操作锁住的是一个 <code>segment</code> ，这样只要保证每个 <code>Segment</code> 是线程安全的，也就实现了全局的线程安全。</p><p><img src="http://bloghello.oursnail.cn/ConcurrentHashMap7.png" alt="image"></p><p>如图所示，是由 <code>Segment</code> 数组、<code>HashEntry</code> 数组组成，和 <code>HashMap</code> 一样，仍然是数组加链表组成。</p><p><code>ConcurrentHashMap</code> 采用了分段锁技术，其中 <code>Segment</code> 继承于 <code>ReentrantLock</code>。不会像 <code>HashTable</code> 那样不管是 <code>put</code> 还是 <code>get</code> 操作都需要做同步处理，理论上 <code>ConcurrentHashMap</code> 支持 <code>CurrencyLevel</code> ( <code>Segment</code> 数组数量)的线程并发。每当一个线程占用锁访问一个 <code>Segment</code> 时，不会影响到其他的 <code>Segment</code>。</p><h5>1.1 get方法</h5><p><code>ConcurrentHashMap</code> 的 <code>get</code> 方法是非常高效的，因为<strong>整个过程都不需要加锁</strong>。</p><p>只需要将 <code>Key</code> 通过 <code>Hash</code> 之后定位到具体的 <code>Segment</code> ，再通过一次 <code>Hash</code> 定位到具体的元素上。由于 <code>HashEntry</code> 中的 <code>value</code> 属性是用 <code>volatile</code> 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值.</p><p>内部 <code>HashEntry</code> 类 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>1.2 put方法</h5><p>虽然 <code>HashEntry</code> 中的 <code>value</code> 是用 <code>volatile</code> 关键词修饰的，但是并不能保证并发的原子性，所以 <code>put</code> 操作时仍然<strong>需要加锁处理</strong>。</p><p>首先也是通过 <code>Key</code> 的 <code>Hash</code> 定位到具体的 <code>Segment</code>，在 <code>put</code> 之前会进行一次扩容校验。这里比 <code>HashMap</code> 要好的一点是：<code>HashMap</code> 是插入元素之后再看是否需要扩容，有可能扩容之后后续就没有插入就浪费了本次扩容(扩容非常消耗性能)。</p><p><strong>而 <code>ConcurrentHashMap</code> 不一样，它是在将数据插入之前检查是否需要扩容，之后再做插入操作。</strong></p><h5>1.3 size方法</h5><p>每个 <code>Segment</code> 都有一个 <code>volatile</code> 修饰的全局变量 <code>count</code> ,求整个 <code>ConcurrentHashMap</code> 的 size 时很明显就是将所有的 <code>count</code> 累加即可。但是 <code>volatile</code> 修饰的变量却不能保证多线程的原子性，所有直接累加很容易出现并发问题。</p><p>但如果每次调用 <code>size</code> 方法将其余的修改操作加锁效率也很低。所以做法是先尝试两次将 <code>count</code> 累加，如果容器的 <code>count</code> 发生了变化再加锁来统计 <code>size</code>。</p><p>在 <code>JDK7</code> 中，<strong>第一种方案</strong>他会使用不加锁的模式去尝试多次计算 <code>ConcurrentHashMap</code> 的 <code>size</code>，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。</p><p><strong>第二种方案</strong>是如果第一种方案不符合，他就会给每个 <code>Segment</code> 加上锁，然后计算 <code>ConcurrentHashMap</code> 的 <code>size</code> 返回。其源码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line"> <span class="keyword">int</span> size;</span><br><span class="line"> <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line"> <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line"> <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line"> <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0L</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    overflow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += seg.modCount;</span><br><span class="line">            <span class="keyword">int</span> c = seg.count;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">            overflow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == last)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        last = sum; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2>二、JDK8实现</h2><p><img src="http://bloghello.oursnail.cn/ConcurrentHashMap8.png" alt="image"></p><p><code>jdk8</code> 中的 <code>ConcurrentHashMap</code> 数据结构和实现与 <code>jdk7</code> 还是有着明显的差异。</p><p>其中抛弃了原有的 <code>Segment</code> 分段锁，而采用了 <code>CAS</code> + <code>synchronized</code> 来保证并发安全性。</p><p>也将 <code>jdk7</code> 中存放数据的 <code>HashEntry</code> 改为 <code>Node</code>，但作用都是相同的。</p><p><img src="http://bloghello.oursnail.cn/collection12-2.jpg" alt="image"></p><p>其中的 <code>val</code> <code>next</code> 都用了 <code>volatile</code> 修饰，保证了可见性。</p><h2>2.1 put方法</h2><p>重点来看看 <code>put</code> 函数：</p><p><img src="http://bloghello.oursnail.cn/collection12-3.jpg" alt="image"></p><ul><li>根据 <code>key</code> 计算出 <code>hashcode</code> 。</li><li>判断是否需要进行初始化。</li><li><code>f</code> 即为当前 <code>key</code> 定位出的 <code>Node</code>，<strong>如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入</strong>，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足(不需要初始化、Node不为空、不需要扩容)，则<strong>利用 <code>synchronized</code> 锁写入数据</strong>。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h2>2.2 get方法</h2><ul><li>根据计算出来的 <code>hashcode</code> 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>都不满足那就按照链表的方式遍历获取值。</li></ul><h2>2.3 size方法</h2><p><code>JDK8</code> 实现相比 <code>JDK7</code> 简单很多，只有一种方案，我们直接看 <code>size()</code> 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">                (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (<span class="keyword">int</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CounterCell[] as = counterCells; </span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//获取baseCount值</span></span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="comment">//遍历CounterCell数组全部加到baseCount上，它们的和就是size</span></span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可能你会有所疑问，<code>ConcurrentHashMap</code> 中的 <code>baseCount</code> 属性不就是记录的所有键值对的总数吗？直接返回它不就行了吗？</p><p>之所以没有这么做，是因为我们的 <code>addCount</code> 方法用于 <code>CAS</code> 更新 <code>baseCount</code>，但很有可能在高并发的情况下，更新失败，那么这些节点虽然已经被添加到哈希表中了，但是数量却没有被统计。</p><p><strong>还好，<code>addCount</code> 方法在更新 <code>baseCount</code> 失败的时候，会调用 <code>fullAddCount</code> 将这些失败的结点包装成一个 <code>CounterCell</code> 对象，保存在 <code>CounterCell</code> 数组中。那么整张表实际的 <code>size</code> 其实是 <code>baseCount</code> 加上 <code>CounterCell</code>数组中元素的个数。</strong></p><h2>三、总结</h2><ul><li>并发情况下请使用<code>concurrentHashMap</code></li><li>在<code>jdk7</code>中，用的是分段锁，默认是12段，那么并发量最多也就12.<ul><li><code>get</code>不加锁，第一次<code>hash</code>定位到<code>segment</code>，第二次<code>hash</code>定位到元素，元素值是用<code>volatile</code>保证内存可见性</li><li><code>put</code>需要加锁，<code>hash</code>定位到<code>segment</code>后，先检查是否需要扩容再插入。</li><li><code>size</code>先使用不加锁的模式去尝试多次计算<code>size</code>，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入；如果不一致，给每个 <code>Segment</code> 加上锁再依次去计算个数</li></ul></li><li>在<code>jdk8</code>中，采用了 <code>CAS</code> + <code>synchronized</code> 来保证并发安全性<ul><li><code>put</code>的过程比较复杂，简单来说是：先计算<code>hash</code>定位到<code>node</code>—》判断是否初始化—》如果<code>node</code>为空则表示可以插入，用<code>cas</code>插入—》判断是否需要扩容—》如果不需要初始化、<code>Node</code>不为空、不需要扩容，则利用 <code>synchronized</code> 锁写入数据—》判断是否需要转换为红黑树</li><li><code>get</code>就比较简单，直接根据<code>hash</code>定位到<code>node</code>，然后以链表或者红黑树的方式拿到</li><li><code>size</code>方法就一种方案：<code>baseCount</code>+<code>CounterCell[]中所有元素</code></li></ul></li></ul><p>整理自：</p><ul><li><a href="https://crossoverjie.top/JCSprout/#/thread/ConcurrentHashMap?id=size-%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">https://crossoverjie.top/JCSprout/#/thread/ConcurrentHashMap?id=size-方法</a></li><li><a href="https://www.jianshu.com/p/e99e3fcface4" target="_blank" rel="noopener">https://www.jianshu.com/p/e99e3fcface4</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于并发场景下，推荐使用线程安全的 concurrentHashMap ，而不是 HashMap 或者是 HashTable .concurrentHashMap在JDK7和JDK8中的实现原理是不一样的。本文分别对其核心思想和方法进行阐述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java容器" scheme="http://yoursite.com/tags/java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap死循环问题</title>
    <link href="http://yoursite.com/2019/01/21/java-collection/11.HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/21/java-collection/11.HashMap死循环问题/</id>
    <published>2019-01-21T14:25:51.037Z</published>
    <updated>2019-01-22T06:43:45.198Z</updated>
    
    <content type="html"><![CDATA[<p>JDK1.7或者更老的版本中在多线程情况下是会存在死循环问题，究其原因是put过程中的resize方法在调用transfer方法的时候导致的死锁。这次我们来看看到底是哪里出了问题！</p><a id="more"></a><h2>核心源码</h2><p>在JDK8中，内部已经调整，解决了死循环问题，是如何解决的呢？将JDK7中头插入法改为末端插入。就是这么简单。关于这个，可以查看jdk8源码中的<code>resize</code>方法。</p><p>上面提到是由于<code>put</code>时出现问题，那么先来到<code>put()</code>中看看：</p><p><img src="http://bloghello.oursnail.cn/collection11-1.png" alt="image"></p><p>我们看到，put一个不存在的新元素，必然增加一个节点，我们进入这个增加节点的方法：</p><p><img src="http://bloghello.oursnail.cn/collection11-2.png" alt="image"></p><p>检查是否需要扩容，需要的话就<code>resize</code>:</p><p><img src="http://bloghello.oursnail.cn/collection11-3.png" alt="image"></p><p>下面就是对链表数据进行迁移：</p><p><img src="http://bloghello.oursnail.cn/collection11-4.png" alt="image"></p><p>核心的代码就是这么多，首先要强调一下：<strong>两个线程进来，是分别建立了两个独立的扩容后的数组</strong>，比如这里是两个长度为4的数组。老的数组为2个数就是唯一的。所以在第一步，线程2运行结束时，老的数组元素已经空了。</p><p>下面先演示一下正常的<code>rehash</code>过程。</p><h2>正常情况</h2><p><img src="http://bloghello.oursnail.cn/collection11-5.png" alt="image"></p><ul><li>假设了我们的<code>hash</code>算法就是简单的用 key mod 一下数组(hash表)的大小</li><li>最上面的是<code>old hash</code> 表，其中的<code>Hash</code>表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在<code>table[1]</code>这里了。</li><li>接下来的三个步骤是<code>Hash</code>表 <code>resize</code> 成4，然后所有的 <code>&lt;key,value&gt;</code> 重新 <code>rehash</code> 的过程</li></ul><p>注意到，在JDK7中，是按照头插入法依次插入的。所以7插到了3前面。</p><h2>并发情况</h2><h5>1.初始情况</h5><p>假设我们有两个线程。我用红色和浅蓝色标注了一下。</p><p>对于第一个线程先执行完这一行，然后挂起，此时 <code>e</code> 和 <code>next</code> 都附好值了：</p><p><img src="http://bloghello.oursnail.cn/collection11-6.png" alt="image"></p><p>而让线程二执行完成。于是我们有下面的这个样子：</p><p><img src="http://bloghello.oursnail.cn/collection11-7.png" alt="image"></p><p>因为<code>Thread1</code>的 <code>e</code> 指向了 <code>key(3)</code> ，而 <code>next</code> 指向了 <code>key(7)</code> ，其在 <code>Thread2</code>  <code>rehash</code>后，指向了 <code>Thread2</code> 重组后的链表。</p><h5>2.Thread1被调度回来执行</h5><ul><li>先是执行 <code>newTalbe[i] = e</code> ：此时线程1的第三个位置就是指向元素3;</li><li>然后是 <code>e = next</code>，导致了 <code>e</code> 指向了 <code>key(7)</code> ;</li><li>而下一次循环的 <code>next = e.next</code> 导致了 <code>next</code> 指向了 <code>key(3)</code> ;</li></ul><p><img src="http://bloghello.oursnail.cn/collection11-8.png" alt="image"></p><h2>3.一切安好</h2><p>线程一接着工作。把 <code>key(7)</code> 摘下来，放到 <code>newTable[i]</code> 的第一个，然后把 <code>e</code> 和 <code>next</code> 往下移。</p><p><img src="http://bloghello.oursnail.cn/collection11-9.png" alt="image"></p><h5>4.环形链接出现</h5><p><code>e.next = newTable[i]</code> 导致  <code>key(3).next</code> 指向了 <code>key(7)</code></p><p>注意：此时的 <code>key(7).next</code> 已经指向了 <code>key(3)</code>， 环形链表就这样出现了。</p><p><img src="http://bloghello.oursnail.cn/collection11-10.png" alt="image"></p><h2>自己的简单整理</h2><p>这里还是比较绕的，理解的最好方式左边放源码，右边放图，中间用草稿纸画一画。</p><p>那么，这里我在对其过程尽可能地讲明白一点。我们先确定7和3会全部落到扩容后的下标为3的位置(3%4=3,7%4=3)。</p><p>规定线程1开辟的数组为 <code>arr1</code> ，线程2开辟的数组为 <code>arr2</code>;</p><h5>1. 初始状态</h5><ul><li>线程一： e -&gt; key3 , next -&gt; key7</li><li>线程二： 数组3号位置 arr2[3] -&gt; key7 -&gt; key3</li></ul><p>注意此时 <code>key7</code> 指向 <code>key3</code> .</p><p>我们要明确一下，发生死循环，是指在<code>put</code>操作完毕之后，最终生成的数组中有死循环引用才行，千万不要一开始看线程一种key3指向key7，然后线程二种key7指向key3就是死循环了。。。</p><h5>2. 线程一继续执行</h5><p><img src="http://bloghello.oursnail.cn/collection11-6.png" alt="image"></p><ul><li>i = 3</li><li>e.next = key7,此时 e=key3 ,所以是 key3.next = key7（这是线程1的初始状态决定的）</li><li>arr1[3] 指向 key3</li><li>e 为 key7</li></ul><h5>3.由于e不为空，所以还会循环：</h5><ul><li>上一步 e 为 key7，所以 next = key7.next ，到线程2中一看是 key3 ，所以 next = key3（线程2中key7.next就是key3）</li><li>i = 3</li><li>e.next = key3------<strong>注意，这里就是Key7指向了key3,key7的next引用下面没有变过，所以这里做一下记录，即key7指向key3</strong></li><li>newTable[3] = key7</li><li>e = key3</li></ul><h5>4.由于e不为空，所以还会循环：</h5><ul><li>上一步 e=key3 , next=null</li><li>i=3</li><li>key3.next = key7，注意,由于key7已经指向了key3，<strong>此时key3又指向key7</strong>,发生死循环</li><li>newTable[3] = key3</li><li>e = null</li></ul><h5>5.e为null，跳出循环。</h5><p>此时发现key3又指向了key7。发生死循环。</p><p>整理自:<a href="https://coolshell.cn/articles/9606.html/comment-page-2#comments" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html/comment-page-2#comments</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK1.7或者更老的版本中在多线程情况下是会存在死循环问题，究其原因是put过程中的resize方法在调用transfer方法的时候导致的死锁。这次我们来看看到底是哪里出了问题！&lt;/p&gt;
    
    </summary>
    
    
      <category term="java容器" scheme="http://yoursite.com/tags/java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux重要的一些命令</title>
    <link href="http://yoursite.com/2019/01/21/linux%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/01/21/linux重要的命令/</id>
    <published>2019-01-21T12:16:48.954Z</published>
    <updated>2019-01-21T09:09:02.036Z</updated>
    
    <content type="html"><![CDATA[<p>很多命令之所以重要，是因为用它们会大幅提高工作效率。所以，熟悉它们是我们必须要做的一件事情。下面着重提取了find、grep、管道、wc、awk以及sed等几个命令来看看如何使用。</p><a id="more"></a><h2>一、Linux体系结构</h2><div align="center">    <img src="http://bloghello.oursnail.cn/linux1-1.png" style="width:300px;"></div><p>对这幅图进行详细说明一下。</p><ul><li>体系结构主要分为<strong>用户态</strong>(用户上层活动)和<strong>内核态</strong></li><li><strong>内核：本质是一段管理计算机硬件设备的程序</strong>，这个程序直接管理硬件：包括CPU、内存空间、硬盘接口、网络接口等。所有的计算机操作都要通过内核来操作。</li><li>系统调用：内核的访问接口，<strong>是一种不能再简化的操作</strong>(可以认为系统调用已经是最小的原子操作，上层完成一个功能要依托于若干系统调用才能完成)</li><li>由于系统调用比较基础，要完成一个功能需要很多系统调用组合才能实现，对于程序员来说比较复杂。这个时候怎么办呢？<strong>我们可以调用公共函数库：系统调用的组合拳。简化程序员操作</strong>。</li><li><code>Shell</code>也是一种特殊的应用程序，是一个命令解释器，可以编程。</li><li><code>Shell</code>下通系统调用，上通各种应用，是上层和下层之间粘合的胶水，让不同程序可以偕同工作。</li><li>在没有图形界面之前，用户通过<code>shell</code>命令行或者可编程的<code>shell</code>脚本可以完成很多事情。</li></ul><h2>二、如何根据文件名检索文件</h2><ul><li>find</li><li>在指定目录下查找文件</li></ul><blockquote><p>语法 find path [options] params</p></blockquote><h3>2.1 精确查找文件</h3><p>比如我在当前目录(可能在子目录下)下找一个文件叫做<code>test.java</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name "test.java"</span><br></pre></td></tr></table></figure><p>这个指令就可以在本目录以及子目录下递归查找这个文件了。</p><p>实例：精确查询名字叫<code>snailmall-api-gateway-8080.jar</code>这个文件：</p><p><img src="http://bloghello.oursnail.cn/linux1-4.png" alt="image"></p><h3>2.2 全局搜索</h3><p>如果是全局查找，也很简单，无非是从根目录开始递归查找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name "test.java"</span><br></pre></td></tr></table></figure><p>实例：我对这台服务器全局查找文件名以<code>snailmall</code>开头的所有文件：</p><p><img src="http://bloghello.oursnail.cn/linux1-3.png" alt="image"></p><h3>2.3 模糊查询</h3><p>如果找以test打头的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name "test*"</span><br></pre></td></tr></table></figure><p>即用 <code>*</code> 通配符就可以模糊查询到以 <code>test</code> 打头的文件。</p><p>实例，我的这台服务器上部署了几个关于商城的服务，这个目录下我放了jar包和相应的启动信息文件。我对其进行模糊查询：</p><p><img src="http://bloghello.oursnail.cn/linux1-2.png" alt="image"></p><h3>2.4 忽略大小写</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -iname "test*"</span><br></pre></td></tr></table></figure><h2>三、如何根据文件内的内容进行检索</h2><h3>3.1 grep命令</h3><ul><li>grep</li><li>查找文件里符合条件的字符串</li></ul><blockquote><p>语法：grep [options] pattern file</p></blockquote><p>比如 <code>test.java</code> 中有一句话是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"i love java"</span>);</span><br></pre></td></tr></table></figure><p>那么如何查找 <code>test.java</code> 中的 <code>java</code> 呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "java" test*</span><br></pre></td></tr></table></figure><p>这句话意思就是查找以 <code>test</code> 打头的文件中的包含 <code>java</code> 字符串所在的行。</p><p>直接输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "hello"</span><br></pre></td></tr></table></figure><p>会等待用户输入文本。然后再对输入的内容进行检索。</p><h3>3.2 管道操作符 |</h3><blockquote><p>可将指令连接起来，前一个指令的输出作为后一个指令的输入。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / | grep "test"</span><br></pre></td></tr></table></figure><p>作用同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name "test"</span><br></pre></td></tr></table></figure><div class="tip"><p>注意：</p><p>只有前一个指令正确才会再处理。</p><p>管道右边命令必须能接收标准输入流，否则传递过程中数据会被抛弃</p></div><h3>3.3 grep结合管道</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'xxx' hello.info</span><br></pre></td></tr></table></figure><p>可以将 <code>xxx</code> 所在的行全部筛选出来，但是还是特别多，我比如关心这每一行中某个字段的信息，比如是 <code>param[xx12]</code>这种信息。如何实现筛选呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'xxx' hello.info | grep -o 'param\[[0-9a-z]*\]'</span><br></pre></td></tr></table></figure><p>这样就只把类似于 <code>param[xx12]</code> 这样的信息清晰地展现出来。</p><p>如何过滤掉不要的信息呢？可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v</span><br></pre></td></tr></table></figure><p>比如我们查询 <code>tomcat</code> 进程信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br></pre></td></tr></table></figure><p>我们会发现，不仅 <code>tomcat</code> 的信息展现出来了，执行 <code>grep</code> 命令本身的进程信息也展示出来了。我们要将这个 <code>grep</code> 命令过滤掉，只展现 <code>tomcat</code> 进程信息，可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat | grep -v "grep"</span><br></pre></td></tr></table></figure><p>这样就把 <code>grep</code> 进程信息过滤掉了。</p><h2>四、如何对文件内容做统计</h2><ul><li>awk</li><li>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分</li><li>将切片直接保存再内建的变量中，$1$2…($0表示行的全部)</li><li>支持对单个切片的判断，支持循环判断，<strong>默认分隔符为空格</strong></li></ul><blockquote><p>语法：awk [options] ‘cmd’ file</p></blockquote><p>有这样一个文件text1.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proto   Recv-Q   Send-Q    Local Address     Foreign Address      state</span><br><span class="line">tcp     0        48        111.34.134.2:ssh  124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     0        48        localhost:mysql   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     0        48        111.34.13.2:s0    124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     0        48        localhost:mysql   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     1        48        localhots:webcac  124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     1        48        111.34.134.2:s1   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     1        48        111.34.134.2:s2   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     0        48        111.34.134.2:s3   124.213.2.12:12565   ESTABLISHED</span><br></pre></td></tr></table></figure><p>列出切分出来的第一列和第二列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1,$2&#125;' test1.txt</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://bloghello.oursnail.cn/linux1-7.png" alt="image"></p><p>筛选出第一列为<code>tcp</code>和第二列为<code>1</code>的所在行，将这些行数据全部打印出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '$1="tcp" &amp;&amp; $2==1&#123;print $0&#125;' test1.txt</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://bloghello.oursnail.cn/linux1-8.png" alt="image"></p><p>打印带有表头的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '($1="tcp" &amp;&amp; $2==1) || NR==1 &#123;print $0&#125;' test1.txt</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-9.png" alt="image"></p><p>默认是以空格分隔，那么以逗号或者其他符号可以吗？答案当然是可以。对于这样的文件text2.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adas,123</span><br><span class="line">wqe,544</span><br><span class="line">12321,dddf</span><br><span class="line">sdaasd,1235</span><br><span class="line">465547,fjigj</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F "," '&#123;print $2&#125;' text2.txt</span><br></pre></td></tr></table></figure><h2>五、WC统计</h2><p>有一个文件test2.txt，里面的内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swg123eh shwf</span><br><span class="line">shsfswg7 121 32n dswg17328 123swg1 2h1jhw</span><br><span class="line">jqbsjwqbsh ddddh wg ehdedhd  dhsjh</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-10.png" alt="image"></p><h2>六、sed命令</h2><p>sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作</p><blockquote><p>sed [-n/e/f/r/i] ‘command’ 输入文本</p></blockquote><p>常用选项：</p><ul><li>-n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</li><li>-e∶直接在指令列模式上进行 sed 的动作编辑；</li><li>-f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；</li><li>-r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)</li><li>-i∶<strong>直接修改读取的档案内容，而不是由萤幕输出</strong>。</li></ul><p>常用命令：</p><ul><li>a   ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c   ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d   ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i   ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p  ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～</li><li>s  ∶<strong>取代</strong>，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><p>这里我就主要看一下批量替换这个功能。</p><p>如果只是给一个文件中的若干字符串批量替换，只需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i "s/oldstring/newstring/g" filename</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-12.png" alt="image"></p><p>如果是对某一路径下很多的文件批量替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/oldstring/newstring/g&quot; `grep oldstring -rl path`</span><br></pre></td></tr></table></figure><p>其中，<code>oldstring</code>是待被替换的字符串，<code>newstring</code>是待替换<code>oldstring</code>的新字符串，<code>grep</code>操作主要是按照所给的路径查找<code>oldstring</code>，<code>path</code>是所替换文件的路径；</p><ul><li><strong>-i选项是直接在文件中替换，不在终端输出</strong>；</li><li><strong>-r选项是所给的path中的目录递归查找</strong>；</li><li><strong>-l选项是输出所有匹配到oldstring的文件</strong>；</li></ul><p>这里只是模拟一下，将目录下的所有文件进行批量修改：</p><p><img src="http://bloghello.oursnail.cn/linux1-13.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多命令之所以重要，是因为用它们会大幅提高工作效率。所以，熟悉它们是我们必须要做的一件事情。下面着重提取了find、grep、管道、wc、awk以及sed等几个命令来看看如何使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>站点文章汇总</title>
    <link href="http://yoursite.com/2019/01/21/%E7%AB%99%E7%82%B9%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2019/01/21/站点文章汇总/</id>
    <published>2019-01-21T11:53:05.000Z</published>
    <updated>2019-01-23T07:21:24.030Z</updated>
    
    <content type="html"><![CDATA[<p>☝️☝️☝️🔝🔝🔝本文为置顶文章，为了方便管理和查阅，在这里详细展示目录索引，看完索引，你就知道本站的大体内容啦！我相信一定会给小伙伴们一些收获！</p><a id="more"></a><h2>计算机网络🐭🐭🐭</h2><p>这一部分主要是关于<code>HTTP</code>和<code>TCP</code>的必备知识。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">《计算机网络相关系列》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/1.%E4%BB%8E%E4%B8%8B%E5%88%B0%E4%B8%8A%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">《从下到上看五层模型》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/2.%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">《从上到下看五层模型》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/3.http%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" target="_blank" rel="noopener">《HTTP的前世今生》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/4.TCP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">《TCP协议入门》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/5.TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" target="_blank" rel="noopener">《TCP三次握手和四次挥手》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/6.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8F%90%E7%82%BC/" target="_blank" rel="noopener">《HTTP基础知识提炼》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/7.%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3HTTPS/" target="_blank" rel="noopener">《一步一步理解HTTPS》</a></li></ul></li></ul><h2>JAVA容器🐱🐱🐱</h2><p>这一部分是<code>JAVA</code>容器一系列文章，主要讲了常用<code>JAVA</code>容器的源码和一些特性，面试必问点。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/java%E5%AE%B9%E5%99%A8/" target="_blank" rel="noopener">《JAVA容器》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/1.ArrayList%E5%92%8CVector/" target="_blank" rel="noopener">《ArrayList/Vector》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/2.LinkedList/" target="_blank" rel="noopener">《LinkedList》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/3.CopyOnWriteArrayList/" target="_blank" rel="noopener">《CopyOnWriteArrayList》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/4.hashcode%E5%92%8Cequals/" target="_blank" rel="noopener">《HashCode/Equals》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/5.HashMap/" target="_blank" rel="noopener">《HashMap》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/6.HashSet/" target="_blank" rel="noopener">《HashSet》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/7.LinkedHashMap/" target="_blank" rel="noopener">《LinkedHashMap》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">《HashMap和LinkedHashMap遍历机制》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/9.HashTable/" target="_blank" rel="noopener">《HashTable》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/10.LinkedHashSet/" target="_blank" rel="noopener">《LinkedHashSet》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/21/java-collection/11.HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《JDK7中HashMap死循环原因剖析》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/java-collection/12.ConcurrentHashMap/" target="_blank" rel="noopener">《ConcurrentHashMap》</a></li></ul></li></ul><h2>Linux&amp;操作系统🐶🐶🐶</h2><p>一些必备的<code>Liunx</code>相关的知识点整理。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/Linux/" target="_blank" rel="noopener">《Linux》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/21/linux%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4/" target="_blank" rel="noopener">《Linux面试重要命令》</a></li></ul></li><li><a href="http://fourcolor.oursnail.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">《操作系统相关》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">《面试-进程与线程》</a></li></ul></li></ul><h2>JAVA虚拟机相关🐹🐹🐹</h2><p>主要是介绍JVM相关知识。轻松以应付面试。</p><h2>JAVA核心基础知识🐺🐺🐺</h2><p>主要是介绍比较核心的JAVA基础知识，属于JAVA基础进阶。</p><h2>JAVA多线程🐸🐸🐸</h2><p>多线程这一块比较棘手，且学且保重。</p><h2>Redis🐯🐯🐯</h2><p>系统学习redis的笔记整理。</p><h2>MySQL数据库🐨🐨🐨</h2><p>作为必备技能，用法和原理都要会。</p><h2>算法🐻🐻🐻</h2><p>算法这一块也是面试痛点和难点，头发越来越少了呢！</p><h2>Spring🐷🐷🐷</h2><p>大厂必问啊啊啊啊，源码终究还是要读的~</p><h2>Spring Cloud相关🐮🐮🐮</h2><p>这一块就比较偏实践了。分布式。。。路漫漫。。。</p><h2>Zookeeper🐗🐗🐗</h2><p>作为当今分布式协调中心，核心的Paxos算法你不想了解一下吗？</p><h2>杂记🐵🐵🐵</h2><p>在这个板块，不划分类别，文章尽可能地简短，也可谓之记忆碎片。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/miscellany/" target="_blank" rel="noopener">《技术短文杂记》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/01%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/" target="_blank" rel="noopener">《spring事务的传播行为》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/02Redisson%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《Redisson实现Redis分布式锁原理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《redis实现分布式锁》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/" target="_blank" rel="noopener">《springMVC全局异常+spring包扫描包隔离+spring事务传播》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">《分布式ID生成策略》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/06Spring%20Session/" target="_blank" rel="noopener">《Spring Session》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《Curator》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">《ELK平台搭建》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《库存扣减问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/" target="_blank" rel="noopener">《分布式事务解决方案思考》</a></li></ul></li></ul><h2>实战作品🐰🐰🐰</h2><p>记录一些实战作品，代码主要存放在<code>github</code>上。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">《我的实战》</a>：<ul><li><a href="https://github.com/sunweiguo/MMall" target="_blank" rel="noopener">《快乐蜗牛商城代码》</a></li><li><a href="https://github.com/sunweiguo/mama-buy" target="_blank" rel="noopener">《码码购分布式电商实战代码》</a></li></ul></li></ul><hr><img src="http://bloghello.oursnail.cn/mypay.png" width="500">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;☝️☝️☝️🔝🔝🔝本文为置顶文章，为了方便管理和查阅，在这里详细展示目录索引，看完索引，你就知道本站的大体内容啦！我相信一定会给小伙伴们一些收获！&lt;/p&gt;
    
    </summary>
    
    
      <category term="汇总" scheme="http://yoursite.com/tags/%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashSet</title>
    <link href="http://yoursite.com/2019/01/20/java-collection/10.LinkedHashSet/"/>
    <id>http://yoursite.com/2019/01/20/java-collection/10.LinkedHashSet/</id>
    <published>2019-01-20T12:43:12.169Z</published>
    <updated>2019-01-20T12:43:14.826Z</updated>
    
    <content type="html"><![CDATA[<p>HashSet 和 LinkedHashSet 的关系类似于 HashMap 和 LinkedHashMap 的关系，即后者维护双向链表，实现迭代顺序可为插入顺序或是访问顺序。所以也就轻松加愉快快速了解一下即可。</p><a id="more"></a><p>从源码中可以看到其空的构造函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>super</code>即父类是<code>HashSet</code>，从它的继承关系就可以显然看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>那么<code>HashSet</code>内部的数据结构就是一个 <code>HashMap</code>，其方法的内部几乎就是在调用 <code>HashMap</code> 的方法。</p><p><code>LinkedHashSet</code> 首先我们需要知道的是它是一个 <code>Set</code> 的实现，所以它其中存的肯定不是键值对，而是值。此实现与 <code>HashSet</code> 的不同之处在于，<code>LinkedHashSet</code> 维护着一个运行于所有条目的双向循环链表。</p><p>这一切都与<code>LinkedHashMap</code>类似。</p><p><code>LinkedHashSet</code> 内部有个属性 <code>accessOrder</code> 控制着遍历次序。默认情况下该值为 <code>false</code> ,即按插入排序访问。如果将该值设置为 <code>true</code> 的话，则按访问次序排序(即最近最少使用算法，最近最少使用的放在链表头部，最近访问的则在链表尾部)。</p><h2>一、 示例</h2><h4>HashSet的遍历：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">linkedHashSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"eee"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = linkedHashSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>输出结果是：</h4><blockquote><p>aaa<br>ccc<br>bbb<br>eee</p></blockquote><h4>LinkedHashSet的遍历：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">linkedHashSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"eee"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">linkedHashSet.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = linkedHashSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>输出结果是：</h4><blockquote><p>aaa<br>eee<br>ccc<br>bbb<br>null</p></blockquote><p>可以看到与输入顺序是一致的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashSet 和 LinkedHashSet 的关系类似于 HashMap 和 LinkedHashMap 的关系，即后者维护双向链表，实现迭代顺序可为插入顺序或是访问顺序。所以也就轻松加愉快快速了解一下即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java容器" scheme="http://yoursite.com/tags/java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hashtable</title>
    <link href="http://yoursite.com/2019/01/20/java-collection/9.HashTable/"/>
    <id>http://yoursite.com/2019/01/20/java-collection/9.HashTable/</id>
    <published>2019-01-20T12:26:26.250Z</published>
    <updated>2019-01-20T12:40:29.498Z</updated>
    
    <content type="html"><![CDATA[<p>Hashtable 是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。但这并不是我们不去了解它的理由。最起码 Hashtable 和 HashMap 的面试题在面试中经常被问到。</p><a id="more"></a><h2>一、前言</h2><p><code>Hashtable</code>和<code>HashMap</code>，从存储结构和实现来讲基本上都是相同的。</p><p>它和<code>HashMap</code>的最大的不同是它是线程安全的，另外它不允许<code>key</code>和<code>value</code>为<code>null</code>。</p><p>为了能在哈希表中成功地保存和取出对象，用作<code>key</code>的对象必须实现<code>hashCode</code>方法和<code>equals</code>方法。</p><h2>二、fail-fast机制</h2><p><code>iterator</code>方法返回的迭代器是<code>fail-fast</code>的。如果在迭代器被创建后<code>hashtable</code>被结构型地修改了，除了迭代器自己的<code>remove</code>方法，迭代器会抛出一个<code>ConcurrentModificationException</code>异常。</p><p><strong>因此，面对在并发的修改，迭代器干脆利落的失败，而不是冒险的继续。</strong></p><p>关于这个的理解，其实在上一章讲<code>LinkedHashMap</code>中的第八点提到：</p><div class="tip"><p><strong>值得注意的是，<code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</strong></p><p>简单说，就是两个线程同时分别进行修改和遍历时，会抛出这个异常。</p></div><p><strong>面试题：集合在遍历过程中是否可以删除元素，为什么迭代器就可以安全删除元素？</strong></p><p>集合在使用 <code>for</code> 循环迭代的过程中不允许使用，集合本身的 <code>remove</code> 方法删除元素，如果进行错误操作将会导致 <code>ConcurrentModificationException</code> 异常的发生</p><p><code>Iterator</code> 可以删除访问的当前元素(<code>current</code>)，一旦删除的元素是<code>Iterator</code> 对象中 <code>next</code> 所正在引用的，在 <code>Iterator</code> 删除元素通过 修改 <code>modCount</code> 与 <code>expectedModCount</code> 的值，可以使下次在调用 <code>remove</code> 的方法时候两者仍然相同因此不会有异常产生。</p><p>迭代器的<code>fail-fast</code>机制并不能得到保证，它不能够保证一定出现该错误。一般来说，<code>fail-fast</code>会尽最大努力抛出<code>ConcurrentModificationException</code>异常。因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：<code>ConcurrentModificationException</code> 应该仅用于检测 bug。</p><p><code>Hashtable</code>是线程安全的。如果不需要线程安全的实现是不需要的，推荐使用<code>HashMap</code>代替<code>Hashtable</code>。如果需要线程安全的实现，推荐使用<code>java.util.concurrent.ConcurrentHashMap</code>代替<code>Hashtable</code>。</p><h2>二、继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>extends Dictionary&lt;K,V&gt;</code>：<code>Dictionary</code>类是一个抽象类，用来存储键/值对，作用和Map类相似。</li><li><code>implements Map&lt;K,V&gt;</code>：实现了<code>Map</code>，实现了<code>Map</code>中声明的操作和<code>default</code>方法。</li></ul><p><code>hashMap</code>以及<code>TreeMap</code>的源码，都没有继承于这个类。不过当我看到注释中的解释也就明白了，其 <code>Dictionary</code> 源码注释是这样的：<code>NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class.</code> 该话指出 <code>Dictionary</code> 这个类过时了，新的实现类应该实现<code>Map</code>接口。</p><h2>三、属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashtable被结构型修改的次数。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>HashTable</code>并没有像<code>HashMap</code>那样定义了很多的常量，而是直接写死在了方法里。</p><p><code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。</p><h2>四、构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认初始化容量（11）和默认负载因子（0.75）来构造一个空的hashtable.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里可以看到，Hashtable默认初始化容量为16，而HashMap的默认初始化容量为11。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以获取到这些信息：<code>HashTable</code>默认的初始化容量为11（与<code>HashMap</code>不同），负载因子默认为0.75（与<code>HashMap</code>相同）。而正因为默认初始化容量的不同，同时也没有对容量做调整的策略，所以可以先推断出，<code>HashTable</code>使用的哈希函数跟<code>HashMap</code>是不一样的（事实也确实如此）。</p><h2>五、重要方法</h2><h4>5.1 get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//通过哈希函数，计算出key对应的桶的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">//遍历该桶的所有元素，寻找该key</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，<code>Hashtable</code>和<code>HashMap</code>确认<code>key</code>在数组中的索引的方法不同。</p><ul><li><code>Hashtable</code>通过<code>index = (hash &amp; 0x7FFFFFFF) % tab.length;</code>来确认</li><li><code>HashMap</code>通过<code>i = (n - 1) &amp; hash;</code>来确认</li></ul><p>跟<code>HashMap</code>相比，<code>HashTable</code>的<code>get</code>方法非常简单。我们首先可以看见<code>get</code>方法使用了<code>synchronized</code>来修饰，所以它能保证线程安全。并且它是通过链表的方式来处理冲突的。另外，我们还可以看见<code>HashTable</code>并没有像<code>HashMap</code>那样封装一个哈希函数，而是直接把哈希函数写在了方法中。而哈希函数也是比较简单的，<strong>它仅对哈希表的长度进行了取模</strong>。</p><h4>5.2 put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确认value不为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//找到key在table中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">//获取key所在索引的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//遍历entry，判断key是否已经存在</span></span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">//如果key已经存在</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="comment">//保存旧的value</span></span><br><span class="line">            V old = entry.value;</span><br><span class="line">            <span class="comment">//替换value</span></span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">//返回旧的value</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key在hashtable不是已经存在，就直接将键值对添加到table中，返回null</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//哈希表的键值对个数达到了阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="comment">//把新节点插入桶中（头插法）</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以总结出<code>Hashtable</code>的<code>put</code>方法的总体思路：</p><ul><li>确认<code>value</code>不为<code>null</code>。如果为<code>null</code>，则抛出异常</li><li>找到<code>key</code>在<code>table</code>中的索引，获取<code>key</code>所在位置的<code>entry</code></li><li>遍历<code>entry</code>，判断<code>key</code>是否已经存在</li><li>如果<code>key</code>已经存在，替换<code>value</code>，返回旧的<code>value</code></li><li>如果<code>key</code>在<code>hashtable</code>不是已经存在，就直接添加，否则直接将键值对添加到<code>table</code>中，返回<code>null</code></li></ul><p>在方法中可以看到，在遍历桶中元素时，是按照链表的方式遍历的。可以印证，<code>HashMap</code>的桶中可能为链表或者树。但<code>Hashtable</code>的桶中只可能是链表。</p><h4>5.3 remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//计算key在hashtable中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//遍历entry，如果entry中存在key为参数key的键值对，就删除键值对，并返回键值对的value</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不存在key为参数key的键值对，返回value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以总结出<code>Hashtable</code>的<code>remove</code>方法的总体思路：</p><ul><li>找到<code>key</code>在<code>table</code>中的索引，获取<code>key</code>所在位置的<code>entry</code></li><li>遍历<code>entry</code>，判断<code>key</code>是否已经存在</li><li>如果<code>key</code>存在，删除<code>key</code>映射的键值对，返回旧的<code>value</code></li><li>如果<code>key</code>在<code>hashtable</code>不存在，返回<code>null</code></li></ul><h4>5.4 rehash方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加hashtable的容量，为了更有效地存放和找到它的entry。</span></span><br><span class="line"><span class="comment"> * 当键值对的数量超过了临界值（capacity*load factor）这个方法自动调用</span></span><br><span class="line"><span class="comment"> * 长度变为原来的2倍+1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    <span class="comment">//记录旧桶的数组</span></span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//新的容量为旧的容量的2倍+1</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果新的容量大于容量的最大值MAX_ARRAY_SIZE </span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧容量为MAX_ARRAY_SIZE，容量不变，中断方法的执行</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果旧容量不为MAX_ARRAY_SIZE，新容量变为MAX_ARRAY_SIZE</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新的数组，容量为新容量</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">    <span class="comment">//结构性修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//计算扩容的临界值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line">    <span class="comment">//将旧的数组中的键值对转移到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完代码，我们可以总结出<code>rehash</code>的总体思路为：</p><ul><li>新建变量新的容量，值为旧的容量的2倍+1</li><li>如果新的容量大于容量的最大值<code>MAX_ARRAY_SIZE</code><ul><li>如果旧容量为<code>MAX_ARRAY_SIZE</code>，容量不变，中断方法的执行</li><li>如果旧容量不为<code>MAX_ARRAY_SIZE</code>，新容量变为<code>MAX_ARRAY_SIZE</code></li></ul></li><li>创建新的数组，容量为新容量</li><li>将旧的数组中的键值对转移到新数组中</li></ul><p>这里可以看到，一般情况下，<code>HashMap</code>扩容后容量变为原来的两倍，而<code>Hashtable</code>扩容后容量变为原来的两倍加一。</p><p><strong><code>HashTable</code>的<code>rehash</code>方法相当于<code>HashMap</code>的<code>resize</code>方法。跟<code>HashMap</code>那种巧妙的<code>rehash</code>方式相比，<code>HashTable</code>的<code>rehash</code>过程需要对每个键值对都重新计算哈希值，而比起异或和与操作，取模是一个非常耗时的操作，所以这也是导致效率较低的原因之一。</strong></p><h2>六、遍历</h2><p>可以使用与<code>HashMap</code>一样的遍历方式，但是由于历史原因，多了<code>Enumeration</code>的方式。</p><h5>针对Enumeration，这里与iterator进行对比一下。</h5><h6>相同点</h6><ul><li><code>Iterator</code>和<code>Enumeration</code>都可以对某些容器进行遍历。</li><li><code>Iterator</code>和<code>Enumeration</code>都是接口。</li></ul><h6>不同点</h6><ul><li><code>Iterator</code>有对容器进行修改的方法。而<code>Enumeration</code>只能遍历。</li><li><code>Iterator</code>支持<code>fail-fast</code>，而<code>Enumeration</code>不支持。</li><li><code>Iterator</code>比<code>Enumeration</code>覆盖范围广，基本所有容器中都有<code>Iterator</code>迭代器，而只有<code>Vector</code>、<code>Hashtable</code>有<code>Enumeration</code>。</li><li><code>Enumeration</code>在JDK 1.0就已经存在了，而<code>Iterator</code>是JDK2.0新加的接口。</li></ul><h2>七、Hashtable与HashMap对比</h2><p><code>HashTable</code>的应用非常广泛，<code>HashMap</code>是新框架中用来代替<code>HashTable</code>的类，也就是说建议使用<code>HashMap</code>。</p><h4>下面着重比较一下二者的区别：</h4><h5>1.继承不同</h5><p><code>Hashtable</code>是基于陈旧的<code>Dictionary</code>类的，<code>HashMap</code>是java1.2引进的Map接口的一个实现。</p><h5>2.同步</h5><p><code>Hashtable</code> 中的方法是同步的，保证了<code>Hashtable</code>中的对象是线程安全的。</p><p><code>HashMap</code>中的方法在缺省情况下是非同步的,<code>HashMap</code>中的对象并不是线程安全的。在多线程并发的环境下，可以直接使用<code>Hashtable</code>，但是要使用<code>HashMap</code>的话就要自己增加同步处理了。</p><h5>3.效率</h5><p>单线程中, <code>HashMap</code>的效率大于<code>Hashtable</code>。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合，<code>HashMap</code>是<code>Hashtable</code>的轻量级实现，这样可以避免由于同步带来的不必要的性能开销，从而提高效率。</p><h5>4.null值</h5><p><code>Hashtable</code>中，<code>key</code>和<code>value</code>都不允许出现<code>null</code>值，否则出现<code>NullPointerException</code>。</p><p>在<code>HashMap</code>中，<code>null</code>可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为<code>nul</code>l。当<code>get()</code>方法返回<code>null</code>值时，即可以表示 <code>HashMap</code>中没有该键，也可以表示该键所对应的值为<code>null</code>。因此，<strong>在<code>HashMap</code>中不能由<code>get()</code>方法来判断<code>HashMap</code>中是否存在某个键，而应该用<code>containsKey()</code>方法来判断</strong>。</p><h5>5.遍历方式</h5><p><code>Hashtable</code>、<code>HashMap</code>都使用了 <code>Iterator</code>。而由于历史原因，<code>Hashtable</code>可以使用<code>Enumeration</code>的方式。</p><h5>6.容量</h5><p><code>Hashtable</code>和<code>HashMap</code>它们两个内部实现方式的数组的初始大小和扩容的方式。</p><p><code>HashTable</code>中<code>hash</code>数组默认大小是11，增加的方式是 <code>old*2+1</code>。</p><p><code>HashMap</code>中<code>hash</code>数组的默认大小是16，而且一定是2的指数。</p><h2>八、总结</h2><p>无论什么时候有多个线程访问相同实例的可能时，就应该使用<code>Hashtable</code>，反之使用<code>HashMap</code>。非线程安全的数据结构能带来更好的性能。</p><p>如果在将来有一种可能—你需要按顺序获得键值对的方案时，<code>HashMap</code>是一个很好的选择，因为有<code>HashMap</code>的一个子类 <code>LinkedHashMap</code>。</p><p>所以如果你想可预测的按顺序迭代（默认按插入的顺序），你可以很方便用<code>LinkedHashMap</code>替换<code>HashMap</code>。反观要是使用的<code>Hashtable</code>就没那么简单了。</p><p>如果有多个线程访问<code>HashMap</code>，<code>Collections.synchronizedMap（）</code>可以代替，总的来说<code>HashMap</code>更灵活，或者直接用并发容器<code>ConcurrentHashMap</code>。</p><p>整理自：</p><ul><li><a href="http://blog.csdn.net/panweiwei1994/article/details/77428710" target="_blank" rel="noopener">http://blog.csdn.net/panweiwei1994/article/details/77428710</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52655042" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52655042</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashtable 是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。但这并不是我们不去了解它的理由。最起码 Hashtable 和 HashMap 的面试题在面试中经常被问到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java容器" scheme="http://yoursite.com/tags/java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和LinkedHashMap遍历机制</title>
    <link href="http://yoursite.com/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/01/20/java-collection/8.HashMap和LinkedHashMap遍历机制/</id>
    <published>2019-01-20T12:07:31.483Z</published>
    <updated>2019-01-20T12:08:05.754Z</updated>
    
    <content type="html"><![CDATA[<p>本篇单独讲一下HashMap和LinkedHashMap遍历方式。</p><a id="more"></a><h2>一、对HashMap和LinkedHashMap遍历的几种方法</h2><p>这里以<code>HashMap</code>为例，<code>LinkedHashMap</code>一样的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>强烈建议使用第一种 <code>EntrySet</code> 进行遍历。</strong></p><p>第一种可以把 <code>key value</code> 同时取出，第二种还得需要通过 <code>key</code> 取一次 <code>value</code>，效率较低, 第三种需要 <code>JDK1.8</code> 以上，通过外层遍历 <code>table</code>，内层遍历链表或红黑树。</p><p>我们知道，<code>HashMap</code>的输出顺序与元素的输入顺序无关，<code>LinkedHashMap</code>可以按照输入顺序输出，也可以根据读取元素的顺序输出。这一现象，已经在上一篇中展示出来了。</p><h2>二、HashMap的遍历机制</h2><p><code>HashMap</code> 提供了两个遍历访问其内部元素<code>Entry&lt;k,v&gt;</code>的接口：</p><ol><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>-------&gt;返回此映射所包含的映射关系的 Set 视图。</li><li><code>Set&lt;K&gt; keySet()</code>--------&gt;返回此映射中所包含的键的 Set 视图。</li></ol><blockquote><p>实际上，第二个接口表示的<code>Key</code>的顺序，和第一个接口返回的<code>Entry</code>顺序是对应的，也就是说：这两种接口对<code>HashMap</code>的元素遍历的顺序相相同的。  那么，<code>HashMap</code>遍历内部<code>Entry&lt;K,V&gt;</code> 的顺序是什么呢？ 搞清楚这个问题，先要知道其内部结构是怎样的。</p></blockquote><p><code>HashMap</code>在存储<code>Entry</code>对象的时候，是根据<code>Key</code>的<code>hash</code>值判定存储到<code>Entry[] table</code>数组的哪一个索引值表示的链表上。</p><p>对<code>HashMap</code>遍历<code>Entry</code>对象的顺序和<code>Entry</code>对象的存储顺序之间没有任何关系。</p><p><strong><code>HashMap</code>散列图、<code>Hashtable</code>散列表是按“有利于随机查找的散列(hash)的顺序”。并非按输入顺序。遍历时只能全部输出，而没有顺序</strong>。甚至可以<code>rehash()</code>重新散列，来获得更利于随机存取的内部顺序。</p><p>所以对<code>HashMap</code>的遍历，由内部的机制决定的，这个机制是只考虑利于快速存取，不考虑输入等顺序。</p><h2>三、LinkedHashMap 的遍历机制</h2><p><code>LinkedHashMap</code> 是<code>HashMap</code>的子类，它可以实现对容器内Entry的存储顺序和对Entry的遍历顺序保持一致。</p><p>为了实现这个功能，<strong><code>LinkedHashMap</code>内部使用了一个<code>Entry</code>类型的双向链表，用这个双向链表记录<code>Entry</code>的存储顺序</strong>。当需要对该<code>Map</code>进行遍历的时候，实际上是遍历的是这个双向链表。</p><p><code>LinkedHashMap</code>内部使用的<code>LinkedHashMap.Entry</code>类继承自<code>Map.Entry</code>类，在其基础上增加了<code>LinkedHashMap.Entry</code>类型的两个字段，用来引用该<code>Entry</code>在双向链表中的前面的<code>Entry</code>对象和后面的<code>Entry</code>对象。</p><p>它的内部会在<code>Map.Entry</code>类的基础上，增加两个<code>Entry</code>类型的引用：<code>before</code>，<code>after</code>。<code>LinkedHashMap</code>使用一个双向连表，将其内部所有的<code>Entry</code>串起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap linkedHashMap = <span class="keyword">new</span> LinkedHashMap();  </span><br><span class="line">linkedHashMap.put(<span class="string">"name"</span>,<span class="string">"louis"</span>);  </span><br><span class="line">linkedHashMap.put(<span class="string">"age"</span>,<span class="string">"24"</span>);  </span><br><span class="line">linkedHashMap.put(<span class="string">"sex"</span>,<span class="string">"male"</span>);</span><br></pre></td></tr></table></figure><p>对<code>LinkedHashMap</code>进行遍历的策略：</p><p><strong>从 <code>header.after</code> 指向的<code>Entry</code>对象开始，然后一直沿着此链表遍历下去，直到某个<code>entry.after == header</code> 为止，完成遍历。</strong></p><p>根据<code>Entry&lt;K,V&gt;</code>插入<code>LinkedHashMap</code>的顺序进行遍历的方式叫做：按插入顺序遍历。</p><p>另外，<code>LinkedHashMap</code>还支持一种遍历顺序，叫做：Get读取顺序。</p><p>如果<code>LinkedHashMap</code>的这个<code>Get</code>读取遍历顺序开启，那么，当我们在<code>LinkedHashMap</code>上调用<code>get(key)</code> 方法时，会导致内部<code>key</code>对应的<code>Entry</code>在双向链表中的位置移动到双向链表的最后。</p><h2>四、遍历机制的总结</h2><ol><li><p><code>HashMap</code>对元素的遍历顺序跟<code>Entry</code>插入的顺序无关，而<code>LinkedHashMap</code>对元素的遍历顺序可以跟<code>Entry&lt;K,V&gt;</code>插入的顺序保持一致：从双向。</p></li><li><p>当<code>LinkedHashMap</code>处于<code>Get</code>获取顺序遍历模式下，当执行<code>get()</code> 操作时，会将对应的<code>Entry&lt;k,v&gt;</code>移到遍历的最后位置。</p></li><li><p><code>LinkedHashMap</code>处于按插入顺序遍历的模式下，如果新插入的<code>&lt;key,value&gt;</code> 对应的<code>key</code>已经存在，对应的<code>Entry</code>在遍历顺序中的位置并不会改变。</p></li><li><p>除了遍历顺序外，其他特性<code>HashMap</code>和<code>LinkedHashMap</code>基本相同。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇单独讲一下HashMap和LinkedHashMap遍历方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java容器" scheme="http://yoursite.com/tags/java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap</title>
    <link href="http://yoursite.com/2019/01/20/java-collection/7.LinkedHashMap/"/>
    <id>http://yoursite.com/2019/01/20/java-collection/7.LinkedHashMap/</id>
    <published>2019-01-20T11:17:21.878Z</published>
    <updated>2019-01-20T11:49:07.463Z</updated>
    
    <content type="html"><![CDATA[<p>大多数情况下，只要不涉及线程安全问题， Map 基本都可以使用 HashMap ，不过 HashMap 有一个问题，就是迭代 HashMap 的顺序并不是 HashMap 放置的顺序，也就是无序。 HashMap 的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的 Map。</p><a id="more"></a><div class="tip">篇幅有点长，但是在理解了HashMap之后就比较简单了。</div><p>这个时候，<code>LinkedHashMap</code>就闪亮登场了，它虽然增加了时间和空间上的开销，但是可以解决有排序需求的场景。</p><p>它的底层是继承于 <code>HashMap</code> 实现的，由一个<strong>双向循环链表</strong>所构成。</p><p><code>LinkedHashMap</code> 的排序方式有两种：</p><ul><li>根据写入顺序排序。</li><li>根据访问顺序排序。</li></ul><p>其中根据访问顺序排序时，每次 <code>get</code> 都会将访问的值移动到链表末尾，这样重复操作就能得到一个按照访问顺序排序的链表。</p><h2>一、LinkedHashMap数据结构</h2><p><img src="http://bloghello.oursnail.cn/collection7-1.jpg" alt="image"></p><p><code>LinkedHashMap</code>是通过哈希表和双向循环链表实现的，它通过维护一个双向循环链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。</p><p>我们可以看出，遍历所有元素只需要从header开始遍历即可，一直遍历到下一个元素是header结束。</p><p>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说，假设你插入的键的顺序为1、2、3、4，后来再次插入2，迭代时的顺序还是1、2、3、4，而不会因为后来插入的2变成1、3、4、2。（但其实我们可以改变它的规则，使它变成1、3、4、2）</p><p><code>LinkedHashMap</code>的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希表部分继承了<code>HashMap</code>，拥有了<code>HashMap</code>那一套高效的操作，所以我们要看的就是<code>LinkedHashMap</code>中链表的部分，了解它是如何来维护有序性的。</p><h2>二、demo示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap插入数据，遍历输出无序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------HashMap插入数据--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iter = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap插入数据，遍历，默认以插入顺序为序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------LinkedHashMap插入数据,按照插入顺序进行排序--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    linkedHashMap.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = linkedHashMap.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap插入数据，设置accessOrder=true实现使得其遍历顺序按照访问的顺序输出，这里先用get方法来演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------LinkedHashMap插入数据,accessOrder=true:按照访问顺序进行排序--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; linkedHashMap2 = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"apple"</span>, <span class="string">"aa"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"banana"</span>, <span class="string">"cc"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"peach"</span>, <span class="string">"dd"</span>);</span><br><span class="line"></span><br><span class="line">    linkedHashMap2.get(<span class="string">"banana"</span>);<span class="comment">//banana移动到了内部的链表末尾</span></span><br><span class="line">    linkedHashMap2.get(<span class="string">"apple"</span>);<span class="comment">//apple移动到了内部的链表末尾</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    Iterator iter2 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter2.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap的put方法在accessOrder=true的情况下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);<span class="comment">//watermelon移动到了内部的链表末尾</span></span><br><span class="line">    linkedHashMap2.put(<span class="string">"stawbarrey"</span>, <span class="string">"ee"</span>);<span class="comment">//末尾插入新元素stawbarrey</span></span><br><span class="line">    linkedHashMap2.put(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//插入新的节点 null</span></span><br><span class="line">    Iterator iter3 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter3.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----------HashMap插入数据--------</span><br><span class="line">banana=c</span><br><span class="line">apple=a</span><br><span class="line">peach=d</span><br><span class="line">watermelon=b</span><br><span class="line">----------LinkedHashMap插入数据,按照插入顺序进行排序--------</span><br><span class="line">apple=a</span><br><span class="line">watermelon=b</span><br><span class="line">banana=c</span><br><span class="line">peach=d</span><br><span class="line">----------LinkedHashMap插入数据,按照访问顺序进行排序--------</span><br><span class="line">watermelon=bb</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc<span class="comment">//banana到了末尾</span></span><br><span class="line">apple=aa<span class="comment">//apple到了末尾</span></span><br><span class="line">-----------</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc</span><br><span class="line">apple=aa</span><br><span class="line">watermelon=bb<span class="comment">//watermelon到了链表末尾</span></span><br><span class="line">stawbarrey=ee<span class="comment">//新插入的放在末尾</span></span><br><span class="line"><span class="keyword">null</span>=<span class="keyword">null</span><span class="comment">//新插入的放在末尾</span></span><br></pre></td></tr></table></figure><h2>三、属性</h2><p><code>LinkedHashMap</code>可以认为是<code>HashMap+LinkedList</code>，即它既使用<code>HashMap</code>操作数据结构，又使用<code>LinkedList</code>维护插入元素的先后顺序</p><h5>3.1 继承关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，自然<code>LinkedHashMap</code>也就继承了<code>HashMap</code>中所有非private的方法。所以它已经从 <code>HashMap</code> 那里继承了与哈希表相关的操作了，那么在<code>LinkedHashMap</code>中，它可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p><h5>3.2 属性介绍</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap的链表节点继承了HashMap的节点，而且每个节点都包含了前指针和后指针，所以这里可以看出它是一个双向链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认为false。当为true时，表示链表中键值对的顺序与每个键的插入顺序一致，也就是说重复插入键，也会更新顺序</span></span><br><span class="line"><span class="comment">//简单来说，为false时，就是上面所指的1、2、3、4的情况；为true时，就是1、3、4、2的情况</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h2>五、构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是调用的 <code>HashMap</code> 的构造方法:</p><p><code>HashMap</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//HashMap 只是定义了改方法，具体实现交给了 LinkedHashMap</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面有一个空的 <code>init()</code>，具体是由 <code>LinkedHashMap</code> 来实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也就是对 <code>header</code> 进行了初始化。</p><h2>六、添加元素</h2><p><img src="http://bloghello.oursnail.cn/collection7-2.jpg" alt="image"></p><p><code>LinkedHashMap</code>并没有重写任何<code>put</code>方法。但是其重写了构建新节点的<code>newNode()</code>方法.</p><p><code>newNode()</code> 会在<code>HashMap</code>的<code>putVal()</code> 方法里被调用，<code>putVal()</code> 方法会在批量插入数据<code>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</code> 或者插入单个数据<code>public V put(K key, V value)</code>时被调用。</p><p><code>LinkedHashMap</code>重写<code>了newNode()</code>,在每次构建新节点时，通过<code>linkNodeLast(p);</code>将新节点链接在内部双向链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`.</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将新增的节点，连接在链表的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">//集合之前是空的</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//将新节点连接在链表的尾部</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及<code>HashMap</code>专门预留给<code>LinkedHashMap</code>的<code>afterNodeAccess()</code> 、<code>afterNodeInsertion()</code> 、<code>afterNodeRemoval()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>如果你没有注意到注释的解释的话，你可能会很奇怪为什么会有三个空方法，而且有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点之后，进行一些处理，它们在<code>LinkedHashMap</code>有各自的实现。<code>LinkedHashMap</code>正是通过重写这三个方法来保证链表的插入、删除的有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数，新节点插入之后回调,判断是否需要删除最老插入的节点。</span></span><br><span class="line"><span class="comment">//如果实现LruCache会用到这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">//LinkedHashMap 默认返回false 则不删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap 默认返回false 则不删除节点。 </span></span><br><span class="line"><span class="comment">//返回true 代表要删除最早的节点。</span></span><br><span class="line"><span class="comment">//通常构建一个LruCache会在达到Cache的上限是返回true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void afterNodeInsertion(boolean evict)</code>以及<code>boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code> 是构建LruCache需要的回调，在这可以忽略它们。</p><h2>七、删除元素</h2><p><code>LinkedHashMap</code>也没有重写<code>remove()</code> 方法，因为它的删除逻辑和<code>HashMap</code>并无区别。<br>但它重写了<code>afterNodeRemoval()</code> 这个回调方法。该方法会在<code>Node&lt;K,V&gt; removeNode(int hash, Object key</code>, <code>Object value</code>,<br><code>boolean matchValue, boolean movable)</code> 方法中回调，<code>removeNode()</code> 会在所有涉及到删除节点的方法中被调用，上文分析过，是删除节点操作的真正执行者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在删除节点e时，同步将e从双向链表上删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">//待删除节点 p 的前置后置节点都置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果前置节点是null，则现在的头结点应该是后置节点a</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则将前置节点b的后置节点指向a</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">//同理如果后置节点时null ，则尾节点应是b</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则更新后置节点a的前置节点为b</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>八、查询元素</h2><p><code>LinkedHashMap</code>重写了<code>get()</code>和<code>getOrDefault()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>HashMap</code>中的实现,<code>LinkedHashMap</code>只是增加了在成员变量(构造函数时赋值)<code>accessOrder</code>为true的情况下，要去回调<code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>afterNodeAccess()</code> 函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;<span class="comment">//原尾节点</span></span><br><span class="line">    <span class="comment">//如果accessOrder 是true ，且原尾节点不等于e</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">//节点e强转成双向链表节点p</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">//p现在是尾节点， 后置节点一定是null</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果p的前置节点是null，则p以前是头结点，所以更新现在的头结点是p的后置节点a</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则更新p的前直接点b的后置节点为 a</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">//如果p的后置节点不是null，则更新后置节点a的前置节点为b</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果原本p的后置节点是null，则p就是尾节点。 此时 更新last的引用为 p的前置节点b</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//原本尾节点是null  则，链表中就一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点的引用赋值成p</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">//修改modCount。</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示(注意这个图，1和6也应该是连在一起的，因为是双向循环链表，所以视为一个小错误)：</p><p><img src="http://hashmap.oursnail.cn/afterNodeAccess.png" alt="image"></p><p>说明：从图中可以看到，结点3链接到了尾结点后面。</p><p><strong>值得注意的是，<code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</strong></p><h2>九、判断元素是否存在</h2><p>它重写了该方法，相比<code>HashMap</code>的实现，更为高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历一遍链表，去比较有没有value相等的节点，并返回</span></span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>HashMap</code>，是用两个<code>for</code>循环遍历，相对低效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>十、替换某个元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用dst替换src</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = dst;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://hashmap.oursnail.cn/transferLinks.png" alt="image"></p><h2>十二、总结</h2><p><code>LinkedHashMap</code>相对于<code>HashMap</code>的源码比，是很简单的。因为大树底下好乘凉。它继承了<code>HashMap</code>，仅重写了几个方法，以改变它迭代遍历时的顺序。这也是其与<code>HashMap</code>相比最大的不同。<br>在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。</p><ul><li><p><code>accessOrder</code>默认是<code>false</code>，则迭代时输出的顺序是插入节点的顺序。若为<code>true</code>，则输出的顺序是按照访问节点的顺序。为<code>true</code>时，可以在这基础之上构建一个<code>LruCache</code>.</p></li><li><p><code>LinkedHashMap</code>并没有重写任何put方法。但是其重写了构建新节点的<code>newNode()</code>方法.在每次构建新节点时，将新节点链接在内部双向链表的尾部</p></li><li><p><code>accessOrder=true</code>的模式下,在<code>afterNodeAccess()</code>函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。值得注意的是，<code>afterNodeAccess()</code>函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</p></li><li><p><code>nextNode()</code> 就是迭代器里的<code>next()</code>方法 。该方法的实现可以看出，迭代<code>LinkedHashMap</code>，就是从内部维护的双链表的表头开始循环输出。</p></li><li><p>而双链表节点的顺序在<code>LinkedHashMap</code>的增、删、改、查时都会更新。以满足按照插入顺序输出，还是访问顺序输出。</p></li><li><p>它与<code>HashMap</code>比，还有一个小小的优化，重写了<code>containsValue()</code>方法，直接遍历内部链表去比对<code>value</code>值是否相等。</p></li></ul><p>整理自：</p><ul><li><a href="http://blog.csdn.net/zxt0601/article/details/77429150" target="_blank" rel="noopener">http://blog.csdn.net/zxt0601/article/details/77429150</a></li><li><a href="http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52659741" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52659741</a></li><li><a href="http://www.cnblogs.com/leesf456/p/5248868.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/5248868.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数情况下，只要不涉及线程安全问题， Map 基本都可以使用 HashMap ，不过 HashMap 有一个问题，就是迭代 HashMap 的顺序并不是 HashMap 放置的顺序，也就是无序。 HashMap 的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的 Map。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java容器" scheme="http://yoursite.com/tags/java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashSet</title>
    <link href="http://yoursite.com/2019/01/20/java-collection/6.HashSet/"/>
    <id>http://yoursite.com/2019/01/20/java-collection/6.HashSet/</id>
    <published>2019-01-20T10:32:18.891Z</published>
    <updated>2019-01-20T10:36:33.916Z</updated>
    
    <content type="html"><![CDATA[<p>HashSet 是一个不允许存储重复元素的集合，它是基于 HashMap 实现的， HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet  的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成。所以只要理解了 HashMap，HashSet 就水到渠成了。</p><a id="more"></a><h2>成员变量</h2><p>首先了解下<code>HashSet</code>的成员变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>发现主要就两个变量:</p><ul><li><code>map</code> ：用于存放最终数据的。</li><li><code>PRESENT</code> ：是所有写入<code>map</code>的<code>value</code>值。</li></ul><h2>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数很简单，利用了<code>HashMap</code>初始化了<code>map</code>。</p><h2>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会受到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p><p>该方法如果添加的是在 <code>HashSet</code> 中不存在的，则返回 <code>true</code>；如果添加的元素已经存在，返回 <code>false</code>。其原因在于我们之前提到的关于 <code>HashMap</code> 的 <code>put</code> 方法。该方法在添加 <code>key</code> 不重复的键值对的时候，会返回 <code>null</code>。</p><h2>总结</h2><p><code>HashSet</code> 的原理比较简单，几乎全部借助于 <code>HashMap</code> 来实现的。</p><p>所以 <code>HashMap</code> 会出现的问题 <code>HashSet</code> 依然不能避免。</p><p>对于 <code>HashSet</code> 中保存的对象，请注意正确重写其 <code>equals</code> 和 <code>hashCode</code> 方法，以保证放入的对象的唯一性。这两个方法是比较重要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashSet 是一个不允许存储重复元素的集合，它是基于 HashMap 实现的， HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet  的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成。所以只要理解了 HashMap，HashSet 就水到渠成了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java容器" scheme="http://yoursite.com/tags/java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://yoursite.com/2019/01/20/java-collection/5.HashMap/"/>
    <id>http://yoursite.com/2019/01/20/java-collection/5.HashMap/</id>
    <published>2019-01-20T10:07:36.921Z</published>
    <updated>2019-01-20T12:07:09.930Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap基本是面试必问的点，因为这个数据结构用的太频繁了，jdk1.8中的优化也是比较巧妙。有必要去深入探讨一下。但是涉及的内容比较多，这里只先探讨jdk8中HashMap的实现，至于jdk7中HashMap的死循环问题、红黑树的原理等都不会在本篇文章扩展到。其他的文章将会再去探讨整理。</p><a id="more"></a><p>本篇文章较长，高能预警。</p><h2>一、前言</h2><p>之前的<code>List</code>，讲了<code>ArrayList</code>、<code>LinkedList</code>，最后讲到了<code>CopyOnWriteArrayList</code>，就前两者而言，反映的是两种思想：</p><p>（1）<code>ArrayList</code>以数组形式实现，顺序插入、查找快，插入、删除较慢</p><p>（2）<code>LinkedList</code>以链表形式实现，顺序插入、查找较慢，插入、删除方便</p><p>那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是<code>HashMap</code>。</p><p><code>HashMap</code>是一种非常常见、方便和有用的集合，是一种键值对（K-V）形式的存储结构，在有了<code>HashCode</code>的基础后，下面将还是用图示的方式解读<code>HashMap</code>的实现原理。</p><p>Java为数据结构中的映射定义了一个接口<code>java.util.Map</code>，此接口主要有四个常用的实现类，分别是<code>HashMap</code>、<code>Hashtable</code>、<code>LinkedHashMap</code>和<code>TreeMap</code>，类继承关系如下图所示：</p><p><img src="http://hashmap.oursnail.cn/map%E6%8E%A5%E5%8F%A3.png" alt="image"></p><p>(1) <code>HashMap</code>：它根据键的<code>hashCode</code>值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 <code>HashMap</code>最多只允许一条记录的键为<code>null</code>，允许多条记录的值为<code>null</code>。<code>HashMap</code>非线程安全，即任一时刻可以有多个线程同时写<code>HashMap</code>，可能会导致数据的不一致。如果需要满足线程安全，可以用 <code>Collections</code>的<code>synchronizedMap</code>方法使<code>HashMap</code>具有线程安全的能力，或者使用<code>ConcurrentHashMap</code>。</p><p>(2) <code>Hashtable</code>：<code>Hashtable</code>是遗留类，很多映射的常用功能与<code>HashMap</code>类似，不同的是它承自<code>Dictionary</code>类，并且是线程安全的，任一时间只有一个线程能写<code>Hashtable</code>，并发性不如<code>ConcurrentHashMap</code>，因为<code>ConcurrentHashMap</code>引入了分段锁。<code>Hashtable</code>不建议在新代码中使用，不需要线程安全的场合可以用<code>HashMap</code>替换，需要线程安全的场合可以用<code>ConcurrentHashMap</code>替换。</p><p>(3) <code>LinkedHashMap</code>：<code>LinkedHashMap</code>是<code>HashMap</code>的一个子类，保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>(4) <code>TreeMap</code>：<code>TreeMap</code>实现<code>SortedMap</code>接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code>遍历<code>TreeMap</code>时，得到的记录是排过序的。如果使用排序的映射，建议使用<code>TreeMap</code>。在使用<code>TreeMap</code>时，key必须实现<code>Comparable</code>接口或者在构造<code>TreeMap</code>传入自定义的<code>Comparator</code>，否则会在运行时抛出<code>java.lang.ClassCastException</code>类型的异常。</p><p>对于上述四种<code>Map</code>类型的类，要求映射中的<code>key</code>是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，<code>Map</code>对象很可能就定位不到映射的位置了。</p><h2>二、HashMap的结构</h2><p>其中哈希表是一个数组，<strong>我们经常把数组中的每一个节点称为一个桶</strong>，哈希表中的每个节点都用来存储一个键值对。</p><p>在插入元素时，如果发生冲突（即多个键值对映射到同一个桶上）的话，就会通过链表的形式来解决冲突。</p><p>因为<strong>一个桶上可能存在多个键值对</strong>，所以在查找的时候，会先通过<code>key</code>的哈希值先定位到桶，再遍历桶上的所有键值对，找出<code>key</code>相等的键值对，从而来获取<code>value</code>。</p><p><img src="http://bloghello.oursnail.cn/HashMap%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p><p>如图所示，<code>HashMap</code> 底层是基于数组和链表实现的。其中有两个重要的参数：</p><ul><li>容量</li><li>负载因子</li></ul><p>容量的默认大小是 16，负载因子是 0.75，当 <code>HashMap</code> 的 size &gt; 16*0.75 时就会发生扩容(容量和负载因子都可以自由调整)。</p><h2>三、继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p><code>HashMap</code>继承自<code>AbstractMap</code>，<code>AbstractMap</code>是<code>Map</code>接口的骨干实现，<code>AbstractMap</code>中实现了<code>Map</code>中最重要最常用和方法，这样<code>HashMap</code>继承<code>AbstractMap</code>就不需要实现<code>Map</code>的所有方法，让<code>HashMap</code>减少了大量的工作。</p></blockquote><h2>四、属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//最大的容量上限为2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的负载因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//变成树型结构的临界值为8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//恢复链式结构的临界值为6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表的最小树形化容量</span></span><br><span class="line"><span class="comment"> * 当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span></span><br><span class="line"><span class="comment"> * 否则桶内元素太多时会扩容，而不是树形化</span></span><br><span class="line"><span class="comment"> * 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//哈希表被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//它是通过capacity*load factor计算出来的，当size到达这个值时，就会进行扩容操作</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h5>4.1 几个属性的详细说明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>首先，<code>Node[] table</code>的初始化长度<code>length</code>(<strong>默认值是16</strong>)，<code>Load factor</code>为负载因子(<strong>默认值是0.75</strong>)，<code>threshold</code>是<code>HashMap</code>所能容纳的最大数据量的<code>Node</code>(键值对)个数。<code>threshold = length * Load factor</code>。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，<code>threshold</code>就是在此<code>Load factor</code>和<code>length</code>(数组长度)对应下允许的最大元素数目，超过这个数目就重新<code>resize</code>(扩容)，<strong>扩容后的<code>HashMap</code>容量是之前容量的两倍（为什么是两倍下文会说明）</strong>。</p><div class="tip">默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子`Load factor`的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子`loadFactor`的值，这个值可以大于1。</div><p><code>size</code>这个字段其实很好理解，就是<code>HashMap</code>中<strong>实际存在的键值对数量</strong>。<strong>注意<code>size</code>和<code>table</code>的长度<code>length</code>、容纳最大键值对数量<code>threshold</code>的区别</strong>。</p><p>而<code>modCount</code>字段主要用来记录<code>HashMap</code>内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，<strong>内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个<code>key</code>对应的<code>value</code>值被覆盖不属于结构变化。</strong></p><p><strong>在<code>HashMap</code>中，哈希桶数组<code>table</code>的长度<code>length</code>大小必须为2的n次方(一定是合数)</strong>，这是一种非常规的设计，因为常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考 <a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a> ，<code>Hashtable</code>初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。<strong><code>HashMap</code>采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，<code>HashMap</code>定位哈希桶索引位置时，也加入了高位参与运算的过程。下文会说明。</strong></p><p>这里存在一个问题，即使负载因子和<code>Hash</code>算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响<code>HashMap</code>的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。<strong>而当链表长度太长（默认超过8）时，并且链表的长度超过64时，链表就转换为红黑树</strong>，利用红黑树快速增删改查的特点提高<code>HashMap</code>的性能，其中会用到红黑树的插入、删除、查找等算法。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E7%BB%93%E6%9E%84.png" alt="image"></p><p>这里着重提一下<code>MIN_TREEIFY_CAPACITY</code>字段，容易与<code>TREEIFY_THRESHOLD</code>打架，<code>TREEIFY_THRESHOLD</code>是指桶中元素达到8个，就将其本来的链表结构改为红黑树，提高查询的效率。<code>MIN_TREEIFY_CAPACITY</code>是指最小树化的哈希表元素个数，也就是说，小于这个值，就算你(数组)桶里的元素数量大于8了，还是要用链表存储，只有同时满足：表中数据容量已经扩容到<code>MIN_TREEIFY_CAPACITY</code>这个长度，并且桶里的数据个数达到8个的时候，才会将该桶里的结构进行树化。注意扩容是数组的复制。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E7%BB%93%E6%9E%842.png" alt="image"></p><h5>4.2 Node结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code>是<code>HashMap</code>的一个内部类，实现了<code>Map.Entry</code>接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个<code>Node</code>对象。</p><p>例如程序执行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</span><br></pre></td></tr></table></figure><p>系统将调用&quot;美团&quot;这个<code>key</code>的<code>hashCode()</code>方法得到其<code>hashCode</code>值（该方法适用于每个<code>Java</code>对象）。</p><p>然后再通过<code>Hash</code>算法来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了<code>Hash</code>碰撞。</p><p>当然<code>Hash</code>算法计算结果越分散均匀，<code>Hash</code>碰撞的概率就越小，<code>map</code>的存取效率就会越高。</p><p>如果哈希桶数组很大，即使较差的<code>Hash</code>算法也会比较分散，如果哈希桶数组数组很小，即使好的<code>Hash</code>算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少<code>Hash</code>碰撞。</p><p><strong>那么通过什么方式来控制<code>map</code>使得<code>Hash</code>碰撞的概率又小，哈希桶数组（<code>Node[] table</code>）占用空间又少呢？答案就是好的<code>Hash</code>算法(5.4节)和扩容机制(5.5节)。下文会讲到。</strong></p><h2>五、方法</h2><h5>5.1 get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get方法主要调用的是getNode方法，所以重点要看getNode方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空 &amp;&amp; key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//是否直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//判断是否有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前的桶是采用红黑树处理冲突，则调用红黑树的get方法去获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该key</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现步骤大致如下：</p><ul><li>通过<code>hash</code>值获取该key映射到的桶。</li><li>桶上的<code>key</code>就是要查找的<code>key</code>，则直接命中。</li><li>桶上的<code>key</code>不是要查找的<code>key</code>，则查看后续节点：</li><li>如果后续节点是树节点，通过调用树的方法查找该<code>key</code>。</li><li>如果后续节点是链式节点，则通过循环遍历链查找该<code>key</code>。</li></ul><h5>5.2 put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法的具体实现也是在putVal方法中，所以我们重点看下面的putVal方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果哈希表为空，则先创建一个哈希表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果当前桶没有碰撞冲突，则直接把键值对插入，完事</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果桶上节点的key与当前key重复，那你就是我要找的节点了</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果是采用红黑树的方式处理冲突，则通过红黑树的putTreeVal方法去插入这个键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//否则就是传统的链式结构</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//采用循环遍历的方式，判断链中是否有重复的key</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//到了链尾还没找到重复的key，则说明HashMap没有包含该键</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                    <span class="comment">//创建一个新节点插入到尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果链的长度大于TREEIFY_THRESHOLD这个临界值，则把链变为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到了重复的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里表示在上面的操作中找到了重复的键，所以这里把该键的值替换为新值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断是否需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code>方法比较复杂，实现步骤大致如下：</p><ul><li>先通过<code>hash</code>值计算出<code>key</code>映射到哪个桶。</li><li>如果桶上没有碰撞冲突，则直接插入。</li><li>如果出现碰撞冲突了，则需要处理冲突：<ul><li>如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。</li><li>否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红黑树。</li></ul></li><li>如果桶中存在重复的键，则为该键替换新值。</li><li>如果<code>size</code>大于阈值，则进行扩容。</li></ul><p><img src="http://hashmap.oursnail.cn/hashmap%E6%89%A9%E5%AE%B9.jpg" alt="image"></p><h5>5.3 remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove方法的具体实现在removeNode方法中，所以我们重点看下面的removeNode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//如果当前key映射到的桶不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//如果桶上的节点就是要找的key，则直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是以红黑树处理冲突，则构建一个树节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//如果是以链式的方式处理冲突，则通过遍历链表来寻找节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比对找到的key的value跟要删除的是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//通过调用红黑树的方法来删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//使用链表的操作来删除节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>5.4 hash方法(确定哈希桶数组索引位置)</h5><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过<code>HashMap</code>的数据结构是数组和链表的结合，所以我们当然希望这个<code>HashMap</code>里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用<code>hash</code>算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。<code>HashMap</code>定位数组索引位置，直接决定了<code>hash</code>方法的离散性能。</p><p>注意<code>get</code>方法和<code>put</code>方法源码中都需要先计算<code>key</code>映射到哪个桶上，然后才进行之后的操作，计算的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>上面代码中的n指的是哈希表的大小，<code>hash</code>指的是<code>key</code>的哈希值，<code>hash</code>是通过下面这个方法计算出来的，采用了二次哈希的方式，其中<code>key的hashCode</code>方法是一个<code>native</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于任意给定的对象，只要它的<code>hashCode()</code>返回值相同，那么程序调用方法一所计算得到的<code>Hash</code>码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在<code>HashMap</code>中是这样做的：调用方法二来计算该对象应该保存在<code>table</code>数组的哪个索引处。</p><p>这个方法非常巧妙，它通过<code>h &amp; (table.length -1)</code>来得到该对象的保存位，而<code>HashMap</code>底层数组的长度总是2的n次方，这是<code>HashMap</code>在速度上的优化。当<code>length</code>总是2的n次方时，<code>h&amp; (length-1)</code>运算等价于对<code>length</code>取模，也就是<code>h%length</code>，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在数组<code>table</code>的<code>length</code>比较小的时候，也能保证考虑到高低<code>Bit</code>都参与到<code>Hash</code>的计算中，同时不会有太大的开销。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E6%89%A9%E5%AE%B92.jpg" alt="image"></p><blockquote><p>总结就是：由于在计算中位运算比取模运算效率高的多，所以 HashMap 规定数组的长度为 2^n 。这样用 2^n - 1 做位运算与取模效果一致，并且效率还要高出许多。这样回答了上文中：好的Hash算法到底是什么。</p></blockquote><h5>5.5 resize方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前容量超过最大容量，则无法进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没超过最大值则扩为原来的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的resize阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历旧哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果桶上只有一个键值对，则直接插入</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是通过红黑树来处理冲突的，则调用相关方法把树分离开</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果采用链式处理冲突</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//通过上面讲的方法来计算节点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashMap</code>在进行扩容时，使用的<code>rehash</code>方式非常巧妙，因为每次扩容都是翻倍，与原来计算<code>（n-1）&amp;hash</code>的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</p><p>例如，原来的容量为32，那么应该拿<code>hash</code>跟31（0x11111）做与操作；在扩容扩到了64的容量之后，应该拿<code>hash</code>跟63（0x111111）做与操作。新容量跟原来相比只是多了一个bit位，假设原来的位置在23，那么当新增的那个bit位的计算结果为0时，那么该节点还是在23；相反，计算结果为1时，则该节点会被分配到23+31的桶上。</p><p><strong>这样做的好处：正是因为这样巧妙的<code>rehash</code>方式，保证了<code>rehash</code>之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了<code>rehash</code>之后不会出现更严重的冲突。回答了上文中好的扩容机制。</strong></p><h2>六、总结</h2><ul><li><code>HashMap</code>的结构底层是一个数组，每个数组元素是一个桶，后面可能会连着一串因为碰撞而聚在一起的(key,value)节点，以链表的形式或者树的形式挂着</li><li>按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表的效率降低至O（n），而通过红黑树的方式，可以把效率改进至<code>O（logn）</code>。相比链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。</li><li><code>threshold</code>是数组长度扩容的临界值</li><li><code>modCount</code>字段主要用来记录HashMap内部结构发生变化的次数，这里结构变化必须是新的值塞进来或者某个值删除这种类型，而不是仅仅是覆盖</li><li>只有同时满足：表中数据容量已经扩容到<code>MIN_TREEIFY_CAPACITY</code>这个长度，并且桶里的数据个数达到8个的时候，才会将该桶里的结构进行树化。</li><li><strong>好的hash算法</strong>：由于在计算中位运算比取模运算效率高的多，所以<code>HashMap</code>规定数组的长度为 2^n 。这样用 <code>2^n - 1</code> 与 <code>hash</code> 做位运算与取模效果一致，并且效率还要高出许多。</li><li><strong>好的扩容机制</strong>：因为每次扩容都是翻倍，与原来计算<code>（n-1）&amp;hash</code>的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。这样做的好处：正是因为这样巧妙的rehash方式，保证了rehash之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了rehash之后不会出现更严重的冲突。</li><li>还有就是要记住<code>put</code>的过程。</li></ul><p>整理自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52649867" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52649867</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap基本是面试必问的点，因为这个数据结构用的太频繁了，jdk1.8中的优化也是比较巧妙。有必要去深入探讨一下。但是涉及的内容比较多，这里只先探讨jdk8中HashMap的实现，至于jdk7中HashMap的死循环问题、红黑树的原理等都不会在本篇文章扩展到。其他的文章将会再去探讨整理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java容器" scheme="http://yoursite.com/tags/java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
</feed>
