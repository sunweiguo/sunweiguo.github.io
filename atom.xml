<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-09T12:47:16.842Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类的初始化过程</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/09/JVM/类的初始化过程/</id>
    <published>2019-02-09T12:13:48.264Z</published>
    <updated>2019-02-09T12:47:16.842Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十一篇文章，其实在前面的文章中已经说到了类加载机制，但是为了本文的完整性，前面一部分还是重复地放在这里，后面会着重说明初始化过程。</p><a id="more"></a><h2>1. 类加载过程</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（<code>Loading</code>）、验证（<code>Verification</code>）、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>Using</code>)和卸载(<code>Unloading</code>)7个阶段。其中准备、验证、解析3个部分统称为连接（<code>Linking</code>）。如图所示：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" alt="image"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都以<code>HotSpot</code>为基准。</p><h2>2. 加载</h2><p><strong>在加载阶段</strong>（可以参考<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法），虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li></ul><p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h2>3. 验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>验证阶段大致会完成4个阶段的检验动作</strong>：</p><blockquote><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></blockquote><blockquote><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p></blockquote><blockquote><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></blockquote><blockquote><p>符号引用验证：确保解析动作能正确执行。</p></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2>4. 准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量<code>value</code>在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把<code>value</code>赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器()方法之中，所以把<code>value</code>赋值为123的动作将在初始化阶段才会执行。</p><p><strong>至于“特殊情况”是指</strong>：<code>public static final int value=123</code>，即当类字段的字段属性是<code>ConstantValue</code>时，会在准备阶段初始化为指定的值，所以标注为<code>final</code>之后，<code>value</code>的值在准备阶段初始化为123而非0.</p><h2>5. 解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h2>6. 初始化</h2><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程.</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，<strong>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        System.out.println(i);<span class="comment">//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么去掉报错的那句，改成下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        i=0;</span><br><span class="line">//      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i=1;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是什么呢？当然是1啦~在准备阶段我们知道i=0，然后类初始化阶段按照顺序执行，首先执行<code>static</code>块中的i=0,接着执行<code>static</code>赋值操作i=1,最后在main方法中获取i的值为1。</p><p><code>&lt;clinit&gt;()</code>方法与实例构造器<code>&lt;init&gt;()</code>方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<code>&lt;cinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕.</p><p>⭐由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p><p><code>&lt;clinit&gt;()</code>方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<code>&lt;clinit&gt;()</code>方法。</p><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。</p><p>虚拟机规范严格规定了<strong>有且只有</strong>5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><blockquote><ol><li>遇到 <code>new</code> , <code>getstatic</code> , <code>putstatic</code> , <code>invokestatic</code> 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：<strong>①使用new关键字实例化对象的时候</strong>、<strong>②读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候</strong>，以及<strong>③调用一个类的静态方法的时候</strong>。</li></ol></blockquote><blockquote><ol start="2"><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li></ol></blockquote><blockquote><ol start="3"><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li></ol></blockquote><blockquote><ol start="4"><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li></ol></blockquote><p>下面说明三种被动引用(除了上面提到的五种情况外，所有引用类的方法都不会触发初始化，成为被动引用)。</p><p><strong>第一种：通过子类引用父类的静态字段，不会导致子类初始化。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superclass static init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superclass static init</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>说明：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p><strong>第二种：通过数组定义来引用类，不会触发此类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter12;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SuperClass复用上面个代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：（无）</p><p>说明：从结果来看，显然没有触发类<code>chapter12.SuperClass</code>的初始化阶段，但是这段代码触发了另一个名叫 <code>&quot;[Lchapter12.SuperClass&quot;</code>的类的初始化阶段。这显然不是一个合法的类名称，他是由虚拟机自动生成的、直接继承于<code>java.lang.Object</code>的子类，创建动作由字节码制定<code>newarray</code>触发。</p><p>这个类代表了一个元素类型为<code>chapter12.SuperClass</code>的一维数组，数组中应有的属性和方法(用于可直接使用的只有被修饰为<code>public</code>的<code>length</code>属性和<code>clone()</code>方法)都实现在这个类里。Java语言中对数组的访问比<code>C/C++</code>相对安全是因为这个类封装了数组元素的访问方法，而<code>C/C++</code>     直接翻译为对数组指针的移动。</p><p><strong>第三种：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：hello world</p><p>说明：上述代码虽然在java源码中引用了<code>ConstClass</code>类中的常量<code>hello world</code>，但是其实在编译阶段通过常量传播优化，已经将此常量值<code>hello world</code>存储到了<code>NotInitialization</code>的常量池中，以后<code>NotInitialization</code>对常量<code>ConstClass.HELLOWORLD</code>的引用实际上都被转化为<code>NotInitialization</code>对自身常量池的引用了。</p><h2>7. 接口的加载</h2><p>接口的加载过程与类加载过程有一些不同，针对接口需要做一些特殊说明：</p><p>接口也有初始化过程，而接口中不能使用<code>static{}</code>语句块，但编译器仍然会为接口生成<code>&quot;&lt;clinit()&gt;&quot;</code>类构造器，用于初始化接口中所定义的成员变量。</p><p>接口与类真正所区别的是前面讲述的5种“有且仅有”情况的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个借口在初始化时，并不要求其父接口全部都已经完成了初始化，只有在真正用到父接口时（如引用接口中定义的常量）才会初始化。</p><h2>8. 例子巩固</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SSClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> <span class="keyword">extends</span> <span class="title">SSClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init SuperClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init SubClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SSClass</span><br><span class="line">SuperClass init!</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>说明：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><h2>9.总结java执行顺序</h2><p>举例立刻明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Children构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Children普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Children静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Children children = <span class="keyword">new</span> Children();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parent静态代码块</span><br><span class="line">Children静态代码块</span><br><span class="line">Parent普通代码块</span><br><span class="line">Parent构造函数</span><br><span class="line">Children普通代码块</span><br><span class="line">Children构造函数</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类静态块</span><br><span class="line">自身静态块</span><br><span class="line">父类块</span><br><span class="line">父类构造器</span><br><span class="line">自身块</span><br><span class="line">自身构造器</span><br></pre></td></tr></table></figure><h2>10. 总结java赋值顺序</h2><p>举例立刻明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag = <span class="string">"父类成员变量赋值"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"父类构造器---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"父类构造器赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"父类构造器---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类代码块---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"父类代码块赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"父类代码块---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag = <span class="string">"成员变量赋值"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类构造器---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"子类构造器赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"子类构造器---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类代码快---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"子类代码块赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"子类代码块---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类方法---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Children children = <span class="keyword">new</span> Children();</span><br><span class="line">        children.setFlag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">父类代码块---&gt;父类成员变量赋值</span><br><span class="line">父类代码块---&gt;父类代码块赋值</span><br><span class="line"></span><br><span class="line">父类构造器---&gt;父类代码块赋值</span><br><span class="line">父类构造器---&gt;父类构造器赋值</span><br><span class="line"></span><br><span class="line">子类代码快---&gt;成员变量赋值</span><br><span class="line">子类代码块---&gt;子类代码块赋值</span><br><span class="line"></span><br><span class="line">子类构造器---&gt;子类代码块赋值</span><br><span class="line">子类构造器---&gt;子类构造器赋值</span><br><span class="line"></span><br><span class="line">子类方法---&gt;子类构造器赋值</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">父类的静态变量赋值</span><br><span class="line">自身的静态变量赋值</span><br><span class="line"></span><br><span class="line">父类成员变量赋值</span><br><span class="line">父类块赋值</span><br><span class="line">父类构造器赋值</span><br><span class="line"></span><br><span class="line">自身成员变量赋值</span><br><span class="line">自身块赋值</span><br><span class="line">自身构造器赋值</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第十一篇文章，其实在前面的文章中已经说到了类加载机制，但是为了本文的完整性，前面一部分还是重复地放在这里，后面会着重说明初始化过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读5-Class文件中的方法表集合--method方法在class文件中是怎样组织的</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB5-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88--method%E6%96%B9%E6%B3%95%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读5-Class文件中的方法表集合--method方法在class文件中是怎样组织的/</id>
    <published>2019-02-09T11:40:07.123Z</published>
    <updated>2019-02-09T11:40:14.998Z</updated>
    
    <content type="html"><![CDATA[<p>继续讲class文件中的方法表集合。</p><a id="more"></a><h2>1. 方法表集合概述</h2><p>方法表集合是指由若干个方法表（method_info）组成的集合。对于在类中定义的若干个经过JVM编译成class文件后，会将相应的method方法信息组织到一个叫做方法表集合的结构中，字段表集合是一个类数组结构，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9591" alt="image"></p><h2>2. method方法的描述-方法表集合在class文件中的位置</h2><p>method方法的描述-方法表集合紧跟在字段表集合的后面，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9592" alt="image"></p><h2>3. 一个类中的method方法应该包含哪些信息？----method_info结构体的定义</h2><p>对于一个方法的表示，我们根据我们可以概括的信息如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9593" alt="image"></p><p>实际上JVM还会对method方法的描述添加其他信息，我们将在后面详细讨论。如上图中的method_info结构体的定义，该结构体的定义跟描述field字段 的field_info结构体的结构几乎完全一致,如下图所示。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9594" alt="image"></p><p>方法表的结构体由：访问标志(access_flags)、名称索引(name_index)、描述索引(descriptor_index)、属性表(attribute_info)集合组成。</p><p><strong>访问标志(access_flags)：</strong></p><p>method_info结构体最前面的两个字节表示的访问标志（access_flags），记录这这个方法的作用域、静态or非静态、可变性、是否可同步、是否本地方法、是否抽象等信息，实际上不止这些信息，我们后面会详细介绍访问标志这两个字节的每一位具体表示什么意思。</p><p><strong>名称索引(name_index)：</strong></p><p>紧跟在访问标志（access_flags）后面的两个字节称为名称索引，这两个字节中的值指向了常量池中的某一个常量池项，这个方法的名称以UTF-8格式的字符串存储在这个常量池项中。如public void methodName(),很显然，“methodName”则表示着这个方法的名称，那么在常量池中会有一个CONSTANT_Utf8_info格式的常量池项，里面存储着“methodName”字符串，而mehodName()方法的方法表中的名称索引则指向了这个常量池项。</p><p><strong>描述索引(descriptor_index)：</strong></p><p>描述索引表示的是这个方法的特征或者说是签名，一个方法会有若干个参数和返回值，而若干个参数的数据类型和返回值的数据类型构成了这个方法的描述，其基本格式为：     (参数数据类型描述列表)返回值数据类型   。我们将在后面继续讨论。</p><p><strong>属性表(attribute_info)集合：</strong></p><p>这个属性表集合非常重要，方法的实现被JVM编译成JVM的机器码指令，机器码指令就存放在一个Code类型的属性表中；如果方法声明要抛出异常，那么异常信息会在一个Exceptions类型的属性表中予以展现。Code类型的属性表可以说是非常复杂的内容，也是本文最难的地方。</p><h2>4. 访问标志(access_flags)—记录着method方法的访问信息</h2><p>访问标志（access_flags）共占有2 个字节，分为 16 位，这 16位 表示的含义如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9595" alt="image"></p><p><strong>举例：某个类中定义了如下方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>greeting()方法的修饰符有：public、static、synchronized、final 这几个修饰符修饰，那么相对应地，greeting()方法的访问标志中的ACC_PUBLIC、ACC_STATIC、ACC_SYNCHRONIZED、ACC_FINAL标志位都应该是1，即：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9596" alt="image"></p><p>从上图中可以看出访问标志的值应该是二进制00000000 00111001,即十六进制0x0039。我们将在文章的最后一个例子中证实这点。</p><h2>5. 名称索引和描述符索引----一个方法的签名</h2><p>紧接着访问标志（access_flags）后面的两个字节，叫做<strong>名称索引(name_index)</strong>，这两个字节中的值是指向了常量池中某个常量池项的索引，该常量池项表示这这个方法名称的字符串。</p><p><strong>方法描述符索引</strong>(descrptor_index)是紧跟在名称索引后面的两个字节，这两个字节中的值跟名称索引中的值性质一样，都是指向了常量池中的某个常量池项。这两个字节中的指向的常量池项，是表示了方法描述符的字符串。</p><p><strong>所谓的方法描述符，实质上就是指用一个什么样的字符串来描述一个方法</strong>，方法描述符的组成如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9597" alt="image"></p><p>举例：对于如下定义的的greeting()方法，我们来看一下对应的method_info结构体中的名称索引和描述符索引信息是怎样组织的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示,method_info结构体的名称索引中存储了一个索引值x，指向了常量池中的第x项，第 x项表示的是字符串&quot;greeting&quot;,即表示该方法名称是&quot;greeting&quot;；描述符索引中的y 值指向了常量池的第y项，该项表示字符串&quot;()V&quot;，即表示该方法没有参数，返回值是void类型。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9598" alt="image"></p><h2>6. 属性表集合–记录方法的机器指令和抛出异常等信息</h2><p>属性表集合记录了某个方法的一些属性信息，这些信息包括：</p><blockquote><ol><li>这个方法的代码实现，即方法的可执行的机器指令</li><li>这个方法声明的要抛出的异常信息</li><li>这个方法是否被@deprecated注解表示</li><li>这个方法是否是编译器自动生成的</li></ol></blockquote><p>属性表（attribute_info）结构体的一般结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9599" alt="image"></p><p><ins>修正：属性长度为4个字节。</ins></p><h3>6.1 Code类型的属性表–method方法中的机器指令的信息</h3><p>Code类型的属性表(attribute_info)可以说是class文件中最为重要的部分，因为它包含的是JVM可以运行的机器码指令，JVM能够运行这个类，就是从这个属性中取出机器码的。除了要执行的机器码，它还包含了一些其他信息，如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95910" alt="image"></p><p><strong>Code属性表的组成部分</strong>：</p><blockquote><p>机器指令----code：</p></blockquote><p>目前的JVM使用一个字节表示机器操作码，即对JVM底层而言，它能表示的机器操作码不多于2的 8 次方，即 256个。class文件中的机器指令部分是class文件中最重要的部分，并且非常复杂，本文的重点不止介绍它</p><blockquote><p>异常处理跳转信息—exception_table：</p></blockquote><p>如果代码中出现了try{}catch{}块，那么try{}块内的机器指令的地址范围记录下来，并且记录对应的catch{}块中的起始机器指令地址，当运行时在try块中有异常抛出的话，JVM会将catch{}块对应懂得其实机器指令地址传递给PC寄存器，从而实现指令跳转；</p><blockquote><p>Java源码行号和机器指令的对应关系—LineNumberTable属性表：</p></blockquote><p>编译器在将java源码编译成class文件时，会将源码中的语句行号跟编译好的机器指令关联起来，这样的class文件加载到内存中并运行时，如果抛出异常，JVM可以根据这个对应关系，抛出异常信息，告诉我们我们的源码的多少行有问题，方便我们定位问题。这个信息不是运行时必不可少的信息，但是默认情况下，编译器会生成这一项信息，如果你项取消这一信息，你可以使用-g:none 或-g:lines来取消或者要求设置这一项信息。如果使用了-g:none来生成class文件，class文件中将不会有LineNumberTable属性表，造成的影响就是 将来如果代码报错，将无法定位错误信息报错的行，并且如果项调试代码，将不能在此类中打断点（因为没有指定行号。）</p><blockquote><p>局部变量表描述信息----LocalVariableTable属性表：</p></blockquote><p>局部变量表信息会记录栈帧局部变量表中的变量和java源码中定义的变量之间的关系，这个信息不是运行时必须的属性，默认情况下不会生成到class文件中。你可以根据javac指令的-g:none或者-g:vars选项来取消或者设置这一项信息。<br>它有什么作用呢？  当我们使用IDE进行开发时，最喜欢的莫过于它们的代码提示功能了。如果在项目中引用到了第三方的jar包，而第三方的包中的class文件中有无LocalVariableTable属性表的区别如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95911" alt="image"></p><p><strong>Code属性表结构体的解释：</strong></p><ol><li><p>attribute_name_index,属性名称索引，占有2个字节，其内的值指向了常量池中的某一项，该项表示字符串“Code”;</p></li><li><p>attribute_length,属性长度，占有 4个字节，其内的值表示后面有多少个字节是属于此Code属性表的；</p></li><li><p>max_stack,操作数栈深度的最大值，占有 2 个字节，在方法执行的任意时刻，操作数栈都不应该超过这个值，虚拟机的运行的时候，会根据这个值来设置该方法对应的栈帧(Stack Frame)中的操作数栈的深度；</p></li><li><p>max_locals,最大局部变量数目，占有 2个字节，其内的值表示局部变量表所需要的存储空间大小；</p></li><li><p>code_length,机器指令长度，占有 4 个字节，表示跟在其后的多少个字节表示的是机器指令；</p></li><li><p>code,机器指令区域，该区域占有的字节数目由 code_length中的值决定。JVM最底层的要执行的机器指令就存储在这里；</p></li><li><p>exception_table_length,显式异常表长度，占有2个字节，如果在方法代码中出现了try{} catch()形式的结构，该值不会为空，紧跟其后会跟着若干个exception_table结构体，以表示异常捕获情况；</p></li><li><p>exception_table，显式异常表，占有8 个字节，start_pc,end_pc,handler_pc中的值都表示的是PC计数器中的指令地址。exception_table表示的意思是：如果字节码从第start_pc行到第end_pc行之间出现了catch_type所描述的异常类型，那么将跳转到handler_pc行继续处理。</p></li><li><p>attribute_count,属性计数器，占有 2 个字节，表示Code属性表的其他属性的数目</p></li><li><p>attribute_info,表示Code属性表具有的属性表，它主要分为两个类型的属性表：“LineNumberTable”类型和“LocalVariableTable”类型。<br>“LineNumberTable”类型的属性表记录着Java源码和机器指令之间的对应关系<br>“LocalVariableTable”类型的属性表记录着局部变量描述</p></li></ol><p><strong>举例：</strong></p><p>如下定义Simple类，使用javac -g:none Simple.java 编译出Simple.class 文件，并使用javap -v Simple &gt; Simple.txt 查看反编译的信息，然后看Simple.class文件中的方法表集合是怎样组织的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>1. Simple.class文件组织信息如下所示：</h4><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95912" alt="image"></p><p>如上所示，方法表集合使用了蓝色线段圈了起来。<br>请注意：方法表集合的头两个字节，即方法表计数器（method_count）的值是0x0002，它表示该类中有2 个方法。细心的读者会注意到，我们的Simple.java中就定义了一个greeting()方法，为什么class文件中会显示有两个方法呢？？</p><blockquote><p>JVM为没有显式定义实例化构造方法的类，自动生成默认的实例化构造方法&quot;<init>()&quot;</init></p></blockquote><p>除了实例化构造方法，JVM还会在特殊的情况下生成一个叫类构造方法&quot;<cinit>()&quot;。如果我们在类中使用到了static修饰的代码块，那么，JVM会在class文件中生成一个“<cinit>()”构造方法。关于它们的具体细节，我将在后续的文章中详细讨论，在这里就不展开了。</cinit></cinit></p><blockquote><ol start="2"><li>Simple.class 中的<init>() 方法:</init></li></ol></blockquote><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95913" alt="image"></p><p>解释：</p><ol><li><p>方法访问标志(access_flags)： 占有 2个字节，值为0x0001,即标志位的第 16 位为 1，所以该<init>()方法的修饰符是：ACC_PUBLIC;</init></p></li><li><p>名称索引(name_index)： 占有 2 个字节，值为 0x0004，指向常量池的第 4项，该项表示字符串“<init>”，即该方法的名称是“<init>”;</init></init></p></li><li><p>描述符索引(descriptor_index): 占有 2 个字节，值为0x0005,指向常量池的第 5 项，该项表示字符串“()V”，即表示该方法不带参数，并且无返回值（构造函数确实也没有返回值）；</p></li><li><p>属性计数器（attribute_count): 占有 2 个字节，值为0x0001,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；</p></li><li><p>属性表的名称索引(attribute_name_index)：占有 2 个字节，值为0x0006,指向常量池中的第6 项，该项表示字符串“Code”，表示这个属性表是Code类型的属性表；</p></li><li><p>属性长度（attribute_length）：占有4个字节，值为0x0000 0011，即十进制的 17，表明后续的 17 个字节可以表示这个Code属性表的属性信息；</p></li><li><p>操作数栈的最大深度（max_stack）：占有2个字节，值为0x0001,表示栈帧中操作数栈的最大深度是1；</p></li><li><p>局部变量表的最大容量（max_variable）：占有2个字节，值为0x0001, JVM在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；</p></li><li><p>机器指令数目(code_length)：占有4个字节，值为0x0000 0005,表示后续的5 个字节 0x2A 、0xB7、 0x00、0x01、0xB1表示机器指令;</p></li><li><p>机器指令集(code[code_length])：这里共有  5个字节，值为0x2A 、0xB7、 0x00、0x01、0xB1；</p></li><li><p>显式异常表集合（exception_table_count）： 占有2 个字节，值为0x0000,表示方法中没有需要处理的异常信息；</p></li><li><p>Code属性表的属性表集合（attribute_count）： 占有2 个字节，值为0x0000，表示它没有其他的属性表集合，因为我们使用了-g:none 禁止编译器生成Code属性表的 LineNumberTable 和LocalVariableTable;</p></li></ol><blockquote><p>B. Simple.class 中的greeting() 方法:</p></blockquote><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95914" alt="image"></p><p>解释：</p><ol><li><p>方法访问标志(access_flags)： 占有 2个字节，值为 0x0039 ,即二进制的00000000 00111001,即标志位的第11、12、13、16位为1，根据上面讲的方法标志位的表示，可以得到该greeting()方法的修饰符有：ACC_SYNCHRONIZED、ACC_FINAL、ACC_STATIC、ACC_PUBLIC;</p></li><li><p>名称索引(name_index)： 占有 2 个字节，值为 0x0007，指向常量池的第 7 项，该项表示字符串“greeting”，即该方法的名称是“greeting”;</p></li><li><p>描述符索引(descriptor_index): 占有 2 个字节，值为0x0005,指向常量池的第 5 项，该项表示字符串“()V”，即表示该方法不带参数，并且无返回值；</p></li><li><p>属性计数器（attribute_count): 占有 2 个字节，值为0x0001,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；</p></li><li><p>属性表的名称索引(attribute_name_index)：占有 2 个字节，值为0x0006,指向常量池中的第6 项，该项表示字符串“Code”，表示这个属性表是Code类型的属性表；</p></li><li><p>属性长度（attribute_length）：占有4个字节，值为0x0000 0010，即十进制的16，表明后续的16个字节可以表示这个Code属性表的属性信息；</p></li><li><p>操作数栈的最大深度（max_stack）：占有2个字节，值为0x0001,表示栈帧中操作数栈的最大深度是1；</p></li><li><p>局部变量表的最大容量（max_variable）：占有2个字节，值为0x0001, JVM在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；</p></li><li><p>机器指令数目(code_length)：占有4 个字节，值为0x0000 0004,表示后续的4个字节0x10、 0x0A、 0x3B、0xB1的是表示机器指令;</p></li><li><p>机器指令集(code[code_length])：这里共有4 个字节，值为0x10、 0x0A、 0x3B、0xB1 ；</p></li><li><p>显式异常表集合（exception_table_count）： 占有2 个字节，值为0x0000,表示方法中没有需要处理的异常信息；</p></li><li><p>Code属性表的属性表集合（attribute_count）： 占有2 个字节，值为0x0000，表示它没有其他的属性表集合，因为我们使用了-g:none 禁止编译器生成Code属性表的 LineNumberTable 和LocalVariableTable;</p></li></ol><h3>6.2 Exceptions类型的属性表----method方法声明的要抛出的异常信息</h3><p>有些方法在定义的时候，会声明该方法会抛出什么类型的异常，如下定义一个Interface接口，它声明了sayHello()方法，抛出Exception异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们看一下Exceptions类型的属性表(attribute_info)结构体是怎样组织的：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95915" alt="image"></p><p>如上图所示，Exceptions类型的属性表(attribute_info)结构体由一下元素组成：</p><p>属性名称索引(attribute_name_index)：占有 2个字节，其中的值指向了常量池中的表示&quot;Exceptions&quot;字符串的常量池项；</p><p>属性长度(attribute_length)：它比较特殊，占有4个字节，它的值表示跟在其后面多少个字节表示异常信息；</p><p>异常数量(number_of_exceptions)：占有2 个字节，它的值表示方法声明抛出了多少个异常，即表示跟在其后有多少个异常名称索引；</p><p>异常名称索引(exceptions_index_table)：占有2个字节，它的值指向了常量池中的某一项，该项是一个CONSTANT_Class_info类型的项，表示这个异常的完全限定名称；</p><p><strong>Exceptions类型的属性表的长度计算</strong></p><p>如果某个方法定义中，没有声明抛出异常，那么，表示该方法的方法表(method_info)结构体中的属性表集合中不会有Exceptions类型的属性表；换句话说，如果方法声明了要抛出的异常，方法表(method_info)结构体中的属性表集合中必然会有Exceptions类型的属性表，并且该属性表中的异常数量不小于1。<br>我们假设异常数量中的值为 N，那么后面的异常名称索引的数量就为N，它们总共占有的字节数为N*2，而异常数量占有2个字节，那么将有下面的这个关系式：</p><blockquote><p>属性长度(attribute_length)中的值= 2  + 2*异常数量(number_of_exceptions)中的值</p></blockquote><blockquote><p>Exceptions类型的属性表（attribute_info）的长度=2+4+属性长度(attribute_length)中的值</p></blockquote><p><strong>举例：</strong><br>将上面定义的Interface接口类编译成class文件，然后我们查看Interface.class文件，找出方法表集合所在位置和相应的数据，并辅助javap -v  Inerface 查看</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95916" alt="image"></p><p>由于sayHello()方法是在的Interface接口类中声明的，它没有被实现，所以它对应的方法表(method_info)结构体中的属性表集合中没有Code类型的属性表。</p><ol><li><p>方法计数器（methods_count）中的值为0x0001，表明其后的方法表(method_info)就一个,即我们就定义了一个方法，其后会紧跟着一个方法表(method_info)结构体；</p></li><li><p>方法的访问标志（access_flags）的值是0x0401，二进制是00000100 00000001,第6位和第16位是1，对应上面的标志位信息，可以得出它的访问标志符有：ACC_ABSTRACT、ACC_PUBLIC。细心的读者可能会发现，在上面声明的sayHello()方法中并没有声明为abstract类型啊。确实如此，这是因为编译器对于接口内声明的方法自动加上ACC_ABSTRACT标志。</p></li><li><p>名称索引（name_index）中的值为0x0005，0x0005指向了常量池的第5项，第五项表示的字符串为“sayHello”，即表示的方法名称是sayHello</p></li><li><p>描述符索引(descriptor_index)中的值为0x0006,0x0006指向了常量池中的第6项，第6项表示的字符串为“()V” 表示这个方法的无入参，返回值为void类型</p></li><li><p>属性表计数器(attribute_count)中的值为0x0001,表示后面的属性表的个数就1个，后面紧跟着一个attribute_info结构体；</p></li><li><p>属性表（attribute_info）中的属性名称索引(attribute_name_index)中的值为0x0007，0x0007指向了常量池中的第7 项，第 7项指向字符串“Exceptions”，即表示该属性表表示的异常信息；</p></li><li><p>属性长度（attribute_length）中的值为：0x00000004,即后续的4个字节将会被解析成属性值；</p></li><li><p>异常数量（number_of_exceptions）中的值为0x0001,表示这个方法声明抛出的异常个数是1个；</p></li><li><p>异常名称索引(exception_index_table)中的值为0x0008,指向了常量池中的第8项，第8项表示的是CONSTANT_Class_info类型的常量池项，表示“java/lang/Exception”，即表示此方法抛出了java.lang.Exception异常。</p></li></ol><h2>7. IDE代码提示功能实现的基本原理</h2><p>每个IDE都提供了代码提示功能，它们实现的基本原理其实就是IDE针对它们项目下的包中所有的class文件进行建模，解析出它们的方法信息，当我们一定的条件时，IDE会自动地将合适条件的方法列表展示给开发者，供开发者使用。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95917" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续讲class文件中的方法表集合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读4-Class文件中的字段表集合--field字段在class文件中是怎样组织的</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB4-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88--field%E5%AD%97%E6%AE%B5%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读4-Class文件中的字段表集合--field字段在class文件中是怎样组织的/</id>
    <published>2019-02-09T11:38:35.969Z</published>
    <updated>2019-02-09T11:38:52.544Z</updated>
    
    <content type="html"><![CDATA[<p>继续讲class文件中的字段表集合。</p><a id="more"></a><h2>1. 字段表集合概述</h2><p>字段表集合是指由若干个字段表（field_info）组成的集合。对于在类中定义的若干个字段，经过JVM编译成class文件后，会将相应的字段信息组织到一个叫做字段表集合的结构中，字段表集合是一个类数组结构，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B581" alt="image"></p><p>注意：这里所讲的字段是指在类中定义的静态或者非静态的变量，而不是在类中的方法内定义的变量。请注意区别。<br>比如，如果某个类中定义了5个字段，那么，JVM在编译此类的时候，会生成5个字段表（field_info）信息,然后将字段表集合中的字段计数器的值设置成5，将5个字段表信息依次放置到字段计数器的后面。</p><h2>2. 字段表集合在class文件中的位置</h2><p>字段表集合紧跟在class文件的接口索引集合结构的后面，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B582" alt="image"></p><h2>3.  Java中的一个Field字段应该包含那些信息？------字段表field_info结构体的定义</h2><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B583" alt="image"></p><p>针对上述的字段表示，JVM虚拟机规范规定了field_info结构体来描述字段，其表示信息如下：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B584" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B585" alt="image"></p><p>下面我将一一讲解FIeld_info的组成元素：访问标志（access_flags）、名称索引（name_index）、描述索引（descriptor_index）、属性表集合</p><h2>4. field字段的访问标志</h2><p>如上图所示定义的field_info结构体，field字段的访问标志(access_flags)占有两个字节，它能够表述的信息如下所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B586" alt="image"></p><p>举例：如果我们在某个类中有定义field域：private static String str;，那么在访问标志上，第15位ACC_PRIVATE和第13位ACC_STATIC标志位都应该为1。field域str的访问标志信息应该是如下所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B587" alt="image"></p><h2>5. 字段的数据类型表示和字段名称表示</h2><p>class文件对数据类型的表示如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B588" alt="image"></p><p>field字段名称，我们定义了一个形如private static String str的field字段，其中&quot;str&quot;就是这个字段的名称。<br>class文件将字段名称和field字段的数据类型表示作为字符串存储在常量池中。在field_info结构体中，紧接着访问标志的，就是字段名称索引和字段描述符索引，它们分别占有两个字节，其内部存储的是指向了常量池中的某个常量池项的索引，对应的常量池项中存储的字符串，分别表示该字段的名称和字段描述符。</p><h2>6. 属性表集合-----静态field字段的初始化</h2><p>在定义field字段的过程中，我们有时候会很自然地对field字段直接赋值，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX=<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>对于虚拟机而言，上述的两个field字段赋值的时机是不同的：</p><blockquote><p>对于非静态（即无static修饰）的field字段的赋值将会出现在实例构造方法<init>()中</init></p></blockquote><blockquote><p>对于静态的field字段，有两个选择：1、在静态构造方法<cinit>()中进行；2 、使用ConstantValue属性进行赋值</cinit></p></blockquote><p>Sun javac编译器对于静态field字段的初始化赋值策略：</p><blockquote><p>如果使用final和static同时修饰一个field字段，并且这个字段是基本类型或者String类型的，那么编译器在编译这个字段的时候，会在对应的field_info结构体中增加一个ConstantValue类型的结构体，在赋值的时候使用这个ConstantValue进行赋值；</p></blockquote><blockquote><p>如果该field字段并没有被final修饰，或者不是基本类型或者String类型，那么将在类构造方法<cinit>()中赋值。</cinit></p></blockquote><p>对于上述的public static final init MAX=100：</p><blockquote><p>javac编译器在编译此field字段构建field_info结构体时，除了访问标志、名称索引、描述符索引外，会增加一个ConstantValue类型的属性表。</p></blockquote><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B589" alt="image"></p><h2>7. 实例解析</h2><p>定义如下一个简单的Simple类，然后通过查看Simple.class文件内容并结合javap -v Simple 生成的常量池内容，分析str field字段的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">transient</span> <span class="keyword">static</span> <span class="keyword">final</span> String str =<span class="string">"This is a test"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B5810" alt="image"></p><blockquote><ol><li>字段计数器中的值为0x0001,表示这个类就定义了一个field字段</li></ol></blockquote><blockquote><ol start="2"><li>字段的访问标志是0x009A,二进制是00000000 10011010，即第9、12、13、15位标志位为1，这个字段的标志符有：ACC_TRANSIENT、ACC_FINAL、ACC_STATIC、ACC_PRIVATE;</li></ol></blockquote><blockquote><ol start="3"><li>名称索引中的值为0x0005,指向了常量池中的第5项，为“str”,表明这个field字段的名称是str；</li></ol></blockquote><blockquote><ol start="4"><li>描述索引中的值为0x0006,指向了常量池中的第6项，为&quot;Ljava/lang/String;&quot;，表明这个field字段的数据类型是java.lang.String类型；</li></ol></blockquote><blockquote><p>5.属性表计数器中的值为0x0001,表明field_info还有一个属性表；</p></blockquote><blockquote><p>6.属性表名称索引中的值为0x0007,指向常量池中的第7项，为“ConstantValue”,表明这个属性表的名称是ConstantValue，即属性表的类型是ConstantValue类型的；</p></blockquote><blockquote><p>7.属性长度中的值为0x0002，因为此属性表是ConstantValue类型，它的值固定为2；</p></blockquote><blockquote><p>8.常量值索引 中的值为0x0008,指向了常量池中的第8项，为CONSTANT_String_info类型的项，表示“This is a test” 的常量。在对此field赋值时，会使用此常量对field赋值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续讲class文件中的字段表集合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读3-Class文件中的访问标志、类索引、父类索引、接口索引集合</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB3-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读3-Class文件中的访问标志、类索引、父类索引、接口索引集合/</id>
    <published>2019-02-09T11:37:12.949Z</published>
    <updated>2019-02-09T11:37:24.227Z</updated>
    
    <content type="html"><![CDATA[<p>讲完了class文件中的常量池，我们就相当于克服了class文件中最麻烦的模块了。现在，我们来看一下class文件中紧接着常量池后面的几个东西：访问标志、类索引、父类索引、接口索引集合。</p><a id="more"></a><h2>1. 访问标志、类索引、父类索引、接口索引集合 在class文件中的位置</h2><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%20%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE" alt="image"></p><h2>2. 访问标志(access_flags)能够表示什么？</h2><p>访问标志（access_flags）紧接着常量池后，占有两个字节，总共16位，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%28access_flags%29%E8%83%BD%E5%A4%9F%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F" alt="image"></p><p>当JVM在编译某个类或者接口的源代码时，JVM会解析出这个类或者接口的访问标志信息，然后，将这些标志设置到访问标志（access_flags）这16个位上。JVM会考虑如下设置如下访问表示信息：</p><h4>a. 类或接口</h4><p>我们知道，每个定义的类或者接口都会生成class文件（这里也包括内部类，在某个类中定义的静态内部类也会单独生成一个class文件）。</p><blockquote><p>对于定义的类，JVM在将其编译成class文件时，会将class文件的访问标志的第11位设置为1 。第11位叫做ACC_SUPER标志位；</p></blockquote><blockquote><p>对于定义的接口，JVM在将其编译成class文件时，会将class文件的访问标志的第8位 设置为 1 。第8位叫做ACC_INTERFACE标志位；</p></blockquote><h4>b. 访问权限：public类型和包package类型。</h4><p>如果类或者接口被声明为public类型的，那么，JVM将其编译成class文件时，会将class文件的访问标志的第16位设置为1 。第16位叫做ACC_PUBLIC标志符；</p><h4>c. 类是否为抽象类型的，即我们定义的类有没有被abstract关键字修饰，即我们定义的类是否为抽象类。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;......&#125;</span><br></pre></td></tr></table></figure><p>定义某个类时，JVM将它编译成class文件的时候，会将class文件的访问标志的第7位设置为1 。第7位叫做ACC_ABSTRACT标志位。</p><p>另外值得注意的是，对于定义的接口，JVM在编译接口的时候也会对class文件的访问标志上的ACC_ABSTRACT标志位设置为 1；</p><h4>d. 该类是否被声明了final类型,即表示该类不能被继承。</h4><p>此时JVM会在编译class文件的过程中，会将class文件的访问标志的第12位设置为 1 。第12位叫做ACC_FINAL标志位；</p><h4>e.是否是JVM通过java源代码文件编译而成的</h4><p>如果我们这个class文件不是JVM通过java源代码文件编译而成的，而是用户自己通过class文件的组织规则生成的，那么，一般会对class文件的访问标志第4位设置为 1 。通过JVM编译源代码产生的class文件此标志位为 0，第4位叫做ACC_SYNTHETIC标志位；</p><h4>f. 枚举类</h4><p>对于定义的枚举类如：public enum EnumTest{…}，JVM也会对此枚举类编译成class文件，这时，对于这样的class文件，JVM会对访问标志第2位设置为 1 ，以表示它是枚举类。第2位叫做ACC_ENUM标志位；</p><h4>g. 注解类</h4><p>对于定义的注解类如：public @interface{…},JVM会对此注解类编译成class文件，对于这样的class文件，JVM会将访问标志第3位设置为1，以表示这是个注解类，第3位叫做ACC_ANNOTATION标志位。</p><p>当JVM确定了上述标志位的值后，就可以确定访问标志（access_flags）的值了。实际上JVM上述标志会根据上述确定的标志位的值，对这些标志位的值取或，便得到了访问标志（access_flags）。如下图所示:</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97" alt="image"></p><h4>举例</h4><p>定义一个最简单的类Simple.java，使用编译器编译成class文件，然后观察class文件中的访问标志的值，以及使用javap -v Simple 查看访问标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用UltraEdit查看编译成的class文件，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%972" alt="image"></p><p>上述的图中黄色部分表示的是常量池部分,常量池后面紧跟着就是访问标志，它的十六进制值为0x0021,二进制的值为：00000000 00100001，由二进制的1的位数可以得出第11、16位为1，分别对应ACC_SUPER标志位和ACC_PUBLIC标志位。验证一下:</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%973" alt="image"></p><h2>3. 类索引(this_class)是什么？</h2><p>我们知道一般情况下一个Java类源文件经过JVM编译会生成一个class文件，也有可能一个Java类源文件中定义了其他类或者内部类，这样编译出来的class文件就不止一个，但每一个class文件表示某一个类，至于这个class表示哪一个类，便可以通过 类索引 这个数据项来确定。JVM通过类的完全限定名确定是某一个类。</p><p><strong>类索引的作用，就是为了指出class文件所描述的这个类叫什么名字。</strong></p><p>类索引紧接着访问标志的后面，占有两个字节，在这两个字节中存储的值是一个指向常量池的一个索引，该索引指向的是CONSTANT_Class_info常量池项.</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%951" alt="image"></p><p>以上面定义的Simple.class 为例，如下图所示，查看他的类索引在什么位置和取什么值。</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%952" alt="image"></p><p>由上可知，它的类索引值为0x0001,那么，它指向了常量池中的第一个常量池项，那我们再看一下常量池中的信息。使用javap -v Simple,常量池中有以下信息：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%953" alt="image"></p><p>可以看到常量池中的第一项是CONSTANT_Class_info项，它表示一个&quot;com/louis/jvm/Simple&quot;的类名。即类索引是告诉我们这个class文件所表示的是哪一个类。</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%954" alt="image"></p><h2>4. 父类索引(super_class)是什么？</h2><p>Java支持单继承模式，除了java.lang.Object 类除外，每一个类都会有且只有一个父类。class文件中紧接着类索引(this_class)之后的两个字节区域表示父类索引，跟类索引一样，父类索引这两个字节中的值指向了常量池中的某个常量池项CONSTANT_Class_info，表示该class表示的类是继承自哪一个类。</p><p><img src="http://javajvm.oursnail.cn/%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95" alt="image"></p><h2>5. 接口索引集合(interfaces)是什么？</h2><p>一个类可以不实现任何接口，也可以实现很多个接口，为了表示当前类实现的接口信息，class文件使用了如下结构体描述某个类的接口实现信息:</p><p><img src="http://javajvm.oursnail.cn/%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95" alt="image"></p><p>由于类实现的接口数目不确定，所以接口索引集合的描述的前部分叫做接口计数器（interfaces_count），接口计数器占用两个字节，其中的值表示着这个类实现了多少个接口，紧跟着接口计数器的部分就是接口索引部分了，每一个接口索引占有两个字节，接口计数器的值代表着后面跟着的接口索引的个数。接口索引和类索引和父类索引一样，其内的值存储的是指向了常量池中的常量池项的索引，表示着这个接口的完全限定名。</p><p><strong>举例：</strong></p><p>定义一个Worker接口，然后类Programmer实现这个Worker接口，然后我们观察Programmer的接口索引集合是怎样表示的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">implements</span> <span class="title">Worker</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I'm Programmer,Just coding...."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%954" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲完了class文件中的常量池，我们就相当于克服了class文件中最麻烦的模块了。现在，我们来看一下class文件中紧接着常量池后面的几个东西：访问标志、类索引、父类索引、接口索引集合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读2-Class文件中的常量池</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB2-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读2-Class文件中的常量池/</id>
    <published>2019-02-09T11:35:04.972Z</published>
    <updated>2019-02-09T11:35:16.666Z</updated>
    
    <content type="html"><![CDATA[<p>上一节Class类文件结构大致地介绍了class文件的组织结构，接下来，我们将深入每一个结构，来详细了解它们。这一章节呢，我们就来扒一扒class文件中非常重要 的一个数据区域------常量池。它在JVM虚拟机中扮演了非常重要的地位。</p><a id="more"></a><p>本篇内容来自于<a href="http://blog.csdn.net/luanlouis/article/details/40148053" target="_blank" rel="noopener">java虚拟机原理图解</a>，自己一边理解一边进行复制整理得此文章，<strong>也是看了很多遍，逐渐地好像懂了常量池怎么玩的，所以一定要坚持，读不懂多读几遍一定可以读懂的。</strong></p><p>本篇文章内容过多，这里将目录列举在此。</p><blockquote><ol><li>常量池是什么</li><li>常量池在class文件的什么位置？</li><li>常量池里面是怎么组织的？</li><li>常量池项 (cp_info) 的结构是什么？</li><li>常量池能够表示哪些信息？</li><li>int和float数据类型的常量在常量池中是怎样表示和存储的？</li><li>long和 double数据类型的常量在常量池中是怎样表示和存储的？</li><li>String类型的字符串常量在常量池中是怎样表示和存储的？</li><li>类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？</li><li>类中引用到的field字段在常量池中是怎样描述的？</li><li>类中引用到的method方法在常量池中是怎样描述的？</li><li>类中引用到某个接口中定义的method方法在常量池中是怎样描述的？</li><li>更好地支持动态语言所增加的三项</li></ol></blockquote><hr><h2>1. 常量池是什么</h2><p>可以理解为class文件之中的资源仓库，它是class文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据项目之一，同时它还是class文件中第一个出现表类型的数据项目．</p><p>由于常量池的数量是不固定的，所以在常量池入口需要放置一项u2（即２个字节）类型的数据，代表常量池容量计数值（constant-pool-count）(从１开始，将０表示不引用任何常量).</p><p>常量池中主要存放两大类常量：<strong>字面量（Literal）和符号引用(Synbolic Reference)</strong>．</p><p>字面量：比较接近于Java语言层面的常量概念，如文本字符串，声明为final的常量值.</p><p>符号引用：包括如下三类常量：</p><blockquote><ol><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ol></blockquote><h2>2. 常量池在class文件的什么位置？</h2><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BD%8D%E7%BD%AE" alt="image"></p><h2>3. 常量池的里面是怎么组织的？</h2><p>常量池的组织很简单，前端的两个字节占有的位置叫做常量池计数器(constant_pool_count)，它记录着常量池的组成元素  常量池项(cp_info) 的个数。紧接着会排列着constant_pool_count-1个常量池项(cp_info)。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%84%E7%BB%87" alt="image"></p><h2>4. 常量池项 (cp_info) 的结构是什么？</h2><p>每个常量池项(cp_info) 都会对应记录着class文件中的某种类型的字面量。让我们先来了解一下常量池项(cp_info)的结构吧：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%93%E6%9E%84" alt="image"></p><p>JVM虚拟机规定了不同的tag值和不同类型的字面量对应关系如下：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%842" alt="image"></p><p>所以根据cp_info中的tag 不同的值，可以将cp_info 更细化为以下结构体：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%843" alt="image"></p><p>现在让我们看一下细化了的常量池的结构会是类似下图所示的样子：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%844" alt="image"></p><h2>5. 常量池能够表示那些信息？</h2><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%83%BD%E5%A4%9F%E8%A1%A8%E7%A4%BA%E9%82%A3%E4%BA%9B%E4%BF%A1%E6%81%AF" alt="image"></p><h2>6. int和float数据类型的常量在常量池中是怎样表示和存储的？(CONSTANT_Integer_info, CONSTANT_Float_info)</h2><p>Java语言规范规定了 int类型和Float 类型的数据类型占用 4 个字节的空间。那么存在于class字节码文件中的该类型的常量是如何存储的呢？相应地，在常量池中，将 int和Float类型的常量分别使用CONSTANT_Integer_info和 Constant_float_info表示，他们的结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" alt="image"></p><p>举例：建下面的类 IntAndFloatTest.java，在这个类中，我们声明了五个变量，但是取值就两种int类型的10 和Float类型的11f.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntAndFloatTest</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> c = <span class="number">11f</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> d = <span class="number">11f</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> e = <span class="number">11f</span>;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用编译器编译成IntAndFloatTest.class字节码文件，我们通过javap -v IntAndFloatTest 指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了两次10 和三次11f，但是常量池中，就只有一个常量10 和一个常量11f,如下图所示:</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2" alt="image"></p><p>从结果上可以看到常量池第#8 个常量池项(cp_info) 就是CONSTANT_Integer_info,值为10；第#23个常量池项(cp_info) 就是CONSTANT_Float_info,值为11f。</p><p>代码中所有用到 int 类型 10 的地方，会使用指向常量池的指针值#8 定位到第#8 个常量池项(cp_info)，即值为 10的结构体 CONSTANT_Integer_info，而用到float类型的11f时，也会指向常量池的指针值#23来定位到第#23个常量池项(cp_info) 即值为11f的结构体CONSTANT_Float_info。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B3" alt="image"></p><h2>7. long和 double数据类型的常量在常量池中是怎样表示和存储的？(CONSTANT_Long_info、CONSTANT_Double_info )</h2><p>Java语言规范规定了 long 类型和 double类型的数据类型占用8 个字节的空间。那么存在于class 字节码文件中的该类型的常量是如何存储的呢？相应地，在常量池中，将long和double类型的常量分别使用CONSTANT_Long_info和Constant_Double_info表示，他们的结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/long%E5%92%8C%20double%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" alt="image"></p><p>代码中所有用到 long 类型-6076574518398440533L 的地方，会使用指向常量池的指针值#18 定位到第 #18 个常量池项(cp_info)，即值为-6076574518398440533L 的结构体CONSTANT_Long_info，而用到double类型的10.1234567890D时，也会指向常量池的指针值#26 来定位到第 #26 个常量池项(cp_info) 即值为10.1234567890D的结构体CONSTANT_Double_info。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/long%E5%92%8C%20double%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2" alt="image"></p><h2>8. String类型的字符串常量在常量池中是怎样表示和存储的？（CONSTANT_String_info、CONSTANT_Utf8_info）</h2><p>对于字符串而言，JVM会将字符串类型的字面量以UTF-8 编码格式存储到在class字节码文件中。这么说可能有点摸不着北，我们先从直观的Java源码中中出现的用双引号&quot;&quot; 括起来的字符串来看，在编译器编译的时候，都会将这些字符串转换成CONSTANT_String_info结构体，然后放置于常量池中。其结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B" alt="image"></p><p>如上图所示的结构体，CONSTANT_String_info结构体中的string_index的值指向了CONSTANT_Utf8_info结构体，而字符串的utf-8编码数据就在这个结构体之中。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B" alt="image"></p><p>请看一例，定义一个简单的StringTest.java类，然后在这个类里加一个&quot;JVM原理&quot; 字符串，然后，我们来看看它在class文件中是怎样组织的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String s1 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s2 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s3 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s4 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B3" alt="image"></p><p>在上面的图中，我们可以看到CONSTANT_String_info结构体位于常量池的第#15个索引位置。而存放&quot;Java虚拟机原理&quot; 字符串的 UTF-8编码格式的字节数组被放到CONSTANT_Utf8_info结构体中，该结构体位于常量池的第#16个索引位置。上面的图只是看了个轮廓，让我们再深入地看一下它们的组织吧。请看下图：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B4" alt="image"></p><h2>9. 类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？(CONSTANT_Class_info)</h2><p>JVM会将某个Java 类中所有使用到了的类的完全限定名 以二进制形式的完全限定名 封装成CONSTANT_Class_info结构体中，然后将其放置到常量池里。CONSTANT_Class_info 的tag值为 7 。其结构如下：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B61" alt="image"></p><p><strong>类的完全限定名和二进制形式的完全限定名</strong></p><p>在某个Java源码中，我们会使用很多个类，比如我们定义了一个 ClassTest的类，并把它放到com.louis.jvm 包下，则 ClassTest类的完全限定名为com.louis.jvm.ClassTest，将JVM编译器将类编译成class文件后，此完全限定名在class文件中，是以二进制形式的完全限定名存储的，即它会把完全限定符的&quot;.“换成”/&quot; ，即在class文件中存储的 ClassTest类的完全限定名称是&quot;com/louis/jvm/ClassTest&quot;。因为这种形式的完全限定名是放在了class二进制形式的字节码文件中，所以就称之为 二进制形式的完全限定名。</p><p>举例，我们定义一个很简单的ClassTest类，来看一下常量池是怎么对类的完全限定名进行存储的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Date date =<span class="keyword">new</span> Date();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B62" alt="image"></p><p>如上图所示，在ClassTest.class文件的常量池中，共有 3 个CONSTANT_Class_info结构体，分别表示ClassTest 中用到的Class信息。 我们就看其中一个表示com/jvm.ClassTest的CONSTANT_Class_info 结构体。它在常量池中的位置是#1，它的name_index值为#2，它指向了常量池的第2 个常量池项，如下所示:</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B63" alt="image"></p><p>注意：</p><p>对于某个类而言，其class文件中至少要有两个CONSTANT_Class_info常量池项，用来表示自己的类信息和其父类信息。(除了java.lang.Object类除外，其他的任何类都会默认继承自java.lang.Object）如果类声明实现了某些接口，那么接口的信息也会生成对应的CONSTANT_Class_info常量池项。</p><p>除此之外，如果在类中使用到了其他的类，只有真正使用到了相应的类，JDK编译器才会将类的信息组成CONSTANT_Class_info常量池项放置到常量池中。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Date date;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Other</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        Date da;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的Other的类，在JDK将其编译成class文件时，常量池中并没有java.util.Date对应的CONSTANT_Class_info常量池项，为什么呢?</p><p>在Other类中虽然定义了Date类型的两个变量date、da，但是JDK编译的时候，认为你只是声明了“Ljava/util/Date”类型的变量，并没有实际使用到Ljava/util/Date类。将类信息放置到常量池中的目的，是为了在后续的代码中有可能会反复用到它。很显然，JDK在编译Other类的时候，会解析到Date类有没有用到，发现该类在代码中就没有用到过，所以就认为没有必要将它的信息放置到常量池中了。</p><p>将上述的Other类改写一下，仅使用new Date()，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Other</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Date();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ol><li>对于某个类或接口而言，其自身、父类和继承或实现的接口的信息会被直接组装成CONSTANT_Class_info常量池项放置到常量池中；</li><li>类中或接口中使用到了其他的类，只有在类中实际使用到了该类时，该类的信息才会在常量池中有对应的CONSTANT_Class_info常量池项；</li><li>类中或接口中仅仅定义某种类型的变量，JDK只会将变量的类型描述信息以UTF-8字符串组成CONSTANT_Utf8_info常量池项放置到常量池中，上面在类中的private Date date;JDK编译器只会将表示date的数据类型的“Ljava/util/Date”字符串放置到常量池中。</li></ol></blockquote><h2>10. 类中引用到的field字段在常量池中是怎样描述的？(CONSTANT_Fieldref_info, CONSTANT_Name_Type_info)</h2><p>一般而言，我们在定义类的过程中会定义一些 field 字段，然后会在这个类的其他地方（如方法中）使用到它。有可能我们在类的方法中只使用field字段一次，也有可能我们会在类定义的方法中使用它很多很多次。</p><p>举一个简单的例子，我们定一个叫Person的简单java bean，它有name和age两个field字段，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面定义的类中，我们在Person类中的一系列方法里，多次引用到namefield字段 和agefield字段，对于JVM编译器而言，name和age只是一个符号而已，并且它在由于它可能会在此类中重复出现多次，所以JVM把它当作常量来看待，将name和age以field字段常量的形式保存到常量池中。</p><p>将它name和age封装成 CONSTANT_Fieldref_info 常量池项，放到常量池中，在类中引用到它的地方，直接放置一个指向field字段所在常量池的索引。</p><p>上面的Person类，使用javap -v Person指令，查看class文件的信息，你会看到，在Person类中引用到age和namefield字段的地方，都是指向了常量池中age和namefield字段对应的常量池项中。表示field字段的常量池项叫做CONSTANT_Fieldref_info。</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B51" alt="image"></p><p>怎样描述某一个field字段的引用？</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B52" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B53" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B54" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B55" alt="image"></p><p>实例解析： 现在，让我们来看一下Person类中定义的namefield字段在常量池中的表示。通过使用javap -v Person会查看到如下的常量池信息：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B56" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B57" alt="image"></p><p>请读者看上图中namefield字段的数据类型，它在#6个常量池项，以UTF-8编码格式的字符串“Ljava/lang/String;” 表示，这表示着这个field 字段是java.lang.String 类型的。关于field字段的数据类型，class文件中存储的方式和我们在源码中声明的有些不一样。请看下图的对应关系：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B58" alt="image"></p><p><strong>注意：</strong></p><p>如果我们在类中定义了field 字段，但是没有在类中的其他地方用到这些字段，它是不会被编译器放到常量池中的。</p><p>只有在类中的其他地方引用到了，才会将他放到常量池中。</p><h2>11. 类中引用到的method方法在常量池中是怎样描述的？(CONSTANT_Methodref_info, CONSTANT_Name_Type_info)</h2><h3>1. 举例</h3><p>还是以Person类为例。在Person类中，我们定义了setName(String name)、getName()、setAge(int age)、getAge()这些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们定义了方法，但是这些方法没有在类总的其他地方被用到（即没有在类中其他的方法中引用到），所以它们的方法引用信息并不会放到常量中。</p><p>现在我们在类中加一个方法 getInfo()，调用了getName()和getAge() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> getName()+<span class="string">"\t"</span>+getAge();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候JVM编译器会将getName()和getAge()方法的引用信息包装成CONSTANT_Methodref_info结构体放入到常量池之中。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%951" alt="image"></p><p>这里的方法调用的方式牵涉到Java非常重要的一个术语和机制，叫动态绑定。这个动态绑定问题以后在单独谈谈。</p><h3>2. 表示一个方法引用</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%952" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%953" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%954" alt="image"></p><h3>3. 方法描述符的组成</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%955" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%956" alt="image"></p><h3>4. getName() 方法引用在常量池中的表示</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%957" alt="image"></p><h2>12. 类中引用到某个接口中定义的method方法在常量池中是怎样描述的？(CONSTANT_InterfaceMethodref_info, CONSTANT_Name_Type_info)</h2><p>当我们在某个类中使用到了某个接口中的方法，JVM会将用到的接口中的方法信息方知道这个类的常量池中。<br>比如我们定义了一个Worker接口，和一个Boss类，在Boss类中调用了Worker接口中的方法，这时候在Boss类的常量池中会有Worker接口的方法的引用表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">(Worker worker)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        worker.work();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84method%E6%96%B9%E6%B3%951" alt="image"></p><p>如上图所示，在Boss类的makeMoney()方法中调用了Worker接口的work()方法，机器指令是通过invokeinterface指令完成的，invokeinterface指令后面的操作数，是指向了Boss常量池中Worker接口的work()方法描述，表示的意思就是：“我要调用Worker接口的work()方法”。</p><p>Worker接口的work()方法引用信息，JVM会使用CONSTANT_InterfaceMethodref_info结构体来描述，CONSTANT_InterfaceMethodref_info定义如下：</p><p><img src="http://javajvm.oursnail.cn/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84method%E6%96%B9%E6%B3%952" alt="image"></p><p>CONSTANT_InterfaceMethodref_info结构体和上面介绍的CONSTANT_Methodref_info 结构体很基本上相同，它们的不同点只有：</p><blockquote><ol><li>CONSTANT_InterfaceMethodref_info 的tag 值为11，而CONSTANT_Methodref_info的tag值为10；</li></ol></blockquote><blockquote><ol start="2"><li>CONSTANT_InterfaceMethodref_info 描述的是接口中定义的方法，而CONSTANT_Methodref_info描述的是实例类中的方法；</li></ol></blockquote><p>其他的基本与上面一个一毛一样。参照上面个理解即可。</p><h2>13. CONSTANT_MethodType_info，CONSTANT_MethodHandle_info，CONSTANT_InvokeDynamic_info</h2><p>这三项主要是为了让Java语言支持动态语言特性而在Java 7 版本中新增的三个常量池项，只会在极其特别的情况能用到它，在class文件中几乎不会生成这三个常量池项。   其实我花了一些时间来研究这三项，并且想通过各种方式生成这三项，不过没有成功，最后搞的还是迷迷糊糊的。从我了解到的信息来看，Java 7对动态语言的支持很笨拙，并且当前没有什么应用价值，然后就对着三项的研究先放一放了。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一节Class类文件结构大致地介绍了class文件的组织结构，接下来，我们将深入每一个结构，来详细了解它们。这一章节呢，我们就来扒一扒class文件中非常重要 的一个数据区域------常量池。它在JVM虚拟机中扮演了非常重要的地位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读1-Class类文件结构</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB-Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读-Class类文件结构/</id>
    <published>2019-02-09T11:32:35.940Z</published>
    <updated>2019-02-09T11:33:03.051Z</updated>
    
    <content type="html"><![CDATA[<p>总体概览一下Class文件是什么以及有什么。</p><a id="more"></a><h2>整体感知</h2><p><code>class</code>文件是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得<code>class</code>文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间。 我们的Java源文件， 在被编译之后， 每个类（或者接口）都单独占据一个<code>class</code>文件， 并且类中的所有信息都会在<code>class</code>文件中有相应的描述， 由于<code>class</code>文件很灵活， 它甚至比Java源文件有着更强的描述能力。</p><h2>Class文件格式</h2><p><img src="http://javajvm.oursnail.cn/Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="image"></p><p><strong>换成表格的形式：</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count - 1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h3>NO1. 魔数(magic)</h3><p>所有的由Java编译器编译而成的class文件的前4个字节都是“0xCAFEBABE”</p><p>它的作用在于：</p><blockquote><p>当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。</p></blockquote><h3>NO2.版本号(minor_version,major_version)</h3><p>主版本号和次版本号在class文件中各占两个字节，<strong>副版本号占用第5、6两个字节，而主版本号则占用第7，8两个字节</strong>。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51,对应的7，8个字节的十六进制的值应该是 0x33。</p><p>JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版本号，如果JVM本身的版本号小于class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的<code>&quot;java.lang.UnsupportedClassVersionError: Bad version number in .class file &quot; Error</code>错误；反之，JVM会认为可以加载此class文件，继续加载此class文件。</p><h3>NO3.常量池计数器(constant_pool_count)</h3><p>常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。 常量池是由一组<code>constant_pool</code>结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器<code>constant_pool_count</code> 的值等于<code>constant_pool</code>表中的成员数+ 1。<code>constant_pool</code>表的索引值只有在大于 0 且小于<code>constant_pool_count</code>时(即1~(constant_pool_count-1))才会被认为是有效的。</p><p>这个容量计数是从1而不是从0开始的，如果常量池容量为十六进制数0x0016，即十进制22，这就代表着常量池中有21个常量，索引值范围为1-21。在Class文件格式规范制定时，设计者将第0项常量空出来是有特殊考虑的，用于在特定情况下表达“不引用任何一个常量池项目”。</p><h3>NO4.常量池数据区(constant_pool[contstant_pool_count-1])</h3><p>常量池，constant_pool是一种表结构,它包含 Class 文件结构及其子结构中引用的所有字符串常量、 类或接口名、字段名和其它常量。 常量池中的每一项都具备相同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，称为 “tag byte” 。常量池的索引范围是 1 至constant_pool_count−1。常量池的具体细节我们会稍后讨论。</p><h3>NO6.访问标志(access_flags)</h3><p>访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="image"></p><h3>NO7.类索引(this_class)</h3><p>类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类或接口。</p><h3>NO8.父类索引(super_class)</h3><p>父类索引，对于类来说，super_class 的值必须为 0 或者是对constant_pool 表中项目的一个有效索引值。如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的access_flag 中都不能带有ACC_FINAL 标记。对于接口来说，它的Class文件的super_class项的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是java.lang.Object类，只有它是唯一没有父类的类。</p><h3>NO9.接口计数器(interfaces_count)</h3><p>接口计数器，interfaces_count的值表示当前类或接口的直接父接口数量。</p><h3>NO10.接口信息数据区(interfaces[interfaces_count])</h3><p>接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员 interfaces[i]  必须为 CONSTANT_Class_info类型常量，其中 0 ≤ i &lt;interfaces_count。在interfaces[]数组中，成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><h3>NO11.字段计数器(fields_count)</h3><p>字段计数器，fields_count的值表示当前 Class 文件 fields[]数组的成员个数。 fields[]数组中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。</p><h3>NO12.字段信息数据区(fields[fields_count])</h3><p>字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接口继承的部分。</p><h3>NO13.方法计数器(methods_count)</h3><p>方法计数器， methods_count的值表示当前Class 文件 methods[]数组的成员个数。Methods[]数组中每一项都是一个 method_info 结构的数据项。</p><h3>NO14.方法信息数据区(methods[methods_count])</h3><p>方法表，methods[] 数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。如果某个method_info 结构的access_flags 项既没有设置 ACC_NATIVE 标志也没有设置ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需要引用其它类。 method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法方法和类或接口初始化方法方法 。methods[]数组只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。</p><h3>NO15.属性计数器(attributes_count)</h3><p>属性计数器，attributes_count的值表示当前 Class 文件attributes表的成员个数。attributes表中每一项都是一个attribute_info 结构的数据项。</p><h3>NO16.属性信息数据区(attributes[attributes_count])</h3><p>属性表，attributes 表的每个项的值必须是attribute_info结构。</p><p>在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性： InnerClasses  、 EnclosingMethod 、 Synthetic  、Signature、SourceFile，SourceDebugExtension 、Deprecated、RuntimeVisibleAnnotations 、RuntimeInvisibleAnnotations以及BootstrapMethods属性。</p><p>对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取attributes表中的Signature、RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。Java 7 规范 要求任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 （甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总体概览一下Class文件是什么以及有什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>内存分配和回收策略</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/02/09/JVM/内存分配和回收策略/</id>
    <published>2019-02-09T11:16:03.990Z</published>
    <updated>2019-02-09T11:26:05.405Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十篇文章，本章对内存分配和垃圾回收的细节再次详细说明一下，并且说明一下逃逸分析/栈上分配以及TLAB两种方式的概念和原理。</p><a id="more"></a><h2>1. 对象优先在Eden分配</h2><p><strong>前面文章曾介绍HotSpot虚拟机新生代内存布局及算法:</strong></p><blockquote><p>（1）、将新生代内存分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间；</p><p>（2）、每次使用<code>Eden</code>和其中一块<code>Survivor</code>；</p><p>（3）、当回收时，将<code>Eden</code>和使用中的<code>Survivor</code>中还存活的对象一次性复制到另外一块<code>Survivor</code>；</p><p>（4）、而后清理掉<code>Eden</code>和使用过的<code>Survivor</code>空间；</p><p>（5）、后面就使用<code>Eden</code>和复制到的那一块<code>Survivor</code>空间，重复步骤3；</p></blockquote><p>默认<code>Eden：Survivor=8:1</code>，即每次可以使用90%的空间，只有一块<code>Survivor</code>的空间被浪费；</p><p>大多数情况下，对象在新生代<code>Eden</code>区中分配；</p><p>当<code>Eden</code>区没有足够空间进行分配时，JVM将发起一次<code>Minor GC</code>（新生代GC）；</p><p><code>Minor GC</code>时，如果发现存活的对象无法全部放入<code>Survivor</code>空间，只好通过分配担保机制提前转移到老年代。</p><h2>2. 大对象直接进入老年代</h2><p>大对象指需要大量连续内存空间的Java对象，如，很长的字符串、数组；</p><p>经常出现大对象容易导致内存还有不少空间就提前触发GC,以获取足够的连续空间来存放它们，所以应该尽量避免使用创建大对象；</p><p><code>-XX:PretenureSizeThreshold</code>：</p><p><strong>可以设置这个阈值，大于这个参数值的对象直接在老年代分配；</strong></p><p>默认为0（无效），且只对<code>Serail</code>和<code>ParNew</code>两款收集器有效；</p><p>如果需要使用该参数，可考虑<code>ParNew+CMS</code>组合。</p><h2>3. 长期存活的对象将进入老年代</h2><p>JVM给每个对象定义一个对象年龄计数器，其计算流程如下：</p><blockquote><p>在<code>Eden</code>中分配的对象，经<code>Minor GC</code>后还存活，就复制移动到<code>Survivor</code>区，年龄为1；</p><p>而后每经一次<code>Minor GC</code>后还存活，在<code>Survivor</code>区复制移动一次，年龄就增加1岁；</p><p>如果年龄达到一定程度，就晋升到老年代中；</p></blockquote><p><code>-XX:MaxTenuringThreshold</code>：</p><p><strong>设置新生代对象晋升老年代的年龄阈值，默认为15；</strong></p><h2>4. 动态对象年龄判定</h2><p>JVM为更好适应不同程序，不是永远要求等到<code>MaxTenuringThreshold</code>中设置的年龄；</p><p>如果在<code>Survivor</code>空间中相同年龄的所有对象大小总和大于<code>Survivor</code>空间的一半，大于或等于该年龄的对象就可以直接进入老年代</p><h2>5. 空间分配担保</h2><p>在前面曾简单介绍过分配担保：</p><p>当<code>Survivor</code>空间不够用时，需要依赖其他内存（老年代）进行分配担保（<code>Handle Promotion</code>）；</p><p><strong>分配担保的流程如下：</strong></p><blockquote><p>在发生<code>Minor GC</code>前，JVM先检查老年代最大可用的连续空间是否大于新生所有对象空间；</p></blockquote><blockquote><p>如果大于，那可以确保<code>Minor GC</code>是安全的；</p></blockquote><blockquote><p>如果不大于，则<code>JVM</code>查看<code>HandlePromotionFailure</code>值是否允许担保失败；</p></blockquote><blockquote><p>如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小；</p></blockquote><blockquote><p>如果大于，将尝试进行一次<code>Minor GC</code>，但这是有风险的；</p></blockquote><blockquote><p>如果小于或<code>HandlePromotionFailure</code>值不允许冒险，那这些也要改为进行一次<code>Full GC</code>；</p></blockquote><p><strong>尝试<code>Minor GC</code>的风险–担保失败：</strong></p><blockquote><p>因为尝试<code>Minor GC</code>前面，无法知道存活的对象大小，所以使用历次晋升到老年代对象的平均大小作为经验值；</p><p>假如尝试的<code>Minor GC</code>最终存活的对象远远高于经验值的话，会导致担保失败（<code>Handle Promotion Failure</code>）；</p><p>失败后只有重新发起一次<code>Full GC</code>，这绕了一个大圈，代价较高；</p></blockquote><p><strong>但一般还是要开启<code>HandlePromotionFailure</code>，避免<code>Full GC</code>过于频繁，而且担保失败概率还是比较低的；</strong></p><p><strong>JDK6-u24后，JVM代码中已经不再使用<code>HandlePromotionFailure</code>参数了；</strong></p><p>规则变为：</p><p>⭐⭐⭐<strong>只要老年代最大可用的连续空间大于新生所有对象空间或历次晋升到老年代对象的平均大小，就会进行<code>Minor GC</code>；否则进行<code>Full GC</code>；</strong></p><p>⭐⭐⭐即老年代最大可用的连续空间小于新生所有对象空间时，不再检查<code>HandelPromotionFailure</code>，而直接检查历次晋升到老年代对象的平均大小；</p><h2>6. 逃逸分析</h2><p>般认为new出来的对象都是被分配在堆上，但是这个结论不是那么的绝对，通过对Java对象分配的过程分析，可以知道有两个地方会导致Java中new出来的对象并不一定分配在所认为的堆上。这两个点分别是Java中的逃逸分析和<code>TLAB</code>（<code>Thread Local Allocation Buffer</code>）。</p><h5>6.1 什么是栈上分配？</h5><p>栈上分配主要是指在Java程序的执行过程中，<strong>在方法体中声明的变量以及创建的对象，将直接从该线程所使用的栈中分配空间</strong>。</p><p>一般而言，创建对象都是从堆中来分配的，这里是指在栈上来分配空间给新创建的对象。</p><h5>6.2 什么是逃逸？</h5><p>逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；</p><p>这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。</p><p>正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；而此时由于无法回收，即成为逃逸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> V global_v;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> V v=b_method();  </span><br><span class="line"> c_method();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">b_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> V v=<span class="keyword">new</span> V();  </span><br><span class="line"> <span class="keyword">return</span> v;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> global_v=<span class="keyword">new</span> V();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>b_method</code>方法内部生成的V对象的引用被返回给<code>a_method</code>方法内的变量v，<code>c_method</code>方法内生成的V对象被赋给了全局变量<code>global_v</code>。这两种场景都发生了（引用）逃逸。</p><h5>6.3 逃逸分析</h5><p>在JDK 6之后支持对象的栈上分析和逃逸分析，在JDK7中完全支持栈上分配对象。其是否打开逃逸分析依赖于以下JVM的设置：</p><blockquote><p><code>-XX:+DoEscapeAnalysis</code></p></blockquote><h5>6.4 栈上分配与逃逸分析的关系</h5><p>进行逃逸分析之后，产生的后果是所有的对象都将由栈上分配，而非从JVM内存模型中的堆来分配。</p><h5>6.5 逃逸分析／栈上分配的优劣分析</h5><p>JVM在<code>Server</code>模式下的逃逸分析可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配，由于该对象一定是局部的，所以栈上分配不会有问题。</p><blockquote><p>消除同步。</p></blockquote><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。</p><blockquote><p>矢量替代。</p></blockquote><p>逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。</p><blockquote><p>劣势：</p></blockquote><p>栈上分配受限于栈的空间大小，一般自我迭代类的需求以及大的对象空间需求操作，将导致栈的内存溢出；故只适用于一定范围之内的内存范围请求。</p><h5>6.6 测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//会发生逃逸</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            x = (++counter);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">10</span>; ++i) &#123;  </span><br><span class="line">            Foo foo = <span class="keyword">new</span> Foo();  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();  </span><br><span class="line">        System.out.println(<span class="string">"Time cost is "</span> + (end - start));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未开启逃逸分析设置为：</p><blockquote><p>-server -verbose:gc</p></blockquote><p>在未开启逃逸分析的状况下运行情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC 5376K-&gt;427K(63872K), 0.0006051 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(63872K), 0.0003928 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(63872K), 0.0003639 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(69248K), 0.0003770 secs]  </span><br><span class="line">[GC 11179K-&gt;427K(69248K), 0.0003987 secs]  </span><br><span class="line">[GC 11179K-&gt;427K(79552K), 0.0003817 secs]  </span><br><span class="line">[GC 21931K-&gt;399K(79552K), 0.0004342 secs]  </span><br><span class="line">[GC 21903K-&gt;399K(101120K), 0.0002175 secs]  </span><br><span class="line">[GC 43343K-&gt;399K(101184K), 0.0001421 secs]  </span><br><span class="line">Time cost is 58514571</span><br></pre></td></tr></table></figure><p>开启逃逸分析设置为：</p><blockquote><p>-server -verbose:gc -XX:+DoEscapeAnalysis</p></blockquote><p>开启逃逸分析的状况下，运行情况如下：</p><blockquote><p>Time cost is 10031306</p></blockquote><p>未开启逃逸分析时，运行上述代码，JVM执行了GC操作，而在开启逃逸分析情况下，JVM并没有执行GC操作。同时，操作时间上，开启逃逸分析的程序运行时间是未开启逃逸分析时间的1/5。</p><h2>7. 再来聊聊TLAB</h2><p>JVM在内存新生代<code>Eden Space</code>中开辟了一小块线程私有的区域，称作<code>TLAB</code>（<code>Thread-local allocation buffer</code>）。默认设定为占用<code>Eden Space</code>的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且<code>TLAB</code>上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。<br>也就是说，Java中每个线程都会有自己的缓冲区称作<code>TLAB</code>（<code>Thread-local allocation buffer</code>），每个<code>TLAB</code>都只有一个线程可以操作，TLAB结合<code>bump-the-pointer</code>技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。</p><h2>8. 对象内存分配过程再升级</h2><blockquote><ol><li>编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.</li></ol></blockquote><blockquote><ol start="2"><li>如果<code>tlab_top + size &lt;= tlab_end</code>，则在在TLAB上直接分配对象并增加<code>tlab_top</code><br>的值，如果现有的TLAB不足以存放当前对象则3.</li></ol></blockquote><blockquote><ol start="3"><li>重新申请一个<code>TLAB</code>，并再次尝试存放当前对象。如果放不下，则4.</li></ol></blockquote><blockquote><ol start="4"><li>在<code>Eden</code>区加锁（这个区是多线程共享的），如果<code>eden_top + size &lt;= eden_end</code>则将对象存放在<code>Eden</code>区，增加<code>eden_top</code> 的值，如果<code>Eden</code>区不足以存放，则5.</li></ol></blockquote><blockquote><ol start="5"><li>执行一次<code>Young GC</code>（<code>minor collection</code>）。</li></ol></blockquote><blockquote><ol start="6"><li>经过<code>Young GC</code>之后，如果<code>Eden</code>区任然不足以存放当前对象，则直接分配到老年代。</li></ol></blockquote><blockquote><ol start="7"><li>老年代还是不足，则触发Full GC，再不足就OOM错误</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第十篇文章，本章对内存分配和垃圾回收的细节再次详细说明一下，并且说明一下逃逸分析/栈上分配以及TLAB两种方式的概念和原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器介绍</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/02/09/JVM/垃圾收集器介绍/</id>
    <published>2019-02-09T04:46:58.587Z</published>
    <updated>2019-02-09T04:48:23.164Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第九篇文章，主要介绍七种比较经典的垃圾收集器的实现原理。</p><a id="more"></a><h2>垃圾收集器</h2><p><img src="http://xiaozhao.oursnail.cn/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>以上是 <code>HotSpot</code> 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><h3>1. Serial 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p><code>Serial</code> 翻译为串行，垃圾收集和用户程序不能同时执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 <code>CMS</code> 和 <code>G1</code> 之外，其它收集器都是以串行的方式执行。<code>CMS</code> 和 <code>G1</code> 可以使得垃圾收集和用户程序同时执行，被称为并发执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 <code>Client</code> 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。<code>Serial</code> 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h3>2. ParNew 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>它是 <code>Serial</code> 收集器的多线程版本。</p><p>是 <code>Server</code>模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 <code>Serial</code> 收集器，只有它能与 <code>CMS</code> 收集器配合工作。</p><p>默认开始的线程数量与 CPU 数量相同，可以使用 <code>-XX:ParallelGCThreads</code> 参数来设置线程数。</p><h3>3. Parallel Scavenge 收集器</h3><p>与 <code>ParNew</code> 一样是并行的多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 <code>-XX:MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 和 <code>Survivor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（<code>GC Ergonomics</code>）。</p><h3>4. Serial Old 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/SerialOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>是 <code>Serial</code> 收集器的老年代版本，也是给 <code>Client</code> 模式下的虚拟机使用。如果用在 <code>Server</code> 模式下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（<code>Parallel Old</code> 诞生以前）中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li><li>作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li></ul><h3>5. Parallel Old 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>是 <code>Parallel Scavenge</code> 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器。</p><h3>6. CMS 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p><code>CMS</code>（Concurrent Mark Sweep），<code>Mark Sweep</code> 指的是标记 - 清除算法。</p><p>特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 <code>GC Roots</code> 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行<code>GC Roots Tracing</code> 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 <code>-XX:CMSInitiatingOccupancyFraction</code> 来改变触发 <code>CMS</code> 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 <code>Serial Old</code> 来替代 <code>CMS</code>。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code>。</li></ul><h3>7. G1 收集器</h3><p><code>G1</code>（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。<code>HotSpot</code> 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>G1 把新生代和老年代划分成多个大小相等的独立区域（<code>Region</code>），新生代和永久代不再物理隔离。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A82.png" alt="image"></p><p>通过引入 <code>Region</code> 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用来记录该 <code>Region</code> 对象的引用对象所在的 <code>Region</code>。通过使用 <code>Remembered Set</code>，在做可达性分析的时候就可以避免全堆扫描。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A83.jpg" alt="image"></p><p>如果不计算维护 <code>Remembered Set</code> 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 <code>Region</code> 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 <code>Region</code> 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h3>8. 比较</h3><table><thead><tr><th style="text-align:center">收集器</th><th style="text-align:center">串行/并行/并发</th><th style="text-align:center">新生代/老年代</th><th style="text-align:center">收集算法</th><th style="text-align:center">目标</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Serial</strong></td><td style="text-align:center">串行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单 CPU 环境下的 Client 模式</td></tr><tr><td style="text-align:center"><strong>Serial Old</strong></td><td style="text-align:center">串行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单 CPU 环境下的 Client 模式、CMS 的后备预案</td></tr><tr><td style="text-align:center"><strong>ParNew</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr><tr><td style="text-align:center"><strong>Parallel Scavenge</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>Parallel Old</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>CMS</strong></td><td style="text-align:center">并行 + 并发</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-清除</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">集中在互联网站或 B/S 系统服务端上的 Java 应用</td></tr><tr><td style="text-align:center"><strong>G1</strong></td><td style="text-align:center">并行 + 并发</td><td style="text-align:center">新生代 + 老年代</td><td style="text-align:center">标记-整理 + 复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">面向服务端应用，将来替换 CMS</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第九篇文章，主要介绍七种比较经典的垃圾收集器的实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GC相关</title>
    <link href="http://yoursite.com/2019/02/09/JVM/GC%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2019/02/09/JVM/GC相关/</id>
    <published>2019-02-09T04:19:18.323Z</published>
    <updated>2019-02-09T04:48:00.764Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第八篇文章，我们知道，JVM为我们管理垃圾对象实现自动回收，让我们不需要太关心内存释放问题，一定程度上减少了内存溢出的错误。这一切的背后是如何实现的呢？</p><a id="more"></a><h2>一、垃圾标记算法</h2><h5>1.1 引用计数法</h5><p><strong>算法思想</strong></p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器☞减一；任何时候计数器为0的对象是不可能再被使用的。</p><p><strong>主要缺陷</strong></p><p>无法解决对象间相互循环引用的问题。</p><p><strong>举个例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Test objA = <span class="keyword">new</span> Test();<span class="comment">//count=1</span></span><br><span class="line">    Test objB = <span class="keyword">new</span> Test();<span class="comment">//count=1</span></span><br><span class="line"></span><br><span class="line">        objA.instance = objB;<span class="comment">//count=2</span></span><br><span class="line">        objB.instance = objA;<span class="comment">//count=2</span></span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;<span class="comment">//count=1</span></span><br><span class="line">        objB = <span class="keyword">null</span>;<span class="comment">//count=1</span></span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">testGC();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入参数</strong></p><blockquote><p>-verbose:gc -XX:+PrintGCDetails</p></blockquote><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 6063K-&gt;600K(37888K)] 6063K-&gt;608K(123904K), 0.0037131 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 600K-&gt;0K(37888K)] [ParOldGen: 8K-&gt;529K(86016K)] 608K-&gt;529K(123904K), [Metaspace: 2595K-&gt;2595K(1056768K)], 0.0062705 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 37888K, used 328K [0x00000000d6100000, 0x00000000d8b00000, 0x0000000100000000)</span><br><span class="line">  eden space 32768K, 1% used [0x00000000d6100000,0x00000000d6152030,0x00000000d8100000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d8100000,0x00000000d8100000,0x00000000d8600000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8600000,0x00000000d8600000,0x00000000d8b00000)</span><br><span class="line"> ParOldGen       total 86016K, used 529K [0x0000000082200000, 0x0000000087600000, 0x00000000d6100000)</span><br><span class="line">  object space 86016K, 0% used [0x0000000082200000,0x0000000082284778,0x0000000087600000)</span><br><span class="line"> Metaspace       used 2601K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>日志中6063K-&gt;600K(37888K)，从原来的6M内存变成了600k，表明对象已被回收，从而表明JVM没有使用引用计数算法。Java中使用了可达性分析算法来来判定对象是否存活。</p><h5>1.2 可达性分析算法</h5><p>这个算法的基本思路就是通过一系列的称谓<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径为引用链，当一个对象到<code>GC Roots</code>没有任何引用链时，则证明此对象时不可用的，下面看一下例子：</p><p><img src="http://img.blog.csdn.net/20141102164158981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><p>上面的这张图，对象<code>object5</code>、<code>object6</code>、<code>object7</code>虽然互相没有关联，但是它们到<code>GC Roots</code>是不可达的，所以它们将会被判定为是可回收的对象</p><p>注：Java语言中，可作为<code>GC Roots</code>的对象包括下面几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li><li>活跃线程引用的对象</li></ul><h2>二、Java中的引用类型</h2><p>从JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用，这四种引用的强度一次逐渐减弱</p><ol><li><p>强引用就是指在程序代码之中普遍存在的，类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</p></li><li><p>软引用是用来描述一些还有用但并非需要的对象，对于软引用关联着的对象，在系统将要发生内存异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存异常</p></li><li><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存释放足够，都会回收掉只被弱引用关联的对象</p></li><li><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，对一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p></li></ol><h3>三、两次标记</h3><p>《深入理解java虚拟机》原文：</p><blockquote><p>在java根搜索算法中判断对象的可达性，对于不可达的对象，也并不一定是必须清理。这个时候有一个缓刑期，真正的判断一个对象死亡，至少要经过俩次标记过程：</p><p>如果对象在进行根搜索后发现没有与<code>GC roots</code>相关联的引用链，那他将会第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这俩种情况都视为“没有必要执行”。</p><p>即当一个对象重写了<code>finalize()</code>方法的时候，这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象被放置在<code>F-Queue</code>队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行。这里所谓的执行是指虚拟机会出发这个方法，但不承诺会等待它运行结束。这样做的原因：如果一个对象在<code>finalize()</code>方法中执行缓慢，或者发生了死循环（极端的情况下），将可能会导致<code>F-Queue</code>队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象要在<code>finalize()</code>中成功拯救自己----只要重新与引用链上的任何建立关联即可，那么在第二次标记时它将会被移出“即将回收”的集合；如果对象这时候没有逃脱，就会被回收。</p></blockquote><h5>3.1 finalize的工作原理</h5><p>一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用<code>finalize()</code>，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.所以如果使用<code>finalize()</code>，就可以在垃圾收集期间进行一些重要的清除或清扫工作.</p><h5>3.2 finalize()在什么时候被调用?</h5><ol><li>所有对象被<code>Garbage Collection</code>时自动调用,比如运行<code>System.gc()</code>的时候.</li><li>程序退出时为每个对象调用一次<code>finalize</code>方法。</li><li>显式的调用<code>finalize</code>方法</li></ol><p>这个方法的用途就是：在该对象被回收之前，该对象的<code>finalize()</code>方法会被调用。<strong>这里的回收之前指的就是被标记之后</strong>，问题就出在这里，有没有一种情况就是原本一个对象开始不再上一章所讲的“关系网”（引用链）中，但是当开发者重写了<code>finalize()</code>后，并且将该对象重新加入到了“关系网”中，也就是说该对象对我们还有用，不应该被回收，但是已经被标记啦，怎么办呢？</p><p>针对这个问题，虚拟机的做法是进行两次标记，即<strong>第一次标记不在“关系网”中的对象，并且要判断该对象有没有实现<code>finalize()</code>方法</strong>了，如果没有实现就直接判断该对象可回收。如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它。</p><p><strong>随后就会进行第二次的小规模标记</strong>，如果对象还没有逃脱，在这次被标记的对象就会真正的被回收了。</p><h2>四、垃圾收集算法</h2><h5>4.1 标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（<code>Mark-Sweep</code>）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<strong>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</strong>。</p><p>标记-清除算法的执行过程如图：</p><p><img src="http://bloghello.oursnail.cn/jvm8-1.jpg" alt="image"></p><h5>4.2 复制算法</h5><p>为了解决效率问题，一种称为“复制”（<code>Copying</code>）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<strong>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点</strong>。</p><p>复制算法的执行过程如图：</p><p><img src="http://bloghello.oursnail.cn/jvm8-2.jpg" alt="image"></p><h5>4.3 标记-整理算法</h5><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就<strong>需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法</strong>。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（<code>Mark-Compact</code>）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图</p><p><img src="http://bloghello.oursnail.cn/jvm8-3.jpg" alt="image"></p><h5>4.4 分代收集算法</h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（<code>Generational Collection</code>）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收</strong></p><p><img src="http://bloghello.oursnail.cn/jvm8-4.jpg" alt="image"></p><h2>五、新生代和老年代</h2><h5>5.1 新生代</h5><p>新生代分为三个区域，一个<code>Eden</code>区和两个<code>Survivor</code>区，它们之间的比例为（8：1：1），这个比例也是可以修改的。通常情况下，对象主要分配在新生代的<code>Eden</code>区上，少数情况下也可能会直接分配在老年代中。</p><p>Java虚拟机每次使用新生代中的<code>Eden</code>和其中一块<code>Survivor</code>（<code>From</code>），在经过一次<code>MinorGC</code>后，将<code>Eden</code>和<code>Survivor</code>中还存活的对象一次性地复制到另一块<code>Survivor</code>空间上（这里使用的复制算法进行GC），最后清理掉<code>Eden</code>和刚才用过的<code>Survivor</code>（<code>From</code>）空间。将此时在<code>Survivor</code>空间存活下来的对象的年龄设置为1，以后这些对象每在<code>Survivor</code>区熬过一次GC，它们的年龄就加1，当对象年龄达到某个年龄（默认值为15）时，就会把它们移到老年代中。</p><p>在新生代中进行GC时，有可能遇到另外一块<code>Survivor</code>空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><p>总结：</p><p>1、<code>Minor GC</code>是发生在新生代中的垃圾收集，采用的复制算法；</p><p>2、新生代中每次使用的空间不超过90%，主要用来存放新生的对象；</p><p>3、<code>Minor GC</code>每次收集后Eden区和一块<code>Survivor</code>区都被清空；</p><h5>5.1 老年代</h5><p>老年代里面存放都是生命周期长的对象，对于一些较大的对象（即需要分配一块较大的连续内存空间），是直接存入老年代的，还有很多从新生代的<code>Survivor</code>区域中熬过来的对象。</p><p>老年代中使用的是<code>Full GC</code>，<code>Full GC</code>所采用的是标记-清除或者标记-整理算法。老年代中的<code>Full GC</code>不像<code>Minor GC</code>操作那么频繁，并且进行一次<code>Full GC</code>所需要的时间要比<code>Minor GC</code>的时间长。</p><h5>5.2 触发Full GC的条件</h5><ul><li>老年代空间不足</li><li>JDK8以前的永久代空间不足，现在永久代已经被元数据区代替</li><li>CMS GC时出现<code>promotion failed</code>，<code>concurrent mode failure</code>(下面文章讲到CMS垃圾收集器的时候会说明)</li><li><code>minor GC</code>晋升到老年代的平均大小大于老年代的剩余空间</li><li>调用<code>System.gc()</code>提醒JVM回收一下，只是提醒</li></ul><h5>5.3 对象如何晋升到老年代</h5><p>一般有如下情况会晋升：</p><ul><li>经历一定minor次数依然存活的对象</li><li>survivor区中存放不下的对象</li><li>新生成的大对象</li></ul><h5>5.4 常用的调优参数</h5><p><img src="http://bloghello.oursnail.cn/jvm8-5.jpg" alt="image"></p><h5>5.5 内存申请过程</h5><p>A. JVM会试图为相关Java对象在<code>Eden</code>中初始化一块内存区域</p><p>B. 当<code>Eden</code>空间足够时，内存申请结束。否则到下一步</p><p>C. <code>JVM</code>试图释放在<code>Eden</code>中所有不活跃的对象（<code>Minor GC</code>）, 释放后若<code>Eden</code>空间仍然不足以放入新对象，则试图将部分<code>Eden</code>中活跃对象放入<code>Survivor</code>区</p><p>D. 当<code>Survivor</code>区空间不够时或者某些对象熬的时间比较长，则<code>Survivor</code>区这些对象会被移到<code>Old</code>区</p><p>E. 当<code>Old</code>区空间不够时，<code>JVM</code>会在<code>Old</code>区进行完全的垃圾收集（<code>Full GC</code>）</p><p>F. 完全垃圾收集后，若<code>Survivor</code>及<code>Old</code>区仍然无法存放从<code>Eden</code>复制过来的部分对象，导致<code>JVM</code>无法在<code>Eden</code>区为新对象创建内存区域，则出现<code>out of memory</code>错误.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第八篇文章，我们知道，JVM为我们管理垃圾对象实现自动回收，让我们不需要太关心内存释放问题，一定程度上减少了内存溢出的错误。这一切的背后是如何实现的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JAVA内存模型常问面试题</title>
    <link href="http://yoursite.com/2019/02/08/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%B8%B8%E9%97%AE%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/08/JVM/JAVA内存模型常问面试题/</id>
    <published>2019-02-08T15:19:47.969Z</published>
    <updated>2019-02-08T15:28:58.766Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第七篇文章，介绍一些面试比较常问的问题。</p><a id="more"></a><h2>一、JVM三大性能调优参数-Xms -Xmx -Xss的含义</h2><p>一般我们可以传入以下参数去调整堆和内存所占的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms128m -Xmx128m -Xss256k -jar xxx.jar</span><br></pre></td></tr></table></figure><ul><li>-Xms ：堆的初始值</li><li>-Xmx ：堆能达到的最大值</li><li>-Xss ：规定了每个线程虚拟机栈的大小</li></ul><h2>二、JAVA内存模型中堆和栈的区别</h2><p>首先来了解一下几种不同的内存分配策略：</p><ul><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求，比如static声明的静态变量，这里的数据一般都放在方法区，java8中这个区域叫做元数据区，用的时物理内存，并且之前合在一起的字符串常量池也被移到了堆区，详情见上一篇文章。</li><li>栈式存储：数据去需求在编译时未知，运行时模块入口前确定，比如基本数据类型，都是在运行的时候，才知道数据(字面量)到底是什么，对于JVM，一个方法内的执行，局部变量表和操作数栈的大小时确定的，即引用变量和栈空间大小是编译器确定的，至于字面量等运行时才能确定。</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配，比如可变长度串、对象实例</li></ul><p>下面来看看栈和堆的联系：</p><p>引用对象或者数组时，栈里定义变量保存堆中目标的首地址。</p><p><img src="http://bloghello.oursnail.cn/jvm7-1.png" alt="image"></p><p>下面来看看栈和堆的区别：</p><ul><li>管理方式：栈自动释放，堆需要GC</li><li>空间大小：栈比堆小</li><li>碎片相关：栈产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ul><p>简单总结：栈比较小，随着方法执行完毕自动释放，栈数据结构简单，所以操作也简单高效。堆放各种对象实例和数组，必定要比较大的空间，那么需要GC来回收不需要的数据，效率低并且碎片也比较多，由于堆的操作比较复杂，所以数据结构也复杂，效率低。</p><h2>三、元空间、堆、线程独占部分间的联系</h2><p>先来看一个最简单的程序：</p><p><img src="http://bloghello.oursnail.cn/jvm7-2.png" alt="image"></p><p>我们分别从元空间、堆、以及线程独占的部分来看看分别存储了啥：</p><p><img src="http://bloghello.oursnail.cn/jvm7-3.png" alt="image"></p><p>学到这里，对于这些东西已经不需要解释了。针对JVM内存模型的知识在这里就串联起来了。了解到这里，对内存模型这一块基本的知识已经差不多了。</p><h2>四、再来说说字符串</h2><p>之前在<a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" target="_blank" rel="noopener">java字符串核心一网打尽</a>文章中，其实是对于JDK8这个版本的字符串特性进行详细的解读，其中也介绍了<code>intern</code>这个方法的含义和用法，由于JDK6和JDK6+关于<code>intern</code>是不一样的，这里对比一下。</p><p>对于JDK8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况</span></span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    str1.intern();</span><br><span class="line">    String str2 = <span class="string">"a"</span>;</span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种情况</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    str3.intern();</span><br><span class="line">    String str4 = <span class="string">"aa"</span>;</span><br><span class="line">    System.out.println(str3 == str4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>但是在JDK6中执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>这个问题困扰了我很久，由于之前基础不是太扎实，所以直接就跳过了这个问题，在面试的时候几乎也不会太深究，但是一直成为我心里的坎。今天要把他解决掉。在说明这个问题之前，需要说明一下JVM有三种常量池：</p><h5>4.1 三种常量池</h5><ol><li>Class文件中的常量池</li></ol><p>这里面主要存放两大类常量：字面量和符号引用，符号引用包含三类常量：</p><ul><li>类和接口的全限定名(<code>Full Qualified Name</code>)</li><li>字段的名称和描述符(<code>Descriptor</code>)</li><li>方法的名称和描述符</li></ul><p>这个用<code>javap</code>看一下就能明白，这里只涉及字符串就不谈其他的了。简单地说，用双引号引起来的字符串字面量都会进这里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>str2</code>就是符号引用，<code>a</code>就是字面量。</p><ol start="2"><li>运行时常量池</li></ol><p>方法区的一部分。<code>Class</code>文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池(<code>Constant Pool Table</code>)，存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。</p><ol start="3"><li>全局字符串</li></ol><p><code>HotSpot VM</code>里，记录<code>interned string</code>的一个全局表叫做<code>StringTable</code>，它本质上就是个<code>HashSet&lt;String&gt;</code>。这是个纯运行时的结构，而且是惰性（<code>lazy</code>）维护的。</p><p>注意，它里面存放的是引用。</p><p>所以，一般我们说一个字符串进入了全局的字符串常量池其实是说在这个<code>StringTable</code>中保存了对它的引用，反之，如果说没有在其中就是说<code>StringTable</code>中没有对它的引用。</p><h5>4.2 字面量进入字符串常量池的时机</h5><p>先给出一个结论：就<code>HotSpot VM</code>的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在<code>StringTable</code>中并没有相应的引用，在堆中也没有对应的对象产生）</p><p>那么加载类的过程发生的是什么呢？</p><p>R大的一篇文章：</p><blockquote><p>在类加载阶段， JVM会在堆中创建 对应这些 class文件常量池中的 字符串对象实例 并在字符串常量池中驻留其引用。具体在resolve阶段执行。这些常量全局共享。</p></blockquote><p>这里说的比较笼统，没错，是<code>resolve</code>阶段，但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 <strong>JVM规范里明确指定resolve阶段可以是lazy的。</strong></p><p>所以，类加载的时候，必定要做的东西是，将class文件中字面量和符号引用放入运行时常量池中，而<code>JVM</code>规范里<code>Class</code>文件的常量池项的类型，有两种东西：<code>CONSTANT_Utf8</code>和<code>CONSTANT_String</code>。后者是<code>String</code>常量的类型，但它并不直接持有<code>String</code>常量的内容，而是只持有一个<code>index</code>，这个<code>index</code>所指定的另一个常量池项必须是一个<code>CONSTANT_Utf8</code>类型的常量，这里才真正持有字符串的内容。</p><p><code>CONSTANT_Utf8</code>会在类加载的过程中就全部创建出来，而<code>CONSTANT_String</code>则是<code>lazy resolve</code>的，例如说在第一次引用该项的<code>ldc</code>指令被第一次执行到的时候才会<code>resolve</code>。</p><h5>4.3 ldc指令是什么东西？</h5><p>简单地说，它用于将int、float或String型常量值从常量池中推送至栈顶</p><p>以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abc</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        String a = <span class="string">"AA"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看其编译后的Class文件如下：</p><p><img src="http://bloghello.oursnail.cn/jvm7-4.png" alt="image"></p><p>根据上面说的，在类加载阶段，这个 <code>resolve</code> 阶段（ <code>constant pool resolution</code>）是<code>lazy</code>的。换句话说并没有真正的对象，字符串常量池里自然也没有。执行<code>ldc</code>指令就是触发这个<code>lazy resolution</code>动作的条件。</p><p>ldc字节码在这里的执行语义是：到当前类的运行时常量池去查找该<code>index</code>对应的项,即上面说的<code>CONSTANT_String</code>指向的<code>index</code>，如果该项尚未<code>resolve</code>则<code>resolve</code>之，并返回<code>resolve</code>后的内容。</p><p>在遇到<code>String</code>类型常量时，<code>resolve</code>的过程如果发现<code>StringTable</code>已经有了内容匹配的<code>java.lang.String</code>的引用，则直接返回这个引用，反之，如果<code>StringTable</code>里尚未有内容匹配的<code>String</code>实例的引用，则会在<code>Java</code>堆里创建一个对应内容的<code>String</code>对象，然后在<code>StringTable</code>记录下这个引用，并返回这个引用出去。</p><p>这里很重要，昭示了一个重要问题：<code>String a = &quot;AA&quot;;</code>这一句执行完，要看字符串常量池中是否已经存在，不存在的话是要在堆中先创建对象的，然后把堆地址给全局的字符串常量池。</p><p>理解到这，有些问题就可以解决了，这里先不回答最上面的问题，先来看看下面的例子。注意运行环境是JDK8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTest0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s1=<span class="string">"static"</span>;  <span class="comment">// 第一句</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"he"</span>)+<span class="keyword">new</span> String(<span class="string">"llo"</span>); <span class="comment">//第二句</span></span><br><span class="line">        s2.intern(); <span class="comment">// 第三句</span></span><br><span class="line">        String s3=<span class="string">"hello"</span>;  <span class="comment">//第四句</span></span><br><span class="line">        System.out.println(s2 == s3);<span class="comment">//第五句，输出是true。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;static&quot;</code> <code>&quot;he&quot;</code> <code>&quot;llo&quot;</code> <code>&quot;hello&quot;</code>都会进入<code>Class</code>的常量池， 按照上面说的，类加载阶段由于<code>resolve</code> 阶段是<code>lazy</code>的，所以是不会创建实例，更不会驻留字符串常量池了。</p><p>但是要注意这个<code>“static”</code>和其他三个不一样，它是静态的，在类加载阶段中的初始化阶段，会为静态变量指定初始值，也就是要把<code>“static”</code>赋值给<code>s1</code>，这个赋值操作要怎么搞啊，先<code>ldc</code>指令把它放到栈顶，然后用<code>putstatic</code>指令完成赋值。注意，<code>ldc</code>指令，根据上面说的，会创建<code>&quot;static&quot;</code>字符串对象，并且会保存一个指向它的引用到字符串常量池。</p><p>运行<code>main</code>方法后，首先是第二句，一样的，要先用<code>ldc</code>把<code>&quot;he&quot;</code>和<code>&quot;llo&quot;</code>送到栈顶，换句话说，会创建他俩的对象（注意，在堆中开辟本体所占的空间，还没到new的那一步），并且会保存引用到字符串常量池中（把本地在堆中空间地址传给字符串常量池）；然后有个<code>＋</code>号对吧，内部是创建了一个<code>StringBuilder</code>对象，一路<code>append</code>，最后调用<code>StringBuilder</code>对象的<code>toString</code>方法得到一个<code>String</code>对象（内容是<code>hello</code>，注意这个<code>toString</code>方法会<code>new</code>一个<code>String</code>对象），并把它赋值给<code>s2</code>（s2指向的是new出来的新对象，是新的一块内存空间）。</p><p>注意，此时还没有把<code>hello</code>的引用放入字符串常量池。然后是第三句，<code>intern</code>方法一看，字符串常量池里面没有，它会把上面的这个<code>hello</code>对象的引用保存到字符串常量池，然后返回这个引用，但是这个返回值我们并没有使用变量去接收，所以没用。</p><p>第四句，字符串常量池里面已经有了，直接用嘛。所以<code>s2</code>和<code>s3</code>都是<code>s2</code>的指向的地址。</p><p>再来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    String s1=<span class="keyword">new</span> String(<span class="string">"he"</span>)+<span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">    String s2=<span class="keyword">new</span> String(<span class="string">"h"</span>)+<span class="keyword">new</span> String(<span class="string">"ello"</span>);</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    String s3=s1.intern();</span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    String s4=s2.intern();</span><br><span class="line">    <span class="comment">// ④</span></span><br><span class="line">    System.out.println(s1==s3);</span><br><span class="line">    System.out.println(s1==s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是将一些符号引用和字面量从class文件的常量池中撞到运行时常量池。然后运行main方法，先看第一句，会创建<code>&quot;he&quot;</code>和<code>&quot;llo&quot;</code>对象，并放入字符串常量池，然后会创建一个<code>&quot;hello&quot;</code>对象，没有放入字符串常量池，<code>s1</code>指向这个<code>&quot;hello&quot;</code>对象。</p><p>第二句，创建<code>&quot;h&quot;</code>和<code>&quot;ello&quot;</code>对象，并放入字符串常量池，然后会创建一个<code>&quot;hello&quot;</code>对象，没有放入字符串常量池，<code>s2</code>指向这个<code>&quot;hello&quot;</code>对象。</p><p>第三句，字符串常量池里面还没有，于是会把<code>s1</code>指向的<code>String</code>对象的引用放入字符串常量池（换句话说，放入池中的引用和<code>s1</code>指向了同一个对象），然后会把这个引用返回给了<code>s3</code>，所以<code>s3==s1</code>是<code>true</code>。</p><p>第四句，字符串常量池里面已经有了，直接将它返回给了<code>s4</code>，所以<code>s4==s1</code>是<code>true</code>。</p><p>此时，回到一开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    str1.intern();</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    String str2 = <span class="string">"a"</span>;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种情况</span></span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    <span class="comment">//6</span></span><br><span class="line">    str3.intern();</span><br><span class="line">    <span class="comment">//7</span></span><br><span class="line">    String str4 = <span class="string">"aa"</span>;</span><br><span class="line">    <span class="comment">//8</span></span><br><span class="line">    System.out.println(str3 == str4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk1.6及以前，调用<code>intern()</code></p><blockquote><p>如果常量池中不存在值相等的字符串时，jvm会复制一个字符串到创量池中，并返回常量池中的字符串。</p></blockquote><p>而在jdk1.7及以后，调用<code>intern()</code></p><blockquote><p>如果常量池中不存在值相等的字符串时，jvm只是在常量池记录当前字符串的引用，并返回当前字符串的引用。</p></blockquote><p>所以在JDK6情况下，都是返回false，原因是：第一种情况下，执行第一句，看到有个字符串<code>&quot;a&quot;</code>，那么首先是创建<code>&quot;a&quot;</code>本体对象，并且把副本放入字符串常量池中。执行第二句，发现字符串常量池中已经存在，则不放了。执行第三句，<br>s2指向的是字符串常量池中的<code>&quot;a&quot;</code>，这个字符串常量池<code>&quot;a&quot;</code>所在的地址，肯定与堆中的新new出来的不一样。所以返回false。</p><p>第二种情况，第一句相当于：</p><p>其实相当于:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String str3 =  (<span class="keyword">new</span> StringBuilder()).apend(s1).apend(s2).toString();</span><br></pre></td></tr></table></figure><p>会先在堆中创建两个对象<code>&quot;a&quot;</code>，拷贝一个副本到字符串常量池中，此时<code>&quot;a&quot;</code>已经存在于字符串常量池中了。然后拼接生成一个新的对象<code>&quot;aa&quot;</code>在堆中，这种拼接出来的<code>&quot;aa&quot;</code>此时是不会把副本放进字符串常量池的，因为字符串常量池只保存已确定的字面量，这种拼接的属于运行完成才能确定，所以字符串常量池中没有，直到执行第6句，才会尝试把<code>&quot;aa&quot;</code>副本放入字符串常量池，但是还是跟上面一样，一个指向堆，一个指向字符串常量池，肯定不相等。</p><p>在JDK6+情况下，第一个返回false，第二个返回true。原因是：第一种情况下，执行第一句，首先是创建<code>&quot;a&quot;</code>本体对象，并且把引用放进字符串常量池中，然后new，开辟新的地址空间，此时<code>str1</code>指向的是new出来的空间的引用。执行第二句，尝试将<code>str1</code>的引用放入字符串常量池，但是池中已经存在了，所以不能放，所以一个指向堆，一个是本体对象的引用，不一样，所以为false。第二种情况，<code>&quot;a&quot;</code>跟上面一样，在堆中开辟，然后引用放入字符串常量池中，后面拼接成<code>&quot;aa&quot;</code>，此时只是在堆中开辟空间，下面执行<code>intern</code>尝试把它的引用传给字符串常量池，由于字符串常量池中没有，所以就放进去了。此时字符串常量池中的引用与<code>&quot;aa&quot;</code>对象实际的堆地址是一样的，所以为true.</p><p>这边有一个事实：在执行<code>String s1 = new String(&quot;a&quot;)</code>的<code>new</code>之前，JVM先看到有一个字符串<code>&quot;a&quot;</code>，则会先看看字符串常量池中是否有这个<code>&quot;a&quot;</code>，有则直接返回字符串常量池引用，没有则给它开辟空间，并且把这个空间的引用传给字符串常量池。</p><p><img src="http://bloghello.oursnail.cn/jvm7-7.png" alt="image"></p><p>整理自：<a href="https://www.zhihu.com/question/55994121/answer/147296098" target="_blank" rel="noopener">木女孩的回答</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第七篇文章，介绍一些面试比较常问的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>内连接和外连接</title>
    <link href="http://yoursite.com/2019/02/05/mysql/%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/02/05/mysql/内连接和外连接/</id>
    <published>2019-02-05T14:19:25.724Z</published>
    <updated>2019-02-05T14:22:15.656Z</updated>
    
    <content type="html"><![CDATA[<p>在电信实习的时候，天天有人来面试，问的问题我都听的蛮清楚的，比如内连接和外连接的区别，好像很简单，但还是说的不好，这里总结一下。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A表                         B表</span><br><span class="line">id      name                id      name </span><br><span class="line">1          a                1       b </span><br><span class="line">2          b                3       c</span><br><span class="line">4          c</span><br></pre></td></tr></table></figure><h3>内连接</h3><p>内连接就是左表和右表相同的数据:</p><p><img src="http://bloghello.oursnail.cn/mysql9-1.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id      name            id      name </span><br><span class="line">1         a              1       b</span><br></pre></td></tr></table></figure><h3>左外连接</h3><p>左外连接就是以左表为准，去匹配右表，左表有多少条数据，结果就是多少条数据</p><p><img src="http://bloghello.oursnail.cn/mysql9-2.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id      name        id     name </span><br><span class="line">1         a          1       b </span><br><span class="line">2         b         null    null</span><br><span class="line">4         c         null    null</span><br></pre></td></tr></table></figure><h3>右外连接</h3><p>右外连接就是与左外连接反之，以右表为准，去匹配左表，右表有多少条数据，结果就是多少条数据</p><p><img src="http://bloghello.oursnail.cn/mysql9-3.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id      name            id     name </span><br><span class="line">1         a             1       b </span><br><span class="line">null    null            3       c</span><br></pre></td></tr></table></figure><h3>交叉连接</h3><p>交叉连接不带 <code>WHERE</code> 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到<br>结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查<br>询条件的数据行数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">join</span> B</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id  name  id  name</span><br><span class="line">1 a  1   b</span><br><span class="line">1 a  3   c</span><br><span class="line">2 b    1    b</span><br><span class="line">2 b  3   c</span><br><span class="line">4 c  1   b</span><br><span class="line">4 c  3   c</span><br></pre></td></tr></table></figure><h3>内连接和外连接的区别</h3><p>内连接只列出两张表共同匹配的数据行，而外连接的结果集中不仅包含符合连接条件的数据行，还包括左表(左外连接或左连接)或右表(右外连接或右连接)中的所有数据行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在电信实习的时候，天天有人来面试，问的问题我都听的蛮清楚的，比如内连接和外连接的区别，好像很简单，但还是说的不好，这里总结一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JAVA内存模型-线程共享</title>
    <link href="http://yoursite.com/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/"/>
    <id>http://yoursite.com/2019/02/05/JVM/JAVA内存模型-线程共享/</id>
    <published>2019-02-05T13:31:10.778Z</published>
    <updated>2019-02-05T13:37:32.005Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第六篇文章，介绍线程共享区域。</p><a id="more"></a><h2>一、内存模型–JAVA堆</h2><ul><li><p>java堆一般是java虚拟机所管理的内存中最大的一块。</p></li><li><p>java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p></li><li><p>堆上存放对象实例和数组。</p></li><li><p>java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p></li><li><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p></li></ul><h2>二、内存模型–方法区</h2><p><img src="http://bloghello.oursnail.cn/jvm5-4.png" alt="image"></p><blockquote><p>方法区和堆一样，是各个线程共享的内存区域。</p></blockquote><blockquote><p>它用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。</p></blockquote><blockquote><p>其中，类信息包含类的版本、字段、接口、方法</p></blockquote><h2>八、PermGen与Metaspace</h2><p>其实，方法区可以理解为一个规范，jdk6的具体实现是<code>PermGen</code>,而后来的版本具体实现是<code>Metaspace</code>。它们有一定的区别。</p><p>在 <code>HotSpot JVM</code> 中，永久代中用于存放类和方法的元数据以及常量池，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>永久代是有大小限制的，它用的是JVM内存，即与堆内存等价的<code>no heap</code>区域，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <code>java.lang.OutOfMemoryError: PermGen</code> ，为此我们不得不对虚拟机做调优。</p><ol><li>由于 <code>PermGen</code> 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 <code>JVM</code> 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li><li>移除 <code>PermGen</code> 可以促进 <code>HotSpot JVM</code> 与 <code>JRockit VM</code> 的融合，因为 <code>JRockit</code> 没有永久代。</li></ol><p>根据上面的各种原因，<code>PermGen</code> 最终被移除，方法区移至 <code>Metaspace</code>，字符串常量移至 <code>Java Heap</code>。<code>Metaspace</code>并不在虚拟机中，而是使用本地内存,十分方便管理，不会出现永久带内存溢出问题，垃圾回收的时候这个单独区域方便处理。</p><h2>三、运行时常量池</h2><blockquote><p>是方法区的一部分。</p></blockquote><blockquote><p>类文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法的运行时常量池中存放。</p></blockquote><blockquote><p>这里尤其值得注意的是字符串的创建，会被扔到字符串常量池中。如果是new，那么还是在堆重创建的。当然，运行时也可以产生新的常量放入池中，比如讲new出来的字符串用<code>intern()</code>方法便可以在运行时将其放到常量池中。</p></blockquote><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str3.intern()); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><blockquote><p>对于直接声明的内容相同的字符串，对于str2来说是不需要重新分配地址的，因为str1的hello这个常量已经存在于常量池中了。所以他们两个其实是一个东西。</p></blockquote><blockquote><p>对于new出来的str3，是不会直接扔到常量池中的，他是在堆中分配，地址不一样，所以显然是false。</p></blockquote><blockquote><p>String类的<code>intern()</code>方法，使得运行时将堆中产生的对象放入常量池中，所以是true。</p></blockquote><p>这里我在<a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" target="_blank" rel="noopener">java字符串核心一网打尽</a>中已经详细说明了，不再赘述。</p><h2>四、对象探秘</h2><h5>4.1 对象的创建过程</h5><ul><li><p>类加载检查：检查该对象的类是否已经被加载、解析、初始化过，如果没有则先进行类加载操作。</p></li><li><p>分配内存：如果内存规整使用“指针碰撞”分配，否则一般使用“空闲列表”分配，具体看垃圾回收器是否带有整理（<code>Compact</code>）空闲内存功能。</p></li><li><p>初始化：将内存区初始化置零，不包含对象头，这一步保证了对象的实例字段在java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p>对象头设置：这个对象是哪个类的实例、如何找到类的元数据信息、哈希码、GC分代年龄信息等即为对象头</p></li><li><p>对象的方法：即按照程序员的意愿进行初始化</p></li></ul><h5>4.2 对象的内存布局</h5><ul><li>对象头</li></ul><p><strong>一部分称为<code>Mark Word</code>，存储对象自身运行时的数据</strong>，包含哈希码、GC分代年龄、锁状态标志等等。</p><p>采用压缩存储，压缩到虚拟机位数（32位/64位）。由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计为一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p><strong>另一部分为类型指针，指向它的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例</strong>。并不是所有虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。</p><p>如果对象是一个java数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象的元数据信息确定java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p><ul><li><p>实例数据</p><ul><li>实例数据部分是对象真正存储的有效信息，也是在程序中定义的各种类型的字段内容。</li><li>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li><li>从分配策略中可以看出，相同宽度的字段总是分配在一起，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</li></ul></li><li><p>对齐填充</p><ul><li>非必需，只有前两者加起来非8的倍数时才会有。</li><li>因为<code>HotSpot VM</code> 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍。不对齐的时候，需要通过它来填充对齐。</li></ul></li></ul><h2>九、对象的访问定位</h2><ul><li>通过句柄访问</li></ul><p><img src="http://bloghello.oursnail.cn/jvm5-5.png" alt="image"></p><p>通过句柄访问对象：当java虚拟机GC移动堆对象时，并不需要修改<code>reference</code>，只需修改句柄对象的实例数据指针。</p><ul><li>通过直接指针访问</li></ul><p><img src="http://bloghello.oursnail.cn/jvm5-6.png" alt="image"></p><p>通过直接指针访问对象：加快了对象访问速度，比间接访问少一次对象实例数据的访问，<code>HotSpot</code>则采用的这种访问方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第六篇文章，介绍线程共享区域。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JAVA内存模型-线程私有</title>
    <link href="http://yoursite.com/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
    <id>http://yoursite.com/2019/02/05/JVM/JAVA内存模型-线程私有/</id>
    <published>2019-02-05T13:28:38.289Z</published>
    <updated>2019-02-05T13:30:54.924Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第五篇文章，JVM的内存模型一般是面试必问的点，因为对JVM内存模型有所了解，才会有可能知道调优手段。本篇文章首先介绍线程私有的一些区域。</p><a id="more"></a><h2>一、从整体看JVM运行时内存模型</h2><p><img src="http://bloghello.oursnail.cn/jvm5-1.png" alt="image"></p><p>下面详细说说各个部分的作用。</p><h2>二、内存模型–程序计数器</h2><ul><li><p><strong>占用内存小</strong>：是一块较小的内存空间，当前线程所执行的字节码的行号指示器。</p></li><li><p><strong>PC作用</strong>：字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></li><li><p><strong>线程独立</strong>：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们成这类内存区域为“线程私有”的内存。</p></li><li><p><strong>native方法</strong>：如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空(undefined).</p></li><li><p><strong>无内存溢出异常</strong>：此内存区域是唯一一个在java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p></li></ul><h2>三、内存模型–JAVA虚拟机栈</h2><p><img src="http://bloghello.oursnail.cn/jvm5-2.png" alt="image"></p><ul><li><p>线程私有，生命周期与线程相同。</p></li><li><p>虚拟机栈描述的是Java方法的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p></li></ul><h2>四、栈帧</h2><p><img src="http://bloghello.oursnail.cn/jvm5-3.png" alt="image"></p><ul><li><p>我们口中常常提到的栈与堆，其中栈就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p></li><li><p>局部变量表存放了编译期可知的各种基本数据类型(<code>boolean</code>,<code>byte</code>,<code>char</code>,<code>short</code>,<code>int</code>,<code>float</code>,<code>long</code>,<code>double</code>),对象引用(它不等同于对象本身，可能是一个指向对象地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)、<code>returnAddress</code>类型(指向了一条字节码指令的地址)</p></li><li><p>其中64位长度的<code>long</code>和<code>double</code>类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p></li><li><p>局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，比如递归层数过多，将抛出<code>StackOverflowError</code>异常；如果虚拟机可以动态扩展，即虚拟机栈申请过多，扩展时却无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>异常。</p></li></ul><h2>五、内存模型–本地方法栈</h2><ul><li><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈尾虚拟机执行java方法(也就是字节码)服务，而本地方法栈则为虚拟机用到的Native方法服务。</p></li><li><p><code>Sun HotSpot</code>虚拟机直接将本地方法栈和虚拟机栈合二为一。</p></li><li><p>与虚拟机栈一样会抛出<code>StackOverflowError</code>异常或者<code>OutOfMemoryError</code>异常。</p></li></ul><p><strong>什么是native方法？</strong></p><p>简单地讲，一个<code>Native Method</code>就是一个java调用非java代码的接口。一个<code>Native Method</code>是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在<code>C＋＋</code>中，你可以用<code>extern “C”</code>告知<code>C＋＋</code>编译器去调用一个C的函数。</p><p>下一篇来看看线程共享的区域。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第五篇文章，JVM的内存模型一般是面试必问的点，因为对JVM内存模型有所了解，才会有可能知道调优手段。本篇文章首先介绍线程私有的一些区域。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>细谈loadClass</title>
    <link href="http://yoursite.com/2019/02/05/JVM/%E7%BB%86%E8%B0%88loadClass/"/>
    <id>http://yoursite.com/2019/02/05/JVM/细谈loadClass/</id>
    <published>2019-02-05T11:10:58.655Z</published>
    <updated>2019-02-05T12:25:03.356Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第四篇文章，对于获取Class对象，其实我们不知不觉中已经接触过两种了，一种就是loadClass，一种就是<a href="http://fourcolor.oursnail.cn/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/" target="_blank" rel="noopener">反射</a>中的forName，它们到底有什么区别呢？其实涉及了类加载过程的区别。下面好好来探讨一下。</p><a id="more"></a><h2>一、问题的提出</h2><p>对于之前的 测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\swg\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"Robot"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家有没有疑惑，我们这里是用了<code>loadClass(name)</code>来加载对应的<code>Class</code>对象的，最后还需要进行<code>newInstance()</code>。那么为什么要调用<code>newInstance()</code>才行呢？</p><h5>1.1 new的方式构建对象实例</h5><p>下面要进行相应的测试。对于<code>Robot.java</code>:</p><p><img src="http://bloghello.oursnail.cn/jvm4-1.png" alt="image"></p><p>首先用<code>new</code>的方式：</p><p><img src="http://bloghello.oursnail.cn/jvm4-2.png" alt="image"></p><p>显示结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><h5>1.2 loadClass来获取Class对象</h5><p><img src="http://bloghello.oursnail.cn/jvm4-3.png" alt="image"></p><p>如果仅仅这样写，显示结果仅仅为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>也就是说，并不会触发<code>static</code>静态块的执行，也就是说这个类根本就没有初始化。</p><h5>1.3 forName来获取Class对象</h5><p><img src="http://bloghello.oursnail.cn/jvm4-4.png" alt="image"></p><p>显示结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><p>触发了静态块的执行。</p><h2>二、类加载过程</h2><p>要想说明上面区别产生的原因，这里必须要介绍一个从未使用过的类加载的过程。</p><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（<code>Loading</code>）、验证（<code>Verification</code>）、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>Using</code>)和卸载(<code>Unloading</code>)7个阶段。其中准备、验证、解析3个部分统称为连接（<code>Linking</code>）。如图所示：</p><p><img src="http://bloghello.oursnail.cn/jvm4-5.png" alt="image"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p><h5>2.1 加载</h5><p><strong>在加载阶段</strong>（可以参考<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法），虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个<code>Class</code>文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口；</li></ul><p>加载阶段和连接阶段（<code>Linking</code>）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h5>2.2 验证</h5><p>验证是连接阶段的第一步，这一阶段的目的是为了确保<code>Class</code>文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>验证阶段大致会完成4个阶段的检验动作</strong>：</p><blockquote><p>文件格式验证：验证字节流是否符合<code>Class</code>文件格式的规范；例如：是否以魔术<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></blockquote><blockquote><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比<code>javac</code>编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了<code>java.lang.Object</code>之外。</p></blockquote><blockquote><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></blockquote><blockquote><p>符号引用验证：确保解析动作能正确执行。</p></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h5>2.3 准备</h5><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量<code>value</code>在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把<code>value</code>赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器()方法之中，所以把<code>value</code>赋值为123的动作将在初始化阶段才会执行。</p><p><strong>至于“特殊情况”是指</strong>：<code>public static final int value=123</code>，即当类字段的字段属性是<code>ConstantValue</code>时，会在准备阶段初始化为指定的值，所以标注为<code>final</code>之后，<code>value</code>的值在准备阶段初始化为123而非0.</p><h5>2.4 解析</h5><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><p>对于这里说的：将符号引用替换为直接引用。很多人包括我第一次看到的时候感觉莫名其妙，教材上也是直接用这些专用名词，给我们的学习带来了极大的困扰。这里还是要解释一下。</p><p>比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>s</code>是符号引用，而<code>abc</code>是字面量。</p><p>此时，知道了什么是符号引用就好办了，因为符号引用一般都是放在栈中的，这个玩意肯定是依赖于实际的东西，相当于一个指针，多以我们程序需要将其解析成这个实际东西所在的真正的地址。所以，一旦解析了，那么内存中必然实际存在了这个对象，即拥有实际的物理地址了。</p><h5>2.5 初始化</h5><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程.</p><h2>三、new、loadClass、forName</h2><p>正常情况下，我们一般构建对象实例是通过<code>new</code>的方式，<code>new</code>是隐式构建对象实例，不需要<code>newInstance()</code>，并且可以用带参数的构造器来生成对象实例；</p><p>对于<code>new</code>，我们有点基础的，是知道，已经一直来到了最后初始化完成的这一步，生成了可以直接使用的对象实例。由于篇幅不宜太长，不想展开讲new的过程发生了什么，这里先贴个我觉得讲的不错的链接：<a href="https://www.jianshu.com/p/ebaa1a03c594" target="_blank" rel="noopener">https://www.jianshu.com/p/ebaa1a03c594</a></p><p>然而<code>loadClass(name)</code>这种显示调用的方式，我们可以看到，只有加载的功能，而没有后续连接以及初始化的过程。</p><p>所以<code>loadClass(name)</code>需要进行<code>newInstance()</code>才能生成对应的对象实例，并且这个<code>newInstance()</code>方法不支持参数调用，要想实现输入参数生成实例对象，需要通过反射获取构造器对象传入参数再生成对象实例。</p><p>这里也就解释了为什么要<code>newInstance()</code>，因为不这样，<code>loadClass(name)</code>只是加载，并没有后续过程，也就是说这个类根本就没有动它，仅仅是加载进来而已。从代码层面调用<code>loadClass()</code>的时候，我们可以看到一个之前故意忽视的东西：</p><p><img src="http://bloghello.oursnail.cn/jvm4-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/jvm4-7.png" alt="image"></p><p>这个<code>resolve</code>默认是传入<code>false</code>的，那么进来看看这个<code>resolveClass()</code>方法：</p><p><img src="http://bloghello.oursnail.cn/jvm4-8.png" alt="image"></p><p>再下去是<code>native</code>方法，不必关心，我们只看方法的注释即可，写的是链接指定的类，就是上面的连接过程。我们由上面知道，如果这个方法能执行，那么就会触发验证、准备、解析这三个过程，而准备阶段是会去执行静态方法或静态块，类变量会被进行初始化，即分配内存，但是仅仅赋初值即可。</p><p>所以，<code>loadClass(name)</code>有一种懒加载的思想在里面，要用了再去进行初始化，而不是一开始就初始化好。</p><p>既然已经知道了<code>new</code>和<code>loadClass</code>的区别了，下面再来看看<code>Class.forName()</code>,聪明的读者估计已经可以猜到了，没错，根据实验的结果来看，它至少要进行到连接完，实质它也完成了初始化，即已经到达第三步：</p><p><img src="http://bloghello.oursnail.cn/jvm4-9.png" alt="image"></p><p>总结一下：<code>loadClass</code>仅仅是第一步的加载，而<code>forName</code>和<code>new</code>都是已经初始化好了。</p><h2>存在的原因</h2><p>所谓存在即合理，<code>forName</code>的用法，最常见的莫过于用于加载数据库驱动这，我们这里实验一下，首先引入相关的依赖：</p><p><img src="http://bloghello.oursnail.cn/jvm4-10.png" alt="image"></p><p>经典写法来啦：</p><p><img src="http://bloghello.oursnail.cn/jvm4-11.png" alt="image"></p><p>点进去看看：</p><p><img src="http://bloghello.oursnail.cn/jvm4-12.png" alt="image"></p><p>我们这个时候发现，里面是一个<code>static</code>方法，也就是说，我们要立即创建驱动。所以这个时候必须用<code>forname</code>方法啦！</p><p>那么对于<code>loadClass</code>，其实上面已经提及了，就是懒加载，这个思想再<code>spring</code>中是到处可见的，<code>bean</code>只是加载，但是步进行初始化，等用的时候再去初始化，提高性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第四篇文章，对于获取Class对象，其实我们不知不觉中已经接触过两种了，一种就是loadClass，一种就是&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;反射&lt;/a&gt;中的forName，它们到底有什么区别呢？其实涉及了类加载过程的区别。下面好好来探讨一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派模型</title>
    <link href="http://yoursite.com/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/02/05/JVM/双亲委派模型/</id>
    <published>2019-02-05T08:18:14.365Z</published>
    <updated>2019-02-05T08:26:50.082Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第三篇文章，谈到JVM类加载机制，双亲委派模型是绕不开的话题，名字看好像是个高大上、深不可测的玩意，其实逐步揭开面纱之后很简单。下面我们就来揭揭看。</p><a id="more"></a><h2>回顾类加载器</h2><p>上一节简单说明了类加载器的作用，只说到一个核心功能是加载class文件。但是，绝对没有这么简单，神书《深入理解Java虚拟机》第二版对类加载器的说明：</p><blockquote><p>代码编译的结果从本地机器码转变成字节码，是存储格式的一小步，却是编程语言发展的一大步。</p><p>Java虚拟机把描述类的数据从Class文件加载进内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这动作的代码模块成为“类加载器”。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。这句话可以表达的更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</p></blockquote><p>对于上面进行一些说明：</p><p>注意，加载之后要将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）</p><p>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。这个<code>Class</code>对象并没有规定是在<code>Java</code>堆内存中，它比较特殊，虽为对象，但存放在方法区中。</p><p>这样，就可以使用这个类了。</p><p>还有，关于相等，只有在满足如下三个类“相等”判定条件，才能判定两个类相等。</p><ul><li>两个类来自同一个Class文件</li><li>两个类是由同一个虚拟机加载</li><li>两个类是由同一个类加载器加载</li></ul><h2>什么是双亲委派模型</h2><p>我们上一节已经知道了有四种类加载器，它们的实际关系为：</p><p><img src="http://bloghello.oursnail.cn/jvm3-1.png" alt="image"></p><p>从这个图来看，是一个继承的关系，是这样吗？我们用代码来看看是不是真的是这样。</p><p>代码还是用上一篇文章自定义类加载器来测试：</p><p><img src="http://bloghello.oursnail.cn/jvm3-3.png" alt="image"></p><p>结果是：</p><p><img src="http://bloghello.oursnail.cn/jvm3-4.png" alt="image"></p><p>从这个结果就很容易看出，层级关系是与上图所述的一样。那么，这个层级关系其实就是我们下面要说的双亲委派模型的结构。</p><p>这里还想补充一点：就是为什么最后一个是null，即<code>bootstrap</code>为什么显示null，其实是因为它是用C++实现的，不是java语言实现的，所以与其他几个都有区别，这里根据就调用不到，所以显示null。如果非要看<code>bootstrap</code>里面大概如何实现的，需要去看看<code>opjdk</code>的代码。</p><p>结合代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//2.首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">//3.如果当前类加载器没有加载过，进来</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//4.看是否有父类加载器，有则进来</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//5.父类加载器看看是否已经加载过</span></span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//进到这个，是来看看bootstrap类加载器是否加载过，没有加载过则加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一开始是false</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，就是先一级一级往上查询是否已经加载过，加载过直接返回即可；一直查询到<code>bootstrap</code>类加载器，都没有加载过，那么就从<code>bootstrap</code>类加载器开始一级一级向下到他们的扫描范围内尝试加载这个class文件，知道自定义类加载(如果有的话)，没有则返回找不到。</p><p>说一下代码的实现思路。代码使用递归实现的，先一级一级找父亲，即一级一级向上入栈，某一个查到了就返回，每一层递归停留在<code>c = parent.loadClass(name, false);</code>；都查不到，再一级一级出栈去执行，那么就从<code>c = findBootstrapClassOrNull(name);</code>后面的代码继续执行，那么显然就是执行<code>if (c == null) {...}</code>尝试去加载。</p><h2>为什么要用双亲委派模型</h2><p>为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：</p><blockquote><p>黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只<br>是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，<br>黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲<br>委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，<br>导致“病毒代码”被执行。</p></blockquote><p>而有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。</p><p>或许你会想，我在自定义的类加载器里面强制加载自定义的<code>java.lang.String</code>类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回<code>false</code>。</p><p>举个简单例子：</p><blockquote><p>ClassLoader1、ClassLoader2都加载java.lang.String类，对应Class1、Class2对象。<br>那么Class1对象不属于ClassLoad2对象加载的java.lang.String类型。</p></blockquote><p>委托机制的意义：防止内存中出现多份同样的字节码</p><p>比如两个类A和类B都要加载<code>System</code>类：</p><p>如果不用委托而是自己加载自己的，那么类A就会加载一份<code>System</code>字节码，然后类B又会加载一份<code>System</code>字节码，这样内存中就出现了两份<code>System</code>字节码。</p><p>如果使用委托机制，会递归的向父类查找，也就是首选用<code>Bootstrap</code>尝试加载，如果找不到再向下。这里的<code>System</code>就能在<code>Bootstrap</code>中找到然后加载，如果此时类B也要加载<code>System</code>，也从<code>Bootstrap</code>开始，此时<code>Bootstrap</code>发现已经加载过了<code>System</code>那么直接返回内存中的<code>System</code>即可而不需要重新加载，这样内存中就只有一份<code>System</code>的字节码了。</p><h2>一个面试题</h2><p>能不能自己写个类叫<code>java.lang.System</code>？</p><p>显然是不可以的，可能方案是自己搞一个这个类放在特殊目录，用自定义类加载器去加载，然而系统自身的类加载器会先去加载使用，下次再用的时候，是先逐级向上查询是否已经加载过，根本没有机会让自定义类加载器去加载。</p><p>所以，如果非要用，那么必定是要破坏双亲委派模型了，那么又回到为什么要用双亲委派模型的问题上了，所以，为了自己写一个<code>java.lang.System</code>而破坏双亲委派模型，我只能说，脑子秀逗了。所以不要搞这些东西，包名或类名写的不一样即可。</p><h2>一个问题</h2><p>那么为什么不能用一个加载器去一个目录加载所有呢？还要分这么多的类加载器，不是麻烦么？</p><p>其实，这个问题也是比较可笑的，毕竟每个层级的功能是不一样的，比如<code>bootstrap</code>是加载最核心的文件，没有它，都玩不起来。而自定义的呢？是比较特殊的需求，需要的时候才用到。对于这种有个性化的要求，一套代码来实现，显然是不合理的。</p><p>比如这个回答是根据加载的方式来思考的：</p><blockquote><p>每一个类加载器都是为了去在不同的情景下去加载类。比如，你可以从联网服务器上加载一个class文件，也可以从远程web服务器下载二进制类。这么设计是因为我们需要类加载器提供一致的接口，这样客户端就可以加载类但是却不用管类加载器到底是怎么实现的。启动类加载器能够加载JVM_HOME/lib 下的类，但如果我们需要在其他的情况下加载类呢？简单来说，加载类的方法有无数种，我们需要一个灵活的加载器系统去在特定的情况下按照我们的想法来加载类。</p></blockquote><p>还有一个回答是说更方便地对特定类进行优化：</p><blockquote><p>虽然 对java 虚拟机没有研究过，java 为什么不能 一个加载器 加载全部的类<br>很明显， 实现起来也可以<br>但是需要 的 代码 更多，也更难 为各种类进行 优化，为了更简单的抽象<br>我在明确知道 该类是启动类的情况下，我就会 为该类 进行优化。<br>如果是自定义类，可能就 不会进行 此类优化。<br>在明确 目的的情况下， 专用代码 比 通用代码 更简单，也更有效。</p></blockquote><p>总之，就是为了清晰和方便，这也是我们在进行软件设计的时候最基本的要求，即不能写死代码，影响扩展性；层次结构也不能写的太乱，影响后续的优化。</p><p>至此，双亲委派模型就讲完了。我们也清晰地知道了其设计思想和好处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第三篇文章，谈到JVM类加载机制，双亲委派模型是绕不开的话题，名字看好像是个高大上、深不可测的玩意，其实逐步揭开面纱之后很简单。下面我们就来揭揭看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>浅谈ClassLoader</title>
    <link href="http://yoursite.com/2019/02/05/JVM/%E6%B5%85%E8%B0%88ClassLoader/"/>
    <id>http://yoursite.com/2019/02/05/JVM/浅谈ClassLoader/</id>
    <published>2019-02-05T06:44:35.075Z</published>
    <updated>2019-02-05T08:17:49.416Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第二篇文章，上一篇文章初步提到了class文件，以及一个最简单程序执行的指令含义，我们提到，是由JAVA虚拟机先加载这些编译好的class文件，然后再去根据解析出来的指令去转换为具体平台上的机器指令执行，但是加载这个class文件时如何加载的呢？其实就涉及比较重要的东西：ClassLoader</p><a id="more"></a><p>有一个基本认识，从编译到实例化对象的过程可以概括为以下三个阶段：</p><ul><li>编译器将<code>xxx.java</code>源文件编译为<code>xxx.class</code>字节码文件</li><li><code>ClassLoader</code>将字节码转换为JVM种的<code>Class&lt;xxx&gt;</code>对象</li><li>JVM利用<code>Class&lt;xxx&gt;</code>对象实例化为<code>xxx</code>对象</li></ul><h2>一、JVM系统结构</h2><p><img src="http://bloghello.oursnail.cn/jvm2-1.png" alt="image"></p><ul><li><code>ClassLoader</code>：依据特定格式，加载class文件到内存</li><li><code>Execution Engine</code>：对命令进行解析</li><li><code>Native Interface</code>：融合不同开发语言的原生库为Java所用</li><li><code>Runtime Data Area</code>：JVM内存空间结构模型</li></ul><p>首先通过<code>ClassLoader</code>加载符合条件的字节码文件到内存中，然后通过<code>Execution Engine</code>解析字节码指令，交由操作系统去执行。</p><h2>二、什么是ClassLoader</h2><p><code>ClassLoader</code>在java中有着非常重要的作用，它主要工作在<code>Class</code>装载的加载阶段，其主要作用是从系统外部获得<code>Class</code>二进制数据流。他是JAVA的核心组件，所有的<code>Class</code>都是由<code>ClassLoader</code>进行加载的，<code>ClassLoader</code>负责通过将<code>Class</code>文件里的二进制数据流装载进系统，然后交给JAVA虚拟机进行连接、初始化等操作。</p><p>简而言之，就是加载字节码文件。</p><p>我们翻开<code>ClassLoader</code>源码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>它是一个抽象类，下面我们再来说具体的实现类。</p><p>里面比较重要的是<code>loadClass()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是根据<code>name</code>来加载字节码文件，返回<code>Class</code>实例，加载不到则抛出<code>ClassNotFoundException</code>异常。</p><h2>三、ClassLoader的种类</h2><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：由<code>C++</code>语言实现（针对<code>HotSpot</code>）,加载核心库<code>java.*</code>。</li></ul><ul><li>扩展类加载器（<code>Extension ClassLoader</code>）：Java编写，加载扩展库<code>javax.*</code></li></ul><p>它扫描的是哪个路径呢？</p><p><img src="http://bloghello.oursnail.cn/jvm2-2.png" alt="image"></p><p>我们看到，它负责将 <code>&lt;JAVA_HOME &gt;/lib/ext</code>或者由系统变量<code>-Djava.ext.dir</code>指定位置中的类库 加载到内存中。</p><ul><li>应用程序类加载器（<code>Application ClassLoader</code>）：Java编写，加载程序所在目录</li></ul><p><img src="http://bloghello.oursnail.cn/jvm2-3.png" alt="image"></p><p>它负责将 用户类路径(<code>java -classpath</code>或<code>-Djava.class.path</code>变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，看截图的最后一行，显示的是当前项目路径。</p><ul><li>自定义<code>ClassLoader</code>：自定义</li></ul><h2>四、如何自定义ClassLoader</h2><p>要自己实现一个<code>ClassLoader</code>，其核心涉及两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先想一下为什么是这两个类？</p><p>其实答案在<code>loadClass()</code>这个方法里面。如果已经熟悉双亲委派模型的同学，都会知道加载<code>Class</code>对象是先委派给父亲，看父亲是否已经加载，如果没有加载过，则从最顶层父亲开始逐层往下进行加载，这一块详细在下一篇文章中解释，我们先走马观花看看这个的核心方法长啥样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不去重写<code>findClass(name)</code>方法，默认是直接抛出找不到的异常，所以我们要对这个方法进行重写。</p><p>由于字节码文件是一堆二进制流，所以需要一个方法来根据这个二进制流来定义成一个类，即<code>defineClass()</code>这个方法来实现这个功能。</p><p>说的比较抽象，下面来真正实践一把！</p><h2>五、实践自定义ClassLoader</h2><p>首先写一个类：Robot.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello , i am a robot!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对<code>Robot.java</code>用<code>javac</code>编译之后形成<code>Robot.class</code>文件，就要删除本项目下的这个<code>Robot.java</code>文件，要不然就会被<code>AppClassLoader</code>类加载先加载了，而无法再被我们的自定义类加载器再去加载。这个<code>Robot.class</code>文件我就直接放到桌面去了。路径为<code>C:/Users/swg/Desktop/</code>.</p><p>然后定义一个自定义的<code>ClassLoader</code>，按照上面的理论，只要重写<code>findClass</code>就可以指定到某个地方获取class字节码文件，此时获取的是二进制流文件，转换为字节数组，最后借用<code>defineClass</code>获取真正的<code>Class</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行加载的class文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">//自定义类加载器的名字</span></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    MyClassLoader(String path,String classLoaderName)&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于寻找类文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于加载类文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        name = path + name + <span class="string">".class"</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in  = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试一下能不能用自定义类加载器去加载到<code>Robot</code>对应的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\swg\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"Robot"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader@677327b6</span><br><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><p>好了，学习了关于<code>ClassLoader</code>的分类以及如何自定义<code>ClassLoader</code>，我们知道了类加载器的基本实现，上面谈到了一个重要方法是<code>loadClass</code>，这就涉及了类加载器的双亲委派模型。下一节从代码层面好好来说说这个，其实很简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第二篇文章，上一篇文章初步提到了class文件，以及一个最简单程序执行的指令含义，我们提到，是由JAVA虚拟机先加载这些编译好的class文件，然后再去根据解析出来的指令去转换为具体平台上的机器指令执行，但是加载这个class文件时如何加载的呢？其实就涉及比较重要的东西：ClassLoader&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2019年展望</title>
    <link href="http://yoursite.com/2019/02/05/suibi/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/"/>
    <id>http://yoursite.com/2019/02/05/suibi/2019年展望/</id>
    <published>2019-02-05T05:38:52.590Z</published>
    <updated>2019-02-05T11:36:14.733Z</updated>
    
    <content type="html"><![CDATA[<p>今天是大年初一，算是真正步入2019年了。保存几张老家门口拍的照片，以作纪念。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/suibi1-2.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/suibi1-3.jpg" alt="image"></p><p>老家越来越冷清，越来越萧条。</p><p>今年四月底顺利毕业的话，就真的工作了，在南京，本科+研究生读了七年书，加上小时候每年暑假都来南京玩，对南京的熟悉的程度远远大于家乡盐城。</p><p>所以希望可以努力，在南京能扎下根，然后一家人全搬过去。</p><p>在找工作方面，找的并不理想，可能还在不好的几个offer之中选择了更不好的一个，心里甚是难受。不过，凡事都没有绝对，往好处多想想就好了，关键还是靠自己努力。</p><p>在2018年，算是学习java的进阶之年，自己学习了很多新的技术，也好好地夯实了基础，把以前很多模糊的问题搞清楚了，确实，基础真的太重要的，光学时髦的框架，可以写写简单的CRUD应用，是远远不够的，我觉得程序员的目标是可以造出大家都认可并且乐于使用的开源作品，没有好的基础，便是天方夜谭，也只能永远做一个普通的码农。</p><p>所以，我给自己定一个三年的目标，三年以后，无论是搞java还是搞大数据还是其他，我希望能达到中高级水平，在这个行业方向上有较好的基础和较深的认识。为后续更高的发展打下坚实的基础。</p><p>我希望，github真正能成为我出发的地方，并且能够走很远。犹记得，14年在大神室友的推荐下，注册了github，但是真正使用还是从去年开始吧。所以甚是惭愧，如果早一点上路，虽然追赶不上大神的脚步（已经进了google），但是进个二线比如京东、美团等都是轻而易举吧，但是谈这些确实是废话，没有人有假如。</p><p>除了对未来三年的一些初步想法之外，我还是希望我与家人都有一个健健康康的身体，所以工作以后身体的锻炼是必不可少的，八块腹肌是不指望了，至少爬几层楼不用喘吧。</p><p>一切还是视实际情况而定，但是终身学习的信念要埋藏在心里，这个时代以及未来的时代，选择了这一行，掉头发是注定的了，但是如果仅仅以掉头发的代价，可以让家人舒舒服服，健健康康，开开心心的话，那给我剃个光头也无妨了。</p><p>废话不多说了，我要继续完成本笔记的JVM部分了，不忘初心，套用喜剧之王的台词：努力，奋斗！</p><p><img src="http://bloghello.oursnail.cn/suibi1-4.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是大年初一，算是真正步入2019年了。保存几张老家门口拍的照片，以作纪念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>彻底理解java反射机制</title>
    <link href="http://yoursite.com/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/02/04/java-basic/彻底理解java反射/</id>
    <published>2019-02-04T08:33:13.519Z</published>
    <updated>2019-02-04T08:42:30.505Z</updated>
    
    <content type="html"><![CDATA[<p>反射机制这一块也是面试经常会被问到的，我从反射的基本概念到反射的一些面试题出发，好好理一理反射的知识。</p><a id="more"></a><h2>1. 什么是反射</h2><p>标准定义：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用方法的功能成为反射机制。</p><p>注意几个关键字：运行状态中，动态获取。</p><h2>2. Class对象和实例对象</h2><p>想要理解反射首先需要知道<code>Class</code>这个类，它的全称是<code>java.lang.Class</code>类。java是面向对象的语言，讲究万物皆对象，即使强大到一个类，它依然是另一个类（<code>Class</code>类）的对象，换句话说，普通类是<code>Class</code>类的对象，即<code>Class</code>是所有类的类（<code>There is a class named Class</code>）。</p><p>我们知道java世界是运行在JVM之上的，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的<code>.class</code>文件，这个就是JVM可以加载执行的字节码。</p><p>运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(<code>class loader</code>)的<code>defineClass()</code>被JVM调用，便会为这个类产生一个<code>Class</code>对象（一个<code>Class</code>类的实例），用来表达这个类，该类的所有实例都共同拥有着这个<code>Class</code>对象，而且是唯一的。</p><p>也就是说，加载<code>.class</code>文件之后会生成一个对应的<code>Class</code>对象。下面说说如何获取这个<code>Class</code>对象。</p><h2>3. 取得Class对象的三种方式</h2><p>我们假设有这么一个类叫<code>MyClass</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li>第一种方式：通过“类名.class”的方式取得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class classInstance= MyClass.class;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Car.class;</span><br><span class="line">Class cls1 = int.class;</span><br><span class="line">Class cls2 = String.class;</span><br></pre></td></tr></table></figure><ul><li>第二种方式：通过类创建的实例对象的<code>getClass</code>方法取得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">Class classInstance = myClass.getClass();</span><br></pre></td></tr></table></figure><ul><li>第三种方式：通过<code>Class</code>类的静态方法<code>forName</code>方法取得（参数是带包名的完整的类名）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class classInstance = Class.forName(<span class="string">"mypackage.MyClass"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种方法取得的对象都是相同的，所以效果上等价。</p><p><code>classInstance</code>是类类型，通过类类型可以得到一个类的属性和方法等参数，这是反射的基础。</p><h2>4. 利用反射API全面分析类的信息——方法，成员变量，构造器</h2><p>反射的一大作用是用于分析类的结构，或者说用于分析和这个类有关的所有信息。而这些信息就是类的基本的组成： 方法，成员变量和构造器。</p><p>在java种万物皆对象，一个类中的方法，成员变量和构造器也分别对应着一个对象</p><ol><li>每个方法都对应有一个保存和该方法有关信息的<strong>Method对象</strong>， 这个对象所属的类是<code>java.lang.reflect.Method</code>;</li><li>每个成员变量都对应有一个保存和该变量有关信息的<strong>Field对象</strong>，这个对象所属的类是 <code>java.lang.reflect.Field</code></li><li>每个构造器都对应有一个保存和该构造器有关信息的<strong>Constructor对象</strong>，这个对象所属的类是<code>java.lang.reflect.Constructor</code></li></ol><p>假设c是一个类的Class对象：</p><ul><li>通过 <code>c.getDeclaredMethods()</code>可取得这个类中所有声明方法对应的<code>Method</code>对象组成的数组</li><li>通过 <code>c.getDeclaredFields()</code>可取得这个类中所有声明的成员变量对应的<code>Field</code>对象组成的数组</li><li>通过 <code>c.getConstructors()</code>; 可取得这个类中所有构造函数所对应的<code>Constructor</code>对象所组成的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method [] methods = c.getDeclaredMethods(); <span class="comment">// 获取方法对象列表</span></span><br><span class="line"> </span><br><span class="line">Field [] fields = c.getDeclaredFields();   <span class="comment">// 获取成员变量对象列表</span></span><br><span class="line"></span><br><span class="line">Constructor [] constructors = c.getConstructors();  <span class="comment">// 获取构造函数对象列表</span></span><br><span class="line"></span><br><span class="line">xxx.getName()就可以打印出对应的名字了。</span><br></pre></td></tr></table></figure><h2>5. 更多的反射api</h2><h5>getMethods和getDeclaredMethods方法</h5><ul><li><code>getMethods</code>取得的<code>method</code>对应的方法<strong>包括从父类中继承的那一部分</strong>，而</li><li><code>getDeclaredMethods</code>取得的<code>method</code>对应的方法<strong>不包括从父类中继承的那一部分</strong></li></ul><p>一个普通的类，他们的基类都是<code>Object</code>，那么如果用<code>getMethods</code>，遍历得到的结果，会发现<code>Object</code>中的基础方法名都会被打印出来。</p><p>诸如<code>wait()</code>,<code>equals()</code>,<code>toString()</code>,<code>getClass()</code>,<br><code>notify()</code>,<code>notifyAll()</code>,<code>hashCode()</code>等等。</p><h5>通过method.getReturnType()获取方法返回值对应的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class returnClass = method.getReturnType(); <span class="comment">// 获取方法返回值对应的Class对象</span></span><br><span class="line">String returnName = returnClass.getName();  <span class="comment">//获取返回值所属类的类名——也即返回值类型</span></span><br></pre></td></tr></table></figure><h5>通过method.getParameterTypes()获取方法各参数的Class对象组成的数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class [] paramsClasses = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class pc: paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName(); <span class="comment">// 获取当前参数类型</span></span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>获取成员变量类型对应的的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = c.getDeclaredField(<span class="string">"name"</span>);  <span class="comment">// 取得名称为name的field对象</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 这一步很重要！！！设置为true才能访问私有成员变量name的值！</span></span><br><span class="line">String nameValue = (String) field.get(obj); <span class="comment">// 获取obj中name成员变量的值</span></span><br></pre></td></tr></table></figure><h5>通过getType方法读取成员变量类型的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = class1.getDeclaredField(number<span class="string">");</span></span><br><span class="line"><span class="string">System.out.print(field.getType().getName());</span></span><br></pre></td></tr></table></figure><p>因为java权限的原因，直接读取私有成员变量的值是非法的（加了<code>field.setAccessible(true)</code>后就可以了），但仍可以直接读取私有成员变量的类型</p><h5>利用反射API分析类中构造器信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> a, String str)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printContructorsMessage</span> <span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">Class c = obj.getClass();  <span class="comment">// 取得obj所属类对应的Class对象</span></span><br><span class="line">Constructor [] constructors = c.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">  Class [] paramsClasses =  constructor.getParameterTypes();</span><br><span class="line">  String paramsStr = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (Class pc : paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName();</span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"构造函数的所有参数的类型列表："</span> + paramsStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数的所有参数的类型列表：<span class="keyword">int</span>  java.lang.String</span><br></pre></td></tr></table></figure><h2>6. 利用反射动态加载类，并用该类创建实例对象</h2><p>我们用普通的方式使用一个类的时候，类是静态加载的<br>，<strong>而使用Class.forName(“XXX”)这种方式，则属于动态加载一个类</strong></p><p>静态加载的类在编译的时候就能确定该类是否存在，但动态加载一个类的时候却无法在编译阶段确定是否存在该类，而是在运行时候才能够确定是否有这个类，所以要捕捉可能发生的异常.</p><p>Class对象有一个<code>newInstance</code>方法，我们可以用它来创建实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class classInstance = Class.forName(<span class="string">"mypackage.MyClass"</span>);</span><br><span class="line">MyClass myClass = (MyClass) classInstance.newInstance();</span><br></pre></td></tr></table></figure><h2>7. 总结</h2><ul><li>反射为我们提供了全面的分析类信息的能力，例如类的方法，成员变量和构造器等的相关信息，反射能够让我们很方便的获取这些信息， 而实现这个获取过程的关键是取得类的<code>Class</code>对象，然后根据<code>Class</code>对象取得相应的<code>Method</code>对象，<code>Field</code>对象和<code>Constructor</code>对象，再分别根据各自的API取得信息。</li><li>反射还为我们提供动态加载类的能力</li><li>API中<code>getDeclaredXXX</code>和<code>getXXX</code>的区别在于前者只获取本类声明的XXX（如成员变量或方法），而不获取超类中继承的XXX， 后者都可以获取</li><li>API中， <code>getXXXs</code>（注意后面的s）返回的是一个数组， 而对应的 <code>getXXX</code>（“键”）按键获取一个值（这个时候因为可能报已检查异常所以要用try*catch语句包裹）</li><li>私有成员变量是不能直接获取到值的！因为java本身的保护机制，允许你取得私有成员变量的类型，但是不允许直接获取值，所以要对对应的<code>field</code>对象调用<code>field.setAccessible(true)</code> 放开权限</li></ul><h2>8. 面试</h2><h4>什么是反射</h4><p>反射是一种能够在程序运行时动态访问、修改某个类中任意属性（状态）和方法（行为）的机制</p><h4>反射到底有什么具体的用处</h4><ul><li>操作因访问权限限制的属性和方法；</li><li>实现自定义注解；</li><li>动态加载第三方jar包，解决android开发中方法数不能超过65536个的问题；</li><li>按需加载类，节省编译和初始化APK的时间；</li></ul><h4>反射的原理是什么</h4><p>当我们编写完一个Java项目之后，每个java文件都会被编译成一个.class文件，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被ClassLoader加载到虚拟机中。当一个类被加载以后，Java虚拟机就会在内存中自动产生一个Class对象。我们通过new的形式创建对象实际上就是通过这些Class来创建，只是这个过程对于我们是透明的而已。</p><p>反射的工作原理就是借助<code>Class.java</code>、<code>Constructor.java</code>、<br><code>Method.java</code>、<code>Field.java</code>这四个类在程序运行时动态访问和修改任何类的行为和状态。</p><h4>如何获取Class对象</h4><ul><li><code>Class</code>的<code>forName()</code>方法的返回值就是<code>Class</code>类型，也就是动态导入类的<code>Class</code>对象的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure><ul><li>每个类都会有一个名称为<code>Class</code>的静态属性，通过它也是可以获取到<code>Class</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz = Student.class;</span><br></pre></td></tr></table></figure><ul><li><code>Object</code>类中有一个名为<code>getClass</code>的成员方法，它返回的是对象的运行时类的<code>Class</code>对象。因为<code>Object</code>类是所有类的父类，所以，所有的对象都可以使用该方法得到它运行时类的<code>Class</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">Class&lt;Student&gt; clazz = stu.getClass();</span><br></pre></td></tr></table></figure><h4>反射的特点</h4><blockquote><p>优点</p></blockquote><ul><li>灵活、自由度高：不受类的访问权限限制，想对类做啥就做啥</li></ul><blockquote><p>缺点</p></blockquote><ul><li>性能问题</li></ul><p>通过反射访问、修改类的属性和方法时会远慢于直接操作，但性能问题的严重程度取决于在程序中是如何使用反射的。如果使用得很少，不是很频繁，性能将不会是什么问题；</p><ul><li>安全性问题</li></ul><p>反射可以随意访问和修改类的所有状态和行为，破坏了类的封装性，如果不熟悉被反射类的实现原理，随意修改可能导致潜在的逻辑问题；</p><h4>如何提高反射性能</h4><p>java应用反射的时候，性能往往是java程序员担心的地方，那么在大量运用反射的时候，性能的微弱提升，对这个系统而言都是如旱地逢甘霖。</p><ul><li><code>setAccessible(true)</code>,可以防止安全性检查（做这个很费时）</li><li>做缓存，把要经常访问的元数据信息放入内存中，<code>class.forName</code> 太耗时</li><li><code>getMethods()</code> 等方法尽量少用，尽量调用<code>getMethod(name)</code>指定方法的名称，减少遍历次数</li></ul><h4>java面试中面试官让你讲讲反射，应该从何讲起？</h4><p>先讲反射机制，反射就是程序运行期间JVM会对任意一个类洞悉它的属性和方法，对任意一个对象都能够访问它的属性和方法。依靠此机制，可以动态的创建一个类的对象和调用对象的方法。</p><p>其次就是反射相关的API，只讲一些常用的，比如获取一个<code>Class</code>对象。<code>Class.forName(完整类名)</code>。通过<code>Class</code>对象获取类的构造方法，<code>class.getConstructor</code>。根据<code>Class</code>对象获取类的方法，<code>getMethod</code>和<code>getMethods</code>。使用<code>Class</code>对象创建一个对象，<code>class.newInstance</code>等。</p><p>最后可以说一下反射的优点和缺点，优点就是增加灵活性，可以在运行时动态获取对象实例。缺点是反射的效率很低，而且会破坏封装，通过反射可以访问类的私有方法，不安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射机制这一块也是面试经常会被问到的，我从反射的基本概念到反射的一些面试题出发，好好理一理反射的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java如何执行一个最简单的程序</title>
    <link href="http://yoursite.com/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/03/JVM/Java如何执行一个最简单的程序/</id>
    <published>2019-02-03T03:44:31.998Z</published>
    <updated>2019-02-03T06:09:47.192Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第一篇文章，需要之前对JVM有一定了解的基础。我们都知道，JAVA号称：一次编译多处运行。这就离不开字节码文件和虚拟机啦！那么，虚拟机到底是如何去执行一个简单的程序的呢？理解了这个，我们就可以理解java时如何做到平台无关的了。下面我们来分析分析。</p><a id="more"></a><p>首先，写一个最简单的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">5</span>;</span><br><span class="line">        i++;</span><br><span class="line">        ++j;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后的结果想必就一目了然，我们就通过这个程序来分析分析到底是怎么执行这个程序额的。</p><p>首先呢，java程序的执行经历编译，编译成系统能识别的文件，这里的系统对应java语言就是JVM，即JAVA虚拟机。JVM在识别之后，再去与我们真正的操作系统进行交互和处理。</p><p>所以，我们要执行一个.java程序，必须要先进行编译。初学者都会学习一个指令叫做<code>javac</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-1.png" alt="image"></p><p>我们会发现路径下面就会多一个.class文件，这就是编译之后的文件。直接点开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> var1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> var2 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> var3 = var1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> var4 = var2 + <span class="number">1</span>;</span><br><span class="line">        System.out.println(var3);</span><br><span class="line">        System.out.println(var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看第一行注释，说的是编译后的文件已经自动被<code>IDEA</code>反编译了，所以我们还能看得懂。真正的文件是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">漱壕   4 </span><br><span class="line">    </span><br><span class="line">     &lt;init&gt; ()V Code LineNumberTable main ([Ljava/lang/String;)V </span><br><span class="line">SourceFile Main.java         Main java/lang/Object java/lang/System out Ljava/io/PrintStream; java/io/PrintStream println (I)V !                    *? ?             </span><br><span class="line">      E     &lt;=??? ? ? ? ?</span><br></pre></td></tr></table></figure><p>我们可以看到，其实是一堆乱码，根本看不懂。而在执行的时候，class文件是一种8位字节的二进制流文件。放在<code>sublime</code>中可以看到二进制文件（以16进制显示，在JAVA虚拟机中将来了解这各文件的含义，我们可以看到第一个单词是cafe babe，表明这是一个class字节码文件）：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-2.png" alt="image"></p><p>那么我们想看看.class中的信息，还是需要反编译，这个时候可以用<code>javap</code>指令来做。如果我们对其不熟悉，可以先执行<code>javap -help</code>来了解了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>我们注意到，有一个<code>-c</code>是进行反汇编，那么就用它试试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;javap -c Main.class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Compiled from &quot;Main.java&quot;</span><br><span class="line">public class Main &#123;</span><br><span class="line">  public Main();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_5</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iinc          1, 1</span><br><span class="line">       7: iinc          2, 1</span><br><span class="line">      10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      13: iload_1</span><br><span class="line">      14: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      17: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: iload_2</span><br><span class="line">      21: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      24: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这反汇编出来的东西是什么呢？这是一连串的指令，其实这些是加载class文件时真正执行的java虚拟机指令。</p><p>我们来看看它的含义吧！</p><p><img src="http://bloghello.oursnail.cn/javabasic6-3.png" alt="image"></p><p>仔细看看，其实发现并不神秘，一个函数的执行是一个入栈出栈的过程。ok，大体了解了字节码文件是什么以及里面的指令含义之后，我们对java如何执行它已经大体清楚了。下面执行一下：</p><p>那么如何运行呢？</p><p><img src="http://bloghello.oursnail.cn/javabasic6-4.png" alt="image"></p><p>其实这是废话，初学java其实是<code>java Main</code>运行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;java Main</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>这个时候，class文件可以移植到任何平台上去，比如直接上传到<code>linux</code>上，只要JDK或者JRE环境类似即可，就可以直接运行了，不需要编译，也不需要关心是什么系统。这就做到了一次编译到处运行。</p><p>下面总结一下：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-5.png" alt="image"></p><p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，JAVA语言在不同平台上运行时不需要进行重新编译，JAVA虚拟机在执行字节码的时候，把字节码转换为具体平台上的机器指令，然后各种操作系统就可以正确识别了。这就是JAVA如何执行代码和平台无关性的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第一篇文章，需要之前对JVM有一定了解的基础。我们都知道，JAVA号称：一次编译多处运行。这就离不开字节码文件和虚拟机啦！那么，虚拟机到底是如何去执行一个简单的程序的呢？理解了这个，我们就可以理解java时如何做到平台无关的了。下面我们来分析分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>关于Redis一些重要的面试点</title>
    <link href="http://yoursite.com/2019/02/02/redis/%E5%85%B3%E4%BA%8ERedis%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%82%B9/"/>
    <id>http://yoursite.com/2019/02/02/redis/关于Redis一些重要的面试点/</id>
    <published>2019-02-02T13:39:56.932Z</published>
    <updated>2019-02-02T13:40:28.368Z</updated>
    
    <content type="html"><![CDATA[<p>这里整理一些面试题目，很多已经在前面的文章中详细说明了，这里算是总结一下。也补充了一点新的知识。</p><a id="more"></a><h2>Redis有哪些数据结构？</h2><p>字符串 <code>String</code>、字典 <code>Hash</code> 、列表 <code>List</code> 、集合 <code>Set</code> 、有序集合 <code>SortedSet</code>。</p><p>如果你是Redis中高级用户，还需要加上下面几种数据结构<code>HyperLogLog</code>、<code>Geo</code>、<code>Pub/Sub</code>。</p><h2>String类型的底层数据结构</h2><p>Redis 是一个键值对数据库, 数据库的值可以是字符串、集合、列表等多种类型的对象， 而数据库的键则总是字符串对象。</p><p>对于那些包含字符串值的字符串对象来说， 每个字符串对象都包含一个 <code>sds</code> 值。</p><div class="tip">“包含字符串值的字符串对象”，这种说法初听上去可能会有点奇怪， 但是在 Redis 中， 一个字符串对象除了可以保存字符串值之外， 还可以保存 long 类型的值， 所以为了严谨起见， 这里需要强调一下： 当字符串对象保存的是字符串时， 它包含的才是 sds 值， 否则的话， 它就是一个 long 类型的值。</div><p>举个例子， 以下命令创建了一个新的数据库键值对， 这个键值对的键和值都是字符串对象， 它们都包含一个 <code>sds</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET book &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET book</span><br><span class="line">&quot;Mastering C++ in 21 days&quot;</span><br></pre></td></tr></table></figure><p>目前来说， 只要记住这个事实即可： 在 <code>Redis</code> 中， 客户端传入服务器的协议内容、 aof 缓存、 返回给客户端的回复， 等等， 这些重要的内容都是由 <code>sds</code> 类型来保存的。</p><p>在 C 语言中，字符串可以用一个 <code>\0</code> 结尾的 <code>char</code> 数组来表示。</p><p>比如说， <code>hello world</code> 在 C 语言中就可以表示为 <code>&quot;hello world\0&quot;</code> 。</p><p>这种简单的字符串表示，在大多数情况下都能满足要求，但是，它并不能高效地支持长度计算和追加（<code>append</code>）这两种操作：</p><ul><li>每次计算字符串长度（<code>strlen(s)</code>）的复杂度为 θ(N) 。</li><li>对字符串进行 N 次追加，必定需要对字符串进行 N 次内存重分配（<code>realloc</code>）。</li></ul><p>在 <code>Redis</code> 内部， 字符串的追加和长度计算很常见， 而 <code>APPEND</code> 和 <code>STRLEN</code> 更是这两种操作，在 <code>Redis</code> 命令中的直接映射， 这两个简单的操作不应该成为性能的瓶颈。</p><p>另外， <code>Redis</code> 除了处理字符串之外， 还需要处理单纯的字节数组， 以及服务器协议等内容， 所以为了方便起见， <code>Redis</code> 的字符串表示还应该是二进制安全的： 程序不应对字符串里面保存的数据做任何假设， 数据可以是以 \0 结尾的 C 字符串， 也可以是单纯的字节数组， 或者其他格式的数据。</p><p>考虑到这两个原因， <code>Redis</code> 使用 <code>sds</code> 类型替换了 C 语言的默认字符串表示： sds 既可高效地实现追加和长度计算， 同时是二进制安全的。</p><p>在前面的内容中， 我们一直将 <code>sds</code> 作为一种抽象数据结构来说明， 实际上， 它的实现由以下两部分组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 已占用长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 剩余可用长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，类型 <code>sds</code> 是 <code>char *</code> 的别名（alias），而结构 <code>sdshdr</code> 则保存了 <code>len</code> 、 <code>free</code> 和 <code>buf</code> 三个属性。</p><p>作为例子，以下是新创建的，同样保存 <code>hello world</code> 字符串的 <code>sdshdr</code> 结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    len = 11;</span><br><span class="line">    free = 0;</span><br><span class="line">    buf = &quot;hello world\0&quot;;  // buf 的实际长度为 len + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>len</code> 属性， <code>sdshdr</code> 可以实现复杂度为 θ(1) 的长度计算操作。</p><p>另一方面， 通过对 <code>buf</code> 分配一些额外的空间， 并使用 <code>free</code> 记录未使用空间的大小， <code>sdshdr</code> 可以让执行追加操作所需的内存重分配次数大大减少。</p><p>为了易于理解，我们用一个 <code>Redis</code> 执行实例作为例子，解释一下，当执行以下代码时， <code>Redis</code> 内部发生了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND msg <span class="string">" again!"</span></span><br><span class="line">(integer) <span class="number">18</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world again!"</span></span><br></pre></td></tr></table></figure><p>首先， <code>SET</code> 命令创建并保存 <code>hello world</code> 到一个 <code>sdshdr</code> 中，这个 <code>sdshdr</code> 的值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    buf = <span class="string">"hello world\0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <code>APPEND</code> 命令时，相应的 <code>sdshdr</code> 被更新，字符串 &quot; again!&quot; 会被追加到原来的 “hello world” 之后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">18</span>;</span><br><span class="line">    buf = <span class="string">"hello world again!\0                  "</span>;     <span class="comment">// 空白的地方为预分配空间，共 18 + 18 + 1 个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中， 保存 “hello world again!” 共需要 18 + 1 个字节， 但程序却为我们分配了 18 + 18 + 1 = 37 个字节 —— 这样一来， 如果将来再次对同一个 <code>sdshdr</code> 进行追加操作， 只要追加内容的长度不超过 <code>free</code> 属性的值， 那么就不需要对 <code>buf</code> 进行内存重分配。</p><div class="tip">这种分配策略会浪费内存吗？执行过 APPEND 命令的字符串会带有额外的预分配空间， 这些预分配空间不会被释放， 除非该字符串所对应的键被删除， 或者等到关闭 Redis 之后， 再次启动时重新载入的字符串对象将不会有预分配空间。<p>因为执行 APPEND 命令的字符串键数量通常并不多， 占用内存的体积通常也不大， 所以这一般并不算什么问题。</p><p>另一方面， 如果执行 APPEND 操作的键很多， 而字符串的体积又很大的话， 那可能就需要修改 Redis 服务器， 让它定时释放一些字符串键的预分配空间， 从而更有效地使用内存。</p></div><p>当然， <code>sds</code> 也对操作的正确实现提出了要求 —— 所有处理 <code>sdshdr</code> 的函数，都必须正确地更新 <code>len</code> 和 <code>free</code> 属性，否则就会造成 bug 。</p><p>更多参见：<a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html" target="_blank" rel="noopener">简单动态字符串</a></p><h2>从海量数据中查询某一固定前缀的key</h2><p>使用<code>keys</code>指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<code>scan</code>指令，scan指令可以<strong>无阻塞</strong>的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><p>基于游标的迭代器，需要使用上一次游标延续之前的迭代过程。游标为0的时候代表开始或结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#模式</span><br><span class="line">scan cursor match pattern count</span><br><span class="line">#示例</span><br><span class="line">scan 0 match k* count 10</span><br></pre></td></tr></table></figure><h2>Redis做异步队列</h2><p>一般使用<code>list</code>结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当<code>lpop</code>没有消息的时候，要适当<code>sleep</code>一会再重试。</p><p>如果对方追问可不可以不用<code>sleep</code>呢？<code>list</code>还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p><p>如果对方追问能不能生产一次消费多次呢？使用<code>pub/sub</code>主题订阅者模式，可以实现1:N的消息队列。</p><p>如果对方追问<code>pub/sub</code>有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>rabbitmq</code>等。</p><p>如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用<code>sortedset</code>，拿时间戳作为<code>score</code>，消息内容作为<code>key</code>调用<code>zadd</code>来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理。</p><h2>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2>Redis如何做持久化的？</h2><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><p>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><p>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h2>Redis的同步机制了解么？</h2><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h2>是否使用过Redis集群，集群的原理是什么？</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p><p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><p>整理自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32540678" target="_blank" rel="noopener">天下无难试之Redis面试题刁难大全</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里整理一些面试题目，很多已经在前面的文章中详细说明了，这里算是总结一下。也补充了一点新的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
</feed>
