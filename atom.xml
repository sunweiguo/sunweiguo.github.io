<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-22T08:20:57.218Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>004-sort-list</title>
    <link href="http://yoursite.com/2019/03/22/leetcode-classic/004-sort-list/"/>
    <id>http://yoursite.com/2019/03/22/leetcode-classic/004-sort-list/</id>
    <published>2019-03-22T08:20:14.190Z</published>
    <updated>2019-03-22T08:20:57.218Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第四题，对链表进行排序。</p><a id="more"></a><h2>题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p><p>Example 1:</p><blockquote><p>Input: 4-&gt;2-&gt;1-&gt;3</p><p>Output: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p>Example 2:</p><blockquote><p>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</p><p>Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h2>解题思路</h2><p>最近忙着追《都挺好》，差点忘记每天的任务。这一题要求时间复杂度为O(n log n) 并且用常数级别的空间复杂度。对于链表这种数据结构，不像数组那么方便，因此堆排序以及快速排序不是很方便，因此这一题用归并排序比较合适，并且对于本题，空间上不需要用数组来存储，因此是常数级别的。</p><h2>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归并排序的归过程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判定是否为空或者只有一个元素，这也是归并排序中归的停止条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.将链表截成两段</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.此时pre跟slow指的一样，现在将链表从中间断开</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.继续再对上面分开的链表再分</span></span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.递归分开之后就应该按照一定的规则合并了</span></span><br><span class="line">        <span class="keyword">return</span> merge(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并排序的并过程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//新建一个结点用于串联并过程结果</span></span><br><span class="line">        ListNode tmp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//并的过程，谁小谁就接到p后面</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果有一段没有结束，直接接到后面即可</span></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回下一个结点</span></span><br><span class="line">        <span class="keyword">return</span> tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第四题，对链表进行排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>003-Max Points on a Line</title>
    <link href="http://yoursite.com/2019/03/21/leetcode-classic/003-Max%20Points%20on%20a%20Line/"/>
    <id>http://yoursite.com/2019/03/21/leetcode-classic/003-Max Points on a Line/</id>
    <published>2019-03-21T04:33:04.880Z</published>
    <updated>2019-03-21T04:33:51.164Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第三题，关于求坐标共线问题。</p><a id="more"></a><h2>题目描述</h2><p><img src="http://bloghello.oursnail.cn/leetcode3-1.png" alt="image"></p><h2>解题思路</h2><p>点共线，那么最容易想到的思路就是确定斜率，斜率相同不就共线了。但是还有两点特殊情况需要考虑，二是当两个点重合时，无法确定一条直线，但这也是共线的情况，需要特殊处理。二是斜率不存在的情况，由于两个点(x1, y1)和(x2, y2)的斜率k表示为(y2 - y1) / (x2 - x1)，那么当x1 = x2时斜率不存在，这种共线情况需要特殊处理。这里我对重合的情况，斜率不存在的情况以及斜率为0的情况进行了讨论，因为这比较好处理，所以处理一下斜率为0的没什么问题。最后就是通用情况，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(points.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> points.length;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Double,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="keyword">int</span> overlap = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> vertical = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> horizon = <span class="number">0</span>;   </span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">double</span> rate = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="keyword">double</span> gapx = <span class="keyword">new</span> Double(points[i].x) - <span class="keyword">new</span> Double(points[j].x);</span><br><span class="line">                <span class="keyword">double</span> gapy = <span class="keyword">new</span> Double(points[i].y) - <span class="keyword">new</span> Double(points[j].y);</span><br><span class="line">                <span class="keyword">if</span>(gapx == <span class="number">0</span> &amp;&amp; gapy == <span class="number">0</span>)&#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gapx == <span class="number">0</span>)&#123;</span><br><span class="line">                    vertical++;</span><br><span class="line">                    max = Math.max(max,vertical);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gapy == <span class="number">0</span>)&#123;</span><br><span class="line">                    horizon++;</span><br><span class="line">                    max = Math.max(max,horizon);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    rate = gapy/gapx;</span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(rate))&#123;</span><br><span class="line">                        map.put(rate,map.get(rate)+<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        map.put(rate,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    max = Math.max(max,map.get(rate));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result=Math.max(result, max+overlap+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以在牛客上通过，但是这个思路在leetcode上已经不行了，它给的例子是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input      [[0,0],[94911151,94911150],[94911152,94911151]]</span><br><span class="line">Output     3</span><br><span class="line">Expected   2</span><br></pre></td></tr></table></figure><p>我们注意到，由于精度丢失问题，我们算出来的斜率竟然是一样的了，所以这个程序错误地认为这三个点都共线了。因此错误。那怎么办呢？</p><h2>代码提交</h2><p>由于通过斜率来判断共线需要用到除法，而用double表示的双精度小数在有的系统里不一定准确，为了更加精确无误的计算共线，<strong>我们应当避免除法</strong>，从而避免无线不循环小数的出现，那么怎么办呢，我们把除数和被除数都保存下来，不做除法，但是<u><strong>我们要让这两数分别除以它们的最大公约数，这样例如8和4，4和2，2和1，这三组商相同的数就都会存到一个映射里面，同样也能实现我们的目标。</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(points.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> points.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//key为每个数组除以最大公约数后的结果，比如[8,4],[4,2],[2,1]最后都变成[2,1]存储</span></span><br><span class="line">        Map&lt;Map&lt;Integer,Integer&gt;,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">//每次循环完毕要清空map，否则会把上次统计结果带到下一次循环来</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="comment">//重复个数，自己算重复元素，所以初始元素为1</span></span><br><span class="line">            <span class="keyword">int</span> dup = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="comment">//计算出两者间隔</span></span><br><span class="line">                <span class="keyword">int</span> x = points[i].x - points[j].x;</span><br><span class="line">                <span class="keyword">int</span> y = points[i].y - points[j].y;</span><br><span class="line">                <span class="comment">//重合的话就将dup加一</span></span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">                    dup++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算最大公约数</span></span><br><span class="line">                <span class="keyword">int</span> d = gcd(x, y);</span><br><span class="line">                Map&lt;Integer,Integer&gt; tmpMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                tmpMap.put(x/d,y/d);</span><br><span class="line">                <span class="comment">//次数</span></span><br><span class="line">                map.put(tmpMap, map.getOrDefault(tmpMap, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//每次都将最大的放到max中，避免最后还要遍历判断map中最大次数</span></span><br><span class="line">                max = Math.max(max,map.get(tmpMap));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后的结果就是map+dup</span></span><br><span class="line">            result = Math.max(result,max+dup);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b == <span class="number">0</span>) ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第三题，关于求坐标共线问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>javascript基础扫尾</title>
    <link href="http://yoursite.com/2019/03/20/front/javascript%E5%9F%BA%E7%A1%80%E6%89%AB%E5%B0%BE/"/>
    <id>http://yoursite.com/2019/03/20/front/javascript基础扫尾/</id>
    <published>2019-03-20T13:09:32.070Z</published>
    <updated>2019-03-20T13:09:54.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文继续对js的基础知识进行学习。</p><a id="more"></a><h2>一、日期操作</h2><p>对于日期一般都是简单的显示，因为处理都是在后端的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(now);<span class="comment">//当前时间：Wed Mar 20 2019 14:58:09 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以自定义时间</span></span><br><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2019-03-20 15:04:14"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以set也可以get</span></span><br><span class="line"><span class="built_in">console</span>.log(now.getDay());</span><br><span class="line"><span class="built_in">console</span>.log(now.getMonth());<span class="comment">//注意0代表的是一月份</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>二、字符串的一些操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//字符串处理</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"HELLO fossi"</span>;</span><br><span class="line"><span class="comment">//str = str.replace("o","O");//替换o为O</span></span><br><span class="line">str = str.replace(<span class="regexp">/o/gi</span>,<span class="string">"e"</span>);<span class="comment">//g全局，i表示忽略大小写，这里用到了正则表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line">str = <span class="string">"HELLO fossi"</span>;</span><br><span class="line"><span class="keyword">var</span> res = str.split(<span class="string">" "</span>);<span class="comment">//按照空格进行切割，返回的是数组</span></span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">// ["HELLO", "fossi"]</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>关于字符串的操作有很多很多，且与其他主流语言支持的差不多，所以就不赘述了。</p><h2>三、函数的调用和声明位置</h2><p>一般情况下，函数是先定义再调用。但是在js中如果是普通的函数，那么无论是先声明再调用还是先调用再声明，都是可以的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//1.先调用函数，再声明函数</span></span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.先声明函数再调用</span></span><br><span class="line"><span class="comment">//console.log(add1(2,3));//OK</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>但是另一种方式，就是一个函数作为一个变量的写法，就必须先声明再调用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(add2(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//ERROR</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//作为一个变量的话，必须先声明后使用</span></span><br><span class="line"><span class="keyword">var</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(add2(2,3));//OK</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>四、函数作为参数传递</h2><p>js非常灵活，一个函数就可以作为参数传递进另一个函数中。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//函数可以作为参数传递给另一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num+<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFuntion</span>(<span class="params">someFuntion,arg</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> someFuntion(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callFuntion(addTen,<span class="number">100</span>));<span class="comment">//110</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>五、根据属性对对象进行排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">// 自定义的排序</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">name:<span class="string">"fossi"</span>,</span><br><span class="line">age:<span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">name:<span class="string">"swg"</span>,</span><br><span class="line">age:<span class="number">30</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">name:<span class="string">"swg"</span>,</span><br><span class="line">age:<span class="number">25</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [person1,person2,person3];</span><br><span class="line"><span class="comment">//用createComparator进行排序的定义</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(createComparator(<span class="string">"age"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparator</span>(<span class="params">propertyName</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> value1 = obj1[propertyName];</span><br><span class="line"><span class="keyword">var</span> value2 = obj2[propertyName];</span><br><span class="line"><span class="keyword">if</span>(value1 &gt; value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1 &lt; value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>六、apply和call</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">// apply call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="comment">//1.第一种写法</span></span><br><span class="line"><span class="comment">// return sum.apply(this,arguments);</span></span><br><span class="line"><span class="comment">//2.第二种写法</span></span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,[num1,num2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span>,num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><code>apply</code>和<code>call</code>方法类似，简单理解，都是相当于调用其他的方法。它有个显著的特点就是改变作用域，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//可以改变作用域</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">color</span>:<span class="string">"green"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showColor();<span class="comment">//red</span></span><br><span class="line">showColor.apply(person);<span class="comment">//green</span></span><br><span class="line">showColor.call(person);<span class="comment">//green</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>直接调用必然是全局域中的<code>red</code>，但是用<code>apply</code>方法的话，传禁区的是<code>person</code>这个对象，那么此时打印出来的就是这个对象中的属性值。</p><h2>七、包装类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//基本类型的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"hello fossi"</span>;</span><br><span class="line"><span class="comment">// 等价于：var s = new String("hello fossi");</span></span><br><span class="line"><span class="keyword">var</span> res = s.split(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是一旦包装类型创建成功后就不能再像普通对象一样添加属性</span></span><br><span class="line">s.name = <span class="string">"fossi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.name);<span class="comment">//undefined</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>包装类型可以提供一些方法让你调用，十分方便。上面说的是字符串，还有布尔和number类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> falseObj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);<span class="comment">//尽量不要用,会引起一些必要的问题</span></span><br><span class="line"><span class="keyword">var</span> fal = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObj);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fal);<span class="comment">//boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//number类型</span></span><br><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> number = <span class="number">10.005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number.toFixed(<span class="number">2</span>));<span class="comment">//指定显示的小数的位数，这里就是10.01</span></span><br><span class="line"><span class="keyword">var</span> number2 = <span class="number">2374281472</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number2.toExponential());<span class="comment">//指数来表示</span></span><br><span class="line"><span class="built_in">console</span>.log(number2.toPrecision(<span class="number">3</span>));<span class="comment">//自己指定位数显示</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>八、eval</h2><p>这玩意可就厉害了，可以把js的语句包在字符串里面，可以直接执行和调用，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//可以在eval里面嵌套语句或者函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"console.log(a)"</span>);<span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"function say()&#123;alert(a)&#125;"</span>);</span><br><span class="line">say();<span class="comment">//hello world</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>九、面向对象</h2><p>我们知道定义一个对象，如果没有任何处理的话，可以直接修改它的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"swg"</span>; <span class="comment">//如果不让随意做修改怎么办呢?</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>此时就需要给它加上一些规则，允许对它干什么，不允许对它干什么，都规定好。那么如果不允许对它的属性进行修改的话，那么就不能通过上面的方式进行随意修改了，这如何实现的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>));</span><br><span class="line"><span class="comment">//主要显示的是四个属性:</span></span><br><span class="line"><span class="comment">//&#123;value: "fossi", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">//value:值;</span></span><br><span class="line"><span class="comment">//writable是否可以修改;</span></span><br><span class="line"><span class="comment">//enumerable是否支持for-in遍历;</span></span><br><span class="line"><span class="comment">//configurable是否允许删除</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>下面我们来实际操作一下这几个属性。</p><p>首先我配置它不允许被删除，下面再删除属性试试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据属性-控制对象的数据</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">configurable:<span class="literal">false</span>,<span class="comment">//不允许删除此属性</span></span><br><span class="line">value:<span class="string">"swg"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//swg</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//没有报错,还是swg</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>下面配是一下不能修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据属性-控制对象的数据</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">configurable:<span class="literal">false</span>,<span class="comment">//不允许删除此属性</span></span><br><span class="line">writable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//fossi</span></span><br><span class="line">person.name = <span class="string">"swg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//fossi</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>修改不成功，说明不让在外面修改了。好了，关于数据属性就介绍这么多，下面说一下访问器属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">_age: <span class="number">0</span>,</span><br><span class="line">sex: <span class="number">1</span>,</span><br><span class="line">birth:<span class="number">1994</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据属性-控制对象的数据</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"age"</span>,&#123;</span><br><span class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._age = <span class="number">2019</span>-<span class="keyword">this</span>.birth;</span><br><span class="line">&#125;,</span><br><span class="line">set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>._age = newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.age);<span class="comment">//25</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>就是说一调用<code>person.name</code>的时候就会自动调用<code>get</code>来获取，这里就可以实现动态的获取年龄。</p><p>注意，这里的age用_age代替.前面加下划线是常用的用法,表示只能用对象方法访问的属性.如果用age回导致死循环赋值.</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">0</span>,</span><br><span class="line">sex: <span class="number">1</span>,</span><br><span class="line">birth:<span class="number">1994</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据属性-控制对象的数据</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"age"</span>,&#123;</span><br><span class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age = <span class="number">2019</span>-<span class="keyword">this</span>.birth;</span><br><span class="line">&#125;,</span><br><span class="line">set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.age);<span class="comment">//25</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test.html:22 Uncaught RangeError: Maximum call stack size exceeded</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文继续对js的基础知识进行学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>002-evaluate-reverse-polish-notation</title>
    <link href="http://yoursite.com/2019/03/20/leetcode-classic/002-evaluate-reverse-polish-notation/"/>
    <id>http://yoursite.com/2019/03/20/leetcode-classic/002-evaluate-reverse-polish-notation/</id>
    <published>2019-03-20T03:45:59.138Z</published>
    <updated>2019-03-20T03:46:30.140Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第二题，关于栈的操作。</p><a id="more"></a><h2>题目描述</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.<br>Valid operators are+,-,*,/. Each operand may be an integer or another expression.<br>Some examples:</p><p><img src="http://bloghello.oursnail.cn/leetcode2-1.png" alt="image"></p><h2>解题思路</h2><p>这一题提示信息是用栈来实现，那么思路为：如果当前元素是数字就入栈，否则就是运算符，那么就将这个运算符前面两个数字进行相应操作，并且将这个操作结果重新再放入栈中，参与下一次的运算。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tokens == <span class="keyword">null</span> || tokens.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tokens.length == <span class="number">1</span>)&#123;</span><br><span class="line">            res = Integer.valueOf(tokens[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">"+"</span>) || str.equals(<span class="string">"-"</span>) || str.equals(<span class="string">"*"</span>) || str.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> v1 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> v2 = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(str.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">                    res = v1+v2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"-"</span>))&#123;</span><br><span class="line">                    res = v2-v1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"*"</span>))&#123;</span><br><span class="line">                    res = v1*v2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">                    res = v2/v1;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(res);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(str));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第二题，关于栈的操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>001-Minimum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2019/03/20/leetcode-classic/001-Minimum%20Depth%20of%20Binary%20Tree/"/>
    <id>http://yoursite.com/2019/03/20/leetcode-classic/001-Minimum Depth of Binary Tree/</id>
    <published>2019-03-20T03:15:24.805Z</published>
    <updated>2019-03-20T03:16:23.477Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第一题，关于树。</p><a id="more"></a><h2>题目描述</h2><p>Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><h2>解题思路</h2><p>解决树的问题，递归肯定是最简单的代码。我们之前练习过求树的最大深度，但是要注意，求最小深度和最大深度是稍微有点不一样的，因为最大深度只需要考虑哪边大即可，即使是单子树（树只有一侧有结点），方式与求双子树的最大深度是一样的。但是对于求最小深度而言，如果出现单子树的情况，那么按照最小深度的定义：根结点到叶子结点的最小距离，那么显然这个最小深度是表示有结点的那一侧。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口条件1</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归出口条件2</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意点是要考虑是单子树的情况，因为很有可能只有一侧有节点，那么最小深度就是这以一侧</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> run(root.right)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> run(root.left)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是双子树，则对比树两边谁小即可，与求最大深度一样</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(run(root.left),run(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第一题，关于树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>javascript基础学习</title>
    <link href="http://yoursite.com/2019/03/19/front/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/19/front/javascript基础学习/</id>
    <published>2019-03-19T13:56:39.529Z</published>
    <updated>2019-03-19T14:04:31.654Z</updated>
    
    <content type="html"><![CDATA[<p>js和其他的语言很像，很多的操作都是一样的，比如数值的运算符、循环的控制等，这些基础的语法知识就不再赘述了，本文着重是对比较重要的知识点进行总结，尤其是关于对象和数组这块的处理，因为对于前端来说，大多数数据不是对象(json)就是数组，所以掌握其中的一些api会事半功倍。</p><a id="more"></a><h2>一、数据类型</h2><p>虽然说定义变量都是<code>var</code>，但是其实是分为几种类型的，下面我们来看看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="string">'hello'</span>;</span><br><span class="line">     <span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">var</span> d;</span><br><span class="line">     <span class="keyword">var</span> e = alert;</span><br><span class="line">     <span class="keyword">var</span> f = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*基本数据类型*/</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> d);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> e);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>我们看到，可以用<code>typeof</code>来查看每个变量的类型，它们是：</p><p><img src="http://bloghello.oursnail.cn/js1-1.png" alt="image"></p><h2>二、无限大</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/*无限大以及NAN*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="number">3</span>*<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE/<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>/<span class="number">0</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>执行的结果是：</p><p><img src="http://bloghello.oursnail.cn/js1-2.png" alt="image"></p><p>我们看到，无穷与0想成则为NAN，就是说它也不知道这到底是啥玩意，其他的基本都是表示无限大的<code>Infinity</code></p><h2>三、函数参数问题</h2><p>在我们比较熟悉的静态语言比如C，C++以及Java中，调用函数的话，参数一定要明确，否则会出错。比如一个函数明明没有任何形参，但是你调用的时候硬生生地传递几个参数进去，那么编译的时候就会报错。但是js中是不会的。一个函数可以定义为无参，但是调用的时候，你可以添加几个参数进去，所以是动态的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//可以没有形式参数</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">         <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">             sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(add(a,b));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>所以上面这个程序是可以正常执行的。</p><h2>四、作用域问题</h2><p>如果是一个局部变量，那么在外面正常情况下是无法访问到的，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//作用域</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">             <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log(a);<span class="comment">//error</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这里的a就无法在函数外面访问到，因为这个a是函数f的内部局部变量，外面的只能访问全局变量。这也符合我们其他语言的规范，但是这里要注意，定义在<code>if</code>,<code>while</code>以及<code>for</code>代码块中的局部变量我们依然可以在外面访问到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log(a);<span class="comment">//ok</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>五、数组如何定义</h2><p>数组是一种引用类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        alert(<span class="string">"arr 是数组"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在对于传入的参数不清楚的情况下，我们可以先判断一下类型是不是符合我们的要求，这可以提高程序的健壮性，就像先判断是否为空再操作的原则。</p><h2>六、定义一个对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//第一种 new Object</span></span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    person.name = <span class="string">"fossi"</span>;</span><br><span class="line">    person.age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这跟java中定义形式几乎一样，访问它的属性也一样，就是<code>person.name</code>即可。</p><p>还有一种比较常用的定义对象的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//第二种 new Object</span></span><br><span class="line">    <span class="keyword">var</span> person = &#123;<span class="string">"name"</span>:<span class="string">"fossi"</span>,</span><br><span class="line">                  <span class="string">"age"</span>:<span class="number">20</span>,</span><br><span class="line">                  <span class="string">"fun"</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                     alert(<span class="string">"i am a person"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">    person.fun();</span><br><span class="line">    <span class="built_in">console</span>.log(person[<span class="string">"age"</span>]);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>注意，一个函数也可以作为它的成员变量，类似于java中的成员方法。</p><h2>七、数组打印</h2><p>数组非常重要，掌握数组常用的技巧将事半功倍。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//opeartion of array</span></span><br><span class="line">    <span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"yellow"</span>,<span class="string">"blue"</span>];</span><br><span class="line">    colors[<span class="number">8</span>] = <span class="string">"pink"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    <span class="built_in">console</span>.log(colors.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.valueOf());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.toLocaleString());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.join(<span class="string">"|"</span>));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这几个基本都是以不同的形式打印出数组来，最后一个是指用<code>|</code>来拼接数组元素再打印。</p><p><img src="http://bloghello.oursnail.cn/js1-3.png" alt="image"></p><h2>八、数组实现栈以及队列</h2><p>数组可以直接用<code>push</code>和<code>pop</code>实现栈的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//stack</span></span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    stack.push(<span class="string">"fossi"</span>);</span><br><span class="line">    stack.push(<span class="string">"vainda"</span>);</span><br><span class="line">    stack.push(<span class="string">"xiaoxu"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果也显而易见：</p><p><img src="http://bloghello.oursnail.cn/js1-4.png" alt="image"></p><p>下面再用数组来模拟队列，<code>shift()</code> 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值，也是非常简单的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//queue push+shift or unshift+pop</span></span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    queue.push(<span class="string">"fossi"</span>);</span><br><span class="line">    queue.push(<span class="string">"vainda"</span>);</span><br><span class="line">    queue.push(<span class="string">"xiaoxu"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果也显而易见：</p><p><img src="http://bloghello.oursnail.cn/js1-6.png" alt="image"></p><h2>九、数组的拼接和删除</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"yellow"</span>,<span class="string">"blue"</span>,<span class="string">"pink"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.后面拼接一个元素进去</span></span><br><span class="line">    <span class="built_in">console</span>.log(colors.concat(<span class="string">"green"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.从0号开始删除一个元素</span></span><br><span class="line">    colors.splice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.从2号元素开始删除一个元素,再插入两个新元素</span></span><br><span class="line">    colors.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"black"</span>,<span class="string">"white"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.根据元素获取下标索引</span></span><br><span class="line">    <span class="built_in">console</span>.log(colors.indexOf(<span class="string">"yellow"</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(colors.lastIndexOf(<span class="string">"yellow"</span>));<span class="comment">//不存在则返回-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.遍历数组</span></span><br><span class="line">    colors.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">        <span class="built_in">console</span>.log(index);</span><br><span class="line">        <span class="built_in">console</span>.log(array);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>关于第5个，每个参数都是啥呢？</p><p><img src="http://bloghello.oursnail.cn/js1-7.png" alt="image"></p><h2>十、数组的高级操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全部都要满足条件，有一个不满足就返回false</span></span><br><span class="line">    <span class="keyword">var</span> flag = num.every(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//每一个item都必须小于4才返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> num &lt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(flag);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只要有一个满足条件即可，也是返回true或者false</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.some(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">         <span class="comment">//只要有一个满足条件即可</span></span><br><span class="line">        <span class="keyword">return</span> item &lt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//过滤出符合条件的值</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每一个元素进行同样的操作</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item*<span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对元素进行统计</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> sum = num.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre,curr,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre+curr;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>前面的几个都比较好理解，最后两个可能比较抽象一点。其实这个在大数据中式比较常用的概念，比较典型的就是<code>MapReduce</code>这个组件，其实就是两个过程，一个是<code>map</code>一个是<code>reduce</code>，前者是对每个值进行相应的操作，后者是对这些处理完的值进行合并。从而达到一些数据统计的目的。比如这里，我对每个值简单乘以2，那么数组就变为<code>[2,8,4,12,16,6,2]</code>；下面一个实现的是求和功能，算出来是25.还可以进行很多的操作。</p><p>ok，后续其他的再学习，且记录到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js和其他的语言很像，很多的操作都是一样的，比如数值的运算符、循环的控制等，这些基础的语法知识就不再赘述了，本文着重是对比较重要的知识点进行总结，尤其是关于对象和数组这块的处理，因为对于前端来说，大多数数据不是对象(json)就是数组，所以掌握其中的一些api会事半功倍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>05-软件设计七大原则-接口隔离原则</title>
    <link href="http://yoursite.com/2019/03/19/design-pattern/05-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/03/19/design-pattern/05-软件设计七大原则-接口隔离原则/</id>
    <published>2019-03-19T11:06:56.699Z</published>
    <updated>2019-03-19T11:07:23.947Z</updated>
    
    <content type="html"><![CDATA[<p>本文来了解一下什么是接口隔离原则。</p><a id="more"></a><h2>定义</h2><ul><li>用多个专门的接口，而不适用单一的总接口，客户端不应该依赖它不需要的接口</li><li>一个类对一个类的依赖应该建立在最小的接口上</li><li>建立单一接口，不要建立庞大臃肿的接口</li><li>尽量细化接口，接口中的方法尽量少</li></ul><p>也就是说，我们提供接口的时候，只暴露需要的方法，而将不需要的方法隐藏起来。</p><h2>例子</h2><p>定义一个接口叫做动物行为接口，但是呢，由于没有细化，比如狗子，一旦实现这个接口，那就要实现所有的方法，包括它不会的飞翔。</p><p><img src="http://bloghello.oursnail.cn/uml5-1.png" alt="image"></p><p>将接口进行细化（这里要注意是要适当）。哪个要实现什么，就去实现，不需要的方法就可以不用去实现。</p><p>注意，接口隔离原则好像与上一章的单一职责原则有点像，这里说明一下区别：单一职责原则强调职责，一个class或者接口只负责一个职责，可以有很多的方法。但是接口隔离原则强调的是适当地设计接口，尽量地给不同的调用者适当的接口，不要设计的太臃肿，注重的是接口依赖的隔离。</p><p>这里强调适当，接口也不能太多，效果反而会适得其反。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来了解一下什么是接口隔离原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>04-软件设计七大原则-单一职责原则</title>
    <link href="http://yoursite.com/2019/03/19/design-pattern/04-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/03/19/design-pattern/04-软件设计七大原则-单一职责原则/</id>
    <published>2019-03-19T04:09:02.740Z</published>
    <updated>2019-03-19T04:09:28.971Z</updated>
    
    <content type="html"><![CDATA[<p>本文来了解一下什么是单一职责原则。</p><a id="more"></a><h2>定义</h2><p>假设一个类(class)中有两个职责，一个是指责A，一个是指责B，当我们修改A时，可能会导致B出现问题。就是说，职责A和职责B发生改变时都会影响这个class，从而使这个class可能发生变更。</p><p>解决方案：对于这两个指责分别建立class1和class2，使他们互相不影响。这个原则就是单一职责原则。</p><p>即一个类/接口/方法只负责一项职责。</p><p>好处：降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。</p><h2>例子</h2><p>单一职责原则是很好理解的，下面配以代码举一个小例子。</p><p>比如有一个类，描述的是鸟移动的模式，正常情况下鸟是飞的，但是如果传进来一只不会飞的鸟咋办呢，比如鸵鸟，这就需要判断一下了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdMoveMode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(birdName.equals(<span class="string">"鸵鸟"</span>))&#123;</span><br><span class="line">            System.out.println(birdName+<span class="string">"是跑的..."</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(birdName+<span class="string">"是飞的..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，最好是将这个类分离成两类，一个是会飞的，一个是走的：</p><p><img src="http://bloghello.oursnail.cn/um4-1.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyBird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        System.out.println(birdName+<span class="string">"是飞的..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WalkBird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        System.out.println(birdName+<span class="string">"是跑的..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于接口和方法也一样，接口里面的方法声明分开；方法重载来分开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来了解一下什么是单一职责原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题66-机器人的运动范围】</title>
    <link href="http://yoursite.com/2019/03/19/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9866-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/19/剑指offer/【面试题66-机器人的运动范围】/</id>
    <published>2019-03-19T03:55:00.344Z</published>
    <updated>2019-03-19T03:59:09.212Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十六题。</p><a id="more"></a><h2>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2>解题思路</h2><p>基本的思路是同上一题的，就不再赘述思路了。至此，《剑指offer》66题全部刷完，这是我第三遍刷了，很多答案进行了优化，总体上是把比较好的方案总结在这上面，而不是只贪图简单而采取暴力解法，那样达不到真正的目的。下面的刷题主要是围绕牛客网的《leetcode在线编程训练》进行练习，后面的刷题进度可能总体较慢。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//根据m行n列的方格，构造一个数组来标识是否已经判断过，已经判断过的话置为true，否则置为false</span></span><br><span class="line">        <span class="comment">//这里初始化默认是false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="comment">//下面开始走，边走边判断周围是否符合</span></span><br><span class="line">        <span class="comment">//judge(初始横坐标i，初始横坐标j，行数，列数，k值，标识是否走过)</span></span><br><span class="line">        <span class="keyword">return</span> judge(<span class="number">0</span>,<span class="number">0</span>,rows,cols,threshold,flag);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> threshold,<span class="keyword">boolean</span>[][] flag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界、flsg=true说明已经走过，就不要再走了、行坐标和列坐标的数位之和大于k也跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || flag[i][j]==<span class="keyword">true</span> || getK(i)+getK(j)&gt;threshold)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//机器人从[0,0]出发，必定是满足的，先置为true,所以要先加个1</span></span><br><span class="line">        flag[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//基于回溯的思想，就是到达一个格子后，不断地判断他的周围四个格子是否满足要求，递归判断下去，必定走遍所有格子</span></span><br><span class="line">        <span class="keyword">return</span> judge(i-<span class="number">1</span>,j,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i,j-<span class="number">1</span>,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i+<span class="number">1</span>,j,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i,j+<span class="number">1</span>,rows,cols,threshold,flag)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//计算数字每一位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getK</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum += num%<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>((num=num/<span class="number">10</span>) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题65-矩阵中的路径】</title>
    <link href="http://yoursite.com/2019/03/19/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9865-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/19/剑指offer/【面试题65-矩阵中的路径】/</id>
    <published>2019-03-19T03:27:52.563Z</published>
    <updated>2019-03-19T03:28:15.510Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十五题。</p><a id="more"></a><h2>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2>解题思路</h2><p>回溯</p><p>基本思想：</p><p>0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次</p><p>1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge</p><p>2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组</p><p>3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通</p><p>4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的</p><p>5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。</p><p>6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//标志位，初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                 <span class="comment">//循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法</span></span><br><span class="line">                 <span class="keyword">if</span>(judge(matrix,i,j,rows,cols,flag,str,<span class="number">0</span>))&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">boolean</span>[] flag,<span class="keyword">char</span>[] str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先根据i和j计算匹配的第一个元素转为一维数组的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == str.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//要走的第一个位置置为true，表示已经走过了</span></span><br><span class="line">        flag[index] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回溯，递归寻找，每次找到了就给k加一，找不到，还原</span></span><br><span class="line">        <span class="keyword">if</span>(judge(matrix,i-<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i+<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j-<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j+<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>)  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，说明这一条路不通，还原，再试其他的路径</span></span><br><span class="line">        flag[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>02-分布式文件系统HDFS(一)</title>
    <link href="http://yoursite.com/2019/03/18/hadoop/02-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FHDFS(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/03/18/hadoop/02-分布式文件系统HDFS(一)/</id>
    <published>2019-03-18T09:40:05.844Z</published>
    <updated>2019-03-18T09:45:18.254Z</updated>
    
    <content type="html"><![CDATA[<p>从本文开始了解HDFS的基本原理，为后续的实际操作打下理论基础。</p><a id="more"></a><h2>HDFS概述及设计目标</h2><p>如果让我们自己设计一个分布式文件系统，如何来设计呢？可能会简单地这样想：为了保障数据稳定性，那么就可以多存几份，放在不同的节点上，这样，即使某个节点挂了，相应的数据还可以从其他地方读到，如下图所示：</p><p><img src="http://bloghello.oursnail.cn/hadoop2-1.png" alt="image"></p><p>我们看到，这样设计的好处是即使第一个存放数据的节点挂了，也不会有什么影响，后面其他的节点上还是有它的副本的。但是这样设计的缺点也很明显：</p><ul><li>不管文件多大，都存储在一个节点上，在进行数据处理的时候很难进行并行处理，节点可能就成为网络瓶颈，很难进行大数据的处理</li><li>存储负载很难均衡，每个节点的利用率很低</li></ul><p>HDFS是如何设计的呢？这里简单先说一下，它是先将每个文件进行拆分，默认是128兆，这些拆分出来的block也是多副本进行存储。这样，数据分布会比较均匀，并且可以并行处理，提高并行计算能力。</p><h2>HDFS设计目标</h2><ul><li>能构建非常巨大的分布式文件系统</li><li>运行在普通廉价的硬件上</li><li>易扩展、为用户提供性能不错的文件存储服务</li></ul><h2>HDFS架构</h2><p>我们来官网看看HDFS的架构以及说明，其中有一段描述是：</p><blockquote><p>HDFS has a master/slave architecture. An HDFS cluster consists of a single NameNode, a master server that manages the file system namespace and regulates access to files by clients. In addition, there are a number of DataNodes, usually one per node in the cluster, which manage storage attached to the nodes that they run on. HDFS exposes a file system namespace and allows user data to be stored in files. Internally, a file is split into one or more blocks and these blocks are stored in a set of DataNodes. The NameNode executes file system namespace operations like opening, closing, and renaming files and directories. It also determines the mapping of blocks to DataNodes. The DataNodes are responsible for serving read and write requests from the file system’s clients. The DataNodes also perform block creation, deletion, and replication upon instruction from the NameNode.</p></blockquote><p>首先，<font color="red">HDFS是一个主从的架构</font>，包含一个<code>NameNode</code>，它主要负责的是管理<code>namespace</code>以及用户访问的文件；此外，还包含一些<code>DataNodes</code>，主要是负责数据管理。</p><p><font color="red">命名空间的作用：</font>HDFS暴露一个文件系统命名空间允许用户数据保存在这里。<code>NameNode</code>执行系统命名空间操作比如打开、关闭、重命名文件以及目录。这个命名空间还确定了<code>block</code>到<code>DataNode</code>的映射。</p><p><font color="red"><code>DataNode</code>和<code>block</code>：</font>在内部，一个文件是被切割为多个<code>block</code>的，这些<code>block</code>是存储在一系列的<code>DataNode</code>上的。这些<code>DataNode</code>负责提供读写请求，还可以根据<code>NameNode</code>的指令进行<code>block</code>的创建、删除以及复制。</p><p>下面总结一下两者的功能：</p><ul><li><code>NameNode</code>（Master/NN）:<ul><li>负责客户端请求的响应</li><li>负责元数据（文件的名称、副本系数、block存放的DN）的管理</li></ul></li><li><code>DataNode</code>（Slaves/DN）:<ul><li>存储用户的文件对应的数据块（block）</li><li>要定期向NN发送心跳信息，汇报本身及其所有的block信息，健康状况</li></ul></li></ul><p>官网贴了一张架构图：</p><p><img src="http://bloghello.oursnail.cn/hadoop2-2.png" alt="image"></p><p>这里感觉有很多东西要额外注意，暂时先学习到这里。</p><h2>HDFS副本机制</h2><blockquote><p>HDFS supports a traditional hierarchical file organization. A user or an application can create directories and store files inside these directories. The file system namespace hierarchy is similar to most other existing file systems; one can create and remove files, move a file from one directory to another, or rename a file.</p></blockquote><p>HDFS支持传统的分层文件组织。 用户或应用程序可以在这些目录中创建目录并存储文件。 文件系统命名空间层次结构与大多数其他现有文件系统类似; 可以创建和删除文件，将文件从一个目录移动到另一个目录，或重命名文件。</p><blockquote><p>The NameNode maintains the file system namespace. Any change to the file system namespace or its properties is recorded by the NameNode. An application can specify the number of replicas of a file that should be maintained by HDFS. The number of copies of a file is called the replication factor of that file. This information is stored by the NameNode.</p></blockquote><p><code>NameNode</code>维护文件系统名称空间。 <code>NameNode</code>记录对文件系统命名空间或其属性的任何更改。 应用程序可以指定应由HDFS维护的文件的副本数。 文件的副本数称为该文件的复制因子。 该信息由<code>NameNode</code>存储。</p><blockquote><p>HDFS is designed to reliably store very large files across machines in a large cluster. It stores each file as a sequence of blocks. The blocks of a file are replicated for fault tolerance. The block size and replication factor are configurable per file.</p></blockquote><p>HDFS旨在可靠地在集群上存储非常大的文件。 它将每个文件切割为为一系列的块进行存储。这些块被复制成多个副本以达到一定的容错性。 块大小和复制因子可根据文件进行配置。</p><blockquote><p>An application can specify the number of replicas of a file. The replication factor can be specified at file creation time and can be changed later. Files in HDFS are write-once (except for appends and truncates) and have strictly one writer at any time.</p></blockquote><p>应用程序可以指定文件的副本数。 复制因子可以在文件创建时指定，并可以在以后更改。 HDFS中的文件是一次写入的（除了追加和删除），并且在任何时候都有一个在写入，也就是说不支持并发写。</p><blockquote><p>The NameNode makes all decisions regarding replication of blocks. It periodically receives a Heartbeat and a Blockreport from each of the DataNodes in the cluster. Receipt of a Heartbeat implies that the DataNode is functioning properly. A Blockreport contains a list of all blocks on a DataNode.</p></blockquote><p>它定期从群集中的每个<code>DataNode</code>接收<code>Heartbeat</code>和<code>Blockreport</code>。 收到心跳意味着<code>DataNode</code>正常运行。 <code>Blockreport</code>包含<code>DataNode</code>上所有块的列表。</p><p><img src="http://bloghello.oursnail.cn/hadoop2-3.png" alt="image"></p><h2>HDFS副本存放策略</h2><p>为了提高可用性，大型Hadoop集群以机架的形式来组织的，同一个机架上不同节点间的网络状况比不同机架之间更为理想。</p><p>那么副本是如何存储呢？</p><p><img src="http://bloghello.oursnail.cn/hadoop2-4.png" alt="image"></p><p>如图所示，这里以默认的三个副本为例子说明，一般策略是这样的：同一个机架的同一台机器上先放一个副本，然后不同机架随机选择两个机器放副本。这样，一旦其中一个机架挂了，另一个机架还可以继续工作。</p><p>至此，关于HDFS基础的理论都已经说明完毕了，下面就要来实际操作一把了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本文开始了解HDFS的基本原理，为后续的实际操作打下理论基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>【面试题64-滑动窗口的最大值】</title>
    <link href="http://yoursite.com/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9864-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/18/剑指offer/【面试题64-滑动窗口的最大值】/</id>
    <published>2019-03-18T04:19:13.557Z</published>
    <updated>2019-03-18T04:19:31.932Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十四题。</p><a id="more"></a><h2>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2>解题思路</h2><p>比较简单的思路是每次用一个<code>ArrayList</code>来存放窗口内的数，进行排序，然后得到最大的添加进外面的<code>ArrayList</code>中，最后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num.length == <span class="number">0</span> || size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (ArrayList)result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=num.length-size;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+size;j++)&#123;</span><br><span class="line">                list.add(num[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            result.add(list.get(size-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ArrayList)result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历再排序，时间复杂度还是挺高的，遍历一遍是不可避免的，优化点在于如何以O(1)的时间复杂度拿到当前窗口的最大值。下面介绍一下优化方法。</p><p>以输入数字{2,3,4,2,6,2,5,1}为例一步分析。</p><p>数组的第一个数字是 2，把它存入队列中。第二个数字是3.由于它比前一个数字 2 大，因此 2不可能成为滑动窗口中的最大值。2 先从队列里删除，再把3存入到队列中。此时队列中只有一个数字 3。针对第三个数字 4 的步骤类似，最终在队列中只剩下一个数字 4。此时滑动窗口中已经有 3 个数字，而它的最大值 4 位于队列的头部。</p><p>接下来处理第四个数字 2。2 比队列中的数字 4 小。当 4 滑出窗口之后 2 还是有可能成为滑动窗口的最大值，因此把 2 存入队列的尾部。现在队列中有两个数字 4 和 2，其中最大值 4 仍然位于队列的头部。</p><p>下一个数字是 6。由于它比队列中已有的数字 4 和 2 都大，因此这时 4 和 2 已经不可能成为滑动窗口中的最大值。先把 4 和 2 从队列中删除，再把数字 6 存入队列。这个时候最大值 6 仍然位于队列的头部。</p><p>第六个数字是 2。由于它比队列中已有的数字 6 小，所以 2 也存入队列的尾部。此时队列中有两个数字，其中最大值 6 位于队列的头部。</p><p>接下来的数字是 5。在队列中已有的两个数字 6 和 2 里，2 小于 5，因此 2 不可能是一个滑动窗口的最大值，可以把它从队列的尾部删除。删除数字 2 之后，再把数字 5 存入队列。此时队列里剩下两个数字 6 和 5，其中位于队列头部的是最大值 6。</p><p>数组最后一个数字是 1，把 1 存入队列的尾部。注意到位于队列头部的数字 6 是数组的第 5 个数字，此时的滑动窗口已经不包括这个数字了，因此应该把数字 6 从队列删除。那么怎么知道滑动窗口是否包括一个数字？<strong>应该在队列里存入数字在数组里的下标，而不是数值</strong>。当一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字已经从滑动窗口中滑出，可以从队列中删除了。</p><p><img src="http://bloghello.oursnail.cn/offer64.jpg" alt="image"></p><p>框框里的都是下标。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存放当前窗口中最大值</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//队列的头部存放的是当前窗口最大值</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length &lt;= <span class="number">0</span> || size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="comment">//比如当前数据比队尾的数字大，说明当前这个数字最起码在从现在起到后面的过程中可能是最大值</span></span><br><span class="line">            <span class="comment">//而之前队尾的数字不可能最大了，所以要删除队尾元素。</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt; num[i])&#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            <span class="comment">//队头的元素是否超过窗口的范围</span></span><br><span class="line">            <span class="keyword">if</span>(queue.peekFirst() == i-size)&#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在包含了三个元素之后才开始记录，其中最大值就在队列的头部</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= size - <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(num[queue.peekFirst()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题63-数据流中的中位数】</title>
    <link href="http://yoursite.com/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9863-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/18/剑指offer/【面试题63-数据流中的中位数】/</id>
    <published>2019-03-18T02:39:33.366Z</published>
    <updated>2019-03-18T02:39:57.320Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十三题。</p><a id="more"></a><h2>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h2>解题思路</h2><ul><li>先用java集合<code>PriorityQueue</code>来设置一个小顶堆和大顶堆</li><li>主要的思想是：因为要求的是中位数，那么这两个堆，<strong>大顶堆用来存较小的数，从大到小排列</strong>；<br><strong>小顶堆存较大的数，从小到大的顺序排序</strong>，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。</li><li>⭐保证：小顶堆中的元素都大于等于大顶堆中的元素，所以每次塞值，并不是直接塞进去，而是从另一个堆中poll出一个最大（最小）的塞值</li><li>⭐当数目为偶数的时候，将这个值插入大顶堆中，再将大顶堆中根节点（即最大值）插入到小顶堆中；</li><li>⭐当数目为奇数的时候，将这个值插入小顶堆中，再讲小顶堆中根节点（即最小值）插入到大顶堆中；</li><li>⭐取中位数的时候，如果当前个数为偶数，显然是取小顶堆和大顶堆根结点的平均值；如果当前个数为奇数，显然是取小顶堆的根节点</li></ul><p>理解了上面所述的主体思想，下面举个例子辅助验证一下。</p><p>例如，传入的数据为：[5,2,3,4,1,6,7,0,8],那么按照要求，输出是&quot;5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 &quot;</p><p>那么整个程序的执行流程应该是（用min表示小顶堆，max表示大顶堆）：</p><ul><li>5先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[<font color="red">5</font>],max=[无]，avg=[5.00]</li><li>2先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[<font color="red">5</font>],max=[<font color="red">2</font>],avg=[(5+2)/2]=[3.50]</li><li>3先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[<font color="red">3</font>,5],max=[2],avg=[3.00]</li><li>4先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[<font color="red">4</font>,5],max=[<font color="red">3</font>,2],avg=[(4+3)/2]=[3.50]</li><li>1先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[<font color="red">3</font>,4,5],max=[2,1]，avg=[3/00]</li><li>6先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[<font color="red">4</font>,5,6],max=[<font color="red">3</font>,2,1],avg=[(4+3)/2]=[3.50]</li><li>7先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[<font color="red">4</font>,5,6,7],max=[3,2,1],avg=[4]=[4.00]</li><li>0先进入小顶堆，然后将小顶堆中最大值放入小顶堆中，此时min=[<font color="red">4</font>,5,6,7],max=[<font color="red">3</font>,2,1,0],avg=[(4+3)/2]=[3.50]</li><li>8先进入大顶堆，然后将大顶堆中最小值放入大顶堆中，此时min=[<font color="red">4</font>,5,6,7,8],max=[3,2,1,0],avg=[4.00]</li></ul><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录偶数个还是奇数个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次插入小顶堆的是当前大顶堆中最大的数</span></span><br><span class="line">    <span class="comment">//每次插入大顶堆的是当前小顶堆中最小的数</span></span><br><span class="line">    <span class="comment">//这样保证小顶堆中的数永远大于等于大顶堆中的数</span></span><br><span class="line">    <span class="comment">//中位数就可以方便地从两者的根结点中获取了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> max = maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中</span></span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> min = minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek() + maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前为奇数个，则直接从小顶堆中取元素即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题62-二叉搜索树的第k个结点】</title>
    <link href="http://yoursite.com/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9862-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/18/剑指offer/【面试题62-二叉搜索树的第k个结点】/</id>
    <published>2019-03-18T01:22:44.681Z</published>
    <updated>2019-03-18T01:25:38.450Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十二题。</p><a id="more"></a><h2>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h2>解题思路</h2><p>二叉搜索树的中序遍历就是其排序好的序列，然后取第k个值即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list = fun(pRoot);</span><br><span class="line">        <span class="keyword">if</span>(k&gt;list.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LinkedList&lt;TreeNode&gt; <span class="title">fun</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fun(root.left);</span><br><span class="line">            list.add(root);</span><br><span class="line">            fun(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>01-初识Hadoop</title>
    <link href="http://yoursite.com/2019/03/15/hadoop/1.%E5%88%9D%E8%AF%86Hadoop/"/>
    <id>http://yoursite.com/2019/03/15/hadoop/1.初识Hadoop/</id>
    <published>2019-03-15T09:24:24.454Z</published>
    <updated>2019-03-15T09:31:23.220Z</updated>
    
    <content type="html"><![CDATA[<p>关于大数据的学习终于开始了，对java后台开发比较熟悉的同学会发现，部分的组件比如zookeeper就是从Hadoop生态圈中诞生的，但是纵观hadoop的生态圈，大多数还是比较陌生，本节来说一说比较核心的组件，找到学习的入口。</p><a id="more"></a><h2>一、概述</h2><p>我们来到它的官网来看看Hadoop到底是什么。</p><p><img src="http://bloghello.oursnail.cn/hadoop1-1.png" alt="image"></p><p>大概就是说：Haadoop项目旨在发展可靠的、可扩展的、分布式计算的开源软件。允许用简单的编程跨越集群来分布式处理大数据集。可以从单体服务扩展到上千台机器，每个机器都可以提供本地计算和存储。相比于依赖硬件来保证高可用，Hadoop是在应用层监测和处理错误从而保证可靠性，允许单个机器出现故障。</p><p>可以看到，Hadoop旨在提供高可用、可扩展、分布式计算一种能力，是应对海量数据的存储以及处理的一个方案。</p><p>这个<code>Hadoop project</code>包含了几个核心的子模块：</p><ul><li>Hadoop Common: 为其他的模块提供基础支持。</li><li>Hadoop Distributed File System (HDFS™): 一个高吞吐量的分布式文件系统</li><li>Hadoop YARN: 一个作业调度和集群资源管理的框架</li><li>Hadoop MapReduce: 基于YARN实线的用于并行处理大数据集的系统</li></ul><h2>二、核心组件之HDFS</h2><ul><li>源自于谷歌的GFS论文，论文发表于2003年10月</li><li>HDFS是GFS的克隆版</li><li>HDFS特点：扩展性&amp;容错性&amp;海量数据存储</li></ul><p>HDFS是一种分布式文件系统，文件系统是什么，我们需要知道他的基本功能是：管理和调度文件的存储空间，提供文件的逻辑结构、物理结构和存储方法;实现文件从标识到实际地址的映射。也就是对文件进行管理和调度的。</p><p>海量的数据，我们需要良好的扩展性来存放，也需要容错性来防止数据丢失，因此HDFS是在文件系统基本要求的基础上，实现更可靠的存储。</p><p>这里简单说一下的它的容错性是如何做到的：将文件切分为指定带线啊哦的数据块并以多副本的方式存储在多个机器上，而数据切分、多副本、容错等操作对用户是透明的。</p><h2>三、核心组件之资源调度系统YARN</h2><ul><li>负责整个集群资源的管理和调度：比如有一个作业要提交上来执行，需要占用多少CPU，多少内存都是YARN来计算完成的。</li><li>具有扩展性&amp;容错性&amp;多框架资源统一调度</li></ul><p>这里注意，YARN可以为上层应用提供统一的资源管理和调度，是什么意思呢？</p><p><img src="http://bloghello.oursnail.cn/hadoop1-2.png" alt="image"></p><p>这张图从下面开始，<code>HDFS2</code>其实就是表示<code>hadoop2.x</code>，他是做存储的，往上看有一个<code>YARN</code>，他就是做集群的资源管理的（<code>cluster resource management</code>），再往上看，对于批处理我们可以用<code>mapreduce</code>这种执行引擎，对于交互式的我们可以使用<code>tez</code>，在线的我们可以使用<code>hbase</code>，流处理可以采用<code>storm</code>，图计算用<code>giraph</code>，内存式的计算我们可以使用<code>spark</code>。。。。。</p><p>有了<code>YARN</code>之后就可以执行不同类型的计算框架，我们可以把<code>YARN</code>理解为操作系统级别的资源调度框架，可以让更多的计算框架<code>mapreduce</code>，<code>spark</code>，<code>storm</code>等等都运行在同一个集群里面，而且不同的计算框架可以共享同一个<code>hdfs</code>上的数据，享受整体的资源调度。</p><h2>四、核心组件之分布式计算框架MapReduce</h2><p>也是根据谷歌的论文实线的。不再赘述。下面我们来看看它是如何简单地统计单词出现频率的：</p><p><img src="http://bloghello.oursnail.cn/hadoop1-3.png" alt="image"></p><p>这是比较经典的一个案例。</p><p>大概是分成下面几个环节：</p><ul><li>Map阶段<ul><li>主要完成<code>key-value</code>对生成，这里是每看到一个单词，就输出(单词，1)的kv对</li></ul></li><li>排序阶段<ul><li>对刚才的kv对进行排序，这样相同单词就在一块儿了</li></ul></li><li>Reduce阶段<ul><li>对同一个单词的次数进行汇总，得到(词，频次)对</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/hadoop1-4.png" alt="image"></p><h2>五、Hadoop优势</h2><ul><li>高可用性：<ul><li>数据存储：数据块多副本</li><li>数据计算：发生异常的时候会重新调度作业计算</li></ul></li><li>高扩展性<ul><li>可以横向增加机器</li></ul></li><li>其他<ul><li>可以存储在廉价机器上，降低成本</li><li>成熟的生态圈</li></ul></li></ul><h2>六、狭义Hadoop和广义Hadoop</h2><p>狭义上的Hadoop：是一个适合大数据分布式存储(HDFS)、分布式计算(MapReduce)和资源调度(YARN)的平台。</p><p>广义上的Hadoop：指的是Hadoop生态系统。我们要知道，完成一些任务仅靠上面几个是不够的，比如<code>MapReduce</code>只能做离线批处理，要想做实时计算时无法完成的，所以需要其他的软件来完成。Hadoop生态系统是一个很庞大的概念，Hadoop是其中最重要最基础的一个部分；生态系统中的每一个子系统只解决某一个特定的问题域，不搞统一型的一个全能系统，而实小而精的多个小系统。</p><h2>七、Hadoop生态圈介绍</h2><p><img src="http://bloghello.oursnail.cn/hadoop1-5.png" alt="image"></p><p>我们从图中可以大概知道每个组件的用途。下面我们来简单说一说。</p><p><code>HDFS</code>是<code>GFS</code>的一种实现，他的完整名字是分布式文件系统，类似于<code>FAT32</code>，<code>NTFS</code>，是一种文件格式，是底层的。</p><p><code>Hive</code>与<code>Hbase</code>的数据一般都存储在<code>HDFS</code>上。<code>hadoop HDFS</code>为他们提供了高可靠性的底层存储支持。</p><p><code>hive</code>不支持更改数据的操作，<code>Hive</code>基于数据仓库，提供静态数据的动态查询。其使用类SQL语言，底层经过编译转为<code>MapReduce</code>程序，在<code>Hadoop</code>上运行，数据存储在<code>HDFS</code>上。</p><p><code>Hbase</code>是<code>Hadoop database</code>，即<code>Hadoop</code>数据库。它是一个适合于非结构化数据存储的数据库，<code>HBase</code>基于列的而不是基于行的模式。</p><p><code>HBase</code>是<code>Google Bigtable</code>的开源实现，类似<code>Google Bigtable</code>利用<code>GFS</code>作为其文件存储系统，<code>HBase</code>利用<code>Hadoop HDFS</code>作为其文件存储系统；<code>Google</code>运行<code>MapReduce</code>来处理<code>Bigtable</code>中的海量数据，<code>HBase</code>同样利用<code>Hadoop MapReduce</code>来处理<code>HBase</code>中的海量数据。</p><p><code>Pig</code>的语言层包括一个叫做<code>PigLatin</code>的文本语言,<code>Pig Latin</code>是面向数据流的编程方式。<code>Pig</code>和<code>Hive</code>类似更侧重于数据的查询和分析，底层都是转化成<code>MapReduce</code>程序运行。</p><p><code>Pig</code>和<code>Hive</code>的区别是<code>Hive</code>是类SQL的查询语言，要求数据存储于表中，而Pig是面向数据流的一个程序语言。</p><p>总结：</p><p><code>Hadoop HDFS</code>为<code>HBase</code>提供了高可靠性的底层存储支持，<code>Hadoop MapReduce</code>为<code>HBase</code>提供了高性能的计算能力，<code>Zookeeper</code>为<code>HBase</code>提供了稳定服务和<code>failover</code>机制(<code>zookeeper</code> = 通知机制 + 文件系统)。<code>Pig</code>和<code>Hive</code>还为<code>HBase</code>提供了高层语言支持，使得在<code>HBase</code>上进行数据统计处理变的非常简单。</p><h2>八、选型</h2><ul><li>Apache Hadoop</li><li>CDH:Cloudera Distributed Hadoop</li><li>HDP:Hortonworks Data Platform</li></ul><p>优先选择CDH，比较全，解决了版本冲突问题。</p><h2>九、总结</h2><p>我们可以看到，Hadoop的生态圈是极其庞大的，每个组件都是小而精，是为了解决特定问题而产生的，因此需要具体情况具体分析选用什么组件，也需要对核心的组件原理和使用了如指掌，下面我们先逐个来学习一下狭义Hadoop核心组件，从HDFS开始。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于大数据的学习终于开始了，对java后台开发比较熟悉的同学会发现，部分的组件比如zookeeper就是从Hadoop生态圈中诞生的，但是纵观hadoop的生态圈，大多数还是比较陌生，本节来说一说比较核心的组件，找到学习的入口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>【面试题61-序列化二叉树】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9861-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题61-序列化二叉树】/</id>
    <published>2019-03-15T07:26:00.625Z</published>
    <updated>2019-03-15T07:26:21.175Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十一题。</p><a id="more"></a><h2>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h2>解题思路</h2><p>比较简单的解题思路是：层序遍历二叉树，将这遍历结果组装成字符串，那么序列化就完成了。下面就是根据这个字符串想办法再还原为原来的二叉树。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//层序遍历放进StringBuilder中，空的则为#</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                sb.append(node.val+<span class="string">","</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="string">"#,"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() != <span class="number">0</span>)&#123;</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.trim().length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析StringBuilder，拆分为数组</span></span><br><span class="line">        String[] strChar = str.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//新建一个一样长度的TreeNode类型的数组</span></span><br><span class="line">        TreeNode[] nodeArr = <span class="keyword">new</span> TreeNode[strChar.length];</span><br><span class="line">        <span class="comment">//将不为#的字符都转为TreeNode类型，为#的则默认为Null</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strChar.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!strChar[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">                nodeArr[i] = <span class="keyword">new</span> TreeNode(Integer.valueOf(strChar[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次遍历，还原二叉树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;strChar.length&amp;&amp;j&lt;strChar.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodeArr[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nodeArr[i].left = nodeArr[j++];</span><br><span class="line">                nodeArr[i].right = nodeArr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题60-把二叉树打印成多行】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9860-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题60-把二叉树打印成多行】/</id>
    <published>2019-03-15T04:01:14.697Z</published>
    <updated>2019-03-15T04:01:38.691Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十题。</p><a id="more"></a><h2>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2>解题思路</h2><p>一开始我以为就是简单的层序遍历嘛：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.pop();</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用例:</span><br><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br><span class="line"></span><br><span class="line">对应输出应该为:</span><br><span class="line"></span><br><span class="line">[[8],[6,10],[5,7,9,11]]</span><br><span class="line"></span><br><span class="line">你的输出为:</span><br><span class="line"></span><br><span class="line">[[8],[6],[10],[5],[7],[9],[11]]</span><br></pre></td></tr></table></figure><p>事实上，这里需要将在同一层的数放到一个集合之中，所以还需要加工一下才行。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先把root放进结果集</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(pRoot.val);</span><br><span class="line">        res.add(list);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//统计一下当前队列中的个数，因为当前队列中存放的都是同一层的数据</span></span><br><span class="line">            <span class="comment">//所以需要对这一层进行处理</span></span><br><span class="line">            <span class="keyword">int</span> num = queue.size();</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node = queue.pop();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(node.left.val);</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                    list.add(node.right.val);</span><br><span class="line">                &#125;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题59-按之字形顺序打印二叉树】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9859-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题59-按之字形顺序打印二叉树】/</id>
    <published>2019-03-15T03:35:42.514Z</published>
    <updated>2019-03-15T03:36:02.923Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十九题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2>解题思路</h2><p>思路是搞两个栈，一个栈专门保存奇数层数据，一个栈专门保存偶数层数据。注意保存的顺序，保存偶数层的时候是从左到右，保存奇数层的时候从右到左。这样依次出栈的时候顺序是第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，依次类推。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//存放奇数层</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack1.push(pRoot);</span><br><span class="line">        <span class="comment">//存放偶数层</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(layer%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//说明是奇数层</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                    TreeNode tmp = stack1.pop();</span><br><span class="line">                    <span class="keyword">if</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(tmp.val);</span><br><span class="line">                        stack2.push(tmp.left);</span><br><span class="line">                        stack2.push(tmp.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    layer++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明是偶数层</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                    TreeNode tmp = stack2.pop();</span><br><span class="line">                    <span class="keyword">if</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(tmp.val);</span><br><span class="line">                        stack1.push(tmp.right);</span><br><span class="line">                        stack1.push(tmp.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    layer++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题58-对称的二叉树】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9858-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题58-对称的二叉树】/</id>
    <published>2019-03-15T03:02:08.386Z</published>
    <updated>2019-03-15T03:14:05.098Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十八题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2>解题思路</h2><p>递归下去，不赘述了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> judge(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左子树为空的话，右子树必须为空才符合条件</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (right == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树不为空，右子树为空了，false</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右结点的值不相等则false</span></span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归下去</span></span><br><span class="line">        <span class="keyword">return</span> judge(left.right,right.left) &amp;&amp; judge(left.left,right.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题57-二叉树的下一个结点】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9857-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题57-二叉树的下一个结点】/</id>
    <published>2019-03-15T02:31:46.627Z</published>
    <updated>2019-03-15T02:33:03.847Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十七题。</p><a id="more"></a><h2>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2>解题思路</h2><p>我们对于中序排序的规则已经很熟悉，下面图示:</p><p><img src="http://bloghello.oursnail.cn/suanfa6-8.png" alt="image"></p><p>我们从这个图上可以看到，找下一个节点是可以分为几种情况的。</p><p>第一种情况，就是一个节点有右子树。比如要求节点B的下一个节点，其实是找到它的右子树的最左孩子，就是G节点。</p><p>第二种情况，就是一个节点没有右子树，此时又可以分为两种情况。</p><p>对于G这个节点来说，没有右子节点了，它的父亲节点是E，G是E的左子节点，即E的左子节点是G，那么G的下一个节点就是E。</p><p>对于E这个节点来说，也没有右子节点，它的父亲节点是B，此时E是B的右子节点，根据实际情况来说，E的下一个节点绝对不是B，因为E是B的右子节点，根据中序遍历的规则，此时肯定是先遍历B再遍历E，所以B肯定在E的前面，而不是后面，所以我们还需要再往上找父亲节点，此时B的父亲节点为A，B为A的左子节点，此时根据实际情况，A就是我们要找的E的下一个节点。</p><p>所以，对于一个没有右子节点的节点来说，只需要判断它有没有父节点并且是不是父节点的左子节点，是的话，就找到了，不是则要不断地向上找。</p><p>如果一直找到根还是找不到，像节点F，那就返回null，因为实际上F节点就是中序遍历的最后一个节点，没有所谓的下一个节点了。</p><p>将上面所述转换为图示为：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-9.png" alt="image"></p><p>总之，我们不关心当前节点的左子节点，因为它不在我们的考虑范围内，它必定出现在当前节点的前面。</p><p>我们主要就是考虑有没有右子节点，或者没有右子节点的话就考虑父亲节点。有右子节点比较简单，一直找最左边的子节点即可。但是没有右子节点的时候，就需要去查询父亲节点了。理解了这些，程序也就呼之欲出了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.判断当前节点是否有右子节点，有则去里面找</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> firstInRightTree(pNode);</span><br><span class="line">        <span class="comment">//2.没有右子节点，就需要去父节点找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3.直到找到符合条件的父节点为止，跳出循环时pNode的父节点符合条件，这个父节点就是我们要的东西</span></span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span> &amp;&amp; pNode.next.left != pNode)&#123;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到右子树中找符合条件的，显然就是找最最最左边的子节点即可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeLinkNode <span class="title">firstInRightTree</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        TreeLinkNode curr = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
