<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-07T09:44:38.530Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【面试题18-二叉树的镜像】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9818-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题18-二叉树的镜像】/</id>
    <published>2019-03-07T09:44:15.108Z</published>
    <updated>2019-03-07T09:44:38.530Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十八题。</p><a id="more"></a><h2>题目描述</h2><p><img src="http://bloghello.oursnail.cn/offer18-1.png" alt="image"></p><h2>解题思路</h2><p>我们或许还记得递归的终极思想是数学归纳法，我们思考递归的时候一定不要去一步一步看它执行了啥，只会更绕。我们牢牢记住，思考的方式是我们首先假设子问题都已经完美处理，我只需要处理一下最终的问题即可，子问题的处理方式与最终那个处理方式一样，但是问题规模一定要以1的进制缩小。最后给一个递归出口条件即可。</p><p>对于本题，首先假设<code>root</code>的左右子树已经都处理好了，即左子树自身已经镜像了，右子树自身也镜像了，那么最后一步就是交换左右子树，问题解决。所以我只需要将<code>root.left</code>和<code>root.right</code>交换即可。下面进入递归，就是处理子问题。子问题的处理方式与<code>root</code>一样，只是要缩小问题规模，所以只需要考虑<code>root.left</code>是什么情况，<code>root.right</code>是什么情况即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        reverseTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//为空则结束</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假设root两边的子树自己都已经翻转成功了，那么只需要再将左右子树互换一下就成功了</span></span><br><span class="line">        <span class="comment">//交换root的左右子树</span></span><br><span class="line">        swap(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树翻转自己去处理就行了，我们规定每个子树的root都跟最终的root处理方式一样即可</span></span><br><span class="line">        reverseTree(root.left);</span><br><span class="line">        reverseTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        node = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题17-树的子结构】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9817-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题17-树的子结构】/</id>
    <published>2019-03-07T09:08:53.574Z</published>
    <updated>2019-03-07T09:09:17.170Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十七题。</p><a id="more"></a><h2>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2>解题思路</h2><p>针对树的结构，肯定是要用递归了，本题我觉得还是比较难的，需要注意很多东西，但是理解上比较轻松，直接看代码，理解了就好了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//都不为空的话再去判断，因为空树不是任意一个树的子树</span></span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//相等，则进入另外一个函数递归判断</span></span><br><span class="line">            <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                res = doTree1ContainsTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面个不符合条件的话，则继续找下一个相等的结点，再去遍历</span></span><br><span class="line">            <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                res = HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                res = HasSubtree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doTree1ContainsTree2</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口1：子树已经判断完毕了则结束，表明整个过程都为true，最终返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归出口2：子树还没空，父树先走到空了，那么肯定是不是子树结构的</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归出口3：两个数的结点值不相等的话停止</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> doTree1ContainsTree2(root1.left,root2.left) &amp;&amp; doTree1ContainsTree2(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题16-合并两个排序的链表】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9816-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题16-合并两个排序的链表】/</id>
    <published>2019-03-07T08:27:25.043Z</published>
    <updated>2019-03-07T08:36:46.535Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十六题。</p><a id="more"></a><h2>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2>解题思路</h2><p>跟归并排序的并过程很类似。理解了归并排序，这个就很简单了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//newHead是为了表示头节点用的</span></span><br><span class="line">        <span class="comment">//node是为了穿针引线，将两个链表连起来</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//两个指针不停比较，把较小的用node串起来，并且焦较小的指针往后移动即可</span></span><br><span class="line">            <span class="keyword">if</span>(list1.val &gt; list2.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    newHead = list2;</span><br><span class="line">                    node = list2;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = list2;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    newHead = list1;</span><br><span class="line">                    node = list1;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = list1;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//走到这里，最多只有一个链表还没遍历完，下面补全就可以了</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题15-反转链表】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9815-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题15-反转链表】/</id>
    <published>2019-03-07T03:44:50.327Z</published>
    <updated>2019-03-07T03:45:20.193Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十五题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2>解题思路</h2><p>一开始学的时候看的答案就是这个方法，显然是要比递归好的，但是如果不理解的话，光靠背很容易出错，并且也不大背的上，如今重温这道题，其实是很简单的，我们下面用图示来阐述。</p><p>主要的思想是用两个指针，其中<code>newHead</code>指向的是反转成功的链表的头部，<code>currentHead</code>指向的是还没有反转的链表的头部：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-1.png" alt="image"></p><p>初始状态是<code>newHead</code>指向<code>null</code>，<code>currentHead</code>指向的是第一个元素，一直往后遍历直到<code>newHead</code>指向最后一个元素为止：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-3.png" alt="image"></p><p>下面展示的是其中某个时间点的指向细节：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-2.png" alt="image"></p><p>理解了上面的图示，程序就呼之欲出了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode currentHead = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(currentHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = currentHead.next;</span><br><span class="line">            currentHead.next = newHead;</span><br><span class="line">            newHead = currentHead;</span><br><span class="line">            currentHead = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题14-链表中倒数第k个结点】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9814-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题14-链表中倒数第k个结点】/</id>
    <published>2019-03-07T03:43:20.812Z</published>
    <updated>2019-03-07T03:44:40.517Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十四题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2>解题思路</h2><p>做过这个题目或者了解过，思路一下就有了。要求倒数第k个结点，而这个单向链表只能next，所以往前找是不行的。怎么办呢？我们可以先派一个指针走k个结点，然后另一个指针从头开始，两个指针同时后移，当前面个指针到最后一个结点的下一个结点即null的时候，后面个指针恰好指向的就是倒数第k个结点。</p><h2>我的答案</h2><p>答案稍微有点繁琐了，但是我觉得思路清晰是最重要的，代码再精简是需要在思路清晰的基础上再加以磨练才行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算出链表的长度，判断k是否超出</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k &gt; count)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到第k个结点</span></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一个结点指向head，一个结点指向第k个，两者同时后移</span></span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此时ehad就是倒数第k个结点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题13-调整数组顺序使奇数位于偶数前面】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9813-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题13-调整数组顺序使奇数位于偶数前面】/</id>
    <published>2019-03-07T02:41:50.142Z</published>
    <updated>2019-03-07T02:42:15.123Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十三题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2>解题思路</h2><p>这个题目最简单的思路自然是新开一个数组来存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                temp[e++] = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[count++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">            array[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过确实有点low，应该不是出题者本意。我们可以在原地进行处理，基本思想同插入排序。</p><p>首先说明一下，本题用快排的话会非常复杂，几乎是做不出来。因为他要保证偶数与偶数，奇数与奇数相对的顺序不变。</p><p>要想保证偶数与偶数，奇数与奇数相对顺序不变，那么就不能简单地交换，办法是整体移动。我首先找到第一个偶数，然后从这个偶数开始找第一个奇数。两者不能直接交换，因为交换的话，在前面的偶数被调到了后面，不符合题意。</p><p>从偶数位置开始，依次往后挪一格，然后将第一个奇数放到当前偶数的位置。依次循环，到最后i或者j越界了说明已经全部调整好了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非法判断</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> , j;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; array.length)&#123;</span><br><span class="line">            <span class="comment">//找到第一个偶数停止</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; array.length &amp;&amp; !isEven(array[i]))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从偶数位置开始，找第一个奇数</span></span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; array.length &amp;&amp; isEven(array[j]))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个j越界说明找不到奇数了，则后面没有奇数就结束了</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; array.length)&#123;</span><br><span class="line">                <span class="comment">//从偶数位置开始到奇数位置整体向后移动一格，然后把这个奇数放到偶数位置即可</span></span><br><span class="line">                <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j2 = j-<span class="number">1</span>;j2 &gt;= i;j2--)&#123;</span><br><span class="line">                    array[j2+<span class="number">1</span>] = array[j2];</span><br><span class="line">                &#125;</span><br><span class="line">                array[i++] = tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">break</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否为偶数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题12-数值的整数次方】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9812-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题12-数值的整数次方】/</id>
    <published>2019-03-06T09:55:01.132Z</published>
    <updated>2019-03-06T09:56:03.483Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十二题。</p><a id="more"></a><h2>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2>解题思路</h2><p>把两个问题考虑清楚就可以了。第一个问题是判断指数是不是小于0，这关系到要不要取倒数；第二个问题是判断底数是不是负数，这个时候，如果指数是偶数，则为正数，如果指数为奇数则为负数。</p><p>我们将问题简化，将底数设置为正数，设好标识符最后统一处理，我们的首要目标是计算出次方数，最后再判断上面的两种情况，对结果进行调整。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先把指数全部搞成正数，后面再处理</span></span><br><span class="line">        <span class="keyword">int</span> e = exponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            e = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//看看是不是奇数,如果是奇数并且base为负数，那么最终还是负数，其余情况都是正数</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(base % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算次方的结果</span></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(e &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res *= base;</span><br><span class="line">            e--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果指数小于0，则要取倒数</span></span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            res = <span class="number">1</span>/res;</span><br><span class="line">            <span class="comment">//base为负数并且指数为基数的时候，要取反</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                res = <span class="number">0</span>-res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：貌似有更快的方法，暂时先不考虑了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题11-二进制中1的个数】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9811-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题11-二进制中1的个数】/</id>
    <published>2019-03-06T09:27:02.941Z</published>
    <updated>2019-03-06T09:33:22.829Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十一题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2>解题思路</h2><p>这个题目求一个数的二进制形式的1的个数，比较简单的思路是：每次与1进行&amp;操作，看是不是1，是则奇数，无论如何都后移一位再判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果输入时负数会陷入死循环，因为负数右移时，在最高位补得是1。那么就死循环了。</p><p>比较好的解法是：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。</p><p>循环是判断n是不是为0了，只要不为0，就循环。一进循环说明n是有至少一个1的，二话不说，先count++;</p><p>比如：一个二进制数1100，减去1之后是1011。</p><p>两者一&amp;则变为1000，原来最右边的1就变成了0.</p><p>由于n不为0，则再次进入循环：</p><p>1000减去1是0111，两者一&amp;就是0000.退出循环。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题10-矩形覆盖】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9810-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题10-矩形覆盖】/</id>
    <published>2019-03-06T08:15:38.532Z</published>
    <updated>2019-03-06T08:16:13.778Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十题。</p><a id="more"></a><h2>题目描述</h2><p>我们可以用 <code>2*1</code> 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个 <code>2*1</code> 的小矩形无重叠地覆盖一个 <code>2*n</code> 的大矩形，总共有多少种方法？</p><h2>解题思路</h2><p><img src="http://bloghello.oursnail.cn/offer10-1.png" alt="image"></p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题9-变态跳台阶】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%989-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题9-变态跳台阶】/</id>
    <published>2019-03-06T08:05:21.845Z</published>
    <updated>2019-03-06T08:12:08.793Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第九题。</p><a id="more"></a><h2>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2>解题思路</h2><p>这就是上一题的延申，上一题要么跳一个要么跳两个，这一题是从1个到n个，那么同样地，找出f(n)与f(n-1)的关系就好了。</p><ul><li>f(1) = 1：一个台阶只有一种跳法，就是跳一个</li><li>f(2) = f(2-1) + f(2-2)：两个台阶有两种跳法，跳一个或者跳两个</li><li>①f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) = f(0) + f(1) + f(2) + … + f(n-2) + f(n-1)：n个台阶就有n个跳法</li></ul><p>根据上一个式子，我们可以得出：</p><p>②f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + … + f(n-2)：n-1个台阶有n-1个跳法</p><p>根据①②可以得出：</p><p>f(n) = f(n-1) + f(n-1) =2*f(n-1)</p><p>这个问题就解决了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题8-跳台阶】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%988-%E8%B7%B3%E5%8F%B0%E9%98%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题8-跳台阶】/</id>
    <published>2019-03-06T08:03:07.323Z</published>
    <updated>2019-03-06T08:03:56.808Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第八题。</p><a id="more"></a><h2>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2>解题思路</h2><p>对于本题,前提只有 一次 1阶或者2阶的跳法。</p><ul><li>如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);</li><li>假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)</li><li>可以得出总跳法为: f(n) = f(n-1) + f(n-2)</li><li>然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</li></ul><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题7-斐波那契数列】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%987-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题7-斐波那契数列】/</id>
    <published>2019-03-06T08:01:44.875Z</published>
    <updated>2019-03-06T08:02:57.584Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第七题。</p><a id="more"></a><h2>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><h2>解题思路</h2><p>最简单的解法就是递归了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是递归存在重复子问题，所以时间复杂度较高，但是这里竟然通过了？斐波那契数列我认为最优的一个解法是用两个变量存储。</p><p>这题目用动态规划来解其实是不好的，至少逆向思考问题本身就是比较问难的，我觉得这种记忆化搜索对于这种问题是最好理解并且解是比较优的解。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题6-旋转数组的最小数字】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%986-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题6-旋转数组的最小数字】/</id>
    <published>2019-03-06T07:58:30.451Z</published>
    <updated>2019-03-06T07:58:55.710Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六题。</p><a id="more"></a><h2>题目描述</h2><p>一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2>解题思路</h2><p>当我们看到关键字“非减排序的数组&quot;的时候，我们要想到这题目的最优解可能是用二分查找法。</p><p>我们知道，二分查找法适用于有序数组的查找，这里对这个非减排序的数组进行了旋转，那么旋转之后这个数组的一个明显特征是：前面的一段序列必然大于等于后面的一段序列。</p><p>这题目可以认为是二分查找法的变种题目，下面我们来具体分析一下编程思路。</p><p>我们可以找一个基准数，比如数组的最优一个元素<code>target</code>，我们比较中间元素比如叫做<code>arr[mid]</code>和这个<code>target</code>的大小：</p><ul><li>如果<code>arr[mid]</code>&gt;<code>target</code>:那么表明截取的时候，后面比前面长，那么最小值必然存在于索引mid的后面</li><li>如果<code>arr[mid]</code>&lt;<code>target</code>:那么表明截取的时候，前面比后面长，那么最小值必然存在于索引mid的前面(此时应该包含mid对应的元素，因为极限情况比如只有两个元素，那么反转之后前面可能比后面大，如果不包含这个mid就错了)</li><li>如果<code>arr[mid]</code>=<code>target</code>:这个时候元素组比如为[0,1,1,1,1]，那么旋转之后可能为 [1,0,1,1,1] 或者[1,1,1,0,1]，不好判断，一个一个试。</li></ul><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[end])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[end])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题5-用两个栈实现队列】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%985-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题5-用两个栈实现队列】/</id>
    <published>2019-03-06T07:52:05.206Z</published>
    <updated>2019-03-06T07:57:49.667Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五题。</p><a id="more"></a><h2>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为int类型。</p><h2>解题思路</h2><p>队列是先进先出，栈是先进后出，如何用两个栈来实现这种先进先出呢？</p><p>其实很简单，我们假设用<code>stack1</code>专门来装元素，那么直接<code>stack1.pop</code>肯定是不行的，这个时候<code>stack2</code>就要发挥作用了。</p><p>我们的规则是：只要<code>stack2</code>中有元素就<code>pop</code>，如果<code>stack2</code>为空，则将<code>stack1</code>中所有元素倒进<code>satck2</code>中，就是说，新元素只进<code>stack1</code>，元素出来只从<code>stack2</code>出来。</p><p>这样子，就能保证每次从<code>stack2</code>中<code>pop</code>出来的元素就是最老的元素了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//负责装元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//负责出元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主要思想是：stack2有元素就pop，没有元素就将stack1中所有元素倒进来再pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> node = stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"no valid element"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题4-重建二叉树】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%984-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题4-重建二叉树】/</id>
    <published>2019-03-06T06:35:16.987Z</published>
    <updated>2019-03-06T07:48:48.341Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四题。</p><a id="more"></a><h2>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2>解题思路</h2><p>因为是树的结构，一般都是用递归来实现。</p><p>用数学归纳法的思想就是，假设最后一步，就是root的左右子树都已经重建好了，那么我只要考虑将root的左右子树安上去即可。</p><p>根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。</p><p>根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。</p><p>正如上面所说，只需要将确定的左右子树安到root上即可。递归要注意出口，假设最后只有一个元素了，那么就要返回。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组长度为0的时候要处理</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组长度仅为1的时候就要处理</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//我们先找到root所在的位置，确定好前序和中序中左子树和右子树序列的范围</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rootVal == in[i])&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归，假设root的左右子树都已经构建完毕，那么只要将左右子树安到root左右即可</span></span><br><span class="line">        <span class="comment">//这里注意Arrays.copyOfRange(int[],start,end)是[)的区间</span></span><br><span class="line">        root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,rootIndex+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,rootIndex));</span><br><span class="line">        root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,rootIndex+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,rootIndex+<span class="number">1</span>,in.length));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题3-从尾到头打印链表】</title>
    <link href="http://yoursite.com/2019/03/05/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%983-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/05/剑指offer/【面试题3-从尾到头打印链表】/</id>
    <published>2019-03-05T13:57:55.460Z</published>
    <updated>2019-03-05T13:58:12.374Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第三题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><h2>解题思路</h2><p>这一题给一个单向链表，然后你反向打印出来。其实最容易想到的就是两个方案，一个是将这个链表进行反置，然后依次打印即可。一个就是通过栈这个数据结构，先进后出，那么也可以反向打印出来。由于用栈比较简单，但是链表的反置稍微难一点并且重要，所以本文用反置链表的方式解决。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = listNode;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pre就是反向链表的头结点</span></span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(pre.val);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题2-替换空格】</title>
    <link href="http://yoursite.com/2019/03/05/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%982-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/05/剑指offer/【面试题2-替换空格】/</id>
    <published>2019-03-05T13:49:24.362Z</published>
    <updated>2019-03-05T14:04:17.044Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第二题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2>解题思路</h2><p>由于<code>java</code>给的参数是<code>StringBuilder</code>，这在一定程度上给我们一定的提示，我们利用<code>StringBuilder</code>的<code>charAt(i)</code>和<code>setCharAt(i,xxx)</code>这两个函数可以轻易实现获取索引处元素以及对这个索引处元素进行赋值。</p><p>由于是将空格替换成<code>%20</code>，空格本身就算一个地方，所以我需要将原来的字符串进行扩充。扩充的长度也非常好算，就是原来的长度+空格个数*2即可。然后遍历原字符串，不是空格的就一个个搬到新长度对应的位置上，否则就塞入<code>%20</code>三个字符。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取空格数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.拿到原来字符串的长度，计算新的字符串长度</span></span><br><span class="line">        <span class="comment">//并且我是从尾巴开始往前遍历，所以我需要获取起始的两个索引值</span></span><br><span class="line">        <span class="keyword">int</span> oldLength = str.length();</span><br><span class="line">        <span class="keyword">int</span> oldIndex = oldLength - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> newLength = oldLength + <span class="number">2</span>*count;</span><br><span class="line">        <span class="keyword">int</span> newIndex = newLength - <span class="number">1</span>;</span><br><span class="line">        str.setLength(newLength);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.从后往前遍历原字符串，赋值给“新”的字符串，不过是原地进行的，没有开辟新的空间</span></span><br><span class="line">        <span class="keyword">for</span>(;oldIndex &gt;= <span class="number">0</span> &amp;&amp; oldIndex &lt; newIndex;oldIndex--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(oldIndex) == <span class="string">' '</span>)&#123;</span><br><span class="line">                str.setCharAt(newIndex--,<span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(newIndex--,<span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(newIndex--,<span class="string">'%'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str.setCharAt(newIndex--,str.charAt(oldIndex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题1-二维数组中的查找】</title>
    <link href="http://yoursite.com/2019/03/05/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%981-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/05/剑指offer/【面试题1-二维数组中的查找】/</id>
    <published>2019-03-05T12:58:02.150Z</published>
    <updated>2019-03-05T14:04:26.172Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第一题。</p><a id="more"></a><h2>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2>解题思路</h2><p>考察数组的特性，我们如果从右上角的元素开始找，比如我们要找4，比9小，那么直接删除列即可，因为这个列上的元素看到都大于9；那么我们这时锁定8，发现还是比他小，再删除一列；这时变成了2，发现4比他大，则删除行；这个是后就锁定了4，就是我们想要的答案。</p><p>规律：首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；</p><p>如果该数字大于要查找的数字，剔除这个数字所在的列：如果该数字小于要查找的数字，剔除这个数字所在的行。</p><p>也就是说如果要查找的数字不在数组的右上角，则每－次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;=array.length-<span class="number">1</span> &amp;&amp; j&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>基础算法14-二叉搜索树</title>
    <link href="http://yoursite.com/2019/03/04/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9514-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/04/algorithms-basic/基础算法14-二叉搜索树/</id>
    <published>2019-03-04T13:55:21.777Z</published>
    <updated>2019-03-04T13:58:22.719Z</updated>
    
    <content type="html"><![CDATA[<p>本文比较轻松简单，就是动态生成一个二叉搜索而已。</p><a id="more"></a><h2>动态构建二叉搜索树</h2><p>首先明确二叉搜索树基本性质，就是根节点的值一定比左孩子的值要大，一定比右孩子的值要小。(为了简单起见，假定元素都是不重复的)</p><p>如何动态生成一颗二叉搜索树呢？思路其实是很简单的，就是判断与根节点的左孩子和右孩子分别比较大小，一直到末梢就可以插入元素了。</p><p>先准备一个<code>TreeNode</code>：</p><p><img src="http://bloghello.oursnail.cn/suanfa14-1.png" alt="image"></p><p>下面就是对节点进行操作了：</p><p><img src="http://bloghello.oursnail.cn/suanfa14-2.png" alt="image"></p><p>我们来进行前序遍历和中序遍历以及后序遍历看看生成的二叉搜索树是否正确：</p><p><img src="http://bloghello.oursnail.cn/suanfa14-3.png" alt="image"></p><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前序遍历为：  6 3 2 1 5 8 7 </span><br><span class="line">中序遍历为：  1 2 3 5 6 7 8 </span><br><span class="line">后序遍历为：  1 2 5 3 7 8 6</span><br></pre></td></tr></table></figure><p>经过验证发现完全是正确的。并且我们发现，中序遍历后是一个有序的序列，说明二叉搜索树中序遍历之后有序。</p><p>二叉树天生递归，关于它的很多题目用递归就可以解决，后序会有一个单独的文章专门来刷关于二叉树的题目。这里先不赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文比较轻松简单，就是动态生成一个二叉搜索而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法13-动态规划入门</title>
    <link href="http://yoursite.com/2019/03/04/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9513-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/03/04/algorithms-basic/基础算法13-动态规划入门/</id>
    <published>2019-03-04T13:54:58.069Z</published>
    <updated>2019-03-04T13:55:10.377Z</updated>
    
    <content type="html"><![CDATA[<p>在求解某个序列的最优解的时候，经常会用到动态规划来解决。动态规划的核心是找出一个关系式，并且借助于选或者不选找出两个迭代的路径进行比较，最终遍历整个序列之后也就得到了选或者不选中的最优解，也就是整个序列的最优解。由于还是比较复杂的，所以是对动态规划学习的一个入门之作。</p><a id="more"></a><h2>什么是动态规划</h2><blockquote><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。引自百度百科</p></blockquote><p>我们以解决一个小例子入手。</p><h2>例子</h2><p><img src="http://bloghello.oursnail.cn/suanfa13-1.png" alt="image"></p><p>如图所示，横轴是时间，上面是一段一段的长方形，将其想象为工作时间，比如第一块，是1点到4点的工作，收益为5，第二块是3点到5点的工作，收益是1.一个人不可能同时做两份工作，即时间不能重叠，请问这个人如何安排做哪几个工作最终收益是最大的？</p><p>这道题目如何思考呢？正常的思维可能是：假设我做第一个工作，那么我做完之后只能做第四个工作才不冲突，做完第四个再做第8个工作，但是这个不一定是最优解，那么我还需要判断各种情况，比如我第一个工作做完了可能会去做第6个工作，好像很混乱，无从下手了。</p><p>各位，现在转换一下思维，我们不从第一个开始考虑，我们从最后一个开始考虑。怎么考虑呢？</p><p>对于第八份工作而言，我有两个选择，一个是做，一个是不做。不做就很简单，我再从第七份工作开始考虑。做的话，那么我下面就要考虑前面可以做的最好的工作了，我们发现第五份工作以及之前的工作都可以做做，那么就是说对前五个工作找到一个收益最大的方案就即刻。我们用OPT(i)函数表示第i个参数之前最优解的话，那么对于上述可以表示为：</p><p><img src="http://bloghello.oursnail.cn/suanfa13-2.png" alt="image"></p><p>其实根据这个情况，我们递推出一个通用一点的关系式：</p><p><img src="http://bloghello.oursnail.cn/suanfa13-3.png" alt="image"></p><p>对于这个<code>prev(i)</code>表示在选择当前i元素之后，可以考虑的最优的子集的第一个元素（这个元素是反着找的）。比如选了8，那么我前面能考虑的只能是1，2，3，4，5这几块，因为6和7都不能选的。即使3或者4可能不满足条件，但是我们只要找到最接近的5即可。</p><p><img src="http://bloghello.oursnail.cn/suanfa13-4.png" alt="image"></p><p>我们会发现这种问题是存在重叠子问题的，这个就是问题的关键，一个问题分解为若干子问题，为了避免重复的计算，是需要将这些子问题存储起来的，下次用到的时候直接去内存中查出来即可。</p><p>这个问题根据上面的表达式就可以求出最优的一个情况。对于这个例子我们只需要理解它的解体思想即可，下面我们真正实践一个题目。</p><h2>小偷偷东西</h2><p><img src="http://bloghello.oursnail.cn/suanfa13-5.png" alt="image"></p><p>这个问题大概就是说，一个小偷偷东西，但是它不能偷相邻的两家人的东西，这样会被抓住，只能隔着偷，请问，怎么偷才能利益最大化，因为每个房子的价值不一样，假如有两家，一家有100块，一家有一个亿，你选择不好，选了100的那家，那就亏大发了，一个亿的下次再来偷吧。</p><p>按照上面的思路，我们来思考这个问题，我们从最后一家开始考虑，选择就两个，偷或者不偷，偷了会怎么样，不偷会怎么样，其实关系式跟上面是差不多的，我偷了的话，比如偷的是n，那么下次只能从n-2开始考虑它的最大价值方案。不偷的话，就是考虑n-1的最大价值方案。</p><p>最简单的实现就是递归来实现，主要是要考虑一下函数的出口条件，即偷到第一家了是什么样，以及第一家之前没有人家了怎么办。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rob(nums,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> A = rob(nums,n-<span class="number">2</span>) + nums[n];</span><br><span class="line">            <span class="keyword">int</span> B = rob(nums,n-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> A &gt; B ? A : B;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很可惜，虽然逻辑上正确，但是由于是递归，在数据规模大一点之后，就不行了，因为我们前面也说到，存在大量的重叠子问题，问题多一个输入，那么计算的规模就要乘上2，所以时间复杂度为2^n这个级别。所以此方案放在leetcode上会超时，下面就是想办法把他改成非递归的版本。</p><p>前面提到，计算出来的子问题完全可以存在一个地方，下次要用直接取。OK，用非递归版本的数组版本实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        tmp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        tmp[<span class="number">1</span>] = nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? nums[<span class="number">0</span>] : nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> A = tmp[i-<span class="number">2</span>] + nums[i];</span><br><span class="line">            <span class="keyword">int</span> B = tmp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> max = A &gt; B ? A : B;</span><br><span class="line">            tmp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主体还是上面提到的那个关系，只是我们将子问题的结果放在了一个临时数组中。临时数组中存放的都是子问题的最优解。比如tmp[1]里面存放的就是前两个元素中最大值，即最优解。当计算前三个数中最优解的时候，我只要做一个选择，即要不要选择nums[2]这个元素，选择的话，那么我就从tmp[2-2]中得到最优解，加起来就是当前最优解，不选择的话，就从tmp[2-1]中选择最优解。依次下去，tmp中最后一个值就是整个序列中组合的最优解了。</p><p>这里注意一下，这里其实是记忆化搜索的思想来实现的，我们可以注意到，其实是自顶向下来看的，从第一个数字来一直推到最后。然而动态规划的思想是从底向上的，参见第一个递归版本的实现。我们先考虑的是最终的n，而不是考虑从0开始。所以在设计思想上是有所区别的，但是又是非常类似，有的人将他们归位一类，我想，它们在大多数场景下可以互换的化，可以认为都是广义上的DP算法吧，因为DP毕竟只是一种思想，正过来实现反过来实现也未尝不可。</p><p>我们用一个数组来存放子问题的最优解，大大降低了时间复杂度，leetcode上也顺利通过。其实这个是一种记忆化搜索的思想，上面这个用了一个数组，其实完全没有必要用数组，用两个变量即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> b = nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? nums[<span class="number">0</span>] : nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> A = a + nums[i];</span><br><span class="line">            <span class="keyword">int</span> B = b;</span><br><span class="line">            <span class="keyword">int</span> max = A &gt; B ? A : B;</span><br><span class="line">            a = b;</span><br><span class="line">            b = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度不变，空间上占用的更少了。下面我们还是从底向上的思想来解决一下这个问题吧。所以我们还是从最后一个元素开始思考，从后往前找，一直找到第一个结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        tmp[n-<span class="number">1</span>] = nums[n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                tmp[i] = Math.max(tmp[i],nums[j] + (j+<span class="number">2</span>&lt;n?tmp[j+<span class="number">2</span>]:<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下来的效果是要比上面的记忆化搜索效果差的，但是都通过了。</p><p>⭐墙裂推荐：</p><ul><li><a href="https://www.bilibili.com/video/av16544031" target="_blank" rel="noopener">动态规划 (第1讲)</a></li><li><a href="https://www.bilibili.com/video/av18512769/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">动态规划 (第2讲)</a></li></ul><p>部分图片截取于他的视频。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在求解某个序列的最优解的时候，经常会用到动态规划来解决。动态规划的核心是找出一个关系式，并且借助于选或者不选找出两个迭代的路径进行比较，最终遍历整个序列之后也就得到了选或者不选中的最优解，也就是整个序列的最优解。由于还是比较复杂的，所以是对动态规划学习的一个入门之作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
