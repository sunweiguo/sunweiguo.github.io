<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-26T15:36:42.693Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>锁模块</title>
    <link href="http://yoursite.com/2019/01/26/mysql/%E9%94%81%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/01/26/mysql/锁模块/</id>
    <published>2019-01-26T15:35:48.460Z</published>
    <updated>2019-01-26T15:36:42.693Z</updated>
    
    <content type="html"><![CDATA[<p>本章对行锁表所、共享锁排他锁进行详细说明。这是数据库锁的核心知识。</p><a id="more"></a><h2>MyISAM和InnoDB关于锁方面的区别</h2><p>结论：</p><ul><li>MyISAM默认使用的是表级锁，不支持行级锁</li><li>InnoDB默认使用的是行级锁，也支持表级锁</li></ul><p>所谓表级锁，就是锁住整张表。开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p><strong>MyISAM在执行select的时候会产生一个表共享读锁，当进行更新等操作的时候会产生表独占写锁（排他锁）</strong>。所以：</p><ul><li>myISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但会阻塞对同一个表的写请求。</li><li>myISAM表的写操作，会阻塞其他用户对同一个表的读和写操作。</li><li>myISAM表的读、写操作之间、以及写操作之间是串行的。</li></ul><blockquote><p>这里的读是共享锁，也可以将其变为排他锁，语法是select … for update</p></blockquote><p>上面说完了<code>MyISAM</code>的表锁，下面要说说<code>InnoDB</code>啦。<code>InnoDB</code>支持行级锁。</p><p>所谓行级锁，就是锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发性也最高。</p><h2>SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE</h2><p>如果你在查询数据，然后在同一个事务里插入或者修改相关的数据，常规的 <code>select</code> 语句不会提供足够的保护。其他的事务可以修改或者删除你正在查询的行。<code>InnoDB</code> 支持两种可以提供安全机制的读取锁：</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code></li><li><code>SELECT ... FOR UPDATE</code></li></ul><p><code>SELECT … LOCK IN SHARE MODE</code> 在读取的行上设置一个共享锁，其他的<code>session</code>可以读这些行，但在你的事务提交之前不可以修改它们。如果这些行里有被其他的还没有提交的事务修改，你的查询会等到那个事务结束之后使用最新的值。</p><p>索引搜索遇到的记录，<code>SELECT … FOR UPDATE</code> 会锁住行及任何关联的索引条目，和你对那些行执行 <code>update</code> 语句相同。其他的事务会被阻塞在比如执行 <code>update</code> 操作，获取共享锁，或从某些事务隔离级别读取数据等操作。</p><p>使用 <code>SELECT FOR UPDATE</code> 为 <code>update</code> 操作锁定行，只适用于 <code>autocommit</code> 被禁用（当使用 <code>START TRANSACTION</code> 开始事务或者设置 <code>autocommit</code> 为0时）。如果 <code>autocommit</code> 已启用，符合规范的行不会被锁定。</p><p>以上是对官方文档的翻译解读。</p><hr><p><code>SELECT … LOCK IN SHARE MODE</code> ：<strong>共享锁</strong>(S锁, <code>share locks</code>)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。</p><p>如果事务对某行数据加上共享锁之后，可进行读写操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。</p><p><code>SELECT … FOR UPDATE</code>：<strong>排他锁</strong>(X锁, <code>exclusive locks</code>)。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。</p><p>注：普通 <code>select</code> 语句默认不加锁，而<code>CUD</code>操作默认加排他锁。</p><ul><li>当前事务获取共享锁后，可以读写，其他事务是否可以进行读写操作和获取共享锁：可以读，可以获取共享锁，不可以写</li><li>两个事务同时获取共享锁后，是否可以进行update操作：不可以</li><li>当前事务获取排他锁后，其他事务是否可以进行读写操作和获取共享锁：其他事务可以读，不可以获取共享锁，不可以写</li><li>是否可对一条数据加多个排他锁：不可以</li><li>行锁和索引的关系：查询字段未加索引（主键索引、普通索引等）时，使用表锁</li></ul><blockquote><p>注：InnoDB行级锁基于索引实现。</p></blockquote><blockquote><ul><li><p>未加索引时，两种行锁情况为（使用表锁）：</p><ul><li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的共享锁，不可以获取不同行数据的排他锁</li><li>事务1获取某行数据排他锁，其他事务不可以获取不同行数据的共享锁、排他锁</li></ul></li><li><p>加索引后，两种行锁为（使用行锁）：</p><ul><li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的排他锁</li><li>事务1获取某行数据排他锁，其他事务可以获取不同行数据的共享锁、排他锁</li></ul></li></ul></blockquote><ul><li>索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</li></ul><h2>总结（很重要）</h2><ul><li>MyISAM默认使用的是表级锁，不支持行级锁<ul><li>执行select的时候会产生一个表共享读锁</li><li>当进行更新等操作的时候会产生表独占写锁（排他锁）</li><li>读不会阻塞其他session的读以及获取表共享读锁</li><li>写会阻塞其他session读和写操作</li><li>写与读之间是串行的</li></ul></li><li>InnoDB默认使用的是行级锁，也支持表级锁<ul><li>InnoDB 支持两种可以提供安全机制的读取锁：SELECT … LOCK IN SHARE MODE以及SELECT … FOR UPDATE</li><li>SELECT … LOCK IN SHARE MODE 在读取的行上设置一个共享锁</li><li>SELECT … FOR UPDATE：排他锁</li><li>一个session对某一行上共享锁，其他的session可以读这行，也可以获取共享锁，但是不允许写，更不允许获取写锁。对于其他行，可以读写其他行数据也可以上读写锁。</li><li>一个session对某一行上排他锁，其他的session则不能加任何锁，包括共享锁。允许读这一行，但是不能写。允许对其他行数据进行读写以及上读写锁。</li><li>InnoDB中行级锁基于索引实现，所以在不加索引的时候，这两者上的其实都是表锁；加上索引之后，使用行锁。</li></ul></li></ul><div class="tip"><p>以上的内容都是从博客：<a href="https://blog.csdn.net/u012099869/article/details/52778728" target="_blank" rel="noopener">https://blog.csdn.net/u012099869/article/details/52778728</a> 中整理而来，具体的实验也在他的博客中进行了详细的展示。</p></div><h2>MyISAM适合场景</h2><ul><li>频繁执行全表count语句(MyISAM已经用一个表保存了行数)</li><li>对数据进行增删改的频率不高，查询非常频繁</li><li>没有事务</li></ul><h2>InnoDB适合场景</h2><ul><li>数据增删改查都相当频繁</li><li>可靠性要求比较高，要求支持事务</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章对行锁表所、共享锁排他锁进行详细说明。这是数据库锁的核心知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于索引失效和联合索引</title>
    <link href="http://yoursite.com/2019/01/26/mysql/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/01/26/mysql/关于索引失效和联合索引/</id>
    <published>2019-01-26T14:02:17.335Z</published>
    <updated>2019-01-26T14:02:52.401Z</updated>
    
    <content type="html"><![CDATA[<p>理解最左前缀原则，可以帮助我们避免索引失效。</p><a id="more"></a><h2>索引失效</h2><blockquote><p>查询条件包含or</p></blockquote><p>当<code>or</code>左右查询字段只有一个是索引，该索引失效，<code>explain</code>执行计划<code>key=null</code>；只有当or左右查询字段均为索引时，才会生效；</p><blockquote><p>组合索引，不是使用第一列索引，索引失效</p></blockquote><ul><li>如果<code>select * from key1=1 and key2= 2;</code>建立组合索引<code>（key1，key2）</code>;</li><li><code>select * from key1 = 1;</code>组合索引有效；</li><li><code>select * from key1 = 1 and key2= 2;</code>组合索引有效；</li><li><code>select * from key2 = 2;</code>组合索引失效；不符合最左前缀原则</li></ul><blockquote><p>like 以%开头</p></blockquote><p>使用<code>like</code>模糊查询，当%在前缀时，索引失效；</p><blockquote><p>如何列类型是字符串，where时一定用引号括起来，否则索引失效</p></blockquote><blockquote><p>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效</p></blockquote><h2>最左前缀原则</h2><p>建立以下sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`test_index`</span>(</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`data`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`union_index`</span> (<span class="string">`a`</span>,<span class="string">`b`</span>,<span class="string">`c`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> ROW_FORMAT=DYNAMIC  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=<span class="built_in">binary</span>;</span><br></pre></td></tr></table></figure><p>测试的<code>mysql</code>版本是 5.7.</p><ol><li>首先以列a作为条件查询数据，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 4</code> 表示索引长度为4，也就是利用上了索引来进行查找:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>然后以列b作为条件查询数据，可以看到<code>type: ALL</code>表示全表查找, <code>key_len: NULL</code> 表示没有索引，也就说明如果只使用b作为查询条件，不能利用索引来加快查找速度.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="3"><li>接着以列c作为条件查询数据，可以看到<code>type: ALL</code>表示全表查找, <code>key_len: NULL</code> 表示没有索引，情况与用b作为条件一样，只使用c作为查询条件也不能利用索引来加快查找速度</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="4"><li>现在来测一下使用a、b作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 8</code> 表示索引长度为8，也就是说我们利用上了a、b联合索引来进行查找</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> b = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">8</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="5"><li>紧接着来测一下使用a、c作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 4</code> 表示索引长度为4，这就奇怪了，按照最左原则来说，a、c上是不会建立索引的，为什么会有索引长度呢？其实与a、b上的索引一比较我们就能发现，a、c上的索引长度只有4，而且单独的c上是没有索引的，所以4字节长度的索引只能是a上的，也就是说这种情况我们只使用了a列上的索引来进行查找</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">index</span> condition</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="6"><li>为了进一步验证上面的想法，这一次测一下使用b、c作为条件的情况，我们看到 <code>type: ALL</code> 表示全表查找, <code>key_len: NULL</code> 表示没有索引可以使用，按照最左原则来说，b列上没有索引，c列上也没有索引，同时b、c的上也不存在联合索引，所以使用b、c作为查询条件时无法利用联合索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">1.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="7"><li>测试完两个条件的情况，接下来测试一下使用a、b、c作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 12</code> 表示索引长度为12，这完全符合联合索引的最左原则，同时使用3个条件查询可以利用联合索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">12</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="8"><li>下面这种情况也能利用a、b上的联合索引，索引长度为8</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span> <span class="keyword">and</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">8</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="9"><li>再来试试这种情况，按照最左原则，c上没有建立索引，a上有索引，c、a没有建立联合索引，所以只能使用a上的索引进行查找，结果索引长度只有4，验证了我们的想法，联合查询条件使用索引时满足“交换律”</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> c = <span class="number">1</span> <span class="keyword">and</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">index</span> condition</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2>联合索引总结</h2><ol><li>联合索引的最左原则就是建立索引<code>KEY union_index (a,b,c)</code>时，等于建立了(a)、(a,b)、(a,b,c)三个索引，从形式上看就是索引向左侧聚集，所以叫做最左原则，因此最常用的条件应该放到联合索引的组左侧。</li><li>**对于&quot;=&quot;和&quot;in&quot;可以乱序。**利用联合索引加速查询时，联合查询条件符合“交换律”，也就是<code>where a = 1 and b = 1</code> 等价于 <code>where b = 1 and a = 1</code>。这归功于mysql查询优化器，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</li><li><strong>mysql会一直向右匹配直到遇到范围查询(&lt;,&gt;,between,like)就停止匹配</strong>。比如a=3 and b=4 and c&gt;5 and d=6，如果建立(a,b,c,d)顺序的索引，d是用不到索引的。如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li></ol><h2>对于最左匹配原则的理解</h2><p><a href="https://www.zhihu.com/question/36996520" target="_blank" rel="noopener">mysql索引最左匹配原则的理解?–沈杰的回答</a></p><p>其实我觉得只要理解一点就是，只要有最左边的索引元素，那么这个索引结构一定是按照最左索引元素排序的，后序的索引元素也是依赖于最左元素之后才有可能变得有意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解最左前缀原则，可以帮助我们避免索引失效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL调优</title>
    <link href="http://yoursite.com/2019/01/26/mysql/MySQL%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2019/01/26/mysql/MySQL调优/</id>
    <published>2019-01-26T14:01:10.286Z</published>
    <updated>2019-01-26T14:02:08.396Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍最基本的sql调优手段。</p><a id="more"></a><h2>根据慢日志定位慢查询sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这里是用模糊查询查出关于查询的一些配置项--&gt;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%query%'</span></span><br></pre></td></tr></table></figure><p>我们关注<code>slow_query_log</code>：<code>OFF</code>，表示慢查询处于关闭状态。关注<code>long_query_time</code>：超出这个时间就是慢查询，记录到<code>slow_query_log_file</code>文件中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%slow_queries%'</span></span><br></pre></td></tr></table></figure><p>这一句作用是统计慢查询的数量。</p><p>如何打开慢查询呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--打开慢查询--&gt;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log = <span class="keyword">on</span>;</span><br><span class="line">&lt;!--慢查询的标准是1秒--&gt;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>注意要重启一下客户端。或者在配置文件中设置，重启服务端就永久保留了。</p><h2>explain分析慢日志</h2><p>上一步时打开慢查询日志。下面要进行分析。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ...</span><br></pre></td></tr></table></figure><p>对这个命令进行分析。有两个关键字段：</p><p><code>type</code>：表示mysql找到数据行的方式，下面的顺序是由快到慢：</p><p><code>system</code>&gt;<code>const</code>&gt; <code>eq_ref</code>&gt;<code>ref</code>&gt;<code>fulltext</code>&gt;<code>ref_or_null</code>&gt;<code>index_merge</code>&gt;<code>unique_subquery</code>&gt;<code>index_subquery</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>all</code></p><p><strong>其中<code>index</code>和<code>all</code>为全表扫描。说明需要优化。</strong></p><p><code>extra</code>：</p><ul><li><code>using_filesort</code>：表示MySQL会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容。可能在内存或者磁盘上进行排序。MqSQL中无法利用索引完成的排序操作称为“文件排序”</li><li><code>using temporary</code>：表示MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by。</li></ul><p><strong>当<code>extra</code>中出现以上两项意味着MYSQL根本不能使用索引，效率会受到重大影响，应尽可能对此进行优化。</strong></p><h2>修改sql或者尽量让sql走索引</h2><p>上一步分析完之后，就要采取一定的措施来修正。</p><p>如果是没有加索引，可以对其加上索引。<code>extra</code>就会变成<code>using index</code>，表示走了索引。</p><h2>索引是越多越好吗</h2><ul><li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li><li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li><li>更多的索引意味着也需要更多的空间</li></ul><p>可以理解为，一个几页的宣传手册</p><ul><li>对于几页的宣传手册我们还需要建立一个目录吗？</li><li>变更这个小的宣传手册里面的章节还要修改目录不是更烦吗？</li><li>一个宣传手册内容就两页，结果你的目录就占了一页，这合理吗？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍最基本的sql调优手段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引全面解读</title>
    <link href="http://yoursite.com/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/01/26/mysql/MySQL索引全面解读/</id>
    <published>2019-01-26T13:04:35.636Z</published>
    <updated>2019-01-26T13:05:27.856Z</updated>
    
    <content type="html"><![CDATA[<p>彻底理解MySQL的存储引擎数据结构以及聚集索引。</p><a id="more"></a><h2>1.为什么需要索引</h2><p>如果不用索引，那么最简单的方案是：将数据全部或者分批次地加载到内存，因为数据是以页的形式存储的，所以我们可以轮询这些页，找出有没有我们需要的数据。</p><p>在大数据量的情况下，显然是会非常慢的。因为它要进行全表的扫描。</p><p>而索引的灵感来源于字典，我们知道，新华字典前面有按照拼音或者按偏旁部首排序的一个列表页，我们可以快速地根据这个索引目录迅速定位到某几页，然后我们到这个某几页找一下就可以找到了。不需要全表扫描。</p><h2>2.索引的数据结构</h2><h5>2.1 二叉查找树上阵</h5><p>二叉查找树的特点：</p><ul><li>二分搜索树本质上是一棵二叉树。不需要是一棵完全二叉树。</li><li>每个节点的键值大于左孩子</li><li>每个节点的键值小于右孩子</li><li>以左右孩子为根的子树仍为二分搜索树</li></ul><p>二叉查找树有点很明显，我们查询一个数据只需要O(logn)的时间。但是它存在一个致命问题：</p><p>我们有时会删除增加数据，搞的不好，会把他恶化成一个链表。</p><p><img src="http://bloghello.oursnail.cn/mysql4-1.jpg" alt="image"></p><p>但是有的同学说，我们可以利用红黑树之类的数据结构来维持住平衡二叉树的特性，这样不就好了吗？</p><p>这里还存在另一个问题，就是IO。我们知道从磁盘查询数据，影响性能的关键点是iO的次数，然后这种一个节点只有两个孩子，在海量数据里，IO的次数还是太多，影响性能。</p><p>我们这个时候就知道了方向，我们想找一个数据结构，它既包含了二叉树的优点，还要是平衡的树，还能使树的高度变矮，并且每个节点存储更多的数据。</p><h5>2.2 BTree上阵</h5><p>B数又叫平衡多路查找树。M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉</p><p><img src="http://bloghello.oursnail.cn/mysql4-2.jpg" alt="image"></p><p>有几个特点：</p><ul><li>根节点至少包含两个孩子</li><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li><strong>子节点数</strong>：树中每个节点最多包含m个孩子(m&gt;=2)；除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子</li><li><strong>关键字数</strong>：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于m-1个（<strong>分别比孩子数少一个</strong>）</li><li>所有叶子节点都位于同一层，即所有叶子节点高度都一样</li></ul><p>我们结合这个图来理解。</p><p>可以看到，我们这是一个3路B树，根节点有3个孩子，有2个关键字。根据规则，子节点数最多为m个即3个，最少为ceil(1.5)个即2个；关键字数最多为m-1个即2个，最少为于ceil(1.5)-1个即1个.</p><p>那么我们进行插入的时候，关键字这里最多为2个，所以大于2就要进行拆分。</p><p>如何拆分呢？拿个例子来：</p><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;</p><p>那么关键字最多为4个，超过4个就拆分。</p><p>先插入 3、8、31、11</p><p><img src="http://bloghello.oursnail.cn/mysql4-23jpg.jpg" alt="image"></p><p>再插入23、29</p><p><img src="http://bloghello.oursnail.cn/mysql4-3.jpg" alt="image"></p><p>再插入50、28</p><p><img src="http://bloghello.oursnail.cn/mysql4-4.jpg" alt="image"></p><p>大概就是这样的流程。总之要维护一个从左到右逐渐增大的一个特性，并且必须是平衡的。(大概忽略里面可能存在的一些小错误，理解其中意思即可)</p><p>对于删除也是如此，要满足以上的特性才行，这里就不再赘述了。</p><p>对B树总结一下：</p><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p><h5>2.3 B+树</h5><p>是B树的变体，其定义基本上与B树是差不多的。除了：</p><ul><li><strong>非叶子节点的子树指针与关键字个数相同</strong></li><li><strong>非叶子节点仅用来索引，数据都保存在叶子节点中</strong></li><li><strong>所有叶子节点均有一个链指针指向下一个叶子节点</strong></li></ul><p>这就是B+树相对于B树的改进的几个点。</p><p>由于数据存在叶子节点，优点是非叶子节点保存的关键字更多了，树的高度就会更矮。</p><p><img src="http://bloghello.oursnail.cn/mysql4-5.jpg" alt="image"></p><h5>2.4 总结</h5><p>B+树更适合用来做存储索引：</p><ul><li>B+树的磁盘读写代价更低（因为内部不存放数据，一次性读取的关键字更多，IO次数降低）</li><li>B+树的查询效率更加稳定（任何关键字的查找都要到叶子节点，导致每个查询都差不多）</li><li>B+树有利于对数据库扫描（遍历叶子节点就可以直接扫描整个表，这个适合做范围查询）</li></ul><h5>2.5 Hash索引也可以考虑一下</h5><p>Hash结构可以一次性地定位到响应位置。如果遇到碰撞的情况，只需要遍历链表即可。那么性能这么高，为什么我们不用Hash索引呢？</p><p>它也有缺点：</p><ul><li>只能做等值操作，不能使用范围查询</li><li>hash索引不是按照索引值顺序存储，无法使用于排序。</li><li>不能利用部分索引键查询（比如组合索引，hash索引是对这几个索引一起hash计算的，而我们用组合索引中的部分索引时就无法用了）</li><li>不能避免表扫描（会出现hashs冲突，必然要扫描里面具体的数据才行）</li><li>遇到大量hash值相等的时候性能不一定比B树高(同上)</li></ul><h2>3. 聚集索引</h2><h5>3.1 什么是聚集索引</h5><p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><h5>3.2 MyISAM和InnoDB索引实现</h5><p><strong>第一个不同是：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</strong></p><p><code>MyISAM</code>引擎使用<code>B+Tree</code>作为索引结构，叶节点的<code>data</code>域存放的是数据记录的地址，是没有任何顺序而言的，所以<strong>MyISAM的索引方式也叫做“非聚集”的</strong>，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><p><code>MyISAM</code>中索引检索的算法为首先按照<code>B+Tree</code>搜索算法搜索索引，如果指定的Key存在，则取出其<code>data</code>域的值，然后以<code>data</code>域的值为地址，读取相应数据记录。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9523.png" alt="image"></p><p>在<code>MyISAM</code>中，主索引和辅助索引（<code>Secondary key</code>）在结构上没有任何区别，只是主索引要求<code>key</code>是唯一的，而辅助索引的<code>key</code>可以重复。</p><p><code>InnoDB</code>也使用<code>B+Tree</code>作为索引结构。<code>InnoDB</code>的数据文件本身就是索引文件，即  <code>InnoDB</code> 表是基于聚簇索引建立的。</p><p><code>MyISAM</code>索引文件和数据文件是分离的，索引文件仅保存数据记录的地址（这一点可以通过在<code>data</code>目录下查看数据库文件验证。<code>Innodb</code>每一个数据库只有一个数据文件，而<code>Myisam</code>则有三个（数据文件、索引文件、表结构文件））。</p><p>而在<code>InnoDB</code>中，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的<code>key</code>是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9524.png" alt="image"></p><p>上图是<code>InnoDB</code>主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。聚集索引的确定规则为：</p><ul><li>若一个主键被定义，该主键则作为聚集索引</li><li>若没有主键被定义，该表的第一个唯一非空索引作为聚集索引</li><li>若上述都找不到，innodb内部会生成一个隐藏主键(聚集索引)</li><li>非主键索引存储相关键位和其对应的主键值，包含两次查找</li></ul><p><strong>第二个与<code>MyISAM</code>索引的不同是<code>InnoDB</code>的辅助索引<code>data</code>域存储相应记录主键的值而不是地址。</strong></p><p>换句话说，<code>InnoDB</code>的所有辅助索引都引用主键作为<code>data</code>域。</p><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p><img src="http://bloghello.oursnail.cn/mysql4-6.jpg" alt="image"></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了<code>InnoDB</code>的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在<code>InnoDB</code>中不是个好主意，因为<code>InnoDB</code>数据文件本身是一颗<code>B+Tree</code>，非单调的主键会造成在插入新记录时数据文件为了维持<code>B+Tree</code>的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择</p><h2>4. 总结</h2><p>本文首先介绍的是为什么要索引。这个问题很简单。</p><p>然后介绍了几种数据结构：二叉搜索树、二叉平衡树、B树以及B+树。一步一步引出为什么最终是B+树。面试的时候就看解决：为什么不能用二叉搜索树、为什么不用红黑树、B树和B+树各自的数据结构特点、B+树的优点</p><p>最后介绍了聚集索引，因为这是MyISAM与InnoDB索引结构最大的不同。</p><p>之前还是不能太准确理解聚集索引，这两种存储引擎都是以B+树数据结构建立索引结构的，但是InnoDB本身这个B+树就作为了索引文件，即索引与数据是放在一起的，所以逻辑上这样排的数据，它物理上也是这么排。</p><p>而MyISAM的索引结构(B+树)与数据是分离的，虽然B+树可能是按照主键有序地组织，但是表的数据在另一个地方是随机放的，找数据是根据地址来找即可，所以这种结构就不是聚集的。</p><p>理解了这个，下面就非常好理解了，InnoDB这个B+树，我们知道，叶子节点的核心数据就是主键。所以是按照主键递增的方式进行排列。这样子，无论是按照主键排序还是范围搜索，都会非常地快。</p><p>那么如果是非主键索引的辅助索引呢？InnoDB只能通过两次查询来实现了，首先第一步是根据这个辅助索引找到存放在叶子节点中的主键值，然后根据主键再去主键索引中去查找对应的数据。</p><p>而MyISAM索引，主键索引和辅助索引就区别不大了。都是单独一个索引结构，然后根据最后叶子节点中的该条数据的地址去找。</p><p>上面说的按照主键排列，就是这里所谓的聚集索引啦。当然了，如果没有指定主键，会按照上面所说的规则去构建聚集索引。</p><p>那么，面试的时候，就可以应对InnoDB与MyISAM索引结构的各自的实现和不同点啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;彻底理解MySQL的存储引擎数据结构以及聚集索引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引入门</title>
    <link href="http://yoursite.com/2019/01/26/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/01/26/mysql/数据库索引入门/</id>
    <published>2019-01-26T12:56:21.061Z</published>
    <updated>2019-01-26T13:06:28.879Z</updated>
    
    <content type="html"><![CDATA[<p>索引是数据库中提高性能的一大利器。本篇入门索引的基本知识。</p><a id="more"></a><h2>1. 什么是索引</h2><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><h2>2. 为什么要用索引</h2><p>索引主要就是为了提高查询速度用的。</p><h2>3. 索引的一些缺点</h2><ul><li>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h2>4. 哪些字段适合用索引</h2><ul><li><strong>在经常需要搜索的列上</strong>，可以加快搜索的速度；</li><li><strong>在作为主键的列上</strong>，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li><strong>在经常需要根据范围进行搜索的列上创建索引</strong>，因为索引已经排序，其指定的范围是连续的；</li><li><strong>在经常需要排序的列上创建索引</strong>，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li><strong>在经常使用在WHERE子句中的列上面创建索引</strong>，加快条件的判断速度。（这同一）</li></ul><h2>5. 不应该创建索引的的这些列具有下列特点</h2><ul><li>第一，<strong>对于那些在查询中很少使用或者参考的列不应该创建索引</strong>。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>第二，<strong>对于那些只有很少数据值的列也不应该增加索引</strong>。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>第三，<strong>对于那些定义为<code>text</code>, <code>image</code>和<code>bit</code>数据类型的列不应该增加索引</strong>。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>第四，<strong>当修改性能远远大于检索性能时，不应该创建索引</strong>。这是因为，<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><h2>6. 索引的分类</h2><p><code>B-Tree</code> 索引， <code>Hash</code> 索引， <code>Fulltext</code> 索引和<code>R-Tree</code> 索引</p><p>最主要关心的是<code>B-Tree</code> 索引。下面再提一下聚集索引，因为这是innodb最主要的组织方式。</p><p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><p><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">下一节</a>会详细讲到<code>InnoDB</code>和<code>MyISAM</code>的索引实现方式，他们最大的区别就是<code>InnoDB</code>是聚集索引，而<code>MyISAM</code>不是。</p><h2>7. 局部性原理与磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此<strong>为了提高效率，要尽量减少磁盘I/O</strong>。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会<strong>预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。<strong>这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（<code>page</code>）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h2>8.B树/B+树</h2><p>想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是<code>B tree</code>或者 <code>B+ tree</code>，重要的事情说三遍：“<strong>平衡树，平衡树，平衡树</strong>”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。</p><p>我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。</p><p>事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。</p><p><strong>如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引</strong>。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。</p><p><strong>这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置</strong>。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9521.png" alt="image"></p><p>上图就是带有主键的表（聚集索引）的结构图。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句：</p><blockquote><p>select * from table where id = 1256;</p></blockquote><p>首先根据索引定位到1256这个值所在的叶结点，然后再通过叶结点取到id等于1256的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%9522.jpg" alt="image"></p><p>这一节先对索引入个门，关于B+树以及聚集索引下篇文章来具体分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引是数据库中提高性能的一大利器。本篇入门索引的基本知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个关系型数据库</title>
    <link href="http://yoursite.com/2019/01/26/mysql/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/01/26/mysql/如何设计一个关系型数据库/</id>
    <published>2019-01-26T08:23:31.518Z</published>
    <updated>2019-01-26T08:29:22.339Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个比较空的面试题，这里说一下如何回答。</p><a id="more"></a><h2>如何设计一个关系型数据库</h2><p>我们考虑开发一个数据库最重要的模块是什么。首先数据存储是其核心功能。因此会有一个存储模块来存储数据。介质主要是硬盘。</p><p>可是，光有存储是不行的。我们需要有以下程序模块对数据进行组织。</p><ul><li>存储管理</li></ul><p>我们需要对数据的格式和文件的分隔进行统一的管理，通过逻辑的形式来组合和表示出来。</p><p>我们知道程序处理，需要将数据先加载到内存中去，不可能直接在硬盘上进行处理。</p><p>我们通过io读取磁盘数据，磁盘的io是非常耗时的，所以硬盘以页的形式存储数据，根据局部性原理，往往用户要查询的数据周围的数据也会被查询到，所以取数据都是以页为单位查取多个数据，提高效率。</p><ul><li>缓存机制</li></ul><p>也就是上面提到的，一次IO不会只取用户所需要的一点数据，所以会涉及到缓存，缓存可能会不够放，那就涉及一些缓存淘汰的算法，比如比较常用的是LRU算法。</p><ul><li>SQL解析</li></ul><p>将SQL进行编译执行。如何提高SQL解析效率呢？可能也用缓存，缓存好SQL解析后的结果，下次再执行一样的SQL就可以免去解析的过程。</p><ul><li>日志管理</li></ul><p>要记录SQL操作，方便主从同步、灾难恢复等。这里要了解一下binlog.</p><ul><li>权限划分</li></ul><p>就是权限。</p><ul><li>容灾机制</li></ul><p>要对异常情况做好准备，比如数据库挂了怎么办。</p><ul><li>索引管理</li></ul><p>优化数据库执行效率。</p><ul><li>锁模块</li></ul><p>使得数据库支持并发操作。</p><h2>总结</h2><p>了解了上面的内容，我们就可以对这个问题做一个简单的总结性回答了，如何设计关系型数据库呢？首先数据库有一个存储的功能，使得它能存储在比如机械硬盘或者固态硬盘上面。其次，我们需要一个存储管理模块来映射程序逻辑与物理地址，实现存储管理。还需要缓存机制，对一些数据进行缓存提高效率，并且缓存不能太大，必须配备缓存淘汰机制；然后需要一个SQL解析模块，来解析SQL；然后需要日志管理来提供主从赋值、主从同步等功能；还需要一个权限划分模块，来提供给多用户使用场景；还需要容灾机制面对异常情况；最后，为了提高数据查询效率需要有索引管理模块；为了支持并发操作需要有锁模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个比较空的面试题，这里说一下如何回答。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>delete和truncate以及drop区别</title>
    <link href="http://yoursite.com/2019/01/25/mysql/delete%E5%92%8Ctruncate%E4%BB%A5%E5%8F%8Adrop%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/01/25/mysql/delete和truncate以及drop区别/</id>
    <published>2019-01-25T14:31:42.869Z</published>
    <updated>2019-01-25T14:32:44.400Z</updated>
    
    <content type="html"><![CDATA[<p>这个题目我自己也被问过，这里简单整理一下。</p><a id="more"></a><p>先来个总结：</p><ul><li><code>drop</code>直接删掉表；</li><li><code>truncate</code>删除的是表中的数据，再插入数据时自增长的数据id又重新从1开始；</li><li><code>delete</code>删除表中数据，可以在后面添加<code>where</code>字句。</li></ul><h2>日志是否记录</h2><p><code>DELETE</code>语句执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p><p><code>TRUNCATE TABLE</code> 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><h2>是否可以回滚</h2><p><code>delete</code> 这个操作会被放到 <code>rollback segment</code> 中,事务提交后才生效。<code>truncate</code>、<code>drop</code>是DLL（data define language),操作立即生效，原数据不放到 <code>rollback segment</code> 中，不能回滚.</p><p>所以在没有备份情况下，谨慎使用 <code>drop</code> 与 <code>truncate</code>。</p><h2>表和索引占的空间</h2><p>当表被 <code>TRUNCATE</code> 后，这个表和索引所占用的空间会恢复到初始大小。</p><p>而 <code>DELETE</code> 操作不会减少表或索引所占用的空间。</p><p><code>drop</code>语句将表所占用的空间全释放掉。</p><p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据，而 <code>DROP</code> 则删除整个表（结构和数据）</p><p>所以从干净程度，<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></p><p>ok，差不多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个题目我自己也被问过，这里简单整理一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql最基础知识小结</title>
    <link href="http://yoursite.com/2019/01/25/mysql/mysql%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/25/mysql/mysql最基础知识小结/</id>
    <published>2019-01-25T13:51:16.997Z</published>
    <updated>2019-01-25T13:57:04.879Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍关于数据库的最最最最基本的一些语法知识，如果这些都不熟悉，建议多多练习，因为后续的文章会比较深入原理。</p><a id="more"></a><p>一、DDL语句</p><p>1、创建数据库：<code>create database dbname;</code></p><p>2、删除数据库：<code>drop database dbname;</code></p><p>3、创建表：<code>create table tname;</code></p><p>4、删除表：<code>drop table tname;</code></p><p>5、修改表：略，懒得看</p><hr><p>二、DML语句</p><ul><li>插入：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span>(字段<span class="number">1</span>，字段<span class="number">2</span>，...) <span class="keyword">values</span> (value1,value2,...) , (value3,value4,..)</span><br></pre></td></tr></table></figure><ul><li>更新：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> 字段=<span class="keyword">value</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><ul><li>删除：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><p>这里要注意下<code>delete</code>和<code>truncate</code>以及<code>drop</code>三者的区别，下篇文章详解。</p><ul><li>单表查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure><ul><li>连表查询方式1：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 别名<span class="number">1.</span>字段,别名<span class="number">2.</span>字段 <span class="keyword">from</span> table1 别名<span class="number">1</span>,table2 别名<span class="number">2</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><ul><li>连表查询方式2：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 别名<span class="number">1.</span>字段,别名<span class="number">2.</span>字段 <span class="keyword">from</span> table1 别名<span class="number">1</span> <span class="keyword">join</span> table2 别名<span class="number">2</span> <span class="keyword">on</span> ...</span><br></pre></td></tr></table></figure><p>这是全连接，这里就要了解一下笛卡儿积，简单来说，最后行数是左边表的函数乘以右边表的行数。详细的可以自行google.</p><ul><li>查询不重复的记录：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span> ...</span><br></pre></td></tr></table></figure><ul><li>排序：默认是升序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ... <span class="keyword">asc</span>/<span class="keyword">desc</span></span><br></pre></td></tr></table></figure><ul><li>limit：主要用于分页</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ... <span class="keyword">asc</span>/<span class="keyword">desc</span> <span class="keyword">limit</span> 起始偏移位置，显示条数</span><br></pre></td></tr></table></figure><ul><li>聚合：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*)/<span class="keyword">avg</span>(..)/<span class="keyword">sum</span>(...)/<span class="keyword">max</span>(...)/<span class="keyword">min</span>(...) <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">group</span> <span class="keyword">by</span> ... <span class="keyword">having</span> ....</span><br></pre></td></tr></table></figure><p>注意这里的<code>having</code>和<code>where</code>的区别：<code>where</code>是对表结果进行筛选，<code>having</code> 是对查询结果进行筛选，与<code>group by</code> 合用</p><ul><li>左连接和右连接</li></ul><p>左连接意思就是左表中的记录都在，右表没有匹配项就以null显示。记录数等于左表的行数。</p><p>右连接与之同理，尽量转为左连接做。</p><ul><li>子查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">in</span> (<span class="keyword">select</span> ....)</span><br></pre></td></tr></table></figure><p>所谓子查询就是根据另一个<code>select</code>的结果再进行筛选，常用的是in,not in,=,!=,exits,not exits</p><ul><li>union<br>主要用于两张表中的数据的合并：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> table1 <span class="keyword">union</span> all <span class="keyword">select</span> 字段 <span class="keyword">from</span> table2</span><br></pre></td></tr></table></figure><p>要想不重复用<code>union</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍关于数据库的最最最最基本的一些语法知识，如果这些都不熟悉，建议多多练习，因为后续的文章会比较深入原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>一些常见的面试题</title>
    <link href="http://yoursite.com/2019/01/25/network/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/25/network/8.一些常见的面试题/</id>
    <published>2019-01-25T13:42:05.723Z</published>
    <updated>2019-01-25T13:43:01.881Z</updated>
    
    <content type="html"><![CDATA[<p>对这一块整理一些常见的面试题。</p><a id="more"></a><h2>1.TCP三次握手、四次挥手</h2><p>这部分略。前面已经说的很详细，包括握手为什么不是两次、为什么不是四次，为什么挥手要等2MSL的时间。</p><h2>2.常见的HTTP状态码及其含义</h2><ul><li>200 OK：正常返回信息</li><li>400 Bad Reqest：客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized：请求未经授权，这个状态码必须与WWW-Authenticate报头域一起使用</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在</li><li>500 Internal Server Error：服务器发生不可预期的错误</li><li>503 Server Unavilable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul><h2>3.Get请求和Post请求的区别</h2><ul><li>Http报文层面：GET将请求信息放在URL，POST则放在报文体中</li><li>数据库层面：GET符合幂等性和安全性(查询不会改变数据库)，POST不符合</li><li>其他层面：GET可以被缓存、被存储为书签，而POST不行</li></ul><h2>4.Cookie和Session的区别</h2><p>对于session，字面上理解是会话，可以理解为用户与服务端一对一的交互。是一个比较抽象的概念。</p><p>但是我们常说的session其实是这里抽象概念的一种实现方式罢了，我觉得没有必要咬文嚼字，下面直接从面试角度来分析一下。</p><p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。</p><p>这个Session是保存在服务端的，有一个唯一标识，这个唯一标识对应一个用户。在服务端保存Session的方法很多，内存、数据库、文件都有。</p><p>服务端解决了用户标识问题，但是服务端怎么知道此时操作浏览器的用户是谁呢？</p><p>这个时候<code>Cookie</code>就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。</p><p>实际上大多数的应用都是用 <code>Cookie</code> 来实现<code>Session</code>跟踪的，第一次创建<code>Session</code>的时候，服务端会在HTTP协议中告诉客户端(放在响应头中返回)，需要在 <code>Cookie</code> 里面记录一个<code>Session ID</code>，以后每次请求(请求头)把这个会话ID发送到服务器，我就知道你是谁了。</p><p>有人问，如果客户端的浏览器禁用了 <code>Cookie</code> 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p><p><code>Cookie</code>其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到<code>Cookie</code>里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是<code>Cookie</code>名称的由来，给用户的一点甜头。</p><p><strong>总结：</strong></p><p><code>Session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</p><p><code>Cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现<code>Session</code>的一种方式。</p><p>下面说一下很常见的一种写法。比如在单体应用中，我此时登陆你的网站了，你可以将我的信息保存在<code>session</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User currentUserInfo = userService.getUserByUsernameAndPasswd(username,password);</span><br><span class="line">session.setAttribute(<span class="string">"currentUser"</span>,currentUserInfo);</span><br></pre></td></tr></table></figure><p>下次，我就可以在我们之间的会话中随时获取我的个人信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User currentUser = session.getAttribute(<span class="string">"currentUser"</span>);</span><br></pre></td></tr></table></figure><p>其实这些就是利用存放在<code>Cookie</code>中的<code>JSESSIONID</code>来实现的。</p><h2>5.HTTP和HRTTPS的关系</h2><p>来说一下SSL(Security Sockets Layer，安全套接层)</p><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统对外的API，SSL3.0之后更名为TLS</li><li>采用身份验证和数据加密保证网络通信的安全和数据的完整性</li></ul><p>HTTPS数据传输流程：</p><ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器</li><li>浏览器验证证书合法性，并结合证书公钥加密信息发给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器</li><li>浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据</li></ul><p>这个也就不赘述了，下面直接说说区别。</p><ul><li>HTTPS需要到CA申请证书，HTTP不需要</li><li>HTTPS密文传输，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</li><li>HTTPS=HTTP+加密+认证+完整性保护，更安全</li></ul><p>但是仍然存在一定的风险：</p><ul><li>浏览器默认填充http://，请求需要进行跳转，有被劫持的风险</li><li>可以使用HSTS(HTTP Strict Transport Security)优化（这个还不未主流，面试问的少）</li></ul><h2>Socket简介</h2><p>我们知道，进程与进程直接的通信最基本的要求是：可以唯一确定进程。</p><p>在本地进程通信中，可以用PID来唯一标识一个进程。</p><p>但是PID只在本地唯一，网络中PID冲突的几率还是存在的。</p><p>我们知道，到IP层就可以唯一定位到一台主机了，TCP层(tcp协议+端口号)可以唯一定位一台主机中的一个进程。</p><p>这样，我们可以通过ip地址+协议+端口号可以唯一标识一台主机的一个进程。这样就可以通过socket进行网络通信了。</p><p>socket是对TCP/IP协议的抽象，是操作系统对外开放的接口。</p><p>socket起源于unix，而unix是遵从一切皆文件的哲学。Socket是一种基于从打开、读/写、关闭的模式实现的。客户端和服务器各自维护一个文件，在连接建立后，可以供对方读取或者读取对方内容。</p><h2>socket相关题目</h2><p>编写一个网络程序，有客户端和服务端，客户端向服务端发送一个字符串，服务器收到字符串之后打印到命令行上，然后向客户端返回该字符串的长度，最后，客户端输出服务端返回的该字符串的长度，分别用TCP和UDP两种方式去实现。</p><p>代码地址：<a href="https://github.com/sunweiguo/TcpAndUdp/" target="_blank" rel="noopener">https://github.com/sunweiguo/TcpAndUdp/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对这一块整理一些常见的面试题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络相关" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础核心-理解类、对象、面向对象编程、面向接口编程</title>
    <link href="http://yoursite.com/2019/01/24/java-basic/JAVA%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/01/24/java-basic/JAVA基础核心-理解类、对象、面向对象编程、面向接口编程/</id>
    <published>2019-01-24T03:21:28.861Z</published>
    <updated>2019-01-24T03:44:33.429Z</updated>
    
    <content type="html"><![CDATA[<p>什么是类，什么是对象，什么是面向对象编程，什么是面向接口编程。学习面向对象思想的语言，比如java，第一关可能就是要理解这些概念。下面就来好好琢磨一下。</p><a id="more"></a><h2>类和对象的概念</h2><p>首先总结一下：<strong>类是一个模板，对象就是用这个模板创造出来的东西</strong>。</p><p>比如，男孩，他就是一个模板，男的就行，那么对象是什么呢？就是具体某个男孩，比如男孩<code>BOB</code>，男孩<code>fourColor</code>.</p><p>请看下面一张图：</p><p><img src="http://bloghello.oursnail.cn/javabasic4-1.png" alt="image"></p><p>男孩女孩是比较抽象的概念，是模板，左边一排就是其具体的一些对象。你看长的都不一样，有的黑，有的白，有的高，有的矮，国家地区也不一样。但是他们都属于男孩或者女孩。</p><p>那么同理，人就是一个类，男孩女孩就是人的<strong>子类</strong>，因为人可能不仅包括男孩女孩，还包括第三性别这个类。</p><p>这里还引出了JAVA特性中的继承。继承简单理解就是父类有的东西(访问级别不能是private)的，那都是你的。比如你老爸的房子，就是属于你的，你出入自由。</p><p>人还可以分为胖人和瘦人这个子类。所以只要是抽象的模板，就是一个类。</p><ul><li>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li>类：类是一个模板，它描述一类对象的行为和状态。</li></ul><p>下面就拿狗这个类来说事。狗是动物这个类的子类。</p><h2>Java中创建类</h2><h5>构造器方法说明</h5><p>需要创造一个类对象出来的时候，要用到这个类的构造器方法，那么啥是构造器方法呢？<strong>构造器方法就是创造类时的初始化方法</strong>，和类同名的方法，你可以在里面写自己的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    访问权限 构造方法名称()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">   <span class="comment">//构造方法一</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"nothing to do..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造方法二</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">//这里就可以给每条new出来的对象(狗)初始化一个名字</span></span><br><span class="line">      System.out.println(<span class="string">"hi,my name is "</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>一个相对比较完整的类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    <span class="comment">//构造器方法</span></span><br><span class="line">    <span class="comment">//声明成员变量---这个变量属于这个类</span></span><br><span class="line">    <span class="comment">//声明成员方法</span></span><br><span class="line">        <span class="comment">//在方法里面定义的变量是局部变量，区别于成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"nothing to do..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">       <span class="comment">//这里就可以给每条new出来的对象(狗)初始化一个名字</span></span><br><span class="line">       System.out.println(<span class="string">"hi,my name is "</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//狗的颜色--成员属性</span></span><br><span class="line">    <span class="keyword">public</span> String color;<span class="comment">//一般是private，赋值用set方法，取值用get方法，这里只是演示</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//狗的行为，它会叫---成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"我会叫：汪汪汪~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>创建对象</h2><p>语法：</p><blockquote><p>类名 对象名 = new 类名() ;</p></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog fourcolor ;    // 先声明一个 Dog 类的对象 fourcolor</span><br><span class="line">fourcolor = new Dog(&quot;fourcolor&quot;) ;  // 用 new 关键字实例化 Dog 的对象 fourcolor,此时调用构造方法二</span><br></pre></td></tr></table></figure><p>通过<code>Dog</code>这个类可以创造出<code>fourcolor</code>对象.下面我才能操作这个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//让它的颜色为黑色</span><br><span class="line">fourcolor.color = &quot;black&quot;;</span><br><span class="line">//让它叫</span><br><span class="line">fourcolor.say();</span><br></pre></td></tr></table></figure><h2>面向对象</h2><p>在理解了什么是类，什么是对象，就可以来说说面向对象到底是什么了。</p><p>先来说说面向过程，大家都学习过C语言。C语言就是典型的面向过程的语言。</p><p>举个例子：要把大象装进冰箱里，这件事，面向过程的程序员是这样思考的：</p><ul><li>把冰箱门儿打开。</li><li>把大象装进去。</li><li>把冰箱门儿关上。</li></ul><p>上面的每一件事都用一个函数来实现。抽象为下面三个函数：</p><ul><li>openTheDoor()；</li><li>pushElephant()；</li><li>closeTheDoor()；</li></ul><p>这样不挺好的吗？为什么不用面向过程的这种思维来编程呢，还要搞出什么面向对象来。</p><p>需求又来啦：</p><ul><li>「我要把大象装微波炉里」</li><li>「我要把狮子也装冰箱里」</li><li>「我要把大象装冰箱，但是门别关，敞着就行」</li></ul><p>这个时候，面向过程的程序员就悲剧了，来一个需求我就写一个函数，我还能下班吗？</p><p>面向对象从另一个角度来解决这个问题。它抛弃了函数，把「对象」作为程序的基本单元。</p><p>面向对象的世界里，到处都是对象。即：万物皆对象。</p><p>比如人这个类，每个具体的人(对象)都要有这样的属性：身高、体重、年龄。每个人都有这样的行为：吃饭、睡觉、上厕所。</p><p>那么，这些通用的属性+方法可以构建一个模板：人这个类。因为每个具体的人（对象）都需要这些基本的东西。当然了，每个人具体什么身高、什么体重、吃什么都是不一样的，所以每个对象一般都是不一样的。但是模板是一样的。</p><p>那么，回到刚才的需求，面向对象是如何思考这件事的呢？</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>就是说，我不用亲自管开门的细节，我只要叫他开门即可。</p><div class="tip">我们创建的对象，应该是刚刚好能做完它能做的事情，不多做，不少做。多做了容易耦合，各种功能杂糅在一个对象里。比如我有一个对象叫「汽车」，可以「行驶」，可以「载人」，现在的需求是要实现「载人飞行」，就不能重用这个对象，必须新定义一个对象「飞机」来做。如果你给「汽车」插上了翅膀，赋予了它「飞行」的能力，那么新来的同学面对你的代码就会莫名其妙，无从下手。</div><p>但是不禁要问：怎么实现这种下达命令就可以自动去执行的效果呢？或者说，我怎么知道它有这个功能啊！</p><h2>面向接口编程</h2><p>现在我们把「数据」和「行为」都封装到了对象里，相当于对象成了一个黑匣子，那我们怎么知道对象具有什么样的能力呢？这个问题的关键就是接口。</p><p>因为无论是把大象装进洗衣机还是冰箱，都要求洗衣机或者冰箱有开门和关门的功能。这个时候，我们就可以抽象出来一个接口：【自动门】。这个接口里面定义两个能力：【开门】和【关门】。</p><p>让洗衣机、冰箱、微波炉这些带门的东西全部实现【自动门】接口。</p><p>这个时候，每个具体的实现可能略有不同，比如冰箱开门是往外拽，但是洗衣机开门可能是往上翻盖子。</p><p>此时，我有一个需求，把大象放进冰箱。我一看，冰箱实现了【自动门】这个接口，里面有【开门】和【关门】两个方法，ok，我知道冰箱是可以开门和关门了，那就好办了。我直接下达命令即可。还是跟上面一样的步骤.</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>此时，需要将狮子也装冰箱里。那还是一样：</p><ul><li>向冰箱下达「开门」的命令。</li><li>向狮子下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>此时，我要把大象装冰箱，但是门别关，敞着就行，那就：</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li></ul><p>是不是很方便？冰箱也可以换，我可以换成任何东西，只要实现了这个接口，这些东西就都有这些能力，那我才不管里面到底怎么实现的呢，直接下达【开门】【关门】命令即可。</p><p>这也引入了JAVA特性中另一个特性：封装。外界不知道里面实现细节，只需要知道它的功能和入参即可。</p><p>这就是面向过程和面向对象编程的区别，也顺带地理解了什么是面向接口编程。这是学习JAVA最基础也是最核心的点。</p><p>整理自：</p><ul><li><a href="https://tryenough.com/java05" target="_blank" rel="noopener">https://tryenough.com/java05</a></li><li><a href="http://www.woshipm.com/pmd/294180.html" target="_blank" rel="noopener">http://www.woshipm.com/pmd/294180.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是类，什么是对象，什么是面向对象编程，什么是面向接口编程。学习面向对象思想的语言，比如java，第一关可能就是要理解这些概念。下面就来好好琢磨一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java字符串核心一网打尽</title>
    <link href="http://yoursite.com/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/"/>
    <id>http://yoursite.com/2019/01/23/java-basic/java字符串核心一网打尽/</id>
    <published>2019-01-23T12:21:15.176Z</published>
    <updated>2019-01-24T01:56:07.682Z</updated>
    
    <content type="html"><![CDATA[<p>对字符串中最核心的点：对象创建和动态加入常量池这些点进行深入分析。</p><a id="more"></a><p>比如有两个面试题：</p><p>Q1：<code>String s = new String(&quot;abc&quot;);</code> 定义了几个对象。</p><p>Q2：如何理解<code>String</code>的<code>intern</code>方法？</p><p>A1：对于通过 <code>new</code> 产生的对象，会先去常量池检查有没有 “abc”，如果没有，先在常量池创建一个 “abc” 对象，然后在堆中创建一个常量池中此 “abc” 对象的拷贝对象。所以答案是：一个或两个。如果常量池中原来没有 ”abc”, 就是两个。如果原来的常量池中存在“abc”时，就是一个。</p><p>A2：当一个<code>String</code>实例调用<code>intern()</code>方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><h2>字面量和运行时常量池</h2><p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。</p><p>在JVM运行时区域的方法区中，有一块区域是运行时常量池，主要用来存储编译期生成的各种字面量和符号引用。</p><p>了解过JVM就会知道，在java代码被javac编译之后，文件结构中是包含一部分<code>Constant pool</code>的。比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译后，常量池内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #2 = String             #21            // abc</span><br><span class="line">  #3 = Class              #22            // StringDemo</span><br><span class="line">  #4 = Class              #23            // java/lang/Object</span><br><span class="line">  ...</span><br><span class="line">  #16 = Utf8               s</span><br><span class="line">  ..</span><br><span class="line">  #21 = Utf8               abc</span><br><span class="line">  #22 = Utf8               StringDemo</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p>上面的Class文件中的常量池中，比较重要的几个内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#16 = Utf8               s</span><br><span class="line">#21 = Utf8               abc</span><br><span class="line">#22 = Utf8               StringDemo</span><br></pre></td></tr></table></figure><p>上面几个常量中，<code>s</code>就是前面提到的符号引用，而<code>abc</code>就是前面提到的字面量。而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。</p><h2>new String创建了几个对象</h2><p>下面，我们可以来分析下<code>String s = new String(&quot;abc&quot;);</code>创建对象情况了。</p><p>这段代码中，我们可以知道的是，在编译期，符号引用<code>s</code>和字面量<code>abc</code>会被加入到Class文件的常量池中。由于是<code>new</code>的方式，在类加载期间，先去常量池检查有没有 “abc”，如果没有，先在常量池创建一个 “abc” 对象。</p><p>在运行期间，在堆中创建一个常量池中此 “abc” 对象的拷贝对象。</p><h2>运行时常量池的动态扩展</h2><p>编译期生成的各种字面量和符号引用是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期像运行时常量池中增加常量。那就是String的<code>intern</code>方法。</p><p>当一个String实例调用<code>intern()</code>方法时，JVM会查找常量池中是否有相同<code>Unicode</code>的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个<code>Unicode</code>等于str的字符串并返回它的引用；</p><p><code>intern()</code>有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。</p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s==s1:"</span>+(s==s1));</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s==s2:"</span>+(s==s2));</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1==s2:false</span><br><span class="line">s2==s3:true</span><br></pre></td></tr></table></figure><p>你可以简单的理解为<code>String s1 = &quot;hello world&quot;;</code>和<code>String s3 = new String(&quot;hello world&quot;).intern();</code>做的事情是一样的（但实际有些区别，这里暂不展开）。都是定义一个字符串对象，然后将其字符串字面量保存在常量池中，并把这个字面量的引用返回给定义好的对象引用。</p><p>对于<code>String s3 = new String(&quot;hello world&quot;).intern();</code>，在不调<code>intern</code>情况，<code>s3</code>指向的是JVM在堆中创建的那个对象的引用的（如<code>s2</code>）。但是当执行了<code>intern</code>方法时，<code>s3</code>将指向字符串常量池中的那个字符串常量。</p><p>由于<code>s1</code>和<code>s3</code>都是字符串常量池中的字面量的引用，所以<code>s1</code>==<code>s3</code>。但是，<code>s2</code>的引用是堆中的对象，所以<code>s2!=s1</code>。</p><h2>intern的正确用法</h2><p>不知道，你有没有发现，在<code>String s3 = new String(&quot;abc&quot;).intern();</code>中，其实<code>intern</code>是多余的？</p><p>因为就算不用<code>intern</code>，“abc&quot;作为一个字面量也会被加载到Class文件的常量池”&quot;，进而加入到运行时常量池中，为啥还要多此一举呢？到底什么场景下才会用到<code>intern</code>呢?<br>在解释这个之前，我们先来看下以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = s1 + s2;</span><br><span class="line">String s4 = <span class="string">"hello"</span> + <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><p>在经过反编译后，得到代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = (<span class="keyword">new</span> StringBuilder()).append(s1).append(s2).toString();</span><br><span class="line">String s4 = <span class="string">"helloworld"</span>;</span><br></pre></td></tr></table></figure><p>这就是阿里巴巴文档里为什么规定循环拼接字符串不准使用&quot;+&quot;而必须使用<code>StringBuilder</code>，因为反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个 <code>StringBuilder</code> 对象，然后进行<code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。</p><p>不恰当的方式形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"start"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    str = str + <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，言归正传，可以发现，同样是字符串拼接，<code>s3</code>和<code>s4</code>在经过编译器编译后的实现方式并不一样。<code>s3</code>被转化成<code>StringBuilder</code>及<code>append</code>，而<code>s4</code>被直接拼接成新的字符串。</p><p>如果你感兴趣，你还能发现，<code>String s4 = s1 + s2;</code> 经过编译之后，常量池中是有两个字符串常量的分别是 <code>hello</code>、<code>world</code>（其实<code>hello</code>和<code>world</code>是<code>String s1 = &quot;hello&quot;;</code>和<code>String s2 = &quot;world&quot;;</code>定义出来的），拼接结果<code>helloworld</code>并不在常量池中。</p><p>如果代码只有<code>String s4 = &quot;hello&quot; + &quot;world&quot;;</code>，那么常量池中将只有<code>helloworld</code>而没有<code>hello</code>和 <code>world</code>。</p><p><strong>究其原因，是因为常量池要保存的是已确定的字面量值</strong>。也就是说，对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串。</p><p>如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成<code>StringBuilder.append</code>，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。</p><p>那么，有了这个特性了，<code>intern</code>就有用武之地了。<strong>那就是很多时候，我们在程序中用到的字符串是只有在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中</strong>。</p><p>这时候，对于那种可能经常使用的字符串，使用<code>intern</code>进行定义，每次JVM运行到这段代码的时候，就会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了。</p><h2>总结</h2><h6>第一种情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(str1 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><ul><li>栈中开辟一块空间存放引用str1；</li><li>String池中开辟一块空间，存放String常量&quot;abc&quot;；</li><li>引用str1指向池中String常量&quot;abc&quot;；</li><li>str1所指代的地址即常量&quot;abc&quot;所在地址，输出为true</li></ul><h6>第二种情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); </span><br><span class="line">System.out.println(str2 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><ul><li>栈中开辟一块空间存放引用str2；</li><li>堆中开辟一块空间存放一个新建的String对象&quot;abc&quot;；</li><li>引用str2指向堆中的新建的String对象&quot;abc&quot;；</li><li>str2所指代的对象地址为堆中地址，而常量&quot;abc&quot;地址在池中，输出为false；</li></ul><h6>第三、四种情况</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（3）</span></span><br><span class="line">String str1 = <span class="string">"a"</span>；</span><br><span class="line">String str2 = <span class="string">"b"</span>；</span><br><span class="line">String str3 = str1 + <span class="string">"b"</span>；</span><br><span class="line"><span class="comment">//str1 和 str2 是字符串常量，所以在编译期就确定了。</span></span><br><span class="line"><span class="comment">//str3 中有个 str1 是引用，所以不会在编译期确定。</span></span><br><span class="line"><span class="comment">//又因为String是 final 类型的，所以在 str1 + "b" 的时候实际上是创建了一个新的对象，在把新对象的引用传给str3。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）</span></span><br><span class="line"><span class="keyword">final</span> String str1 = <span class="string">"a"</span>；</span><br><span class="line">String str2 = <span class="string">"b"</span>；</span><br><span class="line">String str3 = str1 + <span class="string">"b"</span>；</span><br><span class="line"><span class="comment">//这里和(3)的不同就是给 str1 加上了一个final，这样str1就变成了一个常量。</span></span><br><span class="line"><span class="comment">//这样 str3 就可以在编译期中就确定了</span></span><br></pre></td></tr></table></figure><p>这里的细节在上面已经详细说明了。</p><h6>第五种情况</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"ab"</span>；</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str1== str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2.intern() == str1);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>整理自：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4OTA3NDQ0Nw==&amp;mid=2455545837&amp;idx=1&amp;sn=5dde0e68c22e1827cc7422d1af39a2de&amp;chksm=fb9cbb8dcceb329b88dc91fe4c6a9d6535752cdd1191092d93da665b051f16c06bc9e0e2e508&amp;mpshare=1&amp;scene=24&amp;srcid=0121duABpN7IHaUl1JxPtp66&amp;ascene=14&amp;devicetype=android-26&amp;version=2700003b&amp;nettype=WIFI&amp;abtest_cookie=BgABAAgACgALABIAEwAUAAcAnoYeACaXHgBXmR4Am5keAJ2ZHgC3mR4A0pkeAAAA&amp;lang=zh_CN&amp;pass_ticket=UZ59UG%2Bqu2i5egH9vmxuu5prus%2FoCSM%2B4QOgzET8cSVcTyIG%2BDpQQbT5Prwgm96v&amp;wx_header=1" target="_blank" rel="noopener">我终于搞清楚了和String有关的那点事儿</a></li><li><a href="https://www.jianshu.com/p/2624036c9daa" target="_blank" rel="noopener">https://www.jianshu.com/p/2624036c9daa</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对字符串中最核心的点：对象创建和动态加入常量池这些点进行深入分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java字符串</title>
    <link href="http://yoursite.com/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/01/23/java-basic/java字符串/</id>
    <published>2019-01-23T08:56:37.842Z</published>
    <updated>2019-01-23T08:56:38.177Z</updated>
    
    <content type="html"><![CDATA[<p>关于java字符串不可变特性的深入理解。</p><a id="more"></a><h2>什么是不可变对象？</h2><p>众所周知， 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ 可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><h2>区分对象和对象的引用</h2><p>对于Java初学者， 对于String是不可变对象总是存有疑惑。看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);  </span><br><span class="line">  </span><br><span class="line">s = <span class="string">"123456"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = 123456</span><br></pre></td></tr></table></figure><p>首先创建一个 String 对象 <code>s</code> ，然后让 <code>s</code> 的值为 <code>ABCabc</code> ， 然后又让 <code>s</code> 的值为 <code>123456</code> 。 从打印结果可以看出，<code>s</code> 的值确实改变了。那么怎么还说 String 对象是不可变的呢？</p><p>其实这里存在一个误区：<strong>s只是一个String对象的引用，并不是对象本身</strong>。</p><p>对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。</p><p>引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。</p><p>也就是说，<code>s</code> 只是一个引用，它指向了一个具体的对象，当 s=“123456”; 这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个新的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。内存结构如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="image"></p><h2>为什么String对象是不可变的？</h2><p>要理解 String 的不可变性，首先看一下 String 类中都有哪些成员变量。 在JDK1.6中，String 的成员变量有以下几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>在JDK1.7和1.8中，String 类做了一些改动，主要是改变了<code>substring</code>方法执行时的行为，这和本文的主题不相关。JDK1.7中 String 类的主要成员变量就剩下了两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>由以上的代码可以看出， <strong>在Java中 String 类其实就是对字符数组的封装</strong>。</p><p>JDK6中， <code>value</code>是String封装的数组，<code>offset</code>是String在这个value数组中的起始位置，<code>count</code>是String所占的字符的个数。</p><p>在JDK7中，只有一个<code>value</code>变量，也就是<code>value</code>中的所有字符都是属于<code>String</code>这个对象的。这个改变不影响本文的讨论。</p><p>除此之外还有一个<code>hash</code>成员变量，是该 String 对象的哈希值的缓存，这个成员变量也和本文的讨论无关。在Java中，数组也是对象。</p><p>所以<code>value</code>也只是一个引用，它指向一个真正的数组对象。其实执行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = “ABCabc<span class="string">";</span></span><br></pre></td></tr></table></figure><p>这句代码之后，真正的内存布局应该是这样的：</p><p><img src="http://xiaozhao.oursnail.cn/String%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="image"></p><p><code>value</code>，<code>offset</code>和<code>count</code>这三个变量都是<code>private</code>的，并且没有提供<code>setValue</code>， <code>setOffset</code>和<code>setCount</code>等公共方法来修改这些值，所以在<code>String</code>类的外部无法修改<code>String</code>。也就是说一旦初始化就不能修改， 并且在<code>String</code>类的外部不能访问这三个成员。</p><p>此外，<code>value</code>，<code>offset</code>和<code>count</code>这三个变量都是<code>final</code>的， 也就是说在 String 类内部，一旦这三个值初始化了， 也不能被改变。所以可以认为 String 对象是不可变的了。</p><p>那么在 String 中，明明存在一些方法，调用他们可以得到改变后的值。这些方法包括<code>substring</code>， <code>replace</code>， <code>replaceAll</code>， <code>toLowerCase</code>等。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//ABCabc</span></span><br><span class="line">a = a.replace(<span class="string">'A'</span>, <span class="string">'a'</span>);  </span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//aBCabc</span></span><br></pre></td></tr></table></figure><p>那么<code>a</code>的值看似改变了，其实也是同样的误区。再次说明， <code>a</code>只是一个引用， 不是真正的字符串对象，在调用<code>a.replace('A', 'a')</code>时， 方法内部创建了一个新的String对象，并把这个心的对象重新赋给了引用a。String中<code>replace</code>方法的源码可以说明问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);<span class="comment">//new出了新的String对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>String对象真的不可变吗？</h2><p>从上文可知String的成员变量是<code>private final</code> 的，也就是初始化之后不可改变。那么在这几个成员中， <code>value</code>比较特殊，因为他是一个引用变量，而不是真正的对象。</p><p><code>value</code>是<code>final</code>修饰的，也就是说<code>final</code>不能再指向其他数组对象，那么我能改变<code>value</code>指向的数组吗？</p><p>比如将数组中的某个位置上的字符变为下划线“_”。 至少在我们自己写的普通代码中不能够做到，因为我们根本不能够访问到这个<code>value</code>引用，更不能通过这个引用去修改数组。<br>那么用什么方式可以访问私有成员呢？</p><p>没错，用反射， 可以反射出String对象中的<code>value</code>属性， 进而改变通过获得的<code>value</code>引用改变数组的结构。下面是实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s  </span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;   </span><br><span class="line">      </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取String类中的value字段  </span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//改变value属性的访问权限  </span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值  </span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符  </span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;  </span><br><span class="line">      </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中，<code>s</code>始终引用的同一个 String 对象，但是再反射前后，这个 String 对象发生了变化， 也就是说，通过反射是可以修改所谓的“不可变”对象的。但是一般我们不这么做。</p><p>这个反射的实例还可以说明一个问题：<strong>如果一个对象，他组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final 的，但是这个Wheel对象内部的状态可以改变， 那么就不能很好的保证Car对象不可变。</strong></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521" target="_blank" rel="noopener">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于java字符串不可变特性的深入理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Integer拆箱和装箱</title>
    <link href="http://yoursite.com/2019/01/23/java-basic/Integer%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1/"/>
    <id>http://yoursite.com/2019/01/23/java-basic/Integer拆箱和装箱/</id>
    <published>2019-01-23T08:30:12.150Z</published>
    <updated>2019-01-23T08:31:46.994Z</updated>
    
    <content type="html"><![CDATA[<p>由于笔试经常遇到，所以这里整理一下。将Integer这一块一网打尽。</p><a id="more"></a><h2>拆箱和装箱</h2><p>这里以面试笔试经常出现的<code>Integer</code>类型为例，请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*第一组*/</span></span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    Integer i2 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i == i2);</span><br><span class="line"></span><br><span class="line">    Integer i3 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    Integer i4 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第二组*/</span></span><br><span class="line">    Integer i5 = <span class="number">128</span>;</span><br><span class="line">    Integer i6 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i5 == i6);</span><br><span class="line"></span><br><span class="line">    Integer i7 = <span class="number">127</span>;</span><br><span class="line">    Integer i8 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i7 == i8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第三组*/</span></span><br><span class="line">    Integer i9 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">int</span> i10 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i9 == i10);</span><br><span class="line"></span><br><span class="line">    Integer i11 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    <span class="keyword">int</span> i12 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i11== i12);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第四组*/</span></span><br><span class="line">    Integer i13 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    Integer i14 = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">    System.out.println(i13 == i14);</span><br><span class="line"></span><br><span class="line">    Integer i15 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    Integer i16 = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">    System.out.println(i13 == i14);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第五组*/</span></span><br><span class="line">    Integer i17 = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">    Integer i18 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i17 == i18);</span><br><span class="line"></span><br><span class="line">    Integer i19 = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">    Integer i20 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i19 == i20);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>翻开源码(jdk8)，我们可以看到一个私有的静态类，叫做整形缓存。顾名思义，就是缓存某些整型值，我们可以看到，它默认将-127-128之间数字封装成对象，放进一个常量池中，以后定义类似于<code>Integer a = 1</code>里面的<code>a</code>就可以直接从这个常量池中取对象即可，不需要重新<code>new</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Integer.valueOf()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，也是先看看是不是在-127到128之间的范围，是的话就从 <code>cache</code> 中取出相应的 <code>Integer</code> 对象即可。</p><ul><li>第一组中<ul><li>第一种情况，<code>i</code> 是创建的一个<code>Integer</code>的对象，取值是128。<code>i2</code> 是进行自动装箱的实例，因为这里超出了-128到127的范围，所以是创建了新的<code>Integer</code>对象。由于<code>==</code>比较的是地址，所以两者必然不一样。</li><li>第二种情况就不一样了，<code>i4</code>是不需要自己<code>new</code>，而是可以直接从缓存中取，但是<code>i3</code>是<code>new</code>出来的，地址还是不一样。</li></ul></li><li>第二组中<ul><li>第一种情况是都超出范围了，所以都要自己分别去<code>new</code>，所以不一样</li><li>第二种情况是在范围内，都去缓存中取，实际上都指向同一个对象，所以一样</li></ul></li><li>第三组中<ul><li><code>i10</code>和<code>i12</code>都是<code>int</code>型，<code>i9</code>和<code>i11</code>与它们比较的时候都要自动拆箱，所以比较的是数值，所以都一样</li></ul></li><li>第四组中<ul><li>与第一组原理一样</li></ul></li><li>四五组中<ul><li>与第二组原理一样</li></ul></li></ul><p>所以啊，<code>new Integer()</code>是每次都直接<code>new</code>对象出来，而<code>Integer.valueOf()</code>可能会用到缓存，所以后者效率高一点。</p><h2>总结</h2><ul><li><code>int</code> 和 <code>Integer</code> 在进行比较的时候， <code>Integer</code> 会进行拆箱，转为 <code>int 值与</code>int` 进行比较。</li><li><code>Integer</code> 与 <code>Integer</code> 比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是 <code>-128&lt;= x&lt;=127</code> 的整数，将会直接缓存在 <code>IntegerCache</code> 中，那么当赋值在这个区间的时候，不会创建新的 <code>Integer</code> 对象，而是从缓存中获取已经创建好的 <code>Integer</code> 对象。二：当大于这个范围的时候，直接 <code>new Integer</code> 来创建 <code>Integer</code> 对象。</li><li><code>new Integer(1)</code> 和 <code>Integer a = 1</code> 不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从 <code>IntegerCache</code> 中获取的。那么 <code>Integer a = 128</code>, 大于该范围的话才会直接通过 <code>new Integer(128)</code>创建对象，进行装箱。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于笔试经常遇到，所以这里整理一下。将Integer这一块一网打尽。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务解决方案思考</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/10分布式事务解决方案思考/</id>
    <published>2019-01-23T07:14:45.099Z</published>
    <updated>2019-01-23T07:15:50.428Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，最头疼的就是分布式事务问题，处理起来一定要小心翼翼。由于没有此方面实战，本文就从理论上看看比较好的分布式事务处理方案。</p><a id="more"></a><h2>什么是分布式事务</h2><p>众所周知，数据库能实现本地事务，也就是在同一个数据库中，你可以允许一组操作要么全都正确执行，要么全都不执行。这里特别强调了<strong>本地事务</strong>，也就是目前的数据库只能支持同一个数据库中的事务。但现在的系统往往采用微服务架构，业务系统拥有独立的数据库，因此就出现了<strong>跨多个数据库的事务需求</strong>，这种事务即为“分布式事务”。那么在目前数据库不支持跨库事务的情况下，我们应该如何实现分布式事务呢？</p><p>比如用户下单过程。当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：</p><ul><li>用户通过商品系统浏览商品，他看中了某一项商品，便点击下单</li><li>此时订单系统会生成一条订单</li><li>订单创建成功后，支付系统提供支付功能</li><li>当支付完成后，由积分系统为该用户增加积分</li></ul><p>上述步骤2、3、4需要在一个事务中完成。对于传统单体应用而言，实现事务非常简单，只需将这三个步骤放在一个方法A中，再用Spring的<code>@Transactional</code>注解标识该方法即可。Spring通过数据库的事务支持，保证这些步骤要么全都执行完成，要么全都不执行。但在这个微服务架构中，这三个步骤涉及三个系统，涉及三个数据库，此时我们必须在数据库和应用系统之间，通过某项黑科技，实现分布式事务的支持。</p><h2>方案1：基于可靠消息服务的分布式事务</h2><p><img src="http://bloghello.oursnail.cn/mama11-1.png" alt="image"></p><ul><li>在系统A处理任务A前，首先向消息中间件发送一条消息</li><li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li><li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li><li>系统A收到确认应答后，则可以开始处理任务A；</li><li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。<br>但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li><li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li><li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li></ul><p>上述过程中，如果任务A处理失败，那么需要进入回滚流程:</p><ul><li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li><li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li></ul><p>上面所介绍的<code>Commit</code>和<code>Rollback</code>都属于理想情况，但在实际系统中，<code>Commit</code>和<code>Rollback</code>指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是超时询问机制。</p><p>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的<code>Commit</code>或<code>Rollback</code>指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p><ul><li>提交  若获得的状态是“提交”，则将该消息投递给系统B。</li><li>回滚  若获得的状态是“回滚”，则直接将条消息丢弃。</li><li>处理中  若获得的状态是“处理中”，则继续等待。</li></ul><p>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p><p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。</p><p>注意，这个方案需要消息队列具有事务消息的能力，阿里的<code>RocketMQ</code>可以实现这个目标。其他的MQ还不行。</p><h2>方案2：最大努力通知（定期校对）</h2><p><img src="http://bloghello.oursnail.cn/mama11-2.png" alt="image"></p><ul><li>上游系统在完成任务后，向消息中间件同步地发送一条消息，确保消息中间件成功持久化这条消息，然后上游系统可以去做别的事情了；</li><li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；</li><li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</li></ul><p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p><ul><li>消息中间件向下游系统投递消息失败</li><li>上游系统向消息中间件发送消息失败</li></ul><p>对于第一种情况，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，<strong>如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“定期校对”</strong>。</p><p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p><p>对于第二种情况，需要在上游系统中建立消息重发机制。<strong>可以在上游系统建立一张本地消息表，并将 任务处理过程 和 向本地消息表中插入消息 这两个步骤放在一个本地事务中完成</strong>。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。</p><p>如果这两步都执行成功，那么该本地事务就完成了。<strong>接下来会有一个专门的消息发送者不断地发送本地消息表中的消息</strong>，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p><p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过重试机制+定期校对实现分布式事务，但相比于第一种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p><p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。还有其他的一些解决思路，这里就暂时只描述这些。后续再学习。</p><p>参考自：<a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">https://juejin.im/post/5aa3c7736fb9a028bb189bca</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式系统中，最头疼的就是分布式事务问题，处理起来一定要小心翼翼。由于没有此方面实战，本文就从理论上看看比较好的分布式事务处理方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>库存扣减问题</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/09库存扣减问题/</id>
    <published>2019-01-23T07:09:02.844Z</published>
    <updated>2019-01-23T07:10:26.873Z</updated>
    
    <content type="html"><![CDATA[<p>库存扣减问题一直是秒杀中最关键的一个点。如果把控不好，扣成负数，那可就麻烦了，如么如何保证不会出现超卖还能保证性能呢？</p><a id="more"></a><h2>一、扣减库存问题分析</h2><p>在提交订单的时候，要扣减库存，对于sql，是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>首先这条sql存在超卖问题，很有可能会减成负数。可能会改成如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span> <span class="keyword">and</span> stock &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样好像解决了超卖问题。但是引入了新的问题。由于库存牵涉进货、补货等系统，所以是个独立的服务。</p><p>并且，比如我是通过MQ去通知库存进行扣减库存，但是由于网络抖动，请求扣减库存没有结果，这个时候可能需要进行重试。重试之后，可能成功了，这个时候，有可能这两次都成功了。那么，一个用户买一样东西，但是库存扣了两遍。这就是幂等。如果不做幂等处理，重试会出现上述这种致命问题。</p><p>那么如何做到幂等呢？</p><p>实际上就是追求数据一致性。那么就可以考虑锁来保证，比如我这里用乐观锁来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> stock,<span class="keyword">version</span> <span class="keyword">from</span> t_stock;</span><br><span class="line">if(stock &gt; 用户购买数量)</span><br><span class="line">    <span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span> = last_version</span><br></pre></td></tr></table></figure><p>但是，一旦出现并发，那么可能这个用户是执行update失败的，所以还需要去重试(guava retry或者spring retry都可以优雅地实现重试)，直到成功或者库存已经不足。</p><p>那么，在少量并发的情况下，可以考虑乐观锁，要不然会大量失败，此时需要用悲观锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_stock <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">下面执行<span class="keyword">update</span>操作。。。</span><br></pre></td></tr></table></figure><p>在一个事务内，第一句为<code>select for update</code>，那么这一行数据就会被本线程锁住，整个事务执行完才能允许其他线程进来。</p><p>存在的问题：一个线程锁住这行数据，那么其他线程都要等待，效率很低。</p><p>那么，如何保证数据一致性，还可以提高效率呢？</p><p>对于扣减库存，往往是先在redis中进行扣减库存。redis是单线程，是高速串行执行，不存在并发问题。</p><p>如果是单机redis，可以在同一个事务中保证一次性执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch stock</span><br><span class="line">multi</span><br><span class="line">if stock &gt; count</span><br><span class="line">    stock = stock - count;</span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/mama8-1.png" alt="image"></p><p>但是不能在集群中用（分布在不同节点上时），所以用watch不通用。</p><p>redis都是原子操作，比如自增:incrby，用这个就可以判断库存是否够。就是所谓的redis预减库存。</p><p>但是在实际中，库存表里有两个字段：库存和锁定库存。</p><p>锁定库存是表示多少用户真正下单了，但是还没有支付。锁定库存+库存=总库存，等用户真正支付之后，就可以将锁定库存减掉。那么，此时，redis中需要存库存和锁定库存这两个值，上面单一的原子操作就不行了。</p><p>解决方案：redis+lua</p><p>为什么要用lua呢？可以用lua将一系列操作封装起来执行，输入自己的参数即可。lua脚本在redis中执行是串行的、原子性的。</p><p>OK，下面就实战一波：根据skuId查询缓存中的库存值。</p><h2>二、查询库存（设置库存）</h2><p>首先，我们要明确一点，redis中的库存初始值是由后台的系统人工提前配置好的，在进行商品销售时（用户下单时），直接从redis中先进行库存的扣减。</p><p>这里呢，我们没有进行初始化，而是在程序中进行判断：如果redis已经有了这个库存值，就将他查询出来返回；否则，就去数据库查询，然后对redis进行初始化。</p><p>这里的一个问题是：如果存在并发问题，但是我们初始化两个值（库存值和库存锁定值），这里采用lua脚本，在lua脚本中完成初始化，并且对于两个用户同时进行初始化库存的问题，可以在lua中进行判断,因为redis是单线程，lua也是单线程，不用担心会同时初始化两次。</p><p>下面首先写一个接口，根据skuid查询库存(库存和锁定库存)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/query/&#123;skuId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult&lt;Stock&gt; <span class="title">queryStock</span><span class="params">(@PathVariable <span class="keyword">long</span> skuId)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;Stock&gt;  result = <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"库存查询成功"</span>);</span><br><span class="line">    Stock stock = <span class="keyword">new</span> Stock();</span><br><span class="line">    stock.setSkuId(skuId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stockCount = stockService.queryStock(skuId);</span><br><span class="line"></span><br><span class="line">    stock.setStock(stockCount);</span><br><span class="line">    result.setData(stock);</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queryStock</span><span class="params">(<span class="keyword">long</span> skuId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先查redis</span></span><br><span class="line">    Stock stock ;</span><br><span class="line">    String stockKey = Constants.CACHE_PRODUCT_STOCK+<span class="string">":"</span>+skuId;</span><br><span class="line">    String stockLockKey = Constants.CACHE_PRODUCT_STOCK_LOCK+<span class="string">":"</span>+skuId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只需要查询一个即可，比如我这里只查询库存就行</span></span><br><span class="line">    Object stockObj = redisTemplate.opsForValue().get(stockKey);</span><br><span class="line">    Integer stockInRedis = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">if</span>(stockObj!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stockInRedis = Integer.valueOf(stockObj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有，那么我就需要将数据库中的数据初始化到redis中</span></span><br><span class="line">    <span class="keyword">if</span>(stockInRedis==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//去数据库查询 然后对redis进行初始化</span></span><br><span class="line">        stock = stockMapper.selectBySkuId(skuId);</span><br><span class="line">        <span class="comment">//两个key和两个库存值通过lua脚本塞到redis中</span></span><br><span class="line">        <span class="comment">//这里如果发生两个用户并发初始化redis，脚本中会进行判断，如果已经初始化了，脚本就会停止执行</span></span><br><span class="line">        <span class="comment">// 设置库存不应该在这配置，应该是后台管理系统进行设置，所以正常情况下，这里redis中应该是必然存在的</span></span><br><span class="line">        <span class="comment">//如果是在后台配置，就没有必要这么复杂了</span></span><br><span class="line">        redisUtils.skuStockInit(stockKey,stockLockKey,stock.getStock().toString(),stock.getLockStock().toString());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockInRedis;<span class="comment">//缓存中有就直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存结果可能会返回设置不成功，所以还是返回数据库查询结果</span></span><br><span class="line">    <span class="keyword">return</span> stock.getStock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个工具类为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看redis是否已经初始化好库存初始值，没有就初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_CACHE_LUA =</span><br><span class="line">        <span class="string">"local stock = KEYS[1] "</span> +</span><br><span class="line">                <span class="string">"local stock_lock = KEYS[2] "</span> +</span><br><span class="line">                <span class="string">"local stock_val = tonumber(ARGV[1]) "</span> +</span><br><span class="line">                <span class="string">"local stock_lock_val = tonumber(ARGV[2]) "</span> +</span><br><span class="line">                <span class="string">"local is_exists = redis.call(\"EXISTS\", stock) "</span> +</span><br><span class="line">                <span class="string">"if is_exists == 1  then "</span> +</span><br><span class="line">                <span class="string">"   return 0 "</span> +</span><br><span class="line">                <span class="string">"else  "</span> +</span><br><span class="line">                <span class="string">"   redis.call(\"SET\", stock, stock_val) "</span> +</span><br><span class="line">                <span class="string">"   redis.call(\"SET\", stock_lock, stock_lock_val) "</span> +</span><br><span class="line">                <span class="string">"   return 1 "</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 缓存sku库存 以及锁定库存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">skuStockInit</span><span class="params">(String stockKey,String stockLockKey,String stock,String stockLock)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用jedis去执行lua脚本 输入的参数要注意顺序 都是写死的 第一组是key，第二组是stock</span></span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(STOCK_CACHE_LUA, Collections.unmodifiableList(Arrays.asList(stockKey,stockLockKey))</span><br><span class="line">                ,Collections.unmodifiableList(Arrays.asList(stock, stockLock)));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (EXCUTE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于lua脚本进行稍微的解释一下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//第一组数据是key数组；第二组数据是args数组，是与key数组对应的值，就是库存</span><br><span class="line">//我们这里第一组为[stockKey,stockLockKey],就是存在redis中的名字，这里是在service层中定义好了</span><br><span class="line">//第二组为[<span class="number">50</span>,<span class="number">0</span>]，这个值就是可以从数据库表t_stock中查询出来的</span><br><span class="line">//因为执行这段lua脚本的话，说明redis中没有缓存的数据，所以需要先查询数据库，然后将缓存设置好</span><br><span class="line">//lua中定义变量用<span class="keyword">local</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> stock = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> stock_lock = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> stock_val = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> stock_lock_val = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">//再查询一遍缓存是否存在，防止两个线程同时进来设置缓存</span><br><span class="line">//存在就不用设置缓存了，否则就设置缓存</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> is_exists = redis.call(<span class="string">"EXISTS"</span>, stock)</span><br><span class="line"><span class="keyword">if</span> is_exists == <span class="number">1</span>  <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">"SET"</span>, stock, stock_val)</span><br><span class="line">    redis.call(<span class="string">"SET"</span>, stock_lock, stock_lock_val)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那么，启动工程<code>mama-buy-stock</code>：假如我去查询skuId=1的商品：</p><p><img src="http://bloghello.oursnail.cn/mama8-2.png" alt="image"></p><p>第一次库存不存在，那么就会去查询数据库：</p><p><img src="http://bloghello.oursnail.cn/mama8-3.png" alt="image"></p><p>我们再来看看redis中的数据：</p><p><img src="http://bloghello.oursnail.cn/mama8-4.png" alt="image"></p><h2>三、扣减库存</h2><p>下面来看看扣减库存是如何实现的。因为提交订单后，往往是不止一件商品的，往往购物车内有很多件商品，同时过来，假设有五件商品，但是其中只有一件暂时没有库存了，那么我还是希望其他的四件商品能够卖出去，只是没有库存的商品就不算钱了。所以扣减库存用一个map来装，即<code>Map&lt;skuId,count&gt;</code></p><p>controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/reduce"</span>)</span><br><span class="line"><span class="keyword">public</span> ApiResult&lt;Map&lt;Long,Integer&gt;&gt; reduceStock(<span class="meta">@RequestBody</span> List&lt;StockReduce&gt; stockReduceList)&#123;</span><br><span class="line">    ApiResult result = <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"库存扣减成功"</span>);</span><br><span class="line">    Map&lt;Long,Integer&gt; resultMap =  stockService.reduceStock(stockReduceList);</span><br><span class="line">    result.setData(resultMap);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Long, Integer&gt; <span class="title">reduceStock</span><span class="params">(List&lt;StockReduce&gt; stockReduceList)</span> </span>&#123;</span><br><span class="line">    Map&lt;Long, Integer&gt; resultMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历去减redis中库存，增加锁定库存</span></span><br><span class="line">    stockReduceList.stream().forEach(param -&gt; &#123;</span><br><span class="line">        String stockKey = Constants.CACHE_PRODUCT_STOCK+<span class="string">":"</span>+param.getSkuId();</span><br><span class="line">        String stockLockKey = Constants.CACHE_PRODUCT_STOCK_LOCK+<span class="string">":"</span>+param.getSkuId();</span><br><span class="line">        Object result = redisUtils.reduceStock(stockKey,</span><br><span class="line">                                               stockLockKey,</span><br><span class="line">                                               param.getReduceCount().toString(),<span class="comment">//incrby一个负数，就是减</span></span><br><span class="line">                                               String.valueOf(Math.abs(param.getReduceCount())));<span class="comment">//incrby一个正数，就是加</span></span><br><span class="line">        <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Long)&#123;</span><br><span class="line">            <span class="comment">//库存不存在或者不足 扣减失败 sku下单失败 记录下来</span></span><br><span class="line">            resultMap.put(param.getSkuId(),-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> List)&#123;</span><br><span class="line">            <span class="comment">//扣减成功 记录扣减流水</span></span><br><span class="line">            List resultList =  ((List) result);</span><br><span class="line">            <span class="keyword">int</span> stockAftChange =  ((Long)resultList.get(<span class="number">0</span>)).intValue();</span><br><span class="line">            <span class="keyword">int</span> stockLockAftChange = ((Long) resultList.get(<span class="number">1</span>)).intValue();</span><br><span class="line">            StockFlow stockFlow = <span class="keyword">new</span> StockFlow();</span><br><span class="line">            stockFlow.setOrderNo(param.getOrderNo());</span><br><span class="line">            stockFlow.setSkuId(param.getSkuId());</span><br><span class="line">            stockFlow.setLockStockAfter(stockLockAftChange);</span><br><span class="line">            stockFlow.setLockStockBefore(stockLockAftChange+param.getReduceCount());</span><br><span class="line">            stockFlow.setLockStockChange(Math.abs(param.getReduceCount()));</span><br><span class="line">            stockFlow.setStockAfter(stockAftChange);</span><br><span class="line">            stockFlow.setStockBefore(stockAftChange+Math.abs(param.getReduceCount()));</span><br><span class="line">            stockFlow.setStockChange(param.getReduceCount());</span><br><span class="line">            stockFlowMapper.insertSelective(stockFlow);</span><br><span class="line">            resultMap.put(param.getSkuId(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于redis的操作，基本与上一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>   扣减库存lua脚本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> 0  key不存在 错误   -1 库存不足  返回list  扣减成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_REDUCE_LUA=</span><br><span class="line">        <span class="string">"local stock = KEYS[1]\n"</span> +</span><br><span class="line">                <span class="string">"local stock_lock = KEYS[2]\n"</span> +</span><br><span class="line">                <span class="string">"local stock_change = tonumber(ARGV[1])\n"</span> +</span><br><span class="line">                <span class="string">"local stock_lock_change = tonumber(ARGV[2])\n"</span> +</span><br><span class="line">                <span class="string">"local is_exists = redis.call(\"EXISTS\", stock)\n"</span> +</span><br><span class="line">                <span class="string">"if is_exists == 1 then\n"</span> +</span><br><span class="line">                <span class="string">"    local stockAftChange = redis.call(\"INCRBY\", stock,stock_change)\n"</span> +</span><br><span class="line">                <span class="string">"    if(stockAftChange&lt;0) then\n"</span> +</span><br><span class="line">                <span class="string">"        redis.call(\"DECRBY\", stock,stock_change)\n"</span> +</span><br><span class="line">                <span class="string">"        return -1\n"</span> +</span><br><span class="line">                <span class="string">"    else \n"</span> +</span><br><span class="line">                <span class="string">"        local stockLockAftChange = redis.call(\"INCRBY\", stock_lock,stock_lock_change)\n"</span> +</span><br><span class="line">                <span class="string">"        return &#123;stockAftChange,stockLockAftChange&#125;\n"</span> +</span><br><span class="line">                <span class="string">"    end "</span> +</span><br><span class="line">                <span class="string">"else \n"</span> +</span><br><span class="line">                <span class="string">"    return 0\n"</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reduceStock</span><span class="params">(String stockKey,String stockLockKey,String stockChange,String stockLockChange)</span></span>&#123;</span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(STOCK_REDUCE_LUA, Collections.unmodifiableList(Arrays.asList(stockKey,stockLockKey))</span><br><span class="line">                ,Collections.unmodifiableList(Arrays.asList(stockChange, stockLockChange)));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，一旦数据库发生异常，那么就会回滚，但是redis中是无法回滚的。这个问题不用担心，因为数据库发生异常是及其严重的问题，是很少会发生的，一旦发生，只需要去这个流水的表中去查看情况，然后去执行脚本去初始化这个redis即可。所以是可以补救的。</p><p>但是接口的幂等性还没有做。重复尝试调用这个接口（通常是发生在MQ的失败重传机制，客户端的连续点击一般是可以避免的），可能会重复减redis库存并且重复地去插入流水记录。这个问题该如何解决呢？</p><h2>四、redis分布式锁来实现幂等性</h2><p>主流的方案，比如有用一张表来控制，比如以这个orderID为唯一主键，一旦插入成功，就可以根据这个唯一主键的存在与否判断是否为重复请求（也就是说，这里的扣减库存和插入去重表放在一个事务里，去重表中有一个字段为orderId，全局唯一不重复，用唯一索引进行约束，那么插入的时候判断这个去重表是否可以插入成功，如果不成功，那么数据库操作全部回滚）。</p><p>可以用redis分布式锁给这个订单上锁。以订单id为锁，不会影响其他线程来扣减库存，所以不影响性能。</p><p>针对这个订单，第一次肯定是可以去扣减库存的，但是第二次再接收到这个请求，那么就要返回已经成功了，不要再重复扣减。</p><p>对于<code>reduceStock()</code>这个方法最前面增加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止扣减库存时MQ正常重试时的不幂等</span></span><br><span class="line"><span class="comment">//以订单ID 加个缓存锁 防止程序短时间重试 重复扣减库存 不用解锁 自己超时</span></span><br><span class="line">Long orderNo = stockReduceList.get(<span class="number">0</span>).getOrderNo();</span><br><span class="line"><span class="keyword">boolean</span> lockResult = redisUtils.distributeLock(Constants.ORDER_RETRY_LOCK+orderNo.toString(),orderNo.toString(),<span class="number">300000</span>);</span><br><span class="line"><span class="keyword">if</span>(!lockResult)&#123;</span><br><span class="line">    <span class="comment">//锁定失败 重复提交 返回一个空map</span></span><br><span class="line">    <span class="keyword">return</span>  Collections.EMPTY_MAP;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long EXCUTE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**lua脚本  在redis中 lua脚本执行是串行的 原子的 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNLOCK_LUA=</span><br><span class="line">        <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> +</span><br><span class="line">                <span class="string">"   return redis.call('del', KEYS[1]) "</span> +</span><br><span class="line">                <span class="string">"else "</span> +</span><br><span class="line">                <span class="string">"   return 0 "</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 获取分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">distributeLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span></span>&#123;</span><br><span class="line">    String result = redisTemplate.execute((RedisCallback&lt;String&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        JedisCommands commands = (JedisCommands)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> commands.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);<span class="comment">//一条命令实现setnx和setexpire这些操作，原子性</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 释放分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseDistributelock</span><span class="params">(String lockKey, String requestId)</span></span>&#123;</span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(UNLOCK_LUA, Collections.singletonList(lockKey), Collections.singletonList(requestId));<span class="comment">//lua脚本中原子性实现：get查询和delete删除这两个操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (EXCUTE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里不需要我们主动去释放分布式锁，只要设置一个大于重试时间的过期时间即可。让它自己删除。</p><p>注意redis在集群下做分布式锁，最好要用Redission。这里如果用于集群，如何lua脚本在一个事务里同时操作多个key的时候，如果要保证这个事务生效，就需要保证这几个key都要在同一个节点上。但是，比如我们这里的两个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK = <span class="string">"product:stock"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK_LOCK = <span class="string">"product:stock:lock"</span>;</span><br></pre></td></tr></table></figure><p>因为我们这里要同时对库存和锁定库存这两个key进行操作，需要放在一个事务内执行，不处理的话，一旦他们不在一个节点，那么事务就不会生效，解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK = <span class="string">"&#123;product:stock&#125;"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK_LOCK = <span class="string">"&#123;product:stock&#125;:lock"</span>;</span><br></pre></td></tr></table></figure><p>如果加上花括号，那么在进行计算hash值的时候，他们两就会是一样的，会被投放到同一个slot中，自然就保证了在同一个节点上。</p><h2>五、测试一下</h2><p><img src="http://bloghello.oursnail.cn/mama8-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mama8-5.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mama8-7.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;库存扣减问题一直是秒杀中最关键的一个点。如果把控不好，扣成负数，那可就麻烦了，如么如何保证不会出现超卖还能保证性能呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>ELK平台搭建</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/08ELK平台搭建/</id>
    <published>2019-01-23T07:02:24.093Z</published>
    <updated>2019-01-23T07:04:59.931Z</updated>
    
    <content type="html"><![CDATA[<p>因为要完成产品的全文搜索这个功能，所以需要准备一下ES的环境。本节安装ELK。</p><p>ELK由Elasticsearch、Logstash和Kibana三部分组件组成。</p><a id="more"></a><h2>前言</h2><p><img src="http://bloghello.oursnail.cn/mama6-2.png" alt="image"></p><p><code>Elasticsearch</code>是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，<code>restful</code>风格接口，多数据源，自动搜索负载等。<br>简单来说，他是个全文搜索引擎，可以快速地储存、搜索和分析海量数据。</p><p><code>Logstash</code>是一个完全开源的工具，它可以把分散的、多样化的日志日志，或者是其他数据源的数据信息进行收集、分析、处理，并将其存储供以后使用。</p><p><code>Kibana</code>是一个开源的分析和可视化平台，设计用于和<code>Elasticsearch</code>一起工作。</p><p>你用<code>Kibana</code>来搜索，查看，并和存储在<code>Elasticsearch</code>索引中的数据进行交互。</p><p>你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。</p><p><code>Kibana</code>使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示<code>Elasticsearch</code>查询的变化。</p><h2>一、安装ES</h2><h3>1.1 首先是安装JDK：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line"></span><br><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;</span><br><span class="line"></span><br><span class="line">tar xzf jdk-8u141-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h3>1.2 添加环境变量：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">JAVA_HOME=/opt/jdk1.8.0_141</span><br><span class="line">JAVA_JRE=$JAVA_HOME/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h3>1.3 下载6.2.4版本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.tar.gz</span><br><span class="line">tar -xzvf elasticsearch-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf elasticsearch-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line">mv elasticsearch-6.2.4 elasticsearch</span><br></pre></td></tr></table></figure><h3>1.4 配置sysctl.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#修改sysctl配置</span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"> </span><br><span class="line">#添加如下配置</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"> </span><br><span class="line">#让配置生效</span><br><span class="line">sysctl -p</span><br><span class="line"> </span><br><span class="line">#查看配置的数目</span><br><span class="line">sysctl -a|grep vm.max_map_count</span><br></pre></td></tr></table></figure><h3>1.5 elasticsearch从5.0版本之后不允许root账户启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#添加用户</span><br><span class="line">adduser dev</span><br><span class="line"> </span><br><span class="line">#设定密码</span><br><span class="line">passwd dev</span><br><span class="line"> </span><br><span class="line">#添加权限</span><br><span class="line">chown -R dev /opt/elasticsearch</span><br><span class="line"> </span><br><span class="line">#切换用户</span><br><span class="line">su dev</span><br><span class="line"> </span><br><span class="line">#查看当前用户</span><br><span class="line">who am i</span><br><span class="line"> </span><br><span class="line">#启动</span><br><span class="line">./elasticsearch/bin/elasticsearch</span><br><span class="line"> </span><br><span class="line">#后台启动</span><br><span class="line">./elasticsearch/bin/elasticsearch -d</span><br></pre></td></tr></table></figure><h3>1.6 配置limits.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line"> </span><br><span class="line">把</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"> </span><br><span class="line">改为</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line"> </span><br><span class="line">#切换用户</span><br><span class="line">su dev</span><br><span class="line"> </span><br><span class="line">#查看配置是否生效</span><br><span class="line">ulimit -Hn</span><br></pre></td></tr></table></figure><h3>1.7 配置所有用户访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><h3>1.8 添加一下内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><h3>1.9 重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep elastic</span><br><span class="line">kill -9 xxxx</span><br></pre></td></tr></table></figure><h3>1.10 测试：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200/</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;MmiaBfA&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;zjX-q5PDRLyrWMy5TiBDkw&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.2.4&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;ccec39f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2018-04-12T20:37:28.497551Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;7.2.1&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就说明成功了。</p><h2>二、安装Kibana 6.2.4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">mv kibana-6.2.4-linux-x86_64 kibana</span><br><span class="line"></span><br><span class="line">vim /opt/kibana/config/kibana.yml</span><br></pre></td></tr></table></figure><h3>2.1 添加以下内容：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.url: &quot;http://127.0.0.1:9200&quot;</span><br></pre></td></tr></table></figure><h3>2.2 切换到bin目录下，启动即可。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#不能关闭终端</span><br><span class="line">./kibana  </span><br><span class="line"></span><br><span class="line">#可关闭终端</span><br><span class="line">nohup ./kibana &amp;</span><br></pre></td></tr></table></figure><h3>2.3 开放防火墙和安全组对应的这个端口</h3><p>浏览器访问：<a href="http://106.14.163.235:5601" target="_blank" rel="noopener">http://106.14.163.235:5601</a> 看到一个控制台页面就成功啦。</p><p><img src="http://bloghello.oursnail.cn/mama6-1.png" alt="image"></p><h3>2.4 关闭这个进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ps -ef|grep kibana</span><br><span class="line"> </span><br><span class="line">ps -ef|grep 5601</span><br><span class="line"> </span><br><span class="line">都找不到 </span><br><span class="line"> </span><br><span class="line">尝试 使用 fuser -n tcp 5601</span><br><span class="line"> </span><br><span class="line">kill -9  端口</span><br><span class="line"> </span><br><span class="line">启动即可 ./kibana</span><br><span class="line"></span><br><span class="line">或者去这个目录下的.out日志中可以看到看到它占用的pid</span><br></pre></td></tr></table></figure><h2>三、logstash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf logstash-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line"># 重命名</span><br><span class="line">mv logstash-6.2.4.tar.gz logstash</span><br><span class="line"></span><br><span class="line"># 进入</span><br><span class="line">cd logstash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个配置文件 我这里是mysqltones.conf</span><br><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">      jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/mama-buy-trade&quot;</span><br><span class="line">      jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">      jdbc_password =&gt; &quot;root&quot;</span><br><span class="line"></span><br><span class="line">      jdbc_driver_library =&gt; &quot;/opt/logstash/mysql-connector-java-5.1.46-bin.jar&quot;</span><br><span class="line">      # the name of the driver class for mysql</span><br><span class="line">      jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">      jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">      jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line"></span><br><span class="line">      # mysql文件, 也可以直接写SQL语句在此处，如下：</span><br><span class="line">      statement =&gt; &quot;SELECT * from t_product&quot;</span><br><span class="line">      # statement_filepath =&gt; &quot;/opt/logstash/conf/jdbc.sql&quot;</span><br><span class="line"></span><br><span class="line">      # 这里类似crontab,可以定制定时操作，比如每10分钟执行一次同步(分 时 天 月 年)</span><br><span class="line">      schedule =&gt; &quot;*/10 * * * *&quot;</span><br><span class="line">      type =&gt; &quot;jdbc&quot;</span><br><span class="line"></span><br><span class="line">      # 是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中</span><br><span class="line">      record_last_run =&gt; &quot;true&quot;</span><br><span class="line"></span><br><span class="line">      # 是否需要记录某个column 的值,如果record_last_run为真,可以自定义我们需要 track 的 column 名称，此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.</span><br><span class="line">      use_column_value =&gt; &quot;true&quot;</span><br><span class="line"></span><br><span class="line">      # 如果 use_column_value 为真,需配置此参数. track 的数据库 column 名,该 column 必须是递增的. 一般是mysql主键</span><br><span class="line">      tracking_column =&gt; &quot;id&quot;</span><br><span class="line"></span><br><span class="line">      last_run_metadata_path =&gt; &quot;/opt/logstash/conf/last_id&quot;</span><br><span class="line"></span><br><span class="line">      # 是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录</span><br><span class="line">      clean_run =&gt; &quot;false&quot;</span><br><span class="line"></span><br><span class="line">      # 是否将 字段(column) 名称转小写</span><br><span class="line">      lowercase_column_names =&gt; &quot;false&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 此处我不做过滤处理</span><br><span class="line">filter &#123;&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    # 输出到elasticsearch的配置</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        index =&gt; &quot;jdbc&quot;</span><br><span class="line"></span><br><span class="line">        # 将&quot;_id&quot;的值设为mysql的autoid字段</span><br><span class="line">        document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">        template_overwrite =&gt; true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 这里输出调试，正式运行时可以注释掉</span><br><span class="line">    stdout &#123;</span><br><span class="line">        codec =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">./bin/logstash -f ./mysqltones.conf</span><br></pre></td></tr></table></figure><p>看到这个就说明成功了：</p><p><img src="http://bloghello.oursnail.cn/mama6-3.png" alt="image"></p><h2>安装mysql数据库</h2><p>这一步要在执行logstash之前搞定，我的是阿里云centos7.3版本，mysql版本是5.7，安装过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 下载MySQL源安装包: </span><br><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"></span><br><span class="line"># 安装MySQL源：</span><br><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm </span><br><span class="line"></span><br><span class="line"># 检查MySQL源安装情况： </span><br><span class="line">yum repolist enabled | grep &quot;mysql.*-community.*&quot;</span><br><span class="line"></span><br><span class="line"># 安装MySQL: </span><br><span class="line">yum install mysql-community-server</span><br><span class="line"></span><br><span class="line"># 启动MySQL: </span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"># 查看MySQL状态: </span><br><span class="line">systemctl status mysqld</span><br><span class="line"></span><br><span class="line"># 设置开机启动MySQL：</span><br><span class="line">systemctl enable mysqld </span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 查找并修改MySQL默认密码（注意密码要符合规范，否则会失败）：</span><br><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log </span><br><span class="line"></span><br><span class="line">mysql -uroot -p </span><br><span class="line"></span><br><span class="line">alter user root@localhost identified by &apos;你的新密码&apos;;</span><br><span class="line"></span><br><span class="line"># 远程连接测试添加远程账户：</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;用户&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"># 立即生效：</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># 退出MySQL：</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 最后远程将数据给导入数据库</span><br></pre></td></tr></table></figure><h2>安装分词器</h2><p><code>ik_max_word</code>是分词比较细腻的一款，我们就用它来做分词，首先需要安装一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接安装</span><br><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.4/elasticsearch-analysis-ik-6.2.4.zip</span><br><span class="line"> </span><br><span class="line"># 重新启动ES</span><br><span class="line">ps -ef | grep elastic</span><br><span class="line">kill -9 xxxx</span><br><span class="line">su dev</span><br><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><p>对这个分词器在<code>kibana</code>中进行测试：</p><p><img src="http://bloghello.oursnail.cn/mama6-5.png" alt="image"></p><p>下面结合数据库模拟一下：</p><p><img src="http://bloghello.oursnail.cn/mama6-4.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为要完成产品的全文搜索这个功能，所以需要准备一下ES的环境。本节安装ELK。&lt;/p&gt;
&lt;p&gt;ELK由Elasticsearch、Logstash和Kibana三部分组件组成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Curator</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/07Curator实现分布式锁/</id>
    <published>2019-01-23T06:57:33.756Z</published>
    <updated>2019-01-24T01:53:44.898Z</updated>
    
    <content type="html"><![CDATA[<p>从技术角度出发，注册一个网站，再高并发的时候，有可能出现用户名重复这样的问题（虽然一般情况下不会出现这种问题），如何解决呢？</p><a id="more"></a><p>从数据库角度，对于单表，我可以用<code>select .. for update</code>悲观锁实现，或者用version这种乐观锁的思想。</p><p>更好的方法是将这个字段添加唯一索引，用数据库来保证不会重复。一旦插入重复，那么就会抛出异常，程序就可以捕获到。</p><p>但是，假如我们这里分表了，以上都是针对单表，第一种方案是锁表，不行，设置唯一索引是没有用。怎么办呢？</p><p>解决方案：用ZK做一个分布式锁。</p><p>首先准备一个ZK客户端，用的是<code>Curator</code>来连接我们的ZK：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">getZkClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        CuratorFrameworkFactory.Builder builder= CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(parameters.getZkHost())</span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">        CuratorFramework framework = builder.build();</span><br><span class="line">        framework.start();</span><br><span class="line">        <span class="keyword">return</span> framework;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册用一个分布式锁来控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    InterProcessLock lock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock = <span class="keyword">new</span> InterProcessMutex(zkClient, Constants.USER_REGISTER_DISTRIBUTE_LOCK_PATH);</span><br><span class="line">        <span class="keyword">boolean</span> retry = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">3000</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                <span class="comment">//查询重复用户</span></span><br><span class="line">                User repeatedUser = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">                <span class="keyword">if</span>(repeatedUser!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> MamaBuyException(<span class="string">"用户邮箱重复"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line">                user.setNickname(<span class="string">"码码购用户"</span>+user.getEmail());</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">                <span class="comment">//跳出循环</span></span><br><span class="line">                retry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可以适当休息一会...也可以设置重复次数，不要无限循环</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (retry);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">"用户注册异常"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span>  e;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lock != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">                log.info(user.getEmail()+Thread.currentThread().getName()+<span class="string">"释放锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路非常简单，就是先尝试上锁，即<code>acquire</code>，但是有可能失败，所以这里用一个超时时间，即<code>3000ms</code>之内上不了锁就失败，进入下一次循环。最后释放锁即可。</p><p>ok，这里要来说说ZK实现分布式锁了。这里用了开源客户端<code>Curator</code>，他对于实现分布式锁进行了封装，但是，我还是想了解一下它的实现原理：</p><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>也就是说，最小的那个节点就是Leader，进来判断是不是为那个节点，是的话就可以获取到锁，反之不行。</p><blockquote><p>为什么不能通过大家一起创建节点，如果谁成功了就算获取到了锁。 多个client创建一个同名的节点，如果节点谁创建成功那么表示获取到了锁，创建失败表示没有获取到锁。</p></blockquote><p>答：使用临时顺序节点可以保证获得锁的公平性，及谁先来谁就先得到锁，这种方式是随机获取锁，会造成无序和饥饿。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从技术角度出发，注册一个网站，再高并发的时候，有可能出现用户名重复这样的问题（虽然一般情况下不会出现这种问题），如何解决呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Spring Session</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/06Spring%20Session/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/06Spring Session/</id>
    <published>2019-01-23T06:40:34.693Z</published>
    <updated>2019-01-23T06:52:48.614Z</updated>
    
    <content type="html"><![CDATA[<p>在单体应用中，我们经常用http session去管理用户信息，但是到了分布式环境下，显然是不行的，因为session对于不同的机器是隔离的，而http本身是无状态的，那么就无法判断出用户在哪一个服务器上登陆的。这个时候就需要有一个独立的地方存储用户session。spring session可以做到无代码侵入的方式实现分布式session存储。</p><a id="more"></a><p>在<code>spring boot</code>开发中，我们先注册相应<code>bean</code>并且打开相应的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span> <span class="comment">//(maxInactiveIntervalInSeconds = 604800)//session超时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpSessionStrategy <span class="title">httpSessionStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> HeaderHttpSessionStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisConnectionFactory connectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line"></span><br><span class="line">        String redisHost = parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> redisPort = Integer.valueOf(parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        connectionFactory.setTimeout(<span class="number">2000</span>);</span><br><span class="line">        connectionFactory.setHostName(redisHost);</span><br><span class="line">        connectionFactory.setPort(redisPort);</span><br><span class="line"><span class="comment">//        connectionFactory.setPassword(parameters.getRedisAuth());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，这样子其实就配置好了，一开始我也云里雾里的，这是啥玩意？</p><p>其实官网的文档中讲的是最准确的。所以还是官网看看吧！</p><p>ok，来spring session的官网(<a href="https://spring.io/projects/spring-session" target="_blank" rel="noopener">https://spring.io/projects/spring-session</a>)来看看把，我们来看看1.3.4GA版本的文档(<a href="https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest</a>).</p><p>spring session可以存在很多介质中，比如我们的数据源，比如redis，甚至是mongodb等。但是我们常用的是存在redis中，结合redis的过期机制来做。</p><p>所以其实我们只要关心如何跟redis整合，以及restful接口。</p><p>我们可以看到一开始文档就告诉我们要配置一下<code>HttpSessionStrategy</code>和存储介质。从<code>HttpSessionStrategy</code>语义就能大致看出配置的是它的策略，是基于<code>header</code>的策略。这个是什么意思，下面会提到。</p><p><img src="http://bloghello.oursnail.cn/mama4-1.png" alt="image"></p><p>那么我们就来看看文档吧！</p><p><img src="http://bloghello.oursnail.cn/mama4-2.png" alt="image"></p><p>好了，我们知道了它的基本原理，下面来看看是如何在restful接口中实现用户session的管理的：</p><p><img src="http://bloghello.oursnail.cn/mama4-3.png" alt="image"></p><p>也就是说要想在restful接口应用中用这种方式，直接告诉spring session:<code>return new HeaderHttpSessionStrategy();</code>即可。进入源码我们就会知道，它默认给这个header里面放置的一条类似于token的名字是<code>private String headerName = &quot;x-auth-token&quot;;</code>。</p><p>那么在用户登陆成功之后，到底存到是什么呢，先来看看响应数据的header里面是什么：</p><p><img src="http://bloghello.oursnail.cn/mama4-4.png" alt="image"></p><p>这一串数字正好可以跟redis中对应上，我们可以先来redis中看看到底在里面存储了啥玩意：</p><p><img src="http://bloghello.oursnail.cn/mama4-5.png" alt="image"></p><p>我们已经看到了想要看到的一串字符串，这里解释一下<code>redis</code>中存储的东西：</p><ul><li><code>spring:session</code>是默认的<code>Redis HttpSession</code>前缀（<code>redis</code>中，我们常用’:’作为分割符）</li><li>每一个<code>session</code>都会有三个相关的<code>key</code>，第一个<code>key</code>(<code>spring:session:sessions:37...</code>)最为重要，它是一个<code>HASH</code>数据结构，将内存中的<code>session</code>信息序列化到了<code>redis</code>中。如本项目中用户信息,还有一些<code>meta</code>信息，如创建时间，最后访问时间等。</li><li>另外两个key，一个是<code>spring:session:expiration</code>，还有一个是<code>spring:session:sessions:expires</code>，前者是一个SET类型，后者是一个STRING类型，可能会有读者发出这样的疑问，redis自身就有过期时间的设置方式TTL，为什么要额外添加两个key来维持session过期的特性呢？redis清除过期key的行为是一个异步行为且是一个低优先级的行为，用文档中的原话来说便是，可能会导致session不被清除。于是引入了专门的expiresKey，来专门负责session的清除，包括我们自己在使用redis时也需要关注这一点。</li></ul><p>这样子，就可以用独立的<code>redis</code>来存储用户的信息，通过前端传来的<code>header</code>里面的<code>token</code>，就可以到<code>redis</code>拿出当前登陆用户的信息了。</p><p>OK，在解决了<code>spring session</code>的问题之后，下面就可以来实现登陆啦：</p><p>controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult <span class="title">login</span><span class="params">(@RequestBody @Valid User user, HttpSession session)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;UserElement&gt; result = <span class="keyword">new</span> ApiResult&lt;&gt;(Constants.RESP_STATUS_OK,<span class="string">"登录成功"</span>);</span><br><span class="line"></span><br><span class="line">    UserElement ue= userService.login(user);</span><br><span class="line">    <span class="keyword">if</span>(ue != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(Constants.REQUEST_USER_SESSION) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            session.setAttribute(Constants.REQUEST_USER_SESSION,ue);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setData(ue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就跟以前一样，将session直接存进去就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserElement <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    UserElement ue = <span class="keyword">null</span>;</span><br><span class="line">    User userExist = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">    <span class="keyword">if</span>(userExist != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//对密码与数据库密码进行校验</span></span><br><span class="line">        <span class="keyword">boolean</span> result = passwordEncoder.matches(user.getPassword(),userExist.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"密码错误"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//校验全部通过，登陆通过</span></span><br><span class="line">            ue = <span class="keyword">new</span> UserElement();</span><br><span class="line">            ue.setUserId(userExist.getId());</span><br><span class="line">            ue.setEmail(userExist.getEmail());</span><br><span class="line">            ue.setNickname(userExist.getNickname());</span><br><span class="line">            ue.setUuid(userExist.getUuid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在单体应用中，我们经常用http session去管理用户信息，但是到了分布式环境下，显然是不行的，因为session对于不同的机器是隔离的，而http本身是无状态的，那么就无法判断出用户在哪一个服务器上登陆的。这个时候就需要有一个独立的地方存储用户session。spring session可以做到无代码侵入的方式实现分布式session存储。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID生成策略</title>
    <link href="http://yoursite.com/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/01/23/miscellany/05分布式ID生成策略/</id>
    <published>2019-01-23T06:33:29.648Z</published>
    <updated>2019-01-23T06:50:27.571Z</updated>
    
    <content type="html"><![CDATA[<p>分布式环境下如何保证ID的不重复呢？一般我们可能会想到用UUID来实现嘛。但是UUID一般可以获取当前时间的毫秒数再加点随机数，但是在高并发下仍然可能重复。最重要的是，如果我要用这种UUID来生成分表的唯一ID的话，重复不谈，这种随机的字符串对于我们的innodb存储引擎的插入效率是很低的。所以我们生成的ID如果作为主键，最好有两种特性：分布式唯一和有序。</p><a id="more"></a><p>唯一性就不用说了，有序保证了对索引字段的插入的高效性。我们来具体看看<code>ShardingJDBC</code>的分布式ID生成策略是如何保证。</p><h3>snowflake算法</h3><p><img src="http://bloghello.oursnail.cn/mama5-10.png" alt="image"></p><p><code>sharding-jdbc</code>的分布式ID采用<code>twitter</code>开源的<code>snowflake</code>算法，不需要依赖任何第三方组件，这样其扩展性和维护性得到最大的简化；但是<code>snowflake</code>算法的缺陷（<strong>强依赖时间，如果时钟回拨，就会生成重复的ID</strong>）。</p><p>雪花算法是由<code>Twitter</code>公布的分布式主键生成算法，<strong>它能够保证不同进程主键的不重复性，以及相同进程主键的有序性</strong>。</p><p><strong>在同一个进程中</strong>，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。例如MySQL的Innodb存储引擎的主键。</p><p>使用雪花算法生成的主键，二进制表示形式包含4部分，从高位到低位分表为：1bit符号位、41bit时间戳位、10bit工作进程位以及12bit序列号位。</p><p>雪花算法主键的详细结构见下图。</p><p><img src="http://bloghello.oursnail.cn/mama5-1.png" alt="image"></p><ul><li>符号位(1bit)</li></ul><p>预留的符号位，恒为零。</p><ul><li>时间戳位(41bit)</li></ul><p>41位的时间戳可以容纳的毫秒数是2的41次幂，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。通过计算可知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);</span><br></pre></td></tr></table></figure><p>结果约等于69.73年。<code>ShardingSphere</code>的雪花算法的时间纪元从2016年11月1日零点开始，可以使用到2086年，相信能满足绝大部分系统的要求。</p><ul><li>工作进程位(10bit)</li></ul><p>该标志在Java进程内是唯一的，如果是分布式应用部署应保证每个工作进程的id是不同的。该值默认为0，可通过调用静态方法<code>DefaultKeyGenerator.setWorkerId()</code>设置。</p><ul><li>序列号位(12bit)</li></ul><p>该序列是用来在同一个毫秒内生成不同的ID。如果在这个毫秒内生成的数量超过4096(2的12次幂)，那么生成器会等待到下个毫秒继续生成。</p><h2>时钟回拨</h2><p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为0，可通过调用静态方法<code>DefaultKeyGenerator.setMaxTolerateTimeDifferenceMilliseconds()</code>设置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式环境下如何保证ID的不重复呢？一般我们可能会想到用UUID来实现嘛。但是UUID一般可以获取当前时间的毫秒数再加点随机数，但是在高并发下仍然可能重复。最重要的是，如果我要用这种UUID来生成分表的唯一ID的话，重复不谈，这种随机的字符串对于我们的innodb存储引擎的插入效率是很低的。所以我们生成的ID如果作为主键，最好有两种特性：分布式唯一和有序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>springMVC全局异常+spring包扫描包隔离+spring事务传播</title>
    <link href="http://yoursite.com/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
    <id>http://yoursite.com/2019/01/22/miscellany/04springMVC全局异常+spring包扫描包隔离+spring事务传播/</id>
    <published>2019-01-22T13:16:15.370Z</published>
    <updated>2019-01-24T03:57:56.673Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，springMVC全局异常+spring包扫描包隔离+spring事务传播这三个不可能不会遇到。下面来好好说说他们吧。</p><a id="more"></a><h2>1、全局异常引入原因</h2><p>假设在我们的<code>login.do</code>的<code>controller</code>方法中第一行增加一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>重新启动服务器进行用户登录操作，那么就会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    com.swg.controller.portal.UserController.login(UserController.java:<span class="number">37</span>)</span><br><span class="line">    ...其他的堆栈信息</span><br></pre></td></tr></table></figure><p>这些信息会直接显示在网页上，如果是关于数据库的错误，同样，会详细地将数据库中的字段都显示在页面上，这对于我们的项目来说是存在很大的安全隐患的。这个时候，需要用全局异常来处理，如果发生异常，我们就对其进行拦截，并且在页面上显示我们给出的提示信息。</p><p>对于<code>SpringBoot</code>，一般全局异常是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        log.error(e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createByErrorCodeMessage(Constants.RESP_STATUS_INTERNAL_ERROR,<span class="string">"系统异常，请稍后再试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(SnailmallException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">handleException</span><span class="params">(SnailmallException e)</span></span>&#123;</span><br><span class="line">        log.error(e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createByErrorCodeMessage(e.getExceptionStatus(),e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>2、引入全局异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"exception:&#123;&#125;"</span>,httpServletRequest.getRequestURI(),e);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> MappingJacksonJsonView());</span><br><span class="line">        mv.addObject(<span class="string">"status"</span>,ResponseEnum.ERROR.getCode());</span><br><span class="line">        mv.addObject(<span class="string">"msg"</span>,<span class="string">"接口异常，详情请查看日志中的异常信息"</span>);</span><br><span class="line">        mv.addObject(<span class="string">"data"</span>,e.toString());</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，再执行登陆操作之后，就不会在页面上直接显示异常信息了。有效地屏蔽了关键信息。</p><h2>3、spring和springmvc配置文件的优化</h2><h5>3.1 包隔离优化</h5><p>在编写全局异常之前，先进行了包隔离和优化，一期中的扫描包的写法是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--springmvc:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>即<code>spring</code>和<code>springmvc</code>扫描包下面的所有的<code>bean</code>和<code>controller</code>.优化后的代码配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#spring</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将controller的扫描排除掉--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#springmvc</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg.controller"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加白名单，只扫描controller，总之要将service给排除掉即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做的原因是：<code>Spring</code>和<code>SpringMVC</code>是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题。</p><p><img src="http://bloghello.oursnail.cn/zaji4-1.png" alt="image"></p><p>针对包扫描只要记住以下几点即可：</p><ul><li><code>spring</code>是父容器，<code>springmvc</code>是子容器，子容器可以访问父容器的<code>bean</code>,父容器不能访问子容器的<code>bean</code>。</li><li>只有顶级容器（<code>spring</code>）才有加强的事务能力，而<code>springmvc</code>容器的<code>service</code>是没有的。</li><li>如果<code>springmvc</code>不配置包扫描的话，页面404.</li></ul><h5>3.2 事务的传播机制</h5><p>针对事务，不得不展开说明spring事务的几种传播机制了。在 <code>spring</code> 的 <code>TransactionDefinition</code> 接口中一共定义了七种事务传播属性：</p><ol><li><code>PROPAGATION_REQUIRED</code> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择（默认）。</li><li><code>PROPAGATION_SUPPORTS</code> – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li><code>PROPAGATION_MANDATORY</code> – 支持当前事务，如果当前没有事务，就抛出异常。</li><li><code>PROPAGATION_REQUIRES_NEW</code> – 新建事务，如果当前存在事务，把当前事务挂起。</li><li><code>PROPAGATION_NOT_SUPPORTED</code> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><code>PROPAGATION_NEVER</code> – 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><code>PROPAGATION_NESTED</code> – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与<code>PROPAGATION_REQUIRED</code>类似的操作。</li></ol><h2>4、补充</h2><p><code>Spring</code>默认情况下，会对运行期例外(<code>RunTimeException</code>)，即<code>uncheck</code>异常，进行事务回滚。如果遇到<code>checked</code>异常就不回滚。如何改变默认规则：</p><ul><li>让<code>checked</code>例外也回滚：在整个方法前加上 <code>@Transactional(rollbackFor=Exception.class)</code></li><li>让<code>unchecked</code>例外不回滚： <code>@Transactional(notRollbackFor=RunTimeException.class)</code></li><li>不需要事务管理的(只查询的)方法：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li></ul><h2>5、那么什么是嵌套事务呢？</h2><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫做<code>save point</code>，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点在于那个<code>save point</code>，看以下几个问题：</p><p><strong>问题1：如果子事务回滚，会发生什么？</strong></p><p>父事务会回到进入子事务前建立的<code>save point</code>，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>问题2：如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚，为什么呢？因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理/</p><p><strong>问题3：父事务先提交，然后子事务再提交；还是子事务先提交，然后父事务再提交呢？</strong></p><p>答案是第二种情况，子事务是父事务的一部分，由父事务同意提交。</p><h2>6、spring配置文件的一些理解：</h2><blockquote><p>容器</p></blockquote><p>在<code>Spring</code>整体框架的核心概念中，容器是核心思想，就是用来管理<code>Bean</code>的整个生命周期的，而在一个项目中，容器不一定只有一个，<code>Spring</code>中可以包括多个容器，而且容器有上下层关系，目前最常见的一种场景就是在一个项目中引入<code>Spring</code>和<code>SpringMVC</code>这两个框架，那么它其实就是两个容器，<code>Spring</code>是父容器，<code>SpringMVC</code>是其子容器，并且在<code>Spring</code>父容器中注册的<code>Bean</code>对于<code>SpringMV</code>C容器中是可见的，而在<code>SpringMVC</code>容器中注册的<code>Bean</code>对于<code>Spring</code>父容器中是不可见的，也就是子容器可以看见父容器中的注册的<code>Bean</code>，反之就不行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.springmvc.test"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用统一的如下注解配置来对<code>Bean</code>进行批量注册，而不需要再给每个<code>Bean</code>单独使用<code>xml</code>的方式进行配置。</p><p>从<code>Spring</code>提供的参考手册中我们得知该配置的功能是扫描配置的<code>base-package</code>包下的所有使用了<code>@Component</code>注解的类，并且将它们自动注册到容器中，同时也扫描<code>@Controller</code>，<code>@Service</code>，<code>@Respository</code>这三个注解，因为他们是继承自<code>@Component</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。以下配置会默认声明了<code>@Required</code>、<code>@Autowired</code>、 <code>@PostConstruct</code>、<code>@PersistenceContext</code>、<code>@Resource</code>、<code>@PreDestroy</code>等注解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个是<code>SpringMVC</code>必须要配置的，因为它声明了<code>@RequestMapping</code>、<code>@RequestBody</code>、<code>@ResponseBody</code>等。并且，该配置默认加载很多的参数绑定方法，比如<code>json</code>转换解析器等。</p><h2>7、总结</h2><p>在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的<code>Bean</code>：<code>Spring</code>父容器负责所有其他非<code>@Controller</code>注解的<code>Bean</code>的注册，而<code>SpringMVC</code>只负责<code>@Controller</code>注解的<code>Bean</code>的注册，使得他们各负其责、明确边界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，springMVC全局异常+spring包扫描包隔离+spring事务传播这三个不可能不会遇到。下面来好好说说他们吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
</feed>
