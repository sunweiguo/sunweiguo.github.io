<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-21T03:22:08.451Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1.天气预报系统-简单接口调用</title>
    <link href="http://yoursite.com/2019/02/21/weather-for-spring-cloud/1.%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E7%B3%BB%E7%BB%9F-%E7%AE%80%E5%8D%95%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/21/weather-for-spring-cloud/1.天气预报系统-简单接口调用/</id>
    <published>2019-02-21T03:20:32.695Z</published>
    <updated>2019-02-21T03:22:08.451Z</updated>
    
    <content type="html"><![CDATA[<h2>一、获取天气信息</h2><p>数据来源：</p><p><a href="http://wthrcdn.etouch.cn/weather_mini?citykey=xxx" target="_blank" rel="noopener">http://wthrcdn.etouch.cn/weather_mini?citykey=xxx</a></p><p>或者</p><p><a href="http://wthrcdn.etouch.cn/weather_mini?city=xxx" target="_blank" rel="noopener">http://wthrcdn.etouch.cn/weather_mini?city=xxx</a></p><p>首先我们如何做一个查询天气的接口呢？其实特别简单，就是用<code>HttpClient</code>这个客户端来调用以上的接口，就可以拿到数据了。</p><p>我们所需要做的工作也非常少，就是封装一下数据，请求一下参数即可。</p><p>请求的数据是json，我们这里准备好数据bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherResponse</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Weather data;</span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span>  <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String aqi;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Forecast&gt; forecast;</span><br><span class="line">    <span class="keyword">private</span> String ganmao;</span><br><span class="line">    <span class="keyword">private</span> String wendu;</span><br><span class="line">    <span class="keyword">private</span> Yesterday yesterday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Forecast</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String high;</span><br><span class="line">    <span class="keyword">private</span> String fengli;</span><br><span class="line">    <span class="keyword">private</span> String low;</span><br><span class="line">    <span class="keyword">private</span> String fengxiang;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yesterday</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String high;</span><br><span class="line">    <span class="keyword">private</span> String fx;</span><br><span class="line">    <span class="keyword">private</span> String low;</span><br><span class="line">    <span class="keyword">private</span> String fl;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，数据载体已经好了，下面就是用<code>RestTemplate</code>调用<code>url</code>取获取天气信息，用上面的bean来封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherDataServiceImpl</span> <span class="keyword">implements</span> <span class="title">IWeatherDataService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统一接口前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEATHER_URI = <span class="string">"http://wthrcdn.etouch.cn/weather_mini?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeatherResponse <span class="title">getDataByCityId</span><span class="params">(String cityId)</span> </span>&#123;</span><br><span class="line">        String uri = WEATHER_URI + <span class="string">"citykey="</span>+cityId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doGetWeather(uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeatherResponse <span class="title">getDataByCityName</span><span class="params">(String cityName)</span> </span>&#123;</span><br><span class="line">        String uri = WEATHER_URI + <span class="string">"city="</span>+cityName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doGetWeather(uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据参数获取天气数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> WeatherResponse <span class="title">doGetWeather</span><span class="params">(String uri)</span></span>&#123;</span><br><span class="line">        ResponseEntity&lt;String&gt; resString = restTemplate.getForEntity(uri,String.class);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        WeatherResponse resp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String strBody = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(resString.getStatusCodeValue() == <span class="number">200</span>)&#123;</span><br><span class="line">            strBody = resString.getBody();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp = mapper.readValue(strBody,WeatherResponse.class);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再用一个controller来给一个接口即可。</p><h2>二、注意</h2><p>直接启动项目会报错：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.</span><br><span class="line">2018-11-19 15:19:54.732 ERROR 13924 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : </span><br><span class="line"></span><br><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Field restTemplate in com.swg.weatherbasic.service.impl.WeatherDataServiceImpl required a bean of type 'org.springframework.web.client.RestTemplate' that could not be found.</span><br><span class="line"></span><br><span class="line">The injection point has the following annotations:</span><br><span class="line">- @org.springframework.beans.factory.annotation.Autowired(required=true)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider defining a bean of type 'org.springframework.web.client.RestTemplate' in your configuration.</span><br></pre></td></tr></table></figure><p>我们可以看到提示信息是：<code>'org.springframework.web.client.RestTemplate' that could not be found.</code>,错误就很明显了，这个玩意根本就没有在spring中注册，怎么可以注入呢?</p><p>所以，我们需要向spring注册一下这个bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplateBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、彩蛋</h2><p>将此小项目作为一个小版本，直接保存到码云上。如何做呢？</p><p>其实很简单，先去码云上新建一个项目。然后在本地某一个文件夹下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone xxx</span><br></pre></td></tr></table></figure><p>然后将我们的项目直接拷贝到这个文件夹下。执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -am &apos;weather-basic&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>这样就可以了。</p><p>代码地址：<a href="https://github.com/sunweiguo/swgBook-for-spring-cloud/tree/master/spring-cloud-weather-action/01" target="_blank" rel="noopener">spring-cloud-weather-action----01</a></p><p>下面章节的代码依次类推，可能就不再赘述了。本项目的<code>springboot</code>版本是<code>2.1.0.RELEASE</code>，<code>spring cloud</code>用的是<code>Finchley.RELEASE</code>版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;一、获取天气信息&lt;/h2&gt;
&lt;p&gt;数据来源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wthrcdn.etouch.cn/weather_mini?citykey=xxx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wthrcdn.
      
    
    </summary>
    
    
      <category term="天气项目入门微服务" scheme="http://yoursite.com/tags/%E5%A4%A9%E6%B0%94%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>java基础之ThreadLocal自问自答</title>
    <link href="http://yoursite.com/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/"/>
    <id>http://yoursite.com/2019/02/20/java-basic/java基础之ThreadLocal自问自答/</id>
    <published>2019-02-20T12:43:11.161Z</published>
    <updated>2019-02-20T12:43:24.438Z</updated>
    
    <content type="html"><![CDATA[<p>以问答的形式加深对threadlocal的理解，做到面试的镇定自若。</p><a id="more"></a><h3>问题1：ThreadLocal了解吗？您能给我说说他的主要用途吗？</h3><p>官方定位：<code>ThreadLocal</code>类用来<strong>提供线程内部的局部变量</strong>。这种变量在多线程环境下访问（通过<code>get</code>和<code>set</code>方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。</p><p>简单归纳就是：</p><ul><li><code>ThreadLocal</code>的作用是提供线程内的局部变量</li><li>这种变量在线程的生命周期内起作用</li><li>不同的线程之间不会相互干扰</li></ul><h3>问题2：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？</h3><p>通常，如果我不去看源代码的话，我猜<code>ThreadLocal</code>是这样子设计的：每个<code>ThreadLocal</code>类都创建一个<code>Map</code>，然后用线程的ID <code>threadID</code>作为<code>Map</code>的<code>key</code>，要存储的局部变量作为<code>Map</code>的<code>value</code>，这样就能达到各个线程的值隔离的效果。这是最简单的设计方法，JDK最早期的<code>ThreadLocal</code>就是这样设计的。</p><p>但是，JDK后面优化了设计方案，现时JDK8 <code>ThreadLocal</code>的设计是：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>哈希表，这个哈希表的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>才是真正要存储的值<code>Object</code>。</p><p><img src="http://xiaozhao.oursnail.cn/iKjk3GS.png" alt="image"></p><p><strong>那么为什么不用上面个设计呢？多简单啊！</strong></p><p>如果用Map来做的话，只能是用<code>thread</code>+<code>threadlocal</code>计算出来作为<code>key</code>，毕竟我存的不一定只有一个变量。那么不用他的时候，如何清理呢？只能是手动<code>remove</code>掉，但是一方面很麻烦，另一方面代码很丑陋，最后一方面是在<code>remove</code>的时候突然出现问题，那么就可能导致内存泄漏。</p><p><strong>新的设计的好处：</strong></p><p>当<code>Thread</code>销毁之后，对应的<code>ThreadLocalMap</code>也会随之销毁，能减少内存的使用。</p><p>假设当前<code>thread</code>一直活着（比如赖在线程池中），有些无用的<code>threadlocal</code>对象怎么清理呢？</p><p><code>key</code>是一个软引用指向<code>ThreadLocal</code>实例，特性是下一次gc的时候就会被回收掉了，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>.</p><p><code>key</code>回收掉了，<code>value</code>值还在啊，这个怎么回收！！！</p><p><code>ThreadLocal</code>的<code>get</code>和<code>set</code>方法每次调用时，如果发现当前的<code>entry</code>的<code>key</code>为<code>null</code>（也就是被回收掉了），最终会调用<code>expungeStaleEntry(int staleSlot)</code>方法，该方法会把哈希表当前位置的无用数据清理掉（当然还有别的操作）。</p><p>但是最佳实践还是每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据,确保不会出现内存泄漏问题。</p><h3>问题3：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set(T value)，获取get()，删除remove()等操作。</h3><p>具体的代码就不贴了，核心代码都已经看过了。这里简单总结一下。</p><ul><li>调用<code>get()</code><ul><li>获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</li><li>判断当前的<code>ThreadLocalMap</code>是否存在,如果存在，则以当前的<code>ThreadLocal</code> 为 <code>key</code>，调用<code>ThreadLocalMap</code>中的<code>getEntry</code>方法获取对应的存储实体 <code>e</code>。找到对应的存储实体 <code>e</code>，获取存储实体 <code>e</code> 对应的 <code>value</code>值，即为我们想要的当前线程对应此<code>ThreadLocal</code>的值，返回结果值。</li><li>如果不存在，则证明此线程没有维护的<code>ThreadLocalMap</code>对象，调用<code>setInitialValue</code>方法进行初始化。返回<code>setInitialValue</code>初始化的值。</li></ul></li><li>调用<code>set(T value)</code><ul><li>获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</li><li>判断当前的<code>ThreadLocalMap</code>是否存在：</li><li>如果存在，则调用<code>map.set</code>设置此实体<code>entry</code>。</li><li>如果不存在，则调用<code>createMap</code>进行<code>ThreadLocalMap</code>对象的初始化，并将此实体<code>entry</code>作为第一个值存放至<code>ThreadLocalMap</code>中。</li></ul></li><li>调用<code>remove()</code><ul><li>获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</li><li>判断当前的<code>ThreadLocalMap</code>是否存在， 如果存在，则调用<code>map.remove</code>，以当前<code>ThreadLocal</code>为<code>key</code>删除对应的实体<code>entry</code>。</li></ul></li></ul><h3>问题4：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗?</h3><p><code>ThreadLocalMap</code>的底层实现是一个定制的自定义<code>HashMap</code>哈希表，核心组成元素有：</p><ul><li><code>Entry[] table</code>：底层哈希表 <code>table</code>,必要时需要进行扩容，底层哈希表 <code>table.length</code> 长度必须是2的n次方。</li><li><code>int size</code>：实际存储键值对元素个数 <code>entries</code></li><li><code>int threshold</code>：下一次扩容时的阈值，阈值 <code>threshold = len(table) * 2 / 3</code>。当 <code>size &gt;= threshold</code> 时，遍历<code>table</code>并删除<code>key</code>为<code>null</code>的元素，如果删除后<code>size &gt;= threshold*3/4</code>时，需要对<code>table</code>进行扩容</li></ul><p>其中<code>Entry[] table</code>哈希表存储的核心元素是<code>Entry</code>，<code>Entry</code>包含：</p><ul><li><code>ThreadLocal&lt;?&gt; k</code>：当前存储的<code>ThreadLocal</code>实例对象</li><li><code>Object value</code>：当前 <code>ThreadLocal</code> 对应储存的值<code>value</code></li></ul><p>需要注意的是，此<code>Entry</code>继承了弱引用 <code>WeakReference</code>，所以在使用<code>ThreadLocalMap</code>时，发现<code>key == null</code>，则意味着此<code>key ThreadLocal</code>不在被引用，需要将其从<code>ThreadLocalMap</code>哈希表中移除。</p><h3>问题5：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？</h3><p>参考上一篇<a href="http://fourcolor.oursnail.cn/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">文章</a>。</p><h3>问题6：ThreadLocal和synchronized的区别?</h3><p><code>ThreadLocal</code>和<code>synchronized</code>关键字都用于处理多线程并发访问变量的问题，只是二者处理问题的角度和思路不同。</p><ul><li><code>ThreadLocal</code>是一个<code>Java</code>类,通过对当前线程中的局部变量的操作来解决不同线程的变量访问的冲突问题。所以，<code>ThreadLocal</code>提供了线程安全的共享对象机制，每个线程都拥有其副本。</li><li><code>Java</code>中的<code>synchronized</code>是一个保留字，它依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。此时，被用作“锁机制”的变量时多个线程共享的。</li><li>同步机制(<code>synchronized</code>关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而<code>ThreadLocal</code>采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响.</li></ul><h3>问题7：ThreadLocal在现时有什么应用场景？</h3><p>总的来说<code>ThreadLocal</code>主要是解决2种类型的问题：</p><ul><li>解决并发问题：使用<code>ThreadLocal</code>代替<code>synchronized</code>来保证线程安全。同步机制采用了“以时间换空间”的方式，而<code>ThreadLocal</code>采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</li><li>解决数据存储问题：<code>ThreadLocal</code>为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。如一个<code>Parameter</code>对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用<code>ThreadLocal</code>解决。</li></ul><p>一般的<code>Web</code>应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程<code>ThreadLocal</code>是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，<code>ThreadLocal</code>比直接使用<code>synchronized</code>同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p><h3>总结</h3><ul><li><code>ThreadLocal</code>提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</li><li><code>ThreadLocal</code>的设计是：每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>哈希表，这个哈希表的<code>key</code>是<code>ThreadLocal</code>实例本身，<code>value</code>才是真正要存储的值<code>Object</code>。</li><li>对<code>ThreadLocal</code>的常用操作实际是对线程<code>Thread</code>中的<code>ThreadLocalMap</code>进行操作。</li><li><code>ThreadLocalMap</code>的底层实现是一个定制的自定义哈希表，<code>ThreadLocalMap</code>的阈值<code>threshold</code> = <code>底层哈希表table的长度 len * 2 / 3</code>，当实际存储元素个数<code>size</code> 大于或等于 阈值<code>threshold的 3/4</code> 时<code>size &gt;= threshold*3/4</code>，则对底层哈希表数组<code>table</code>进行扩容操作。</li><li><code>ThreadLocalMap</code>中的哈希表<code>Entry[] table</code>存储的核心元素是<code>Entry</code>，存储的<code>key</code>是<code>ThreadLocal</code>实例对象，<code>value</code>是<code>ThreadLocal</code> 对应储存的值<code>value</code>。需要注意的是，此<code>Entry</code>继承了弱引用 <code>WeakReference</code>，所以在使用<code>ThreadLocalMap</code>时，发现<code>key == null</code>，则意味着此<code>key ThreadLocal</code>不在被引用，需要将其从<code>ThreadLocalMap</code>哈希表中移除。</li><li><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收。所以，在<code>ThreadLocal</code>的<code>get()</code>,<code>set()</code>,<code>remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。如果我们不主动调用上述操作，则会导致内存泄露。</li><li>为了安全地使用<code>ThreadLocal</code>，必须要像每次使用完锁就解锁一样，在每次使用完<code>ThreadLocal</code>后都要调用<code>remove()</code>来清理无用的<code>Entry</code>。这在操作在使用线程池时尤为重要。</li><li><code>ThreadLocal</code>和<code>synchronized</code>的区别：同步机制(<code>synchronized</code>关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而<code>ThreadLocal</code>采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。</li><li><code>ThreadLocal</code>主要是解决2种类型的问题：A. 解决并发问题：使用<code>ThreadLocal</code>代替同步机制解决并发问题。B. 解决数据存储问题：如一个<code>Parameter</code>对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用<code>ThreadLocal</code>解决。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以问答的形式加深对threadlocal的理解，做到面试的镇定自若。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之ThreadLocal内存泄漏问题</title>
    <link href="http://yoursite.com/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/20/java-basic/java基础之ThreadLocal内存泄漏问题/</id>
    <published>2019-02-20T12:39:46.248Z</published>
    <updated>2019-02-20T12:39:58.818Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是面试重灾区，分为两篇来讲解其中的用法和原理。这是第二篇。</p><a id="more"></a><h2>一、前言</h2><p><code>ThreadLocal</code> 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用 <code>ThreadLocal</code>，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析 <code>ThreadLocal</code> 内存泄漏的问题:</p><ul><li><code>ThreadLocal</code> 实现原理</li><li><code>ThreadLocal</code>为什么会内存泄漏</li><li><code>ThreadLocal</code> 最佳实践</li></ul><h2>二、ThreadLocal 实现原理</h2><p>这部分内容上一篇已经详细讲解完毕，这里谨作为一个回顾或者总结吧！</p><p><img src="http://xiaozhao.oursnail.cn/iKjk3GS.png" alt="image"></p><p><code>ThreadLocal</code>的实现是这样的：每个<code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 指向 <code>ThreadLocal</code> 实例本身，<code>value</code> 指向真正需要存储的 <code>Object</code>，这个值真实保存在线程实例上的。</p><p>也就是说 <code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。值得注意的是图中的虚线，表示 <code>ThreadLocalMap</code> 是使用 <code>ThreadLocal</code> 的弱引用作为 <code>Key</code> 的，弱引用的对象在 <code>GC</code> 时会被回收。</p><p>这里一定要注意，<code>ThreadLocal</code> 本身并不存储值，它只是作为一个 <code>key</code> 来让线程从 <code>ThreadLocalMap</code> 获取 <code>value</code>。我们从<code>get</code>和<code>set</code>代码中可以看到<code>ThreadLocalMap</code>的<code>key</code>是<code>ThreadLocal</code> 实例本身。</p><p><img src="http://bloghello.oursnail.cn/javabasic14-2.png" alt="image"></p><h2>三、ThreadLocal为什么会内存泄漏</h2><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>,如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 <code>GC</code> 的时候，这个<code>ThreadLocal</code>势必会被回收，这样一来，<code>ThreadLocalMap</code>中就会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就没有办法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程再迟迟不结束的话，这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>永远无法回收，造成内存泄漏。</p><p>其实，<code>ThreadLocalMap</code>的设计中已经考虑到这种情况，也加上了一些防护措施：在<code>ThreadLocal</code>的<code>get(),set(),remove()</code>的时候都会清除线程<code>ThreadLocalMap</code>里所有<code>key</code>为<code>null</code>的<code>value</code>。</p><p>但是这些被动的预防措施并不能保证不会内存泄漏：</p><ul><li>使用<code>static</code>的<code>ThreadLocal</code>，延长了<code>ThreadLocal</code>的生命周期，可能导致的内存泄漏</li><li>分配使用了<code>ThreadLocal</code>又不再调用<code>get(),set(),remove()</code>方法，那么就会导致内存泄漏。</li></ul><h2>四、为什么使用弱引用</h2><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析<code>ThreadLocal</code>使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p><ul><li><strong>key 使用强引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，如果没有手动删除，<code>ThreadLocal</code>不会被回收，导致<code>Entry</code>内存泄漏。</li><li><strong>key 使用弱引用</strong>：引用的<code>ThreadLocal</code>的对象被回收了，由于<code>ThreadLocalMap</code>持有<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set,get，remove</code>的时候会被清除。</li></ul><p>比较两种情况，我们可以发现：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果都没有手动删除对应<code>key</code>，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用<code>ThreadLocal</code>不会内存泄漏，对应的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set,get,remove</code>的时候会被清除。</p><p>因此，<code>ThreadLocal</code>内存泄漏的根源是：由于<code>ThreadLocalMap</code>的生命周期跟<code>Thread</code>一样长，如果没有手动删除对应<code>key</code>就会导致内存泄漏，而不是因为弱引用。</p><h2>五、ThreadLocal 最佳实践</h2><p>综合上面的分析，我们可以理解<code>ThreadLocal</code>内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p><p>每次使用完<code>ThreadLocal</code>，都调用它的<code>remove()</code>方法，清除数据。<br>在使用线程池的情况下，没有及时清理<code>ThreadLocal</code>，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用<code>ThreadLocal</code>就跟加锁完要解锁一样，用完就清理。</p><p>整理自：</p><ul><li><a href="https://blog.xiaohansong.com/ThreadLocal-memory-leak.html" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal是面试重灾区，分为两篇来讲解其中的用法和原理。这是第二篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之ThreadLocal详解</title>
    <link href="http://yoursite.com/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/20/java-basic/java基础之ThreadLocal详解/</id>
    <published>2019-02-20T12:31:57.745Z</published>
    <updated>2019-02-20T12:39:42.852Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal是面试重灾区，但是好像我没遇到过有人问，尴尬脸，不过我们不能做砧板上的鱼肉静静等待宰割，分为两篇来讲解其中的用法和原理。这是第一篇。</p><a id="more"></a><h2>一、ThreadLocal简介</h2><p><code>ThreadLocal</code>类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过<code>get</code>或<code>set</code>方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，<code>ThreadLocal</code>实例通常来说都是<code>private static</code>类型。</p><p><code>ThreadLocal</code>类提供了四个对外开放的接口方法，这也是用户操作<code>ThreadLocal</code>类的基本方法：</p><ul><li><code>void set(Object value)</code>设置当前线程的线程局部变量的值。</li><li><code>public Object get()</code>该方法返回当前线程所对应的线程局部变量。</li><li><code>public void remove()</code>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li><li><code>protected Object initialValue()</code>返回该线程局部变量的初始值，该方法是一个<code>protected</code>的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用<code>get()</code>或<code>set(Object)</code>时才执行，并且仅执行1次，<code>ThreadLocal</code>中的缺省实现直接返回一个<code>null</code>。</li></ul><blockquote><p>一个简单的小例子来感受ThreadLocal到底是什么以及怎么用：</p></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic14-1.png" alt="image"></p><blockquote><p>运行结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-0</span><br><span class="line">张三</span><br><span class="line">李四</span><br><span class="line">王五</span><br><span class="line">Thread-1</span><br><span class="line">Chinese</span><br><span class="line">English</span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>可以，看出虽然多个线程对同一个变量进行访问，但是由于<code>threadLocal</code>变量由<code>ThreadLocal</code> 修饰，则不同的线程访问的就是该线程设置的值，这里也就体现出来<code>ThreadLocal</code>的作用。</p><p>当使用<code>ThreadLocal</code>维护变量时，<code>ThreadLocal</code>为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><h2>二、扒开JDK threadlocal神秘面纱</h2><p>threadlocal的原理图为：</p><p><img src="http://xiaozhao.oursnail.cn/iKjk3GS.png" alt="image"></p><p>那<code>ThreadLocal</code>内部是如何为每一个线程维护变量副本的呢？到底是什么原理呢？</p><p>先来看一下<code>ThreadLocal</code>的<code>set()</code>方法的源码是如何实现的：</p><p><img src="http://bloghello.oursnail.cn/javabasic14-2.png" alt="image"></p><p>我们看到，首先通过<code>getMap(Thread t)</code>方法获取一个和当前线程相关的<code>ThreadLocalMap</code>，然后将变量的值设置到这个<code>ThreadLocalMap</code>对象中，当然如果获取到的<code>ThreadLocalMap</code>对象为空，就通过<code>createMap</code>方法创建。</p><p>我们再往下面去一点，比如<code>map.set</code>方法到底是怎么实现的？</p><p><img src="http://bloghello.oursnail.cn/javabasic14-3.png" alt="image"></p><p>结合上面的图，其实我们可以发现，数据并不是放在所谓的<code>Map</code>集合中，而是放进了一个<code>Entry</code>数组中，这个<code>entry</code>索引是上面计算好的，<code>entry</code>的<code>key</code>是指向<code>threadLocal</code>的一个软引用，<code>value</code>是指向真实数据的一个强引用，以后再获取的时候，再以同样的方式计算得到索引下标即可。</p><blockquote><p>上面代码出现的 ThreadLocalMap 是什么？</p></blockquote><p><strong><code>ThreadLocalMap</code>是<code>ThreadLocal</code>类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的<code>ThreadLocalMap</code>副本，它所存储的值，只能被当前线程读取和修改。</strong></p><p>我们深入看一下<code>getMap</code>和<code>createMap</code>的实现</p><p><code>getMap</code>:</p><p><img src="http://bloghello.oursnail.cn/javabasic14-4.png" alt="image"></p><p><code>createMap</code>:</p><p><img src="http://bloghello.oursnail.cn/javabasic14-5.png" alt="image"></p><p>代码非常直白，就是获取和设置<code>Thread</code>内的一个叫<code>threadLocals</code>的变量，而这个变量的类型就是<code>ThreadLocalMap</code>，这样进一步验证了上文中的观点：<strong>每个线程都有自己独立的<code>ThreadLocalMap</code>对象</strong>。</p><p><code>Thread</code>源码中的<code>threadLocals</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic14-6.png" alt="image"></p><p>我们接着看<code>ThreadLocal</code>中的<code>get</code>方法如下</p><p><img src="http://bloghello.oursnail.cn/javabasic14-7.png" alt="image"></p><ul><li>第一步 先获通过<code>Thread.currentThread（）</code>取当前线程</li><li>第二步 然后获取当前线程的<code>threadLocals</code>属性</li><li>第三步 在<code>threadLocals</code>属性里获取<code>Entry</code>实例</li><li>第四部 从<code>Entry</code>实例的<code>value</code>属性里获取到最后所要的<code>Object</code>对象</li></ul><p>接下来讨论一下上面出现的<code>ThreadLocalMap</code>类以及<code>Entry</code>类，直接贴源码</p><p><img src="http://bloghello.oursnail.cn/javabasic14-8.png" alt="image"></p><p><code>Entry</code>是<code>ThreadLocalMap</code>的内部类，而且<code>ThreadLocalMap</code>里拥有一个类型为<code>Entry[]</code>的<code>table</code>属性，而且每个线程实例有自己的<code>ThreadLocalMap</code>。到这里结论已经很明显了：<strong>负责保存<code>ThreadLocal</code>的<code>key</code>和<code>value</code>根本就不是一个<code>Map</code>类型，而是一个<code>Entry</code>数组!</strong></p><p><code>Entry</code>继承<code>WeakReference</code>，因此继承拥有一个弱引用<code>referent</code>，而且自身也有一个<code>value</code>属性。<code>Entry</code>利用<code>referent</code>来保存<code>threadLocal</code>实例的弱引用，利用<code>value</code>保存<code>Object</code>的强引用。至于为什么一个是强引用，一个是弱引用，我们在下一篇中来探讨。</p><p>最后的问题是怎样在<code>Entry</code>数组里定位我们需要的<code>Entry</code>呢?其实上面在set的时候已经大概知道了，现在再来看看代码吧：</p><p><img src="http://bloghello.oursnail.cn/javabasic14-9.png" alt="image"></p><p>留意<code>key.threadLocalHashCode</code>这个属性，<code>Entry</code>在保存进<code>Entry[]</code>数组之前，会利用<code>ThreadLocal</code>的引用计算出一个<code>hash</code>值，然后利用这个<code>hash</code>值作为下标定位到<code>Entry[]</code>数组的某个位置；</p><p><img src="http://xiaozhao.oursnail.cn/thread_specific_storage_custom.png" alt="image"></p><p>原理总结：<code>ThreadLocal</code>类并没有一个<code>Map</code>来保存数据，数据都是保存在线程实例上的；客户端访问<code>ThreadLocal</code>实例的<code>get</code>方法，<code>get</code>方法通过<code>Thread.getCurrentThread</code>获得当前线程的实例，从而获得当前线程的<code>ThreadLocalMap</code>对象，而<code>ThreadLocalMap</code>里包含了一个<code>Entry</code>数组，里面的每个<code>Entry</code>保存了<code>ThreadLocal</code>引用以及<code>Object</code>引用，<code>Entry</code>的<code>referent</code>保存<code>ThreadLocal</code>的弱引用，<code>Entry</code>的<code>value</code>保存<code>Object</code>的强引用。</p><h2>三、threadLoca应用</h2><blockquote><p><code>threadlocal</code>实现的可复用的耗时统计工具<code>Profiler</code></p></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic14-10.png" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-0耗时： 1000</span><br><span class="line">Thread-1耗时： 1999</span><br></pre></td></tr></table></figure><blockquote><p><code>threadLocal</code>实现数据库连接线程隔离</p></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic14-11.png" alt="image"></p><p>通过调用<code>ConnectionManager.getConnection()</code>方法，每个线程获取到的，都是和当前线程绑定的那个<code>Connection</code>对象，第一次获取时，是通过<code>initialValue()</code>方法的返回值来设置值的。通过<code>ConnectionManager.setConnection(Connection conn)</code>方法设置的<code>Connection</code>对象，也只会和当前线程绑定。这样就实现了<code>Connection</code>对象在多个线程中的完全隔离。</p><p>在<code>Spring</code>容器中管理多线程环境下的<code>Connection</code>对象时，采用的思路和以上代码非常相似。</p><h2>四、threadLocal缺陷</h2><p><code>ThreadLocal</code>变量的这种隔离策略，也不是任何情况下都能使用的。</p><p>如果多个线程并发访问的对象实例只能创建那么一个，那就没有别的办法了，老老实实的使用同步机制吧。</p><p>下一篇探讨<code>ThreadLocal</code> 内存泄漏问题。</p><p>参考：</p><ul><li><a href="http://vence.github.io/2016/05/28/threadlocal-info" target="_blank" rel="noopener">深入理解ThreadLocal</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal是面试重灾区，但是好像我没遇到过有人问，尴尬脸，不过我们不能做砧板上的鱼肉静静等待宰割，分为两篇来讲解其中的用法和原理。这是第一篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之NIO</title>
    <link href="http://yoursite.com/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BNIO/"/>
    <id>http://yoursite.com/2019/02/20/java-basic/java基础之NIO/</id>
    <published>2019-02-20T06:37:00.275Z</published>
    <updated>2019-02-20T06:46:15.922Z</updated>
    
    <content type="html"><![CDATA[<p>为了限制篇幅，关于IO这一块的内容，已经从本笔记中移除，具体还是另外看笔记，这里主要还是介绍NIO。</p><a id="more"></a><h2>一、NIO</h2><p>非阻塞的输入/输出 (<code>NIO</code>) 库是在 <code>JDK 1.4</code> 中引入的。<code>NIO</code> 弥补了原来的 <code>I/O</code> 的不足，提供了高速的、面向块的 <code>I/O</code>。</p><h2>1.1 阻塞I/O通信模型</h2><p>假如现在你对阻塞I/O已有了一定了解，我们知道阻塞I/O在调用<code>InputStream.read()</code>方法时是阻塞的，它会一直等到数据到来时（或超时）才会返回；同样，在调用<code>ServerSocket.accept()</code>方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。阻塞I/O的通信模型示意图如下：</p><p><img src="http://xiaozhao.oursnail.cn/%E9%98%BB%E5%A1%9EIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="image"></p><p>缺点：</p><ol><li>当客户端多时，会创建大量的处理线程。且每个线程都要占用栈空间和一些CPU时间</li><li>阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。</li></ol><h2>1.2 java NIO原理及通信模型</h2><p>下面是<code>java NIO</code>的工作原理：</p><ol><li>由一个专门的线程来处理所有的 IO 事件，并负责分发。</li><li>事件驱动机制：事件到的时候触发，而不是同步的去监视事件。</li><li>线程通讯：线程之间通过 <code>wait</code>,<code>notify</code> 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。</li></ol><p><img src="http://xiaozhao.oursnail.cn/NIO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="image"></p><p><code>Java NIO</code>的服务端只需启动一个专门的线程来处理所有的 <code>IO</code> 事件，这种通信模型是怎么实现的呢？<code>java NIO</code>采用了双向通道（<code>channel</code>）进行数据传输，而不是单向的流（<code>stream</code>），在通道上可以注册我们感兴趣的事件。一共有以下四种事件：</p><table><thead><tr><th>事件名</th><th>对应值</th></tr></thead><tbody><tr><td>服务端接收客户端连接事件</td><td>SelectionKey.OP_ACCEPT(16)</td></tr><tr><td>客户端连接服务端事件</td><td>SelectionKey.OP_CONNECT(8)</td></tr><tr><td>读事件</td><td>SelectionKey.OP_READ(1)</td></tr><tr><td>写事件</td><td>SelectionKey.OP_WRITE(4)</td></tr></tbody></table><p>服务端和客户端各自维护一个管理通道的对象，我们称之为<code>selector</code>，该对象能检测一个或多个通道 (<code>channel</code>) 上的事件。我们以服务端为例，如果服务端的<code>selector</code>上注册了读事件，某时刻客户端给服务端发送了一些数据，阻塞<code>I/O</code>这时会调用<code>read()</code>方法阻塞地读取数据，而<code>NIO</code>的服务端会在<code>selector</code>中添加一个读事件。服务端的处理线程会轮询地访问<code>selector</code>，如果访问<code>selector</code>时发现有感兴趣的事件到达，则处理这些事件，如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达为止。下面是我理解的<code>java NIO</code>的通信模型示意图：</p><p><img src="http://xiaozhao.oursnail.cn/NIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="image"></p><h2>二、关于阻塞与非阻塞，同步与非同步的理解</h2><p>我们都知道常见的IO有四种方式，同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。然而对于同步和阻塞的理解却一直很模糊。</p><h4>2.1 同步与异步</h4><ul><li>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</li><li>而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</li><li>我们可以用打电话（同步）和发短信（异步）来很好的比喻同步与异步操作。</li></ul><h4>2.2 阻塞和非阻塞</h4><ul><li>阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。</li><li>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。</li><li>虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。</li></ul><h4>2.3 什么是阻塞IO？什么是非阻塞IO？</h4><p>在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。</p><p>通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。</p><p>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：</p><ul><li>查看数据是否就绪；</li><li>进行数据拷贝（内核将数据拷贝到用户线程）。</li></ul><p>那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于<font color="#ff0000">第一个阶段</font>，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p><p><font color="#ff0000">Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</font></p><h4>2.4 什么是同步IO？什么是异步IO？</h4><p>我们知道了，阻塞和非阻塞是判断数据是否就绪时如何处理，即IO操作的第一阶段。</p><p>那么什么是同步IO和异步IO呢？</p><p>我们知道，同步是打电话，异步是发短信，打电话需要等到电话通了才能进行下一步，发短信就不用操心那么多了，我发出去就行了，至于什么时候发送、如何发送以及如何保证我这个短信一定能发出去，我是不管的。</p><p>同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。</p><blockquote><p>描述的是用户线程与内核的交互方式：</p></blockquote><ul><li>同步是指用户线程发起 I/O 请求后需要等待或者轮询内核 I/O操作完成后才能继续执行；</li><li>异步是指用户线程发起I/O请求后仍继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</li></ul><h2>三、Channel（通道）</h2><p>通道，顾名思义，就是通向什么的道路，为某个提供了渠道。在传统IO中，我们要读取一个文件中的内容，通常是像下面这样读取的：</p><p><img src="http://bloghello.oursnail.cn/javabbasic13-1.png" alt="image"></p><p>这里的<code>InputStream</code>实际上就是为读取文件提供一个通道的。<br>因此可以将<code>NIO</code> 中的<code>Channel</code>同传统IO中的<code>Stream</code>来类比，但是要注意，传统IO中，<code>Stream</code>是单向的，比如<code>InputStream</code>只能进行读取操作，<code>OutputStream</code>只能进行写操作。而<code>Channel</code>是双向的，既可用来进行读操作，又可用来进行写操作。</p><p>通道包括以下类型：</p><ul><li><code>FileChannel</code>：从文件中读写数据；</li><li><code>DatagramChannel</code>：通过 UDP 读写网络中数据；</li><li><code>SocketChannel</code>：通过 TCP 读写网络中数据；</li><li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 <code>SocketChannel</code></li></ul><p>下面给出通过<code>FileChannel</code>来向文件中写入数据的一个例子：</p><p><img src="http://bloghello.oursnail.cn/javabasic13-2.png" alt="image"></p><h2>四、Buffer（缓冲区）</h2><p><code>Buffer</code>（缓冲区），是<code>NIO</code>中非常重要的一个东西，在<code>NIO</code>中所有数据的读和写都离不开<code>Buffer</code>。比如上面的一段代码中，读取的数据时放在<code>byte</code>数组当中，而在<code>NIO</code>中，读取的数据只能放在<code>Buffer</code>中。同样地，写入数据也是先写入到<code>Buffer</code>中。</p><p><img src="http://xiaozhao.oursnail.cn/NIOBuffer.jpg" alt="image"></p><p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入<code>Buffer</code>中，然后将<code>Buffer</code>中的内容写入通道。服务端这边接收数据必须通过<code>Channel</code>将数据读入到<code>Buffer</code>中，然后再从<code>Buffer</code>中取出数据来处理。</p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>如果是对于文件读写，上面几种<code>Buffer</code>都可能会用到。但是对于网络读写来说，用的最多的是<code>ByteBuffer</code>。</p><h2>五、缓冲区状态变量</h2><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 <code>position</code> 为 0，而 <code>limit = capacity = 8</code>。<code>capacity</code> 变量不会改变，下面的讨论会忽略它。</p><p><img src="http://xiaozhao.oursnail.cn/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="image"></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 <code>position</code> 移动设置为 5，<code>limit</code> 保持不变。</p><p><img src="http://xiaozhao.oursnail.cn/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="image"></p><p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 <code>flip()</code> 方法，这个方法将 <code>limit</code> 设置为当前 <code>position</code>，并将 <code>position</code> 设置为 0。</p><blockquote><p>buffer中的flip方法涉及到bufer中的Capacity,Position和Limit三个概念。其中Capacity在读写模式下都是固定的，就是我们分配的缓冲大小,Position类似于读写指针，表示当前读(写)到什么位置,Limit在写模式下表示最多能写入多少数据，此时和Capacity相同，在读模式下表示最多能读多少数据，此时和缓存中的实际数据大小相同。在写模式下调用flip方法，那么limit就设置为了position当前的值(即当前写了多少数据),postion会被置为0，以表示读操作从缓存的头开始读。也就是说调用flip之后，读写指针指到缓存头部，并且设置了最多只能读出之前写入的数据长度(而不是整个缓存的容量大小)。</p></blockquote><p><img src="http://xiaozhao.oursnail.cn/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="image"></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 <code>position</code> 设为 4。</p><p><img src="http://xiaozhao.oursnail.cn/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="image"></p><p>⑤ 最后需要调用 <code>clear()</code> 方法来清空缓冲区，此时 <code>position</code> 和 <code>limit</code> 都被设置为最初位置。</p><p><img src="http://xiaozhao.oursnail.cn/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="image"></p><h2>六、文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p><p><img src="http://bloghello.oursnail.cn/javabasic13-3.png" alt="image"></p><h2>七、Selector（选择器）</h2><p>可以说它是<code>NIO</code>中最关键的一个部分，<code>Selector</code>的作用就是用来轮询每个注册的<code>Channel</code>，一旦发现<code>Channel</code>有注册的事件发生，便获取事件然后进行处理。</p><p><img src="http://xiaozhao.oursnail.cn/4d930e22-f493-49ae-8dff-ea21cd6895dc.png" alt="image"></p><p>用单线程处理一个<code>Selector</code>，然后通过<code>Selector.select()</code>方法来获取到达事件，在获取了到达事件之后，就可以逐个地对这些事件进行响应处理。</p><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。</p><p>下面从编程的角度具体来看看选择器是如何实现的。</p><h3>7.1 创建选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3>7.2 将通道注册到选择器上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li><code>SelectionKey.OP_CONNECT</code></li><li><code>SelectionKey.OP_ACCEPT</code></li><li><code>SelectionKey.OP_READ</code></li><li><code>SelectionKey.OP_WRITE</code></li></ul><p>它们在 <code>SelectionKey</code> 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3>7.3 监听事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure><p>使用 <code>select()</code> 来监听事件到达，它会一直阻塞直到有至少一个事件到达。</p><h3>7.4 获取到达的事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>7.5 事件循环</h3><p>因为一次 <code>select()</code> 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>八、流与块</h2><p><code>I/O</code> 与 <code>NIO</code> 最重要的区别是数据打包和传输的方式，<code>I/O</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据。</p><p>面向流的 <code>I/O</code> 一次处理一个字节数据，一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 <code>I/O</code> 通常相当慢。</p><p>面向块的 <code>I/O</code> 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 <code>I/O</code> 缺少一些面向流的 <code>I/O</code> 所具有的优雅性和简单性。</p><p><code>I/O</code> 包和 <code>NIO</code> 已经很好地集成了，<code>java.io.*</code> 已经以 <code>NIO</code> 为基础重新实现了，所以现在它可以利用 <code>NIO</code> 的一些特性。例如，<code>java.io.*</code> 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h2>九、一个完整 NIO 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuffer data = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">"hello world"</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>十、NIO和IO的主要区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>无</td><td>选择器</td></tr></tbody></table><ul><li>面向流与面向缓冲</li></ul><blockquote><p>Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p></blockquote><ul><li>阻塞与非阻塞IO</li></ul><blockquote><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p></blockquote><ul><li>选择器（Selectors）</li></ul><blockquote><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p></blockquote><h2>十一、总结</h2><ul><li><code>NIO</code>其实实现的是一个IO的多路复用，用<code>select</code>来同时监听多个<code>channel</code>，本质上还是同步阻塞的，需要<code>select</code>不断监听端口。但是对于IO各个通道来说就是可以看做是异步。</li><li>基本可以认为 “NIO = I/O多路复用 + 非阻塞式I/O”，大部分情况下是单线程，但也有超过一个线程实现NIO的情况</li><li>我们可以用打电话（同步）和发短信（异步）来很好的比喻同步与异步操作</li><li>阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。</li><li>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。两种方式各有优劣。</li><li>传统IO中，<code>Stream</code>是单向的，比如<code>InputStream</code>只能进行读取操作，<code>OutputStream</code>只能进行写操作。而<code>Channel</code>是双向的，既可用来进行读操作，又可用来进行写操作。</li><li>在<code>NIO</code>中，读取的数据只能放在<code>Buffer</code>中。同样地，写入数据也是先写入到<code>Buffer</code>中。缓冲区有三个状态变量：<code>capacity</code>：最大容量；<code>position</code>：当前已经读写的字节数；<code>limit</code>：还可以读写的字节数。</li><li>Selector的作用就是用来轮询每个注册的Channel，一旦发现Channel有注册的事件发生，便获取事件然后进行处理.</li><li>NIO和IO的主要区别。</li><li>NIO适用场景</li></ul><blockquote><p>服务器需要支持超大量的长时间连接。比如10000个连接以上，并且每个客户端并不会频繁地发送太多数据。例如总公司的一个中心服务器需要收集全国便利店各个收银机的交易信息，只需要少量线程按需处理维护的大量长期连接。</p></blockquote><ul><li>BIO适用场景</li></ul><blockquote><p>适用于连接数目比较小，并且一次发送大量数据的场景，这种方式对服务器资源要求比较高，并发局限于应用中。</p></blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3916526.html" target="_blank" rel="noopener">Java NIO：浅析I/O模型</a></li><li><a href="https://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">NIO与传统IO的区别</a></li><li><a href="https://troywu0.gitbooks.io/spark/content/java-io%E6%B5%81.html" target="_blank" rel="noopener">Java NIO：NIO概述</a></li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20IO" target="_blank" rel="noopener">Java I/O</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了限制篇幅，关于IO这一块的内容，已经从本笔记中移除，具体还是另外看笔记，这里主要还是介绍NIO。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Socket基础</title>
    <link href="http://yoursite.com/2019/02/20/Socket%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/20/Socket基础/</id>
    <published>2019-02-20T03:39:29.748Z</published>
    <updated>2019-02-20T06:25:05.442Z</updated>
    
    <content type="html"><![CDATA[<p>学习I/O几种常见模型以及select、poll、epoll三种多路复用的具体实现。</p><a id="more"></a><h2>一、I/O 模型</h2><p>一个输入操作，即我们常说的读取一个文件，通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。我们看到，这是一个比较麻烦的过程，可能是性能出现瓶颈的地方。</p><p><code>Unix</code> 下有五种 <code>I/O</code> 模型：</p><ul><li>阻塞式 <code>I/O</code></li><li>非阻塞式 <code>I/O</code></li><li><code>I/O</code> 复用（<code>select</code> 和 <code>poll</code>）</li><li>信号驱动式 <code>I/O</code>（<code>SIGIO</code>）</li><li>异步 <code>I/O</code>（<code>AIO</code>）</li></ul><h3>1.1 阻塞式 I/O</h3><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p>下图中，<code>recvfrom</code> 用于接收 <code>Socket</code> 传来的数据，并复制到应用进程的缓冲区 <code>buf</code> 中。这里把 <code>recvfrom()</code> 当成系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure><p><img src="http://xiaozhao.oursnail.cn/%E9%98%BB%E5%A1%9E%E5%BC%8FIO1.png" alt="image"></p><h3>1.2 非阻塞式 I/O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 <code>I/O</code> 是否完成，这种方式成为轮询（<code>polling</code>）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><p><img src="http://xiaozhao.oursnail.cn/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO1.png" alt="image"></p><h3>1.3 I/O 复用</h3><p>使用 <code>select</code> 或者 <code>poll</code> 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 <code>recvfrom</code> 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 <code>Event Driven I/O</code>，即事件驱动 I/O。</p><p>如果一个 <code>Web</code> 服务器没有 I/O 复用，那么每一个 <code>Socket</code> 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><p><img src="http://xiaozhao.oursnail.cn/IO%E5%A4%8D%E7%94%A81.png" alt="image"></p><h3>1.4 信号驱动 I/O</h3><p>应用进程使用 <code>sigaction</code> 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 <code>SIGIO</code> 信号，应用进程收到之后在信号处理程序中调用 <code>recvfrom</code> 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><p><img src="http://xiaozhao.oursnail.cn/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO1.png" alt="image"></p><h3>1.5 异步 I/O</h3><p>进行 <code>aio_read</code> 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E6%AD%A5IO1.png" alt="image"></p><h3>1.6 同步 I/O 与异步 I/O</h3><ul><li>同步 I/O：应用进程在调用 <code>recvfrom</code> 操作时会阻塞。</li><li>异步 I/O：不会阻塞。</li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p><h3>1.7 五大 I/O 模型比较</h3><p>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的：将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p><p><img src="http://xiaozhao.oursnail.cn/%E4%BA%94%E5%A4%A7IO%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%831.png" alt="image"></p><h2>二、select/poll/epoll</h2><p>这三个都是 I/O 多路复用的具体实现，<code>select</code> 出现的最早，之后是 <code>poll</code>，再是 <code>epoll</code>。</p><h3>2.1 select</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-1.png" alt="image"></p><p><code>fd_set</code> 表示描述符集合类型，有三个参数：<code>readset</code>、<code>writeset</code> 和 <code>exceptset</code>，分别对应读、写、异常条件的描述符集合。</p><p><code>timeout</code> 参数告知内核等待所指定描述符中的任何一个就绪可花多少时间；</p><p>成功调用返回结果大于 0；出错返回结果为 -1；超时返回结果为 0。</p><p>每次调用 <code>select</code> 都需要将 <code>fd_set \*readfds, fd_set \*writefds, fd_set \*exceptfds</code> 链表内容全部从应用进程缓冲复制到内核缓冲。</p><p>返回结果中内核并没有声明 <code>fd_set</code> 中哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程需要遍历所有的 <code>fd_set</code>。</p><p><code>select</code> 最多支持 1024 个描述符，其中 1024 由内核的 <code>FD_SETSIZE</code> 决定。如果需要打破该限制可以修改 <code>FD_SETSIZE</code>，然后重新编译内核。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-2.png" alt="image"></p><h3>2.2 poll</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-3.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic12-4.png" alt="image"></p><p>它和 <code>select</code> 功能基本相同。同样需要每次将描述符从应用进程复制到内核，<code>poll</code> 调用返回后同样需要进行轮询才能知道哪些描述符已经准备好。</p><p><code>poll</code> 取消了 1024 个描述符数量上限，但是数量太大以后不能保证执行效率，因为复制大量内存到内核十分低效，所需时间与描述符数量成正比。</p><p><code>poll</code> 在描述符的重复利用上比 <code>select</code> 的 <code>fd_set</code> 会更好。</p><p>如果在多线程下，如果一个线程对某个描述符调用了 <code>poll</code> 系统调用，但是另一个线程关闭了该描述符，会导致 <code>poll</code> 调用结果不确定，该问题同样出现在 <code>select</code> 中。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-5.png" alt="image"></p><h3>2.3 epoll</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-6.png" alt="image"></p><p><code>epoll</code> 仅仅适用于 <code>Linux OS</code>。</p><p>它是 <code>select</code> 和 <code>poll</code> 的增强版，更加灵活而且没有描述符数量限制。</p><p>它将用户关心的描述符放到内核的一个事件表中，从而只需要在用户空间和内核空间拷贝一次。</p><p><code>select</code> 和 <code>poll</code> 方式中，进程只有在调用一定的方法后，内核才对所有监视的描述符进行扫描。而 <code>epoll</code> 事先通过 <code>epoll_ctl()</code> 来注册描述符，一旦基于某个描述符就绪时，内核会采用类似 <code>callback</code> 的回调机制，迅速激活这个描述符，当进程调用 <code>epoll_wait()</code> 时便得到通知。</p><p>新版本的 <code>epoll_create(int size)</code> 参数 <code>size</code> 不起任何作用，在旧版本的 <code>epoll</code> 中如果描述符的数量大于 <code>size</code>，不保证服务质量。</p><p><code>epoll_ctl()</code> 执行一次系统调用，用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理。</p><p><code>epoll_wait()</code> 取出在内核中通过链表维护的 I/O 准备好的描述符，将他们从内核复制到应用进程中，不需要像 <code>select/poll</code> 对注册的所有描述符遍历一遍。</p><p><code>epoll</code> 对多线程编程更有友好，同时多个线程对同一个描述符调用了 <code>epoll_wait()</code> 也不会产生像 <code>select/poll</code> 的不确定情况。或者一个线程调用了 <code>epoll_wait</code> 另一个线程关闭了同一个描述符也不会产生不确定情况。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-7.png" alt="image"></p><h2>三、select 和 poll 比较</h2><h3>3.1 功能</h3><p>它们提供了几乎相同的功能，但是在一些细节上有所不同：</p><ul><li><code>select</code> 会修改 <code>fd_set</code> 参数，而 <code>poll</code> 不会；</li><li><code>select</code> 默认只能监听 1024 个描述符，如果要监听更多的话，需要修改 <code>FD_SETSIZE</code> 之后重新编译；</li><li><code>poll</code> 提供了更多的事件类型。</li></ul><h3>3.2 速度</h3><p><code>poll</code> 和 <code>select</code> 在速度上都很慢。</p><ul><li>它们都采取轮询的方式来找到 I/O 完成的描述符，如果描述符很多，那么速度就会很慢；</li><li><code>select</code> 只使用每个描述符的 3 位，而 poll 通常需要使用 64 位，因此 <code>poll</code> 需要复制更多的内核空间。</li></ul><h3>3.3 可移植性</h3><p>几乎所有的系统都支持 <code>select</code>，但是只有比较新的系统支持 <code>poll</code>。</p><h2>四、eopll 工作模式</h2><p><code>epoll_event</code> 有两种触发模式：<code>LT</code>（<code>level trigger</code>）和 <code>ET</code>（<code>edge trigger</code>）。</p><h3>4.1 LT 模式</h3><p>当 <code>epoll_wait()</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 <code>epoll_wait()</code> 时，会再次响应应用程序并通知此事件。是默认的一种模式，并且同时支持 <code>Blocking</code> 和 <code>No-Blocking</code>。</p><h3>4.2 ET 模式</h3><p>当 <code>epoll_wait()</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 <code>epoll_wait()</code> 时，不会再次响应应用程序并通知此事件。很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 <code>No-Blocking</code>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h2>五、select poll epoll 应用场景</h2><p>很容易产生一种错觉认为只要用 <code>epoll</code> 就可以了，<code>select poll</code> 都是历史遗留问题，并没有什么应用场景，其实并不是这样的。</p><h3>5.1 select 应用场景</h3><p><code>select() poll() epoll_wait()</code> 都有一个 <code>timeout</code>参数，在 <code>select()</code> 中 <code>timeout</code> 的精确度为 1ns，而 <code>poll()</code> 和 <code>epoll_wait()</code> 中则为 1ms。所以 <code>select</code> 更加适用于实时要求更高的场景，比如核反应堆的控制。</p><p><code>select</code> 历史更加悠久，它的可移植性更好，几乎被所有主流平台所支持。</p><h3>5.2 poll 应用场景</h3><p><code>poll</code> 没有最大描述符数量的限制，如果平台支持应该采用 <code>poll</code> 且对实时性要求并不是十分严格，而不是 <code>select</code>。</p><p>需要同时监控小于 1000 个描述符。那么也没有必要使用 <code>epoll</code>，因为这个应用场景下并不能体现 <code>epoll</code> 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的。因为 <code>epoll</code> 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 <code>epoll_ctl()</code> 进行系统调用，频繁系统调用降低效率。<code>epoll</code> 的描述符存储在内核，不容易调试。</p><h3>5.3 epoll 应用场景</h3><p>程序只需要运行在 <code>Linux</code> 平台上，有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p><h2>六、对比</h2><p>举例说明：老师收学生作业，相当于应用层调用I/O操作。</p><p>1、老师逐个收学生作业，学生没有做完，只能阻塞等待，收了之后，再去收下一个学生的作业。这显然存在性能问题。</p><p>2、怎么解决上面的问题？<br>老师找个班长，班长负责收作业，班长的做法是：遍历问学生作业写好了吗，写好的，收起来交给老师。休息一会，再去遍历。。。<br>这个班长就是<code>select</code>。</p><blockquote><p>存在问题</p></blockquote><ul><li>这个班长还有一个能力问题，最多只能管理1024个学生。</li><li>很多学生的作业没有写好，而且短时间写不好，班长还是不停地遍历去问，影响效率。</li></ul><blockquote><p>怎么解决问题1班长的能力问题？</p></blockquote><ul><li>换一个能力更强的班长，可以管理更多的学生，这个班长就是<code>poll</code>。</li></ul><blockquote><p>怎么解决问题1、2，存在的能力问题和效率问题？</p></blockquote><ul><li>换一个能力超级强的班长，可以管理无限多的学生，同时班长的做法是：遍历一次所有的学生，如果作业没有写完，告诉学生写好之后，放在一个固定的地方。这样的话，班长只需要定期到这个地方取作业就好了。这就是<code>epoll</code>。</li></ul><p>参考：</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Socket.md" target="_blank" rel="noopener">socket</a></li><li><a href="https://www.cnblogs.com/java2016/p/5538018.html" target="_blank" rel="noopener">理解 select poll epoll</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习I/O几种常见模型以及select、poll、epoll三种多路复用的具体实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Socket" scheme="http://yoursite.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>java基础之泛型下</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8B/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之泛型下/</id>
    <published>2019-02-19T13:12:22.961Z</published>
    <updated>2019-02-19T13:26:22.648Z</updated>
    
    <content type="html"><![CDATA[<p>本节继续讨论泛型相关的知识。</p><a id="more"></a><h2>6、泛型上下边界</h2><p>我们再来讨论讨论通配符。</p><p>通配符有2种：</p><ul><li>无边界通配符，用<code>&lt;?&gt;</code>表示。</li><li>有边界通配符，用<code>&lt;? extends Object&gt;</code>或者<code>&lt;? super Object&gt;</code>来表示。（<code>Object</code>仅仅是一个示例）</li></ul><h5>6.1 无边界</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 合法</span></span><br><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;?&gt;(); <span class="comment">// 不合法</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;?&gt;(); <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><p>对于带有通配符的引用变量，是不能调用具有与泛型参数有关的方法的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(1); // 编译不通过</span><br><span class="line">list.get(0); // 编译通过</span><br><span class="line">int size = list.size(); // 由于size()方法中不含泛型参数，所以可以在通配符变量中调用</span><br></pre></td></tr></table></figure><p>总结起来，无边界通配符主要用做引用，可以调用与泛型参数无关的方法，不能调用参数中包含泛型参数的方法。</p><h5>6.2 有边界</h5><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><ul><li>上边界通配，用&lt;? extends 类型&gt;表示。其语法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends 类型<span class="number">1</span>&gt; x = <span class="keyword">new</span> ArrayList&lt;类型<span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure><p>其中，类型2就只能是类型1或者是类型1的子类。下面代码验证合法性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; x = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//由于Integer是Number的子类，这是合法的</span></span><br><span class="line">List&lt;? extends Number&gt; x = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//由于String不是Number的子类，这是不合法的</span></span><br></pre></td></tr></table></figure><ul><li>下边界通配，用&lt;? super 类型&gt;表示。其语法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> 类型<span class="number">1</span>&gt; x = <span class="keyword">new</span> ArrayList&lt;类型<span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure><p>其中，类型2就只能是类型1或者是类型1的超类。下面代码有验证合法性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> ArrayList&lt;Number&gt;(); <span class="comment">//由于Number是Integer的超类，这是合法的</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//由于String不是Integer的超类，这是不合法的</span></span><br></pre></td></tr></table></figure><p>那么到底什么时候使用下边界通配，什么时候使用上边界通配呢？首先考虑一下怎样才能保证不会发生运行时异常，这是泛型要解决的首要问题，通过前面的内容可以看到，任何可能导致类型转换异常的操作都无法编译通过。</p><ul><li>⭐上边界通配：可以保证存放的实际对象至多是上边界指定的类型，那么在读取对象时，我们总是可以放心地将对象赋予上边界类型的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">List&lt;? extends Number&gt; list2 = list1;</span><br><span class="line">Number a = list2.get(<span class="number">0</span>); <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><ul><li>⭐下边界通配：可以保证存放的实际对象至少是下边界指定的类型，那么在存入对象时，我们总是可以放心地将下边界类型的对象存入泛型对象中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list3.add(<span class="number">1</span>);</span><br><span class="line">list3.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p></blockquote><ul><li>如果你想从一个数据类型里获取数据，使用 ? extends 通配符。</li><li>如果你想把对象写入一个数据结构里，使用 ? super 通配符。</li><li>如果你既想存，又想取，那就别用通配符。</li></ul><p>对于泛型方法添加上下边界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>7、泛型的原理</h2><h5>7.1 类型擦除</h5><p><font color="#ff0000">Java中的泛型是通过类型擦除来实现的</font>。<strong>所谓类型擦除，是指通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。</strong></p><p>下面通过两个例子来证明在编译时确实发生了类型擦除。</p><p>例1分别创建实际类型为<code>String</code>和<code>Integer</code>的<code>ArrayList</code>对象，通过<code>getClass()</code>方法获取两个实例的类，最后判断这个实例的类是相等的，证明两个实例共享同一个类。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-1.png" alt="image"></p><p>例2创建一个只能存储<code>Integer</code>的<code>ArrayList</code>对象，在<code>add</code>一个整型数值后，利用反射调用<code>add(Object o)</code> <code>add</code>一个<code>asd</code>字符串，此时运行代码不会报错，运行结果会打印出1和asd两个值。这时再里利用反射调用<code>add(Integer o)</code>方法，运行会抛出<code>codeNoSuchMethodException</code>异常。这充分证明了在编译后，擦除了<code>Integer</code>这个泛型信息，只保留了原始类型。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-2.png" alt="image"></p><h5>7.2 自动类型转换</h5><p>上一节上说到了类型擦除，Java编译器会擦除掉泛型信息。那么调用<code>ArrayList</code>的<code>get()</code>最终返回的必然会是一个<code>Object</code>对象，但是我们在源代码并没有写过<code>Object</code>转成<code>Integer</code>的代码，为什么就能“直接”将取出来的对象赋予一个<code>Integer</code>类型的变量呢（如下面的代码第12行）？</p><p><img src="http://bloghello.oursnail.cn/javabasic11-3.png" alt="image"></p><p><font color="#ff0000">实际上，Java的泛型除了类型擦除之外，还会自动生成<code>checkcast</code>指令进行强制类型转换</font>。上面的代码中的main方法编译后所对应的字节码如下。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-4.png" alt="image"></p><p>看到第26行代码就是将<code>Object</code>类型的对象强制转换为<code>Integer</code>的指令。我们完全可以将上面的代码转换为下面的代码，它所实现的效果跟上面的泛型是一模一样的。既然泛型也需要进行强制转换，所以泛型并不会提供运行时效率，不过可以大大降低编程时的出错概率。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-5.png" alt="image"></p><h2>8、简单总结</h2><h3>8.1 类型擦除(Type Erasure)</h3><ul><li>Java 的泛型是在编译器层次实现的。</li><li>在编译生成的字节码中不包含泛型中的类型参数，类型参数会在编译时去掉。</li><li>例如：<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在编译后都变成 <code>List</code>。</li><li>类型擦除的基本过程：将代码中的类型参数替换为具体的类，同时去掉 <code>&lt;&gt;</code> 的内容。</li></ul><h3>8.2 泛型的优势</h3><ul><li>编译时更强大的类型检测。</li></ul><p>例如如下代码：方法传入一个<code>String</code>对象，传出一个<code>String</code> 对象，并强制转换为<code>Integer</code>对象。这段代码编译可以通过，因为都是<code>Object</code>的子类，但是运行时会产生<code>ClassCastException</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-6.png" alt="image"></p><p>而如果通过泛型来实现，则会在编译时进行类型的检测。例如如下代码：会产生编译错误。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-7.png" alt="image"></p><ul><li>提供自动和隐式的类型转换</li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-8.png" alt="image"></p><h3>8.3 <code>&lt;T&gt;</code> VS <code>&lt;?&gt;</code></h3><p>不同点：</p><ul><li><code>&lt;T&gt;</code>用于泛型的定义，例如<code>class MyGeneric&lt;T&gt; {...}</code></li><li><code>&lt;?&gt;</code>用于泛型的声明，即泛型的使用，例如<code>MyGeneric&lt;?&gt; g = new MyGeneric&lt;&gt;()</code>;</li></ul><p>相同点：都可以指定上界和下界:</p><p><img src="http://bloghello.oursnail.cn/javabasic11-9.png" alt="image"></p><h3>8.4 <code>&lt;?&gt;</code>不同于<code>&lt;Object&gt;</code></h3><ul><li>指定未知类型，如<code>List&lt;?&gt;</code>。<code>List&lt;?&gt;</code>不等于<code>List&lt;Object&gt;</code></li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-10.png" alt="image"></p><p><code>String</code>是<code>Object</code>的子类，但是<code>List&lt;String&gt;</code>不是<code>List&lt;Object&gt;</code>的子类。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-11.png" alt="image"></p><p>如果将<code>List&lt;Object&gt;</code>换成<code>List&lt;?&gt;</code>，则可以编译通过。</p><p>注意：</p><ul><li>相同参数类型的泛型类的继承关系取决于泛型类自身的继承结构。<br>例如<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code>的子类</li><li>当类型声明中使用通配符<code>?</code>时，其子类型可以在两个维度上扩展。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如 Collection&lt;? extends Number&gt;</span><br><span class="line">在维度<span class="number">1</span>上扩展：List&lt;? extends Number&gt;</span><br><span class="line">在维度<span class="number">2</span>上扩展：Collection&lt;Integer&gt;</span><br></pre></td></tr></table></figure><h2>9、Java泛型中<code>List</code>、<code>List&lt;Object&gt;</code>、<code>List&lt;?&gt;</code>的区别</h2><ul><li><code>List</code>：原生态类型</li><li><code>List&lt;Object&gt;</code>：参数化的类型，表明<code>List</code>中可以<strong>容纳任意类型的对象</strong></li><li><code>List&lt;?&gt;</code>：无限定通配符类型，表示<strong>只能包含某一种未知对象类型</strong></li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-12.png" alt="image"></p><p>我们创建了一个<code>List&lt;String&gt;</code>类型的对象<code>strings</code>，再把它赋给原生态类型<code>List</code>，这是可以的。但是第5行中尝试把它传递给<code>List&lt;Object&gt;</code>时，出现了一个类型不相容错误，注意，这是一个编译期错误。</p><p>这是因为泛型有子类型化的规则：</p><p><code>List&lt;String&gt;</code>是原生态类型<code>List</code>的一个子类型。虽然<code>String</code>是<code>Object</code>的子类型，但是由于泛型是不可协变的，<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，所以这里的传递无法通过编译。</p><p><code>List&lt;Object&gt;</code>唯一特殊的地方只是<code>Object</code>是所有类型的超类，由于泛型的不可协变性，它只能表示<code>List</code>中可以容纳所有类型的对象，却不能表示任何参数类型的<code>List&lt;E&gt;</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-13.png" alt="image"></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">sss</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>List&lt;Object&gt;</code>:表示可用装载任意类型的对象，如上面最后一个例子，但是他不能接受<code>List&lt;String&gt;</code>的替换，因为不具有继承性，并且<code>List&lt;Object&gt;</code>如果可以被<code>List&lt;String&gt;</code>，就不符合原则了，因为<code>List&lt;String&gt;</code>只能接受String类型的对象。</li><li><code>List&lt;?&gt;</code>:解决上面表面有继承关系的List的赋值问题，还有就是，他是用作声明能接收一种未知对象类型，而不是大杂烩啥都能接收。</li><li><code>List</code>：原始类型，啥都没有限制。个人认为与<code>List&lt;Object&gt;</code>类似，但是又没有继承的限制。即啥类型都可以接收。</li></ul><h2>10、参考</h2><ul><li><a href="http://hinylover.space/2016/06/25/relearn-java-generic-1/" target="_blank" rel="noopener">http://hinylover.space/2016/06/25/relearn-java-generic-1/</a></li><li><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">java 泛型详解</a></li><li><a href="https://www.cnblogs.com/rese-t/p/8158870.html" target="_blank" rel="noopener">https://www.cnblogs.com/rese-t/p/8158870.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节继续讨论泛型相关的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之泛型上</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8A/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之泛型上/</id>
    <published>2019-02-19T13:11:29.452Z</published>
    <updated>2019-02-19T13:13:56.474Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章全面介绍Java泛型中的基础及原理。本节主要介绍什么是泛型、泛型的核心特性、泛型与继承注意点、泛型与多态的原理以及泛型的使用。</p><a id="more"></a><h2>1、什么是泛型以及为什么用泛型</h2><p>直接上例子进行说明：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-1.png" alt="image"></p><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>为什么会出现这种问题呢？</p><ul><li>集合本身无法对其存放的对象类型进行限定，可以涵盖Java中的所有类型。缺口太大，导致各种蛇、蚁、虫、鼠通通都可以进来。</li></ul><ul><li>由于我们要使用的实际存放类型的方法，所以不可避免地要进行类型转换。小对象转大对象很容易，大对象转小对象则有很大的风险，因为在编译时，我们无从得知对象真正的类型。</li></ul><p>泛型就是为了解决这类问题而诞生的。</p><h2>2、泛型的特性</h2><h5>2.1 泛型只在编译阶段有效</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-2.png" alt="image"></p><p>输出结果：类型相同</p><blockquote><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。<font color="#ff0000"><strong>也就是说Java中的泛型，只在编译阶段有效</strong>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</font></p></blockquote><p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p><h5>2.2 泛型的兼容性</h5><p>Java编译器是向后兼容的，也就是低版本的源代码可以用高版本编译器进行编译。下面来看看那些兼容性代码。</p><blockquote><ol><li>引用和实例化都不包含泛型信息。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-3.png" alt="image"></p><p>上面的这段代码是可以通过编译的，这是JDK1.4之前的写法，所以可以验证JDK1.5之后的编译器是可以兼容JDK1.4之前的源代码的。不过，笔者在JDK1.8.x版本的编译器进行编译时，会抛出如下所示的警告信息。很显然，如果类被定义成泛型类，但是在实际使用时不使用泛型特性，这是不推荐的做法！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注: Compatibility.java使用了未经检查或不安全的操作。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>引用使用泛型，实例化不使用泛型。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-4.png" alt="image"></p><p>上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告。</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>引用不使用泛型，实例化使用泛型。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-5.png" alt="image"></p><p>上面的这段代码可以编译通过，其效果与1（不使用泛型）完全一致。结合2、3可以知道，编译时只能做引用的类型检查，而无法检查引用所指向对象的实际类型。</p><h2>3、泛型与继承</h2><p>在使用泛型时，引用的参数类型与实际对象的参数类型要保持一致（通配符除外），就算两个参数类型是继承关系也是不允许的。看看下面的2行代码，它们均不能通过编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); <span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>下面来探讨一下为什么不能这么做。</p><ul><li>第1种情况，如果这种代码可以通过编译，那么调用<code>get()</code>方法返回的对象应该是<code>String</code>，但它实际上可以存放任意<code>Object</code>类型的对象，这样在调用类型转换指令时会抛出<code>ClassCastException</code>。</li><li>第2种情况。虽然<code>String</code>类型的对象转换为<code>Object</code>不会有任何问题，但是这有什么意义呢？我们原本想要用<code>String</code>对象的方法，但最终将其赋予了一个<code>Object</code>类型的引用。如果需要使用<code>String</code>中的某些方法，必须将<code>Object</code>强制转换为<code>String</code>。这样不会抛出异常，但是却违背了泛型设计的初衷。</li></ul><h2>4、泛型与多态</h2><p>下面来考虑一下泛型中多态问题。普通类型的多态是通过继承并重写父类的方法来实现的，泛型也不例外，下面是一个泛型多态示例。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic10-7.png" alt="image"></p><p>上面定义了一个泛型父类和一个实际参数为<code>String</code>类型的子类，并“重写”了<code>set(T)</code>和<code>get()</code>方法。<code>Son</code>类中的<code>@Override</code>注解也清楚地显示这是一个重写方法，最终执行的结果如下，与想象中的结果完全一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am father, t=hello world</span><br><span class="line">I am son.</span><br></pre></td></tr></table></figure><p>真的这么简单么？虽然表面上（源代码层面）来看，泛型多态与普通类的多态并无二样，但是其内部的实时原理却大相径庭。</p><p>泛型类<code>Father</code>在编译后会擦除泛型信息，所有的泛型参数都会用<code>Object</code>类替代。实际上，<code>Father</code>编译后的字节码与下面的代码完全一致。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-8.png" alt="image"></p><p><code>Son</code>类的与最终会变为：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-9.png" alt="image"></p><p><code>Father</code>和<code>Son</code>类的<code>set()</code>方法的参数类型不一样，所以，这并不是方法重写，而是方法重载！但是，如果是重载，那么<code>Son</code>类就应该会继承<code>Father</code>类的<code>set(Object)</code>方法，也就是<code>Son</code>会同时包含<code>set(String)</code>和<code>set(Object)</code>，下面来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son son = <span class="keyword">new</span> Son();</span><br><span class="line">son.set(<span class="string">"test"</span>);</span><br><span class="line">son.set(<span class="keyword">new</span> Object()); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>当<code>set</code>一个<code>Object</code>对象时，编译无法通过。这就很奇怪了，感觉跟之前学到的知识是相悖的。我们原本想通过重写方法来实现多态，但由于泛型的类型擦除，却最终变成了重载，所以类型擦除与多态有了矛盾。那么Java是怎么解决这个问题的呢？还是从字节码中找答案吧。<code>Son</code>类最终的编译结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.String)</span></span>;         <span class="comment">// 我们重写的方法</span></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">get</span><span class="params">()</span></span>;              <span class="comment">// 我们重写的方法</span></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;              <span class="comment">// 编译器生成的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;          <span class="comment">// 编译器生成的方法</span></span><br><span class="line">    ...</span><br><span class="line">    2: checkcast     #39                 // class java/lang/String</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><font color="#ff0000">⭐这里面多了一个<code>Object get()</code>方法和<code>set(Object)</code>方法，这两个方法在<code>Son</code>类源代码里面并不存在，这是编译器为了解决泛型的多态问题而自动生成的方法，称为“桥方法”。这两个方法的签名与<code>Father</code>类中的两个方法的签名完全一致，这才是真正的方法重写。也就是说，子类真正重写的我们看不到的桥方法，啊，多么痛的领悟！！！<code>@Override</code>注解只是假象，让人误以为他们真的是重写方法。</font></p><p>再看看<code>set(Object)</code>桥方法的实现细节，先将<code>Object</code>对象强制转换为<code>String</code>对象，然后调用<code>Son</code>中的<code>set(String)</code>方法。饶了一个圈，最终才回到我们“重写”的方法。<code>main</code>方法中原本调用父类的<code>set(Object)</code>方法，由于子类通过桥方法重写了这个方法，所以最终的调用顺序是：<code>set(Object)</code> -&gt; <code>set(String)</code>。</p><p>与<code>set(Object)</code>桥方法的意义不同，<code>Object get()</code>并不仅仅解决泛型与重写的冲突，而更具有一般性。看看下面的代码，这是一个普通类的继承:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralFather</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralSon</span> <span class="keyword">extends</span> <span class="title">GeneralFather</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的返回类型是父类的返回类型的子类，这是允许的，这种特性叫做Java返回值的协变性。而协变性的实现方法就是上面所述的桥方法。</p><p>这里还会有疑惑，<code>set</code>方法可以通过参数类型来确定调用的方法。但是，参数一样而返回值不一样是不能重载的。如果我们在源代码中通过编写<code>String get()</code>和<code>Object get()</code>方法是无法通过编译的。虽然，编译器无法通过编译，但是JVM是可以编写这两种方法的，它调用方法时，将返回值也作为方法签名的一部分。有种只许州官放火，不许百姓点灯的感觉。可以看到，JVM做了不少我们认为不合法的事情，所以如果不深入研究底层原理，有些问题根本解释不了。</p><h2>5、泛型的使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法.</p><h5>5.1 泛型类</h5><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：<code>List</code>、<code>Set</code>、<code>Map</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-10.png" alt="image"></p><p>下面进行实例化：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-11.png" alt="image"></p><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 123456</span><br><span class="line">12-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-12.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/泛型测试: key is 111111</span><br><span class="line">D/泛型测试: key is 4444</span><br><span class="line">D/泛型测试: key is 55.55</span><br><span class="line">D/泛型测试: key is false</span><br></pre></td></tr></table></figure><h5>5.2 泛型接口</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-13.png" alt="image"></p><p>当实现泛型接口的类，未传入泛型实参时：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-14.png" alt="image"></p><p>当实现泛型接口的类，传入泛型实参时：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-15.png" alt="image"></p><h5>5.3 泛型通配符</h5><p><font color="#ff0000">我们知道<code>Ingeter</code>是<code>Number</code>的一个子类，同时我们也验证过<code>Generic&lt;Ingeter&gt;</code>与<code>Generic&lt;Number&gt;</code>实际上是相同的一种基本类型。那么问题来了，在使用<code>Generic&lt;Number&gt;</code>作为形参的方法中，能否使用<code>Generic&lt;Ingeter&gt;</code>的实例传入呢？在逻辑上类似于<code>Generic&lt;Number&gt;</code>和<code>Generic&lt;Ingeter&gt;</code>是否可以看成具有父子关系的泛型类型呢？</font></p><p>为了弄清楚这个问题，我们使用<code>Generic&lt;T&gt;</code>这个泛型类继续看下面的例子：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-16.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic10-17.png" alt="image"></p><p>通过提示信息我们可以看到<code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。由此可以看出:<font color="#ff0000"><strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong></font>。</p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理<code>Generic&lt;Integer&gt;</code>类型的类，这显然与java中的多态理念相违背。因此我们需要一个在逻辑上可以表示同时是<code>Generic&lt;Integer&gt;</code>和<code>Generic&lt;Number&gt;</code>父类的引用类型。由此类型通配符应运而生。</p><p>我们可以将上面的方法改一下：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-18.png" alt="image"></p><p>类型通配符一般是使用<code>'?'</code>代替具体的类型实参，注意，<font color="#ff0000"><strong>此处’?'是类型实参，而不是类型形参</strong></font> 。重要说三遍！此处<code>'?'</code>是类型实参，而不是类型形参 ！ 此处<code>'?'</code>是类型实参，而不是类型形参 ！再直白点的意思就是，此处的<code>'?'</code>和<code>Number</code>、<code>String</code>、<code>Integer</code>一样都是一种实际的类型，可以把<code>'?'</code>看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是<code>'?'</code>；当操作类型时，不需要使用类型的具体功能时，只使用<code>Object</code>类中的功能。那么可以用<code>'?'</code>通配符来表示未知类型。</p><h5>5.4 泛型方法</h5><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-19.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));</span><br></pre></td></tr></table></figure><p>再对泛型方法进行一个比较，加深理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = key；</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//必须要声明E才行</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">setKey</span><span class="params">(E key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = (T)key;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">    <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>5.5 泛型方法与可变参数</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-20.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure><h5>5.6 静态方法与泛型</h5><p><strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</strong></p><p><img src="http://bloghello.oursnail.cn/javabasic10-21.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章全面介绍Java泛型中的基础及原理。本节主要介绍什么是泛型、泛型的核心特性、泛型与继承注意点、泛型与多态的原理以及泛型的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之克隆</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%8B%E9%9A%86/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之克隆/</id>
    <published>2019-02-19T11:27:35.679Z</published>
    <updated>2019-02-19T11:27:45.482Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候可能会问到克隆相关的深拷贝和浅拷贝，至少我是被问过的，所以对它们的了解是必要的，本篇文章探讨Java克隆方面的知识。</p><a id="more"></a><h2>1. Java中对象创建的两种方式</h2><p><code>clone</code>顾名思义就是复制， 在<code>Java</code>语言中， <code>clone</code>方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在<code>java</code>语言中，有几种方式可以创建对象呢？</p><ul><li>使用new操作符创建一个对象</li><li>使用clone方法复制一个对象</li></ul><p>那么这两种方式有什么相同和不同呢？ <code>new</code>操作符的本意是分配内存。程序执行到<code>new</code>操作符时， 首先去看<code>new</code>操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p><p>而<code>clone</code>在第一步是和<code>new</code>相似的， 都是分配内存，调用<code>clone</code>方法时，分配的内存和源对象（即调用<code>clone</code>方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，<code>clone</code>方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p><h2>2. 复制对象 or 复制引用</h2><p>在Java中，以下类似的代码非常常见：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-1.png" alt="image"></p><p>当<code>Person p1 = p;</code>执行之后， 是创建了一个新的对象吗？ 首先看打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br></pre></td></tr></table></figure><p>可已看出，打印的地址值是相同的，既然地址都是相同的，那么肯定是同一个对象。p和p1只是引用而已，他们都指向了一个相同的对象<code>Person(23, &quot;zhang&quot;)</code> 。 可以把这种现象叫做引用的复制。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%95%E7%94%A8%E5%A4%8D%E5%88%B6.png" alt="image"></p><p>而下面的代码是真真正正的克隆了一个对象。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-2.png" alt="image"></p><p>从打印结果可以看出，两个对象的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br><span class="line">com.pansoft.zhangjg.testclone.Person@67f1fba0</span><br></pre></td></tr></table></figure><p>以上代码执行完成后， 内存中的情景如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1.png" alt="image"></p><h2>3. 深拷贝 or 浅拷贝</h2><p><img src="http://bloghello.oursnail.cn/javabasic9-3.png" alt="image"></p><ul><li><p><code>age</code>是基本数据类型，那么对它的拷贝没有什么疑议，直接将一个4字节的整数值拷贝过来就行。</p></li><li><p><code>name</code>是<code>String</code>类型的， 它只是一个引用， 指向一个真正的<code>String</code>对象，那么对它的拷贝有两种方式：</p><ul><li>直接将源对象中的<code>name</code>的引用值拷贝给新对象的<code>name</code>字段</li><li>或者是根据原<code>Person</code>对象中的<code>name</code>指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给新拷贝的<code>Person</code>对象的<code>name</code>字段。</li></ul></li><li><p>这两种拷贝方式分别叫做浅拷贝和深拷贝。深拷贝和浅拷贝的原理如下图所示：</p></li></ul><p><img src="http://xiaozhao.oursnail.cn/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="image"></p><p>下面通过代码进行验证。如果两个<code>Person</code>对象的<code>name</code>的地址值相同， 说明两个对象的<code>name</code>都指向同一个<code>String</code>对象， 也就是浅拷贝， 而如果两个对象的<code>name</code>的地址值不同， 那么就说明指向不同的<code>String</code>对象， 也就是在拷贝<code>Person</code>对象的时候， 同时拷贝了<code>name</code>引用的<code>String</code>对象， 也就是深拷贝。验证代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-4.png" alt="image"></p><p>覆盖<code>Object</code>中的<code>clone</code>方法， 实现深拷贝.假设<code>body</code>类里面组合了<code>head</code>类。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-5.png" alt="image"></p><p><code>Body</code>中组合了<code>Head</code>，重写了<code>Body</code>的<code>clone</code>方法，那么显然第一个输出为<code>false</code>；但是没有对<code>Head</code>进行重写<code>clone</code>方法，那么他们指向的是同一个内存空间。即，没有重写<code>clone的Head</code>类只是浅拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : <span class="keyword">false</span></span><br><span class="line">body.head == body1.head : <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>如果要使<code>Body</code>对象在<code>clone</code>时进行深拷贝， 那么就要在<code>Body</code>的<code>clone</code>方法中，将源对象引用的<code>Head</code>对象也<code>clone</code>一份。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-6.png" alt="image"></p><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br></pre></td></tr></table></figure><p>由此，我们得到一个结论：如果想要深拷贝一个对象， 这个对象必须要实现<code>Cloneable</code>接口，实现<code>clone</code>方法，并且在<code>clone</code>方法内部，把该对象引用的其他对象也要<code>clone</code>一份 ， 这就要求这个被引用的对象必须也要实现<code>Cloneable</code>接口并且实现<code>clone</code>方法。</p><p>那么，按照上面的结论， <code>Body</code>类组合了<code>Head</code>类， 而<code>Head</code>类组合了<code>Face</code>类，要想深拷贝<code>Body</code>类，必须在<code>Body</code>类的<code>clone</code>方法中将<code>Head</code>类也要拷贝一份，但是在拷贝<code>Head</code>类时，默认执行的是浅拷贝，也就是说<code>Head</code>中组合的<code>Face</code>对象并不会被拷贝。验证代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-7.png" alt="image"></p><p>输出结果符合预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br><span class="line">body.head.face == body1.head.face : true</span><br></pre></td></tr></table></figure><p>内存结构图如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A12.png" alt="image"></p><p>那么此时<code>Head</code>中组合的<code>Face</code>又是一个浅拷贝。那么到底如何实现彻底的深拷贝呢？</p><p>对于上面的例子来说，怎样才能保证两个<code>Body</code>对象完全独立呢？只要在拷贝<code>Head</code>对象的时候，也将<code>Face</code>对象拷贝一份就可以了。这需要让<code>Face</code>类也实现<code>Cloneable</code>接口，实现<code>clone</code>方法，并且在在<code>Head</code>对象的<code>clone</code>方法中，拷贝它所引用的<code>Face</code>对象。修改的部分代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-8.png" alt="image"></p><p>再次运行上面的示例，得到的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br><span class="line">body.head.face == body1.head.face : false</span><br></pre></td></tr></table></figure><p>这说名两个<code>Body</code>已经完全独立了，他们间接引用的<code>face</code>对象已经被拷贝，也就是引用了独立的<code>Face</code>对象。内存结构图如下：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A13.png" alt="image"></p><p>显然，对于复杂的对象而言，用这种方式实现深拷贝是十分困难的。这时我们可以用序列化的方式来实现对象的深克隆。</p><h2>4. 序列化解决多层克隆问题</h2><p>首先由一个外部类<code>Outer</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-9.png" alt="image"></p><p>再来一个被序列化的类<code>Inner</code>:</p><p><img src="http://bloghello.oursnail.cn/javabasic9-10.png" alt="image"></p><p>再对克隆的对象进行测试：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-11.png" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">outer的name值为：outer</span><br><span class="line">Inner的name值为：inner</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">Java提高篇——对象克隆（复制）</a></li><li><a href="https://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="noopener">详解Java中的clone方法 – 原型模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试的时候可能会问到克隆相关的深拷贝和浅拷贝，至少我是被问过的，所以对它们的了解是必要的，本篇文章探讨Java克隆方面的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之异常</title>
    <link href="http://yoursite.com/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/02/19/java-basic/java基础之异常/</id>
    <published>2019-02-19T08:04:37.413Z</published>
    <updated>2019-02-19T08:04:51.886Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中，异常处理是一个不可绕开的话题，我们对于异常的处理已经非常熟练了，对于异常本身的概念、用法等不再赘述了，直接结合面试问题来加深对异常的理解吧。</p><a id="more"></a><p><code>Throwable</code> 可以用来表示任何可以作为异常抛出的类，分为两种： <code>Error</code> 和 <code>Exception</code>。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E6%A0%91.png" alt="image"></p><h2>1. 什么是Java异常</h2><p>异常是发生在程序执行过程中阻碍程序正常执行的错误事件。比如：用户输入错误数据、硬件故障、网络阻塞等都会导致出现异常。</p><p>只要在Java语句执行中产生了异常，<strong>一个异常对象就会被创建</strong>，JRE就会试图寻找异常处理程序来处理异常。如果有合适的异常处理程序，异常对象就会被异常处理程序接管，否则，将引发运行环境异常，JRE终止程序执行。</p><p>Java异常处理框架只能处理运行时错误，编译错误不在其考虑范围之内。</p><h2>2. Error和Exception的区别</h2><p>Error：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM出现的问题。</p><p>例如，Java虚拟机运行错误，当 JVM 不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机一般会选择线程终止。</p><h2>3. Java异常处理中有哪些关键字？</h2><ul><li><code>throw</code>:有时我们需要显式地创建并抛出异常对象来终止程序的正常执行。<code>throw</code>关键字用来抛出并处理运行时异常。</li><li><code>throws</code>:当我们抛出任何“被检查的异常(<code>checked exception</code>)”并不处理时，需要在方法签名中使用关键字<code>throws</code>来告知调用程序此方法可能会抛出的异常。调用方法可能会处理这些异常，或者同样用<code>throws</code>来将异常传给上一级调用方法。<code>throws</code>关键字后可接多个潜在异常，甚至是在<code>main()</code>中也可以使用<code>throws</code>。</li><li><code>try-catch</code>:我们在代码中用<code>try-catch</code>块处理异常。当然，一个<code>try</code>块之后可以有多个<code>catch</code>子句，<code>try-catch</code>块也能嵌套。每个<code>catch</code>块必须接受一个（且仅有一个）代表异常类型的参数。</li><li><code>finally</code>:<code>finally</code>块是可选的，并且只能配合<code>try-catch</code>一起使用。虽然异常终止了程序的执行，但是还有一些打开的资源没有被关闭，因此，我们能使用<code>finally</code>进行关闭。不管异常有没有出现，<code>finally</code>块总会被执行。</li></ul><h2>4. 描述一下异常的层级</h2><ul><li><code>Throwable</code>是所有异常的父类，它有两个直接子对象<code>Error</code>,<code>Exception</code>，其中<code>Exception</code>又被继续划分为“被检查的异常(<code>checked exception</code>)”和”运行时的异常（<code>runtime exception</code>,即不受检查的异常）”。 <code>Error</code>表示编译时和系统错误，通常不能预期和恢复，比如硬件故障、JVM崩溃、内存不足等。</li><li>被检查的异常（<code>Checked exception</code>）在程序中能预期，并要尝试修复，如<code>FileNotFoundException</code>。我们必须捕获此类异常，并为用户提供有用信息和合适日志来进行调试。<code>Exception</code>是所有被检查的异常的父类。</li><li>运行时异常（<code>Runtime Exception</code>）又称为不受检查异常，源于糟糕的编程。比如我们检索数组元素之前必须确认数组的长度，否则就可能会抛出<code>ArrayIndexOutOfBoundException</code>运行时异常。<code>RuntimeException</code>是所有运行时异常的父类。</li></ul><h2>5. 描述Java 7 ARM(Automatic Resource Management，自动资源管理)特征和多个catch块的使用</h2><p>如果一个<code>try</code>块中有多个异常要被捕获，<code>catch</code>块中的代码会变丑陋的同时还要用多余的代码来记录异常。有鉴于此，Java 7的一个新特征是：一个<code>catch</code>子句中可以捕获多个异常。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(IOException | SQLException | Exception ex)&#123;</span><br><span class="line">     logger.error(ex);</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> MyException(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况下，当忘记关闭资源或因资源耗尽出现运行时异常时，我们只是用<code>finally</code>子句来关闭资源。这些异常很难调试，我们需要深入到资源使用的每一步来确定是否已关闭。因此，Java 7用<code>try-with-resources</code>进行了改进：在<code>try</code>子句中能创建一个资源对象，当程序的执行完<code>try-catch</code>之后，运行环境自动关闭资源。</p><blockquote><p>利用Try-Catch-Finally管理资源（旧的代码风格）：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>);<span class="comment">//可能发生异常1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read();<span class="comment">//可能发生异常2</span></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">            input.close();<span class="comment">//可能发生异常3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<code>try</code>语句块抛出一个异常，然后<code>finally</code>语句块被执行。同样假设<code>finally</code>语句块也抛出了一个异常。那么哪个异常会根据调用栈往外传播？</p><p><font color="#ff0000">即使<code>try</code>语句块中抛出的异常与异常传播更相关，最终还是<code>finally</code>语句块中抛出的异常会根据调用栈向外传播。</font></p><blockquote><p>在java7中，对于上面的例子可以用try-with-resource 结构这样写：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#ff0000">当<code>try</code>语句块运行结束时，<code>FileInputStream</code> 会被自动关闭。这是因为<code>FileInputStream</code> 实现了java中的<code>java.lang.AutoCloseable</code>接口。所有实现了这个接口的类都可以在<code>try-with-resources</code>结构中使用。</font></p><p><strong>当<code>try-with-resources</code>结构中抛出一个异常，同时<code>FileInputStream</code>被关闭时（调用了其<code>close</code>方法）也抛出一个异常，<code>try-with-resources</code>结构中抛出的异常会向外传播，而<code>FileInputStream</code>被关闭时抛出的异常被抑制了</strong>。</p><blockquote><p>你可以在块中使用多个资源而且这些资源都能被自动地关闭。下面是例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(  FileInputStream     input         = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">          BufferedInputStream bufferedInput = <span class="keyword">new</span> BufferedInputStream(input)</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = bufferedInput.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">    data = bufferedInput.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些资源将按照他们被创建顺序的<strong>逆序</strong>来关闭。首先<code>BufferedInputStream</code> 会被关闭，然后<code>FileInputStream</code>会被关闭。</p><p>这个<code>try-with-resources</code>结构里不仅能够操作java内置的类。你也可以在自己的类中实现<code>java.lang.AutoCloseable</code>接口，然后在<code>try-with-resources</code>结构里使用这个类。</p><p><code>AutoClosable</code> 接口仅仅有一个方法，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoClosable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何实现了这个接口的方法都可以在<code>try-with-resources</code>结构中使用。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoClosable</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoClosable doing it!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoClosable closed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doIt()</code>是方法不是<code>AutoClosable</code> 接口中的一部分，之所以实现这个方法是因为我们想要这个类除了关闭方法外还能做点其他事。</p><p>下面是<code>MyAutoClosable</code> 在<code>try-with-resources</code>结构中使用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myAutoClosable</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(MyAutoClosable myAutoClosable = <span class="keyword">new</span> MyAutoClosable())&#123;</span><br><span class="line">        myAutoClosable.doIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyAutoClosable doing it!</span><br><span class="line">MyAutoClosable closed!</span><br></pre></td></tr></table></figure><p>通过上面这些你可以看到，不论<code>try-catch</code>中使用的资源是自己创造的还是java内置的类型，<code>try-with-resources</code>都是一个能够确保资源能被正确地关闭的强大方法。</p><h2>6. 在Java中throw与throws关键字之间的区别？</h2><p>throws用于在方法签名中声明此方法可能抛出的异常，而throw关键字则是中断程序的执行并移交异常对象到运行时进行处理。</p><h2>7. 在Java中怎么写自定义的异常？</h2><p>我们能继承Exception类或其任何子类来实现自己的自定义异常类。这自定义异常类可以有自己变量和方法来传递错误代码或其它异常相关信息来处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyBikeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code = ResponseEnum.ERROR.getCode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HappyBikeException</span><span class="params">(Integer code,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HappyBikeException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>8. Java中final,finally,finalize的区别？</h2><p>这是一个垃圾问题，很想删除掉，但是考虑到新手，还是保留一下吧，至少从单词上有那么一点点像。</p><p><code>final</code>和<code>finally</code>在Java中是关键字，而finalize则是一个方法。</p><p><code>final</code>关键字使得类变量不可变，避免类被其它类继承或方法被重写。<code>finally</code>跟<code>try-catch</code>块一起使用，即使是出现了异常，其子句总会被执行，通常，<code>finally</code>子句用来关闭相关资源。<code>finally</code>方法中的对象被销毁之前会被垃圾回收。</p><h2>9. 在main方法抛出异常时发生了什么？</h2><p>答：当<code>main</code>方法抛出异常时，Java运行时间终止并在控制台打印异常信息和栈轨迹。</p><h2>10. catch子句能为空吗？</h2><p><code>catch</code>后面括号里面不能为空。</p><p>答：可以有空的<code>catch</code>子句，但那是最糟糕的编程，因为那样的话，异常即使被捕获，我们也得不到任何的有用信息，对于调试来说会是个噩梦，因此，编程时永远不要有空的<code>catch</code>子句。<code>Catch</code>子句中至少要包含一个日志语句输出到控制台或保存到日志文件中。</p><h2>11. 提供一些Java异常处理的最佳实践。</h2><ul><li>使用具体的异常方便调试</li><li>程序中早点抛出异常</li><li>捕获异常后让调用者处理异常</li><li>使用Java 7 ARM功能确保资源关闭或者用finally子句正确地关闭它们</li><li>为了调试需要总是记录异常信息</li><li>用多个catch子句实现更完全的关闭</li><li>你自己的应用API中用自定义的异常来抛出单种类型异常</li><li>遵循命名规定，以异常结束</li><li>在Javadoc中用@throws来标注方法抛出的异常</li><li><strong>处理异常是有花销的，因此只有在必要时才抛出</strong>。否则，你会扑空或毫无收获。</li></ul><h2>12. try、catch、finally三个语句块应注意的问题</h2><ul><li>try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。</li><li>try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。</li><li>多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，并且匹配catch语句的顺序是由上到下。</li><li>无论程序是否有异常，并且无论之间try-catch是否顺利执行完毕，都会执行finally语句。在以下特殊情况下，finally块不会执行：在finally语句块中发生异常；在前面代码中使用了System.exit()退出程序；程序所在线程死亡；关闭cpu。</li><li><strong>⭐当程序执行try块，catch块时遇到return语句或者throw语句，这两个语句都会导致该方法立即结束，所以系统并不会立即执行这两个语句，而是去寻找该异常处理流程中的finally块，如果没有finally块，程序立即执行return语句或者throw语句，方法终止。如果有finally块，系统立即开始执行finally块，只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句，如果finally块里也使用了return或throw等导致方法终止的语句，则finally块已经终止了方法，不用再跳回去执行try块、catch块里的任何代码了。</strong></li></ul><h2>13. 解释Java中的异常处理流程</h2><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E5%B8%B8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="image"></p><h2>异常处理完成以后，Exception对象会发生什么变化？</h2><p>Exception对象会在下一个垃圾回收过程中被回收掉。</p><h2>请写出 5 种常见到的runtime exception。</h2><ul><li><code>NullPointerException</code>：当操作一个空引用时会出现此错误。</li><li><code>NumberFormatException</code>：数据格式转换出现问题时出现此异常。</li><li><code>ClassCastException</code>：强制类型转换类型不匹配时出现此异常。</li><li><code>ArrayIndexOutOfBoundsException</code>：数组下标越界，当使用一个不存在的数组下标时出现此异常。</li><li><code>ArithmeticException</code>：数学运行错误时出现此异常</li></ul><p>参考：</p><ul><li><a href="http://www.importnew.com/7383.html" target="_blank" rel="noopener">http://www.importnew.com/7383.html</a></li><li><a href="http://www.importnew.com/7541.html" target="_blank" rel="noopener">http://www.importnew.com/7541.html</a></li><li><a href="http://www.importnew.com/7820.html" target="_blank" rel="noopener">http://www.importnew.com/7820.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中，异常处理是一个不可绕开的话题，我们对于异常的处理已经非常熟练了，对于异常本身的概念、用法等不再赘述了，直接结合面试问题来加深对异常的理解吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>自己实现一个简单的web服务器</title>
    <link href="http://yoursite.com/2019/02/18/thread/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2019/02/18/thread/自己实现一个简单的web服务器/</id>
    <published>2019-02-18T12:28:38.517Z</published>
    <updated>2019-02-18T12:40:30.144Z</updated>
    
    <content type="html"><![CDATA[<p>这里涉及网络编程的基本知识以及HTTP协议的基本认识，下面来一步一步实现一下最简单的一个web服务器。</p><a id="more"></a><h2>一、用户请求域名到底发送了什么信息来</h2><p>如果服务端都不知道客户端发来的是什么，那何谈对内容的解析呢？所以我们首先在服务端解析客户端的访问信息，比如我们比较关心的是请求的是什么路径：</p><p><img src="http://bloghello.oursnail.cn/thread17-1.png" alt="image"></p><p>此时我们访问地址： localhost:8888 打印出来的结果为：</p><p><img src="http://bloghello.oursnail.cn/thread17-2.png" alt="image"></p><p>其实对于我们这种比较简单的实现来说，红框的信息已经足够了。我们只要知道客户端要发来的资源名字是什么，我们根据这个名字取找响应的资源返回给客户端展示即可。由于我其实请求的是根路径，所以是<code>/</code>。如果我在这里请求 localhost:8888/index.html 那么就会显示 <code>GET /index.html HTTP/1.1</code>这样的信息。不再演示。</p><p>但是上面的写法是存在问题的，仅仅是演示而用，因为它会一直等待输入。</p><p>那么，不用<code>while</code>一直等待，而且只需要第一行即可，那么可以这样写：</p><p><img src="http://bloghello.oursnail.cn/thread17-3.png" alt="image"></p><p>好了，不能总之只接收吧，我们服务端要给客户端点什么。</p><h2>二、服务端如何响应资源给客户端展示</h2><p>首先我们得有资源才能展示，假设我们要展示<code>index.html</code>，我们将其暂时放在<code>F:/webrooot</code>下。</p><p>内容暂时为：</p><p><img src="http://bloghello.oursnail.cn/thread17-4.png" alt="image"></p><p>只是展示一下欢迎信息而已。服务端就需要读取这个文件，然后以流的形式发送给客户端的浏览器上，浏览器再解析展示。</p><p><img src="http://bloghello.oursnail.cn/thread17-5.png" alt="image"></p><p>此时再去访问页面，就会显示欢迎的信息啦！</p><p><img src="http://bloghello.oursnail.cn/thread17-6.png" alt="image"></p><p>这里没有关闭流，也没有关闭<code>socket</code>，不过下面都会关闭掉。这个不重要，重要的是，这玩意都是在主线程中做的，显然不如多线程来的快，并且全写在主线程里，肯定是不够好的。下面就用多线程来实现。</p><h2>三、普通的多线程实现方式</h2><p><img src="http://bloghello.oursnail.cn/thread17-7.png" alt="image"></p><p>就是在这个线程中处理数据和返回数据。</p><p><img src="http://bloghello.oursnail.cn/thread17-8.png" alt="image"></p><p>其很简单，但是如果我想显示一张图片呢？</p><p>比如我的根目录下有一张图片叫做：<code>hh.jpg</code></p><p><img src="http://bloghello.oursnail.cn/thread17-9.png" alt="image"></p><p>很显然现在还是无法展示的，原因是我这里写死了是以<code>text/html</code>的形式响应，但是图片正确的响应是<code>image/jpeg</code>这种格式。</p><p>所以我们不能无脑写死，要进行适当的判断才行。下面贴出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//根目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String webroot = <span class="string">"F:\\webroot\\"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket client;</span><br><span class="line">    InputStream ins;</span><br><span class="line">    OutputStream out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存放类型，比如jpg对应的是image/jpeg，这是http协议规定的每种类型的响应格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; contentMap =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        contentMap.put(<span class="string">"html"</span>,<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        contentMap.put(<span class="string">"jpg"</span>,<span class="string">"image/jpeg"</span>);</span><br><span class="line">        contentMap.put(<span class="string">"png"</span>,<span class="string">"image/jpeg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket client)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ins = client.getInputStream();</span><br><span class="line">            out = client.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            go();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求内容</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(ins));</span><br><span class="line">        <span class="comment">//获取到请求的资源名称</span></span><br><span class="line">        String line = reader.readLine().split(<span class="string">" "</span>)[<span class="number">1</span>].replace(<span class="string">"/"</span>,<span class="string">"\\"</span>);</span><br><span class="line">        <span class="keyword">if</span>(line.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">            line += <span class="string">"index.html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">        <span class="comment">//拼接起来就是资源的完整路径</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(webroot + line);</span><br><span class="line">        <span class="comment">//判断是否存在，存在则响应内容，不存在则告知不存在</span></span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="comment">//给用户响应</span></span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(out);</span><br><span class="line">            InputStream i = <span class="keyword">new</span> FileInputStream(webroot + line);</span><br><span class="line">            <span class="comment">//由于需要将图片也要传给前端，再用这个就不好办了，得用普通的文件输入流</span></span><br><span class="line"><span class="comment">//          BufferedReader fr = new BufferedReader(new InputStreamReader(i));</span></span><br><span class="line">            pw.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">            <span class="comment">//返回的类型是动态判断的，图片用图片的类型，文本用文本的类型</span></span><br><span class="line">            String s = contentMap.get(line.substring(line.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>,line.length()));</span><br><span class="line">            System.out.println(<span class="string">"返回的类型为："</span>+ s);</span><br><span class="line">            pw.println(<span class="string">"Content-Type: "</span> + s);</span><br><span class="line">            pw.println(<span class="string">"Content-Length:"</span> + i.available());</span><br><span class="line">            pw.println(<span class="string">"Server: hello-server"</span>);</span><br><span class="line">            pw.println(<span class="string">"Date:"</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">            pw.println(<span class="string">""</span>);</span><br><span class="line">            pw.flush();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写入输出流中通过PrintWriter发给浏览器</span></span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ( (len = i.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            pw.flush();</span><br><span class="line">            pw.close();</span><br><span class="line">            i.close();</span><br><span class="line">            reader.close();</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuffer error = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            error.append(<span class="string">"HTTP /1.1 400 file not found /r/n"</span>);</span><br><span class="line">            error.append(<span class="string">"Content-Type:text/html \r\n"</span>);</span><br><span class="line">            error.append(<span class="string">"Content-Length:20 \r\n"</span>).append(<span class="string">"\r\n"</span>);</span><br><span class="line">            error.append(<span class="string">"&lt;h1 &gt;File Not Found..&lt;/h1&gt;"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.write(error.toString().getBytes());</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,你会发现，我还添加了判断资源存在不存在的逻辑，这样显得更加健全一点。</p><p>当找得到资源得时候：</p><p><img src="http://bloghello.oursnail.cn/thread17-10.png" alt="image"></p><p>当找不到资源得时候：</p><p><img src="http://bloghello.oursnail.cn/thread17-11.png" alt="image"></p><h2>四、线程池方式</h2><p>其实很简单，线程池的优势以前也说过，不赘述，直接贴一下代码结束。</p><p><img src="http://bloghello.oursnail.cn/thread17-12.png" alt="image"></p><p>至此，我们完成了一个比较简单的web服务器的开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里涉及网络编程的基本知识以及HTTP协议的基本认识，下面来一步一步实现一下最简单的一个web服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础之JDK动态代理</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/java基础之JDK动态代理/</id>
    <published>2019-02-17T12:16:53.333Z</published>
    <updated>2019-02-17T12:27:22.698Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式可以说是经常面试被问的一个东西，因为spring aop的实现原理就是基于它，关于它，只要记住，它是运行时动态生成的一个代理类。在这个基础上，再去看看它底层源码，其实JDK已经帮我们最大程度上封装成简单的函数了，我们只需要传入几个参数就可以生成对应的代理对象。</p><a id="more"></a><h2>代理模式是什么</h2><p>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p><ul><li><code>RealSubject</code> 是原对象（本文把原对象称为&quot;委托对象&quot;），<code>Proxy</code> 是代理对象。</li><li><code>Subject</code> 是委托对象和代理对象都共同实现的接口。</li><li><code>Request()</code> 是委托对象和代理对象共同拥有的方法。</li></ul><h2>结合生活理解代理模式</h2><p>要理解代理模式很简单，其实生活当中就存在代理模式：</p><blockquote><p>我们购买火车票可以去火车站买，但是也可以去火车票代售处买，此处的火车票代售处就是火车站购票的代理，即我们在代售点发出买票请求，代售点会把请求发给火车站，火车站把购买成功响应发给代售点，代售点再告诉你。</p><p>但是代售点只能买票，不能退票，而火车站能买票也能退票，因此代理对象支持的操作可能和委托对象的操作有所不同。</p></blockquote><h2>Java实现静态代理示例</h2><p><img src="http://bloghello.oursnail.cn/javabasic8-1.png" alt="image"></p><p>代理的实现分为：</p><ul><li>静态代理</li></ul><p>代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 <code>class</code> 文件。</p><ul><li>动态代理</li></ul><p>代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 <code>class</code> 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p><h2>Java 实现动态代理</h2><h5>几个重要名词:</h5><ul><li>委托类和委托对象：委托类是一个类，委托对象是委托类的实例，即原类。</li><li>代理类和代理对象：代理类是一个类，代理对象是代理类的实例。</li></ul><h5>Java实现动态代理的大致步骤如下:</h5><ol><li>定义一个委托类和公共接口。</li><li>自己定义一个类（调用处理器类，即实现 <code>InvocationHandler</code> 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括<code>Preprocess</code>和<code>Postprocess</code>），即代理类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。</li><li>生成代理对象（当然也会生成代理类），需要为他指定(1)类加载器对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li></ol><h5>Java 实现动态代理主要涉及以下几个类:</h5><ul><li><code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 <code>Proxy</code> 类生成的代理类都继承了 <code>Proxy</code> 类，即 <code>DynamicProxyClass extends Proxy</code>。</li><li><code>java.lang.reflect.InvocationHandler</code>: 这里称他为&quot;调用处理器&quot;，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 <code>InvocationHandler</code> 接口。</li></ul><h5>Proxy 类主要方法为：</h5><p><img src="http://bloghello.oursnail.cn/javabasic8-2.png" alt="image"></p><ul><li>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区）</li><li>第二个参数是接口（表明你这个代理类需要实现哪些接口）</li><li>第三个参数是调用处理器类实例（指定代理类中具体要干什么）。</li><li>这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用<code>newProxyInstance()</code>时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：</li></ul><p><img src="http://bloghello.oursnail.cn/javabasic8-3.png" alt="image"></p><p><code>Proxy</code> 类还有一些静态方法，比如：</p><ul><li><code>InvocationHandler getInvocationHandler(Object proxy)</code>: 获得代理对象对应的调用处理器对象。</li><li><code>Class getProxyClass(ClassLoader loader, Class[] interfaces)</code>: 根据类加载器和实现的接口获得代理类。</li></ul><p><code>Proxy</code> 类中有一个映射表，映射关系为：(<code>&lt;ClassLoader&gt;</code>,(<code>&lt;Interfaces&gt;</code>,<code>&lt;ProxyClass&gt;</code>) )，可以看出一级key为类加载器，根据这个一级key获得二级映射表，二级key为接口数组，因此可以看出：一个类加载器对象和一个接口数组确定了一个代理类。</p><p>我们写一个简单的例子来阐述 Java 实现动态代理的整个过程：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-4.png" alt="image"></p><p><code>InvocationHandler</code> 接口中有方法：<code>invoke(Object proxy, Method method, Object[] args)</code></p><p>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，<strong>第一个参数是代理对象</strong>（表示哪个代理对象调用了method方法，传递来的是），<strong>第二个参数是 Method 对象</strong>（表示哪个方法被调用了），<strong>第三个参数是指定调用方法的参数</strong>。</p><p>动态生成的代理类具有几个特点：</p><ul><li>继承 <code>Proxy</code> 类，并实现了在<code>Proxy.newProxyInstance()</code>中提供的接口数组。</li><li><code>public final</code>。</li><li>命名方式为 <code>$ProxyN</code>，其中N会慢慢增加，一开始是 <code>$Proxy1</code>，接下来是<code>$Proxy2</code>…</li><li>有一个参数为 <code>InvocationHandler</code> 的构造函数。这个从 <code>Proxy.newProxyInstance()</code> 函数内部的<code>clazz.getConstructor(new Class[] { InvocationHandler.class })</code> 可以看出。</li></ul><p>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p><blockquote><p>不难发现，代理类的实现是有很多共性的（重复代码），动态代理的好处在于避免了这些重复代码，只需要关注操作。</p></blockquote><h2>小栗子</h2><p>假设模拟一个场景，买衣服，正常情况所有人买这件衣服要100块钱。</p><p>定义一个销售接口：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-5.png" alt="image"></p><p>一个具体的实现类：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-6.png" alt="image"></p><p>那么正常情况大家都要花100才能买这件衣服。但是现在对会员做活动，会员打5折。怎么做呢？正常思维是：增加一个接口，甚至更糟的想法是修改一下这个实现类，都是不好的，那么我们是否想过这样的方案：新建一个新的类，让这个代理类去做相应的逻辑呢？既不用修改原来的代码，而且还很简单就能实现。</p><p>现在写一个代理类：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-7.png" alt="image"></p><p>那么调用的时候，一个是会员，一个是普通用户，根据身份调不同的方法即可：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-8.png" alt="image"></p><h2>Java 动态代理的内部实现</h2><p>现在我们就会有一个问题： Java 是怎么保证代理对象调用的任何方法都会调用 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法的？</p><p>这就涉及到动态代理的内部实现。假设有一个接口 <code>Subject</code>，且里面有 <code>int request(int i)</code> 方法，则生成的代理类大致如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-9.png" alt="image"></p><p>通过上面的方法就成功调用了 <code>invoke()</code> 方法，所以这是代理类中已经注定要去执行 <code>invoke()</code> 方法了。</p><p>有一篇文章比较生动地阐述了动态代理的含义：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513926&amp;idx=1&amp;sn=1c43c5557ba18fed34f3d68bfed6b8bd&amp;chksm=80d67b85b7a1f2930ede2803d6b08925474090f4127eefbb267e647dff11793d380e09f222a8#rd" target="_blank" rel="noopener">Java帝国之动态代理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式可以说是经常面试被问的一个东西，因为spring aop的实现原理就是基于它，关于它，只要记住，它是运行时动态生成的一个代理类。在这个基础上，再去看看它底层源码，其实JDK已经帮我们最大程度上封装成简单的函数了，我们只需要传入几个参数就可以生成对应的代理对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之注解</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/java基础之注解/</id>
    <published>2019-02-17T11:44:28.868Z</published>
    <updated>2019-02-17T11:44:49.892Z</updated>
    
    <content type="html"><![CDATA[<p>注解是一系列元数据，它提供数据用来解释程序代码，注释是给人看的，注解是给编译器看的，因此注解只在编译器有效。注解的实现原理涉及反射和动态代理，关于反射已经在前面说过，动态代理还没说，留在下一节。</p><a id="more"></a><h2>注解语法</h2><p>相信有不少的人员会认为注解的地位不高。其实同 <code>classs</code> 和 <code>interface</code> 一样，注解也属于一种类型。它是在 Java SE 5.0 版本中开始引入的概念。</p><h2>注解的定义</h2><p>注解通过 <code>@interface</code> 关键字进行定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><p>你可以简单理解为创建了一张名字为 <code>TestAnnotation</code> 的标签。</p><h2>注解的使用</h2><p>上面创建了一个注解，那么注解的的使用方法是什么呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。</p><h2>什么是元注解</h2><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p><p>元标签有 <code>@Retention</code>、<code>@Documented</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Repeatable</code> 5 种。</p><blockquote><p>@Retention</p></blockquote><p><code>Retention</code> 的英文意为保留期的意思。当 <code>@Retention</code> 应用到一个注解上的时候，它解释说明了这个<strong>注解的的存活时间</strong>。</p><ul><li><code>RetentionPolicy.SOURCE</code> 注解只在<strong>源码阶段</strong>保留，在编译器进行<strong>编译时它将被丢弃</strong>忽视。</li><li><code>RetentionPolicy.CLASS</code> 注解<strong>只被保留到编译进行</strong>的时候，它并<strong>不会被加载到 JVM</strong> 中。</li><li><code>RetentionPolicy.RUNTIME</code> 注解可以<strong>保留到程序运行</strong>的时候，它<strong>会被加载进入到 JVM</strong> 中，所以在程序运行时可以获取到它们。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Documented</p></blockquote><p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 <code>Javadoc</code> 中去。</p><blockquote><p>@Target</p></blockquote><p><code>Target</code> 是目标的意思，<code>@Target</code> 指定了注解运用的地方。</p><ul><li><code>ElementType.ANNOTATION_TYPE</code> 可以给一个注解进行注解</li><li><code>ElementType.CONSTRUCTOR</code> 可以给构造方法进行注解</li><li><code>ElementType.FIELD</code> 可以给属性进行注解</li><li><code>ElementType.LOCAL_VARIABLE</code> 可以给局部变量进行注解</li><li><code>ElementType.METHOD</code> 可以给方法进行注解</li><li><code>ElementType.PACKAGE</code> 可以给一个包进行注解</li><li><code>ElementType.PARAMETER</code> 可以给一个方法内的参数进行注解</li><li><code>ElementType.TYPE</code> 可以给一个类型进行注解，比如类、接口、枚举</li></ul><blockquote><p>@Inherited</p></blockquote><p><code>Inherited</code> 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个<strong>超类被 <code>@Inherited</code> 注解过的注解进行注解</strong>的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个被@Inherited注解的注解@Test</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类被@Test注解，即上面说的被@Inherited 注解过的注解进行注解</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么class B也拥有@Test注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Repeatable</p></blockquote><p><code>Repeatable</code> 自然是可重复的意思。<code>@Repeatable</code> 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照规定，它里面必须要有一个 value 的属性</span></span><br><span class="line"><span class="comment">//属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。</span></span><br><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Repeatable 后面括号中的类相当于一个容器注解</span></span><br><span class="line"><span class="comment">//什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    <span class="function">String <span class="title">role</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有了上面两个注解，Persons相当于一个总标签</span></span><br><span class="line"><span class="comment">//他里面可以放任意多个子标签，这些子标签类型是Person</span></span><br><span class="line"><span class="comment">//并且是存放于这个总标签的Person类型的数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么既然有了总标签和放子标签的数组，那么，下面就可以定义子标签</span></span><br><span class="line"><span class="comment">//子标签的类型自然就是Person，里面这里假设定义role属性</span></span><br><span class="line"><span class="comment">//就是说这些子标签表示人的角色。</span></span><br><span class="line"><span class="comment">//自然也就支持多种角色，那么定义多次即可。如下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"artist"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"coder"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"PM"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>注解的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有默认值的时候，可以不执行属性</span></span><br><span class="line"><span class="meta">@TestAnnotation</span>(id=<span class="number">3</span>,msg=<span class="string">"hello annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些规则：</p><ul><li>修饰符只能是<code>public</code> 或默认(<code>default</code>)</li><li>参数成员只能用基本类型<code>byte</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>double</code>,<code>boolean</code>,<code>char</code>八种基本类型和<code>String</code>,<code>Enum</code>,<code>Class</code>,<code>annotations</code>及这些类型的数组</li><li>如果只有一个参数成员,最好将名称设为”value”</li><li>注解元素必须有确定的值,可以在注解中定义默认值,也可以使用注解时指定,非基本类型的值不可为null,常使用空字符串或0作默认值</li><li>在表现一个元素存在或缺失的状态时,定义一下特殊值来表示,如空字符串或负值</li></ul><h2>Java 预置的注解</h2><blockquote><p>@Deprecated</p></blockquote><p>这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。</p><blockquote><p>@Override</p></blockquote><p>这个大家应该很熟悉了，提示子类要复写父类中被 <code>@Override</code> 修饰的方法</p><blockquote><p>@SuppressWarnings</p></blockquote><p>阻止警告的意思。之前说过调用被 <code>@Deprecated</code> 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 <code>@SuppressWarnings</code> 达到目的。</p><blockquote><p>@SafeVarargs</p></blockquote><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 <code>unchecked</code> 这样的警告。</p><blockquote><p>@FunctionalInterface</p></blockquote><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。</p><p>函数式接口 (<code>Functional Interface</code>) 就是一个具有一个方法的普通接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行线程开发中常用的 <code>Runnable</code> 就是一个典型的函数式接口，上面源码可以看到它就被 <code>@FunctionalInterface</code> 注解。</p><p>可能有人会疑惑，函数式接口标记有什么用，这个原因是函数式接口可以很容易转换为 <code>Lambda</code> 表达式。</p><h2>注解与反射</h2><blockquote><p>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者是 getAnnotations() 方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里举个例子：</p><p>首先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个类，打上这个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再main函数中拿到注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断Test.class中是否存在TestAnnotation注解</span></span><br><span class="line">        <span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(hasAnnotation)&#123;</span><br><span class="line">            System.out.println(<span class="string">"注解存在..."</span>);</span><br><span class="line">            <span class="comment">//从Test类中拿出TestAnnotation注解</span></span><br><span class="line">            TestAnnotation annotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">            <span class="comment">//拿到注解之后，可以拿出注解中的属性对应的默认值</span></span><br><span class="line">            System.out.println(annotation.id());</span><br><span class="line">            System.out.println(annotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面演示的是从类上拿到注解，对于属性、方法同样都可以用反射拿到注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>(value=<span class="string">"hi"</span>)</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Perform</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*************拿到属性上的注解****************/</span></span><br><span class="line">            Field a = Test.class.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">            a.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//获取一个成员变量上的注解</span></span><br><span class="line">            Check check = a.getAnnotation(Check.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( check != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                System.out.println(<span class="string">"check value:"</span>+check.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************拿到方法上的注解****************/</span></span><br><span class="line">            Method testMethod = Test.class.getDeclaredMethod(<span class="string">"testMethod"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( testMethod != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// 获取方法中的注解</span></span><br><span class="line">                Annotation[] ans = testMethod.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.length;i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"method testMethod annotation:"</span>+ans[i].annotationType().getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>注解实现原理</h2><p>在上面获取注解时是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestAnnotation annotation = Test.class.getAnnotation(TestAnnotation.class);</span><br></pre></td></tr></table></figure><p>它是从<code>class</code>中获取出<code>TestAnnotation</code>注解的，所以肯定是在某个时候注解被加入到<code>class</code>结构中去了。</p><ul><li>首先，我们知道从<code>java</code>源码到<code>class</code>字节码是由编译器完成的，编译器会对<code>java</code>源码进行解析并生成<code>class</code>文件。</li><li>而注解也是在编译时由编译器进行处理，编译器会对注解符号处理并附加到<code>class</code>结构中</li><li>根据<code>jvm</code>规范，<code>class</code>文件结构是严格有序的格式，唯一可以附加信息到<code>class</code>结构中的方式就是保存到<code>class</code>结构的<code>attributes</code>属性中</li><li>我们知道对于类、字段、方法，在<code>class</code>结构中都有自己特定的表结构，而且各自都有自己的属性，而对于注解，作用的范围也可以不同，可以作用在类上，也可以作用在字段或方法上，这时编译器会对应将注解信息存放到类、字段、方法自己的属性上。</li><li>在我们的<code>Test</code>类被编译后，在对应的<code>Test.class</code>文件中会包含一个<code>RuntimeVisibleAnnotations</code>属性，由于这个注解是作用在类上，所以此属性被添加到类的属性集上。即<code>TestAnnotation</code>注解的键值对<code>value=test</code>会被记录起来。</li><li>而当<code>JVM</code>加载<code>Test.class</code>文件字节码时，就会将<code>RuntimeVisibleAnnotations</code>属性值保存到<code>Test</code>的<code>Class</code>对象中，于是就可以通过<code>Test.class.getAnnotation(TestAnnotation.class)</code>获取到<code>Test</code>注解对象，进而再通过<code>Test</code>注解对象获取到<code>Test</code>里面的属性值。</li><li><code>Test</code>注解对象是什么？其实注解被编译后的本质就是一个继承<code>Annotation</code>接口的接口。所以<code>@TestAnnotation</code>其实就是“public interface TestAnnotation extends Annotation”</li><li>当我们通过<code>Test.class.getAnnotation(TestAnnotation.class)</code>调用时，<code>JDK</code>会通过动态代理生成一个实现了<code>TestAnnotation</code>接口的对象，并把将<code>RuntimeVisibleAnnotations</code>属性值设置进此对象中，此对象即为<code>TestAnnotation</code>注解对象，通过它的<code>value()</code>方法就可以获取到注解值。</li></ul><h2>总结注解到底是什么以及注解到底有什么应用场景</h2><p>注释是给人看的，<strong>注解是给编译器看的</strong>，以<code>@Override</code>注解为例，他的作用是告诉编译器他所注解的方法是重写父类中的方法，这样编译器就会去检查父类是否存在这个方法，以及这个方法的签名与父类是否相同。</p><p><strong>注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用</strong>；</p><p>也就是说，注解只是描述java代码的代码，能被编译器解析，<strong>只有编译器或者虚拟机来主动解析他的时候，他才可能发挥作用</strong>。</p><p>注解分为三类，元注解，java自带的标准注解以及自定义注解。</p><p>注解的使用场景：</p><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><p>我觉得这些说的太空洞了，注解在<code>spring</code>中就是非常常用的技术，比如，我指定这个类是<code>@Controller</code>或者<code>@Service</code>之类，那么我配置包扫描将其类路径全部扫描到后，启动容器的时候，这些类就会自动被spring所管理，即自动向<code>spring</code>注册，以后要注入这些组件的时候，就直接从<code>spring</code>的<code>IOC</code>容器中取出来即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注解是一系列元数据，它提供数据用来解释程序代码，注释是给人看的，注解是给编译器看的，因此注解只在编译器有效。注解的实现原理涉及反射和动态代理，关于反射已经在前面说过，动态代理还没说，留在下一节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之冰川表面</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%B0%E5%B7%9D%E8%A1%A8%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/Java基础之冰川表面/</id>
    <published>2019-02-17T10:30:34.398Z</published>
    <updated>2019-02-17T10:30:59.111Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是罗列一些关于java基础的核心点，这些点是基础中的基础，也是重点中的重点。为什么本篇文章叫做冰川表面呢？我想表达的意思是，这些基础只是一个引子，背后牵扯出来的东西可能会很多，面试往往都是从基础的知识点慢慢深入挖掘的，所以千万不能忽视对于它们的复习。</p><a id="more"></a><h1>一、关键字</h1><h2>final</h2><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，<code>final</code> 使数值不变；</li><li>对于引用类型，<code>final</code> 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>2. 方法</strong></p><p>声明方法不能被子类覆盖。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是覆盖基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h2>static</h2><p><strong>1. 静态变量</strong></p><p>静态变量在内存中只存在一份，只在类初始化时赋值一次。</p><ul><li>静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;        <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（<code>abstract</code>）。</p><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><p><strong>4. 静态内部类</strong></p><p>内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure><p>在使用静态变量和方法时不用再指明 <code>ClassName</code>，从而简化代码，但可读性大大降低。</p><p><strong>6. 变量赋值顺序</strong></p><p>静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行，静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。</p><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h1>二、Object 通用方法</h1><h2>概览</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2>equals()</h2><p><strong>1. equals() 与 == 的区别</strong></p><ul><li>对于基本类型，<code>==</code> 判断两个值是否相等，基本类型没有 <code>equals()</code> 方法。</li><li>对于引用类型，<code>==</code> 判断两个实例是否引用同一个对象，而 <code>equals()</code> 判断引用的对象是否等价。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>默认情况下也就是从超类<code>Object</code>继承而来的<code>equals</code>方法与<code>==</code>是完全等价的，比较的都是对象的内存地址，但我们可以重写<code>equals</code>方法，使其按照我们的需求的方式进行比较，如<code>String</code>类重写了<code>equals</code>方法，使其比较的是字符的序列，而不再是内存地址。</p><p><strong>2. 等价关系</strong></p><p>（一）自反性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（二）对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（三）传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><p>（四）一致性</p><p>多次调用 <code>equals()</code> 方法结果不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（五）与 <code>null</code> 的比较</p><p>对任何不是 <code>null</code> 的对象 <code>x</code> 调用 <code>x.equals(null)</code> 结果都为 <code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.euqals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 <code>true</code>；</li><li>检查是否是同一个类型，如果不是，直接返回 <code>false</code>；</li><li>将 <code>Object</code> 实例进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>hashCode()</h2><p><code>hasCode()</code> 返回散列值，而 <code>equals()</code> 是用来判断两个实例是否等价。等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</p><p>在覆盖 <code>equals()</code> 方法时应当总是覆盖 <code>hashCode()</code> 方法，保证等价的两个实例散列值也相等。</p><p>下面的代码中，新建了两个等价的实例，并将它们添加到 <code>HashSet</code> 中。我们希望将这两个实例当成一样的，只在集合中添加一个实例，但是因为 <code>EqualExample</code> 没有实现 <code>hasCode()</code> 方法，因此这两个实例的散列值是不同的，最终导致集合添加了两个等价的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><blockquote><p>之所以选择31，是因为它是个奇素数，如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算。使用素数的好处并不是很明显，但是习惯上都使用素数来计算散列结果。31有个很好的特性，就是用移位和减法来代替乘法，可以得到更好的性能：31*i==(i&lt;&lt;5)-i。现在的VM可以自动完成这种优化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>clone()</h2><p><strong>1. cloneable</strong></p><p><code>clone()</code> 是 <code>Object</code> 的受保护方法，这意味着，如果一个类不显式去覆盖 <code>clone()</code> 就没有这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</span></span><br></pre></td></tr></table></figure><p>接下来覆盖 <code>Object</code> 的 <code>clone()</code> 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneTest</span><br></pre></td></tr></table></figure><p>以上抛出了 <code>CloneNotSupportedException</code>，这是因为 <code>CloneTest</code> 没有实现 <code>Cloneable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p><strong>2. 深拷贝与浅拷贝</strong></p><ul><li>浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；</li><li>深拷贝：拷贝实例和原始实例的引用类型引用不同对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用 <code>clone()</code> 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。<code>Effective Java</code> 书上讲到，最好不要去使用 <code>clone()</code>，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1>四、继承</h1><h2>访问权限</h2><p>Java 中有三个访问权限修饰符：<code>private</code>、<code>default</code>、<code>protected</code> 以及<code>public</code>，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>成员可见表示其它类可以用这个类的实例访问到该成员；</li><li>类可见表示其它类可以用这个类创建对象。</li></ul><p><code>protected</code> 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>如果子类的方法覆盖了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。可以使用公有的 <code>getter</code> 和 <code>setter</code> 方法来替换公有字段。</p><h2>抽象类与接口</h2><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 <code>abstract</code> 进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title">AbstractClassExample</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated</span></span><br><span class="line">AbstractClassExample ac2 = <span class="keyword">new</span> AbstractExtendClassExample();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员（字段 + 方法）默认都是 <code>public</code> 的，并且不允许定义为 <code>private</code> 或者<code>protected</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic7-1.png" alt="image"></p><p>接口的字段默认都是 <code>static</code> 和 <code>final</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;                // Variable 'y' might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> z = <span class="number">0</span>;       <span class="comment">// Modifier 'public' is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier 'private' not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier 'protected' not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier 'private' not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated</span></span><br><span class="line">InterfaceExample ie2 = <span class="keyword">new</span> InterfaceImplementExample();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 <code>static</code> 和 <code>final</code> 类型的，而抽象类的字段没有这种限制。</li><li>接口的方法只能是 <code>public</code> 的，而抽象类的方法可以由多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的方法和域的访问权限，而不是都为 <code>public</code>。</li><li>需要继承非静态（<code>non-static</code>）和非常量（<code>non-final</code>）字段。</li></ul><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 <code>Compareable</code> 接口中的 <code>compareTo()</code> 方法；</li><li>需要使用多重继承。</li></ul><p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h2>super</h2><ul><li>访问父类的构造函数：可以使用 <code>super()</code> 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 <code>super</code> 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><h2>覆盖与重载</h2><ul><li><p>覆盖（<code>Override</code>）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法；</p></li><li><p>重载（<code>Overload</code>）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。</p></li></ul><h1>五、String</h1><h2>String, StringBuffer and StringBuilder</h2><p><strong>1. 是否可变</strong></p><ul><li><code>String</code> 不可变</li><li><code>StringBuffer</code> 和 <code>StringBuilder</code> 可变</li></ul><p><strong>2. 是否线程安全</strong></p><ul><li><code>String</code> 不可变，因此是线程安全的</li><li><code>StringBuilder</code> 不是线程安全的</li><li><code>StringBuffer</code> 是线程安全的，内部使用 <code>synchronized</code> 来同步</li></ul><h2>String 不可变的原因</h2><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 <code>String</code> 的 <code>hash</code> 值经常被使用，例如 <code>String</code> 用做 <code>HashMap</code> 的 <code>key</code>。不可变的特性可以使得 <code>hash</code> 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 <code>String</code> 对象已经被创建过了，那么就会从 <code>String Pool</code> 中取得引用。只有 <code>String</code> 是不可变的，才可能使用 <code>String Pool</code>。</p><p><strong>3. 安全性</strong></p><p><code>String</code> 经常作为参数，<code>String</code> 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 <code>String</code> 是可变的，那么在网络连接过程中，<code>String</code> 被改变，改变 <code>String</code> 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p><code>String</code> 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><h2>String.intern()</h2><p>使用 <code>String.intern()</code> 可以保证相同内容的字符串实例引用相同的内存对象。</p><p>下面示例中，<code>s1</code> 和 <code>s2</code> 采用 <code>new String()</code> 的方式新建了两个不同对象，而 <code>s3</code> 是通过 <code>s1.intern()</code> 方法取得一个对象引用，这个方法首先把 <code>s1</code> 引用的对象放到 <code>String Poll</code>（字符串常量池）中，然后返回这个对象引用。因此 <code>s3</code> 和 <code>s1</code> 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">"bbb"</span>;</span><br><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p></blockquote><h1>六、基本类型与运算</h1><h2>包装类型</h2><p>八个基本类型：</p><ul><li>boolean/1</li><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><p><code>new Integer(123)</code> 与 <code>Integer.valueOf(123)</code> 的区别在于，<code>new Integer(123)</code> 每次都会新建一个对象，而 <code>Integer.valueOf(123)</code> 可能会使用缓存对象，因此多次使用 <code>Integer.valueOf(123)</code> 会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 <code>valueOf()</code> 方法，因此多个 <code>Integer</code> 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>valueOf()</code> 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，<code>Integer</code> 缓存池的大小默认为 -128~127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><blockquote><p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener">Differences between new Integer(123), Integer.valueOf(123) and just 123<br></a></p></blockquote><h2>switch</h2><p>从 Java 7 开始，可以在 <code>switch</code> 条件判断语句中使用 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 不支持 <code>long</code>，是因为 <code>swicth</code> 的设计初衷是为那些只需要对少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是罗列一些关于java基础的核心点，这些点是基础中的基础，也是重点中的重点。为什么本篇文章叫做冰川表面呢？我想表达的意思是，这些基础只是一个引子，背后牵扯出来的东西可能会很多，面试往往都是从基础的知识点慢慢深入挖掘的，所以千万不能忽视对于它们的复习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Condition详解</title>
    <link href="http://yoursite.com/2019/02/15/thread/Condition%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/15/thread/Condition详解/</id>
    <published>2019-02-15T03:44:10.048Z</published>
    <updated>2019-02-15T03:51:51.780Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://fourcolor.oursnail.cn/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">线程间通信方式总结</a>中有一个需求：轮流打印奇数和偶数，我们用wait和notify实现了一下，但是这种方式存在弊端，就是不能精确控制唤醒哪个线程，比如现在有一个需求是轮流打印ABC该怎么办呢？</p><a id="more"></a><p>首先准备三个线程，分别执行打印方法，是一个死循环，每次休息一秒。</p><p><img src="http://bloghello.oursnail.cn/thread16-1.jpg" alt="image"></p><h2>一、wait/notify实现轮流打印ABC三个字母</h2><p>如果是不加任何控制策略的话，必然是无法保证按照<code>A</code> <code>B</code> <code>C</code>的顺序依次循环执行的，比如：</p><p><img src="http://bloghello.oursnail.cn/thread16-2.jpg" alt="image"></p><p>执行结果是：</p><p>1694620367</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么如何保证按照我们这个顺序执行呢？如果还是沿用这个方法，只能这样写：</p><p><img src="http://bloghello.oursnail.cn/thread16-3.jpg" alt="image"></p><p>思想也很简单，就是搞一个变量，规定只有0的时候才打印<code>A</code>，只有1的时候才打印<code>B</code>，只有2的时候才打印<code>C</code>。那么，对于打印<code>A</code>的线程，只要不是0就<code>wait()</code>等待，一旦等于0就打印，并且加一；对于打印<code>B</code>的线程，只要不是1就<code>wait()</code>等待，一旦等于1就打印，并且加一。剩下同理。</p><p>这样，由于<code>signal</code>是一个成员变量，初始值为0.那么三个线程中<code>PrintB</code>和<code>PrintC</code>都等待，只有<code>PrintA</code>能执行打印，然后加为1，唤醒所有等待的线程来判断，此时打印<code>A</code>的线程和打印<code>C</code>的线程发现都不符合他们打印的条件，都进入了<code>while</code>中等待了，只有打印<code>B</code>的线程发现等于1，则不进入<code>while</code>循环，打印再加一。依次反复，可以得到顺序打印的<code>A</code>、<code>B</code>、<code>C</code>。</p><p>这种方式显然很不好，是靠<code>notifyAll</code>来唤醒所有线程来实现的，那么我们能不能唤醒指定的线程呢？这样处理起来更加优雅效率也会更高！</p><h2>二、Condition来实现</h2><p><img src="http://bloghello.oursnail.cn/thread16-4.jpg" alt="image"></p><p>达到了上面一样的效果。此时，我们发现它的强大之处在于我们可以指定哪个线程唤醒了，这看起来是一点点进步，但是我们学习多线程那么长时间了，在我看来，是很大的一个进步，因为之前用<code>notify</code>是随机唤醒一个，<code>notifyAll</code>是唤醒全部，总是不能受我们的完全控制，虽然说线程的执行本身就是不确定的，因此不确定性是他们的天生属性，但是在某些场景下我们确实需要一个高效并且优雅的实现可控的方式，所以是很重要的。</p><p>它这种功能可以给我们带来什么呢？下面用它实现一个有界队列。（关于生产者消费者模式，当然也可以用了，写法非常简单，就是对照上面的例子改一下即可。）</p><h2>三、Condition实现有界队列</h2><p>我们已经接触了线程池，它里面涉及队列，有很多种队列，最常见的是<code>ArrayBlockingQueue</code>以及<code>LinkedBlockingQueue</code>，他们的源码中其实也是靠<code>Condition</code>来实现阻塞塞值和阻塞取值的。现在我们也来实现一个比较简单的<code>ArrayBlockingQueue</code>吧！</p><p>首先明确一下队列是<code>FIFO</code>的，即先进先出，那么我们要保证先插入的要先弹出。其次要注意的是当没有元素的时候要阻塞，即等待有元素了才能获取；放入元素也是同理，要等有空位的才能重新放入。</p><p>如何实现以上这种数据结构呢？关于先进的先出来，我们可以用两个指针来实现，一个叫做<code>addIndex</code>，一个叫做<code>removeIndex</code>，初始都是指向第一个元素处。当塞进来一个元素，那么<code>addIndex</code>就自增，当自增到最后一个位置，这个时候数组不一定是满的，因为有可能前面的值已经被取出去了，所以还需要一个变量<code>count</code>来标志是否已经塞满，如果满了就阻塞，否则如果<code>addIndex</code>到最后一个位置，就重新置0.</p><p>对于<code>removeIndex</code>也是相同方向移除，假设最简单的情况，就是长度为5的数组，那么第一个元素放在0位置，第二个元素放在1位置，第三个元素放在2位置，此时要移除，那么第一个元素就是我们要的最先进来的元素，我们将其移除，并且<code>removeIndex</code>加一指向第二个元素。如此反复执行。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指向的是刚入队的元素的下角标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex;</span><br><span class="line">    <span class="comment">//指向的是刚出队的元素后面一个元素的下角标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> removeIndex;</span><br><span class="line">    <span class="comment">//实际元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition putCondition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition getCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化队列的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        myQueue = <span class="keyword">new</span> Object[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列的尾部放入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == myQueue.length)&#123;</span><br><span class="line">            <span class="comment">//说明队列已经满了，需要等待一下，那么放元素的线程就要阻塞住，即等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--队列已满，不能再塞值了，我要阻塞一会...."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                putCondition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明是可以放入元素的</span></span><br><span class="line">        myQueue[addIndex++] = object;</span><br><span class="line">        <span class="keyword">if</span>(addIndex == myQueue.length)&#123;</span><br><span class="line">            addIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素的数量要加一</span></span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功向队列放入一个元素，当前队列元素个数为---"</span>+count);</span><br><span class="line">        System.out.println();</span><br><span class="line">        getCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列的头部获取元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明队列已经满了，需要等待一下，那么取元素的线程就要阻塞住，即等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--队列已空，不能再取值了，我要阻塞一会...."</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getCondition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> removeValue = (<span class="keyword">int</span>) myQueue[removeIndex];</span><br><span class="line">        myQueue[removeIndex++] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (removeIndex == myQueue.length)&#123;</span><br><span class="line">            removeIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功从队列获取一个元素，当前队列的元素个数为---"</span>+count);</span><br><span class="line">        putCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">return</span> removeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue myQueue = <span class="keyword">new</span> MyQueue(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PutThread(myQueue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TakeThread(myQueue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TakeThread(myQueue)).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyQueue myQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(MyQueue myQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myQueue = myQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"成功放入一个元素，元素为："</span>+i);</span><br><span class="line">            myQueue.put(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TakeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyQueue myQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TakeThread</span><span class="params">(MyQueue myQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myQueue = myQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>) myQueue.get();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功放入一个元素，元素为："</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>四、Condition原理概述</h2><p>我们在上面的学习中看到，对于一个线程，我们就要准备一个<code>Condition</code>对象，并且还要用可重入锁<code>ReentrantLock</code>来实现加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">public</span> Condition cp = lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> Condition cc = lock.newCondition();</span><br></pre></td></tr></table></figure><p>它的原理是什么呢？</p><p>我们看到，创建一个<code>condition</code>对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会<code>new</code>出一个<code>ConditionObject</code>对象，该类是<code>AQS</code>的一个内部类.</p><p>我们知道在锁机制的实现上，<code>AQS</code>内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，<code>condition</code>内部也是使用同样的方式，内部维护了一个 等待队列，所有调用<code>condition.await</code>方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到<code>ConditionObject</code>中有两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><p>这样我们就可以看出来<code>ConditionObject</code>通过持有等待队列的头尾指针来管理等待队列。主要注意的是<code>Node</code>类复用了在<code>AQS</code>中的<code>Node</code>类。所以理解了<code>AQS</code>就简单了。但是这个队列有一点不同，他是一个单向链表，而<code>AQS</code>中的同步队列式一个双向链表。</p><p><img src="http://bloghello.oursnail.cn/thread16-5.jpg" alt="image"></p><p>同时还有一点需要注意的是：我们可以多次调用<code>lock.newCondition()</code>方法创建多个<code>condition</code>对象，也就是一个<code>lock</code>可以持有多个等待队列。而在之前利用<code>Object</code>的方式实际上是指在对象<code>Object</code>对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的<code>Lock</code>拥有一个同步队列和多个等待队列。示意图如下：</p><p><img src="http://bloghello.oursnail.cn/thread16-6.jpg" alt="image"></p><p>如图所示，<code>ConditionObject</code>是<code>AQS</code>的内部类，因此每个<code>ConditionObject</code>能够访问到<code>AQS</code>提供的方法，相当于每个<code>Condition</code>都拥有所属同步器的引用。</p><p>好了，至此我们已经知道多次调用<code>lock.newCondition()</code>方法创建多个<code>condition</code>对象，并且实际上这个对象就是<code>ConditionObject</code>。AQS维护的同步队列是一个双向链表结构，而这个<code>Condition</code>对象维护的是一个单项链表结构。</p><h2>五、await实现原理</h2><p>当调用<code>condition.await()</code>方法后会使得当前获取<code>lock</code>的线程进入到等待队列，如果该线程能够从<code>await()</code>方法返回的话一定是该线程获取了与<code>condition</code>相关联的<code>lock</code>。<code>await()</code>方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-7.jpg" alt="image"></p><p>在当前线程调用<code>condition.await()</code>方法后，会使得当前线程释放<code>lock</code>然后加入到等待队列中，直至被<code>signal</code>/<code>signalAll</code>后会使得当前线程从等待队列中移至到同步队列中去，直到获得了<code>lock</code>后才会从<code>await</code>方法返回(跳出<code>while</code>循环那就不用继续等待了呗)，或者在等待时被中断会做中断处理。</p><p>所以对于<code>await()</code>方法来说，它实现的功能为：将要等待的线程封装成节点尾插入到等待队列中，然后跟<code>wait</code>一样释放这个等待线程的锁。这些做完了之后还需要<code>while</code>循环判断是否已经在同步队列中，这个<code>isOnsyncQueue</code>是由下面说到的<code>signal</code>方法触发的，由于此时还没有<code>signal</code>所以陷在死循环中出不来，就调用<code>lockSupport.park</code>方法使他进入等待状态；当有<code>signal</code>或者有中断发生的时候，就跳出循环，继续执行，此时如果是<code>signal</code>触发的，就会进入下一个<code>if</code>,那就调用<code>acquireQueue</code>方法，这个方法在我们之前说的<code>AQS</code>中是提及的，主要思想是如果这个节点的前驱节点是<code>head</code>那么就自旋获取锁，否则可能会阻塞。这里已经从大体上说明了这个方法的整体思路，下面继续详细分析分析。</p><p>在这段代码中，我们将知道：</p><ul><li>是怎样将当前线程添加到等待队列中去的？</li><li>释放锁的过程？</li><li>怎样才能从<code>await</code>方法退出？</li></ul><p>第一个问题：是怎样将当前线程添加到等待队列中去的？</p><p><img src="http://bloghello.oursnail.cn/thread16-8.jpg" alt="image"></p><p>这段代码就很容易理解了，将当前节点包装成<code>Node</code>，如果等待队列的<code>firstWaiter</code>为<code>null</code>的话（等待队列为空队列），则将<code>firstWaiter</code>指向当前的<code>Node</code>,否则，更新<code>lastWaiter</code>(尾节点)即可。就是通过尾插入的方式将当前线程封装的<code>Node</code>插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前我们学习<code>AQS</code>时知道同步队列是一个带头结点的链式队列，这是两者的一个区别。将当前节点插入到等待队列之后，会使当前线程释放<code>lock</code>，由<code>fullyRelease</code>方法实现，<code>fullyRelease</code>源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-9.jpg" alt="image"></p><p>调用<code>AQS</code>的模板方法<code>release</code>方法释放<code>AQS</code>的同步状态(这样也说明了退出<code>await</code>方法必须是已经获得了<code>condition</code>引用（关联）的<code>lock</code>)并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题，怎样从<code>await</code>方法退出？现在回过头再来看<code>await</code>方法有这样一段逻辑：</p><p><img src="http://bloghello.oursnail.cn/thread16-10.jpg" alt="image"></p><p>很显然，当线程第一次调用<code>condition.await()</code>方法时，会进入到这个<code>while()</code>循环中，因为判断的条件是这个线程是否在同步队列中，我们这个刚进等待队列，咋可能在同步队列。</p><p>然后通过<code>LockSupport.park(this)</code>方法使得当前线程进入等待状态，那么要想退出这个<code>await</code>方法第一个前提条件自然而然的是要先退出这个<code>while</code>循环，出口就只剩下两个地方：</p><ol><li>逻辑走到<code>break</code>退出<code>while</code>循环；</li><li><code>while</code>循环中的逻辑判断为<code>false</code>。</li></ol><p>再看代码出现第1种情况的条件是当前等待的线程被中断后代码会走到<code>break</code>退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的<code>condition</code>的<code>signal</code>或者<code>signalAll</code>方法），<code>while</code>中逻辑判断为<code>false</code>后结束<code>while</code>循环。</p><p>总结下，就是当前线程被中断或者调用<code>condition.signal</code>/<code>condition.signalAll</code>方法当前节点移动到了同步队列后 ，这是当前线程退出<code>await</code>方法的前提条件。</p><p>当退出<code>while</code>循环后就会调用<code>acquireQueued(node, savedState)</code>，这个方法在介绍AQS的底层实现时说过了，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到<code>lock</code>）。</p><p><code>await</code>方法示意图如下图：</p><p><img src="http://bloghello.oursnail.cn/thread16-11.jpg" alt="image"></p><p>如图，调用<code>condition.await</code>方法的线程必须是已经获得了<code>lock</code>，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的<code>Node</code>尾插入到等待队列中。</p><p>此外，<code>await</code>也支持超时等待和不响应中断，这里不再赘述。</p><h2>六、signal/signalAll实现原理</h2><p>调用<code>condition</code>的<code>signal</code>或者<code>signalAll</code>方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得<code>lock</code>。按照等待队列是先进先出（<code>FIFO</code>）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用<code>condition</code>的<code>signal</code>方法是将头节点移动到同步队列中。</p><p><img src="http://bloghello.oursnail.cn/thread16-12.jpg" alt="image"></p><p><code>signal</code>方法首先会检测当前线程是否已经获取<code>lock</code>，如果没有获取<code>lock</code>会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的<code>doSignal</code>方法也是基于该节点。下面我们来看看<code>doSignal</code>方法做了些什么事情，<code>doSignal</code>方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-13.jpg" alt="image"></p><p>具体逻辑请看注释，真正对头节点做处理的逻辑在<code>transferForSignal</code>中，该方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-14.jpg" alt="image"></p><p>关键逻辑请看注释，这段代码主要做了两件事情1.将头结点的状态更改为<code>CONDITION</code>；2.调用<code>enq</code>方法，将该节点尾插入到同步队列中，关于<code>enq</code>方法请看<code>AQS</code>的底层实现这篇文章。现在我们可以得出结论：调用<code>condition</code>的<code>signal</code>的前提条件是当前线程已经获取了<code>lock</code>，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从<code>await</code>方法中的<code>LockSupport.park(this)</code>方法中返回，从而才有机会使得调用<code>await</code>方法的线程成功退出，此时就要回过头去再看看<code>await</code>方法的后续处理流程了。<code>signal</code>执行示意图如下图：</p><p><img src="http://bloghello.oursnail.cn/thread16-15.jpg" alt="image"></p><p><code>sigllAll</code>与<code>sigal</code>方法的区别体现在<code>doSignalAll</code>方法上，前面我们已经知道<code>doSignal</code>方法只会对等待队列的头节点进行操作，而<code>doSignalAll</code>只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用<code>condition.await()</code>方法的每一个线程。</p><p>整理自：<a href="https://juejin.im/post/5aeea5e951882506a36c67f0" target="_blank" rel="noopener">详解Condition的await和signal等待/通知机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线程间通信方式总结&lt;/a&gt;中有一个需求：轮流打印奇数和偶数，我们用wait和notify实现了一下，但是这种方式存在弊端，就是不能精确控制唤醒哪个线程，比如现在有一个需求是轮流打印ABC该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>实现生产者消费者模式</title>
    <link href="http://yoursite.com/2019/02/13/thread/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/02/13/thread/实现生产者消费者模式/</id>
    <published>2019-02-13T05:39:59.104Z</published>
    <updated>2019-02-13T09:12:03.707Z</updated>
    
    <content type="html"><![CDATA[<p>无论是面试还是工作中，生产者和消费者模式一直是一个比较常见的问题，今天，我们用各种方式来实现它。</p><a id="more"></a><h2>前言</h2><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p><p><img src="http://bloghello.oursnail.cn/thread11-1.jpg" alt="image"></p><h2>一、wait/notify/notifyAll实现</h2><p>有一个天猫小店专门负责生产商品，用户也可以去买商品：</p><p><img src="http://bloghello.oursnail.cn/thread15-1.jpg" alt="image"></p><p>一个生产者的线程：</p><p><img src="http://bloghello.oursnail.cn/thread15-2.jpg" alt="image"></p><p>同理，一个消费者的线程：</p><p><img src="http://bloghello.oursnail.cn/thread15-3.jpg" alt="image"></p><p>下面进行测试：</p><p><img src="http://bloghello.oursnail.cn/thread15-4.jpg" alt="image"></p><p>此时的结果为：</p><p><img src="http://bloghello.oursnail.cn/thread15-5.jpg" alt="image"></p><p>由于生产大于消费，造成产能过剩。</p><h2>二、阻塞队列实现</h2><p>这个的实现已经在<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/" target="_blank" rel="noopener">JUC组件拓展-BlockingQueue</a>中实现了。不再赘述。主要就是用到阻塞的<code>put()</code>和<code>take()</code>两个方法。</p><h2>三、condition+Lock实现</h2><p>这个也很简单，就是基于<code>wait</code>和<code>notify</code>的代码稍微改一下即可。</p><p><img src="http://bloghello.oursnail.cn/thread15-7.jpg" alt="image"></p><p>生产者改为：</p><p><img src="http://bloghello.oursnail.cn/thread15-8.jpg" alt="image"></p><p>消费者跟生产者一样的改法：</p><p><img src="http://bloghello.oursnail.cn/thread15-9.jpg" alt="image"></p><p>执行效果类似。关于<code>Condition</code>接口，在<a href="">Condition详解</a>这篇文章中进行了详细介绍。</p><p>其实还有一些其他的方式也可以实现生产者消费者模型，但是我觉得最核心的就是上面讲的三种，掌握这个就不慌了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是面试还是工作中，生产者和消费者模式一直是一个比较常见的问题，今天，我们用各种方式来实现它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信方式总结</title>
    <link href="http://yoursite.com/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/13/thread/线程间通信方式总结/</id>
    <published>2019-02-13T04:02:00.062Z</published>
    <updated>2019-02-13T09:12:31.105Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中已经介绍了wait和notify的基本知识，我们知道了他们都是Object这个基类中的方法，因此每个对象都天生拥有这两个方法，可见其重要性，在多线程的学习中，他们两兄弟可以实现线程之间的通信，当然了，还有许多其他的方式实现线程间通信，下面逐一击破。</p><a id="more"></a><h2>一、前言</h2><p>开发中不免会遇到需要所有子线程执行完毕通知主线程处理某些逻辑的场景。或者是线程 A 在执行到某个条件通知线程 B 执行某个操作。</p><h2>二、等待通知机制</h2><p>即用<code>wait</code>+<code>notify</code>来实现。</p><p>案例目标：两个线程交替打印奇偶数，一共100个。注意，这也是阿里的一道面试编程题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoThreadWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwoThreadWaitNotify twoThreadWaitNotify = <span class="keyword">new</span> TwoThreadWaitNotify();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintOdd(twoThreadWaitNotify)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintEven(twoThreadWaitNotify)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印奇数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOdd</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify twoThreadWaitNotify;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintOdd</span><span class="params">(TwoThreadWaitNotify twoThreadWaitNotify)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.twoThreadWaitNotify = twoThreadWaitNotify;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(twoThreadWaitNotify.count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!twoThreadWaitNotify.flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"奇数线程开始执行，打印："</span>+twoThreadWaitNotify.count);</span><br><span class="line">                        twoThreadWaitNotify.count++;</span><br><span class="line">                        twoThreadWaitNotify.flag = <span class="keyword">true</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印偶数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintEven</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify twoThreadWaitNotify;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintEven</span><span class="params">(TwoThreadWaitNotify twoThreadWaitNotify)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.twoThreadWaitNotify = twoThreadWaitNotify;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(twoThreadWaitNotify.count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(twoThreadWaitNotify.flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"偶数线程开始执行，打印："</span>+twoThreadWaitNotify.count);</span><br><span class="line">                        twoThreadWaitNotify.count++;</span><br><span class="line">                        twoThreadWaitNotify.flag = <span class="keyword">false</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果部分截图：</p><p><img src="http://bloghello.oursnail.cn/thread10-2.jpg" alt="image"></p><p>这里的线程 <code>A</code> 和线程 <code>B</code> 都对同一个对象 <code>TwoThreadWaitNotify.class</code> 获取锁，<code>A</code> 线程调用了同步对象的 <code>wait()</code> 方法释放了锁并进入 <code>WAITING</code> 状态。</p><p><code>B</code> 线程调用了 <code>notify()</code> 方法，这样 <code>A</code> 线程收到通知之后就可以从 <code>wait()</code> 方法中返回。</p><p>这里利用了 <code>TwoThreadWaitNotify.class</code> 对象完成了通信。</p><p>有一些需要注意:</p><ul><li><code>wait()</code> 、<code>notify()</code>、<code>notifyAll()</code> 调用的前提都是获得了对象的锁(也可称为对象监视器)。</li><li>调用 <code>wait()</code> 方法后线程会释放锁，进入<code>WAITING</code> 状态，该线程也会被移动到等待队列中。</li><li>调用 <code>notify()</code> 方法会将等待队列中的线程移动到同步队列中，线程状态也会更新为 <code>BLOCKED</code></li><li>从 <code>wait()</code> 方法返回的前提是调用 <code>notify()</code> 方法的线程释放锁，<code>wait()</code> 方法的线程获得锁。</li></ul><p><strong>⭐等待通知有着一个经典范式：</strong></p><p>线程 A 作为消费者：</p><ol><li>获取对象的锁。<br>2.进入 while(判断条件)，并调用 wait() 方法。</li><li>当条件满足跳出循环执行具体处理逻辑。</li></ol><p>线程 B 作为生产者:</p><ol><li>获取对象锁。</li><li>更改与线程 A 共用的判断条件。</li><li>调用 notify() 方法。</li></ol><p>伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Thread A</span><br><span class="line"></span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    while(条件)&#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Thread B</span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    条件=false;//改变条件</span><br><span class="line">    Object.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、Join方式</h2><p><img src="http://bloghello.oursnail.cn/thread14-1.jpg" alt="image"></p><p>这个之前也是提及过的，主要是可以打断主线程让子线程先执行完，但是缺点是粒度不够细腻，我不能控制子线程在某个点停一下让其他子线程执行。</p><p><img src="http://bloghello.oursnail.cn/thread14-2.jpg" alt="image"></p><p>核心逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>join</code> 线程完成后会调用 <code>notifyAll()</code> 方法，是在 <code>JVM</code> 实现中调用，所以这里看不出来。</p><h2>四、volatile 共享内存</h2><p>因为 Java 是采用共享内存的方式进行线程通信的，所以可以采用以下方式用主线程关闭 A 线程:</p><p><img src="http://bloghello.oursnail.cn/thread14-3.jpg" alt="image"></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A执行完毕</span><br></pre></td></tr></table></figure><p>这里的 <code>flag</code> 存放于主内存中，所以主线程和线程 <code>A</code> 都可以看到。<code>flag</code> 采用 <code>volatile</code> 修饰主要是为了内存可见性。</p><h2>五、CountDownLatch 并发工具</h2><p>在前面的<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">文章</a>中我们基本知道它的使用，但是很遗憾，没有找一个比较实际的场景来描述它的功能，下面我将以一个实际场景来用<code>CountDownLatch</code>来解决这个问题。</p><p>假设小明和小红是一对夫妻，他们两准备烧一个菜，就叫做青椒炒肉丝。我们知道，要想炒出青椒炒肉丝，需要切好青椒，然后切好肉丝，如果想要肉的质感爽嫩，需要用淀粉揉一揉，加点醋，加点料酒去去腥，并且弄好了之后需要先炒一下肉。最后两样都准备好之后：即切好的青椒和预热好的肉丝，那么就可以合在一起炒一下出锅了。</p><p>假设切青椒需要3分钟，准备好肉需要5分钟，这两个同时准备好之后就可以进行烧菜了。如何最大程度上提高效率呢？</p><p>显然，就是小明切青椒，小红搞肉丝，两个人并行。这个时候，我们可以用<code>CountDownLatch</code>来模拟这个场景。</p><p>切青椒线程：</p><p><img src="http://bloghello.oursnail.cn/thread14-4.jpg" alt="image"></p><p>准备肉丝的线程：</p><p><img src="http://bloghello.oursnail.cn/thread14-5.jpg" alt="image"></p><p>测试：</p><p><img src="http://bloghello.oursnail.cn/thread14-6.jpg" alt="image"></p><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小明开始切青椒...</span><br><span class="line">小红开始准备肉丝...</span><br><span class="line">小明切好青椒了...</span><br><span class="line">小红准备好肉丝了...</span><br><span class="line">over，食材全部准备好了，一起下锅 cost:5010</span><br></pre></td></tr></table></figure><p>这里突出的就是，主线程等待两个线程都执行完了才能继续执行。</p><p><code>CountDownLatch</code> 也是基于 <code>AQS</code>(<code>AbstractQueuedSynchronizer</code>) 实现的.</p><ul><li>初始化一个 <code>CountDownLatch</code> 时告诉并发的线程，然后在每个线程处理完毕之后调用 <code>countDown()</code> 方法。</li><li>该方法会将 <code>AQS</code> 内置的一个 <code>state</code> 状态 -1 。</li><li>最终在主线程调用 <code>await()</code> 方法，它会阻塞直到 <code>state == 0</code> 的时候返回。</li></ul><p>这个功能是不是很类似于上面的<code>join</code>，但是它比<code>join</code>灵活多了。</p><h2>六、CyclicBarrier 并发工具</h2><p>这个工具类从原理上来看与<code>CountDownLatch</code>非常类似，具体的使用可以看<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">AQS实现的一些同步组件介绍</a>。他们两是有区别的。该工具可以实现 <code>CountDownLatch</code> 同样的功能，但是要更加灵活。甚至可以调用 <code>reset()</code> 方法重置 <code>CyclicBarrier</code> (需要自行捕获 <code>BrokenBarrierException</code> 处理) 然后重新执行。就不再赘述了。</p><h2>七、线程响应中断</h2><p>这个我们之前也是提过的，就是<code>interrupt</code>来实现，线程方法里面用<code>while</code>不停地判断中断标志位从而达到自主中断的目的。</p><p><img src="http://bloghello.oursnail.cn/thread14-7.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread A运行中。。</span><br><span class="line">thread A运行中。。</span><br><span class="line">thread A退出。。</span><br></pre></td></tr></table></figure><p>可以采用中断线程的方式来通信，调用了 <code>thread.interrupt()</code> 方法其实就是将 <code>thread</code> 中的一个标志属性置为了 <code>true</code>。</p><p>并不是说调用了该方法就可以中断线程，如果不对这个标志进行响应其实是没有什么作用(这里对这个标志进行了判断)。</p><p>但是如果抛出了 <code>InterruptedException</code> 异常，该标志就会被 <code>JVM</code> 重置为 <code>false</code>。</p><h2>八、线程池 awaitTermination() 方法</h2><p>这个玩意与我们知道<code>shutdown</code>方法组合使用，我们知道，调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p><p>关于<code>awaitTermination()</code>方法，接收<code>timeout</code>和<code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回<code>true</code>，否则返回<code>false</code>.因此，在<code>shutdwon</code>之后，我们可以用<code>awaitTermination()</code>不断地监测剩下的线程的执行状态，执行完毕就可以执行主线程了。</p><p><img src="http://bloghello.oursnail.cn/thread14-8.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-2] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-1] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 20:18:02.273 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:03.278 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:04.278 [main] INFO  c.c.actual.ThreadCommunication - main over</span><br></pre></td></tr></table></figure><p>最后再强调一下：</p><p>使用这个 <code>awaitTermination()</code> 方法的前提需要关闭线程池，如调用了 <code>shutdown()</code> 方法。</p><p>调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p><h2>九、管道通信</h2><p>这个方式我见到的比较少，了解一下。</p><p><img src="http://bloghello.oursnail.cn/thread14-9.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2018-03-16 19:56:43.014 [Thread-0] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 19:56:43.014 [Thread-1] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 19:56:43.130 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=0</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=1</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=2</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=3</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=4</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=5</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=6</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=7</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=8</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=9</span><br></pre></td></tr></table></figure><p>Java 虽说是基于内存通信的，但也可以使用管道通信。</p><p>需要注意的是，输入流和输出流需要首先建立连接。这样线程 B 就可以收到线程 A 发出的消息了。</p><h2>十、总结</h2><p>实际开发中可以灵活根据需求选择最适合的线程通信方式。</p><p>整理自：<a href="https://crossoverjie.top/JCSprout/#/thread/thread-communication?id=%e7%ba%bf%e7%a8%8b%e6%b1%a0-awaittermination-%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">深入理解线程通信</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的文章中已经介绍了wait和notify的基本知识，我们知道了他们都是Object这个基类中的方法，因此每个对象都天生拥有这两个方法，可见其重要性，在多线程的学习中，他们两兄弟可以实现线程之间的通信，当然了，还有许多其他的方式实现线程间通信，下面逐一击破。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC组件拓展-BlockingQueue</title>
    <link href="http://yoursite.com/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/"/>
    <id>http://yoursite.com/2019/02/12/thread/JUC组件拓展-BlockingQueue/</id>
    <published>2019-02-12T09:37:24.293Z</published>
    <updated>2019-02-12T09:37:32.361Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的线程池原理介绍中，我们了解到在核心线程被全部占用并且没有空闲线程的时候，就会把后续的线程任务先放入一个队列结构中，然后按照队列的方式去消化任务。虽然队列有很多种，但是他们都有一个共同的名字叫做阻塞队列，本文来逐个击破揭开他们的面纱。</p><a id="more"></a><h2>一、BlockingQueue</h2><p>在Java中，<code>BlockingQueue</code>是一个接口，它的实现类有<code>ArrayBlockingQueue</code>、<code>DelayQueue</code>、 <code>LinkedBlockingDeque</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>、<code>SynchronousQueue</code>等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于<code>take</code>与<code>put</code>操作的原理，却是类似的。</p><p><img src="http://bloghello.oursnail.cn/BlockingQueue%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" alt="image"></p><p><code>BlockingQueue</code> 是一个先进先出的队列（<code>Queue</code>），为什么说是阻塞（<code>Blocking</code>）的呢？是因为 <code>BlockingQueue</code> 支持当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p><img src="http://bloghello.oursnail.cn/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="image"></p><ul><li><code>add(anObject)</code>:把<code>anObject</code>加到<code>BlockingQueue</code>里,即如果<code>BlockingQueue</code>可以容纳,则返回true,否则抛出异常</li><li><code>offer(anObject)</code>:表示如果可能的话,将<code>anObject</code>加到<code>BlockingQueue</code>里,即如果<code>BlockingQueue</code>可以容纳,则返回true,否则返回false.</li><li>⭐<code>put(anObject)</code>:把<code>anObject</code>加到<code>BlockingQueue</code>里,如果<code>BlockQueue</code>没有空间,则调用此方法的线程被阻断直到<code>BlockingQueue</code>里面有空间再继续.</li><li>⭐与<code>put</code>相对应的是<code>take()</code>:取走<code>BlockingQueue</code>里排在首位的对象,若<code>BlockingQueue</code>为空,阻断进入等待状态直到<code>Blocking</code>有新的对象被加入为止</li><li><code>poll(time)</code>:取走<code>BlockingQueue</code>里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null</li></ul><div class="tip">注意：BlockingQueue 不接受 null 元素。试图 add 、 put 或 offer 一个 null  元素时，某些实现会抛出 NullPointerException 。 null 被用作指示 poll  操作失败的警戒值。</div><blockquote><p><code>BlockingQueue</code> 的各个实现都遵循了这些规则，当然我们也不用死记这个表格，知道有这么回事，然后写代码的时候根据自己的需要去看方法的注释来选取合适的方法即可。</p></blockquote><blockquote><p>一个 <code>BlockingQueue</code> 可能是有界的，如果在插入的时候，发现队列满了，那么 <code>put</code> 操作将会阻塞。通常，在这里我们说的无界队列也不是说真正的无界，而是它的容量是 <code>Integer.MAX_VALUE</code>（21亿多）。</p></blockquote><blockquote><p><code>BlockingQueue</code> 实现主要用于生产者-消费者队列，但它另外还支持<code>Collection</code> 接口。因此，举例来说，使用<code>remove(x)</code> 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</p></blockquote><blockquote><p><code>BlockingQueue</code> 的实现都是线程安全的，但是批量的集合操作如 <code>addAll</code>, <code>containsAll</code>, <code>retainAll</code> 和 <code>removeAll</code> 不一定是原子操作。如 <code>addAll(c)</code> 有可能在添加了一些元素后中途抛出异常，此时 <code>BlockingQueue</code> 中已经添加了部分元素，这个是允许的，取决于具体的实现。</p></blockquote><p>下面来看看阻塞队列的各种具体的实现类。</p><h2>二、ArrayBlockingQueue</h2><ul><li>构造函数必须带一个int参数来指明其大小</li><li>一个由数组结构组成的有界阻塞队列.</li><li>此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序.</li><li>⭐其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</li><li>⭐如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。</li><li>⭐如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</li><li>支持公平锁和非公平锁。公平的获取锁，也就是当前等待时间最长的线程先获取锁</li></ul><h2>三、LinkedBlockingQueue</h2><ul><li>大小不定的<code>BlockingQueue</code></li><li>若其构造函数带一个规定大小的参数,生成的<code>BlockingQueue</code>有大小限制</li><li>若不带大小参数,所生成的BlockingQueue的大小由<code>Integer.MAX_VALUE</code>来决定</li><li>其所含的对象是以<code>FIFO</code>(先入先出)顺序排序的</li><li>⭐链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低</li><li>最新插入的数据在尾部，最新移除的对象在头部</li></ul><h2>四、PriorityBlockingQueue</h2><ul><li>⭐类似于<code>LinkedBlockQueue</code>,但其所含对象的排序不是<code>FIFO</code>,而是依据对象的自然排序顺序或者是构造函数的<code>Comparator</code>决定的顺序</li><li>一个无界的阻塞队列</li></ul><h2>五、SynchronousQueue</h2><ul><li>⭐它是一种阻塞队列，其中每个 <code>put</code> 必须等待一个 <code>take</code>，反之亦然。</li><li>⭐同步队列没有任何内部容量，甚至连一个队列的容量都没有。</li><li>它是线程安全的，是阻塞的。</li><li>不允许使用 <code>null</code> 元素。</li><li>公平排序策略是指调用 <code>put</code> 的线程之间，或 <code>take</code> 的线程之间。</li></ul><p>一个没有容量的并发队列有什么用了？或者说存在的意义是什么？</p><p>尽管元素在<code>SynchronousQueue</code> 内部不会“停留”，但是并不意味着<code>SynchronousQueue</code> 内部没有队列。实际上<code>SynchronousQueue</code> 维护着线程队列，也就是插入线程或者移除线程在不同时存在的时候就会有线程队列。既然有队列，同样就有公平性和非公平性特性，公平性保证正在等待的插入线 程或者移除线程以<code>FIFO</code>的顺序传递资源。</p><p>它模拟的功能类似于生活中一手交钱一手交货这种情形，像那种货到付款或者先付款后发货模型不适合使用<code>SynchronousQueue</code>。首先要知道<code>SynchronousQueue</code>没有容纳元素的能力，即它的<code>isEmpty()</code>方法总是返回true，但是给人的感觉却像是只能容纳一个元素。</p><h2>六、DelayQueue</h2><ul><li><code>DelayQueue</code> 对元素进行持有直到一个特定的延迟到期。注意其中的元素必须实现 <code>java.util.concurrent.Delayed</code> 接口。</li></ul><h2>七、生产者与消费者模式</h2><p>阻塞队列的最常使用的例子就是生产者消费者模式,也是各种实现生产者消费者模式方式中首选的方式。使用者不用关心什么阻塞生产，什么时候阻塞消费，使用非常方便。</p><p><code>LinkedBlockingQueue</code>来实现一个生产者与消费者模型：</p><p><img src="http://bloghello.oursnail.cn/thread13-1.png" alt="image"></p><p>运行效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">producer1 produce 95</span><br><span class="line">producer3 produce 36</span><br><span class="line">consumer0 consumer 95</span><br><span class="line">consumer2 consumer 36</span><br><span class="line">producer0 produce 27</span><br><span class="line">consumer4 consumer 27</span><br><span class="line">producer2 produce 75</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2>八、ArrayBlockingQueue和LinkedBlockingQueue的区别</h2><ul><li>队列中锁的实现不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；另外，可以指定是否为公平锁，默认是非公平锁。</p><p><code>LinkedBlockingQueue</code>实现的队列中的锁是分离的，在队头和队尾各持有一把锁，入队和出队之间不存在竞争。即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p></blockquote><ul><li>在生产或消费时操作不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；</p><p><code>LinkedBlockingQueue</code>实现的队列中在生产和消费的时候，需要把枚举对象转换为<code>Node&lt;E&gt;</code>进行插入或移出(会生成一个额外的<code>Node</code>对象，这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。)</p></blockquote><ul><li>队列大小初始化方式不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中必须指定队列的大小；</p><p><code>LinkedBlockingQueue</code>实现的队列中可以不指定队列的大小，但是默认是<code>Integer.MAX_VALUE</code></p></blockquote><ul><li>作为开发者，我们需要注意的是，如果构造一个<code>LinkedBlockingQueue</code>对象，而没有指定其容量大小，<code>LinkedBlockingQueue</code>会默认一个类似无限大小的容量（<code>Integer.MAX_VALUE</code>），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</li><li>在使用<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>分别对1000000个简单字符做入队操作时，<code>LinkedBlockingQueue</code>的消耗是<code>ArrayBlockingQueue</code>消耗的10倍左右，即<code>LinkedBlockingQueue</code>消耗在1500毫秒左右，而<code>ArrayBlockingQueue</code>只需150毫秒左右。</li><li>按照实现原理来分析，<code>ArrayBlockingQueue</code>完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。<code>Doug Lea</code>之所以没这样去做，也许是因为<code>ArrayBlockingQueue</code>的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的线程池原理介绍中，我们了解到在核心线程被全部占用并且没有空闲线程的时候，就会把后续的线程任务先放入一个队列结构中，然后按照队列的方式去消化任务。虽然队列有很多种，但是他们都有一个共同的名字叫做阻塞队列，本文来逐个击破揭开他们的面纱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC组件拓展-ForkJoin简介</title>
    <link href="http://yoursite.com/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-ForkJoin%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/02/12/thread/JUC组件拓展-ForkJoin简介/</id>
    <published>2019-02-12T09:03:06.685Z</published>
    <updated>2019-02-12T09:36:00.427Z</updated>
    
    <content type="html"><![CDATA[<p>JUC组件拓展-ForkJoin简介，本文只是初步认识认识一下ForkJoin是什么，不深究里面的原理。</p><a id="more"></a><h2>ForkJoin</h2><h4>什么是Fork/Join框架</h4><p><code>Fork/Join</code>框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>我们再通过<code>Fork</code>和<code>Join</code>这两个单词来理解下<code>Fork/Join</code>框架，<code>Fork</code>就是把一个大任务切分为若干子任务并行的执行，<code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+。。＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。</p><p><img src="http://bloghello.oursnail.cn/ForkJoin%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="image"></p><h4>工作窃取算法</h4><p>工作窃取（<code>work-stealing</code>）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="http://bloghello.oursnail.cn/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt="image"></p><ul><li>那么为什么需要使用工作窃取算法呢？</li></ul><blockquote><p>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></blockquote><ul><li><code>Fork/Join</code>框架如何实现工作窃取的？</li></ul><blockquote><p>这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p></blockquote><ul><li><code>Fork/Join</code>框架有没有什么缺点？</li></ul><blockquote><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></blockquote><ul><li>该如何设计一个<code>Fork/Join</code>框架?</li></ul><blockquote><p>第一步分割任务。首先我们需要有一个<code>fork</code>类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p><p>第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p></blockquote><p>这里就先简单介绍一下，如果有必要，以后再细谈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JUC组件拓展-ForkJoin简介，本文只是初步认识认识一下ForkJoin是什么，不深究里面的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS实现的一些并发工具类</title>
    <link href="http://yoursite.com/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/12/thread/AQS实现的一些并发工具类/</id>
    <published>2019-02-12T08:52:41.518Z</published>
    <updated>2019-02-15T08:27:44.200Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们已经深入了解了AQS原理，本节介绍几个常用的基于AQS实现的并发工具类。</p><a id="more"></a><h2>一、CountDownLatch</h2><p>计数器减到0，处于等待的线程才会继续执行。只能用一次，不能重置。</p><p>比如有一个运算量很大的任务，我们可以将它拆分为多个子任务，等所有子任务全部完成之后，再执行最后的汇总工作。</p><p><img src="http://bloghello.oursnail.cn/CountDownLatch.png" alt="image"></p><p>下面用一个实例来看看它是如何使用的：</p><p><img src="http://bloghello.oursnail.cn/thread12-1.jpg" alt="image"></p><p>运行结果，截取了最后一点：</p><p><img src="http://bloghello.oursnail.cn/thread12-2.jpg" alt="image"></p><p>我们可以看到，主程序等待所有的子程序执行完毕，再执行，它是通过<code>await()</code>阻塞等待，直到计数器的值减到0为止。</p><p>那如果是这种场景呢：计算若干个子任务，给定一个时间，超过这个时间的话，就把这个任务放弃掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h2>二、Semaphore</h2><p>能控制同一时间并发线程的数目</p><blockquote><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。很多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-14/16690827.jpg" alt="image"></p><p><code>Semaphore</code>可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用<code>Semaphore</code>来做流控，代码如下：</p><p><img src="http://bloghello.oursnail.cn/thread12-3.jpg" alt="image"></p><p>再来一个例子：</p><p><img src="http://bloghello.oursnail.cn/thread12-4.jpg" alt="image"></p><blockquote><p>这里是一个线程获取一个许可，那么同一时间，可以有三个线程进来一起工作。那如果我改成一个线程获取三个许可呢？就像一个人同时占三个坑位，那么只有等这个人拉完了才能轮到下一个人了，那么此时就变成跟单线程一样了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">3</span>);</span><br><span class="line">test(threadNum);</span><br><span class="line">semaphore.release(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>考虑这个场景：并发太高了，就算是控制线程数量，也比较棘手；一个厕所三个坑位，外面人太多了，让三个人进来，其他的都给轰走。如何做到呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(semaphore.tryAcquire())&#123;<span class="comment">//尝试获取一个许可</span></span><br><span class="line">    test(threadNum);</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：只有三条信息打印出来，其他的线程就都被丢弃了。</p><p>也可以给他一个超时时间，这里是5000毫秒。每个命令需要运行1000毫秒，那么程序等1000毫秒之后会打印三条；然后再等1000毫秒，又可以拿到新的三个许可，再打印三条；直到5000毫秒用完。可能会打印3*5条记录。剩下的5条记录由于已经超时，全部被放弃掉。</p><h2>三、CyclicBarrier</h2><blockquote><p><code>CyclicBarrier</code>也是一个同步辅助类 , 它允许一组线程相互等待 , 直到到达某个公共的屏障点 , 通过它可以完成多个线程之间相互等待 ,只有当每个线程都准备好之后, 才能各自继续往下执行后续的操作, 和 <code>CountDownLatch</code>相似的地方就是, 它也是通过计数器来实现的. 当某个线程调用了 <code>await()</code>方法之后, 该线程就进入了等待状态 . 而且计数器就进行 -1 操作 , 当计数器的值达到了我们设置的初始值0的时候 , 之前调用了<code>await()</code> 方法而进入等待状态的线程会被唤醒继续执行后续的操作. 因为 <code>CyclicBarrier</code>释放线程之后可以重用, 所以又称之为循环屏障 . <code>CyclicBarrier</code> 使用场景和  <code>CountDownLatch</code> 很相似 , 可以用于多线程计算数据, 最后合并计算结果的应用场景 .</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-14/65784628.jpg" alt="image"></p><p>两者的区别：</p><ul><li><p><code>CountDownLatch</code>的计数器只能使用一次 , 而 <code>CyclicBarrier</code> 的计数器可以使用 <code>reset</code>重置 循环使用</p></li><li><p><code>CountDownLatch</code> 主要是 1 个 或者 n 个线程需要等待其它线程完成某项操作之后才能继续往下执行 , 其描述的是 1 个 或者 n 个线程与其它线程的关系 ; CyclicBarrier 主要是实现了 1 个或者多个线程之间相互等待,直到所有的线程都满足条件之后, 才执行后续的操作 , 其描述的是内部各个线程相互等待的关系 .</p></li></ul><p><code>CyclicBarrier</code> 假如有 5 个线程都调用了 <code>await()</code> 方法 , 那这个 5 个线程就等着 , 当这 5 个线程都准备好之后, 它们有各自往下继续执行 , 如果这 5 个线程在后续有一个计算发生错误了 , 这里可以重置计数器 , 并让这 5 个线程再执行一遍 .</p><p><img src="http://bloghello.oursnail.cn/thread12-5.jpg" alt="image"></p><p>运行效果：先每隔一秒执行<code>race</code>方法打印出<code>ready</code>,等3个线程打印完毕，立即都将阻塞的<code>log.info(&quot;continue...&quot;);</code>全部打印出来。</p><p><img src="http://bloghello.oursnail.cn/thread12-6.jpg" alt="image"></p><p>也可以设定超时时间，超过时间了就不等了。</p><p><img src="http://bloghello.oursnail.cn/thread12-7.jpg" alt="image"></p><p>如果在大家已经都准备好了的时候，可以先做一件事情，即初始化执行一个线程，可以在声明<code>CyclicBarrier</code>后面增加一个线程来执行。</p><p>就像开会，人都到齐了之后，我们喊一声，人都到齐，我们现在开始开会了啊。下面就开始正式开会。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>,() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"callback is running..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2>四、Exchanger</h2><p><code>Exchanger</code> 类表示一种会合点，两个线程可以在这里交换对象。两个线程各自调用<code>exchange</code> 方法进行交换，当线程 <code>A</code> 调用 <code>Exchange</code> 对象的 <code>exchange</code> 方法后，它会陷入阻塞状态，直到线程 <code>B</code> 也调用了 <code>exchange</code> 方法，然后以线程安全的方式交换数据，之后线程 <code>A</code> 和 <code>B</code> 继续运行。</p><p><img src="http://bloghello.oursnail.cn/thread12-8.png" alt="image"></p><p><code>exchange</code> 方法有两个重载实现，在交换数据的时候还可以设置超时时间。如果一个线程在超时时间内没有其他线程与之交换数据，就会抛出 <code>TimeoutException</code> 超时异常。如果没有设置超时时间，则会一直等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换数据，并设置超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br><span class="line"><span class="function"><span class="comment">//交换数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>下面看一个小例子：</p><p><img src="http://bloghello.oursnail.cn/thread12-9.png" alt="image"></p><p>我们要注意，交换的时候两个线程要同时到达一个汇合点才会继续执行，即这里的a线程拿到b线程的值并且b拿到a的值，程序才会继续执行。</p><p><img src="http://bloghello.oursnail.cn/thread12-10.png" alt="image"></p><p>例子很简单，当两个线程都到达调用<code>exchange</code>方法的同步点的时候，两个线程就能交换彼此的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面我们已经深入了解了AQS原理，本节介绍几个常用的基于AQS实现的并发工具类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
