<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-01T13:48:51.350Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis缓存设计与优化</title>
    <link href="http://yoursite.com/2019/02/01/redis/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/02/01/redis/缓存设计与优化/</id>
    <published>2019-02-01T13:46:13.441Z</published>
    <updated>2019-02-01T13:48:51.350Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第九篇文章。介绍redis缓存中 一些重要的问题。</p><a id="more"></a><h2>1. 缓存收益和成本</h2><h4>1.1 收益</h4><ul><li>加速读写</li><li>降低后端负载(降低mysql负载)</li></ul><h4>1.2 成本</h4><ul><li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</li><li>代码维护成本：多了一层缓存逻辑</li><li>运维成本：例如<code>redis cluster</code></li></ul><h4>1.3 使用场景</h4><ul><li>降低后端负载：对于高消耗的SQL：join结果集、分组统计结果；对这些结果进行缓存。</li><li>加速请求响应</li><li>大量写合并为批量写：如计数器先redis累加再批量写入DB</li></ul><h2>2. 缓存的更新策略</h2><ul><li><code>LRU/LFU/FIFO</code>算法剔除：例如<code>maxmemory-policy</code></li></ul><blockquote><p><code>FIFO(first in first out)</code></p><p>先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。</p><p><code>LFU(less frequently used)</code></p><p>最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。</p><p><code>LRU(least recently used)</code></p><p>最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</p></blockquote><ul><li>超时剔除：例如<code>expire</code></li><li>主动更新：开发控制生命周期（最终一致性，时间间隔比较短）</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/51026002.jpg" alt="image"></p><ul><li>低一致性：最大内存和淘汰策略</li><li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底。</li></ul><h2>3. 缓存粒度控制</h2><p><img src="http://bloghello.oursnail.cn/18-5-12/56376367.jpg" alt="image"></p><h4>3.1 缓存粒度控制三个角度</h4><ul><li>通用性：全量属性更好(添加删除属性不需要改东西)</li><li>占用空间：部分属性更好</li><li>代码维护：表面上全量属性更好(添加删除属性不需要改东西)</li></ul><h2>4. 缓存穿透优化</h2><h4>4.1 定义</h4><p>大量请求不命中,缓存已经没有存在的意义了：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/69826621.jpg" alt="image"></p><h4>4.2 产生原因</h4><ul><li>业务代码自身问题</li><li>恶意攻击、爬虫等</li></ul><h4>4.3 如何发现</h4><ul><li>业务响应时间</li><li>业务本身问题</li><li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ul><h4>4.4 解决方案</h4><ul><li>方案一：缓存空对象</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/30770379.jpg" alt="image"></p><blockquote><p>存在的问题</p><p>需要更多的键:恶意攻击、爬虫会有很多乱七八糟的键，当量很大时，会有风险，所以会对这种空对象设置缓存时间控制风险</p><p>缓存层和存储层数据“短期”不一致：缓存了空对象，但是当业务恢复了，真实数据又存在于DB中了，那么在这个空对象过期时间内，取到的仍然是空对象，造成短期内数据不一致的问题。解决：可以订阅消息，当恢复正常后接受到消息，然后刷新缓存。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/91489515.jpg" alt="image"></p><ul><li>方案二：布隆过滤器拦截</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/74465100.jpg" alt="image"></p><p>什么是<code>Bloom Filter</code>？</p><blockquote><p>布隆过滤器（<code>Bloom Filter</code>）是1970年由布隆提出的, “<code>a space-efficient probabilistic data structure</code>”。它实际上是一个很长的二进制矢量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，<code>Hash table</code>）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为<code>O(n),O(log n),O(n/k)</code>。</p><p><strong>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1</strong>。</p><p>优点：相比于其它的数据结构，<ins>布隆过滤器在空间和时间方面都有巨大的优势</ins>。布隆过滤器存储空间和插入/查询时间都是常数（O（k））。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。布隆过滤器可以表示全集，其它任何数据结构都不能；k和m相同，使用同一组散列函数的两个布隆过滤器的交并差运算可以使用位操作进行。</p><p>缺点：但是布隆过滤器的缺点和优点一样明显。<ins>误算率是其中之一</ins>。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。另外，<ins>一般情况下不能从布隆过滤器中删除元素</ins>。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1,这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/60082067.jpg" alt="image"></p><p>检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：<ins>如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在</ins>。这就是布隆过滤器的基本思想。</p><p><code>Bloom Filter</code>应用场景？</p><p><img src="http://bloghello.oursnail.cn/18-5-12/1394689.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-5-12/76148797.jpg" alt="image"></p><p>用<code>Redis</code>的<code>Bitmap</code>作为位数组构建起来的可扩展的布隆过滤器。</p><p><a href="https://blog.csdn.net/NEWCIH/article/details/78934420" target="_blank" rel="noopener">Redis实现的布隆过滤器如何快速有效删除数据？</a>：EXPIRE “bitmap的key值” 0</p><h4>4.5 解决方案对比</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/38205091.jpg" alt="image"></p><h2>5. 无底洞问题优化</h2><h4>5.1 问题描述</h4><ul><li>2010年，facebook有了3000个<code>Memcache</code>节点</li><li>发现问题：&quot;加&quot;机器性能没能提升，反而下降</li></ul><h4>5.2 问题原因</h4><p>当存在的节点异常多的时候，IO的代价已经超过数据传输，上文提到的facebook的节点已经超过3000个，在这种情况下再增加节点已经没法再提高效率了。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/45516608.jpg" alt="image"></p><h4>5.3 问题解决—优化IO</h4><ul><li>命令本身的效率：例如sql优化，命令优化</li><li>网络次数：减少通信次数</li><li>降低接入成本:长连/连接池,NIO等。</li><li>IO访问合并:O(n)到O(1)过程:批量接口(mget)，就是上一篇文章中介绍的对于mget的四个方案。</li></ul><h2>6. 缓存雪崩优化</h2><h4>6.1 什么是缓存雪崩？</h4><p>从下图可以很清晰出什么是缓存雪崩：由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 缓存雪崩的英文原意是 stampeding herd（奔逃的野牛），指的是缓存层宕掉后，流量会像奔逃的野牛一样，打向后端存储。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/92547625.jpg" alt="image"></p><h4>6.2 如何防止缓存雪崩？</h4><ul><li>保证缓存层服务高可用性。</li></ul><p>和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 <code>Redis Sentinel</code> 和 <code>Redis Cluster</code> 都实现了高可用。</p><ul><li>依赖隔离组件为后端限流并降级</li></ul><p>无论是缓存层还是存储层都会有出错的概率，可以将它们视同为资源。作为并发量较大的系统，假如有一个资源不可用，可能会造成线程全部 hang 在这个资源上，造成整个系统不可用。降级在高并发系统中是非常正常的：比如推荐服务中，如果个性化推荐服务不可用，可以降级补充热点数据，不至于造成前端页面是开天窗。</p><p><strong>在实际项目中，我们需要对重要的资源 ( 例如 <code>Redis</code>、 <code>MySQL</code>、 <code>Hbase</code>、外部接口 ) 都进行隔离</strong>，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响。但是线程池如何管理，比如如何关闭资源池，开启资源池，资源池阀值管理，这些做起来还是相当复杂的，这里推荐一个 Java 依赖隔离工具 <code>Hystrix</code>。超出范围了。不再赘述。</p><h2>7. 热点key重建优化</h2><h4>7.1 问题</h4><p>热点<code>key</code>( 例如一个热门的娱乐新闻）+较长的重建时间（可能是一个复杂计算，例如复杂的 SQL、多次 IO、多个依赖等）</p><p>就是说在高并发的情况下，某个key在缓存中重建时间太长，以至于高并发下缓存查不到，都去DB进行查询。对于DB压力很大，并且响应时间长。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/85568274.jpg" alt="image"></p><p>三个目标：<strong>要减少缓存重建次数、数据尽可能一致、减少潜在危险</strong>。</p><p>两个解决：互斥锁、永远不过期</p><h4>7.2 互斥锁—setex,setnx</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/40535698.jpg" alt="image"></p><p>存在问题：有等待时间。</p><p>伪代码：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/13945208.jpg" alt="image"></p><blockquote><p>(1) 从 <code>Redis</code> 获取数据，如果值不为空，则直接返回值，否则执行 (2.1) 和 (2.2)。</p><p>(2) 如果 <code>set(nx 和 ex)</code> 结果为 true，说明此时没有其他线程重建缓存，那么当前线程执行缓存构建逻辑。</p><p>(2.2) 如果 <code>setnx(nx 和 ex)</code> 结果为 false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程将休息指定时间 ( 例如这里是 50 毫秒，取决于构建缓存的速度 ) 后，重新执行函数，直到获取到数据。</p></blockquote><h4>7.3 永远不过期</h4><blockquote><p>这里我想了很久到底是什么意思，，，我感觉这是一个场景：保证数据的定期更新。对于热点<code>key</code>,无非是并发特别大并且重建缓存时间比较长，如果直接设置过期时间，那么时间到的时候，巨大的访问量会压迫到数据库上，所以我们实际上，是不给他设置过期时间，但是不设置过期时间，怎么做到定时更新呢？这里的方案是给热点key的val增加一个逻辑过期时间字段，并发访问的时候，判断这个逻辑字段的时间值是否大于当前时间，大于了说明要对缓存进行更新了，那么这个时候，依然让所有线程访问老的缓存，因为缓存并没有设置过期，但是另开一个线程对缓存进行重构。等重构成功，即执行了<code>redis set</code>操作之后，所有的线程就可以访问到重构后的缓存中的新的内容了。不知道我的理解是不是正确。</p></blockquote><p>“永远不过期”包含两层意思：</p><blockquote><p>从缓存层面来看，确实没有设置过期时间，所以不会出现热点 <code>key</code> 过期后产生的问题，也就是“物理”不过期。</p><p>从功能层面来看，为每个 <code>value</code> 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</p></blockquote><p>2018/6/19 号补充：物理上缓存确实是不过期的，保证所有线程都能访问到，但是有可能是老的数据；逻辑上给 value 增加过期时间，如果当过期时间超过当前时间(每一个线程拿缓存数据的时候都会判断一下，<strong>也就是说这里仍然使用互斥锁</strong>，其中一个线程发现过期时间超过当前时间了，那么锁住，另开一个线程去完成数据重建)，新开一个线程去构建缓存，构建成功之后，设置新内容到缓存中并且删除老缓存，就完成了热点 key 的重建。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/84104163.jpg" alt="image"></p><p>伪代码实现：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/97521024.jpg" alt="image"></p><h4>两种方案对比</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/92977181.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第九篇文章。介绍redis缓存中 一些重要的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Cluster理论详解</title>
    <link href="http://yoursite.com/2019/02/01/redis/Redis-Cluster%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/01/redis/Redis-Cluster理论详解/</id>
    <published>2019-02-01T13:18:07.079Z</published>
    <updated>2019-02-01T13:49:35.733Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第八篇文章。<a href="http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" target="_blank" rel="noopener">上一篇</a>我们学习了redis sentinel，知道了它是redis高可用的一种实现方案。但是面对要求很高的场景，一台master是一定不能解决问题的，redis 3.0给我们带来了服务端集群方案，解决了这个问题。</p><a id="more"></a><h2>1. 数据分区</h2><p>集群，那么就会涉及到数据是如何分片的。有两种方式：顺序分区和哈希分区</p><p><img src="http://bloghello.oursnail.cn/18-5-11/75952046.jpg" alt="image"></p><p>两者对比：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/86878706.jpg" alt="image"></p><p>直接<code>hash</code>取模进行数据分片时，当节点增加，会有很多数据命中不了，需要重新映射。如果大多数数据在增加或者减少节点之后进行迁移的话，对于性能影响是很大的，因为数据迁移，那么缓存中现在是无法命中的，必须去数据库取，是灾难性的行为。</p><p>早期的做法就是这样，在客户端<code>hash</code>取余节点个数来进行数据分片。如果非要这样，采取翻倍扩容会稍微好一点，迁移数据量会小一点。不过无论如何，这种方式在大数据量情况下是不可行的。</p><h2>2. 一致性hash算法</h2><p>对于上面提到的直接hash取余的方式，会导致大量数据的迁移。那么有没有一种方式，在增加或减少节点时，只有少部分数据迁移呢？</p><p>针对一致性<code>hash</code>算法，已经在<a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">简明理解一致性hash算法</a>中详细说明了，不再赘述。</p><p>对于redis 3.0之前，客户端可以用这种方式来实现数据分片。在redis 3.0之后，就不需要客户端来实现分片算法了，而是直接给我们提供了服务端集群方案<code>redis cluster</code>.</p><h2>3. 虚拟槽</h2><p><code>redis cluster</code>引入槽的概念，一定要与一致性<code>hash</code>的槽区分！这里每一个槽映射一个数据集。</p><blockquote><p>CRC16(key) &amp; 16383</p></blockquote><p>这里计算结果发送给<code>redis cluster</code>任意一个<code>redis</code>节点，这个<code>redis</code>节点发现他是属于自己管辖范围的，那就将它放进去；不属于他的槽范围的话，由于<code>redis</code>之间是相互通信的，这个节点是知道其他<code>redis</code>节点的槽的信息，那么会告诉他去那个<code>redis</code>节点去看看。</p><p>那么就实现了服务端对于槽、节点、数据的管理。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/92222837.jpg" alt="image"></p><p>当<code>master</code>节点增加时，即扩容时，对于以上两种方案，都会出现数据迁移，那么只能作为缓存场景使用。但是<code>redis cluster</code>，由于每个节点维护的槽的范围是固定的，当有新加入的节点时，是不会干扰到其他节点的槽的，必须是以前的节点将使用槽的权利分配给你，并且将数据分配给你，这样，新的节点才会真正拥有这些槽和数据。这种实现还处于半自动状态，需要人工介入。-----主要的思想是：槽到集群节点的映射关系要改变，不变的是键到槽的映射关系.</p><p><code>Redis</code>集群，要保证16384个槽对应的<code>node</code>都正常工作，<strong>如果某个<code>node</code>发生故障，那它负责的<code>slots</code>也就失效，整个集群将不能工作</strong>。为了增加集群的可访问性，官方推荐的方案是将<code>node</code>配置成主从结构，即一个<code>master</code>主节点，挂n个<code>slave</code>从节点。这时，如果主节点失效，<code>Redis Cluster</code>会根据选举算法从<code>slave</code>节点中选择一个上升为主节点，整个集群继续对外提供服务。</p><h2>4. 某个Master又怎么知道某个槽自己是不是拥有呢？</h2><p><code>Master</code>节点维护着一个16384/8字节的位序列，<code>Master</code>节点用bit来标识对于某个槽自己是否拥有。比如对于编号为1的槽，<code>Master</code>只要判断序列的第二位（索引从0开始）是不是为1即可。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/45417990.jpg" alt="image"></p><p>如上面的序列，表示当前<code>Master</code>拥有编号为1，134的槽。集群同时还维护着槽到集群节点的映射，是由长度为16384类型为节点的数组实现的，槽编号为数组的下标，数组内容为集群节点，这样就可以很快地通过槽编号找到负责这个槽的节点。位序列这个结构很精巧，即不浪费存储空间，操作起来又很便捷。</p><p>具体参照：<a href="http://blog.jobbole.com/103258/" target="_blank" rel="noopener">http://blog.jobbole.com/103258/</a> ,还提到了<code>slot</code>迁移的一些细节。</p><h2>5. redis节点之间如何通信的？</h2><p><img src="http://bloghello.oursnail.cn/18-5-11/14610782.jpg" alt="image"></p><ul><li><code>gossip</code>协议：节点之间彼此不断通信交换信息，一段时间后所有节点都会知道集群完整的信息。</li><li>节点与节点之间通过<strong>二进制协议</strong>进行通信。</li><li>客户端和集群节点之间通信和通常一样，通过文本协议进行。</li><li>集群节点不会代理查询。</li></ul><h2>6. 集群伸缩</h2><p>这里6385为新加入的节点，一开始是没有槽的，所以进行<code>slot</code>的迁移。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/10996863.jpg" alt="image"></p><p>集群伸缩：槽和数据在节点之间的移动。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/8930549.jpg" alt="image"></p><p>迁移数据的流程图：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/7140273.jpg" alt="image"></p><p><strong>迁移key可以用<code>pipeline</code>进行批量的迁移。</strong></p><p>对于扩容，原理已经很清晰了，至于具体操作，网上很多。至于缩容，也是先手动完成数据迁移，再关闭<code>redis</code>。</p><h2>7. 客户端路由</h2><h4>7.1 moved重定向</h4><p><img src="http://bloghello.oursnail.cn/18-5-11/69037262.jpg" alt="image"></p><p>其中，槽直接命中的话，就直接返回槽编号：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/48809003.jpg" alt="image"></p><p>槽不命中，返回带提示信息的异常，客户端需要重新发送一条命令：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/38968206.jpg" alt="image"></p><p>对于命令行的实验，用<code>redis-cli</code>去连接集群：</p><p><code>redis -c -p 7000</code>:加上<code>-c</code>，表示使用集群模式，帮助我们在第一次不命中的情况下自动跳转到对应的节点上：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/53223278.jpg" alt="image"></p><p>如果不加-c的话，会返回moved异常，不会自动跳转：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/7791978.jpg" alt="image"></p><h4>7.2 ask重定向</h4><p>在扩容缩容的时候，由于需要遍历这个节点上的所有的<code>key</code>然后进行迁移，是比较慢的，对客户端是一个挑战。因为假设一个场景，客户端访问某个key，节点告诉客户端这个<code>key</code>在源节点，当我们再去源节点访问的时候，却发现<code>key</code>已经迁移到目标节点。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/35563321.jpg" alt="image"></p><h4>7.3 moved重定向和ask重定向对比</h4><ul><li>两者都是客户端的重定向</li><li>moved：槽已经确定转移</li><li>ask:槽还在迁移中</li></ul><p>问题：如果节点众多，那么让客户端随机访问节点，那么直接命中的概率只有百分之一，还有就是发生<code>ask</code>异常时（即节点正在迁移时）客户端如何还能高效运转？</p><p>总结一句话就是<code>redis cluster</code>的客户端的实现会更复杂。</p><h2>8. smart客户端</h2><h4>8.1 追求目标</h4><p>追求性能，不会使用代理模式，而是直连对应节点。需要对<code>moved</code>异常和<code>ask</code>异常做兼容。也就是说，需要有一个这个语言对应的客户端来高效实现查找等操作。</p><h4>8.2 smart原理</h4><ul><li>从集群中选一个可运行节点，使用<code>cluster slots</code>初始化槽和节点映射</li><li>将<code>slot</code>与<code>node</code>节点的结果映射到本地，为每个节点创建<code>JedisPool</code></li><li>准备执行命令</li></ul><p>第一步中将<code>slot</code>与<code>node</code>节点的对应关系放在了<code>map</code>中，形成一个映射关系；<code>key</code>是通过<code>CRC16</code>算法再取余得到<code>slot</code>，所以<code>key</code>与<code>slot</code>的映射关系也是确定的。我们就可以直接发送命令。只要后面集群没有发生数据迁移，那么就会连接成功。但是如果在连接的时候出现了连接出错，说明这个<code>key</code>已经迁移到其他的<code>node</code>上了。如果发现<code>key</code>不停地迁移，超过5次就报错。</p><p>在发生<code>moved</code>异常的时候，则需要刷新缓存，即一开始维护的<code>map</code>。<br><img src="http://bloghello.oursnail.cn/18-5-12/49065180.jpg" alt="image"></p><p>有一个情况比较全的图：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/16371398.jpg" alt="image"></p><p><code>java redis cluster</code>客户端：<code>jedisCluster</code>基本使用–伪代码</p><p><img src="http://bloghello.oursnail.cn/18-5-12/31666045.jpg" alt="image"></p><p><code>jedisCluster</code>内部已经封装好池的借还操作等。</p><p>先写一个<code>JedisClusterFactory</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hostPortList;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里可以设置相关参数</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从配置文件中读取ip:port的参数放进Set中</span></span><br><span class="line">        Set&lt;HostAndPort&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String hostPort : hostPortList)&#123;</span><br><span class="line">            String[] arr = hostPort.split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr.length != <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(<span class="keyword">new</span> HostAndPort(arr[<span class="number">0</span>],Integer.parseInt(arr[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedisCluster = <span class="keyword">new</span> JedisCluster(nodeSet,timeout,jedisPoolConfig);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedisCluster != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jedisCluster.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisCluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring注入hostPortList和timeout</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHostPortList</span><span class="params">(List&lt;String&gt; hostPortList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hostPortList = hostPortList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hostPortList</code> 放入<code>spring bean</code>中，<code>spring</code>自动完成注入。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/83900230.jpg" alt="image"></p><h4>8.3 多节点命令实现</h4><p>有的时候我们想操作所有节点的数据。如何实现呢？</p><p><img src="http://bloghello.oursnail.cn/18-5-12/68192871.jpg" alt="image"></p><h4>8.4 批量操作</h4><p><strong><code>mget</code>,<code>mset</code>必须在一个槽</strong>。这个条件比较苛刻，一般是不能保证的，那么如何实现批量的操作呢？</p><blockquote><p><code>Redis Cluster</code>的行为和<code>Redis</code> 的单节点不同，甚至和一个<code>Sentinel</code> 监控的主从模式也不一样。主要原因是集群自动分片，将一个<code>key</code> 映射到16384个槽中的一个，这些槽分布在多个节点上。因此操作多个<code>key</code> 的命令必须保证所有的<code>key</code> 都映射到同一个槽上，避免跨槽执行错误。更进一步说，今后一个单独的集群节点，只服务于一组专用的<code>keys</code>，请求一个命令到一个<code>Server</code>，只能得到该<code>Server</code> 上拥有<code>keys</code> 的对应结果。一个非常简单的例子是执行<code>KEYS</code>命令，当发布该命令到集群环境中的某个节时，只能得到该节点上拥有的<code>keys</code>，而不是集群中所有的<code>keys</code>。所以要得到集群中所有的<code>keys</code>，必须从集群的所有主节点上获取所有的<code>keys</code>。</p></blockquote><p>对于分散在<code>redis</code>集群中不同节点的数据，我们如何比较高效地批量获取数据呢？？？？</p><ol><li>串行mget–原始方案，整一个for循环</li></ol><p><img src="http://bloghello.oursnail.cn/18-5-12/58584180.jpg" alt="image"></p><ol start="2"><li>串行IO</li></ol><p>对key进行RCR16和取余操作得到<code>slot</code>，将<code>slots</code>按照节点进行分批传送：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/35132332.jpg" alt="image"></p><ol start="3"><li>并行IO</li></ol><p><img src="http://bloghello.oursnail.cn/18-5-12/42467098.jpg" alt="image"></p><ol start="4"><li>hash_tag</li></ol><p>不做任何改变的话，<code>hash</code>之后就比较均匀地散在每个节点上：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/67459261.jpg" alt="image"></p><p>那么我们能不能像使用单机<code>redis</code>一样，一次IO将所有的<code>key</code>取出来呢？<code>hash-tag</code>提供了这样的功能，如果将上述的<code>key</code>改为如下，<strong>也就是用大括号括起来相同的内容，那么这些key就会到指定的一个节点上</strong>。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/77254754.jpg" alt="image"></p><p>在<code>mget</code>的时候只需要在一台机器上去即可。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/77494164.jpg" alt="image"></p><ol start="5"><li>对比</li></ol><p>方案三比较复杂，一般不用；方案四可能会出现数据倾斜，也不用。方案一在key小的时候可以用；方案二相对来说有一点优势；</p><p><img src="http://bloghello.oursnail.cn/18-5-12/2180496.jpg" alt="image"></p><p>为什么说是一点优势呢？<code>pipeline</code>批量处理不应该比串行处理好很多吗？</p><ul><li><a href="http://xiezefan.me/2015/12/13/redis_cluster_research_2/" target="_blank" rel="noopener">http://xiezefan.me/2015/12/13/redis_cluster_research_2/</a></li><li><a href="http://trumandu.github.io/2016/05/09/RedisCluster%E6%9E%84%E5%BB%BA%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%8E%A2%E8%AE%A8/" target="_blank" rel="noopener">http://trumandu.github.io/2016/05/09/RedisCluster构建批量操作探讨/</a></li></ul><h2>9. 故障转移</h2><h4>9.1 故障发现</h4><ul><li>通过<code>ping/pong</code>消息实现故障发现：不需要<code>sentinel</code></li><li>分为主观下线和客观下线</li></ul><p>主观下线：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/34676048.jpg" alt="image"></p><p>客观下线：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/16678200.jpg" alt="image"></p><p>pfail消息就是主观下线的信息，维护在一个链表中，链表中包含了所有其他节点对其他节点所有的主观信息，是有时间周期的，为了防止很早以前的主观下线信息还残留在这里。对这个链表进行分析，符合条件就尝试客观下线。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/42802351.jpg" alt="image"></p><h4>9.2 故障恢复</h4><p>从节点接收到他的主节点客观下线的通知，则进行故障恢复的操作。</p><ul><li>资格检查</li></ul><p>选取出符合条件的从节点：当从节点和故障主节点的断线时间太长，会被取消资格。</p><ul><li>准备选举时间</li></ul><p>就是为了保证偏移量大的从节点优先被选举投票</p><p><img src="http://bloghello.oursnail.cn/18-5-12/46928842.jpg" alt="image"></p><ul><li>选举投票</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/64039470.jpg" alt="image"></p><ul><li>替换主节点</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/70736400.jpg" alt="image"></p><p>这些所有步骤加起来，差不多十几秒左右。最后如果故障节点又恢复功能了，就称为新的<code>Master</code>的<code>slave</code>节点。</p><h2>10. 常见问题</h2><h4>10.1 集群完整性</h4><p><code>cluster-require-full-coverage</code>默认为yes</p><pre><code>- 要求所有节点都在服务，集群中16384个槽全部可用：保证集群完整性- 节点故障或者正在故障转移：`(error)CLUSTERDOWN the cluster is down`</code></pre><p><strong>但是大多数业务都无法容忍。需要将<code>cluster-require-full-coverage</code>设置为<code>no</code></strong></p><h4>10.2 带宽消耗</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/18544066.jpg" alt="image"></p><ul><li>消息发送频率：节点发现与其他节点最后通信时间超过<code>cluster-node-timeout/2</code>时会直接发送<code>Ping</code>消息</li><li>消息数据量：<code>slots</code>槽数组(2k空间)和整个集群1、10的状态数据(10个节点状态数据约10k)</li><li>节点部署的机器规模：进去分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽越高。</li><li>优化：避免“大”集群，：避免多业务使用一个集群，大业务可用多集群；<code>cluster-node-timeout</code>时间设置要注意是带宽和故障转移速度的均衡；尽量均匀分配到多机器上：保证高可用和带宽。</li></ul><h4>10.3 PubSub广播</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/49491067.jpg" alt="image"></p><ul><li>问题：<code>publish</code>在集群中每个节点广播：加重带宽。</li><li>解决：单独“走”一套<code>redis sentinel</code>。就是针对目标的几个节点构建<code>redis sentinel</code>，在这个里面实现广播。</li></ul><h4>10.4 数据倾斜</h4><ul><li>节点和槽分配不均匀<ul><li><code>./redis-trib.rb info ip:port</code>查看节点、槽、键值分布</li><li>慎用<code>rebalance</code>命令</li></ul></li><li>不同槽位对应键数量差异较大<ul><li>CRC16正常情况下比较均匀</li><li>可能存在<code>hash_tag</code></li><li><code>cluster countKeysinslot {slot}</code>获取槽对应键值个数</li></ul></li><li>包含<code>bigkey</code><ul><li>例如大字符串、几百万的元素的<code>hash</code>、<code>set</code>等</li><li>在从节点上执行:<code>redis-cli --bigkeys</code>来查看<code>bigkey</code>情况</li><li>优化：优化数据结构</li></ul></li><li>内存相关配置不一致<ul><li>因为某种情况下，某个节点对<code>hash</code>或者<code>Set</code>这种数据结构进行了单独的优化，而其他节点都没有配置，会出现配置不一致的情况。</li></ul></li></ul><h4>10.5 请求倾斜</h4><ul><li>热点key：重要的<code>key</code>或者<code>bigkey</code></li><li>优化：避免<code>bigkey;</code>热键不使用<code>hash_tag</code>；当一致性不高时，可以用本地缓存+MQ</li></ul><h4>10.6 读写分离</h4><ul><li>只读连接：集群模式的从节点不接受任何读写请求</li></ul><blockquote><p>重定向到负责槽的主节点(对从节点进行读，都是重定向到主节点再返回信息)</p><p>readonly命令可以读：连接级别命令(每次重新连接都要写一次)</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/57749242.jpg" alt="image"></p><p>上图可以看出，<strong><code>redis cluster</code> 默认<code>slave</code> 也是不能读的，如果要读取，需要执行 <code>readonly</code></strong>，就可以了。</p><ul><li>读写分离：更加复杂（成本很高，尽量不要使用）</li></ul><blockquote><p>同样的问题：复制延迟、读取过期数据、从节点故障</p><p>修改客户端</p></blockquote><h4>10.7 数据迁移</h4><p>分为离线迁移和在线迁移(唯品会<code>redis-migrate-tool</code>和豌豆荚<code>redis-port</code>)。</p><p>官方的方式：只能从单机迁移到集群、不支持在线迁移、不支持断点续传、单线程迁移影响速度</p><blockquote><p><code>./redis-trib.rb import --from 源ip:port --copy 目标ip:port</code></p></blockquote><p>加入在迁移时再往源<code>redis</code>插入几条数据，这几条数据会丢失(丢失一部分)</p><h4>10.8 集群vs单机</h4><p>集群也有一定的限制：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/73133214.jpg" alt="image"></p><p>分布式<code>redis</code>不一定是好的：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/6295367.jpg" alt="image"></p><h2>11. 简单总结</h2><p><img src="http://bloghello.oursnail.cn/18-5-12/415428.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-5-12/24688449.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第八篇文章。&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇&lt;/a&gt;我们学习了redis sentinel，知道了它是redis高可用的一种实现方案。但是面对要求很高的场景，一台master是一定不能解决问题的，redis 3.0给我们带来了服务端集群方案，解决了这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>简明理解一致性hash算法</title>
    <link href="http://yoursite.com/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/01/miscellany/15简明理解一致性hash算法/</id>
    <published>2019-02-01T12:49:04.348Z</published>
    <updated>2019-02-01T12:50:12.033Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的。</p><a id="more"></a><h2>环形Hash空间</h2><p>按照常用的hash算法来将对应的key哈希到一个具有2^32 次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图</p><p><img src="http://bloghello.oursnail.cn/zaji15-1.png" alt="image"></p><p>把数据通过一定的hash算法处理后映射到环上<br>现在我们将<code>object1</code>、<code>object2</code>、<code>object3</code>、<code>object4</code>四个对象通过特定的<code>Hash</code>函数计算出对应的<code>key</code>值，然后散列到<code>Hash</code>环上。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hash(object1) = key1；</span><br><span class="line">Hash(object2) = key2；</span><br><span class="line">Hash(object3) = key3；</span><br><span class="line">Hash(object4) = key4；</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/zaji15-2.png" alt="image"></p><p>将机器通过hash算法映射到环上<br>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有<code>NODE1</code>，<code>NODE2</code>，<code>NODE3</code>三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hash(NODE1) = KEY1;</span><br><span class="line">Hash(NODE2) = KEY2;</span><br><span class="line">Hash(NODE3) = KEY3;</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/zaji15-3.png" alt="image"></p><p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动<code>object1</code>存储到了<code>NODE1</code>中，<code>object3</code>存储到了<code>NODE2</code>中，<code>object2</code>、<code>object4</code>存储到了<code>NODE3</code>中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p><h2>机器的删除与添加</h2><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p><h3>节点（机器）的删除</h3><p>以上面的分布为例，如果<code>NODE2</code>出现故障被删除了，那么按照顺时针迁移的方法，<code>object3</code>将会被迁移到<code>NODE3</code>中，这样仅仅是<code>object3</code>的映射位置发生了变化，其它的对象没有任何的改动。如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-4.png" alt="image"></p><h3>节点（机器）的添加</h3><p>如果往集群中添加一个新的节点<code>NODE4</code>，通过对应的哈希算法得到<code>KEY4</code>，并映射到环中，如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-5.png" alt="image"></p><p>通过按顺时针迁移的规则，那么<code>object2</code>被迁移到了<code>NODE4</code>中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p><h2>平衡性</h2><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。</p><p>hash算法是不保证平衡的，如上面只部署了<code>NODE1</code>和<code>NODE3</code>的情况（<code>NODE2</code>被删除的图），<code>object1</code>存储到了<code>NODE1</code>中，而<code>object2</code>、<code>object3</code>、<code>object4</code>都存储到了<code>NODE3</code>中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。</p><blockquote><p>“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</p></blockquote><p>以上面只部署了<code>NODE1</code>和<code>NODE3</code>的情况（<code>NODE2</code>被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p><p><img src="http://bloghello.oursnail.cn/zaji15-6.png" alt="image"></p><p>根据上图可知对象的映射关系：<code>object1</code>-&gt;<code>NODE1-1</code>，<code>object2</code>-&gt;<code>NODE1-2</code>，<code>object3</code>-&gt;<code>NODE3-2</code>，<code>object4</code>-&gt;<code>NODE3-1</code>。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，真正的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-7.png" alt="image"></p><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设<code>NODE1</code>的IP地址为<code>192.168.1.100</code>。引入“虚拟节点”前，计算 <code>cache A</code> 的 <code>hash</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100”);</span><br></pre></td></tr></table></figure><p>引入“虚拟节点”后，计算“虚拟节”点<code>NODE1-1</code>和<code>NODE1-2</code>的<code>hash</code>值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100#1”); // NODE1-1</span><br><span class="line">Hash(“192.168.1.100#2”); // NODE1-2</span><br></pre></td></tr></table></figure><p>整理自：</p><ul><li><a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">五分钟理解一致性哈希算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Sentinel实现高可用读写分离</title>
    <link href="http://yoursite.com/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://yoursite.com/2019/02/01/redis/Redis-Sentinel实现高可用读写分离/</id>
    <published>2019-02-01T12:21:44.756Z</published>
    <updated>2019-02-01T12:28:17.975Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第七篇文章。Redis Sentinel 是一个分布式系统，你可以在一个架构中运行多个 Sentinel 进程，这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息，并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。</p><a id="more"></a><p>虽然 <code>Redis Sentinel</code> 是一个单独的可执行文件 <code>redis-sentinel</code> ，但实际上它只是一个运行在特殊模式下的 <code>Redis</code> 服务器，你可以在启动一个普通 <code>Redis</code> 服务器时通过给定 <code>–sentinel</code> 选项来启动 <code>Redis Sentinel</code> 。</p><ul><li>启动方式一：使用<code>sentinel</code>可执行文件 <code>redis-sentinel</code> 程序来启动 <code>Sentinel</code> 系统，命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure><ul><li><code>sentinel</code>只是运行在特殊模式下的<code>redis</code>服务器，你可以用启动<code>redis</code>服务的命令来启动一个运行在 <code>Sentinel</code> 模式下的 <code>Redis</code> 服务器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure><h2>1. redis sentinel</h2><p>首先来看看什么是 <code>redis sentinel</code>，中文翻译是redis哨兵。顾名思义，哨兵是站岗监督突发情况的，那么这里具体的功能上很类似：</p><ul><li>监控：<code>Sentinel</code> 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒：当被监控的某个 <code>Redis</code> 服务器出现问题时，<code>Sentinel</code> 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移：当一个主服务器不能正常工作时，<code>Sentinel</code> 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li></ul><p><img src="http://bloghello.oursnail.cn/redis_sentinel%E7%BB%93%E6%9E%84.png" alt="image"></p><p>其中总结一下故障转移的基本原理：</p><ul><li>多个<code>sentinel</code>发现并确认<code>master</code>有问题</li><li>选举出一个<code>sentinel</code>作为领导</li><li>选出一个可以成为新的<code>master</code>的<code>slave</code></li><li>通知其他的<code>slave</code>称为新的<code>master</code>的<code>slave</code></li><li>通知客户端主从变化</li><li>等待老的<code>master</code>复活称为新的<code>master</code>的<code>slave</code></li></ul><p>也支持多个<code>master-slave</code>结构：</p><p><img src="http://bloghello.oursnail.cn/%E5%A4%9A%E4%B8%AAmaster_slave.png" alt="image"></p><h2>2. 安装与配置</h2><ol><li>配置开启主从节点</li><li>配置开启<code>sentinel</code>监控主节点（<code>sentinel</code>是特殊的<code>redis</code>）</li><li>实际应该多台机器，但是演示方便，只用一台机器来搭建</li><li>详细配置节点</li></ol><p>本地安装的结构图：</p><p><img src="http://bloghello.oursnail.cn/%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="image"></p><p>对于<code>master:redis-7000.conf</code>配置：</p><p><img src="http://bloghello.oursnail.cn/redis-7000.conf.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /usr/local/redis/data/redis-7000.pid</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br></pre></td></tr></table></figure><p>对于<code>slave:redis-7001</code>和<code>redis-7002</code>配置：</p><p><img src="http://bloghello.oursnail.cn/redis-slave.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /usr/local/redis/data/redis-7001.pid</span><br><span class="line">logfile &quot;7001.log&quot;</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br><span class="line">slaveof 127.0.0.1 7000</span><br></pre></td></tr></table></figure><p>启动<code>redis</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server ../config/redis-7000.conf</span><br></pre></td></tr></table></figure><p>访问7000端口的<code>master redis</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 info replication</span><br></pre></td></tr></table></figure><p>显示他有两个从节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=7002,state=online,offset=99550,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=7001,state=online,offset=99816,lag=0</span><br><span class="line">master_repl_offset:99816</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:99815</span><br></pre></td></tr></table></figure><p>对于<code>sentinel</code>主要配置：</p><p><img src="http://bloghello.oursnail.cn/sentinel%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE.png" alt="image"></p><p><code>master sentinel config</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>启动<code>redis sentinel</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel ../config/redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure><p>访问26379 <code>redis sentinel master</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 info sentinel</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:7000,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看这六个进程是否都起来了：ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>注意，如果上面是配置在虚拟机的话，需要将127.0.0.1改为虚拟机的ip，要不然找不着。</p><h2>3. 故障转移演练</h2><h4>3.1 java客户端程序</h4><p><code>JedisSentinelPool</code>只是一个配置中心，不需要具体连接某个<code>redis</code>，注意它不是代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(AppTest.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//哨兵配置，我们访问redis，就通过sentinel来访问</span></span><br><span class="line">    String masername = <span class="string">"mymaster"</span>;</span><br><span class="line">    Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26379"</span>);</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26380"</span>);</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26381"</span>);</span><br><span class="line"></span><br><span class="line">    JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masername,sentinels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个while死循环，每隔一秒往master塞入一个值，并且日志打印</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = sentinelPool.getResource();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">100000</span>);</span><br><span class="line">            String key = <span class="string">"k-"</span> + index;</span><br><span class="line">            String value = <span class="string">"v-"</span> + index;</span><br><span class="line">            jedis.set(key,value);</span><br><span class="line">            logger.info(<span class="string">"&#123;&#125;  value is &#123;&#125;"</span>,key,jedis.get(key));</span><br><span class="line"></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(jedis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>maven</code>依赖是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--slf4j日志接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--logback日志实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动程序，发现是正常写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">16:16:01.424 [main] INFO  com.njupt.swg.AppTest - k-54795  value is v-54795</span><br><span class="line">16:16:02.426 [main] INFO  com.njupt.swg.AppTest - k-55630  value is v-55630</span><br><span class="line">16:16:03.429 [main] INFO  com.njupt.swg.AppTest - k-70642  value is v-70642</span><br><span class="line">16:16:04.430 [main] INFO  com.njupt.swg.AppTest - k-42978  value is v-42978</span><br><span class="line">16:16:05.431 [main] INFO  com.njupt.swg.AppTest - k-96297  value is v-96297</span><br><span class="line">16:16:06.433 [main] INFO  com.njupt.swg.AppTest - k-4220  value is v-4220</span><br><span class="line">16:16:07.435 [main] INFO  com.njupt.swg.AppTest - k-34103  value is v-34103</span><br><span class="line">16:16:08.436 [main] INFO  com.njupt.swg.AppTest - k-9177  value is v-9177</span><br><span class="line">16:16:09.437 [main] INFO  com.njupt.swg.AppTest - k-24389  value is v-24389</span><br><span class="line">16:16:10.439 [main] INFO  com.njupt.swg.AppTest - k-32325  value is v-32325</span><br><span class="line">16:16:11.440 [main] INFO  com.njupt.swg.AppTest - k-68538  value is v-68538</span><br><span class="line">16:16:12.441 [main] INFO  com.njupt.swg.AppTest - k-36233  value is v-36233</span><br><span class="line">16:16:13.443 [main] INFO  com.njupt.swg.AppTest - k-305  value is v-305</span><br><span class="line">16:16:14.444 [main] INFO  com.njupt.swg.AppTest - k-59279  value is v-59279</span><br></pre></td></tr></table></figure><p>我们将现在的端口为7000的<code>redis master</code> 给<code>kill</code>掉</p><blockquote><p>kill -9 master的pid</p></blockquote><p>我们会发现：客户端报异常，但是在大概十几秒之后，就继续正常塞值了。原因是服务端的哨兵机制的选举<code>matser</code>需要一定的时间。</p><h2>4. 三个定时任务</h2><h4>4.1 每10秒每个sentinel对master和slave执行Info</h4><ul><li>发现<code>slave</code>节点</li><li>确认主从关系</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h4>4.2 每2秒每个sentinel通过master节点的channel交换信息(pub/sub)</h4><ul><li>通过<code>__sentinel__</code>:hello进行频道交互</li><li>交互对节点的“看法”和自身信息</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h4>4.3 每1秒每个<code>sentinel</code>对其他<code>sentinel</code>和<code>redis</code>执行<code>ping</code></h4><ul><li>心跳监测，失败判定依据</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h2>5. 主观下线和客观下线</h2><p>对于之前的<code>Sentinel</code>配置文件中有两条配置：</p><p>监控<code>master redis</code>节点，这里是当超过两个<code>sentinel</code>认为<code>master</code>挂了，则认为<code>master</code>挂了。</p><blockquote><p><code>sentinel monitor &lt;masterName&gt; &lt;masterIp&gt; &lt;msterPort&gt; &lt;quorum&gt;</code></p><p><code>sentinel monitor mymaster 127.0.0.1 6379 2</code></p></blockquote><p>这里是每秒<code>sentinel</code>都会去<code>Ping</code>周围的<code>master redis</code>，超过30秒没有任何响应，说明其挂了。</p><blockquote><p><code>sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;</code></p><p><code>sentinel down-after-milliseconds mymaster 300000</code></p></blockquote><h4>5.1 主观下线</h4><p>主观下线：每个<code>sentinel</code>节点对<code>Redis</code>节点失败的“偏见”</p><p>这是一种主观下线。因为在复杂的网络环境下，这个<code>sentinel</code>与这个<code>master</code>不通，但是<code>master</code>与其他的<code>sentinel</code>都是通的呢？所以是一种“偏见”</p><p>这是依靠的第三种定时：每秒去ping一下周围的<code>sentinel</code>和<code>redis</code>。对于<code>slave redis</code>,可以使用这个主观下线，因为他不需要进行故障转移。</p><h4>5.2 客观下线</h4><p>客观下线：所有<code>sentinel</code>节点对<code>master Redis</code>节点失败“达成共识”（超过<code>quorum</code>个则统一）</p><p>这是依靠的第二种定时：每两秒，<code>sentinel</code>之间进行“商量”，传递的消息是:<code>sentinel is-master-down-by-addr</code></p><p>对于<code>master redis</code>的下线，必须要达成共识才可以，因为涉及故障转移，仅仅依靠一个<code>sentinel</code>判断是不够的。</p><h2>6. 领导者选举</h2><p>原因：只有一个<code>sentinel</code>节点完成故障转移</p><p>选举：通过<code>sentinel is-master-down-by-addr</code>命令都希望成为领导者</p><ul><li>每个做主观下线的<code>sentinel</code>节点向其他<code>sentinel</code>节点发送命令，要求将它设置为领导者</li><li>收到命令的<code>sentinel</code>节点如果还没有同意过其他<code>semtinel</code>节点发送的命令，那么将同意该请求，否则拒绝</li><li>如果该<code>sentinel</code>节点发现自己的票数已经超过<code>sentinel</code>集合半数并且超过<code>quorum</code>，那么它将成为领导者。</li><li>如果此过程中多个<code>sentinel</code>节点成为了领导者，那么将等待一段时间重新进行选举</li></ul><h2>7. 故障转移</h2><ul><li>从<code>slave</code>节点中选出一个“合适的”节点作为新的<code>master</code>节点</li><li>对上述的<code>slave</code>节点执行“<code>slaveof no one</code>”命令使其成为<code>master</code>节点</li><li>向剩余的<code>slave</code>节点发送命令，让它们成为新<code>master</code>节点的<code>slave</code>节点，复制规则和<code>parallel-syncs</code>参数一样</li><li>更新对原来的<code>master</code>节点配置为<code>slave</code>，并保持着对其“关注”，当恢复后命令他去复制新的<code>master</code>节点</li></ul><p>那么，如何选择“合适”的<code>slave</code>节点呢？</p><ul><li>选择<code>slave-priority</code>(<code>slave</code>节点优先级)最高的<code>slave</code>节点，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的<code>slave</code>节点(复制得最完整)，如果存在则返回，不存在则继续</li><li>选择<code>run_id</code>最小的<code>slave</code>节点(最早的节点)</li></ul><h2>8. 节点下线</h2><p>主节点下线：<code>sentinel failover &lt;masterName&gt;</code></p><p>从节点下线要注意读写分离问题。</p><h2>9. 总结与思考</h2><blockquote><p><code>redis sentinel</code>是<code>redis</code>高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。</p></blockquote><blockquote><p><code>redis sentinel</code>从<code>redis2.8</code>版本才正式生产可用，之前版本不可生产用。</p></blockquote><blockquote><p>尽可能在不同物理机上部署<code>redis sentinel</code>所有节点。</p></blockquote><blockquote><p><code>redis sentinel</code>中的<code>sentinel</code>节点个数应该大于等于3且最好是奇数。</p></blockquote><blockquote><p><code>redis sentinel</code>中的数据节点和普通数据节点没有区别。每个<code>sentinel</code>节点在本质上还是一个<code>redis</code>实例，只不过和<code>redis</code>数据节点不同的是，其主要作用是监控<code>redis</code>数据节点</p></blockquote><blockquote><p>客户端初始化时连接的是<code>sentinel</code>节点集合，不再是具体的<code>redis</code>节点，但<code>sentinel</code>只是配置中心不是代理。</p></blockquote><blockquote><p><code>redis sentinel</code>通过三个定时任务实现了<code>sentinel</code>节点对于主节点、从节点、其余<code>sentinel</code>节点的监控。</p></blockquote><blockquote><p><code>redis sentinel</code>在对节点做失败判定时分为主观下线和客观下线。</p></blockquote><blockquote><p>看懂<code>redis sentinel</code>故障转移日志对于<code>redis sentine</code>l以及问题排查非常有用。</p></blockquote><blockquote><p><code>redis sentinel</code>实现读写分离高可用可以依赖<code>sentinel</code>节点的消息通知，获取<code>redis</code>数据节点的状态变化。</p></blockquote><p><code>redis sentinel</code>可以实现高可用的读写分离，高可用体现在故障转移，那么实现高可用的基础就是要有从节点，主从节点还实现了读写分离，减少<code>master</code>的压力。但是如果是从节点下线了，<code>sentinel</code>是不会对其进行故障转移的，并且连接从节点的客户端也无法获取到新的可用从节点，而这些问题在<code>Cluster</code>中都得到了有效的解决。</p><p>对于性能提高、容量扩展的时候，这种方式是比较复杂的，比较推荐的是使用集群，就是下面讨论的<code>redis cluster</code>!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第七篇文章。Redis Sentinel 是一个分布式系统，你可以在一个架构中运行多个 Sentinel 进程，这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息，并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>数值计算精度丢失问题</title>
    <link href="http://yoursite.com/2019/01/31/miscellany/14%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/31/miscellany/14数值计算精度丢失问题/</id>
    <published>2019-01-31T13:48:54.352Z</published>
    <updated>2019-01-31T13:49:43.953Z</updated>
    
    <content type="html"><![CDATA[<p>无论在什么业务中，钱是非常重要的东西，对账的时候一定要对的上，不能这边少一分那边多一分。对于数值的计算，尤其是小数，<code>double</code>和<code>double</code>都是禁止使用的。</p><a id="more"></a><blockquote><p>阿里强制要求存放小数时使用 decimal，禁止使用 float 和 double。</p><p>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 <code>decimal</code> 的范围，建议将数据拆成整数和小数分开存储。</p></blockquote><p>处理方式可以为：<code>mysql</code> 可以用 <code>decimal</code> ，如果你是用 <code>java</code>， 在商业计算中我们要用 <code>java.math.BigDecimal</code>，注意：如果需要精确计算，非要用<code>String</code>来够造<code>BigDecimal</code>不可！</p><p>那么到底是什么情况？</p><h2>一个例子说明</h2><p>废话不多说，上图：</p><p><img src="http://bloghello.oursnail.cn/zaji8-1.png" alt="image"></p><h2>问题原因</h2><p>无论是我们本文提到的<code>double</code>，还是<code>float</code>，都是浮点数。</p><p>在计算机科学中，浮点（英语：<code>floating point</code>，缩写为FP）<strong>是一种对于实数的近似值数值表现法</strong>，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（<code>floating-point number</code>）。</p><p>其实我觉得很好理解，我们之前说过，计算机计算加减乘除啊，都是用的加法器，实质都是二进制的加法处理。那么这里就有一个二进制表示的问题。试想，4，2，8之流都是2的幂次方，可以完美用二进制表示，计算当然不会出现问题。对于0，1，3，5之类也都可以用二进制来表示出来，所以，正数肯定是没问题的。</p><p>但是对于小数呢？1、0.5、0.25那都是可以转换成二进制的小数，如十进制的0.1，就无法用二进制准确的表示出来。因此只能使用近似值的方式表达。</p><p><img src="http://bloghello.oursnail.cn/zaji8-2.png" alt="image"></p><p>如果我们尝试着把10进制的0.1转化成二进制，会怎么转呢？</p><p>在十进制中，0.1如何计算出来的呢？</p><blockquote><p>0.1 = 1 ÷ 10</p></blockquote><p>那么二进制中也是同理：</p><blockquote><p>1 ÷ 1010</p></blockquote><p>我们回到小学的课堂，来列竖式吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       0.000110011...</span><br><span class="line">      ------------------</span><br><span class="line">1010 ) 1 0000</span><br><span class="line">         1010</span><br><span class="line">       ------</span><br><span class="line">          1100</span><br><span class="line">          1010</span><br><span class="line">          ----</span><br><span class="line">            10000</span><br><span class="line">             1010</span><br><span class="line">            -----</span><br><span class="line">              1100</span><br><span class="line">              1010</span><br><span class="line">              ----</span><br><span class="line">                10</span><br></pre></td></tr></table></figure><p>很显然，除不尽，除出了一个无限循环小数：二进制的 0.0001100110011…</p><p>那么，如何在计算机中表示这个无限不循环的小数呢？只能考虑按照不同的精度保理不同的位数。</p><p>我们知道float是单精度的，double是双精度的。不同的精度，其实就是保留的有效数字位数不同，保留的位数越多，精度越高。</p><p>所以，浮点数在Java中是无法精确表示的，因为大部分浮点数转换成二进制是一个无限不循环的小数，只能通过保留精度的方式进行近似表示。</p><h2>问题的解决</h2><p><code>String</code> 构造方法是完全可预知的：写入 <code>newBigDecimal(&quot;0.1&quot;)</code> 将创建一个 <code>BigDecimal</code>，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用<code>String</code>构造方法。</p><p>使用<code>BigDecimal(String val)</code>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.add(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">sub</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.subtract(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">mul</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.multiply(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//四舍五入,保留2位小数,应对除不尽的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，上面的精度丢失问题就迎刃而解了。但是除不尽怎么办？比如10.0除以这里的3.0，保留小数点后三位有效数字：</p><p><img src="http://bloghello.oursnail.cn/zaji8-3.png" alt="image"></p><p>那么，每个用户得到的都是3.333元，三个用户加起来是得不到10块钱的。</p><p>对于除法，始终会产生除不尽的情况怎么办？有个词叫轧差</p><p>什么意思呢？举个简单例子。假如现在需要把10元分成3分，如果是10除以3这么除，会发现为3.33333无穷尽的3。这些数字完全无法在程序或数据库中进行精确的存储。</p><p>简单理解就是，当除不尽或需去除小数点的时候，前面的n-1笔（这里n=3）做四舍五入。最后一笔做兜底（总金额减去前面n-1笔之和）。这样保证总金额的不会丢失。</p><p>比如10块钱，三个用户分，前面两个用户只能各分到3。333块钱，最后一个用户分到3.334块钱。保证总额不变。</p><p>至于原理，有一点点数学化，以后再作探讨吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论在什么业务中，钱是非常重要的东西，对账的时候一定要对的上，不能这边少一分那边多一分。对于数值的计算，尤其是小数，&lt;code&gt;double&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;都是禁止使用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://yoursite.com/2019/01/31/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/01/31/redis/Redis主从复制/</id>
    <published>2019-01-31T12:45:32.691Z</published>
    <updated>2019-02-01T12:28:10.690Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第六篇文章。介绍redis主从复制功能实现原理。作为高可用的基础，了解一下其中的门道是有必要的。</p><a id="more"></a><h2>1.单机有什么问题</h2><ul><li>机器故障</li><li>容量瓶颈</li><li>QPS瓶颈</li></ul><h2>2. 主从复制的作用</h2><ul><li>数据副本</li><li>扩展读性能，<code>slave</code>专门用来读</li><li>一个<code>master</code>可以有多个<code>slave</code>，一个<code>salve</code>只能有一个<code>master</code></li></ul><h2>3. 两种实现方式</h2><ul><li>方式一：<code>slaveof</code>命令<ul><li><code>slaveof masterIp masterPort</code></li><li><code>slaveof no one</code>(不会清除原来同步的数据，而是新的数据不会再同步给他)</li></ul></li><li>方式二：配置<ul><li>修改某一行的配置：<code>slaveof ip port</code></li><li>从节点只做读操作：<code>slave-read-only yes</code></li></ul></li><li>对比<ul><li>命令的优点：不需要重启</li><li>命令的缺点：不便于管理</li><li>配置的优点：统一配置</li><li>配置的缺点：需要重启</li></ul></li></ul><p>一个场景，假如6380是6379的一个从节点，然后将6380执行<code>salveof no one</code>，然后插入一些新的数据；再重新变成6379的从节点，那么里面的新数据会被清除掉。</p><ul><li>查看run_id<ul><li><code>redis-cli -p 6379 info server | grep run</code></li></ul></li></ul><h2>4. 全量复制</h2><ul><li>全量复制开销<ul><li>bgsave时间</li><li>rdb网络传输时间</li><li>从节点清空数据的时间</li><li>从节点加载RDB的时间</li><li>可能的AOF重写时间</li></ul></li><li>存在的问题<ul><li>时间开销比较大</li><li>如果<code>master</code>和<code>slave</code>之间网络扰动甚至断开，那么<code>master</code>此间更新的数据对于<code>slave</code>是不知道的，最简单的方法就是再进行一次全量复制，但是显然，消耗太大了。</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png" alt="image"></p><h2>5. 部分复制</h2><p><img src="http://bloghello.oursnail.cn/%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6.png" alt="image"></p><h2>6. 开发与运维的问题</h2><ul><li>读写分离</li></ul><p><code>master</code>只做写操作，<code>slave</code>来做读操作，来分摊流量。但是会有一些问题：</p><blockquote><p>复制数据延迟</p><p>读到过期数据</p><p>从节点故障</p></blockquote><ul><li>主从配置不一致</li></ul><blockquote><p>例如<code>maxmemory</code>不一致：丢失数据</p><p>数据结构优化参数：内存不一致</p></blockquote><ul><li>规避全量复制</li></ul><blockquote><p>第一次全量复制：不可避免—小主节点(<code>maxmemroy</code>不要太大)或者在低峰时进行操作</p><p>节点<code>run_id</code>不匹配（主节点重启，那么<code>master</code>的<code>run_id</code>会发生变化，<code>slave</code>发现其<code>run_id</code>变化，会进行全量复制）；我们可以用故障转移，例如哨兵或集群来避免全量复制。</p><p>复制积压缓冲区不足(网络中断，部分复制无法满足)，可以增大复制缓冲区配置<code>size</code>，网络增强</p></blockquote><ul><li>规避复制风暴</li></ul><blockquote><p>概念：主节点宕机造成大量的全量复制</p><p>单主节点复制风暴：主节点重启，多从节点复制；解决：更换复制拓扑</p><p>单机器复制风暴：机器宕机后（该机器全是<code>Mater</code>），大量全量复制。解决：<code>master</code>分散多机器。</p></blockquote><p>说到底，还是需要有一种高可用的实现方式，在<code>master</code>出现故障之后，如何自动实现从<code>slave</code>晋升为<code>master</code>继续使用.而不是一直死守着原来老的<code>master</code>不放，因为老的<code>master</code>啥时候恢复不知道，恢复了可能会造成复制风暴，既然从节点本来是一直与<code>master</code>节点保持尽量的同步的，那么为什么不将数据最新的从节点升级为主节点呢？下一章继续来分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第六篇文章。介绍redis主从复制功能实现原理。作为高可用的基础，了解一下其中的门道是有必要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://yoursite.com/2019/01/31/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/31/redis/Redis持久化/</id>
    <published>2019-01-31T12:34:15.804Z</published>
    <updated>2019-02-01T12:27:54.497Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第五篇文章。redis处理数据都是在内存中进行，所以速度特别快，同样，它也可以支持持久化，这里注意，并不是说redis要来充当mysql那种角色，其实更多的是为了在崩溃的时候快速恢复以及主从复制这样的功能。redis的持久化主要有两种方式，一种是RDB，一种是AOF，对于他们的原理和区别都是比较重要的面试考察点，需要掌握。</p><a id="more"></a><h2>1. 什么是持久化</h2><p><code>redis</code>所有数据保持在内存中，对数据的更新将异步地保存到磁盘中。</p><h2>2. 持久化的方式</h2><p>快照—<code>mysql dump</code>或者<code>redis rdb</code></p><p>写日志—<code>mysql binlog</code>或者<code>hbase glog</code>或者<code>redis aof</code></p><h2>3. RDB</h2><h4>什么是RDB</h4><p><img src="http://bloghello.oursnail.cn/%E4%BB%80%E4%B9%88%E6%98%AFRDB.png" alt="image"></p><h4>触发机制三种主要方式</h4><ul><li>save(<strong>同步持久化，会造成redis主线程的阻塞，不推荐使用</strong>)</li></ul><p><code>save</code>是同步的，当保存的数据量很大时，可能造成<code>redis</code>的阻塞，即客户端访问<code>redis</code>被阻塞。</p><p><img src="http://bloghello.oursnail.cn/save%E5%91%BD%E4%BB%A4.png" alt="image"></p><p>他的文件策略是：如果存在老的<code>RDB</code>文件，则新的替换老的。复杂度为<code>O(n)</code>。</p><ul><li>bgsave(<strong>异步，fork一个子进程来进行持久化，不会造成主线程的阻塞</strong>)</li></ul><p>一般情况下，<code>fork</code>是比较快的，但是也可以会慢，这时会阻塞<code>redis</code>。只要<code>fork</code>不慢，客户端不会被阻塞。</p><p><img src="http://bloghello.oursnail.cn/newbgsave.png" alt="image"></p><p>他的文件策略和复杂度与save是一样的。</p><p><code>save</code>和<code>bgsave</code>两者对比：</p><p><img src="http://bloghello.oursnail.cn/save%E5%92%8Cbgsave%E5%AF%B9%E6%AF%94.png" alt="image"></p><ul><li>自动</li></ul><p><code>redis</code>的自动保存的默认配置是：</p><table><thead><tr><th>配置</th><th>seconds</th><th>changes</th></tr></thead><tbody><tr><td>save</td><td>900</td><td>1</td></tr><tr><td>save</td><td>300</td><td>10</td></tr><tr><td>save</td><td>60</td><td>10000</td></tr></tbody></table><p>就是说，在60秒内改变了10000条数据，就自动保存；在300秒内有10条改变才自动保存；900秒内有1一条改变就保存。</p><h4>RDB总结</h4><ol><li><code>RDB</code>是<code>Redis</code>内存到硬盘的快照，用于持久化。</li><li><code>save</code>通常会阻塞<code>redis</code>。</li><li><code>bgsave</code>不会阻塞<code>redis</code>，但是会<code>fork</code>新进程。</li><li><code>save</code>自动配置满足任一就会被执行。</li><li>有些触发机制不容忽视。</li></ol><h2>4. AOF</h2><h4>RDB问题</h4><ul><li>全量数据存入磁盘</li></ul><p><code>O(n)</code>数据的备份，很耗时间；对于<code>bgsave</code>来说，<code>fork()</code>是一个很消耗内存的操作；将数据全写到硬盘，必然对硬盘IO占用很大。</p><ul><li>宕机丢失数据多</li></ul><p>还有一点是：<strong>某个时间点宕机，那么在某个时间段的数据就丢失了</strong>。</p><h4>AOF原理</h4><p>将对<code>redis</code>的操作追加到<code>aof</code>文件中。当<code>redis</code>宕机之后，使用<code>aof</code>恢复所有的操作继而实现数据的恢复。</p><h4>AOF三种策略</h4><ul><li>always</li></ul><p><img src="http://bloghello.oursnail.cn/aof-always.png" alt="image"></p><ul><li>everysec</li></ul><p><img src="http://bloghello.oursnail.cn/aof-everysec.png" alt="image"></p><p><code>redis</code>出现故障，有可能丢失一秒的数据。<code>redis</code>默认方式。</p><ul><li>no</li></ul><p><img src="http://bloghello.oursnail.cn/aof-no.png" alt=""></p><h4>三种策略的比较</h4><p><img src="http://bloghello.oursnail.cn/aof%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="image"></p><h4>AOF重写</h4><p><img src="http://bloghello.oursnail.cn/AOF%E9%87%8D%E5%86%99.png" alt="image"></p><p>好处是：减少硬盘占用、减少数据丢失</p><p>下面是AOF的<code>bgrewirteaof</code>的过程：</p><p><img src="http://bloghello.oursnail.cn/bgrewriteaof.png" alt="image"></p><p>注意：这里的重写并不是上面演示的，将原来的<code>aof</code>文件进行重写，而是根据<code>redis</code>现在的内存数据进行一次回溯。</p><h4>aof重写流程</h4><p><img src="http://bloghello.oursnail.cn/aof%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>也就是说，子进程在执行 AOF 重写时，主进程需要执行以下三个工作：</p><ul><li>1.处理命令请求；</li><li>2.将写命令追加到现有的 AOF 文件中；</li><li>3.将写命令追加到 AOF 重写缓存中。</li></ul><p>如此可以保证：</p><ul><li>现有的AOF功能继续执行，即使 AOF 重写期间发生停机，也不会有任何数据丢失；</li><li>所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。</li></ul><p>当子进程完成对 AOF 文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：(阻塞)</p><ul><li>将 AOF 重写缓存中的内容全部写入到新的 AOF 文件中；(现有 AOF 文件、新的 AOF 文件和数据库三者的状态就完全一致了)</li><li>对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。(执行完毕后，程序就完成了新旧两个 AOF 文件的替换)</li></ul><p>当这个信号处理函数执行完毕之后，主进程就可以继续像往常一样接收命令请求了。在整个 AOF 后台重写过程中，<strong>只有最后的“主进程写入命令到AOF缓存”和“对新的 AOF 文件进行改名，覆盖原有的 AOF 文件”这两个步骤会造成主进程阻塞，在其他时候， AOF 后台重写都不会对主进程造成阻塞，这将 AOF 重写对性能造成的影响降到最低。</strong></p><p>小结：</p><ul><li>AOF 重写的目的是轻量地保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求；</li><li>AOF在redis宕机的时候最多丢失一秒的数据，比RDB要好一点，并且可读性高，基本上能看得懂</li><li>AOF 重写其实是一个有歧义的名字，实际上重写工作是针对数据库的当前值来进行的，重写过程中不会读写、也不适用原来的 AOF 文件；</li><li>AOF 可以由用户手动触发，也可以由服务器自动触发。</li></ul><h2>5. 持久化的取舍和选择</h2><h4>RDB和AOF对比</h4><p><img src="http://bloghello.oursnail.cn/RDB%E5%92%8CAOF%E5%AF%B9%E6%AF%94.png" alt="image"></p><p>可以看出，世界上没有完美的东西，只有合适的东西。AOF同样存在一些问题：AOF文件的体积通常要大于RDB文件的体积、且恢复速度慢。</p><h4>RDB最佳策略</h4><p>“关”：建议关闭，但是后面主从复制功能是需要他的，因为需要主节点执行<code>dbsave</code>，然后将<code>rdb</code>文件传给从节点。所以说，关不是永久关。</p><p><strong>“集中管理”：虽然<code>RDB</code>很重，但是对于数据备份是很重要的，按照小时或者天集中地进行备份比较好，因为他的文件很小，利于传输。</strong></p><p>“主从，从开”：有时候从节点打开这个功能是比较好的，但是备份太频繁，取决于实际的场景。</p><h4>AOF最佳策略</h4><ul><li>“开”：建议打开，如果仅仅是作为一个普通缓存，对于数据要求不是很高，这次数据丢了，下次可以从数据库取(数据库压力不是很大)，这种情况就建议关闭，因为<code>AOF</code>还是有性能开销的。</li><li>“everysec”</li></ul><h4>Redis4</h4><p><code>Redis 4.0</code> 新增了 <code>RDB-AOF</code> 混合持久化格式， 这是一个可选的功能，</p><p>在开启了这个功能之后， <code>AOF</code> 重写产生的文件将同时包含 <code>RDB</code> 格式的内容和 <code>AOF</code> 格式的内容， 其中 <code>RDB</code> 格式的内容用于记录已有的数据， 而 <code>AOF</code> 格式的内存则用于记录最近发生了变化的数据， 这样 <code>Redis</code> 就可以同时兼有 <code>RDB</code> 持久化和 <code>AOF</code> 持久化的优点 —— 既能够快速地生成重写文件， 也能够在出现问题时， 快速地载入数据。</p><p>RDB和AOF共存的情况下如何恢复数据：</p><p><img src="http://bloghello.oursnail.cn/redis5-1.png" alt="image"></p><ul><li>优点：<ul><li>混合持久化结合了<code>RDB</code>持久化 和 <code>AOF</code> 持久化的优点,</li><li>由于绝大部分都是<code>RDB</code>格式，加载速度快，同时结合<code>AOF</code>，增量的数据以<code>AOF</code>方式保存了，数据更少的丢失。</li></ul></li><li>缺点：<ul><li>兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该<code>aof</code>文件，同时由于前部分是<code>RDB</code>格式，阅读性较差</li></ul></li></ul><p>策略是：</p><h2>6. 总结</h2><ul><li><a href="http://www.ywnds.com/?p=4876" target="_blank" rel="noopener">http://www.ywnds.com/?p=4876</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第五篇文章。redis处理数据都是在内存中进行，所以速度特别快，同样，它也可以支持持久化，这里注意，并不是说redis要来充当mysql那种角色，其实更多的是为了在崩溃的时候快速恢复以及主从复制这样的功能。redis的持久化主要有两种方式，一种是RDB，一种是AOF，对于他们的原理和区别都是比较重要的面试考察点，需要掌握。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>深入Nginx原理</title>
    <link href="http://yoursite.com/2019/01/30/miscellany/13%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Nginx%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/30/miscellany/13深入探究Nginx原理/</id>
    <published>2019-01-30T09:12:26.197Z</published>
    <updated>2019-01-30T09:15:09.299Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡中间件。是非常常用的web server.我们需要理解它的原理，才能达到游刃有余的程度。</p><a id="more"></a><p>本篇文章需要对Nginx有基本的使用以及对IO复用模型有一定的了解。文章比较长。</p><h2>1.正向代理和反向代理</h2><p><img src="http://xiaozhao.oursnail.cn/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="image"></p><p><strong>正向代理的工作原理就像一个跳板</strong>，比如：我访问不了<code>google.com</code>，但是我能访问一个代理服务器A，A能访问<code>google.com</code>，于是我先连上代理服务器A，告诉他我需要<code>google.com</code>的内容，A就去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="image"></p><p>反向代理（<code>Reverse Proxy</code>）方式是指以代理服务器来接受<code>internet</code>上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给<code>internet</code>上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><p>简单来说：</p><ul><li>正向代理是不知道客户端是谁，代理是一个跳板，所有客户端通过这个跳板来访问到对应的内容。</li><li>反向代理是不知道服务端是谁，用户的请求被转发到内部的某台服务器去处理。</li></ul><h2>2.基本的工作流程</h2><p><img src="http://xiaozhao.oursnail.cn/nginx%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="image"></p><ol><li>用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址；</li><li>反向代理服务器接受用户的请求；</li><li>反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</li><li>如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中。</li></ol><h2>3.优点</h2><ul><li>保护了真实的web服务器，保证了web服务器的资源安全</li><li>节约了有限的IP地址资源</li><li>减少WEB服务器压力，提高响应速度(缓存功能)</li><li>请求的统一控制，包括设置权限、过滤规则等</li><li>实现负载均衡</li><li>区分动态和静态可缓存内容</li><li>…</li></ul><h2>4.使用场景</h2><ul><li>Nginx作为Http代理、反向代理</li><li>Nginx作为负载均衡器</li><li>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</li><li>Nginx作为Web缓存</li></ul><h2>5.Nginx的Master-Worker模式</h2><p><img src="http://xiaozhao.oursnail.cn/Nginx%E7%9A%84Master-Worker%E6%A8%A1%E5%BC%8F.png" alt="image"></p><p>启动<code>Nginx</code>后，其实就是在80端口启动了<code>Socket</code>服务进行监听，如图所示，<code>Nginx</code>涉及<code>Master</code>进程和<code>Worker</code>进程。</p><p><img src="http://xiaozhao.oursnail.cn/Master-Worker%E6%A8%A1%E5%BC%8F.png" alt="image"></p><h2>6.Master进程的作用是？</h2><p>读取并验证配置文件<code>nginx.conf</code>；管理<code>worker</code>进程；</p><ul><li>接收来自外界的信号</li><li>向各worker进程发送信号</li><li>监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程</li></ul><h2>7.Worker进程的作用是？</h2><p>每一个<code>Worker</code>进程都维护一个线程（避免线程切换），处理连接和请求；注意<code>Worker</code>进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个<code>Worker</code>进程。</p><h5>思考：Nginx如何做到热部署？</h5><blockquote><p>所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载/nginx -t检查配置/nginx -s stop）</p><p>通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p>方案一：</p><p>修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点volatile的味道）</p><p>方案二：</p><p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p></blockquote><p>Nginx采用的就是方案二来达到热部署的！</p><h5>思考：Nginx如何做到高并发下的高效处理？</h5><blockquote><p>上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p><p>作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞…</p><p>要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</p><p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</p></blockquote><h5>思考：Nginx挂了怎么办？</h5><blockquote><p>Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p><p>答案是：Keepalived+Nginx实现高可用。</p><p>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</p><p>Keepalived+Nginx实现高可用的思路：</p><p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p><p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,从而实现Nginx故障切换）</p></blockquote><p><img src="http://xiaozhao.oursnail.cn/Keepalived+Nginx.png" alt="image"></p><h2>6.nginx.conf</h2><p><img src="http://xiaozhao.oursnail.cn/nginx.conf.png" alt="image"></p><ul><li>第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</li><li>第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。</li><li>第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</li><li>第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。</li></ul><p>除了可以映射静态资源，上面已经说了，可以作为一个代理服务器来使用。</p><blockquote><p>所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理，上面已经说了，过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。</p></blockquote><p>负载均衡【upstream】</p><blockquote><p>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><p>第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</p><p>第二，将proxy_pass替换成upstream指定的值即可。</p><p>负载均衡可能带来的问题？</p><p>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</p></blockquote><h2>7.惊群现象</h2><p>定义：惊群效应就是当一个fd的事件被触发时，所有等待这个fd的线程或进程都被唤醒。</p><p><code>Nginx</code>的IO通常使用<code>epoll</code>，<code>epoll</code>函数使用了I/O复用模型。与I/O阻塞模型比较，I/O复用模型的优势在于可以同时等待多个（而不只是一个）套接字描述符就绪。<code>Nginx</code>的<code>epoll</code>工作流程如下：</p><ul><li>master进程先建好需要listen的socket后，然后再fork出多个woker进程，这样每个work进程都可以去accept这个socket</li><li>当一个client连接到来时，所有accept的work进程都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败，Nginx提供了一把<strong>共享锁accept_mutex</strong>来保证同一时刻只有一个work进程在accept连接，从而解决惊群问题</li><li>当一个worker进程accept这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了</li></ul><h2>8.Nginx架构及工作流程</h2><p><img src="http://xiaozhao.oursnail.cn/Nginx%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p><p><code>Nginx</code>真正处理请求业务的是<code>Worker</code>之下的线程。<code>worker</code>进程中有一个<code>ngx_worker_process_cycle()</code>函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个<code>Nginx</code>服务被停止。</p><p>当一个 <code>worker</code> 进程在 <code>accept()</code> 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个完整的请求。一个请求，完全由 <code>worker</code> 进程来处理，而且只能在一个 <code>worker</code> 进程中处理。</p><p>这样做带来的好处：</p><ol><li>节省锁带来的开销。每个 <code>worker</code> 进程都是独立的进程，不共享资源，不需要加锁。同时在编程以及问题查上时，也会方便很多。</li><li>独立进程，减少风险。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，<code>master</code> 进程则很快重新启动新的 <code>worker</code> 进程。当然，<code>worker</code> 进程的也能发生意外退出。</li></ol><h2>9.nginx为什么高性能</h2><p><strong>因为nginx是多进程单线程的代表，多进程模型每个进程/线程只能处理一路IO，那么 Nginx是如何处理多路IO呢？</strong></p><p>如果不使用 IO 多路复用，那么在一个进程中，同时只能处理一个请求，比如执行 <code>accept()</code>，如果没有连接过来，那么程序会阻塞在这里，直到有一个连接过来，才能继续向下执行。</p><p>而多路复用，允许我们只在事件发生时才将控制返回给程序，而其他时候内核都挂起进程，随时待命。</p><p><strong>核心：Nginx采用的 IO多路复用模型epoll</strong></p><p><code>epoll</code>通过在<code>Linux</code>内核中申请一个简易的文件系统（文件系统一般用什么数据结构实现？B+树），其工作流程分为三部分：</p><ol><li>调用 <code>int epoll_create(int size)</code>建立一个<code>epoll</code>对象，内核会创建一个<code>eventpoll</code>结构体，用于存放通过<code>epoll_ctl()</code>向<code>epoll</code>对象中添加进来的事件，这些事件都会挂载在红黑树中。</li><li>调用 <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code> 在 <code>epoll</code> 对象中为 fd 注册事件，所有添加到<code>epoll</code>中的事件都会与设备驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个<code>sockfd</code>的回调方法，将<code>sockfd</code>添加到<code>eventpoll</code> 中的双链表</li><li>调用 <code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code> 来等待事件的发生，<code>timeout</code> 为 -1 时，该调用会阻塞直到有事件发生</li></ol><p>这样，注册好事件之后，只要有 fd 上事件发生，<code>epoll_wait()</code> 就能检测到并返回给用户，用户就能”非阻塞“地进行 I/O 了。</p><p><code>epoll()</code> 中内核则维护一个链表，<code>epoll_wait</code> 直接检查链表是不是空就知道是否有文件描述符准备好了。（<code>epoll</code> 与 <code>select</code> 相比最大的优点是不会随着 <code>sockfd</code> 数目增长而降低效率，使用 <code>select()</code> 时，内核采用轮训的方法来查看是否有fd 准备好，其中的保存 <code>sockfd</code> 的是类似数组的数据结构 <code>fd_set</code>，key 为 fd，value 为 0 或者 1。）</p><p>能达到这种效果，是因为在内核实现中 <code>epoll</code> 是根据每个 <code>sockfd</code> 上面的与设备驱动程序建立起来的回调函数实现的。那么，某个 <code>sockfd</code> 上的事件发生时，与它对应的回调函数就会被调用，来把这个 <code>sockfd</code> 加入链表，其他处于“空闲的”状态的则不会。在这点上，<code>epoll</code> 实现了一个”伪”AIO。但是如果绝大部分的 I/O 都是“活跃的”，每个 <code>socket</code> 使用率很高的话，<code>epoll</code>效率不一定比 <code>select</code> 高（可能是要维护队列复杂）。</p><p>可以看出，因为一个进程里只有一个线程，所以一个进程同时只能做一件事，但是可以通过不断地切换来“同时”处理多个请求。</p><p>例子：<code>Nginx</code> 会注册一个事件：“如果来自一个新客户端的连接请求到来了，再通知我”，此后只有连接请求到来，服务器才会执行 <code>accept()</code> 来接收请求。又比如向上游服务器（比如 PHP-FPM）转发请求，并等待请求返回时，这个处理的 <code>worker</code> 不会在这阻塞，它会在发送完请求后，注册一个事件：“如果缓冲区接收到数据了，告诉我一声，我再将它读进来”，于是进程就空闲下来等待事件发生。</p><p>这样，基于 多进程+epoll， Nginx 便能实现高并发。</p><h2>10.几种负载均衡的算法介绍</h2><blockquote><p>轮询（默认）</p></blockquote><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><blockquote><p>weight</p></blockquote><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><blockquote><p>ip_hash</p></blockquote><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问同一个后端服务器，可以解决session的问题。但是不能解决宕机问题。<br>前三种是nginx自带的，直接在配置文件中配置即可使用。</p><blockquote><p>fair（第三方）</p></blockquote><p>按后端服务器的相应时间来分配请求，相应时间短的优先分配。</p><blockquote><p>url_hash（第三方）</p></blockquote><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><h2>11.基于不同层次的负载均衡</h2><p><img src="http://bloghello.oursnail.cn/http1-6.png" alt="image"></p><p>七层就是基于URL等应用层信息的负载均衡；<br>同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。</p><p>换句话说:</p><ul><li>二层负载均衡会通过一个虚拟MAC地址接受请求，然后再分配到真是的MAC地址；</li><li>三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；</li><li>四层通过虚拟的URL或主机名接收请求，然后再分配到真是的服务器。</li></ul><p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。</p><p>比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。</p><p>七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p><p>负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。</p><p>负载均衡设备也常被称为&quot;四到七层交换机&quot;，那么四层和七层两者到底区别在哪里？</p><blockquote><p>第一，技术原理上的区别。</p></blockquote><p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><blockquote><p>第二，应用场景的需求。</p></blockquote><p>七层应用负载的好处，是使得整个网络更&quot;智能化&quot;。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。</p><p>另外一个常常被提到功能就是安全性。</p><h2>12.总结</h2><ol><li>理解正向代理和反向代理的概念</li><li>nginx的优点和使用场景</li><li>master和work两种进程的作用</li><li>如何热部署</li><li>Nginx单点故障的预防</li><li>映射静态文件、反向代理跳转到后端服务器处理的写法</li><li>惊群现象</li><li>Nginx 采用的是多进程（单线程） &amp; 多路IO复用模型(底层依靠epoll实现)</li><li>几种负载均衡的算法</li><li>四层的负载均衡和七层的负载均衡</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx是一个高性能的HTTP和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡中间件。是非常常用的web server.我们需要理解它的原理，才能达到游刃有余的程度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis为什么快</title>
    <link href="http://yoursite.com/2019/01/30/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/"/>
    <id>http://yoursite.com/2019/01/30/redis/Redis为什么快/</id>
    <published>2019-01-30T08:08:05.626Z</published>
    <updated>2019-01-30T09:00:35.737Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第四篇文章，本文主要攻克面试题-Redis为什么这么快。这就涉及Redis的线程模型啦。</p><a id="more"></a><h2>完全基于内存</h2><p><code>Redis</code>是纯内存数据库，相对于读写磁盘，读写内存的速度就不是几倍几十倍了，一般，<code>hash</code>查找可以达到每秒百万次的数量级。</p><h2>多路复用IO</h2><p>“多路”指的是多个网络连接，“复用”指的是复用同一个线程。<strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗）。</p><h2>Redis为什么是单线程的？</h2><p>因为CPU不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><h2>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h2><p>首先，<code>Redis</code> 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p><blockquote><p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ol><li><p>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p></li><li><p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</p></li><li><p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。</p></li></ol><p>第三种就是IO复用模型，<code>Linux</code>下的<code>select</code>、<code>poll</code>和<code>epoll</code>就是干这个的。<strong>将用户<code>socket</code>对应的<code>fd</code>注册进<code>epoll</code>，然后<code>epoll</code>帮你监听哪些<code>socket</code>上有消息到达</strong>，这样就避免了大量的无用操作。此时的<code>socket</code>应该采用非阻塞模式。这样，整个过程只在调用<code>select</code>、<code>poll</code>、<code>epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的<code>reactor</code>模式。</p></blockquote><p>所以，I/O多路复用的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。</p><p>这里还涉及一个名词：<strong>fd文件描述符。</strong></p><p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p><h2>redis的线程模型？</h2><p><code>Redis</code> 服务采用 <code>Reactor</code> 的方式来实现文件事件处理器。</p><p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p><p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 <code>Redis</code> 服务实现的简单。</p><p><img src="http://bloghello.oursnail.cn/redis%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86111.png-1000width" alt="image"></p><p>上面简单理解就是：多个网络连接并发读写redis的时候，先将对应的fd注册到<code>epoll</code>上，I/O多路复用模块会监听这些网络请求的情况，一旦有一个网络连接产生了<code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件，I/O多路复用模块就会向文件事件分派器传送那些产生了事件的网络连接。</p><p><img src="http://bloghello.oursnail.cn/redis4-1.png" alt="image"></p><p>当然了，上面的文件事件可能会并发产生，这时的策略是，将所有产生事件的套接字（对应上面的网络连接）都入队到一个队列里面， 然后通过这个队列， 以有序（<code>sequentially</code>）、同步（<code>synchronously</code>）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。再看看下图，与上图使一样的：</p><p><img src="http://bloghello.oursnail.cn/redis4-2.png" alt="image"></p><p>文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。</p><p>服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。</p><p><strong>整个模块使 <code>Redis</code> 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性，单线程还减少线程切换和调度，实现更加简单</strong></p><p><strong>最后总结一下</strong>，为什么<code>redis</code>比较快大概思路通俗的说就是：<code>Redis</code>是纯内存数据库，读取快，瓶颈在于IO上，如果使用阻塞式IO，因为是单线程的缘故，就会停止等待。所以采用IO多路复用监听文件描述符的状态，将对<code>redis</code>的开关读写换成事件，加入队列进行相应的事件处理，吞吐量比较大。</p><h2>IO复用模型的选择</h2><p>因为 Redis 需要在多个平台上运行，同时为了最大化执行的效率与性能，所以会根据编译平台的不同选择不同的 I/O 多路复用函数作为子模块，提供给上层统一的接口；</p><p>因为 <code>select</code> 函数是作为 <code>POSIX</code> 标准中的系统调用，在不同版本的操作系统上都会实现，所以将其作为保底方案：</p><p><img src="http://bloghello.oursnail.cn/redis4-3.png" alt="image"></p><p><code>Redis</code> 会优先选择时间复杂度为 <code>O(1)</code> 的 I/O 多路复用函数作为底层实现，包括 <code>Solaries 10</code> 中的 <code>evport</code>、<code>Linux</code> 中的 <code>epoll</code> 和 <code>macOS/FreeBSD</code> 中的 <code>kqueue</code>，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。</p><p>但是如果当前编译环境没有上述函数，就会选择 <code>select</code> 作为备选方案，由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 <code>O(n)</code>，并且只能同时服务 1024 个文件描述符，所以一般并不会以 <code>select</code> 作为第一方案使用。</p><h2>reids在linux下的安装</h2><p><code>Redis</code>对于<code>Linux</code>是官方支持的，安装起来也非常地简单，直接编译源码然后进行安装即可。</p><p>这里以<code>centos</code>为例，大概说一下步骤：</p><blockquote><p>下载redis编译工具:<code>yum install gcc</code>和<code>yum install g++</code></p></blockquote><blockquote><p>解压<code>redis.tar.gz</code>文件，进去之后进行编译:<code>make</code></p></blockquote><blockquote><p>然后安装：<code>make install PREFIX=/usr/local/redis</code></p></blockquote><blockquote><p>安装成功之后进入<code>/usr/local/redis/bin</code>下启动<code>redis</code></p><p><code>./redis-server</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第四篇文章，本文主要攻克面试题-Redis为什么这么快。这就涉及Redis的线程模型啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis其他的功能介绍</title>
    <link href="http://yoursite.com/2019/01/29/redis/Redis%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/01/29/redis/Redis其他的功能介绍/</id>
    <published>2019-01-29T13:49:41.030Z</published>
    <updated>2019-01-30T03:20:33.553Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第三篇文章，本文主要介绍redis一些其他的功能。遇到某些场景的时候可以想到redis是不是可以实现。</p><a id="more"></a><h2>一、慢查询日志</h2><h4>1.1 什么是慢查询日志</h4><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来。</p><h4>1.2 redis一条命令简单的生命周期</h4><p><img src="http://xiaozhao.oursnail.cn/redis%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image"></p><p>慢查询只会出现在【<strong>3.执行命令</strong>】这个阶段，即慢查询只记录命令执行时间，并不包括命令排队时间和网络传输时间。</p><h4>1.3 慢查询配置参数</h4><blockquote><p>慢查询的预设阀值  <code>slowlog-log-slower-than</code></p></blockquote><ul><li><code>slowlog-log-slower-than</code>参数就是预设阀值，单位是微秒,默认值是10000，如果一条命令的执行时间超过10000微妙(10毫秒)，那么它将被记录在慢查询日志中。</li><li>如果<code>slowlog-log-slower-than</code>的值是0，则会记录所有命令。</li><li>如果<code>slowlog-log-slower-than</code>的值小于0，则任何命令都不会记录日志。</li><li><code>redis</code>的操作一般是微妙级，<code>slowlog-log-slower-than</code>不要设置太大，一般设置为1毫秒。支持动态设置。</li></ul><blockquote><p>慢查询日志的长度<code>slowlog-max-len</code></p></blockquote><ul><li><code>slowlog-max-len</code>只是说明了慢查询日志最多存储多少条。</li><li><code>Redis</code>使用一个列表来存储慢查询日志，<code>showlog-max-len</code>就是列表的最大长度。</li><li>当慢查询日志已经到达列表的最大长度时，又有慢查询日志要进入列表，则最早插入列表的日志将会被移出列表，新日志被插入列表的末尾。</li><li>默认是128，但是<code>slowlog-max-len</code>不要设置太小，可以设置为1000以上.</li></ul><p><strong>慢查询日志是一个先进先出队列，慢查询较多的情况下，可能会丢失部分慢查询命令，可以定期执行<code>slow get</code>命令将慢查询日志持久化到其他存储中。然后制作可视化界面查询。</strong></p><h2>二、pipeline</h2><h4>2.1 为什么会出现Pipeline</h4><p>用普通的<code>get</code>和<code>set</code>，如果同时需要执行大量的命令，那就是等待上一条命令应答后再执行，这中间不仅仅多了<code>RTT（Round Time Trip）</code>，而且还频繁的调用系统IO，发送网络请求。</p><p><img src="http://bloghello.oursnail.cn/%E6%89%B9%E9%87%8F%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>对于多条命令不是有<code>mget</code>和<code>mset</code>吗？确实对于一批的<code>get</code>和<code>set</code>可以用<code>mget</code>和<code>mset</code>，但是它的问题在于如果我们需要同时传输<code>get</code>和<code>hget</code>呢？此时<code>pipeline</code>(流水线)就出现了。</p><p><img src="http://bloghello.oursnail.cn/%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="image"></p><p>所以流水线解决的问题是N条命令网络通信的减少。</p><p><img src="http://bloghello.oursnail.cn/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="image"></p><p>为什么说网络耗费时间大呢？这里给出一个极端的例子。</p><p><img src="http://bloghello.oursnail.cn/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%97%B6%E9%97%B4.png" alt="image"></p><p><code>pipeline</code>与原生M操作的对比。</p><ul><li>原生M操作是一个原子操作。</li></ul><p><img src="http://bloghello.oursnail.cn/%E5%8E%9F%E7%94%9FM%E6%93%8D%E4%BD%9C.png" alt="image"></p><ul><li><code>pipeline</code>非原子命令。</li></ul><p><img src="http://bloghello.oursnail.cn/pipeline%E9%9D%9E%E5%8E%9F%E5%AD%90%E5%91%BD%E4%BB%A4.png" alt="image"></p><p>当某个命令的执行需要依赖前一个命令的返回结果时，无法使用<code>pipeline</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset a “a1” b “b” c “c1” </span><br><span class="line">mget a b c</span><br></pre></td></tr></table></figure><p><code>mget</code>和<code>mset</code>命令也是为了减少网络连接和传输时间所设置的，其本质和<code>pipeline</code>的应用区别不大，但是在特定场景下只能用<code>pipeline</code>实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get a</span><br><span class="line">set b ‘1’</span><br></pre></td></tr></table></figure><p><code>pipeline</code>适合执行这种连续，且无相关性的命令。</p><h4>2.2 一个demo</h4><p>搭建一个<code>quickstart</code>的<code>maven</code>工程。过程略。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接再单元测试中进行测试：普通的直接<code>hset</code> 10000条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        jedis.hset(<span class="string">"hashkey"</span>+i,<span class="string">"filed"</span>+i,<span class="string">"value"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"一共耗时: "</span>+(after-before)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>一共耗时: 1526ms</p></blockquote><p>但是用pipeline后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//分为10次批量发送</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1000</span>*i;j&lt;(i+<span class="number">1</span>)*<span class="number">1000</span>;j++)&#123;</span><br><span class="line">            pipeline.hset(<span class="string">"hashkey:"</span>+j,<span class="string">"field:"</span>+j,<span class="string">"value:"</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        pipeline.syncAndReturnAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用pipeline一共耗时: "</span>+(after-before)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：使用<code>pipeline</code>一共耗时: 139ms</p></blockquote><p>可以预见，对于更多的传输次数，<code>pipeline</code>的优势将越来越明显。但是<code>pipeline</code>每次只能作用在一个<code>redis</code>节点上。</p><h2>三、发布订阅</h2><h4>3.1 角色</h4><p>发布者----频道----订阅者</p><h4>3.2 模型</h4><p><img src="http://bloghello.oursnail.cn/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>注意，新订阅的，是不能收到之前的消息的。</p><ul><li>订阅者1：subscribe mytopic</li><li>订阅者2：subscribe mytopic</li><li>订阅者3：subscribe mytopic</li><li>发布者：publish mytopic “hello”</li></ul><p>缺点是不能保证消息可达，所以还是用专业的消息队列传达比较保障。</p><p>与发布订阅模型很类似的是<strong>消息队列</strong>模型。</p><p><img src="http://bloghello.oursnail.cn/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>只有一个是可以收到消息的。</p><h2>四、bitMap</h2><h5>4.1 位图是什么</h5><p>就是通过一个<code>bit</code>位来表示某个元素对应的值或者状态,其中的<code>key</code>就是对应元素本身。我们知道8个<code>bit</code>可以组成一个<code>Byte</code>，所以<code>bitmap</code>本身会极大的节省储存空间。</p><p><code>Bitmap</code>不是一个确切的数据类型，而是基于<code>String</code>类型定义的一系列面向位操作的方法。因为<code>String</code>是二进制安全的并且它们的最大长度是512MB，<br>所以<code>String</code>类型很合适去作为一个2^32长度的位数组。</p><p>比如我们执行 <code>set hello big</code></p><p>那么这个<code>big</code>其实是这个形态：</p><p><img src="http://bloghello.oursnail.cn/%E5%AD%97%E7%AC%A6%E4%B8%B2big%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="image"></p><p>执行<code>getbit hello 0</code>  得到0； 执行<code>getbit hello 1</code> 得到1</p><p><code>setbit hello 7 1</code>，那么再<code>get hello</code> 将得到<code>cig</code></p><h5>4.2 位图有什么用呢？</h5><p>位图除了<code>getbit</code>和<code>setbit</code>之外，还有<code>bitcount key [start end]</code>，就是获取执行范围内的1的个数。</p><p><code>bitop</code>作用是做多个<code>Bitmap</code>的<code>and</code>,<code>or</code>,<code>not</code>,<code>xor</code>操作。</p><blockquote><p>以一个场景为例：日活跃用户</p></blockquote><p>每次用户登录时会执行一次<code>redis.setbit(daily_active_users, user_id, 1)</code></p><p>因为日活跃用户每天都变化，所以需要每天创建一个新的<code>bitmap</code>。我们简单地把日期（年月日）添加到key后面，以后就可以根据年月日这个key找到某天活跃用户。实现了这个功能。</p><blockquote><p>第二个场景：用户签到情况</p></blockquote><p>将那天所代表的网站的上线日作为<code>offset</code>参数， 比如,如果今天是网站上线的第100天,而用户$uid=10001在今天阅览过网站, 那么执行命令<code>SETBIT peter 100 1</code>. 如果明天<code>$uid=10001</code>也继续阅览网站,那么执行命令<code>SETBIT peter 101 1</code> ,以此类推.</p><p>仔细想想，用位图，一天签到一次只要占一个bit，8天才占一个字节。那么一年这个用户签到占的数据是365/8=45.625个字节.如果不用位图实现，保存一条记录将远远大于一个比特吧，那么当用户量很大的时候，差距将会特别大。</p><h2>五、hyperLogLog</h2><p>基于<code>HyperLogLog</code>算法：极小空间完成独立数量统计。本质还是字符串。</p><ul><li><code>pfadd key element [element...]</code>:向<code>hyperloglog</code>添加元素</li><li><code>pfcount key [key...]</code>:计算<code>hyperloglog</code>的独立总数</li><li><code>pfmerge destkey sourcekey [sourcekey...]</code>:合并多个<code>hyperloglog</code></li></ul><h4>api例子</h4><p><img src="http://bloghello.oursnail.cn/hyperloglogdemo.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/hyperloglogdemo2.png" alt="image"></p><h4>为什么要用hyperLogLog呢</h4><p>我们上面例子可以看到，他的功能类似于去重，统计出所有不一样元素的个数。</p><p>他的优点是：占用内存极小。</p><p><img src="http://bloghello.oursnail.cn/hyperloglog%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97.png" alt="image"></p><p>缺点也有：</p><ul><li>他可能会出错，错误率为0.81%，看你是否能够容忍错误了</li><li>不能拿到单条数据</li></ul><h2>六、geo</h2><p>存储经纬度、计算两地距离、范围计算等。</p><p>提到<code>LBS(Location Based Service)</code>，基于位置的服务。我立即想起<code>Mongodb</code>的<code>GEO</code>实现地理坐标查询等功能，具体介绍为<a href="http://fourcolor.oursnail.cn/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">地理位置附近查询的GEOHASH解决方案</a>。</p><p><code>mongodb</code>最大的特点是灵活，因为其数据是以<code>json</code>的格式存储，所以字段随时可以增加或减少；<code>Redis</code>的特点是快，适合单一的，简单的，大量数据的存储；<code>HBase</code>我没有做深入研究，它的特点是大，适合做离线缓存。在处理社交这种关系复杂的数据存储时，依然还是需要用<code>mysql</code>这种关系型数据库，<code>nosql</code>并不能完全替代。</p><h2>七、总结</h2><ul><li>首先是慢查询日志，可以定时地持久化，并且用一个可视化页面进行监测。</li><li>pipeline解决的是对没有相互依赖的操作的批量执行，减少网络传输和IO时间。但是呢，需要注意一般只能往一个节点放数据，面对集群的时候，就需要采取一些策略了。mset、mget，目前只支持具有相同slot值的key执行批量操作。后文再讲。</li><li>可以实现发布订阅模型以及消息队列，但是消息是无状态的，不能保证消息一定送达，所以需要用专业的MQ来实现。</li><li>位图，可以实现极小的空间完成对大量用户信息的统计。</li><li>地理坐标服务</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第三篇文章，本文主要介绍redis一些其他的功能。遇到某些场景的时候可以想到redis是不是可以实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基本数据结构和操作</title>
    <link href="http://yoursite.com/2019/01/29/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/01/29/redis/Redis基本数据结构和操作/</id>
    <published>2019-01-29T12:13:04.744Z</published>
    <updated>2019-01-29T12:18:18.520Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第二篇文章，本文主要介绍redis如何启动，以及基本的键命令和五种基本数据类型的操作。部分图片可能看不清楚，可以拖到新窗口打开。</p><a id="more"></a><h2>一、启动方式</h2><p>我的环境是<code>windows</code>，那么直接进入<code>redis</code>的解压目录中，分别执行<code>redis-server.exe</code>和<code>redis-cli.exe</code>两个可执行的程序。也可以通过<code>cmd</code>启动：</p><p><img src="http://bloghello.oursnail.cn/redis2-1.png" alt="image"></p><p>不要直接用<code>crtl+C</code>关闭<code>server</code>，在<code>linux</code>下，直接停掉<code>server</code>的话，会导致数据的丢失。正确的做法是在客户端执行 <code>redis-cli.exe shutdown</code></p><p><img src="http://bloghello.oursnail.cn/redis2-2.png" alt="image"></p><p>还可以指定端口启动：<code>./redis-server.exe --port 6380</code></p><p><img src="http://bloghello.oursnail.cn/redis2-3.png" alt="image"></p><p>那么对应客户端连接也要指定相应 的端口才能连接。关闭服务端也要指定相应的端口才行：</p><p><img src="http://bloghello.oursnail.cn/redis2-4.png" alt="image"></p><p><code>-h</code>指定远程<code>redis</code>的<code>ip</code></p><p><img src="http://bloghello.oursnail.cn/redis2-5.png" alt="image"></p><p>通过配置文件启动,可以在下面这个文件中指定端口号：</p><p><img src="http://bloghello.oursnail.cn/redis2-6.png" alt="image"></p><p>结合配置文件启动:</p><p><img src="http://bloghello.oursnail.cn/redis2-7.png" alt="image"></p><p>还可以设置密码：</p><p><img src="http://bloghello.oursnail.cn/redis2-8.png" alt="image"></p><p>那么客户端连接就必须要密码验证了：</p><p><img src="http://bloghello.oursnail.cn/redis2-9.png" alt="image"></p><h2>二、命令</h2><h6>1、基础命令</h6><p><code>info</code>:查看系统信息</p><p><code>select (0-15)</code>，redis一共有16个工作区间，一般默认从0开始，到15.</p><p><img src="http://bloghello.oursnail.cn/redis2-10.png" alt="image"></p><ul><li><code>flushdb</code>：清空当前选择的空间</li><li><code>flushall</code>：清空所有</li><li><code>dbsize</code>：当前空间里面key-value键值对的数目</li><li><code>save</code>：人工实现redis的持久化</li><li><code>quit</code>：退出</li></ul><h6>2、键命令</h6><p><code>del key</code>成功返回1，失败返回0.</p><p><img src="http://bloghello.oursnail.cn/redis2-11.png" alt="image"></p><p><code>exits key</code></p><p><img src="http://bloghello.oursnail.cn/redis2-12.png" alt="image"></p><p><code>ttl</code>和<code>expire</code></p><p><img src="http://bloghello.oursnail.cn/redis2-13.png" alt="image"></p><p><code>type key</code> 查看key的类型</p><p><code>randomkey</code>:</p><p><img src="http://bloghello.oursnail.cn/redis2-14.png" alt="image"></p><p><code>rename oldkey newkey</code></p><p><img src="http://bloghello.oursnail.cn/redis2-15.png" alt="image"></p><p>如果是重命名为已经存在的key呢？</p><p><img src="http://bloghello.oursnail.cn/redis2-16.png" alt="image"></p><p><code>renamenx</code>:</p><p><img src="http://bloghello.oursnail.cn/redis2-17.png" alt="image"></p><h2>三、redis数据结构</h2><h6>1、String字符串</h6><p><code>setex</code>&amp;<code>psetex</code></p><p><img src="http://bloghello.oursnail.cn/redis2-18.png" alt="image"></p><p><code>getrange</code>&amp;<code>getset</code></p><p><img src="http://bloghello.oursnail.cn/redis2-19.png" alt="image"></p><p><code>mset</code>&amp;<code>mget</code>&amp;<code>strlen</code></p><p><img src="http://bloghello.oursnail.cn/redis2-20.png" alt="image"></p><p><code>setnx</code>&amp;<code>msetnx</code></p><p><img src="http://bloghello.oursnail.cn/redis2-21.png" alt="image"></p><p>数值操作</p><p><img src="http://bloghello.oursnail.cn/redis2-22.png" alt="image"></p><h5>2、hash</h5><p><img src="http://bloghello.oursnail.cn/redis2-23.png" alt="image"></p><h5>3、list</h5><p><img src="http://bloghello.oursnail.cn/redis2-24.png" alt="image"></p><h5>4、set</h5><p><img src="http://bloghello.oursnail.cn/redis2-25.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/redis2-26.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/redis2-27.png" alt="image"></p><h6>5、sorted set</h6><p><img src="http://bloghello.oursnail.cn/redis2-28.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第二篇文章，本文主要介绍redis如何启动，以及基本的键命令和五种基本数据类型的操作。部分图片可能看不清楚，可以拖到新窗口打开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>初步认识Redis</title>
    <link href="http://yoursite.com/2019/01/29/redis/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86Redis/"/>
    <id>http://yoursite.com/2019/01/29/redis/初步认识Redis/</id>
    <published>2019-01-29T09:31:42.493Z</published>
    <updated>2019-01-29T09:40:28.068Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第一篇文章，主要从感性层面来认识一下这个开发中的宠儿，无论是什么应用，只要有点用户量的，不上redis是不可能的。作为当今最优秀的缓存中间件，没有理由不去深入了解它！</p><a id="more"></a><h2>一、redis是什么</h2><p>redis很快，官方宣称QPS(每秒查询率)达10万。</p><p><code>Redis</code>是一个开源的使用<code>ANSI C</code>语言编写、支持网络、<strong>单进程单线程</strong>、<strong>可基于内存亦可持久化</strong>、一个高性能的<code>key-value</code>数据库。</p><p>简而言之，就是一个缓存数据库，基于内存，也可以持久化，速度贼快，几乎所有互联网公司都在使用。</p><p>有的初学者可能看到数据库这个字眼，就把他归类于mysql之类，其实不是，mysql是一种关系型数据库，是存在磁盘中的。核心的数据是一定要落地到mysql之类的数据库中的。redis其实使用最多的功能是缓存，既然能存东西，那么必然也有数据库的功能，但是有可能会造成数据的缺失。所以，数据一定是要落入数据库才保险，redis可以作为缓存，缓存热点数据或者只读数据，提高性能并保护数据库。</p><h2>二、为什么要用redis</h2><p>好了，我们已经知道它是一个高性能的缓存中间件。那么必然一大功能是作为缓存使用。那为什么要用缓存呢？直接从数据库查不就行了码？</p><p>在实际的业务场景中，用户量一上来，数据库是吃不消的。数据库是性能的一大瓶颈，如果不采取措施，用户的操作将卡在数据库处理这一块，最终可能导致不可用。</p><p>那么，此时，加入缓存，比如商城首页有很多很多内容，这些内容不可能经常变化，至少也要两三天吧？所以，可以将这些数据放到redis中，用户进商城之后，数据直接从redis中获取即可。速度极快，提高了用户的体验。</p><p>既然是缓存，那么必定会存在数据不一致的情况，所以缓存最适合于读多写少的情况，当然啦，要修改缓存肯定是可以的，但是要注意热点key的问题，比如微博最火的一片新闻，此时有几百万人再看，你却要修改一下，肯定是要注意点什么东西才行的，后续的文章会讲到如何处理热点key修改的问题。</p><h2>三、Redis与其他key-value存储有什么不同</h2><p>这里先简单说说，后面会有文章详细比价一下。</p><ul><li>多样的数据结构和原子性操作</li></ul><p><code>Redis</code>有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。<code>redis</code>中的单个命令都是原子性的，什么是原子性，就是该命令不可分割。</p><ul><li>运行于内存+持久化于磁盘</li></ul><p><code>Redis</code>运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。另一个优点是， <strong>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样<code>Redis</code>可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</strong>。</p><p>注：我们要知道，对于磁盘的顺序访问速度是远大于随机访问的。这种在硬盘上顺序追加效率很高。</p><h2>四、redis特点</h2><ul><li><strong>速度快</strong>： 基于内存,这是快的最主要原因。</li><li><strong>持久化</strong>： 可以同步或异步保存到磁盘中</li><li><strong>多种数据结构</strong>： 除了五种基本数据类型，还支持位图、<code>HyperLogLog</code>，<code>GEO</code>等</li><li><strong>支持多种编程语言客户端</strong>： <code>java</code>，<code>python</code>，<code>ruby</code>，<code>Lua</code>…</li><li><strong>功能丰富</strong>： 可以实现发布-订阅，支持事务、<code>Lua</code>脚本</li><li><strong>简单</strong>： 不依赖与外部库、单线程模型</li><li><strong>主从复制</strong>： 主服务器同步数据到从服务器，是高可用的基础</li><li><strong>高可用、分布式</strong>： 高可用：<code>redis-Sentinel</code>(v2.8版本)；分布式：<code>redis-cluster</code>(v3.0版本)</li></ul><h2>五、redis典型应用场景</h2><ul><li><strong>缓存系统</strong>：这个就不多说了，<code>redis</code>作为高速缓存是其主要存在价值。</li><li><strong>计数器</strong>：因为是原子操作<code>incr</code>+单线程，作为计数器永远不会出错</li><li><strong>消息队列系统</strong>：数据结构<code>list</code>可以实现这种生产者-消费者模式的消息队列。</li><li><strong>排行榜</strong>：有序集合<code>sorted set</code>就可以实现</li><li><strong>社交网络</strong>：<code>redis</code>与社交网络就是一家，非常方便用<code>set</code>就能实现诸如共同好友这些功能。</li></ul><h2>六、redis优势</h2><ul><li><strong>缓存管理</strong>：可以在必要时将无效的旧数据从内存中删除，为新数据腾出新的空间</li><li><strong>提供更大的灵活性</strong>：<code>redis</code>支持多种类型，并且采用<code>key-value</code> 的形式存储，<code>key</code>和<code>value</code>的大小限制都是512Mb,与编码无关，所以数据安全。但是<code>memcached</code>限制<code>key</code>最大为250字节，<code>value</code>为1MB，况且只支持<code>String</code>类型。</li><li><strong><code>redis</code>提供主从复制</strong>：实现高可用的<code>cache</code>系统，支持集群中多个服务器之间的数据同步。</li><li><strong>数据持久化</strong>：<code>redis</code>可以通过两种方式将数据进行持久化，一定程度上规避缓存中的数据不稳定的问题，也可以在重启服务器时最快的恢复缓存中所需的数据，提高了效率的同时减轻了主数据库系统的开销。</li></ul><p>与传统的<code>Memcached</code>相比，优势还是很大的，两者的具体对比我会在后续的文章中详细说明。这里注意存在即合理，<code>Memcached</code>也有不可替代的适用场景：</p><ul><li>存储一些粒度比较小的静态数据，比如一些html片段，<code>Memcached</code>便是我们更好的选择。相对于<code>redis</code>而言，<code>Memcached</code>的元数据<code>metadata</code>更小些，所以相对来讲对于数据存储管理的性能更高，额外开销更小。</li><li><code>Memcached</code>的特点：<code>Memcached</code>唯一支持的数据类型是<code>String</code>,所以更适合存储只读数据，因为字符串并不会因为额外的处理造成额外的开销。毕竟<code>Memcached</code>每次更新一个对象时，都需要重复执行下面的操作：获取整个字符串-&gt;反序列化为对象-&gt;修改其中的值-&gt;再次序列化该对象-&gt;在缓存中将整个字符串替换为新字符串。这样一来，更新存储数据就会有更高的消耗，可能就不是我们的最佳选择了。</li></ul><h2>七、总结</h2><p>只要记住redis三个关键字：快、持久化、高可用和分布式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第一篇文章，主要从感性层面来认识一下这个开发中的宠儿，无论是什么应用，只要有点用户量的，不上redis是不可能的。作为当今最优秀的缓存中间件，没有理由不去深入了解它！&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>地理位置附近查询的GEOHASH解决方案</title>
    <link href="http://yoursite.com/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/01/29/miscellany/12地理位置附近查询的GEOHASH解决方案/</id>
    <published>2019-01-29T06:56:46.183Z</published>
    <updated>2019-01-29T06:59:36.130Z</updated>
    
    <content type="html"><![CDATA[<p>地理位置附近查询的GEOHASH解决方案</p><a id="more"></a><h2>1.需求场景</h2><p>现今互联网确实从方方面面影响我们的生活。现在我们可以足不出户就能买到我们心仪的衣服，找到附近的美食。当我们点开一个外卖的app就能看到自己附近的餐厅，那我们有没有想过这是怎么实现的呢？</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.png" alt="image"></p><h2>2.尝试解决</h2><ul><li>首先我们能想到的就是把所有餐厅的经纬度存下来</li><li>然后当用户选择附近餐厅时</li><li>我们先获取用户的经纬度，然后到数据库中查出所有的经纬度，依次计算它们和用户间的距离。</li><li>最后根据用户输入的距离范围过滤出合适的餐厅，并根据距离做一个升序排列。</li></ul><p>这样貌似能查出附近的餐厅，但是餐厅的数量这么多，直接全查出来内存也要爆掉，即使分批处理计算量也十分大。这样用户等待的时间就会特别长。那有什么办法能减少我们的计算量呢？</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%883.png" alt="image"></p><p>其实很简单，我们应该只计算用户关心的那一片数据，而不是计算所有的。例如用户在北京，那完全没必要计算海南，黑龙江，新疆，浙江等其它地区的数据。如果我们能快速定位到北京甚至某个区，那么我们的计算量将大大减少。我们发现这其实就是索引的功能，但是<code>MySQL</code>对这种二维的地理位置的索引支持并不友好（<code>mongodb</code>有直接的地理位置索引），它对一维的像字符串这样的支持很好。那如果我们的数据在MySQL中，有没有什么方法能将我们的二维坐标转换为一种可比较的字符串呢？这就是我们今天要介绍的<code>geohash</code>算法。</p><h2>3.基本思想</h2><p><strong><code>geohash</code>简单来说就是将一个地理坐标转换为一个可比较的字符串的算法。不过生成的字符串表示的是一个矩形的范围，并不是一个点。</strong></p><p>比如西二旗地铁附近这一片矩形区域就可以用<code>wx4eyu82</code>这个字符串表示，并且越靠前的编码表示额范围越大，比如中国绝大部分地区可以用w这个字母表示的矩形区域内。像<code>wx4eyu82</code>表示的区域一定在<code>wx4e</code>表示的区域范围内。利用这些特性我们就可以实现附近餐厅的功能了，比如我们希望查看西二旗地铁附近的餐厅就可以这样查询：<code>select * from table where geohash like 'wx4eyu82%';</code> 这样就可以利用索引，快速查询出相关餐厅的信息了。并且我们还可以用<code>wx4eyu82</code>为<code>key</code>，餐厅信息为<code>value</code>做缓存。</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882.png" alt="image"></p><p><strong>通过上面的介绍我们知道了<code>GeoHash</code>就是一种将经纬度转换成字符串的方法，并且使得在大部分情况下，字符串前缀匹配越多的距离越近.</strong></p><h2>4.GeoHash算法的步骤</h2><ul><li>首先我们将经度和纬度都单独转换为一个二进制编码</li><li>得到经度和纬度的二进制编码后，我们按照奇数位放纬度，偶数为放经度的规则（我们这里奇数偶数下标是从0开始）将它们合成一个二进制编码</li><li>最后我们需要将这个二进制编码转换为base32编码</li></ul><p><strong>举例</strong></p><ul><li>地球纬度区间是[-90,90]， 北海公园的纬度是39.928167，可以通过下面算法对纬度39.928167进行逼近编码:<ul><li>区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1；</li><li>接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0；</li><li>递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167；</li><li>如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，这样随着算法的进行会产生一个序列1011100，序列的长度跟给定的区间划分次数有关。</li></ul></li><li>通过上述计算，纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。</li><li>最后使用用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，首先将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。</li></ul><h2>5.缺陷-geohash的边界问题</h2><p>比如红色的点是我们的位置，绿色的两个点分别是附近的两个餐馆，但是在查询的时候会发现距离较远餐馆的<code>GeoHash</code>编码与我们一样（因为在同一个GeoHash区域块上），而较近餐馆的<code>GeoHash</code>编码与我们不一致。</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%884.png" alt="image"></p><p>目前比较通行的做法就是我们不仅获取当前我们所在的矩形区域，还获取周围8个矩形块中的点。那么怎样定位周围8个点呢？关键就是需要获取周围8个点的经纬度，那我们已经知道自己的经纬度，只需要用自己的经纬度减去最小划分单位的经纬度就行。因为我们知道经纬度的范围,又知道需要划分的次数，所以很容易就能计算出最小划分单位的经纬度。</p><h2>6.几种实现geohash方案的对比</h2><h4>6.1支持二维索引的存储数据库：mongodb</h4><p><code>mongoDB</code>支持二维空间索引,使用空间索引,<code>mongoDB</code>支持一种特殊查询,如某地图网站上可以查找离你最近的咖啡厅,银行等信息。这个使用<code>mongoDB</code>的空间索引结合特殊的查询方法很容易实现。</p><ul><li>API直接支持，很方便</li><li>支持按照距离排序，并支持分页。支持多条件筛选。</li><li>可满足实时性需求。</li><li>资源占用大，数据量达到百万级请流量在10w左右查询速度明显下降。</li></ul><h4>6.2升级Mysql至5.7，支持Geohash</h4><p><code>MySQL 5.7.5</code> 增加了对<code>GeoHash</code>的支持，提供了一系列<code>geohash</code>的函数，但是其实<code>Mysql</code>并没有提供类似<code>mogodb</code>类型<code>near</code>这样的函数，仅仅提供了一些经纬度转<code>hash</code>、<code>hash</code>取经纬度的一些函数。</p><ul><li>优点:函数直接调用，生成目标<code>hash</code>、根据<code>hash</code>获取经纬度。</li><li>缺点：不支持范围查询函数，需要自行处理周边8点的问题，需要补充<code>geo</code>的算法</li></ul><h4>6.3Redis Commands: Geography Edition</h4><p>GEO 特性在 Redis 3.2 版发布， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作，GEO通过如下命令来完成GEO需求.</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd</td><td>添加一个或多个经纬度地理位置</td></tr><tr><td>georadius</td><td>获取指定范围内的对象，也可以增加参数withdistance直接算出距离，也可以增加参数descending/ascending 进行距离排序</td></tr><tr><td>georadiusbymember</td><td>通过指定的对象，获取其周边对象</td></tr><tr><td>geoencode</td><td>转换为geohash，52-bit，同时返回该区域最小角的geohash,最大角的geohash，及中心点</td></tr><tr><td>geodecode</td><td>同上逆操作</td></tr></tbody></table><ul><li>优点:效率高，API丰富</li><li>缺点：3.2版本是否稳定？</li></ul><p>面试的时候，问到geohash算法以及技术选型大概也能说一说了…</p><p>本文章借鉴很多优秀文章，七拼八凑而出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;地理位置附近查询的GEOHASH解决方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>补码的前世今生</title>
    <link href="http://yoursite.com/2019/01/29/java-basic/%E8%A1%A5%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://yoursite.com/2019/01/29/java-basic/补码的前世今生/</id>
    <published>2019-01-29T06:32:32.323Z</published>
    <updated>2019-01-29T07:33:31.138Z</updated>
    
    <content type="html"><![CDATA[<p>计算机如何来保存负数呢？其实只要达到这样的目的：正数负数都有一个唯一标识即可，但是，正如人类用+1和-1来表示可以提高效率一样，也得有一个比较适当的适合我们的计算机识别的一个方式。下面来详细讲解。</p><a id="more"></a><h2>问题的由来</h2><p>下面为了表示方便，先假设存储一个整型数字用4个bit。</p><p>举例来说，+2在计算机中表示为二进制的0010，那么-2怎么表示呢？</p><p>很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+2就是<code>0010</code>，而-8则是<code>1010</code>。</p><p>更多的例子如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic5-1.png" alt="image"></p><p>这就是直接用原码的方式来存储，虽然说这种方式理论上是可行的，毕竟每个数我都唯一标识了。</p><p>但是这种方式存在问题，我们希望+1和-1相加为0，但是通过这个方式算出来的是：0001+1001=1010 (-2)。也就是说，按照正常一步头的方式得不到我们想要的结果。</p><p>为了解决了“正负相加等于0”的问题，人们发明了反码。</p><h2>反码</h2><p>“反码”表示方式是用来处理负数的，符号位置不变，其余位置相反。</p><p><img src="http://bloghello.oursnail.cn/javabasic5-2.png" alt="image"></p><p>此时，我们再来算一下+1和-1相加，变成了0001+1110=1111，刚好反码表示方式中，1111象征-0。</p><p>此时，好像是解决了这个问题，但是我们发现，0这个时候有了两种表达：0000和1111。</p><p>即在用反码表示的情况下，0竟然可以用两个值来表示，这显然不好吧。毕竟+0和-0就是同一个玩意啊。</p><p>这个时候补码闪亮登场。</p><h2>补码</h2><p>很简单，在刚才反码的基础上加1。</p><p><img src="http://bloghello.oursnail.cn/javabasic5-3.png" alt="image"></p><p>此时，我们这里假定整形只有4位。那么-0表示为1111+1=10000，显然溢出了，就需要丢弃最高位，变成0000.</p><p>此时，神奇地发现，达到了统一，+0和-0都是用0000来表示了。</p><p>此时，也满足正负数相加为0的条件。比如+2为0010，-2为1110.此时两者相加为：0010+1110=(0)0000，丢掉最高位就是0000</p><p>那么对于普通情况，比如7+(-4)呢?即0111+1100=0011，就是3。OK，大功告成。</p><h2>补码怎么求</h2><p>上面已经说的很详细啦，比如-4，就是在4(0100)的基础上取反(1011)再加一(1100).</p><p>上面也解释了为什么要用补码。即保证了对称的正负数相加为0并且0只有一种表示方式。</p><p>还有一个重要的点就是，我们注意到，7-4其实我们都是转换成7+(-4)，也就是说，在计算机中，减法都是用加法的逻辑实现的。</p><p>即：一套加法的电路实现加减法。此外，乘法和除法其实都是加法这套电路实现的。</p><h2>补码的本质</h2><p>这里假设存储一个整型用8个bit。</p><p>要将正数转成对应的负数，其实只要用0减去这个数就可以了。比如，-8其实就是0-8。</p><p>则8的二进制是00001000，-8就可以用下面的式子求出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　００００００００</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br></pre></td></tr></table></figure><p>因为00000000（被减数）小于0000100（减数），所以不够减。请回忆一下小学算术，如果被减数的某一位小于减数，我们怎么办？很简单，问上一位借1就可以了。</p><p>所以，0000000也问上一位借了1，也就是说，被减数其实是100000000，算式也就改写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">１００００００００</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１１０００</span><br></pre></td></tr></table></figure><p>进一步观察，可以发现100000000 = 11111111 + 1，所以上面的式子可以拆成两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　１１１１１１１１</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１０１１１</span><br><span class="line">＋０００００００１</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１１０００</span><br></pre></td></tr></table></figure><p>通过这一步，我们就从数学上知道了为什么补码是取反加一了。</p><p>你看，求任何一个负数，都是0-正数，那么就用借位的思想来，则变成100000000。</p><p>100000000则可以分解为11111111+00000001。</p><p>此时求负数的过程就就变成11111111-X+1</p><ul><li>而先用11111111来减这个正数，这个结果就是对正数取反。</li><li>此时再加上另外一个1.</li></ul><p>这与我们求补码的过程是一样的，这也解释了为什么要这样求补码。</p><h2>证明(可不看)</h2><p>将上面的特例抽象一下，用统一表达式来证明一下。</p><p>我们要证明的是，X-Y或X+(-Y)可以用X加上Y的补码完成。</p><p>Y的补码等于(11111111-Y)+1。所以，X加上Y补码，就等于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + (11111111-Y) + 1</span><br></pre></td></tr></table></figure><p>我们假定这个算式的结果等于Z，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = X + (11111111-Y) + 1</span><br></pre></td></tr></table></figure><p>接下来，分成两种情况讨论。</p><ul><li>第一种情况，如果X小于Y，那么Z是一个负数。</li></ul><p>由Y的补码等于(11111111-Y)+1，标记为F=(11111111-Y)+1,那么如何根据F逆向求Y呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y=1111111-(F-1)</span><br></pre></td></tr></table></figure><p>OK,因为此时Z是一个负数，那么Z进行补码的逆运算就可以求出它的绝对值，即正数。再加一个符号，两者相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = -[11111111-(Z-1)] = -[11111111-(X + (11111111-Y) + 1-1)] = X - Y</span><br></pre></td></tr></table></figure><ul><li>第二种情况，如果X大于Y</li></ul><p>这意味着Z肯定大于11111111，但是我们规定了这是8位机，最高的第9位是溢出位，必须被舍去，这相当于减去100000000。所以，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = Z - 100000000 = X + (11111111-Y) + 1 - 100000000 = X - Y</span><br></pre></td></tr></table></figure><p>这就证明了，在正常的加法规则下，可以利用2的补码得到正数与负数相加的正确结果。换言之，计算机只要部署加法电路和补码电路，就可以完成所有整数的加法。</p><p>本文整理自：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="noopener">关于2的补码</a></li><li><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="noopener">知乎第一条评论</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机如何来保存负数呢？其实只要达到这样的目的：正数负数都有一个唯一标识即可，但是，正如人类用+1和-1来表示可以提高效率一样，也得有一个比较适当的适合我们的计算机识别的一个方式。下面来详细讲解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot使用logback实现日志按天滚动</title>
    <link href="http://yoursite.com/2019/01/28/miscellany/11SpringBoot%E4%BD%BF%E7%94%A8logback%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%8C%89%E5%A4%A9%E6%BB%9A%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/01/28/miscellany/11SpringBoot使用logback实现日志按天滚动/</id>
    <published>2019-01-28T14:03:48.198Z</published>
    <updated>2019-01-28T14:06:43.235Z</updated>
    
    <content type="html"><![CDATA[<p>日志是任何一个系统都必备的东西，日志的重要程度丝毫不亚于代码。而springboot中经常使用的是logback，那么今天我们就来学习一下在springboot下如何配置logback日志。理解了这里的配置，对于任何的日志都是一样的。</p><a id="more"></a><h2>需求</h2><ul><li>日志按天滚动分割</li><li><code>info</code>和<code>error</code>日志输出到不同文件</li></ul><h2>为什么使用Logback</h2><ul><li><code>Logback</code>是<code>Log4j</code>的升级版，作者为同一个人，作者不想再去改<code>Log4j</code>，所以写了<code>Logback</code></li><li>使用日志框架的最佳实践是选择一款日志门面+一款日志实现，这里选择<code>Slf4j</code>+<code>Logback</code>,<code>Slf4j</code>作者也是<code>Logback</code>的作者</li><li><code>SpringBoot</code>从1.4版本开始，内置的日志框架就是<code>Logback</code></li></ul><h2>Logback在SpringBoot中配置方式一</h2><p>可以直接在<code>applicatin.properties</code>或者<code>application.yml</code>中配置</p><p>以在<code>application.yml</code>中配置为例</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  pattern:</span></span><br><span class="line"><span class="attr">    console:</span> <span class="string">"%d - %msg%n"</span></span><br><span class="line"><span class="attr">  file:</span> <span class="string">/var/log/tomcat/sell.log</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">com.imooc.LoggerTest:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>可以发现，这种配置方式简单，但能实现的功能也很局限，只能</p><ul><li>定制输出格式</li><li>输出文件的路径</li><li>指定某个包下的日志级别</li></ul><p>如果需要完成我们的需求，这就得用第二种配置了</p><h2>Logback在SpringBoot中配置方式二</h2><p>在<code>resource</code>目录下新建<code>logback-spring.xml</code>, 内容如下</p><?xml version="1.0" encoding="UTF-8" ?><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打印到控制台的格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"consoleLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--除了error级别的日志文件保存格式以及滚动策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileInfoLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--过滤器，将error级别过滤掉--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/var/log/tomcat/sell/info.%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--error级别日志文件保存格式以及滚动策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileErrorLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只让error级别的日志进来--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/var/log/tomcat/sell/error.%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileInfoLog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileErrorLog"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个<code>appender</code>你可以理解为一个日志处理策略。</p><p>第一个<code>appender</code>的<code>name=&quot;consoleLog&quot;</code>,</p><p>名字是自己随意取的，取这个名字，表示这个策略用于控制台的日志。</p><p>我们重点看第二个和第三个<code>appender</code>,因为要把<code>info</code>和<code>error</code>日志输入到不同文件，所以我们分别建了两个<code>appender</code>。</p><p><code>rollingPolicy</code>是滚动策略，这里我们设置按时间滚动</p><p><code>filter</code>是日志的过滤方式，我们在<code>fileInfoLog</code>里做了如下过滤</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码翻译之后：拦截<code>ERROR</code>级别的日志。如果匹配到了，则禁用处理。如果不匹配，则接受，开始处理日志。</p><p>那有的同学要问了，不能这样写吗</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样不是只拦截<code>INFO</code>日志了吗？</p><p>不对！</p><p>这就得说一下日志级别了</p><p><code>DEBUG</code> -&gt;<code>INFO</code> -&gt; <code>WARN</code> -&gt;<code>ERROR</code></p><p>如果你设置的日志级别是<code>INFO</code>，那么是会拦截<code>ERROR</code>日志的哦。也就是说，如果直接写<code>info</code>，那么大于等于<code>info</code>级别的日志都会写进去，违背了我们的需求。</p><p>整理自：</p><ul><li><a href="http://www.imooc.com/article/19005" target="_blank" rel="noopener">http://www.imooc.com/article/19005</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志是任何一个系统都必备的东西，日志的重要程度丝毫不亚于代码。而springboot中经常使用的是logback，那么今天我们就来学习一下在springboot下如何配置logback日志。理解了这里的配置，对于任何的日志都是一样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试高频理论知识</title>
    <link href="http://yoursite.com/2019/01/27/mysql/mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/01/27/mysql/mysql面试高频理论知识/</id>
    <published>2019-01-27T14:26:35.934Z</published>
    <updated>2019-01-27T14:31:07.601Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些面试题，简单看看。</p><a id="more"></a><p>目录</p><ol><li>数据库三范式</li><li>事务</li><li>mysql数据库默认最大连接数</li><li>分页</li><li>触发器</li><li>存储过程</li><li>用jdbc怎么调用存储过程？</li><li>对jdbc的理解</li><li>写一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序</li><li>JDBC中的PreparedStatement相比Statement的好处</li><li>数据库连接池作用</li><li>选择合适的存储引擎</li><li>数据库优化-索引</li><li>数据库优化-分表</li><li>数据库优化-读写分离</li><li>数据库优化-缓存</li><li>数据库优化-sql语句优化的技巧</li><li>jdbc批量插入几百万数据怎么实现</li><li>聚簇索引和非聚簇索引</li><li>sql注入问题</li><li>mysql悲观锁和乐观锁</li></ol><h2>1. 数据库三范式</h2><h3>1.1 范式是什么</h3><p>范式就是规范，要满足第二范式必须先满足第一范式，要满足第三范式，必须要先满足第二范式。</p><ul><li>1NF(第一范式)：列数据不可分割，即一列不能有多个值</li><li>2NF(第二范式)：主键(每一行都有唯一标识)</li><li>3NF(第三范式)：外键(表中不包含已在其他表中包含的非主关键信息)</li></ul><h3>1.2 反三范式</h3><p>反三范式：有时为了效率，可以设置重复或者推导出的字段，例如：订单总价格订单项的单价，这个订单总价虽然可以由订单项计算出来，但是当订单数目庞大时，效率比较低，所以订单的总价这个字段是必要的。</p><h2>2. 事务</h2><h3>2.1 含义</h3><p>事务时并发控制的单位，是用户定义的一个操作序列，要么都做，要么都不做，是不可分割的工作单位。</p><h3>2.2 事务的四个特征(ACID特性)</h3><ul><li>原子性：表示事务内操作不可分割</li><li>一致性：要么成功，要么失败，若后面失败，前面则回滚</li><li>隔离性：一个事务开始了，不被其他事务干扰</li><li>持久性：事务开始了，就不能突然终止</li></ul><h2>3. mysql数据库默认最大连接数</h2><h3>3.1 为什么需要最大连接数</h3><p>特定服务器上的数据库只能支持一定数目同时连接，这时需要我们设置最大连接数（最多同时服务多少连接）。在数据库安装时会有一个默认的最大连接数。</p><blockquote><p><code>my.ini</code>中<code>max_connections=100</code></p></blockquote><h2>4. 分页</h2><h3>4.1 为什么需要分页？</h3><p>在很多数据时，不可能完全显示数据。进行分段显示.</p><h3>4.2 mysql如何分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = </span><br><span class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="string">" + pageSize*(pageNumber-1) + "</span>,<span class="string">" + pageSize;</span></span><br></pre></td></tr></table></figure><h3>4.3 oracle分页</h3><p>是使用了三层嵌套查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = </span><br><span class="line"> &quot;select * from &quot; +  </span><br><span class="line"> (select *,rownum rid from (select * from students order by postime desc) where rid&lt;=&quot; + pagesize*pagenumber + &quot;) as t&quot; + </span><br><span class="line"> &quot;where t&gt;&quot; + pageSize*(pageNumber-1);</span><br></pre></td></tr></table></figure><h2>5. 触发器</h2><p>略。</p><h2>6. 存储过程</h2><h3>6.1 数据库存储过程具有如下优点：</h3><ul><li><p>1、存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。</p></li><li><p>2、通常，复杂的业务逻辑需要多条 SQL 语句。这些语句要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会大大减少，降低了网络负载。</p></li><li><p>3、存储过程创建一次便可以重复使用，从而可以减少数据库开发人员的工作量。</p></li><li><p>4、安全性高，存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，无需拥有访问底层数据库对象的显式权限。</p></li></ul><h3>6.2 定义存储过程:</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_Student (_name <span class="built_in">varchar</span>(<span class="number">50</span>),_age <span class="built_in">int</span> ,<span class="keyword">out</span> _id <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span>(<span class="literal">null</span>,_name,_age);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(stuId) <span class="keyword">into</span> _id <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> insert_Student(<span class="string">'wfz'</span>,<span class="number">23</span>,@<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><h2>7. 用jdbc怎么调用存储过程？</h2><blockquote><p>贾琏欲执事</p></blockquote><ul><li>加载驱动</li><li>获取连接</li><li>设置参数</li><li>执行</li><li>释放连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Connection cn = <span class="keyword">null</span>;</span><br><span class="line">CallableStatement cstmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里最好不要这么干，因为驱动名写死在程序中了</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//实际项目中，这里应用DataSource数据，如果用框架，</span></span><br><span class="line"><span class="comment">//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()</span></span><br><span class="line"><span class="comment">//cn = ds.getConnection();</span></span><br><span class="line">cn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///test"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">cstmt = cn.prepareCall(<span class="string">"&#123;call insert_Student(?,?,?)&#125;"</span>);</span><br><span class="line">cstmt.registerOutParameter(<span class="number">3</span>,Types.INTEGER);</span><br><span class="line">cstmt.setString(<span class="number">1</span>, <span class="string">"wangwu"</span>);</span><br><span class="line">cstmt.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">cstmt.execute();</span><br><span class="line"><span class="comment">//get第几个，不同的数据库不一样，建议不写</span></span><br><span class="line">System.out.println(cstmt.getString(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*try&#123;cstmt.close();&#125;catch(Exception e)&#123;&#125;</span></span><br><span class="line"><span class="comment">try&#123;cn.close();&#125;catch(Exception e)&#123;&#125;*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(cstmt != <span class="keyword">null</span>)</span><br><span class="line">cstmt.close();</span><br><span class="line"><span class="keyword">if</span>(cn != <span class="keyword">null</span>)</span><br><span class="line">cn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>8. 对jdbc的理解</h2><p><code>Java database connection</code> java数据库连接.数据库管理系统(<code>mysql</code> <code>oracle</code>等)是很多，每个数据库管理系统支持的命令是不一样的。</p><p>Java只定义接口，让数据库厂商自己实现接口，对于我们者而言。只需要导入对应厂商开发的实现即可。然后以接口方式进行调用.(<code>mysql</code> + <code>mysql</code>驱动（实现）+<code>jdbc</code>)</p><h2>9. 写一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序</h2><blockquote><p>贾琏欲执事</p></blockquote><ol><li>加载驱动(<code>com.mysql.jdbc.Driver,oracle.jdbc.driver.OracleDriver</code>)</li><li>取连接(<code>DriverManager.getConnection(url,usernam,passord)</code>)</li><li>设置参数  <code>Statement PreparedStatement</code><br><code>cstmt.setXXX(index, value);</code></li><li>执行   <code>executeQuery executeUpdate</code></li><li>释放连接(是否连接要从小到大，必须放到<code>finnaly</code>)</li></ol><h2>10. JDBC中的PreparedStatement相比Statement的好处</h2><p><strong>大多数我们都使用<code>PreparedStatement</code>代替<code>Statement</code></strong></p><ul><li>1：<code>PreparedStatement</code>是预编译的，比<code>Statement</code>速度快</li><li>2：代码的可读性和可维护性</li></ul><p>虽然用<code>PreparedStatement</code>来代替<code>Statement</code>会使代码多出几行,但这样的代码无论从可读性还是可维护性上来说.都比直接用<code>Statement</code>的代码高很多档次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeUpdate(<span class="string">"insert into tb_name (col1,col2,col2,col4) values</span></span><br><span class="line"><span class="string">('"</span>+var1+<span class="string">"','"</span>+var2+<span class="string">"',"</span>+var3+<span class="string">",'"</span>+var4+<span class="string">"')"</span>); </span><br><span class="line"></span><br><span class="line">perstmt = con.prepareStatement(<span class="string">"insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)"</span>);</span><br><span class="line">perstmt.setString(<span class="number">1</span>,var1);</span><br><span class="line">perstmt.setString(<span class="number">2</span>,var2);</span><br><span class="line">perstmt.setString(<span class="number">3</span>,var3);</span><br><span class="line">perstmt.setString(<span class="number">4</span>,var4);</span><br><span class="line">perstmt.executeUpdate();</span><br></pre></td></tr></table></figure><ul><li>3：安全性</li></ul><p><code>PreparedStatement</code>可以防止<code>SQL</code>注入攻击，而<code>Statement</code>却不能。</p><p>比如说：</p><blockquote><p>String sql = “select * from tb_name where name= '”+varname+&quot;’ and passwd=’&quot;+varpasswd+&quot;’&quot;;</p></blockquote><p>如果我们把<code>[' or '1' = '1]</code>作为varpasswd传入进来.用户名随意,看看会成为什么?</p><blockquote><p>select * from tb_name = ‘随意’ and passwd = ‘’ or ‘1’ = ‘1’;</p></blockquote><p>因为<code>'1'='1'</code>肯定成立，所以可以任何通过验证。</p><p>更有甚者：把<code>[';drop table tb_name;]</code>作为<code>varpasswd</code>传入进来,则：</p><blockquote><p>select * from tb_name = ‘随意’ and passwd = ‘’;drop table tb_name;</p></blockquote><p>有些数据库是不会让你成功的，但也有很多数据库就可以使这些语句得到执行。</p><p>而如果你使用预编译语句你传入的任何内容就不会和原来的语句发生任何匹配的关系，只要全使用预编译语句你就用不着对传入的数据做任何过虑。而如果使用普通的<code>statement</code>,有可能要对<code>drop</code>等做费尽心机的判断和过虑。</p><h2>11. 数据库连接池作用</h2><ul><li>1、限定数据库的个数，不会导致由于数据库连接过多导致系统运行缓慢或崩溃</li><li>2、数据库连接不需要每次都去创建或销毁，节约了资源</li><li>3、数据库连接不需要每次都去创建，响应时间更快。</li></ul><h2>12. 选择合适的存储引擎</h2><p>在开发中，我们经常使用的存储引擎 <code>myisam</code> / <code>innodb</code>/ <code>memory</code></p><blockquote><p>MyISAM存储引擎</p></blockquote><p>如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. 比如 bbs 中的 发帖表，回复表.</p><blockquote><p>INNODB存储引擎:</p></blockquote><p>对事务要求高，保存的数据都是重要数据，我们建议使用<code>INNODB</code>,比如订单表，账号表.</p><blockquote><p>Memory 存储</p></blockquote><p>我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用<code>memory</code>, 速度极快.</p><p><code>MyISAM</code> 和 <code>INNODB</code>的区别(主要)</p><ol><li>事务安全 <code>myisam</code>不支持事务而<code>innodb</code>支持</li><li>查询和添加速度 <code>myisam</code>不用支持事务就不用考虑同步锁，查找和添加和添加的速度快</li><li>支持全文索引 <code>myisam</code>支持<code>innodb</code>不支持</li><li>锁机制 <code>myisam</code>支持表锁而<code>innodb</code>支持行锁(事务)</li><li>外键 <code>MyISAM</code> 不支持外键， <code>INNODB</code>支持外键. (通常不设置外键，通常是在程序中保证数据的一致)</li></ol><hr><h1>下面是数据库的优化手段，但是只是表面，需要以后再好好探究</h1><p>在项目自验项目转测试之前，在启动<code>mysql</code>数据库时开启慢查询，并且把执行慢的语句写到日志中，在运行一定时间后。通过查看日志找到慢查询语句。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">show variables like '%slow%';   #查看MySQL慢查询是否开启</span><br><span class="line"></span><br><span class="line">set global slow_query_log=ON;   #开启MySQL慢查询功能</span><br><span class="line"></span><br><span class="line">show variables like "long_query_time";  #查看MySQL慢查询时间设置，默认10秒</span><br><span class="line"></span><br><span class="line">set global long_query_time=5;  #修改为记录5秒内的查询</span><br><span class="line"></span><br><span class="line">select sleep(6);  #测试MySQL慢查询</span><br><span class="line"></span><br><span class="line">show variables like "%slow%";  #查看MySQL慢查询日志路径</span><br><span class="line"></span><br><span class="line">show global status like '%slow%';  #查看MySQL慢查询状态</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">vi  /etc/my.cnf  #编辑，在[mysqld]段添加以下代码</span><br><span class="line"></span><br><span class="line">slow-query-log = on  #开启MySQL慢查询功能</span><br><span class="line"></span><br><span class="line">slow_query_log_file =  /var/run/mysqld/mysqld-slow.log #设置MySQL慢查询日志路径</span><br><span class="line"></span><br><span class="line">long_query_time = 5  #修改为记录5秒内的查询，默认不设置此参数为记录10秒内的查询</span><br><span class="line"></span><br><span class="line">log-queries-not-using-indexes = on  #记录未使用索引的查询</span><br><span class="line"></span><br><span class="line">:wq! #保存退出</span><br><span class="line"></span><br><span class="line">service mysqld restart #重启MySQL服务</span><br></pre></td></tr></table></figure><h2>13. 数据库优化-索引</h2><h3>13.1 索引的概念</h3><p>索引（<code>Index</code>）是帮助<code>DBMS</code>高效获取数据的数据结构。</p><h3>13.2 索引有哪些</h3><blockquote><p>分类：普通索引/唯一索引/主键索引/全文索引</p></blockquote><ul><li><p>普通索引:允许重复的值出现</p></li><li><p>唯一索引:除了不能有重复的记录外，其它和普通索引一样(用户名、用户身份证、email,tel)</p></li><li><p>主键索引：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会給改列创建索引。这就是主键索引.唯一且没有null值</p></li><li><p>全文索引:用来对表中的文本域(<code>char</code>，<code>varchar</code>，<code>text</code>)进行索引， 全文索引针对<code>MyIsam</code><br><code>explain select * from articles where match(title,body) against(‘database’);</code>【会使用全文索引】</p></li></ul><h3>13.3 使用索引的注意事项</h3><blockquote><p>索引弊端</p></blockquote><ol><li>占用磁盘空间。</li><li>对<code>dml</code>(插入、修改、删除)操作有影响，变慢。</li></ol><blockquote><p>使用场景：</p></blockquote><ol><li>肯定在<code>where</code>条件经常使用,如果不做查询就没有意义</li><li>该字段的内容不是唯一的几个值(sex)</li><li>字段内容不是频繁变化.</li></ol><blockquote><p>注意事项</p></blockquote><ol><li>对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept <span class="keyword">add</span> <span class="keyword">index</span> my_ind (dname,loc); // dname 左边的列,loc就是右边的列</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=<span class="string">'aaa'</span>\G 会使用到索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> loc=<span class="string">'aaa'</span>\G 就不会使用到索引</span><br></pre></td></tr></table></figure><ol start="2"><li>对于使用<code>like</code>的查询，查询如果是<code>%aaa</code>不会使用到索引而<code>aaa%</code>会使用到索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="keyword">like</span> <span class="string">'%aaa'</span>\G不能使用索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="keyword">like</span> <span class="string">'aaa%'</span>\G使用索引.</span><br></pre></td></tr></table></figure><p>所以在<code>like</code>查询时，‘关键字’的最前面不能使用<code>%</code> 或者 <code>_</code>这样的字符，如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p><ol start="3"><li>索引列排序</li></ol><p><code>MySQL</code>查询只使用一个索引，因此如果<code>where</code>子句中已经使用了索引的话，那么<code>order by</code>中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><ol start="4"><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=’<span class="number">111</span>’;</span><br><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=<span class="number">111</span>;（数值自动转字符串）</span><br><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=qqq;报错</span><br></pre></td></tr></table></figure><p>也就是，如果列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来.</p><ol start="5"><li><p>如果<code>mysql</code>估计使用全表扫描要比使用索引快，则不使用索引。<br>表里面只有一条记录</p></li><li><p>索引不会包含有<code>NULL</code>值的列</p></li></ol><p>只要列中包含有<code>NULL</code>值都将不会被包含在<code>MySQL</code>索引中，复合索引中只要有一列含有<code>NULL</code>值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为<code>NULL</code>。</p><ol start="7"><li>使用短索引</li></ol><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个<code>CHAR(255)</code>的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p><ol start="8"><li>不要在列上进行运算，不使用<code>NOT IN</code>和<code>&lt;&gt;</code>操作，不支持正则表达式。</li></ol><h2>14. 数据库优化-分表</h2><p>分表分为水平(按行)分表和垂直(按列)分表</p><p><strong>水平分表情形：</strong></p><p>根据经验，<code>Mysql</code>表数据一般达到百万级别，查询效率会很低，容易造成表锁，甚至堆积很多连接，直接挂掉；水平分表能够很大程度较少这些压力。</p><p><strong>垂直分表情形：</strong></p><p>如果一张表中某个字段值非常多(长文本、二进制等)，而且只有在很少的情况下会查询。这时候就可以把字段多个单独放到一个表，通过外键关联起来。考试详情，一般我们只关注分数，不关注详情。</p><p><strong>水平分表策略：</strong></p><blockquote><p>1.按时间分表</p></blockquote><p>这种分表方式有一定的局限性，当数据有较强的实效性，如微博发送记录、微信消息记录等，这种数据很少有用户会查询几个月前的数据，如需要就可以按月分表。</p><blockquote><p>2.按区间范围分表</p></blockquote><p>一般在有严格的自增id需求上，如按照<code>user_id</code>水平分表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table_1  user_id从1~100w  </span><br><span class="line">table_2  user_id从101~200w </span><br><span class="line">table_3  user_id从201~300w</span><br></pre></td></tr></table></figure><blockquote><p>3.hash分表</p></blockquote><p>通过一个原始目标的ID或者名称通过一定的<code>hash</code>算法计算出数据存储表的表名，然后访问相应的表。</p><h2>15. 数据库优化-读写分离</h2><p>一台数据库支持的最大并发连接数是有限的，如果用户并发访问太多。一台服务器满足不要要求是就可以集群处理。Mysql的集群处理技术最常用的就是读写分离。</p><p><strong>主从同步</strong></p><p>数据库最终会把数据持久化到磁盘，如果集群必须确保每个数据库服务器的数据是一直的。<strong>能改变数据库数据的操作都往主数据库去写，而其他的数据库从主数据库上同步数据。</strong></p><p><strong>读写分离</strong></p><p>使用负载均衡来实现写的操作都往主数据去，而读的操作往从服务器去。</p><h2>16. 数据库优化-缓存</h2><p><strong>什么是缓存</strong></p><p>在持久层(<code>dao</code>)和数据库(<code>db</code>)之间添加一个缓存层，如果用户访问的数据已经缓存起来时，在用户访问时直接从缓存中获取，不用访问数据库。而缓存是在操作内存级，访问速度快。</p><p><strong>作用</strong></p><p>减少数据库服务器压力，减少访问时间。</p><p><strong>Java中常用的缓存有</strong></p><ol><li><code>hibernate</code>的二级缓存。该缓存不能完成分布式缓存。</li><li>可以使用<code>redis</code>(<code>memcahe</code>等)来作为中央缓存。对缓存的数据进行集中处理</li></ol><h2>17. 数据库优化-sql语句优化的技巧</h2><h3>DDL优化</h3><ol><li>通过禁用索引来提供导入数据性能，这个操作主要针对现有数据库的表追加数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//去除键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test3 <span class="keyword">DISABLE</span> <span class="keyword">keys</span>;</span><br><span class="line">//批量插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test3 ***</span><br><span class="line">//恢复键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test3 <span class="keyword">ENABLE</span> <span class="keyword">keys</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>关闭唯一校验</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> unique_checks=<span class="number">0</span>  关闭</span><br><span class="line"><span class="keyword">set</span> unique_checks=<span class="number">1</span>  开启</span><br></pre></td></tr></table></figure><ol start="3"><li>修改事务提交方式(导入)（变多次提交为一次）</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>   关闭</span><br><span class="line">//批量插入</span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">1</span>   开启</span><br></pre></td></tr></table></figure><h3>DML优化（变多次提交为一次）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">//合并多条为一条</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3>DQL优化</h3><blockquote><p>Order by优化</p></blockquote><ol><li>多用索引排序</li><li>普通结果排序（非索引排序）Filesort</li></ol><blockquote><p>group by优化</p></blockquote><p>使用order by null,取消默认排序</p><p>等等等等…</p><h2>18. jdbc批量插入几百万数据怎么实现</h2><p>1、变多次提交为一次<br>2、使用批量操作<br>3、像这样的批量插入操作能不使用代码操作就不使用，可以使用存储过程来实现</p><p><img src="http://p376695fl.bkt.clouddn.com/jdbc%E6%8F%92%E5%85%A5%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96.png" alt="image"></p><h2>mysql优化手段介绍到这里。</h2><h2>19. 聚簇索引和非聚簇索引</h2><p>索引分为聚簇索引和非聚簇索引。</p><p><strong>“聚簇索引”</strong></p><p>以一本英文课本为例，要找第8课，直接翻书，若先翻到第5课，则往后翻，再翻到第10课，则又往前翻。这本书本身就是一个索引，即“聚簇索引”。</p><p><strong>“非聚簇索引”</strong></p><p>如果要找&quot;fire”这个单词，会翻到书后面的附录，这个附录是按字母排序的，找到F字母那一块，再找到&quot;fire”，对应的会是它在第几课。这个附录，为“非聚簇索引”。</p><p>由此可见，聚簇索引，索引的顺序就是数据存放的顺序，所以，很容易理解，一张数据表只能有一个聚簇索引。</p><p>聚簇索引要比非聚簇索引查询效率高很多，特别是范围查询的时候。所以，至于聚簇索引到底应该为主键，还是其他字段，这个可以再讨论。</p><h3>1、MYSQL的索引</h3><p>mysql中，不同的存储引擎对索引的实现方式不同，大致说下<code>MyISAM</code>和<code>InnoDB</code>两种存储引擎。</p><p><strong>MyISAM存储引擎的索引实现</strong></p><p><code>MyISAM</code>的<code>B+Tree</code>的叶子节点上的<code>data</code>，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。<br>MyISAM还采用压缩机制存储索引，比如，第一个索引为“her”，第二个索引为“here”，那么第二个索引会被存储为“3,e”，这样的缺点是同一个节点中的索引只能采用顺序查找。</p><p><strong>InnoDB存储引擎的索引实现</strong></p><p><code>InnoDB</code> 的数据文件本身就是索引文件，<code>B+Tree</code>的叶子节点上的<code>data</code>就是数据本身，<code>key</code>为主键，这是聚簇索引。非聚簇索引，叶子节点上的data是主键 (所以聚簇索引的<code>key</code>，不能过长)。为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证。<br>至于为什么主键通常建议使用自增id呢？</p><h3>2.聚簇索引</h3><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p><p>聚簇索引不但在检索上可以大大滴提高效率，在数据读取上也一样。比如：需要查询f~t的所有单词。</p><p>一个使用<code>MyISAM</code>的主索引，一个使用<code>InnoDB</code>的聚簇索引。两种索引的<code>B+Tree</code>检索时间一样，但读取时却有了差异。</p><p><strong>因为<code>MyISAM</code>的主索引并非聚簇索引</strong>，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。</p><p><strong>不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是<code>MyISAM</code>占优势些，因为索引所占空间小，这些操作是需要在内存中完成的</strong>。</p><p>鉴于聚簇索引的范围查询效率，很多人认为使用主键作为聚簇索引太多浪费，毕竟几乎不会使用主键进行范围查询。但若再考虑到聚簇索引的存储，就不好定论了。</p><h2>20. sql注入问题</h2><h3>20.1 什么是sql注入</h3><p>sql注入大家都不陌生，是一种常见的攻击方式，攻击者在界面的表单信息或url上输入一些奇怪的sql片段，例如“or ‘1’=’1’”这样的语句，有可能入侵参数校验不足的应用程序。所以在我们的应用中需要做一些工作，来防备这样的攻击方式。在一些安全性很高的应用中，比如银行软件，经常使用将sql语句全部替换为存储过程这样的方式，来防止sql注入，这当然是一种很安全的方式，但我们平时开发中，可能不需要这种死板的方式。</p><h3>20.2 PrepareStatement解决SQL注入的问题</h3><p>在使用<code>JDBC</code>的过程中，可以使用<code>PrepareStatement</code>进行预处理，预处理的优势就是预防绝大多数的SQL注入；而且针对多次操作数据库的情况，可以极大的提高访问数据库的效率。</p><p>那为什么它这样处理就能预防SQL注入提高安全性呢？其实是因为SQL语句在程序运行前已经进行了预编译。在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库以参数化的形式进行查询。当运行时动态地把参数传给<code>PreprareStatement</code>时，即使参数里有敏感字符如 or ‘1=1’，数据库也会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令。如此，就起到了SQL注入的作用了！</p><h3>20.3 MyBatis如何防止sql注入</h3><p><code>mybatis</code>框架作为一款半自动化的持久层框架，其sql语句都要我们自己来手动编写，这个时候当然需要防止sql注入。其实<code>Mybatis</code>的sql是一个具有“输入+输出”功能，类似于函数的结构，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=“getBlogById“ resultType=“Blog“ parameterType=”int”&gt;</span><br><span class="line">       <span class="keyword">select</span> <span class="keyword">id</span>,title,author,<span class="keyword">content</span> </span><br><span class="line">　　　　<span class="keyword">from</span> blog </span><br><span class="line">　　　　<span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125; </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>这里，<code>parameterType</code>标示了输入的参数类型，<code>resultType</code>标示了输出的参数类型。回应上文，如果我们想防止sql注入，理所当然地要在输入参数上下功夫。上面代码中“#{id}”即输入参数在sql中拼接的部分，传入参数后，打印出执行的sql语句，会看到sql是这样的：</p><blockquote><p>select id,title,author,content from blog where id = ?</p></blockquote><p>不管输入什么参数，打印出的sql都是这样的。这是因为<code>mybatis</code>启用了预编译功能，在sql执行前，会先将上面的sql发送给数据库进行编译，执行时，直接使用编译好的sql，替换占位符“？”就可以了。因为sql注入只能对编译过程起作用，所以这样的方式就很好地避免了sql注入的问题。</p><p><code>mybatis</code>是如何做到sql预编译的呢？其实在框架底层，是<code>jdbc</code>中的<code>PreparedStatement</code>类在起作用，<code>PreparedStatement</code>是我们很熟悉的<code>Statement</code>的子类，它的对象包含了编译好的sql语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行一个sql时，能够提高效率，原因是sql已编译好，再次执行时无需再编译。</p><p>补充</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=“orderBlog“ resultType=“Blog“ parameterType=”map”&gt;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">select</span> <span class="keyword">id</span>,title,author,<span class="keyword">content</span> <span class="keyword">from</span> blog <span class="keyword">order</span> <span class="keyword">by</span> $&#123;orderParam&#125;</span><br><span class="line"> </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>仔细观察，内联参数的格式由“#{xxx}”变为了${xxx}。如果我们给参数“orderParam”赋值为”id”,将sql打印出来，是这样的：</p><blockquote><p>select id,title,author,content from blog order by id</p></blockquote><p>显然，这样是无法阻止sql注入的。在mybatis中，”${xxx}”这样格式的参数会直接参与sql编译，从而不能避免注入攻击。<strong>但涉及到动态表名和列名时，只能使用“${xxx}”这样的参数格式</strong>，所以，这样的参数需要我们在代码中手工进行处理来防止注入。</p><h2>21. mysql悲观锁和乐观锁</h2><h2>21.1 悲观锁</h2><p>悲观锁（<code>Pessimistic Lock</code>），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p><p><code>Java synchronized</code> 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p><h2>21.2 乐观锁</h2><p>乐观锁（<code>Optimistic Lock</code>），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p><p>乐观锁一般来说有以下2种方式：</p><ul><li>使用数据版本（<code>Version</code>）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 <code>version</code> 字段来实现。当读取数据时，将<code>version</code>字段的值一同读出，数据每更新一次，对此<code>version</code>值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的<code>version</code>值进行比对，如果数据库表当前版本号与第一次取出来的<code>version</code>值相等，则予以更新，否则认为是过期数据。</li><li>使用时间戳（<code>timestamp</code>）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（<code>timestamp</code>）, 和上面的<code>version</code>类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。<br><code>Java JUC</code>中的<code>atomic</code>包就是乐观锁的一种实现，<code>AtomicInteger</code> 通过<code>CAS</code>（<code>Compare And Set</code>）操作实现线程安全的自增。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一些面试题，简单看看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>复杂查询训练</title>
    <link href="http://yoursite.com/2019/01/27/mysql/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E8%AE%AD%E7%BB%83/"/>
    <id>http://yoursite.com/2019/01/27/mysql/复杂查询训练/</id>
    <published>2019-01-27T14:24:58.261Z</published>
    <updated>2019-01-27T14:25:36.834Z</updated>
    
    <content type="html"><![CDATA[<p>对一些场景进行sql的一些训练。</p><a id="more"></a><h2>1、查询语文成绩比数学成绩好的学生的学号</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、拿到语文科目的所有分数id和分数：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Sid</span>,score <span class="keyword">from</span> score <span class="keyword">WHERE</span> Cid=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、拿到数学科目的所有分数<span class="keyword">id</span>和分数：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Sid</span>,score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> Cid=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、找到同一个学生对应的语文分数比数学分数高的人：</span><br><span class="line"><span class="keyword">SELECT</span> a.Sid <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">Sid</span>,score <span class="keyword">from</span> score <span class="keyword">WHERE</span> Cid=<span class="number">1</span>) a,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">Sid</span>,score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> Cid=<span class="number">2</span>) b</span><br><span class="line"><span class="keyword">WHERE</span> a.score&gt;b.score </span><br><span class="line"><span class="keyword">and</span> a.Sid=b.Sid</span><br></pre></td></tr></table></figure><h2>2、查询平均成绩大于60分的同学的学号和平均成绩</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sc.Sid,</span><br><span class="line"><span class="keyword">AVG</span>(sc.score)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">score sc</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sc.Sid</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">AVG</span>(sc.score) &gt; <span class="number">60</span></span><br></pre></td></tr></table></figure><h2>3、查询所有同学的学号、姓名、选课数、总成绩</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st.Sid <span class="keyword">AS</span> <span class="string">'学号'</span>,</span><br><span class="line">st.Sname <span class="keyword">AS</span> <span class="string">'学生姓名'</span>,</span><br><span class="line"><span class="keyword">COUNT</span>(sc.Cid) <span class="keyword">AS</span> <span class="string">'选课数'</span>,</span><br><span class="line"><span class="keyword">SUM</span>(sc.score) <span class="keyword">AS</span> <span class="string">'总分'</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid = sc.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st.Sid</span><br></pre></td></tr></table></figure><h2>4、查询姓“王”的老师的个数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">count</span>(te.Tname)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">teacher te</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">te.Tname <span class="keyword">LIKE</span> <span class="string">'王%'</span></span><br></pre></td></tr></table></figure><h2>5、查询没学过“王二”老师课的同学的学号、姓名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#1、找出所有学生对应的学号和老师</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,te.Tname <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid = sc.Sid</span><br><span class="line"><span class="keyword">JOIN</span> course co <span class="keyword">on</span> sc.Cid = co.Cid</span><br><span class="line"><span class="keyword">JOIN</span> teacher te <span class="keyword">ON</span> co.Tid = te.Tid</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、找到所有老师是王五的学生<span class="keyword">id</span>和姓名</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname,te.Tname <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid = sc.Sid</span><br><span class="line"><span class="keyword">JOIN</span> course co <span class="keyword">on</span> sc.Cid = co.Cid</span><br><span class="line"><span class="keyword">JOIN</span> teacher te <span class="keyword">ON</span> co.Tid = te.Tid</span><br><span class="line"><span class="keyword">WHERE</span> te.Tname=<span class="string">'王五'</span></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、最后将王五的全部剔除，就是没有学王五课的学生信息</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname <span class="keyword">from</span> student st <span class="keyword">WHERE</span> st.Sid <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid = sc.Sid</span><br><span class="line"><span class="keyword">JOIN</span> course co <span class="keyword">on</span> sc.Cid = co.Cid</span><br><span class="line"><span class="keyword">JOIN</span> teacher te <span class="keyword">ON</span> co.Tid = te.Tid</span><br><span class="line"><span class="keyword">WHERE</span> te.Tname=<span class="string">'王五'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2>6、查询学过“语文”并且也学过“数学”课程的同学的学号、姓名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#1、找到学过"语文"的学生</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid <span class="keyword">from</span> student st </span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid = sc.Sid </span><br><span class="line"><span class="keyword">AND</span> sc.Cid = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、在学过语文的学生中再找出学数学的学生</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname <span class="keyword">from</span> student st </span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid = sc.Sid </span><br><span class="line"><span class="keyword">AND</span> sc.Cid = <span class="number">2</span></span><br><span class="line"><span class="keyword">AND</span> st.Sid <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid <span class="keyword">from</span> student st </span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid = sc.Sid </span><br><span class="line"><span class="keyword">AND</span> sc.Cid = <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2>7、查询课程编号“数学”的成绩比课程编号“语文”课程低的所有同学的学号、姓名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1、先找到课程为语文的所有人的分数</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> score sc <span class="keyword">WHERE</span> sc.Cid=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、先找到课程为数学的所有人的分数</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> score sc <span class="keyword">WHERE</span> sc.Cid=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、找到语文比数学成绩好的学生的成绩</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> score sc <span class="keyword">WHERE</span> sc.Cid=<span class="number">1</span>) sc1,</span><br><span class="line">(<span class="keyword">SELECT</span> * <span class="keyword">from</span> score sc <span class="keyword">WHERE</span> sc.Cid=<span class="number">2</span>) sc2</span><br><span class="line"><span class="keyword">WHERE</span> sc1.score&gt;sc2.score <span class="keyword">AND</span> sc1.Sid=sc2.Sid</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>、将学生信息再拿出来</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname <span class="keyword">from</span> student st <span class="keyword">WHERE</span> st.Sid <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> sc1.Sid <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> score sc <span class="keyword">WHERE</span> sc.Cid=<span class="number">1</span>) sc1,</span><br><span class="line">(<span class="keyword">SELECT</span> * <span class="keyword">from</span> score sc <span class="keyword">WHERE</span> sc.Cid=<span class="number">2</span>) sc2</span><br><span class="line"><span class="keyword">WHERE</span> sc1.score&gt;sc2.score <span class="keyword">AND</span> sc1.Sid=sc2.Sid</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2>8、查询所有课程成绩小于60分的同学的学号、姓名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> st.Sid,st.Sname <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid = sc.Sid</span><br><span class="line"><span class="keyword">WHERE</span> sc.score&lt;<span class="number">60</span></span><br></pre></td></tr></table></figure><h2>9、查询没有学全所有课的同学的学号、姓名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#1、统计出所有学生学习的课程数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(sc.Cid) <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Sid</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、每个学生学习的课程数小于总课程数，说明没有学全</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(sc.Cid)&lt;(<span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> course)</span><br></pre></td></tr></table></figure><h2>10、 查询至少有一门课与学号为“1”的同学所学相同的同学的学号和姓名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1、找出学号为1的学生所学的课程id</span><br><span class="line"><span class="keyword">SELECT</span> sc.Cid <span class="keyword">from</span> student st,score sc <span class="keyword">WHERE</span> st.Sid=sc.Sid <span class="keyword">AND</span> st.Sid=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、从查询结果来看是选择了语文（<span class="number">1</span>）和数学（<span class="number">2</span>）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> st.Sid,st.Sname <span class="keyword">from</span> student st,score sc <span class="keyword">WHERE</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">AND</span> sc.Cid <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> sc.Cid <span class="keyword">from</span> student st,score sc <span class="keyword">WHERE</span> st.Sid=sc.Sid <span class="keyword">AND</span> st.Sid=<span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2>11、查询和“1”号的同学学习的课程完全相同的其他同学学号和姓名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#1、找到2号同学所有学的课程</span><br><span class="line"><span class="keyword">SELECT</span> sc.Cid <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">WHERE</span> st.Sid=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、找到有跟他学的不一样的学生</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> st.Sid,st.Sname <span class="keyword">from</span> student st,score sc <span class="keyword">WHERE</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">AND</span> sc.Cid <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">SELECT</span> sc.Cid <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">WHERE</span> st.Sid=<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、再找出一样的学生，并且将他自己剔除</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> st.Sid,st.Sname <span class="keyword">from</span> student st,score sc <span class="keyword">WHERE</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">AND</span> st.Sid <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> st.Sid <span class="keyword">from</span> student st,score sc <span class="keyword">WHERE</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">AND</span> sc.Cid <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">SELECT</span> sc.Cid <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">WHERE</span> st.Sid=<span class="number">1</span></span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> st.Sid!=<span class="number">1</span></span><br></pre></td></tr></table></figure><h2>12、按平均成绩从高到低显示所有学生的三门的课程成绩,按如下形式显示： 学生ID,语文,数学,英语,有效课程数,有效平均分</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#1、根据学生id分组，按照学生的平均成绩排序</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> st.Sid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(sc.score)</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、按照要求显示</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid <span class="keyword">AS</span> <span class="string">'学生id'</span>,</span><br><span class="line">(<span class="keyword">SELECT</span> score <span class="keyword">from</span> score <span class="keyword">WHERE</span> Cid=<span class="number">1</span> <span class="keyword">and</span> st.Sid=<span class="keyword">Sid</span>) <span class="keyword">AS</span> <span class="string">'语文'</span>,</span><br><span class="line">(<span class="keyword">SELECT</span> score <span class="keyword">from</span> score <span class="keyword">WHERE</span> Cid=<span class="number">2</span> <span class="keyword">and</span> st.Sid=<span class="keyword">Sid</span>) <span class="keyword">AS</span> <span class="string">'数学'</span>,</span><br><span class="line">(<span class="keyword">SELECT</span> score <span class="keyword">from</span> score <span class="keyword">WHERE</span> Cid=<span class="number">3</span> <span class="keyword">and</span> st.Sid=<span class="keyword">Sid</span>) <span class="keyword">AS</span> <span class="string">'英语'</span>,</span><br><span class="line"><span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="string">'有效课程数'</span>,</span><br><span class="line"><span class="keyword">AVG</span>(sc.score) <span class="keyword">AS</span> <span class="string">'平均分'</span></span><br><span class="line"><span class="keyword">FROM</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> st.Sid</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(sc.score)</span><br></pre></td></tr></table></figure><h2>13、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sc.Cid,</span><br><span class="line"><span class="keyword">MAX</span>(sc.score) <span class="keyword">AS</span> <span class="string">'最高分'</span>,</span><br><span class="line"><span class="keyword">MIN</span>(sc.score) <span class="keyword">AS</span> <span class="string">'最低分'</span> <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Cid</span><br></pre></td></tr></table></figure><h2>14、检索“语文”课程分数小于60，按分数降序排列的同学学号</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">ON</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">WHERE</span> sc.score&lt;<span class="number">60</span> <span class="keyword">AND</span> sc.Cid=<span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> sc.score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2>15、查询两门以上不及格课程的同学的学号及其平均成绩</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#1、先查询出挂科超过两门的学生id</span><br><span class="line"><span class="keyword">SELECT</span> sc.Sid <span class="keyword">from</span> score sc </span><br><span class="line"><span class="keyword">WHERE</span> sc.score&lt;<span class="number">60</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Sid </span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(*)&gt;<span class="number">2</span></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、再相应地查出学生的信息</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,<span class="keyword">AVG</span>(sc.score) <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">WHERE</span> st.Sid <span class="keyword">in</span>(</span><br><span class="line"><span class="keyword">SELECT</span> sc.Sid <span class="keyword">from</span> score sc </span><br><span class="line"><span class="keyword">WHERE</span> sc.score&lt;<span class="number">60</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Sid </span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(*)&gt;<span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> st.Sid</span><br></pre></td></tr></table></figure><h2>16、查询没学过“王五”老师讲授的任一门课程的学生姓名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#1、查出报名王五老师课程的学生id</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">JOIN</span> course co <span class="keyword">on</span> sc.Cid=co.Cid</span><br><span class="line"><span class="keyword">JOIN</span> teacher te <span class="keyword">on</span> co.Tid=te.Tid</span><br><span class="line"><span class="keyword">WHERE</span> te.Tname=<span class="string">"王五"</span></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>、找出没有上王五老师课的学生是哪些</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> student st <span class="keyword">WHERE</span> st.Sid <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">JOIN</span> course co <span class="keyword">on</span> sc.Cid=co.Cid</span><br><span class="line"><span class="keyword">JOIN</span> teacher te <span class="keyword">on</span> co.Tid=te.Tid</span><br><span class="line"><span class="keyword">WHERE</span> te.Tname=<span class="string">"王五"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2>17、查询选修全部课程的学生</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#1、查出每个学生选修的课程数</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname,<span class="keyword">count</span>(sc.Cid) <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Sid</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、再找出数量等于全部课程的学生</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname,<span class="keyword">count</span>(sc.Cid) <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> st.Sid=sc.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(sc.Cid)=(<span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> course)</span><br></pre></td></tr></table></figure><h2>18、查询全部学生都选修的课程的课程号和课程名</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#1、在分数表中找出每种课程的选修人数</span><br><span class="line"><span class="keyword">SELECT</span> sc.Cid,<span class="keyword">count</span>(sc.Cid) <span class="keyword">from</span> score sc <span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Cid</span><br><span class="line">#<span class="number">2</span>、人数等于<span class="number">7</span>(<span class="number">8</span>号学生无任何参与)说明所有人都选了</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> course co <span class="keyword">where</span> co.Cid=</span><br><span class="line">(<span class="keyword">SELECT</span> sc.Cid <span class="keyword">from</span> score sc <span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Cid <span class="keyword">HAVING</span> <span class="keyword">count</span>(sc.Cid) = <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h2>19、检索至少选修两门课程的学生学号</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#1、先选出每个学生选秀的课程</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(sc.Cid) <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> sc.Sid=st.Sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sc.Sid</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>、再选出选秀课程超过<span class="number">2</span>门的学生</span><br><span class="line"><span class="keyword">SELECT</span> st.Sid,st.Sname <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> sc.Sid=st.Sid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sc.Sid</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(sc.Cid)&gt;=<span class="number">2</span></span><br></pre></td></tr></table></figure><h2>20、统计每门课程的学生选修人数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1、统计出每门选秀的学生数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(sc.Sid) <span class="keyword">from</span> student st</span><br><span class="line"><span class="keyword">JOIN</span> score sc <span class="keyword">on</span> sc.Sid=st.Sid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.Cid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对一些场景进行sql的一些训练。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL必知必会知识点提炼</title>
    <link href="http://yoursite.com/2019/01/27/mysql/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>http://yoursite.com/2019/01/27/mysql/SQL必知必会/</id>
    <published>2019-01-27T14:22:10.793Z</published>
    <updated>2019-01-27T14:26:55.942Z</updated>
    
    <content type="html"><![CDATA[<p>这是对《mysql必知必会》的知识提炼。</p><a id="more"></a><h1>一、基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p><p><code>SQL</code>（<code>Structured Query Language</code>)，标准 <code>SQL</code> 由 <code>ANSI</code> 标准委员会管理，从而称为 <code>ANSI SQL</code>。各个 <code>DBMS</code> 都有自己的实现，如 <code>PL/SQL</code>、<code>Transact-SQL</code> 等。</p><p><code>SQL</code> 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 <code>DBMS</code> 以及配置。</p><p><code>SQL</code> 支持以下三种注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure><h1>二、创建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h1>三、修改表</h1><p>添加列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><h1>四、插入</h1><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure><p>插入检索出来的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure><p>将一个表的内容插入到一个新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1>五、更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">col</span> = val</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1>六、删除</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>TRUNCATE TABLE</strong>  可以清空表，也就是删除所有行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><p>使用更新和删除操作时一定要用 <code>WHERE</code> 子句，不然会把整张表的数据都破坏。可以先用 <code>SELECT</code> 语句进行测试，防止错误删除。</p><h1>七、查询</h1><h2>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回第 3 ~ 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h1>八、排序</h1><ul><li><strong>ASC</strong> ：升序（默认）</li><li><strong>DESC</strong> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h1>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;&gt; !=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&lt;= !&gt;</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;= !&lt;</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">BETWEEN</td><td style="text-align:center">在两个值之间</td></tr><tr><td style="text-align:center">IS NULL</td><td style="text-align:center">为 NULL 值</td></tr></tbody></table><p>应该注意到，<code>NULL</code> 与 0、空字符串都不同。</p><p><strong>AND 和 OR</strong>  用于连接多个过滤条件。优先处理 <code>AND</code>，当一个过滤表达式涉及到多个 <code>AND</code> 和 <code>OR</code> 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong>  操作符用于匹配一组值，其后也可以接一个 <code>SELECT</code> 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong>  操作符用于否定一个条件。</p><h1>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><p><code>%</code>  匹配 &gt;=0 个任意字符；</p></li><li><p><code>\_</code>  匹配 ==1 个任意字符；</p></li><li><p><code>[ ]</code>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p></li></ul><p>使用 <code>Like</code> 来进行通配符匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">LIKE</span> <span class="string">'[^AB]%'</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h1>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用  <strong>AS</strong>  来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 * col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><p><strong>CONCAT()</strong>  用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">'('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1>十二、函数</h1><h2>汇总</h2><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center">AVG()</td><td style="text-align:center">返回某列的平均值</td></tr><tr><td style="text-align:center">COUNT()</td><td style="text-align:center">返回某列的行数</td></tr><tr><td style="text-align:center">MAX()</td><td style="text-align:center">返回某列的最大值</td></tr><tr><td style="text-align:center">MIN()</td><td style="text-align:center">返回某列的最小值</td></tr><tr><td style="text-align:center">SUM()</td><td style="text-align:center">返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 <code>NULL</code> 行。</p><p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2>文本处理</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">LEFT()</td><td style="text-align:center">左边的字符</td></tr><tr><td style="text-align:center">RIGHT()</td><td style="text-align:center">右边的字符</td></tr><tr><td style="text-align:center">LOWER()</td><td style="text-align:center">转换为小写字符</td></tr><tr><td style="text-align:center">UPPER()</td><td style="text-align:center">转换为大写字符</td></tr><tr><td style="text-align:center">LTRIM()</td><td style="text-align:center">去除左边的空格</td></tr><tr><td style="text-align:center">RTRIM()</td><td style="text-align:center">去除右边的空格</td></tr><tr><td style="text-align:center">LENGTH()</td><td style="text-align:center">长度</td></tr><tr><td style="text-align:center">SOUNDEX()</td><td style="text-align:center">转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong>  可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)</span><br></pre></td></tr></table></figure><h2>日期和时间处理</h2><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center">AddDate()</td><td style="text-align:center">增加一个日期（天、周等）</td></tr><tr><td style="text-align:center">AddTime()</td><td style="text-align:center">增加一个时间（时、分等）</td></tr><tr><td style="text-align:center">CurDate()</td><td style="text-align:center">返回当前日期</td></tr><tr><td style="text-align:center">CurTime()</td><td style="text-align:center">返回当前时间</td></tr><tr><td style="text-align:center">Date()</td><td style="text-align:center">返回日期时间的日期部分</td></tr><tr><td style="text-align:center">DateDiff()</td><td style="text-align:center">计算两个日期之差</td></tr><tr><td style="text-align:center">Date_Add()</td><td style="text-align:center">高度灵活的日期运算函数</td></tr><tr><td style="text-align:center">Date_Format()</td><td style="text-align:center">返回一个格式化的日期或时间串</td></tr><tr><td style="text-align:center">Day()</td><td style="text-align:center">返回一个日期的天数部分</td></tr><tr><td style="text-align:center">DayOfWeek()</td><td style="text-align:center">对于一个日期，返回对应的星期几</td></tr><tr><td style="text-align:center">Hour()</td><td style="text-align:center">返回一个时间的小时部分</td></tr><tr><td style="text-align:center">Minute()</td><td style="text-align:center">返回一个时间的分钟部分</td></tr><tr><td style="text-align:center">Month()</td><td style="text-align:center">返回一个日期的月份部分</td></tr><tr><td style="text-align:center">Now()</td><td style="text-align:center">返回当前日期和时间</td></tr><tr><td style="text-align:center">Second()</td><td style="text-align:center">返回一个时间的秒部分</td></tr><tr><td style="text-align:center">Time()</td><td style="text-align:center">返回一个日期时间的时间部分</td></tr><tr><td style="text-align:center">Year()</td><td style="text-align:center">返回一个日期的年份部分</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-4-14 20:25:11</span><br></pre></td></tr></table></figure><h2>数值处理</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SIN()</td><td style="text-align:center">正弦</td></tr><tr><td style="text-align:center">COS()</td><td style="text-align:center">余弦</td></tr><tr><td style="text-align:center">TAN()</td><td style="text-align:center">正切</td></tr><tr><td style="text-align:center">ABS()</td><td style="text-align:center">绝对值</td></tr><tr><td style="text-align:center">SQRT()</td><td style="text-align:center">平方根</td></tr><tr><td style="text-align:center">MOD()</td><td style="text-align:center">余数</td></tr><tr><td style="text-align:center">EXP()</td><td style="text-align:center">指数</td></tr><tr><td style="text-align:center">PI()</td><td style="text-align:center">圆周率</td></tr><tr><td style="text-align:center">RAND()</td><td style="text-align:center">随机数</td></tr></tbody></table><h1>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p><code>GROUP BY</code> 自动按分组字段进行排序，<code>ORDER BY</code> 也可以按汇总字段来进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p><code>WHERE</code> 过滤行，<code>HAVING</code> 过滤分组，行过滤应当先于分组过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分组规定：</p><ul><li><code>GROUP BY</code> 子句出现在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前；</li><li>除了汇总字段外，<code>SELECT</code> 语句中的每一字段都必须在 <code>GROUP BY</code> 子句中给出；</li><li><code>NULL</code> 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 <code>GROUP BY</code> 列具有可变长度的数据类型。</li></ul><h1>十四、子查询</h1><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h1>十五、连接</h1><p>连接用于连接多个表，使用 <code>JOIN</code> 关键字，并且条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 <code>AS</code> 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2>内连接</h2><p>内连接又称等值连接，使用 <code>INNER JOIN</code> 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>可以不明确使用 <code>INNER JOIN</code>，而使用普通查询并在 <code>WHERE</code> 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>在没有条件语句的情况下返回笛卡尔积。</p><h2>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department = (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure><p>自连接版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure><h2>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure><h2>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure><p>customers 表：</p><table><thead><tr><th style="text-align:center">cust_id</th><th style="text-align:center">cust_name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td></tr></tbody></table><p>orders 表：</p><table><thead><tr><th style="text-align:center">order_id</th><th style="text-align:center">cust_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">3</td></tr></tbody></table><p>结果：</p><table><thead><tr><th style="text-align:center">cust_id</th><th style="text-align:center">cust_name</th><th style="text-align:center">order_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">a</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">a</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">b</td><td style="text-align:center">Null</td></tr></tbody></table><h1>十六、组合查询</h1><p>使用  <strong>UNION</strong>  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 <code>UNION ALL</code>。</p><p>只能包含一个 <code>ORDER BY</code> 子句，并且必须位于语句的最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h1>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理；</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</p><p>给变量赋值都需要用 <code>select into</code> 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="built_in">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="built_in">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y*y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(@ret);</span><br><span class="line"><span class="keyword">select</span> @ret;</span><br></pre></td></tr></table></figure><h1>十九、游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="built_in">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span><br><span class="line">        <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">'02000'</span> <span class="keyword">set</span> done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        open mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            fetch mycursor into ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line"></span><br><span class="line">        close mycursor;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure><h1>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：<code>DELETE</code>、<code>INSERT</code>、<code>UPDATE</code>。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 <code>BEFORE</code> 关键字，之后执行使用 <code>AFTER</code> 关键字。<code>BEFORE</code> 用于数据验证和净化，<code>AFTER</code> 用于审计跟踪，将修改记录到另外一张表中。</p><p><code>INSERT</code> 触发器包含一个名为 <code>NEW</code> 的虚拟表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> @<span class="keyword">result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure><p><code>DELETE</code> 触发器包含一个名为 <code>OLD</code> 的虚拟表，并且是只读的。</p><p><code>UPDATE</code> 触发器包含一个名为 <code>NEW</code> 和一个名为 <code>OLD</code> 的虚拟表，其中 <code>NEW</code> 是可以被修改地，而 <code>OLD</code> 是只读的。</p><p><code>MySQL</code> 不允许在触发器中使用 <code>CALL</code> 语句，也就是不能调用存储过程。</p><h1>二十一、事务处理</h1><p>基本术语：</p><ul><li>事务（<code>transaction</code>）指一组 SQL 语句；</li><li>回退（<code>rollback</code>）指撤销指定 SQL 语句的过程；</li><li>提交（<code>commit</code>）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（<code>savepoint</code>）指事务处理中设置的临时占位符（<code>placeholder</code>），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p><p><code>MySQL</code> 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 <code>autocommit</code> 为 0 可以取消自动提交，直到 <code>autocommit</code> 被设置为 1 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，<code>ROLLBACK</code> 会回退到 <code>START TRANSACTION</code> 语句处；如果设置了保留点，并且在 <code>ROLLBACK</code> 中指定该保留点，则会回退到该保留点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure><h1>二十二、字符集</h1><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(<span class="keyword">col</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><p>可以在排序、分组时指定校对：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">col</span> <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure><h1>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>创建账户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypassword'</span>;</span><br></pre></td></tr></table></figure><p>新创建的账户没有任何权限。</p><p><strong>修改账户名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure><p><strong>删除账户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>查看权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>授予权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure><p>账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。</p><p><strong>删除权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li><li>整个数据库，使用 <code>ON database.\*</code>；</li><li>特定的表，使用 <code>ON database.table</code>；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p><strong>更改密码</strong></p><p>必须使用 <code>Password()</code> 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser = <span class="keyword">Password</span>(<span class="string">'new_password'</span>);</span><br></pre></td></tr></table></figure><p>转自：</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/SQL.md" target="_blank" rel="noopener">SQL</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是对《mysql必知必会》的知识提炼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务核心问题</title>
    <link href="http://yoursite.com/2019/01/27/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/27/mysql/数据库事务核心问题/</id>
    <published>2019-01-27T10:15:45.949Z</published>
    <updated>2019-01-27T10:17:05.522Z</updated>
    
    <content type="html"><![CDATA[<p>本文从事务引出了Mysql InnoDB RR隔离级别下是如何防止幻读的。</p><a id="more"></a><h2>1. 数据库事务的四大特性</h2><p>最重要的是ACID特性。</p><ul><li>原子性(Atomicity)：事务要么都成功要么都失败</li><li>一致性(Consistency)：关系型数据库有很多约束，事务前后都要满足这些约束(不仅仅是数据库物理约束，还包括内部逻辑上的一些假设)</li><li>隔离性(Isolation)：两个事务互相独立，不能互相干扰</li><li>持久性(Durability)：事务执行成功之后结果可以持久化，永久存储下来(redo日志)</li></ul><p>对于一致性，可能解释比较抽象，他的实际含义是：数据库的数据应满足完整性约束。拿转账业务来说，假设用户A和用户B一共有2000块钱，那么他们之间无论如何转账，总共的钱应该都是2000.</p><h2>2. 事务并发访问引起的问题</h2><ul><li>更新丢失-mysql所有事务隔离级别在数据库层面均可避免</li></ul><table><thead><tr><th>取款事务</th><th>存款事务</th></tr></thead><tbody><tr><td>开始事务</td><td>开始事务</td></tr><tr><td>查询余额为100元</td><td>无</td></tr><tr><td>无</td><td>查询余额为100元</td></tr><tr><td>无</td><td>存入20，余额变为120元</td></tr><tr><td>无</td><td>提交事务</td></tr><tr><td>取出10元，余额改为90元</td><td>无</td></tr><tr><td>回滚事务，余额恢复为100元</td><td>更新丢失</td></tr></tbody></table><ul><li>脏读问题-一个事务读到另一个事务未提交的数据</li><li>不可重复读-事务A多次读取数据，未提交数据，此时事务B提交新的数据，导致A多次读取数据期间数据不一致，不满足隔离性</li><li>幻读-事务A受到另一个事务插入新的一行或者删除一行的影响，导致幻觉</li></ul><p><strong>不可重复读的重点是修改:</strong><br>同样的条件的select, 你读取过的数据, 再次读取出来发现值不一样了</p><p><strong>幻读的重点在于新增或者删除:</strong><br>同样的条件的select, 第1次和第2次读出来的记录数不一样</p><p>具体可以自己设置不同的隔离级别进行演示。</p><h2>3. 事务的隔离级别</h2><ul><li>Read uncommitted：读到其他事务未commit的值</li><li>Read committed：解决了脏读问题，但是会读到其他事务commit的值，读两次可能会读到两个值，所以又叫不可重复读</li><li>Repeatable Read：解决了不可重复读问题，可重复读，别人commit对我没有影响，但是对于别的事务插入操作，可能会产生幻读</li><li>Serializable：串行化，当发生两个事务同时提交，结果只可能有一个，相当于串行执行后的某个结果</li></ul><p>级别越来越高，安全性也越来越高，但是但是性能越来越低。说明一下，出现幻读只是针对这种<code>Repeatable Read</code>隔离级别，但是<code>InnoDB</code>已经不存在幻读问题了，如何解决的呢？主要是用<code>next-key锁</code>来解决，下文会讲到。</p><h2>4. 当前读和快照读</h2><h5>4.1 当前读</h5><p>读取的都是当前数据的最新版本，并且在读的时候对其加锁，不允许其他事务进行修改操作。</p><p><code>select ... lock in share mode</code>（共享锁）以及<br><code>select ... for update</code>、<code>update</code>、<code>delete</code>、<code>insert</code>（排他锁）这些操作都是当前读。</p><p>为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：</p><p><img src="http://bloghello.oursnail.cn/mysql4-7.jpg" alt="image"></p><p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，发出current read 读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。</p><p>待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。</p><p>一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。</p><h5>4.2 快照读</h5><p>不加锁的非阻塞读，简单的select（前提是事务级别不是<code>serializable</code>，因为在<code>serializable</code>级别下都是串行读，普通的<code>select</code>也会退化为当前读即<code>select ... lock in share mode</code>）</p><p>快照读的实现是基于多版本并发控制（MVCC）实现，旨在提高性能。有可能读到的不是数据的最新版本。（创建快照的时机决定了读到的数据的版本，如果事务A先快照读，事务B修改，那么事务A再快照读就还是更新前的版本，事务A的当前读会读到最新的数据；而当事务B先更新，事务A再快照读，就会读到数据最新版本了）</p><h6>4.3 MVCC</h6><p>MVCC在MySQL的InnoDB中的实现 在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号</li><li>DELETE时，保存当前事务版本号为行的删除版本号</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li></ul><p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p><p>说白了，就是乐观锁的一种实现。免去了加锁解锁的过程，对于读多写少的场景特别适用。</p><h2>5. RC，RR级别下的InnoDB非阻塞读（快照读）如何实现</h2><ul><li>通过数据行里的<code>DB_TRX_ID</code>、<code>DB_ROLL_PTR</code>、<code>DB_ROW_ID</code>这三个字段</li></ul><p><code>DB_TRX_ID</code>，最后一次修改本行事务的ID</p><p><code>DB_ROLL_PTR</code>，即回滚指针,与undo日志配合</p><p><code>DB_ROW_ID</code>，随着新行插入而单调递增的行号（innoDB中如果既没有主键索引也没有唯一索引的时候，就会自动生成一个隐藏主键，就是这个玩意）</p><p>这三个字段结合<code>undo</code>日志，这个日志里面记录的都是老版本的数据，这样，快照读就可以读出适合的一个版本的数据出来。在数据库中，日志是非常重要的东西，可以说其重要性是大于数据本身的，因为数据丢失可以通过日志找回来，但是日志丢失了，那么以后数据库出现崩溃等就麻烦了。</p><h2>6. 日志</h2><p>数据库数据存放的文件称为<code>data file</code>；日志文件称为<code>log file</code>；数据库数据是有缓存的，如果没有缓存，每次都写或者读物理disk，那性能就太低下了。数据库数据的缓存称为<code>data buffer</code>，日志（redo）缓存称为<code>log buffer</code>；既然数据库数据有缓存，就很难保证缓存数据（脏数据）与磁盘数据的一致性。比如某次数据库操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> driver_info <span class="keyword">set</span> driver_status = <span class="number">2</span> <span class="keyword">where</span> driver_id = <span class="number">10001</span>;</span><br></pre></td></tr></table></figure><p>更新<code>driver_status</code>字段的数据会存放在缓存中，等待存储引擎将<code>driver_status</code>刷新<code>data_file</code>，并返回给业务方更新成功。如果此时数据库宕机，缓存中的数据就丢失了，业务方却以为更新成功了，数据不一致，也没有持久化存储。</p><p>上面的问题就可以通过事务的ACID特性来保证。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> trans；</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> driver_info <span class="keyword">set</span> driver_status = <span class="number">2</span> <span class="keyword">where</span> driver_id = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这样执行后，更新要么成功，要么失败。业务方的返回和数据库<code>data file</code>中的数据保持一致。要保证这样的特性这就不得不说存储引擎<code>innodb</code>的<code>redo</code>和<code>undo</code>日志。</p><h5>6.1 undo是啥</h5><p>undo日志用于存放数据修改被修改前的值，假设修改 tba 表中 id=2的行数据，把Name=‘B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name='B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p><p>对数据的变更操作，主要来自 INSERT UPDATE DELETE，而UNDO LOG中分为两种类型，一种是 <code>INSERT_UNDO</code>（INSERT操作，事务提交后可以立即丢弃），记录插入的唯一键值；一种是 <code>UPDATE_UNDO</code>（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。</p><h5>6.2 redo是啥</h5><p>存储引擎也会为<code>redo</code> <code>undo</code>日志开辟内存缓存空间，<code>log buffer</code>。磁盘上的日志文件称为<code>log file</code>，是顺序追加的，性能非常高，注：磁盘的顺序写性能比内存的写性能差不了多少。</p><p>redo日志记录事务执行后的状态，用来恢复未写入<code>data file</code>的已成功事务更新的数据。例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为&lt;T1, X, 5&gt;，Redo日志为&lt;T1, X, 15&gt;。</p><p>梳理下事务执行的各个阶段：</p><ul><li>写undo日志到log buffer；</li><li>执行事务，并写redo日志到log buffer；</li><li>如果innodb_flush_log_at_trx_commit=1，则将redo日志写到log file，并刷新落盘。</li><li>提交事务。</li></ul><p>那redo日志是写进去了，但是数据呢？</p><p><strong>在数据库的世界里，数据从来都不重要，日志才是最重要的，有了日志就有了一切。</strong></p><p>因为<code>data buffer</code>中的数据会在合适的时间 由存储引擎写入到<code>data file</code>，如果在写入之前，数据库宕机了，根据落盘的redo日志，完全可以将事务更改的数据恢复。好了，看出日志的重要性了吧。先持久化日志的策略叫做<code>Write Ahead Log</code>，即预写日志。</p><h5>6.3 Undo + Redo事务的简化过程</h5><p>假设有A、B两个数据，值分别为1,2，开始一个事务，事务的操作内容为：把1修改为3，2修改为4，那么实际的记录如下（简化）：</p><ol><li>事务开始.</li><li>记录A=1到undo log buffer.</li><li>修改A=3.</li><li>记录A=3到redo log buffer.</li><li>记录B=2到undo log buffer.</li><li>修改B=4.</li><li>记录B=4到redo log buffer.</li><li>将redo log写入磁盘。</li><li>事务提交</li></ol><p>我们可以看到，2，4，5，7，8都是新增操作，但是2，4，5，7都是缓冲到buffer区，只有8是磁盘IO操作。为了保证Redo Log有较好的IO性能，设计一般有以下特点：</p><ul><li>尽量保持<code>Redo Log</code>存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配。 以顺序追加的方式记录<code>Redo Log</code>,通过顺序IO来改善性能。</li><li>批量写入日志。日志并不是直接写入文件，而是先写入<code>redo log buffer</code>.当需要将日志刷新到磁盘时 (如事务提交),将许多日志一起写入磁盘.</li><li>并发的事务共享<code>Redo Log</code>的存储空间，它们的<code>Redo Log</code>按语句的执行顺序，依次交替的记录在一起，</li></ul><blockquote><pre><code> 以减少日志占用的空间。例如,Redo Log中的记录内容可能是这样的： 记录1: &lt;trx1, insert …&gt; 记录2: &lt;trx2, update …&gt; 记录3: &lt;trx1, delete …&gt; 记录4: &lt;trx3, update …&gt; 记录5: &lt;trx2, insert …&gt;</code></pre></blockquote><ul><li>因为上一条的原因,当一个事务将<code>Redo Log</code>写入磁盘时，也会将其他未提交的事务的日志写入磁盘</li><li><code>Redo Log</code>上只进行顺序追加的操作，当一个事务需要回滚时，它的<code>Redo Log</code>记录也不会从<code>Redo Log</code>中删除掉。</li></ul><h5>6.4 回滚</h5><p>前面说到未提交的事务和回滚了的事务也会记录<code>Redo Log</code>，因此在进行恢复时,这些事务要进行特殊的的处理。有2种不同的恢复策略：</p><ul><li>进行恢复时，只重做已经提交了的事务。</li><li>进行恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过<code>Undo Log</code>回滚那些未提交的事务。</li></ul><p>MySQL数据库InnoDB存储引擎使用了第二个策略。</p><h2>InnoDB可重复读隔离级别下如何避免幻读</h2><blockquote><p>表象原因:快照读（非阻塞读）–伪MVCC</p></blockquote><blockquote><p>内在原因：next-key锁（行锁+gap锁）</p></blockquote><h6>6.5 next-key锁</h6><p>在 RR 级别下，如果查询条件能使用上唯一索引，或者是一个唯一的查询条件，那么仅加行锁，如果是一个范围查询，那么就会给这个范围加上 <code>gap</code> 锁或者 <code>next-key</code>锁 (行锁+gap锁)。</p><p>那么gap锁啥时候出现呢？</p><p>使用主键索引或者唯一索引时：</p><ul><li>如果where条件全部命中，则不会用Gap锁，只会加记录锁</li><li>如果where条件部分命中或者全不命中，则会加Gap锁</li></ul><p>在走非唯一索引或者不走索引的当前读中，也会出现Gap锁。对于不走索引的情况，那么就会锁住整张表。</p><p>总结一下：只有对唯一索引+全部命中才不会加gap锁。</p><p>具体来个例子说明间隙锁如何工作。</p><h2>7. 例子-走唯一索引</h2><h5>7.1 准备工作</h5><p>有这样一个表test，其中name为主键，id为唯一键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> ( </span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) primary <span class="keyword">key</span>, </span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>, <span class="keyword">unique</span> <span class="keyword">KEY</span> <span class="string">`id`</span> (<span class="string">`id`</span>) ) </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span> (<span class="string">"f"</span>,<span class="number">1</span>), (<span class="string">"h"</span>,<span class="number">2</span>), (<span class="string">"b"</span>,<span class="number">3</span>), (<span class="string">"a"</span>,<span class="number">5</span>), (<span class="string">"c"</span>,<span class="number">6</span>),(<span class="string">"d"</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>id</th></tr></thead><tbody><tr><td>f</td><td>1</td></tr><tr><td>h</td><td>2</td></tr><tr><td>b</td><td>3</td></tr><tr><td>a</td><td>5</td></tr><tr><td>c</td><td>6</td></tr><tr><td>d</td><td>9</td></tr></tbody></table><p>首先验证一下使用主键索引或者唯一索引时会怎么样。</p><h5>7.2 第一种情况：唯一索引+命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>此时由于id是唯一索引，并且是命中的，所以只是对这一行加排他锁，而没有加gap锁，所以session2是可以正常执行的，不能被阻塞。</p><h5>7.3 第一种情况：唯一索引+不命中数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>此时session2会阻塞住，证明id=7周围加了gap锁。gap锁的范围遵从左开右闭的原则，这里就是(6,7）以及(7,9)都会被锁住。加上record锁组成next-key锁，所以next-key锁的范围是(6,7]以及(7,9]这个范围。</p><h5>7.4 第三种情况：唯一索引+不命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>) <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>这里是一个范围，5和9都是存在的，但是7不存在，即部分数据不存在。</p><p>session2执行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",4);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",7);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",8);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",10);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>那么对于(5,9]的范围内就阻塞住了，那么部分命中就是部分加gap锁。</p><h5>7.5 第四种情况：唯一索引+命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>) <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>这里全部命中，那么</p><p>session2执行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",7);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",8);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>这个时候就不会加gap锁了。</p><h2>8. 例子-不走唯一索引或者不走索引</h2><p>下面来看看不走非唯一索引的当前读是什么情况。</p><p>此时表的数据为：</p><table><thead><tr><th>name</th><th>id</th></tr></thead><tbody><tr><td>h</td><td>2</td></tr><tr><td>c</td><td>6</td></tr><tr><td>b</td><td>9</td></tr><tr><td>d</td><td>9</td></tr><tr><td>f</td><td>11</td></tr><tr><td>a</td><td>15</td></tr></tbody></table><p>把id上的唯一索引换成了普通索引。</p><h5>8.1 第五种情况：非唯一索引</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>此时session2是会被block住的。gap的范围是(6,9]以及(9,11].</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",5);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",7);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",12);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>上面的原理都是一样的，即只要是6和11之间的数，不包含临界值的时候，无论插入什么数据，都是会阻塞的。</p><p>但是关于临界值6和11，这里就比较特殊了，因为需要加上主键的值才能进行精准的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values(&quot;bb&quot;,6);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values(&quot;dd&quot;,6);&lt;!--不可以--&gt;</span><br></pre></td></tr></table></figure><p>这是什么原因呢？</p><p>我们将数据画成图：</p><p><img src="http://bloghello.oursnail.cn/mysql4-8.jpg" alt="image"></p><p>这里的gap区间可能是(负无穷，2],(2,6],(6,9],(9,11],(11,15],(15,正无穷)</p><p>我们可以看到，id为6的行，对应的name为c(不要忘记name是主键，主键按照顺序排序)，那么主键中就是按照字母表的顺序进行排列的（ASCII码），如果插入的name小于c，那么就不在gap的范围内(c,)，就可以插入，但是dd在gap的范围内,所以就会阻塞住。</p><h5>8.2 第五种情况：不走索引</h5><p>这个时候，所有的间隙都会加上间隙锁，那么就是锁表了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从事务引出了Mysql InnoDB RR隔离级别下是如何防止幻读的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>锁模块</title>
    <link href="http://yoursite.com/2019/01/26/mysql/%E9%94%81%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/01/26/mysql/锁模块/</id>
    <published>2019-01-26T15:35:48.460Z</published>
    <updated>2019-01-27T13:25:47.704Z</updated>
    
    <content type="html"><![CDATA[<p>本章对行锁表所、共享锁排他锁进行详细说明。这是数据库锁的核心知识。</p><a id="more"></a><h2>MySQL中几种重要的锁概念</h2><h6>共享锁（S）和 排他锁（X）</h6><p>InnoDB 实现了标准的行级锁，包括两种：共享锁（简称 s 锁）、排它锁（简称 x 锁）</p><ul><li>共享锁允许持锁事务读取一行</li><li>排它锁允许持锁事务更新或者删除一行</li></ul><p>如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：</p><ul><li>T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁</li><li>T2 请求 x 锁不能被立即允许</li></ul><p>如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才行。</p><h6>意向锁</h6><p>innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。</p><p>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。</p><p>说白了意向锁的主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”</p><ul><li>意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 x 锁</li><li>意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 s 锁</li></ul><p>例如， <code>SELECT ... LOCK IN SHARE MODE</code> 设置一个 IS 锁, <code>SELECT ... FOR UPDATE</code> 设置一个 IX 锁。</p><p>意向锁的原则如下：</p><ul><li>一个事务必须先持有该表上的 IS 或者更强的锁才能持有该表中某行的 S 锁</li><li>一个事务必须先持有该表上的 IX 锁才能持有该表中某行的 X 锁</li></ul><h6>next-key锁</h6><p>InnoDB有三种行锁的算法：</p><ul><li>Record Lock：单个行记录上的锁。分为S Lock和X Lock</li><li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</li><li>Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</li></ul><p>在默认情况下，mysql的事务隔离级别是可重复读，并且<code>innodb_locks_unsafe_for_binlog</code>参数为0，这时默认采用<code>next-key locks</code>。所谓<code>Next-Key Locks</code>，就是<code>Record lock</code>和<code>gap lock</code>的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。</p><p>例子：假设一个索引包含值 10,11,13和20，索引上可能的NK 锁包括如下几个区间（注意开闭区间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><p>Innodb使用NK 锁来进行索引搜索和扫描，阻止了幻读。</p><p>间隙锁在Innodb中是被“十足的抑制”的，也就是说，他们只阻止其他事务插入到间隙中，他们不阻止其他事物在同一个间隙上获得间隙锁。</p><p>下篇文章会详细介绍一下。</p><h2>MyISAM和InnoDB关于锁方面的区别</h2><p>结论：</p><ul><li>MyISAM默认使用的是表级锁，不支持行级锁</li><li>InnoDB默认使用的是行级锁，也支持表级锁</li></ul><p>所谓表级锁，就是锁住整张表。开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p><strong>MyISAM在执行select的时候会产生一个表共享读锁，当进行更新等操作的时候会产生表独占写锁（排他锁）</strong>。所以：</p><ul><li>myISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但会阻塞对同一个表的写请求。</li><li>myISAM表的写操作，会阻塞其他用户对同一个表的读和写操作。</li><li>myISAM表的读、写操作之间、以及写操作之间是串行的。</li></ul><blockquote><p>这里的读是共享锁，也可以将其变为排他锁，语法是select … for update</p></blockquote><p>上面说完了<code>MyISAM</code>的表锁，下面要说说<code>InnoDB</code>啦。<code>InnoDB</code>支持行级锁。</p><p>所谓行级锁，就是锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发性也最高。</p><h2>SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE</h2><p>如果你在查询数据，然后在同一个事务里插入或者修改相关的数据，常规的 <code>select</code> 语句不会提供足够的保护。其他的事务可以修改或者删除你正在查询的行。<code>InnoDB</code> 支持两种可以提供安全机制的读取锁：</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code></li><li><code>SELECT ... FOR UPDATE</code></li></ul><p><code>SELECT … LOCK IN SHARE MODE</code> 在读取的行上设置一个共享锁，其他的<code>session</code>可以读这些行，但在你的事务提交之前不可以修改它们。如果这些行里有被其他的还没有提交的事务修改，你的查询会等到那个事务结束之后使用最新的值。</p><p>索引搜索遇到的记录，<code>SELECT … FOR UPDATE</code> 会锁住行及任何关联的索引条目，和你对那些行执行 <code>update</code> 语句相同。其他的事务会被阻塞在比如执行 <code>update</code> 操作，获取共享锁，或从某些事务隔离级别读取数据等操作。</p><p>使用 <code>SELECT FOR UPDATE</code> 为 <code>update</code> 操作锁定行，只适用于 <code>autocommit</code> 被禁用（当使用 <code>START TRANSACTION</code> 开始事务或者设置 <code>autocommit</code> 为0时）。如果 <code>autocommit</code> 已启用，符合规范的行不会被锁定。</p><p>以上是对官方文档的翻译解读。</p><hr><p><code>SELECT … LOCK IN SHARE MODE</code> ：<strong>共享锁</strong>(S锁, <code>share locks</code>)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。</p><p>如果事务对某行数据加上共享锁之后，可进行读写操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。</p><p><code>SELECT … FOR UPDATE</code>：<strong>排他锁</strong>(X锁, <code>exclusive locks</code>)。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。</p><p>注：普通 <code>select</code> 语句默认不加锁，而<code>CUD</code>操作默认加排他锁。</p><ul><li>当前事务获取共享锁后，可以读写，其他事务是否可以进行读写操作和获取共享锁：可以读，可以获取共享锁，不可以写</li><li>两个事务同时获取共享锁后，是否可以进行update操作：不可以</li><li>当前事务获取排他锁后，其他事务是否可以进行读写操作和获取共享锁：其他事务可以读，不可以获取共享锁，不可以写</li><li>是否可对一条数据加多个排他锁：不可以</li><li>行锁和索引的关系：查询字段未加索引（主键索引、普通索引等）时，使用表锁</li></ul><blockquote><p>注：InnoDB行级锁基于索引实现。</p></blockquote><blockquote><ul><li><p>未加索引时，两种行锁情况为（使用表锁）：</p><ul><li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的共享锁，不可以获取不同行数据的排他锁</li><li>事务1获取某行数据排他锁，其他事务不可以获取不同行数据的共享锁、排他锁</li></ul></li><li><p>加索引后，两种行锁为（使用行锁）：</p><ul><li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的排他锁</li><li>事务1获取某行数据排他锁，其他事务可以获取不同行数据的共享锁、排他锁</li></ul></li></ul></blockquote><ul><li>索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</li></ul><h2>总结（很重要）</h2><ul><li>MyISAM默认使用的是表级锁，不支持行级锁<ul><li>执行select的时候会产生一个表共享读锁</li><li>当进行更新等操作的时候会产生表独占写锁（排他锁）</li><li>读不会阻塞其他session的读以及获取表共享读锁</li><li>写会阻塞其他session读和写操作</li><li>写与读之间是串行的</li></ul></li><li>InnoDB默认使用的是行级锁，也支持表级锁<ul><li>InnoDB 支持两种可以提供安全机制的读取锁：SELECT … LOCK IN SHARE MODE以及SELECT … FOR UPDATE</li><li>SELECT … LOCK IN SHARE MODE 在读取的行上设置一个共享锁</li><li>SELECT … FOR UPDATE：排他锁</li><li>一个session对某一行上共享锁，其他的session可以读这行，也可以获取共享锁，但是不允许写，更不允许获取写锁。对于其他行，可以读写其他行数据也可以上读写锁。</li><li>一个session对某一行上排他锁，其他的session则不能加任何锁，包括共享锁。允许读这一行，但是不能写。允许对其他行数据进行读写以及上读写锁。</li><li>InnoDB中行级锁基于索引实现，所以在不加索引的时候，这两者上的其实都是表锁；加上索引之后，使用行锁。</li></ul></li></ul><div class="tip"><p>以上的内容都是从博客：<a href="https://blog.csdn.net/u012099869/article/details/52778728" target="_blank" rel="noopener">https://blog.csdn.net/u012099869/article/details/52778728</a> 中整理而来，具体的实验也在他的博客中进行了详细的展示。</p></div><h2>MyISAM适合场景</h2><ul><li>频繁执行全表count语句(MyISAM已经用一个表保存了行数)</li><li>对数据进行增删改的频率不高，查询非常频繁</li><li>没有事务</li></ul><h2>InnoDB适合场景</h2><ul><li>数据增删改查都相当频繁</li><li>可靠性要求比较高，要求支持事务</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章对行锁表所、共享锁排他锁进行详细说明。这是数据库锁的核心知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
</feed>
