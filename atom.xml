<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-17T12:27:22.698Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础之JDK动态代理</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/java基础之JDK动态代理/</id>
    <published>2019-02-17T12:16:53.333Z</published>
    <updated>2019-02-17T12:27:22.698Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式可以说是经常面试被问的一个东西，因为spring aop的实现原理就是基于它，关于它，只要记住，它是运行时动态生成的一个代理类。在这个基础上，再去看看它底层源码，其实JDK已经帮我们最大程度上封装成简单的函数了，我们只需要传入几个参数就可以生成对应的代理对象。</p><a id="more"></a><h2>代理模式是什么</h2><p>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p><ul><li><code>RealSubject</code> 是原对象（本文把原对象称为&quot;委托对象&quot;），<code>Proxy</code> 是代理对象。</li><li><code>Subject</code> 是委托对象和代理对象都共同实现的接口。</li><li><code>Request()</code> 是委托对象和代理对象共同拥有的方法。</li></ul><h2>结合生活理解代理模式</h2><p>要理解代理模式很简单，其实生活当中就存在代理模式：</p><blockquote><p>我们购买火车票可以去火车站买，但是也可以去火车票代售处买，此处的火车票代售处就是火车站购票的代理，即我们在代售点发出买票请求，代售点会把请求发给火车站，火车站把购买成功响应发给代售点，代售点再告诉你。</p><p>但是代售点只能买票，不能退票，而火车站能买票也能退票，因此代理对象支持的操作可能和委托对象的操作有所不同。</p></blockquote><h2>Java实现静态代理示例</h2><p><img src="http://bloghello.oursnail.cn/javabasic8-1.png" alt="image"></p><p>代理的实现分为：</p><ul><li>静态代理</li></ul><p>代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 <code>class</code> 文件。</p><ul><li>动态代理</li></ul><p>代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 <code>class</code> 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p><h2>Java 实现动态代理</h2><h5>几个重要名词:</h5><ul><li>委托类和委托对象：委托类是一个类，委托对象是委托类的实例，即原类。</li><li>代理类和代理对象：代理类是一个类，代理对象是代理类的实例。</li></ul><h5>Java实现动态代理的大致步骤如下:</h5><ol><li>定义一个委托类和公共接口。</li><li>自己定义一个类（调用处理器类，即实现 <code>InvocationHandler</code> 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括<code>Preprocess</code>和<code>Postprocess</code>），即代理类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。</li><li>生成代理对象（当然也会生成代理类），需要为他指定(1)类加载器对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li></ol><h5>Java 实现动态代理主要涉及以下几个类:</h5><ul><li><code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 <code>Proxy</code> 类生成的代理类都继承了 <code>Proxy</code> 类，即 <code>DynamicProxyClass extends Proxy</code>。</li><li><code>java.lang.reflect.InvocationHandler</code>: 这里称他为&quot;调用处理器&quot;，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 <code>InvocationHandler</code> 接口。</li></ul><h5>Proxy 类主要方法为：</h5><p><img src="http://bloghello.oursnail.cn/javabasic8-2.png" alt="image"></p><ul><li>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区）</li><li>第二个参数是接口（表明你这个代理类需要实现哪些接口）</li><li>第三个参数是调用处理器类实例（指定代理类中具体要干什么）。</li><li>这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用<code>newProxyInstance()</code>时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：</li></ul><p><img src="http://bloghello.oursnail.cn/javabasic8-3.png" alt="image"></p><p><code>Proxy</code> 类还有一些静态方法，比如：</p><ul><li><code>InvocationHandler getInvocationHandler(Object proxy)</code>: 获得代理对象对应的调用处理器对象。</li><li><code>Class getProxyClass(ClassLoader loader, Class[] interfaces)</code>: 根据类加载器和实现的接口获得代理类。</li></ul><p><code>Proxy</code> 类中有一个映射表，映射关系为：(<code>&lt;ClassLoader&gt;</code>,(<code>&lt;Interfaces&gt;</code>,<code>&lt;ProxyClass&gt;</code>) )，可以看出一级key为类加载器，根据这个一级key获得二级映射表，二级key为接口数组，因此可以看出：一个类加载器对象和一个接口数组确定了一个代理类。</p><p>我们写一个简单的例子来阐述 Java 实现动态代理的整个过程：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-4.png" alt="image"></p><p><code>InvocationHandler</code> 接口中有方法：<code>invoke(Object proxy, Method method, Object[] args)</code></p><p>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，<strong>第一个参数是代理对象</strong>（表示哪个代理对象调用了method方法，传递来的是），<strong>第二个参数是 Method 对象</strong>（表示哪个方法被调用了），<strong>第三个参数是指定调用方法的参数</strong>。</p><p>动态生成的代理类具有几个特点：</p><ul><li>继承 <code>Proxy</code> 类，并实现了在<code>Proxy.newProxyInstance()</code>中提供的接口数组。</li><li><code>public final</code>。</li><li>命名方式为 <code>$ProxyN</code>，其中N会慢慢增加，一开始是 <code>$Proxy1</code>，接下来是<code>$Proxy2</code>…</li><li>有一个参数为 <code>InvocationHandler</code> 的构造函数。这个从 <code>Proxy.newProxyInstance()</code> 函数内部的<code>clazz.getConstructor(new Class[] { InvocationHandler.class })</code> 可以看出。</li></ul><p>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p><blockquote><p>不难发现，代理类的实现是有很多共性的（重复代码），动态代理的好处在于避免了这些重复代码，只需要关注操作。</p></blockquote><h2>小栗子</h2><p>假设模拟一个场景，买衣服，正常情况所有人买这件衣服要100块钱。</p><p>定义一个销售接口：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-5.png" alt="image"></p><p>一个具体的实现类：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-6.png" alt="image"></p><p>那么正常情况大家都要花100才能买这件衣服。但是现在对会员做活动，会员打5折。怎么做呢？正常思维是：增加一个接口，甚至更糟的想法是修改一下这个实现类，都是不好的，那么我们是否想过这样的方案：新建一个新的类，让这个代理类去做相应的逻辑呢？既不用修改原来的代码，而且还很简单就能实现。</p><p>现在写一个代理类：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-7.png" alt="image"></p><p>那么调用的时候，一个是会员，一个是普通用户，根据身份调不同的方法即可：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-8.png" alt="image"></p><h2>Java 动态代理的内部实现</h2><p>现在我们就会有一个问题： Java 是怎么保证代理对象调用的任何方法都会调用 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法的？</p><p>这就涉及到动态代理的内部实现。假设有一个接口 <code>Subject</code>，且里面有 <code>int request(int i)</code> 方法，则生成的代理类大致如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-9.png" alt="image"></p><p>通过上面的方法就成功调用了 <code>invoke()</code> 方法，所以这是代理类中已经注定要去执行 <code>invoke()</code> 方法了。</p><p>有一篇文章比较生动地阐述了动态代理的含义：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513926&amp;idx=1&amp;sn=1c43c5557ba18fed34f3d68bfed6b8bd&amp;chksm=80d67b85b7a1f2930ede2803d6b08925474090f4127eefbb267e647dff11793d380e09f222a8#rd" target="_blank" rel="noopener">Java帝国之动态代理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式可以说是经常面试被问的一个东西，因为spring aop的实现原理就是基于它，关于它，只要记住，它是运行时动态生成的一个代理类。在这个基础上，再去看看它底层源码，其实JDK已经帮我们最大程度上封装成简单的函数了，我们只需要传入几个参数就可以生成对应的代理对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础之注解</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/java基础之注解/</id>
    <published>2019-02-17T11:44:28.868Z</published>
    <updated>2019-02-17T11:44:49.892Z</updated>
    
    <content type="html"><![CDATA[<p>注解是一系列元数据，它提供数据用来解释程序代码，注释是给人看的，注解是给编译器看的，因此注解只在编译器有效。注解的实现原理涉及反射和动态代理，关于反射已经在前面说过，动态代理还没说，留在下一节。</p><a id="more"></a><h2>注解语法</h2><p>相信有不少的人员会认为注解的地位不高。其实同 <code>classs</code> 和 <code>interface</code> 一样，注解也属于一种类型。它是在 Java SE 5.0 版本中开始引入的概念。</p><h2>注解的定义</h2><p>注解通过 <code>@interface</code> 关键字进行定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><p>你可以简单理解为创建了一张名字为 <code>TestAnnotation</code> 的标签。</p><h2>注解的使用</h2><p>上面创建了一个注解，那么注解的的使用方法是什么呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。</p><h2>什么是元注解</h2><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p><p>元标签有 <code>@Retention</code>、<code>@Documented</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Repeatable</code> 5 种。</p><blockquote><p>@Retention</p></blockquote><p><code>Retention</code> 的英文意为保留期的意思。当 <code>@Retention</code> 应用到一个注解上的时候，它解释说明了这个<strong>注解的的存活时间</strong>。</p><ul><li><code>RetentionPolicy.SOURCE</code> 注解只在<strong>源码阶段</strong>保留，在编译器进行<strong>编译时它将被丢弃</strong>忽视。</li><li><code>RetentionPolicy.CLASS</code> 注解<strong>只被保留到编译进行</strong>的时候，它并<strong>不会被加载到 JVM</strong> 中。</li><li><code>RetentionPolicy.RUNTIME</code> 注解可以<strong>保留到程序运行</strong>的时候，它<strong>会被加载进入到 JVM</strong> 中，所以在程序运行时可以获取到它们。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Documented</p></blockquote><p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 <code>Javadoc</code> 中去。</p><blockquote><p>@Target</p></blockquote><p><code>Target</code> 是目标的意思，<code>@Target</code> 指定了注解运用的地方。</p><ul><li><code>ElementType.ANNOTATION_TYPE</code> 可以给一个注解进行注解</li><li><code>ElementType.CONSTRUCTOR</code> 可以给构造方法进行注解</li><li><code>ElementType.FIELD</code> 可以给属性进行注解</li><li><code>ElementType.LOCAL_VARIABLE</code> 可以给局部变量进行注解</li><li><code>ElementType.METHOD</code> 可以给方法进行注解</li><li><code>ElementType.PACKAGE</code> 可以给一个包进行注解</li><li><code>ElementType.PARAMETER</code> 可以给一个方法内的参数进行注解</li><li><code>ElementType.TYPE</code> 可以给一个类型进行注解，比如类、接口、枚举</li></ul><blockquote><p>@Inherited</p></blockquote><p><code>Inherited</code> 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个<strong>超类被 <code>@Inherited</code> 注解过的注解进行注解</strong>的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个被@Inherited注解的注解@Test</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类被@Test注解，即上面说的被@Inherited 注解过的注解进行注解</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么class B也拥有@Test注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Repeatable</p></blockquote><p><code>Repeatable</code> 自然是可重复的意思。<code>@Repeatable</code> 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照规定，它里面必须要有一个 value 的属性</span></span><br><span class="line"><span class="comment">//属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。</span></span><br><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Repeatable 后面括号中的类相当于一个容器注解</span></span><br><span class="line"><span class="comment">//什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    <span class="function">String <span class="title">role</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有了上面两个注解，Persons相当于一个总标签</span></span><br><span class="line"><span class="comment">//他里面可以放任意多个子标签，这些子标签类型是Person</span></span><br><span class="line"><span class="comment">//并且是存放于这个总标签的Person类型的数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么既然有了总标签和放子标签的数组，那么，下面就可以定义子标签</span></span><br><span class="line"><span class="comment">//子标签的类型自然就是Person，里面这里假设定义role属性</span></span><br><span class="line"><span class="comment">//就是说这些子标签表示人的角色。</span></span><br><span class="line"><span class="comment">//自然也就支持多种角色，那么定义多次即可。如下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"artist"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"coder"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"PM"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>注解的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有默认值的时候，可以不执行属性</span></span><br><span class="line"><span class="meta">@TestAnnotation</span>(id=<span class="number">3</span>,msg=<span class="string">"hello annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些规则：</p><ul><li>修饰符只能是<code>public</code> 或默认(<code>default</code>)</li><li>参数成员只能用基本类型<code>byte</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>double</code>,<code>boolean</code>,<code>char</code>八种基本类型和<code>String</code>,<code>Enum</code>,<code>Class</code>,<code>annotations</code>及这些类型的数组</li><li>如果只有一个参数成员,最好将名称设为”value”</li><li>注解元素必须有确定的值,可以在注解中定义默认值,也可以使用注解时指定,非基本类型的值不可为null,常使用空字符串或0作默认值</li><li>在表现一个元素存在或缺失的状态时,定义一下特殊值来表示,如空字符串或负值</li></ul><h2>Java 预置的注解</h2><blockquote><p>@Deprecated</p></blockquote><p>这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。</p><blockquote><p>@Override</p></blockquote><p>这个大家应该很熟悉了，提示子类要复写父类中被 <code>@Override</code> 修饰的方法</p><blockquote><p>@SuppressWarnings</p></blockquote><p>阻止警告的意思。之前说过调用被 <code>@Deprecated</code> 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 <code>@SuppressWarnings</code> 达到目的。</p><blockquote><p>@SafeVarargs</p></blockquote><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 <code>unchecked</code> 这样的警告。</p><blockquote><p>@FunctionalInterface</p></blockquote><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。</p><p>函数式接口 (<code>Functional Interface</code>) 就是一个具有一个方法的普通接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行线程开发中常用的 <code>Runnable</code> 就是一个典型的函数式接口，上面源码可以看到它就被 <code>@FunctionalInterface</code> 注解。</p><p>可能有人会疑惑，函数式接口标记有什么用，这个原因是函数式接口可以很容易转换为 <code>Lambda</code> 表达式。</p><h2>注解与反射</h2><blockquote><p>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者是 getAnnotations() 方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里举个例子：</p><p>首先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个类，打上这个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再main函数中拿到注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断Test.class中是否存在TestAnnotation注解</span></span><br><span class="line">        <span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(hasAnnotation)&#123;</span><br><span class="line">            System.out.println(<span class="string">"注解存在..."</span>);</span><br><span class="line">            <span class="comment">//从Test类中拿出TestAnnotation注解</span></span><br><span class="line">            TestAnnotation annotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">            <span class="comment">//拿到注解之后，可以拿出注解中的属性对应的默认值</span></span><br><span class="line">            System.out.println(annotation.id());</span><br><span class="line">            System.out.println(annotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面演示的是从类上拿到注解，对于属性、方法同样都可以用反射拿到注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>(value=<span class="string">"hi"</span>)</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Perform</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*************拿到属性上的注解****************/</span></span><br><span class="line">            Field a = Test.class.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">            a.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//获取一个成员变量上的注解</span></span><br><span class="line">            Check check = a.getAnnotation(Check.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( check != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                System.out.println(<span class="string">"check value:"</span>+check.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************拿到方法上的注解****************/</span></span><br><span class="line">            Method testMethod = Test.class.getDeclaredMethod(<span class="string">"testMethod"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( testMethod != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// 获取方法中的注解</span></span><br><span class="line">                Annotation[] ans = testMethod.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.length;i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"method testMethod annotation:"</span>+ans[i].annotationType().getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>注解实现原理</h2><p>在上面获取注解时是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestAnnotation annotation = Test.class.getAnnotation(TestAnnotation.class);</span><br></pre></td></tr></table></figure><p>它是从<code>class</code>中获取出<code>TestAnnotation</code>注解的，所以肯定是在某个时候注解被加入到<code>class</code>结构中去了。</p><ul><li>首先，我们知道从<code>java</code>源码到<code>class</code>字节码是由编译器完成的，编译器会对<code>java</code>源码进行解析并生成<code>class</code>文件。</li><li>而注解也是在编译时由编译器进行处理，编译器会对注解符号处理并附加到<code>class</code>结构中</li><li>根据<code>jvm</code>规范，<code>class</code>文件结构是严格有序的格式，唯一可以附加信息到<code>class</code>结构中的方式就是保存到<code>class</code>结构的<code>attributes</code>属性中</li><li>我们知道对于类、字段、方法，在<code>class</code>结构中都有自己特定的表结构，而且各自都有自己的属性，而对于注解，作用的范围也可以不同，可以作用在类上，也可以作用在字段或方法上，这时编译器会对应将注解信息存放到类、字段、方法自己的属性上。</li><li>在我们的<code>Test</code>类被编译后，在对应的<code>Test.class</code>文件中会包含一个<code>RuntimeVisibleAnnotations</code>属性，由于这个注解是作用在类上，所以此属性被添加到类的属性集上。即<code>TestAnnotation</code>注解的键值对<code>value=test</code>会被记录起来。</li><li>而当<code>JVM</code>加载<code>Test.class</code>文件字节码时，就会将<code>RuntimeVisibleAnnotations</code>属性值保存到<code>Test</code>的<code>Class</code>对象中，于是就可以通过<code>Test.class.getAnnotation(TestAnnotation.class)</code>获取到<code>Test</code>注解对象，进而再通过<code>Test</code>注解对象获取到<code>Test</code>里面的属性值。</li><li><code>Test</code>注解对象是什么？其实注解被编译后的本质就是一个继承<code>Annotation</code>接口的接口。所以<code>@TestAnnotation</code>其实就是“public interface TestAnnotation extends Annotation”</li><li>当我们通过<code>Test.class.getAnnotation(TestAnnotation.class)</code>调用时，<code>JDK</code>会通过动态代理生成一个实现了<code>TestAnnotation</code>接口的对象，并把将<code>RuntimeVisibleAnnotations</code>属性值设置进此对象中，此对象即为<code>TestAnnotation</code>注解对象，通过它的<code>value()</code>方法就可以获取到注解值。</li></ul><h2>总结注解到底是什么以及注解到底有什么应用场景</h2><p>注释是给人看的，<strong>注解是给编译器看的</strong>，以<code>@Override</code>注解为例，他的作用是告诉编译器他所注解的方法是重写父类中的方法，这样编译器就会去检查父类是否存在这个方法，以及这个方法的签名与父类是否相同。</p><p><strong>注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用</strong>；</p><p>也就是说，注解只是描述java代码的代码，能被编译器解析，<strong>只有编译器或者虚拟机来主动解析他的时候，他才可能发挥作用</strong>。</p><p>注解分为三类，元注解，java自带的标准注解以及自定义注解。</p><p>注解的使用场景：</p><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><p>我觉得这些说的太空洞了，注解在<code>spring</code>中就是非常常用的技术，比如，我指定这个类是<code>@Controller</code>或者<code>@Service</code>之类，那么我配置包扫描将其类路径全部扫描到后，启动容器的时候，这些类就会自动被spring所管理，即自动向<code>spring</code>注册，以后要注入这些组件的时候，就直接从<code>spring</code>的<code>IOC</code>容器中取出来即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注解是一系列元数据，它提供数据用来解释程序代码，注释是给人看的，注解是给编译器看的，因此注解只在编译器有效。注解的实现原理涉及反射和动态代理，关于反射已经在前面说过，动态代理还没说，留在下一节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之冰川表面</title>
    <link href="http://yoursite.com/2019/02/17/java-basic/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%B0%E5%B7%9D%E8%A1%A8%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/02/17/java-basic/Java基础之冰川表面/</id>
    <published>2019-02-17T10:30:34.398Z</published>
    <updated>2019-02-17T10:30:59.111Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是罗列一些关于java基础的核心点，这些点是基础中的基础，也是重点中的重点。为什么本篇文章叫做冰川表面呢？我想表达的意思是，这些基础只是一个引子，背后牵扯出来的东西可能会很多，面试往往都是从基础的知识点慢慢深入挖掘的，所以千万不能忽视对于它们的复习。</p><a id="more"></a><h1>一、关键字</h1><h2>final</h2><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，<code>final</code> 使数值不变；</li><li>对于引用类型，<code>final</code> 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>2. 方法</strong></p><p>声明方法不能被子类覆盖。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是覆盖基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h2>static</h2><p><strong>1. 静态变量</strong></p><p>静态变量在内存中只存在一份，只在类初始化时赋值一次。</p><ul><li>静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;        <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（<code>abstract</code>）。</p><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><p><strong>4. 静态内部类</strong></p><p>内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure><p>在使用静态变量和方法时不用再指明 <code>ClassName</code>，从而简化代码，但可读性大大降低。</p><p><strong>6. 变量赋值顺序</strong></p><p>静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行，静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。</p><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h1>二、Object 通用方法</h1><h2>概览</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2>equals()</h2><p><strong>1. equals() 与 == 的区别</strong></p><ul><li>对于基本类型，<code>==</code> 判断两个值是否相等，基本类型没有 <code>equals()</code> 方法。</li><li>对于引用类型，<code>==</code> 判断两个实例是否引用同一个对象，而 <code>equals()</code> 判断引用的对象是否等价。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>默认情况下也就是从超类<code>Object</code>继承而来的<code>equals</code>方法与<code>==</code>是完全等价的，比较的都是对象的内存地址，但我们可以重写<code>equals</code>方法，使其按照我们的需求的方式进行比较，如<code>String</code>类重写了<code>equals</code>方法，使其比较的是字符的序列，而不再是内存地址。</p><p><strong>2. 等价关系</strong></p><p>（一）自反性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（二）对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（三）传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><p>（四）一致性</p><p>多次调用 <code>equals()</code> 方法结果不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（五）与 <code>null</code> 的比较</p><p>对任何不是 <code>null</code> 的对象 <code>x</code> 调用 <code>x.equals(null)</code> 结果都为 <code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.euqals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 <code>true</code>；</li><li>检查是否是同一个类型，如果不是，直接返回 <code>false</code>；</li><li>将 <code>Object</code> 实例进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>hashCode()</h2><p><code>hasCode()</code> 返回散列值，而 <code>equals()</code> 是用来判断两个实例是否等价。等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</p><p>在覆盖 <code>equals()</code> 方法时应当总是覆盖 <code>hashCode()</code> 方法，保证等价的两个实例散列值也相等。</p><p>下面的代码中，新建了两个等价的实例，并将它们添加到 <code>HashSet</code> 中。我们希望将这两个实例当成一样的，只在集合中添加一个实例，但是因为 <code>EqualExample</code> 没有实现 <code>hasCode()</code> 方法，因此这两个实例的散列值是不同的，最终导致集合添加了两个等价的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><blockquote><p>之所以选择31，是因为它是个奇素数，如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算。使用素数的好处并不是很明显，但是习惯上都使用素数来计算散列结果。31有个很好的特性，就是用移位和减法来代替乘法，可以得到更好的性能：31*i==(i&lt;&lt;5)-i。现在的VM可以自动完成这种优化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>clone()</h2><p><strong>1. cloneable</strong></p><p><code>clone()</code> 是 <code>Object</code> 的受保护方法，这意味着，如果一个类不显式去覆盖 <code>clone()</code> 就没有这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</span></span><br></pre></td></tr></table></figure><p>接下来覆盖 <code>Object</code> 的 <code>clone()</code> 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneTest</span><br></pre></td></tr></table></figure><p>以上抛出了 <code>CloneNotSupportedException</code>，这是因为 <code>CloneTest</code> 没有实现 <code>Cloneable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p><strong>2. 深拷贝与浅拷贝</strong></p><ul><li>浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；</li><li>深拷贝：拷贝实例和原始实例的引用类型引用不同对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用 <code>clone()</code> 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。<code>Effective Java</code> 书上讲到，最好不要去使用 <code>clone()</code>，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1>四、继承</h1><h2>访问权限</h2><p>Java 中有三个访问权限修饰符：<code>private</code>、<code>default</code>、<code>protected</code> 以及<code>public</code>，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>成员可见表示其它类可以用这个类的实例访问到该成员；</li><li>类可见表示其它类可以用这个类创建对象。</li></ul><p><code>protected</code> 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>如果子类的方法覆盖了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。可以使用公有的 <code>getter</code> 和 <code>setter</code> 方法来替换公有字段。</p><h2>抽象类与接口</h2><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 <code>abstract</code> 进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title">AbstractClassExample</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated</span></span><br><span class="line">AbstractClassExample ac2 = <span class="keyword">new</span> AbstractExtendClassExample();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员（字段 + 方法）默认都是 <code>public</code> 的，并且不允许定义为 <code>private</code> 或者<code>protected</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic7-1.png" alt="image"></p><p>接口的字段默认都是 <code>static</code> 和 <code>final</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;                // Variable 'y' might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> z = <span class="number">0</span>;       <span class="comment">// Modifier 'public' is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier 'private' not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier 'protected' not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier 'private' not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated</span></span><br><span class="line">InterfaceExample ie2 = <span class="keyword">new</span> InterfaceImplementExample();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 <code>static</code> 和 <code>final</code> 类型的，而抽象类的字段没有这种限制。</li><li>接口的方法只能是 <code>public</code> 的，而抽象类的方法可以由多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的方法和域的访问权限，而不是都为 <code>public</code>。</li><li>需要继承非静态（<code>non-static</code>）和非常量（<code>non-final</code>）字段。</li></ul><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 <code>Compareable</code> 接口中的 <code>compareTo()</code> 方法；</li><li>需要使用多重继承。</li></ul><p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h2>super</h2><ul><li>访问父类的构造函数：可以使用 <code>super()</code> 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 <code>super</code> 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><h2>覆盖与重载</h2><ul><li><p>覆盖（<code>Override</code>）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法；</p></li><li><p>重载（<code>Overload</code>）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。</p></li></ul><h1>五、String</h1><h2>String, StringBuffer and StringBuilder</h2><p><strong>1. 是否可变</strong></p><ul><li><code>String</code> 不可变</li><li><code>StringBuffer</code> 和 <code>StringBuilder</code> 可变</li></ul><p><strong>2. 是否线程安全</strong></p><ul><li><code>String</code> 不可变，因此是线程安全的</li><li><code>StringBuilder</code> 不是线程安全的</li><li><code>StringBuffer</code> 是线程安全的，内部使用 <code>synchronized</code> 来同步</li></ul><h2>String 不可变的原因</h2><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 <code>String</code> 的 <code>hash</code> 值经常被使用，例如 <code>String</code> 用做 <code>HashMap</code> 的 <code>key</code>。不可变的特性可以使得 <code>hash</code> 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 <code>String</code> 对象已经被创建过了，那么就会从 <code>String Pool</code> 中取得引用。只有 <code>String</code> 是不可变的，才可能使用 <code>String Pool</code>。</p><p><strong>3. 安全性</strong></p><p><code>String</code> 经常作为参数，<code>String</code> 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 <code>String</code> 是可变的，那么在网络连接过程中，<code>String</code> 被改变，改变 <code>String</code> 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p><code>String</code> 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><h2>String.intern()</h2><p>使用 <code>String.intern()</code> 可以保证相同内容的字符串实例引用相同的内存对象。</p><p>下面示例中，<code>s1</code> 和 <code>s2</code> 采用 <code>new String()</code> 的方式新建了两个不同对象，而 <code>s3</code> 是通过 <code>s1.intern()</code> 方法取得一个对象引用，这个方法首先把 <code>s1</code> 引用的对象放到 <code>String Poll</code>（字符串常量池）中，然后返回这个对象引用。因此 <code>s3</code> 和 <code>s1</code> 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">"bbb"</span>;</span><br><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p></blockquote><h1>六、基本类型与运算</h1><h2>包装类型</h2><p>八个基本类型：</p><ul><li>boolean/1</li><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><p><code>new Integer(123)</code> 与 <code>Integer.valueOf(123)</code> 的区别在于，<code>new Integer(123)</code> 每次都会新建一个对象，而 <code>Integer.valueOf(123)</code> 可能会使用缓存对象，因此多次使用 <code>Integer.valueOf(123)</code> 会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 <code>valueOf()</code> 方法，因此多个 <code>Integer</code> 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>valueOf()</code> 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，<code>Integer</code> 缓存池的大小默认为 -128~127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><blockquote><p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener">Differences between new Integer(123), Integer.valueOf(123) and just 123<br></a></p></blockquote><h2>switch</h2><p>从 Java 7 开始，可以在 <code>switch</code> 条件判断语句中使用 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 不支持 <code>long</code>，是因为 <code>swicth</code> 的设计初衷是为那些只需要对少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是罗列一些关于java基础的核心点，这些点是基础中的基础，也是重点中的重点。为什么本篇文章叫做冰川表面呢？我想表达的意思是，这些基础只是一个引子，背后牵扯出来的东西可能会很多，面试往往都是从基础的知识点慢慢深入挖掘的，所以千万不能忽视对于它们的复习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Condition详解</title>
    <link href="http://yoursite.com/2019/02/15/thread/Condition%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/15/thread/Condition详解/</id>
    <published>2019-02-15T03:44:10.048Z</published>
    <updated>2019-02-15T03:51:51.780Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://fourcolor.oursnail.cn/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">线程间通信方式总结</a>中有一个需求：轮流打印奇数和偶数，我们用wait和notify实现了一下，但是这种方式存在弊端，就是不能精确控制唤醒哪个线程，比如现在有一个需求是轮流打印ABC该怎么办呢？</p><a id="more"></a><p>首先准备三个线程，分别执行打印方法，是一个死循环，每次休息一秒。</p><p><img src="http://bloghello.oursnail.cn/thread16-1.jpg" alt="image"></p><h2>一、wait/notify实现轮流打印ABC三个字母</h2><p>如果是不加任何控制策略的话，必然是无法保证按照<code>A</code> <code>B</code> <code>C</code>的顺序依次循环执行的，比如：</p><p><img src="http://bloghello.oursnail.cn/thread16-2.jpg" alt="image"></p><p>执行结果是：</p><p>1694620367</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么如何保证按照我们这个顺序执行呢？如果还是沿用这个方法，只能这样写：</p><p><img src="http://bloghello.oursnail.cn/thread16-3.jpg" alt="image"></p><p>思想也很简单，就是搞一个变量，规定只有0的时候才打印<code>A</code>，只有1的时候才打印<code>B</code>，只有2的时候才打印<code>C</code>。那么，对于打印<code>A</code>的线程，只要不是0就<code>wait()</code>等待，一旦等于0就打印，并且加一；对于打印<code>B</code>的线程，只要不是1就<code>wait()</code>等待，一旦等于1就打印，并且加一。剩下同理。</p><p>这样，由于<code>signal</code>是一个成员变量，初始值为0.那么三个线程中<code>PrintB</code>和<code>PrintC</code>都等待，只有<code>PrintA</code>能执行打印，然后加为1，唤醒所有等待的线程来判断，此时打印<code>A</code>的线程和打印<code>C</code>的线程发现都不符合他们打印的条件，都进入了<code>while</code>中等待了，只有打印<code>B</code>的线程发现等于1，则不进入<code>while</code>循环，打印再加一。依次反复，可以得到顺序打印的<code>A</code>、<code>B</code>、<code>C</code>。</p><p>这种方式显然很不好，是靠<code>notifyAll</code>来唤醒所有线程来实现的，那么我们能不能唤醒指定的线程呢？这样处理起来更加优雅效率也会更高！</p><h2>二、Condition来实现</h2><p><img src="http://bloghello.oursnail.cn/thread16-4.jpg" alt="image"></p><p>达到了上面一样的效果。此时，我们发现它的强大之处在于我们可以指定哪个线程唤醒了，这看起来是一点点进步，但是我们学习多线程那么长时间了，在我看来，是很大的一个进步，因为之前用<code>notify</code>是随机唤醒一个，<code>notifyAll</code>是唤醒全部，总是不能受我们的完全控制，虽然说线程的执行本身就是不确定的，因此不确定性是他们的天生属性，但是在某些场景下我们确实需要一个高效并且优雅的实现可控的方式，所以是很重要的。</p><p>它这种功能可以给我们带来什么呢？下面用它实现一个有界队列。（关于生产者消费者模式，当然也可以用了，写法非常简单，就是对照上面的例子改一下即可。）</p><h2>三、Condition实现有界队列</h2><p>我们已经接触了线程池，它里面涉及队列，有很多种队列，最常见的是<code>ArrayBlockingQueue</code>以及<code>LinkedBlockingQueue</code>，他们的源码中其实也是靠<code>Condition</code>来实现阻塞塞值和阻塞取值的。现在我们也来实现一个比较简单的<code>ArrayBlockingQueue</code>吧！</p><p>首先明确一下队列是<code>FIFO</code>的，即先进先出，那么我们要保证先插入的要先弹出。其次要注意的是当没有元素的时候要阻塞，即等待有元素了才能获取；放入元素也是同理，要等有空位的才能重新放入。</p><p>如何实现以上这种数据结构呢？关于先进的先出来，我们可以用两个指针来实现，一个叫做<code>addIndex</code>，一个叫做<code>removeIndex</code>，初始都是指向第一个元素处。当塞进来一个元素，那么<code>addIndex</code>就自增，当自增到最后一个位置，这个时候数组不一定是满的，因为有可能前面的值已经被取出去了，所以还需要一个变量<code>count</code>来标志是否已经塞满，如果满了就阻塞，否则如果<code>addIndex</code>到最后一个位置，就重新置0.</p><p>对于<code>removeIndex</code>也是相同方向移除，假设最简单的情况，就是长度为5的数组，那么第一个元素放在0位置，第二个元素放在1位置，第三个元素放在2位置，此时要移除，那么第一个元素就是我们要的最先进来的元素，我们将其移除，并且<code>removeIndex</code>加一指向第二个元素。如此反复执行。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指向的是刚入队的元素的下角标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex;</span><br><span class="line">    <span class="comment">//指向的是刚出队的元素后面一个元素的下角标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> removeIndex;</span><br><span class="line">    <span class="comment">//实际元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition putCondition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition getCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化队列的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        myQueue = <span class="keyword">new</span> Object[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列的尾部放入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == myQueue.length)&#123;</span><br><span class="line">            <span class="comment">//说明队列已经满了，需要等待一下，那么放元素的线程就要阻塞住，即等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--队列已满，不能再塞值了，我要阻塞一会...."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                putCondition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明是可以放入元素的</span></span><br><span class="line">        myQueue[addIndex++] = object;</span><br><span class="line">        <span class="keyword">if</span>(addIndex == myQueue.length)&#123;</span><br><span class="line">            addIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素的数量要加一</span></span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功向队列放入一个元素，当前队列元素个数为---"</span>+count);</span><br><span class="line">        System.out.println();</span><br><span class="line">        getCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列的头部获取元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明队列已经满了，需要等待一下，那么取元素的线程就要阻塞住，即等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--队列已空，不能再取值了，我要阻塞一会...."</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getCondition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> removeValue = (<span class="keyword">int</span>) myQueue[removeIndex];</span><br><span class="line">        myQueue[removeIndex++] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (removeIndex == myQueue.length)&#123;</span><br><span class="line">            removeIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功从队列获取一个元素，当前队列的元素个数为---"</span>+count);</span><br><span class="line">        putCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">return</span> removeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue myQueue = <span class="keyword">new</span> MyQueue(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PutThread(myQueue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TakeThread(myQueue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TakeThread(myQueue)).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyQueue myQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(MyQueue myQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myQueue = myQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"成功放入一个元素，元素为："</span>+i);</span><br><span class="line">            myQueue.put(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TakeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyQueue myQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TakeThread</span><span class="params">(MyQueue myQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myQueue = myQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>) myQueue.get();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功放入一个元素，元素为："</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>四、Condition原理概述</h2><p>我们在上面的学习中看到，对于一个线程，我们就要准备一个<code>Condition</code>对象，并且还要用可重入锁<code>ReentrantLock</code>来实现加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">public</span> Condition cp = lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> Condition cc = lock.newCondition();</span><br></pre></td></tr></table></figure><p>它的原理是什么呢？</p><p>我们看到，创建一个<code>condition</code>对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会<code>new</code>出一个<code>ConditionObject</code>对象，该类是<code>AQS</code>的一个内部类.</p><p>我们知道在锁机制的实现上，<code>AQS</code>内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，<code>condition</code>内部也是使用同样的方式，内部维护了一个 等待队列，所有调用<code>condition.await</code>方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到<code>ConditionObject</code>中有两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><p>这样我们就可以看出来<code>ConditionObject</code>通过持有等待队列的头尾指针来管理等待队列。主要注意的是<code>Node</code>类复用了在<code>AQS</code>中的<code>Node</code>类。所以理解了<code>AQS</code>就简单了。但是这个队列有一点不同，他是一个单向链表，而<code>AQS</code>中的同步队列式一个双向链表。</p><p><img src="http://bloghello.oursnail.cn/thread16-5.jpg" alt="image"></p><p>同时还有一点需要注意的是：我们可以多次调用<code>lock.newCondition()</code>方法创建多个<code>condition</code>对象，也就是一个<code>lock</code>可以持有多个等待队列。而在之前利用<code>Object</code>的方式实际上是指在对象<code>Object</code>对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的<code>Lock</code>拥有一个同步队列和多个等待队列。示意图如下：</p><p><img src="http://bloghello.oursnail.cn/thread16-6.jpg" alt="image"></p><p>如图所示，<code>ConditionObject</code>是<code>AQS</code>的内部类，因此每个<code>ConditionObject</code>能够访问到<code>AQS</code>提供的方法，相当于每个<code>Condition</code>都拥有所属同步器的引用。</p><p>好了，至此我们已经知道多次调用<code>lock.newCondition()</code>方法创建多个<code>condition</code>对象，并且实际上这个对象就是<code>ConditionObject</code>。AQS维护的同步队列是一个双向链表结构，而这个<code>Condition</code>对象维护的是一个单项链表结构。</p><h2>五、await实现原理</h2><p>当调用<code>condition.await()</code>方法后会使得当前获取<code>lock</code>的线程进入到等待队列，如果该线程能够从<code>await()</code>方法返回的话一定是该线程获取了与<code>condition</code>相关联的<code>lock</code>。<code>await()</code>方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-7.jpg" alt="image"></p><p>在当前线程调用<code>condition.await()</code>方法后，会使得当前线程释放<code>lock</code>然后加入到等待队列中，直至被<code>signal</code>/<code>signalAll</code>后会使得当前线程从等待队列中移至到同步队列中去，直到获得了<code>lock</code>后才会从<code>await</code>方法返回(跳出<code>while</code>循环那就不用继续等待了呗)，或者在等待时被中断会做中断处理。</p><p>所以对于<code>await()</code>方法来说，它实现的功能为：将要等待的线程封装成节点尾插入到等待队列中，然后跟<code>wait</code>一样释放这个等待线程的锁。这些做完了之后还需要<code>while</code>循环判断是否已经在同步队列中，这个<code>isOnsyncQueue</code>是由下面说到的<code>signal</code>方法触发的，由于此时还没有<code>signal</code>所以陷在死循环中出不来，就调用<code>lockSupport.park</code>方法使他进入等待状态；当有<code>signal</code>或者有中断发生的时候，就跳出循环，继续执行，此时如果是<code>signal</code>触发的，就会进入下一个<code>if</code>,那就调用<code>acquireQueue</code>方法，这个方法在我们之前说的<code>AQS</code>中是提及的，主要思想是如果这个节点的前驱节点是<code>head</code>那么就自旋获取锁，否则可能会阻塞。这里已经从大体上说明了这个方法的整体思路，下面继续详细分析分析。</p><p>在这段代码中，我们将知道：</p><ul><li>是怎样将当前线程添加到等待队列中去的？</li><li>释放锁的过程？</li><li>怎样才能从<code>await</code>方法退出？</li></ul><p>第一个问题：是怎样将当前线程添加到等待队列中去的？</p><p><img src="http://bloghello.oursnail.cn/thread16-8.jpg" alt="image"></p><p>这段代码就很容易理解了，将当前节点包装成<code>Node</code>，如果等待队列的<code>firstWaiter</code>为<code>null</code>的话（等待队列为空队列），则将<code>firstWaiter</code>指向当前的<code>Node</code>,否则，更新<code>lastWaiter</code>(尾节点)即可。就是通过尾插入的方式将当前线程封装的<code>Node</code>插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前我们学习<code>AQS</code>时知道同步队列是一个带头结点的链式队列，这是两者的一个区别。将当前节点插入到等待队列之后，会使当前线程释放<code>lock</code>，由<code>fullyRelease</code>方法实现，<code>fullyRelease</code>源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-9.jpg" alt="image"></p><p>调用<code>AQS</code>的模板方法<code>release</code>方法释放<code>AQS</code>的同步状态(这样也说明了退出<code>await</code>方法必须是已经获得了<code>condition</code>引用（关联）的<code>lock</code>)并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题，怎样从<code>await</code>方法退出？现在回过头再来看<code>await</code>方法有这样一段逻辑：</p><p><img src="http://bloghello.oursnail.cn/thread16-10.jpg" alt="image"></p><p>很显然，当线程第一次调用<code>condition.await()</code>方法时，会进入到这个<code>while()</code>循环中，因为判断的条件是这个线程是否在同步队列中，我们这个刚进等待队列，咋可能在同步队列。</p><p>然后通过<code>LockSupport.park(this)</code>方法使得当前线程进入等待状态，那么要想退出这个<code>await</code>方法第一个前提条件自然而然的是要先退出这个<code>while</code>循环，出口就只剩下两个地方：</p><ol><li>逻辑走到<code>break</code>退出<code>while</code>循环；</li><li><code>while</code>循环中的逻辑判断为<code>false</code>。</li></ol><p>再看代码出现第1种情况的条件是当前等待的线程被中断后代码会走到<code>break</code>退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的<code>condition</code>的<code>signal</code>或者<code>signalAll</code>方法），<code>while</code>中逻辑判断为<code>false</code>后结束<code>while</code>循环。</p><p>总结下，就是当前线程被中断或者调用<code>condition.signal</code>/<code>condition.signalAll</code>方法当前节点移动到了同步队列后 ，这是当前线程退出<code>await</code>方法的前提条件。</p><p>当退出<code>while</code>循环后就会调用<code>acquireQueued(node, savedState)</code>，这个方法在介绍AQS的底层实现时说过了，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到<code>lock</code>）。</p><p><code>await</code>方法示意图如下图：</p><p><img src="http://bloghello.oursnail.cn/thread16-11.jpg" alt="image"></p><p>如图，调用<code>condition.await</code>方法的线程必须是已经获得了<code>lock</code>，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的<code>Node</code>尾插入到等待队列中。</p><p>此外，<code>await</code>也支持超时等待和不响应中断，这里不再赘述。</p><h2>六、signal/signalAll实现原理</h2><p>调用<code>condition</code>的<code>signal</code>或者<code>signalAll</code>方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得<code>lock</code>。按照等待队列是先进先出（<code>FIFO</code>）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用<code>condition</code>的<code>signal</code>方法是将头节点移动到同步队列中。</p><p><img src="http://bloghello.oursnail.cn/thread16-12.jpg" alt="image"></p><p><code>signal</code>方法首先会检测当前线程是否已经获取<code>lock</code>，如果没有获取<code>lock</code>会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的<code>doSignal</code>方法也是基于该节点。下面我们来看看<code>doSignal</code>方法做了些什么事情，<code>doSignal</code>方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-13.jpg" alt="image"></p><p>具体逻辑请看注释，真正对头节点做处理的逻辑在<code>transferForSignal</code>中，该方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-14.jpg" alt="image"></p><p>关键逻辑请看注释，这段代码主要做了两件事情1.将头结点的状态更改为<code>CONDITION</code>；2.调用<code>enq</code>方法，将该节点尾插入到同步队列中，关于<code>enq</code>方法请看<code>AQS</code>的底层实现这篇文章。现在我们可以得出结论：调用<code>condition</code>的<code>signal</code>的前提条件是当前线程已经获取了<code>lock</code>，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从<code>await</code>方法中的<code>LockSupport.park(this)</code>方法中返回，从而才有机会使得调用<code>await</code>方法的线程成功退出，此时就要回过头去再看看<code>await</code>方法的后续处理流程了。<code>signal</code>执行示意图如下图：</p><p><img src="http://bloghello.oursnail.cn/thread16-15.jpg" alt="image"></p><p><code>sigllAll</code>与<code>sigal</code>方法的区别体现在<code>doSignalAll</code>方法上，前面我们已经知道<code>doSignal</code>方法只会对等待队列的头节点进行操作，而<code>doSignalAll</code>只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用<code>condition.await()</code>方法的每一个线程。</p><p>整理自：<a href="https://juejin.im/post/5aeea5e951882506a36c67f0" target="_blank" rel="noopener">详解Condition的await和signal等待/通知机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;线程间通信方式总结&lt;/a&gt;中有一个需求：轮流打印奇数和偶数，我们用wait和notify实现了一下，但是这种方式存在弊端，就是不能精确控制唤醒哪个线程，比如现在有一个需求是轮流打印ABC该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>实现生产者消费者模式</title>
    <link href="http://yoursite.com/2019/02/13/thread/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/02/13/thread/实现生产者消费者模式/</id>
    <published>2019-02-13T05:39:59.104Z</published>
    <updated>2019-02-13T09:12:03.707Z</updated>
    
    <content type="html"><![CDATA[<p>无论是面试还是工作中，生产者和消费者模式一直是一个比较常见的问题，今天，我们用各种方式来实现它。</p><a id="more"></a><h2>前言</h2><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p><p><img src="http://bloghello.oursnail.cn/thread11-1.jpg" alt="image"></p><h2>一、wait/notify/notifyAll实现</h2><p>有一个天猫小店专门负责生产商品，用户也可以去买商品：</p><p><img src="http://bloghello.oursnail.cn/thread15-1.jpg" alt="image"></p><p>一个生产者的线程：</p><p><img src="http://bloghello.oursnail.cn/thread15-2.jpg" alt="image"></p><p>同理，一个消费者的线程：</p><p><img src="http://bloghello.oursnail.cn/thread15-3.jpg" alt="image"></p><p>下面进行测试：</p><p><img src="http://bloghello.oursnail.cn/thread15-4.jpg" alt="image"></p><p>此时的结果为：</p><p><img src="http://bloghello.oursnail.cn/thread15-5.jpg" alt="image"></p><p>由于生产大于消费，造成产能过剩。</p><h2>二、阻塞队列实现</h2><p>这个的实现已经在<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/" target="_blank" rel="noopener">JUC组件拓展-BlockingQueue</a>中实现了。不再赘述。主要就是用到阻塞的<code>put()</code>和<code>take()</code>两个方法。</p><h2>三、condition+Lock实现</h2><p>这个也很简单，就是基于<code>wait</code>和<code>notify</code>的代码稍微改一下即可。</p><p><img src="http://bloghello.oursnail.cn/thread15-7.jpg" alt="image"></p><p>生产者改为：</p><p><img src="http://bloghello.oursnail.cn/thread15-8.jpg" alt="image"></p><p>消费者跟生产者一样的改法：</p><p><img src="http://bloghello.oursnail.cn/thread15-9.jpg" alt="image"></p><p>执行效果类似。关于<code>Condition</code>接口，在<a href="">Condition详解</a>这篇文章中进行了详细介绍。</p><p>其实还有一些其他的方式也可以实现生产者消费者模型，但是我觉得最核心的就是上面讲的三种，掌握这个就不慌了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是面试还是工作中，生产者和消费者模式一直是一个比较常见的问题，今天，我们用各种方式来实现它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信方式总结</title>
    <link href="http://yoursite.com/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/13/thread/线程间通信方式总结/</id>
    <published>2019-02-13T04:02:00.062Z</published>
    <updated>2019-02-13T09:12:31.105Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中已经介绍了wait和notify的基本知识，我们知道了他们都是Object这个基类中的方法，因此每个对象都天生拥有这两个方法，可见其重要性，在多线程的学习中，他们两兄弟可以实现线程之间的通信，当然了，还有许多其他的方式实现线程间通信，下面逐一击破。</p><a id="more"></a><h2>一、前言</h2><p>开发中不免会遇到需要所有子线程执行完毕通知主线程处理某些逻辑的场景。或者是线程 A 在执行到某个条件通知线程 B 执行某个操作。</p><h2>二、等待通知机制</h2><p>即用<code>wait</code>+<code>notify</code>来实现。</p><p>案例目标：两个线程交替打印奇偶数，一共100个。注意，这也是阿里的一道面试编程题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoThreadWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwoThreadWaitNotify twoThreadWaitNotify = <span class="keyword">new</span> TwoThreadWaitNotify();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintOdd(twoThreadWaitNotify)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintEven(twoThreadWaitNotify)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印奇数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOdd</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify twoThreadWaitNotify;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintOdd</span><span class="params">(TwoThreadWaitNotify twoThreadWaitNotify)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.twoThreadWaitNotify = twoThreadWaitNotify;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(twoThreadWaitNotify.count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!twoThreadWaitNotify.flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"奇数线程开始执行，打印："</span>+twoThreadWaitNotify.count);</span><br><span class="line">                        twoThreadWaitNotify.count++;</span><br><span class="line">                        twoThreadWaitNotify.flag = <span class="keyword">true</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印偶数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintEven</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify twoThreadWaitNotify;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintEven</span><span class="params">(TwoThreadWaitNotify twoThreadWaitNotify)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.twoThreadWaitNotify = twoThreadWaitNotify;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(twoThreadWaitNotify.count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(twoThreadWaitNotify.flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"偶数线程开始执行，打印："</span>+twoThreadWaitNotify.count);</span><br><span class="line">                        twoThreadWaitNotify.count++;</span><br><span class="line">                        twoThreadWaitNotify.flag = <span class="keyword">false</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果部分截图：</p><p><img src="http://bloghello.oursnail.cn/thread10-2.jpg" alt="image"></p><p>这里的线程 <code>A</code> 和线程 <code>B</code> 都对同一个对象 <code>TwoThreadWaitNotify.class</code> 获取锁，<code>A</code> 线程调用了同步对象的 <code>wait()</code> 方法释放了锁并进入 <code>WAITING</code> 状态。</p><p><code>B</code> 线程调用了 <code>notify()</code> 方法，这样 <code>A</code> 线程收到通知之后就可以从 <code>wait()</code> 方法中返回。</p><p>这里利用了 <code>TwoThreadWaitNotify.class</code> 对象完成了通信。</p><p>有一些需要注意:</p><ul><li><code>wait()</code> 、<code>notify()</code>、<code>notifyAll()</code> 调用的前提都是获得了对象的锁(也可称为对象监视器)。</li><li>调用 <code>wait()</code> 方法后线程会释放锁，进入<code>WAITING</code> 状态，该线程也会被移动到等待队列中。</li><li>调用 <code>notify()</code> 方法会将等待队列中的线程移动到同步队列中，线程状态也会更新为 <code>BLOCKED</code></li><li>从 <code>wait()</code> 方法返回的前提是调用 <code>notify()</code> 方法的线程释放锁，<code>wait()</code> 方法的线程获得锁。</li></ul><p><strong>⭐等待通知有着一个经典范式：</strong></p><p>线程 A 作为消费者：</p><ol><li>获取对象的锁。<br>2.进入 while(判断条件)，并调用 wait() 方法。</li><li>当条件满足跳出循环执行具体处理逻辑。</li></ol><p>线程 B 作为生产者:</p><ol><li>获取对象锁。</li><li>更改与线程 A 共用的判断条件。</li><li>调用 notify() 方法。</li></ol><p>伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Thread A</span><br><span class="line"></span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    while(条件)&#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Thread B</span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    条件=false;//改变条件</span><br><span class="line">    Object.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、Join方式</h2><p><img src="http://bloghello.oursnail.cn/thread14-1.jpg" alt="image"></p><p>这个之前也是提及过的，主要是可以打断主线程让子线程先执行完，但是缺点是粒度不够细腻，我不能控制子线程在某个点停一下让其他子线程执行。</p><p><img src="http://bloghello.oursnail.cn/thread14-2.jpg" alt="image"></p><p>核心逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>join</code> 线程完成后会调用 <code>notifyAll()</code> 方法，是在 <code>JVM</code> 实现中调用，所以这里看不出来。</p><h2>四、volatile 共享内存</h2><p>因为 Java 是采用共享内存的方式进行线程通信的，所以可以采用以下方式用主线程关闭 A 线程:</p><p><img src="http://bloghello.oursnail.cn/thread14-3.jpg" alt="image"></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A执行完毕</span><br></pre></td></tr></table></figure><p>这里的 <code>flag</code> 存放于主内存中，所以主线程和线程 <code>A</code> 都可以看到。<code>flag</code> 采用 <code>volatile</code> 修饰主要是为了内存可见性。</p><h2>五、CountDownLatch 并发工具</h2><p>在前面的<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">文章</a>中我们基本知道它的使用，但是很遗憾，没有找一个比较实际的场景来描述它的功能，下面我将以一个实际场景来用<code>CountDownLatch</code>来解决这个问题。</p><p>假设小明和小红是一对夫妻，他们两准备烧一个菜，就叫做青椒炒肉丝。我们知道，要想炒出青椒炒肉丝，需要切好青椒，然后切好肉丝，如果想要肉的质感爽嫩，需要用淀粉揉一揉，加点醋，加点料酒去去腥，并且弄好了之后需要先炒一下肉。最后两样都准备好之后：即切好的青椒和预热好的肉丝，那么就可以合在一起炒一下出锅了。</p><p>假设切青椒需要3分钟，准备好肉需要5分钟，这两个同时准备好之后就可以进行烧菜了。如何最大程度上提高效率呢？</p><p>显然，就是小明切青椒，小红搞肉丝，两个人并行。这个时候，我们可以用<code>CountDownLatch</code>来模拟这个场景。</p><p>切青椒线程：</p><p><img src="http://bloghello.oursnail.cn/thread14-4.jpg" alt="image"></p><p>准备肉丝的线程：</p><p><img src="http://bloghello.oursnail.cn/thread14-5.jpg" alt="image"></p><p>测试：</p><p><img src="http://bloghello.oursnail.cn/thread14-6.jpg" alt="image"></p><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小明开始切青椒...</span><br><span class="line">小红开始准备肉丝...</span><br><span class="line">小明切好青椒了...</span><br><span class="line">小红准备好肉丝了...</span><br><span class="line">over，食材全部准备好了，一起下锅 cost:5010</span><br></pre></td></tr></table></figure><p>这里突出的就是，主线程等待两个线程都执行完了才能继续执行。</p><p><code>CountDownLatch</code> 也是基于 <code>AQS</code>(<code>AbstractQueuedSynchronizer</code>) 实现的.</p><ul><li>初始化一个 <code>CountDownLatch</code> 时告诉并发的线程，然后在每个线程处理完毕之后调用 <code>countDown()</code> 方法。</li><li>该方法会将 <code>AQS</code> 内置的一个 <code>state</code> 状态 -1 。</li><li>最终在主线程调用 <code>await()</code> 方法，它会阻塞直到 <code>state == 0</code> 的时候返回。</li></ul><p>这个功能是不是很类似于上面的<code>join</code>，但是它比<code>join</code>灵活多了。</p><h2>六、CyclicBarrier 并发工具</h2><p>这个工具类从原理上来看与<code>CountDownLatch</code>非常类似，具体的使用可以看<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">AQS实现的一些同步组件介绍</a>。他们两是有区别的。该工具可以实现 <code>CountDownLatch</code> 同样的功能，但是要更加灵活。甚至可以调用 <code>reset()</code> 方法重置 <code>CyclicBarrier</code> (需要自行捕获 <code>BrokenBarrierException</code> 处理) 然后重新执行。就不再赘述了。</p><h2>七、线程响应中断</h2><p>这个我们之前也是提过的，就是<code>interrupt</code>来实现，线程方法里面用<code>while</code>不停地判断中断标志位从而达到自主中断的目的。</p><p><img src="http://bloghello.oursnail.cn/thread14-7.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread A运行中。。</span><br><span class="line">thread A运行中。。</span><br><span class="line">thread A退出。。</span><br></pre></td></tr></table></figure><p>可以采用中断线程的方式来通信，调用了 <code>thread.interrupt()</code> 方法其实就是将 <code>thread</code> 中的一个标志属性置为了 <code>true</code>。</p><p>并不是说调用了该方法就可以中断线程，如果不对这个标志进行响应其实是没有什么作用(这里对这个标志进行了判断)。</p><p>但是如果抛出了 <code>InterruptedException</code> 异常，该标志就会被 <code>JVM</code> 重置为 <code>false</code>。</p><h2>八、线程池 awaitTermination() 方法</h2><p>这个玩意与我们知道<code>shutdown</code>方法组合使用，我们知道，调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p><p>关于<code>awaitTermination()</code>方法，接收<code>timeout</code>和<code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回<code>true</code>，否则返回<code>false</code>.因此，在<code>shutdwon</code>之后，我们可以用<code>awaitTermination()</code>不断地监测剩下的线程的执行状态，执行完毕就可以执行主线程了。</p><p><img src="http://bloghello.oursnail.cn/thread14-8.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-2] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-1] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 20:18:02.273 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:03.278 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:04.278 [main] INFO  c.c.actual.ThreadCommunication - main over</span><br></pre></td></tr></table></figure><p>最后再强调一下：</p><p>使用这个 <code>awaitTermination()</code> 方法的前提需要关闭线程池，如调用了 <code>shutdown()</code> 方法。</p><p>调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p><h2>九、管道通信</h2><p>这个方式我见到的比较少，了解一下。</p><p><img src="http://bloghello.oursnail.cn/thread14-9.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2018-03-16 19:56:43.014 [Thread-0] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 19:56:43.014 [Thread-1] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 19:56:43.130 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=0</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=1</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=2</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=3</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=4</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=5</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=6</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=7</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=8</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=9</span><br></pre></td></tr></table></figure><p>Java 虽说是基于内存通信的，但也可以使用管道通信。</p><p>需要注意的是，输入流和输出流需要首先建立连接。这样线程 B 就可以收到线程 A 发出的消息了。</p><h2>十、总结</h2><p>实际开发中可以灵活根据需求选择最适合的线程通信方式。</p><p>整理自：<a href="https://crossoverjie.top/JCSprout/#/thread/thread-communication?id=%e7%ba%bf%e7%a8%8b%e6%b1%a0-awaittermination-%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">深入理解线程通信</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的文章中已经介绍了wait和notify的基本知识，我们知道了他们都是Object这个基类中的方法，因此每个对象都天生拥有这两个方法，可见其重要性，在多线程的学习中，他们两兄弟可以实现线程之间的通信，当然了，还有许多其他的方式实现线程间通信，下面逐一击破。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC组件拓展-BlockingQueue</title>
    <link href="http://yoursite.com/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/"/>
    <id>http://yoursite.com/2019/02/12/thread/JUC组件拓展-BlockingQueue/</id>
    <published>2019-02-12T09:37:24.293Z</published>
    <updated>2019-02-12T09:37:32.361Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的线程池原理介绍中，我们了解到在核心线程被全部占用并且没有空闲线程的时候，就会把后续的线程任务先放入一个队列结构中，然后按照队列的方式去消化任务。虽然队列有很多种，但是他们都有一个共同的名字叫做阻塞队列，本文来逐个击破揭开他们的面纱。</p><a id="more"></a><h2>一、BlockingQueue</h2><p>在Java中，<code>BlockingQueue</code>是一个接口，它的实现类有<code>ArrayBlockingQueue</code>、<code>DelayQueue</code>、 <code>LinkedBlockingDeque</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>、<code>SynchronousQueue</code>等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于<code>take</code>与<code>put</code>操作的原理，却是类似的。</p><p><img src="http://bloghello.oursnail.cn/BlockingQueue%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" alt="image"></p><p><code>BlockingQueue</code> 是一个先进先出的队列（<code>Queue</code>），为什么说是阻塞（<code>Blocking</code>）的呢？是因为 <code>BlockingQueue</code> 支持当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p><img src="http://bloghello.oursnail.cn/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="image"></p><ul><li><code>add(anObject)</code>:把<code>anObject</code>加到<code>BlockingQueue</code>里,即如果<code>BlockingQueue</code>可以容纳,则返回true,否则抛出异常</li><li><code>offer(anObject)</code>:表示如果可能的话,将<code>anObject</code>加到<code>BlockingQueue</code>里,即如果<code>BlockingQueue</code>可以容纳,则返回true,否则返回false.</li><li>⭐<code>put(anObject)</code>:把<code>anObject</code>加到<code>BlockingQueue</code>里,如果<code>BlockQueue</code>没有空间,则调用此方法的线程被阻断直到<code>BlockingQueue</code>里面有空间再继续.</li><li>⭐与<code>put</code>相对应的是<code>take()</code>:取走<code>BlockingQueue</code>里排在首位的对象,若<code>BlockingQueue</code>为空,阻断进入等待状态直到<code>Blocking</code>有新的对象被加入为止</li><li><code>poll(time)</code>:取走<code>BlockingQueue</code>里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null</li></ul><div class="tip">注意：BlockingQueue 不接受 null 元素。试图 add 、 put 或 offer 一个 null  元素时，某些实现会抛出 NullPointerException 。 null 被用作指示 poll  操作失败的警戒值。</div><blockquote><p><code>BlockingQueue</code> 的各个实现都遵循了这些规则，当然我们也不用死记这个表格，知道有这么回事，然后写代码的时候根据自己的需要去看方法的注释来选取合适的方法即可。</p></blockquote><blockquote><p>一个 <code>BlockingQueue</code> 可能是有界的，如果在插入的时候，发现队列满了，那么 <code>put</code> 操作将会阻塞。通常，在这里我们说的无界队列也不是说真正的无界，而是它的容量是 <code>Integer.MAX_VALUE</code>（21亿多）。</p></blockquote><blockquote><p><code>BlockingQueue</code> 实现主要用于生产者-消费者队列，但它另外还支持<code>Collection</code> 接口。因此，举例来说，使用<code>remove(x)</code> 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</p></blockquote><blockquote><p><code>BlockingQueue</code> 的实现都是线程安全的，但是批量的集合操作如 <code>addAll</code>, <code>containsAll</code>, <code>retainAll</code> 和 <code>removeAll</code> 不一定是原子操作。如 <code>addAll(c)</code> 有可能在添加了一些元素后中途抛出异常，此时 <code>BlockingQueue</code> 中已经添加了部分元素，这个是允许的，取决于具体的实现。</p></blockquote><p>下面来看看阻塞队列的各种具体的实现类。</p><h2>二、ArrayBlockingQueue</h2><ul><li>构造函数必须带一个int参数来指明其大小</li><li>一个由数组结构组成的有界阻塞队列.</li><li>此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序.</li><li>⭐其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</li><li>⭐如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。</li><li>⭐如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</li><li>支持公平锁和非公平锁。公平的获取锁，也就是当前等待时间最长的线程先获取锁</li></ul><h2>三、LinkedBlockingQueue</h2><ul><li>大小不定的<code>BlockingQueue</code></li><li>若其构造函数带一个规定大小的参数,生成的<code>BlockingQueue</code>有大小限制</li><li>若不带大小参数,所生成的BlockingQueue的大小由<code>Integer.MAX_VALUE</code>来决定</li><li>其所含的对象是以<code>FIFO</code>(先入先出)顺序排序的</li><li>⭐链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低</li><li>最新插入的数据在尾部，最新移除的对象在头部</li></ul><h2>四、PriorityBlockingQueue</h2><ul><li>⭐类似于<code>LinkedBlockQueue</code>,但其所含对象的排序不是<code>FIFO</code>,而是依据对象的自然排序顺序或者是构造函数的<code>Comparator</code>决定的顺序</li><li>一个无界的阻塞队列</li></ul><h2>五、SynchronousQueue</h2><ul><li>⭐它是一种阻塞队列，其中每个 <code>put</code> 必须等待一个 <code>take</code>，反之亦然。</li><li>⭐同步队列没有任何内部容量，甚至连一个队列的容量都没有。</li><li>它是线程安全的，是阻塞的。</li><li>不允许使用 <code>null</code> 元素。</li><li>公平排序策略是指调用 <code>put</code> 的线程之间，或 <code>take</code> 的线程之间。</li></ul><p>一个没有容量的并发队列有什么用了？或者说存在的意义是什么？</p><p>尽管元素在<code>SynchronousQueue</code> 内部不会“停留”，但是并不意味着<code>SynchronousQueue</code> 内部没有队列。实际上<code>SynchronousQueue</code> 维护着线程队列，也就是插入线程或者移除线程在不同时存在的时候就会有线程队列。既然有队列，同样就有公平性和非公平性特性，公平性保证正在等待的插入线 程或者移除线程以<code>FIFO</code>的顺序传递资源。</p><p>它模拟的功能类似于生活中一手交钱一手交货这种情形，像那种货到付款或者先付款后发货模型不适合使用<code>SynchronousQueue</code>。首先要知道<code>SynchronousQueue</code>没有容纳元素的能力，即它的<code>isEmpty()</code>方法总是返回true，但是给人的感觉却像是只能容纳一个元素。</p><h2>六、DelayQueue</h2><ul><li><code>DelayQueue</code> 对元素进行持有直到一个特定的延迟到期。注意其中的元素必须实现 <code>java.util.concurrent.Delayed</code> 接口。</li></ul><h2>七、生产者与消费者模式</h2><p>阻塞队列的最常使用的例子就是生产者消费者模式,也是各种实现生产者消费者模式方式中首选的方式。使用者不用关心什么阻塞生产，什么时候阻塞消费，使用非常方便。</p><p><code>LinkedBlockingQueue</code>来实现一个生产者与消费者模型：</p><p><img src="http://bloghello.oursnail.cn/thread13-1.png" alt="image"></p><p>运行效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">producer1 produce 95</span><br><span class="line">producer3 produce 36</span><br><span class="line">consumer0 consumer 95</span><br><span class="line">consumer2 consumer 36</span><br><span class="line">producer0 produce 27</span><br><span class="line">consumer4 consumer 27</span><br><span class="line">producer2 produce 75</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2>八、ArrayBlockingQueue和LinkedBlockingQueue的区别</h2><ul><li>队列中锁的实现不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；另外，可以指定是否为公平锁，默认是非公平锁。</p><p><code>LinkedBlockingQueue</code>实现的队列中的锁是分离的，在队头和队尾各持有一把锁，入队和出队之间不存在竞争。即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p></blockquote><ul><li>在生产或消费时操作不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；</p><p><code>LinkedBlockingQueue</code>实现的队列中在生产和消费的时候，需要把枚举对象转换为<code>Node&lt;E&gt;</code>进行插入或移出(会生成一个额外的<code>Node</code>对象，这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。)</p></blockquote><ul><li>队列大小初始化方式不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中必须指定队列的大小；</p><p><code>LinkedBlockingQueue</code>实现的队列中可以不指定队列的大小，但是默认是<code>Integer.MAX_VALUE</code></p></blockquote><ul><li>作为开发者，我们需要注意的是，如果构造一个<code>LinkedBlockingQueue</code>对象，而没有指定其容量大小，<code>LinkedBlockingQueue</code>会默认一个类似无限大小的容量（<code>Integer.MAX_VALUE</code>），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</li><li>在使用<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>分别对1000000个简单字符做入队操作时，<code>LinkedBlockingQueue</code>的消耗是<code>ArrayBlockingQueue</code>消耗的10倍左右，即<code>LinkedBlockingQueue</code>消耗在1500毫秒左右，而<code>ArrayBlockingQueue</code>只需150毫秒左右。</li><li>按照实现原理来分析，<code>ArrayBlockingQueue</code>完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。<code>Doug Lea</code>之所以没这样去做，也许是因为<code>ArrayBlockingQueue</code>的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的线程池原理介绍中，我们了解到在核心线程被全部占用并且没有空闲线程的时候，就会把后续的线程任务先放入一个队列结构中，然后按照队列的方式去消化任务。虽然队列有很多种，但是他们都有一个共同的名字叫做阻塞队列，本文来逐个击破揭开他们的面纱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC组件拓展-ForkJoin简介</title>
    <link href="http://yoursite.com/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-ForkJoin%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/02/12/thread/JUC组件拓展-ForkJoin简介/</id>
    <published>2019-02-12T09:03:06.685Z</published>
    <updated>2019-02-12T09:36:00.427Z</updated>
    
    <content type="html"><![CDATA[<p>JUC组件拓展-ForkJoin简介，本文只是初步认识认识一下ForkJoin是什么，不深究里面的原理。</p><a id="more"></a><h2>ForkJoin</h2><h4>什么是Fork/Join框架</h4><p><code>Fork/Join</code>框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>我们再通过<code>Fork</code>和<code>Join</code>这两个单词来理解下<code>Fork/Join</code>框架，<code>Fork</code>就是把一个大任务切分为若干子任务并行的执行，<code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+。。＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。</p><p><img src="http://bloghello.oursnail.cn/ForkJoin%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="image"></p><h4>工作窃取算法</h4><p>工作窃取（<code>work-stealing</code>）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="http://bloghello.oursnail.cn/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt="image"></p><ul><li>那么为什么需要使用工作窃取算法呢？</li></ul><blockquote><p>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></blockquote><ul><li><code>Fork/Join</code>框架如何实现工作窃取的？</li></ul><blockquote><p>这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p></blockquote><ul><li><code>Fork/Join</code>框架有没有什么缺点？</li></ul><blockquote><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></blockquote><ul><li>该如何设计一个<code>Fork/Join</code>框架?</li></ul><blockquote><p>第一步分割任务。首先我们需要有一个<code>fork</code>类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p><p>第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p></blockquote><p>这里就先简单介绍一下，如果有必要，以后再细谈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JUC组件拓展-ForkJoin简介，本文只是初步认识认识一下ForkJoin是什么，不深究里面的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS实现的一些并发工具类</title>
    <link href="http://yoursite.com/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/12/thread/AQS实现的一些并发工具类/</id>
    <published>2019-02-12T08:52:41.518Z</published>
    <updated>2019-02-15T08:27:44.200Z</updated>
    
    <content type="html"><![CDATA[<p>在前面我们已经深入了解了AQS原理，本节介绍几个常用的基于AQS实现的并发工具类。</p><a id="more"></a><h2>一、CountDownLatch</h2><p>计数器减到0，处于等待的线程才会继续执行。只能用一次，不能重置。</p><p>比如有一个运算量很大的任务，我们可以将它拆分为多个子任务，等所有子任务全部完成之后，再执行最后的汇总工作。</p><p><img src="http://bloghello.oursnail.cn/CountDownLatch.png" alt="image"></p><p>下面用一个实例来看看它是如何使用的：</p><p><img src="http://bloghello.oursnail.cn/thread12-1.jpg" alt="image"></p><p>运行结果，截取了最后一点：</p><p><img src="http://bloghello.oursnail.cn/thread12-2.jpg" alt="image"></p><p>我们可以看到，主程序等待所有的子程序执行完毕，再执行，它是通过<code>await()</code>阻塞等待，直到计数器的值减到0为止。</p><p>那如果是这种场景呢：计算若干个子任务，给定一个时间，超过这个时间的话，就把这个任务放弃掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h2>二、Semaphore</h2><p>能控制同一时间并发线程的数目</p><blockquote><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。很多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-14/16690827.jpg" alt="image"></p><p><code>Semaphore</code>可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用<code>Semaphore</code>来做流控，代码如下：</p><p><img src="http://bloghello.oursnail.cn/thread12-3.jpg" alt="image"></p><p>再来一个例子：</p><p><img src="http://bloghello.oursnail.cn/thread12-4.jpg" alt="image"></p><blockquote><p>这里是一个线程获取一个许可，那么同一时间，可以有三个线程进来一起工作。那如果我改成一个线程获取三个许可呢？就像一个人同时占三个坑位，那么只有等这个人拉完了才能轮到下一个人了，那么此时就变成跟单线程一样了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">3</span>);</span><br><span class="line">test(threadNum);</span><br><span class="line">semaphore.release(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>考虑这个场景：并发太高了，就算是控制线程数量，也比较棘手；一个厕所三个坑位，外面人太多了，让三个人进来，其他的都给轰走。如何做到呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(semaphore.tryAcquire())&#123;<span class="comment">//尝试获取一个许可</span></span><br><span class="line">    test(threadNum);</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：只有三条信息打印出来，其他的线程就都被丢弃了。</p><p>也可以给他一个超时时间，这里是5000毫秒。每个命令需要运行1000毫秒，那么程序等1000毫秒之后会打印三条；然后再等1000毫秒，又可以拿到新的三个许可，再打印三条；直到5000毫秒用完。可能会打印3*5条记录。剩下的5条记录由于已经超时，全部被放弃掉。</p><h2>三、CyclicBarrier</h2><blockquote><p><code>CyclicBarrier</code>也是一个同步辅助类 , 它允许一组线程相互等待 , 直到到达某个公共的屏障点 , 通过它可以完成多个线程之间相互等待 ,只有当每个线程都准备好之后, 才能各自继续往下执行后续的操作, 和 <code>CountDownLatch</code>相似的地方就是, 它也是通过计数器来实现的. 当某个线程调用了 <code>await()</code>方法之后, 该线程就进入了等待状态 . 而且计数器就进行 -1 操作 , 当计数器的值达到了我们设置的初始值0的时候 , 之前调用了<code>await()</code> 方法而进入等待状态的线程会被唤醒继续执行后续的操作. 因为 <code>CyclicBarrier</code>释放线程之后可以重用, 所以又称之为循环屏障 . <code>CyclicBarrier</code> 使用场景和  <code>CountDownLatch</code> 很相似 , 可以用于多线程计算数据, 最后合并计算结果的应用场景 .</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-14/65784628.jpg" alt="image"></p><p>两者的区别：</p><ul><li><p><code>CountDownLatch</code>的计数器只能使用一次 , 而 <code>CyclicBarrier</code> 的计数器可以使用 <code>reset</code>重置 循环使用</p></li><li><p><code>CountDownLatch</code> 主要是 1 个 或者 n 个线程需要等待其它线程完成某项操作之后才能继续往下执行 , 其描述的是 1 个 或者 n 个线程与其它线程的关系 ; CyclicBarrier 主要是实现了 1 个或者多个线程之间相互等待,直到所有的线程都满足条件之后, 才执行后续的操作 , 其描述的是内部各个线程相互等待的关系 .</p></li></ul><p><code>CyclicBarrier</code> 假如有 5 个线程都调用了 <code>await()</code> 方法 , 那这个 5 个线程就等着 , 当这 5 个线程都准备好之后, 它们有各自往下继续执行 , 如果这 5 个线程在后续有一个计算发生错误了 , 这里可以重置计数器 , 并让这 5 个线程再执行一遍 .</p><p><img src="http://bloghello.oursnail.cn/thread12-5.jpg" alt="image"></p><p>运行效果：先每隔一秒执行<code>race</code>方法打印出<code>ready</code>,等3个线程打印完毕，立即都将阻塞的<code>log.info(&quot;continue...&quot;);</code>全部打印出来。</p><p><img src="http://bloghello.oursnail.cn/thread12-6.jpg" alt="image"></p><p>也可以设定超时时间，超过时间了就不等了。</p><p><img src="http://bloghello.oursnail.cn/thread12-7.jpg" alt="image"></p><p>如果在大家已经都准备好了的时候，可以先做一件事情，即初始化执行一个线程，可以在声明<code>CyclicBarrier</code>后面增加一个线程来执行。</p><p>就像开会，人都到齐了之后，我们喊一声，人都到齐，我们现在开始开会了啊。下面就开始正式开会。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>,() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"callback is running..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2>四、Exchanger</h2><p><code>Exchanger</code> 类表示一种会合点，两个线程可以在这里交换对象。两个线程各自调用<code>exchange</code> 方法进行交换，当线程 <code>A</code> 调用 <code>Exchange</code> 对象的 <code>exchange</code> 方法后，它会陷入阻塞状态，直到线程 <code>B</code> 也调用了 <code>exchange</code> 方法，然后以线程安全的方式交换数据，之后线程 <code>A</code> 和 <code>B</code> 继续运行。</p><p><img src="http://bloghello.oursnail.cn/thread12-8.png" alt="image"></p><p><code>exchange</code> 方法有两个重载实现，在交换数据的时候还可以设置超时时间。如果一个线程在超时时间内没有其他线程与之交换数据，就会抛出 <code>TimeoutException</code> 超时异常。如果没有设置超时时间，则会一直等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换数据，并设置超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br><span class="line"><span class="function"><span class="comment">//交换数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>下面看一个小例子：</p><p><img src="http://bloghello.oursnail.cn/thread12-9.png" alt="image"></p><p>我们要注意，交换的时候两个线程要同时到达一个汇合点才会继续执行，即这里的a线程拿到b线程的值并且b拿到a的值，程序才会继续执行。</p><p><img src="http://bloghello.oursnail.cn/thread12-10.png" alt="image"></p><p>例子很简单，当两个线程都到达调用<code>exchange</code>方法的同步点的时候，两个线程就能交换彼此的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面我们已经深入了解了AQS原理，本节介绍几个常用的基于AQS实现的并发工具类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程池原理详解</title>
    <link href="http://yoursite.com/2019/02/12/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/12/thread/线程池原理详解/</id>
    <published>2019-02-12T07:36:14.209Z</published>
    <updated>2019-02-13T03:52:57.801Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA帮助开发者封装了一些现成的线程池调用，但是每种线程池都有自己的使用场景，如果不了解里面的原理，那么很容易掉进坑里，线程池原理也是面试的重灾区，因此本问将完整分析线程池的原理。</p><a id="more"></a><h2>一、new thread弊端</h2><p>从学习java多线程开始，我们就学习了用<code>new thread</code>来创建线程。但是他有一定的弊端：</p><ul><li>每次<code>new Thread</code>新建对象，性能差</li><li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM</li><li>缺少更多功能，如更多执行、定期执行、线程中断</li></ul><h2>二、线程池好处</h2><ul><li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li><li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li><li>提供定时执行、定期执行、单线程、并发数控制等功能</li></ul><h2>三、线程池相关参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>:核心线程数量</li></ul><blockquote><p>默认情况下，在创建了线程池后，线程池中的线程数为0，<br>（除非调用<code>prestartAllCoreThreads()</code>和<code>prestartCoreThread()</code>方法，从方法名字可以看出，是预创建线程的意思，即在没有任务到来之前，就创建<code>corePoolSize</code>个线程或1个线程）当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中；</p><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p></blockquote><ul><li><code>maximumPoolSize</code>:线程最大线程数</li></ul><blockquote><p>线程池中的最大线程数，表示线程池中最多能创建多少个线程。</p><p>超过就执行<code>reject</code>策略:如果队列满了,并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务</p></blockquote><ul><li><code>workQueue</code>:阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响，一般有以下几种选择：</li></ul><blockquote><p><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序；</p><p><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于<code>ArrayBlockingQueue</code>。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列；</p><p><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列；</p><p><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列；底层用<code>DelayedWorkQueue</code>实现。</p></blockquote><ul><li><code>keepAliveTime</code>：线程没有任务执行时最多保持多久时间终止</li></ul><blockquote><p>当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。（但是如果调用了<code>allowCoreThreadTimeOut(boolean value)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0；）</p></blockquote><ul><li><code>unit</code>:<code>keepAliveTime</code>的时间单位</li><li><code>threadFactory</code>：线程工厂，用来创建线程</li></ul><blockquote><p><code>threadFactory</code>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</p></blockquote><ul><li><code>handler</code>:饱和策略</li></ul><blockquote><p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。</p></blockquote><p>这些参数全部传给<code>ThreadPoolExecutor</code>之后，<code>ThreadPoolExecutor</code>就可以为我们提供一个线程池，我们可以对这个线程池提交以及终止线程任务。</p><h2>四、饱和策略</h2><p>当线程池中已经到了完全没有办法再接收新的线程进来的时候，就会启动饱和策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</span><br></pre></td></tr></table></figure><ol><li><code>AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常（默认）</li><li><code>CallerRunsPolicy</code>：只用调用所在的线程运行任务</li><li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li><code>DiscardPolicy</code>：不处理，丢弃掉,不抛出异常。</li></ol><h2>五、线程池的源码解读</h2><p>程序中要声明线程池，是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">exec.excute(Runnable command);</span><br></pre></td></tr></table></figure><p>先来看看<code>ExecutorService</code>其中的奥秘。</p><h5>5.1 ExecutorService和Executor的关系</h5><p><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为<code>void</code>，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>ExecutorService</code>具备管理执行器和任务生命周期的方法，提交任务机制更加完善。<code>Executor</code>只是运行新任务的简单接口，目的是将任务提交和任务执行解耦。</p><h5>5.2 ThreadPoolExecutor重要方法</h5><p>我们知道，在执行<code>Executors.newCachedThreadPool()</code>的时候，内部是调用<code>ThreadPoolExecutor</code>的构造函数来生成<code>Exceutors</code>对象，即生成了线程池，因为继承关系是：<code>ThreadPoolExecutor extends AbstractExecutorService implements ExecutorService extends Executor</code>。构建好之后，就可以构建工作线程去执行任务。其中，流程是这样的：</p><p><img src="http://bloghello.oursnail.cn/thread11-2.jpg" alt="image"></p><p>所以，用于<code>execute()</code>或者<code>submit()</code>的线程任务都是被封装成<code>worker</code>去执行的。下面来看看<code>execute()</code>和<code>submit()</code>等核心方法。</p><p>在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p><ul><li><code>execute()</code></li></ul><blockquote><p><code>execute()</code>方法实际上是<code>Executor</code>中声明的方法，在<code>ThreadPoolExecutor</code>进行了具体的实现，这个方法是<code>ThreadPoolExecutor</code>的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p></blockquote><ul><li><code>submit()</code></li></ul><blockquote><p><code>submit()</code>方法是在<code>ExecutorService</code>中声明的方法,这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code>方法不同，它能够返回任务执行的结果，去看<code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了<code>Future</code>来获取任务执行结果。</p></blockquote><ul><li><code>shutdown()</code><br>将线程池状态置为<code>SHUTDOWN</code>,并不会立即停止：</li></ul><blockquote><p>停止接收外部<code>submit</code>的任务内部正在跑的任务和队列里等待的任务，会执行完等到第二步完成后，才真正停止</p></blockquote><ul><li><code>shutdownNow()</code><br>将线程池状态置为<code>STOP</code>。企图立即停止，事实上不一定：</li></ul><blockquote><p>跟<code>shutdown()</code>一样，先停止接收外部提交的任务忽略队列里等待的任务尝试将正在跑的任务<code>interrupt</code>中断返回未执行的任务列表</p><p>它试图终止线程的方法是通过调用<code>Thread.interrupt()</code>方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有<code>sleep</code> 、<code>wait</code>、<code>Condition</code>、定时锁等应用, <code>interrupt()</code>方法是无法中断当前的线程的。所以，<code>ShutdownNow()</code>并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。但是大多数时候是能立即退出的</p></blockquote><ul><li><code>awaitTermination(long timeOut, TimeUnit unit)</code></li></ul><blockquote><p>接收<code>timeout</code>和<code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回<code>true</code>，否则返回<code>false</code>。一般情况下会和<code>shutdown</code>方法组合使用。</p></blockquote><h5>5.3 Executors生成线程池</h5><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>Executors</code>类里面提供了一些静态工厂，生成一些常用的线程池。这个就涉及上面我们反复提及的核心类：<code>ThreadPoolExecutor</code>。</p><p>⭐其实都是通过调用<code>ThreadPoolExecutor</code>来完成的，最后可以返回<code>ExecutorService</code>对象，其实说白了都是<code>Excutor</code>对象。</p><p>下面来分别看看比较常用的线程池。</p><ul><li><code>newSingleThreadExecutor</code></li></ul><blockquote><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为1的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="comment">//线程由DefaultThreadFactory默认创建，有统一的命名规范，并且优先级是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                               threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:10,index:1</span><br><span class="line">task:10,index:2</span><br><span class="line">task:10,index:3</span><br><span class="line">task:10,index:4</span><br><span class="line">task:10,index:5</span><br><span class="line">task:10,index:6</span><br><span class="line">task:10,index:7</span><br><span class="line">task:10,index:8</span><br><span class="line">task:10,index:9</span><br></pre></td></tr></table></figure><p>运行结果分析：单线程+有序。</p><ul><li><code>newFixedThreadPool</code></li></ul><blockquote><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为nThreads的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:11,index:1</span><br><span class="line">task:11,index:3</span><br><span class="line">task:11,index:4</span><br><span class="line">task:11,index:5</span><br><span class="line">task:11,index:6</span><br><span class="line">task:11,index:7</span><br><span class="line">task:11,index:8</span><br><span class="line">task:11,index:9</span><br><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br></pre></td></tr></table></figure><p>结果分析：只创建了三个线程来执行。</p><ul><li><code>newCachedThreadPool</code></li></ul><blockquote><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个按需创建线程的线程池，初始线程个数为0，最多线程个数为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为同步队列</span></span><br><span class="line"><span class="comment">//keeyAliveTime=60说明只要当前线程60s内空闲则回收</span></span><br><span class="line"><span class="comment">//特殊在于加入到同步队列的任务会被马上被执行，同步队列里面最多只有一个任务，并且存在后马上会拿出执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br><span class="line">task:14,index:4</span><br><span class="line">task:16,index:6</span><br><span class="line">task:18,index:8</span><br><span class="line">task:11,index:1</span><br><span class="line">task:13,index:3</span><br><span class="line">task:15,index:5</span><br><span class="line">task:17,index:7</span><br><span class="line">task:19,index:9</span><br></pre></td></tr></table></figure><p>结果分析：按需创建线程，几乎一次循环就创建了一个新的线程来执行。</p><ul><li><code>newScheduledThreadPool</code></li></ul><blockquote><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多长时间之后执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时执行，这里是每隔3秒执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);<span class="comment">//一开始延迟1秒执行任务，之后每隔3秒执行一次任务，不适合调用exec.shutdown();，因为会被关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>newSingleThreadScheduledExecutor</code></li></ul><blockquote><p>创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize为1，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上。demo不再赘述。</p><h5>5.4  线程池实现原理–线程池状态</h5><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt="image"></p><ul><li><code>static final int RUNNING = 0;</code></li></ul><blockquote><p>当创建线程池后，初始时，线程池处于RUNNING状态；</p></blockquote><ul><li><code>static final int SHUTDOWN = 1;</code></li></ul><blockquote><p>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p></blockquote><ul><li><code>static final int STOP = 2;</code></li></ul><blockquote><p>如果调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p></blockquote><ul><li><code>static final int TERMINATED = 3;</code></li></ul><blockquote><p>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</p></blockquote><h5>6.5 线程池实现原理–任务的执行</h5><p><code>corePoolSize</code>与<code>maximumPoolSize</code>的关系举个简单的例子形象理解就是：</p><blockquote><p>假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p><p>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p><p>然后就将任务也分配给这4个临时工人做；</p><p>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p></blockquote><p>这个例子中的<code>corePoolSize</code>就是10，而<code>maximumPoolSize</code>就是14（10+4）。</p><p><code>maximumPoolSize</code>可以看作是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>在<code>ThreadPoolExecutor</code>类中，最核心的任务提交方法是<code>execute()</code>方法，虽然通过<code>submit</code>也可以提交任务，但是实际上<code>submit</code>方法里面最终调用的还是<code>execute()</code>方法，所以我们只需要研究<code>execute()</code>方法的实现原理即可：</p><p>注：<code>execute()</code>方法和<code>submit()</code>方法已经在前面讲过区别了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">     <span class="comment">// Proceed in 3 steps:</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 1. </span></span><br><span class="line">     <span class="comment">// 判断当前的线程数是否小于corePoolSize,如果是，使用入参任务通过addWord方法创建一个新的线程，</span></span><br><span class="line">     <span class="comment">// 如果能完成新线程创建exexute方法结束，成功提交任务</span></span><br><span class="line">     <span class="comment">// 2. </span></span><br><span class="line">     <span class="comment">// 在第一步没有完成任务提交；状态为运行并且能够成功加入任务到工作队列后，再进行一次check，如果状态</span></span><br><span class="line">     <span class="comment">// 在任务加入队列后变为了非运行（有可能是在执行到这里线程池shutdown了），非运行状态下当然是需要</span></span><br><span class="line">     <span class="comment">// reject；然后再判断当前线程数是否为0（有可能这个时候线程数变为了0），如是，新增一个线程；</span></span><br><span class="line">     <span class="comment">// 3. </span></span><br><span class="line">     <span class="comment">// 如果不能加入任务到工作队列，将尝试使用任务新增一个线程，如果失败，则是线程池已经shutdown或者线程池</span></span><br><span class="line">     <span class="comment">// 已经达到饱和状态，所以reject这个任务</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果工作线程数大于等于核心线程数</span></span><br><span class="line">    <span class="comment">// 线程的的状态为RUNNING并且队列notfull</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查线程的运行状态，如果不是RUNNING直接从队列中移除</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 移除成功，拒绝该非运行的任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">            <span class="comment">// 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列满了或者是非运行的任务都拒绝执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的程序流程图为：</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B111.png" alt="image"></p><p>为了理解更加得透彻，用下图配合文字总结一下：</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86111.png" alt="image"></p><ul><li>1.如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>2.如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>3.如果无法将任务加入<code>BlockingQueue</code>（队列已满），则在非<code>corePool</code>中创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li><li>4.如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ul><blockquote><p><code>ThreadPoolExecutor</code>采取上述步骤的总体设计思路，是为了在执行<code>execute()</code>方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JAVA帮助开发者封装了一些现成的线程池调用，但是每种线程池都有自己的使用场景，如果不了解里面的原理，那么很容易掉进坑里，线程池原理也是面试的重灾区，因此本问将完整分析线程池的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从CAS到Atomic包原理</title>
    <link href="http://yoursite.com/2019/02/12/thread/%E4%BB%8ECAS%E5%88%B0Atomic%E5%8C%85%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/12/thread/从CAS到Atomic包原理/</id>
    <published>2019-02-12T03:48:48.284Z</published>
    <updated>2019-02-12T03:54:21.871Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，volatile保证了可见性，但是不能保证原子性，在面对线程安全问题时，就显地力不从心，那么除了synchronized关键字外，还有什么方式可以实现线程安全更新呢？本文首先介绍CAS是什么，引出JUC下一个重要的包：Atomic包。</p><a id="more"></a><h2>一、CAS简介</h2><p><code>CAS</code>（<code>Compare and Swap</code>），即比较并替换，实现并发算法时常用到的一种技术，<code>Doug lea</code>大神在java同步器中大量使用了<code>CAS</code>技术，鬼斧神工的实现了多线程执行的安全性。</p><p><code>CAS</code>的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回<code>true</code>，否则什么都不做，并返回<code>false</code>。</p><h2>二、n++问题</h2><p><img src="http://bloghello.oursnail.cn/thread9-1.jpg" alt="image"></p><p>通过<code>javap -verbose Case</code>看看<code>add</code>方法的字节码指令：</p><p><img src="http://bloghello.oursnail.cn/thread9-2.jpg" alt="image"></p><p>我们可以看到，<code>n++</code>被拆分成了下面几个指令：</p><ul><li>执行<code>getfield</code>拿到原始<code>n</code>；</li><li>执行<code>iadd</code>进行加1操作；</li><li>执行<code>putfield</code>写把累加后的值写回<code>n</code>；</li></ul><p>通过<code>volatile</code>修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果，那么应该如何解决呢？</p><p>这里顺便提一下线程安全三个特性</p><ul><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程观察到。</li><li>有序性：一个线程观察其他线程中的指令的执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ul><p>可以看到原子性是线程安全的一大特性。</p><h2>三、解决方案一</h2><p>在<code>add</code>方法加上<code>synchronized</code>修饰解决。</p><p><img src="http://bloghello.oursnail.cn/thread9-3.jpg" alt="image"></p><p>这个方案当然可行，但是性能上差了点，还有其它方案么？</p><h2>四、解决方案二</h2><p>我们可不可以用一下乐观锁的思想呢？即不加锁，等真正要赋值的时候比较一下。</p><p><img src="http://bloghello.oursnail.cn/thread9-4.jpg" alt="image"></p><p>当然了，这段代码如果真的在并发下执行，肯定出问题，只有把这整个过程变成一个原子操作才行，即同一时刻只有一个线程才能修改变量<code>a</code>。</p><p>如何实现呢？</p><p>我们注意到JUC下有个好东西，以<code>Atomic</code>打头的一些类。就可以很好地帮助我们实现对一个数加一减一的原子性操作。比如我们要安全地对<code>n</code>加一，可以这样做：</p><p><img src="http://bloghello.oursnail.cn/thread9-5.jpg" alt="image"></p><p>下面就以<code>AtomicInteger</code>的实现为例，分析一下<code>CAS</code>是如何实现的。</p><p><img src="http://bloghello.oursnail.cn/thread9-6.jpg" alt="image"></p><ul><li><code>Unsafe</code>，是<code>CAS</code>的核心类，由于Java方法无法直接访问底层系统，需要通过本地（<code>native</code>）方法来访问，<code>Unsafe</code>相当于一个后门，基于该类可以直接操作特定内存的数据。</li><li>变量<code>valueOffset</code>，表示该变量值在内存中的偏移地址，因为<code>Unsafe</code>就是根据内存偏移地址获取数据的。</li><li>变量<code>value</code>用<code>volatile</code>修饰，保证了多线程之间的内存可见性。</li></ul><p>看看<code>AtomicInteger</code>如何实现并发下的累加操作：</p><p><img src="http://bloghello.oursnail.cn/thread9-7.jpg" alt="image"></p><p>假设线程<code>A</code>和线程<code>B</code>同时执行<code>getAndIncrement</code>操作（分别跑在不同CPU上）：</p><ul><li>假设<code>AtomicInteger</code>里面的<code>value</code>原始值为0，即主内存中<code>AtomicInteger</code>的<code>value</code>为0，根据Java内存模型，线程A和线程B各自持有一份<code>value</code>的副本，值为0。</li><li>线程A通过<code>getIntVolatile(var1, var2)</code>拿到<code>value</code>值0，这时线程A被挂起。</li><li>线程B也通过<code>getIntVolatile(var1, var2)</code>方法获取到<code>value</code>值0，运气好，线程B没有被挂起，并执行<code>compareAndSwapInt</code>方法比较内存值也为0，成功修改内存值为1。</li><li>这时线程A恢复，执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值(0)和内存的值(1)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li><li>重新获取<code>value</code>值，因为变量<code>value</code>被<code>volatile</code>修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功。</li></ul><p>整个过程中，利用<code>CAS</code>保证了对于<code>value</code>的修改的并发安全，继续深入看看<code>Unsafe</code>类中的<code>compareAndSwapInt</code>方法实现。</p><p><img src="http://bloghello.oursnail.cn/thread9-8.jpg" alt="image"></p><p>我们看到是一个本地方法，并且在每个操作系统的具体实现都是不大一样的，这里我们就不再深究了。只要知道它的比较和替换是一个原子操作即可。</p><h2>五、其他重要的Atomic类</h2><h5>5.1 LongAdder</h5><p>上面提到了<code>AtomicInteger</code>，那么必然也存在``AtomicLong`。用法和原理是一样的。</p><p>既然用<code>LongAddr</code>也可以，但是为什么不使用<code>AtomicLong</code>呢？换句话说，为什么<code>AtomicLong</code>可以实现，还要有<code>LongAddr</code>这个类呢？？？</p><p><code>LongAddr</code>优点：我们从<code>AtomicInteger</code>这个类的实现看到，他是在一个死循环内不停地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功的几率很高。否则修改失败的概率就会很高。在大量修改失败的时候，多次尝试，性能会受到一定的影响。</p><p>对于普通类型的<code>Long</code>和<code>Double</code>变量，JVM允许将64位的读操作和写操作拆成两个32位的操作。</p><blockquote><p>我们知道<code>JUC</code>下面提供的原子类都是基于<code>Unsafe</code>类实现的，并由<code>Unsafe</code>来提供<code>CAS</code>的能力。<code>CAS</code> (<code>compare-and-swap</code>)本质上是由现代<code>CPU</code>在硬件级实现的原子指令，允许进行无阻塞，多线程的数据操作同时兼顾了安全性以及效率。<code>getAndAddLong</code>方法会以<code>volatile</code>的语义去读需要自增的域的最新值，然后通过<code>CAS</code>去尝试更新，正常情况下会直接成功后返回，但是在高并发下可能会同时有很多线程同时尝试这个过程，也就是说线程A读到的最新值可能实际已经过期了，因此需要在<code>while</code>循环中不断的重试，造成很多不必要的开销。</p></blockquote><p>将<code>AtomicLong</code>核心数据<code>value</code>分离成一个数组，每个线程访问时，通过<code>hash</code>等算法，映射到其中一个数字进行计数。最终的计数结果则为这个数组的求和累加。其中热点数据<code>value</code>会被分离成多个单元的<code>cell</code>，每个<code>cell</code>独自维护内部的值，当前对象的实际值由<code>cell</code>累计合成。这样，热点就得到有效的分离并提高了并行度。 <code>LongAddr</code>在<code>AtomicLong</code>基础上将单点的更新压力分散到各个节点上。低并发时通过对<code>base</code>直接更新，得到与<code>AtomicLong</code>一样的性能。</p><div class="tip">缺陷：统计的时候，如果有并发更新，会有统计的误差，例如获取一个全局唯一的ID还是采用`AtomicLong`更好一点。</div><h5>5.2 AtomicReference</h5><p>这个其实很简单，用法如下：</p><p><img src="http://bloghello.oursnail.cn/thread9-9.jpg" alt="image"></p><p>其实这个方法实现的是对一个共享对象的原子性操作，保证对象更新的原子性。</p><h5>5.3 AtomicIntegerFieldUpdater</h5><p>假设现在有这样的一个场景： 一百个线程同时对一个int对象进行修改，要求只能有一个线程可以修改。</p><p>可能有的同学会这么写：</p><p><img src="http://bloghello.oursnail.cn/thread9-10.jpg" alt="image"></p><p>我们来分析一下，对于<code>volatile</code>变量，写的时候会将线程本地内存的数据刷新到主内存上，读的时候会将主内存的数据加载到本地内存里，所以可以保证可见行和单个读/写操作的原子性。</p><p>但是上例中先</p><ul><li>先判断:<code>!ischanged</code></li><li>再执行赋值操作：<code>ischanged=true</code></li></ul><p>该组合操作就不能保证原子性了，也就是说线程A A1-&gt;A2 , 线程B B1-&gt;B2 (第一个操作为<code>volatile</code>读或者第二个操作为<code>volatile</code>写的时候，编译器不会对两个语句重排序，所以最后的执行顺序满足顺序一致性模型的)，但是最后的执行结果可能是A1-&gt;B1-&gt;A2-&gt;B2。不满足需求.</p><p>这种情况下，<code>AtomicIntegerFieldUpdater</code>就可以派上用场了。</p><p><img src="http://bloghello.oursnail.cn/thread9-11.jpg" alt="image"></p><p>对于这个代码的理解可以用下面这个代码来：</p><p><img src="http://bloghello.oursnail.cn/thread9-12.jpg" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update success 1:200</span><br><span class="line">update fail</span><br></pre></td></tr></table></figure><p>用<code>AtomicIntegerFieldUpdater.newUpdater</code>指定类里面的属性。这里我们要更新<code>Test</code>类里面的<code>A</code>字段（必须是<code>volatile</code>且不是<code>static</code>对象）。<code>update.compareAndSet()</code>方法使用<code>cas</code>机制，每次提交的时候都比较下<code>test.a</code>是不是100，如果是，则更新。</p><p>注意，不能使用<code>final</code>变量，因为语义冲突。对于<code>AtomicIntegerFieldUpdater</code>和<code>AtomicLongFieldUpdater</code>只能修改<code>int</code>/<code>long</code>类型的字段，不能修改其包装类型（<code>Integer</code>/<code>Long</code>）。如果要修改包装类型就需要使用<code>AtomicReferenceFieldUpdater</code>。</p><h5>5.4 AtomicStampedReference</h5><p>对于上面说的<code>AtomicInteger</code>等存在一个问题就是ABA问题。</p><p>ABA问题：其他线程将A改为B，又重新改为了A，本线程用期望值A与之进行比较，发现是相等的，则进行下面的操作。因为这个值已经被改变过，这就是ABA问题。</p><p>解决：用个版本号来控制，来防止ABA问题。</p><h5>5.5 AtomicBoolean</h5><p>场景：若干个线程进来，但是这个方法只能执行一次。</p><p><img src="http://bloghello.oursnail.cn/thread9-13.jpg" alt="image"></p><p>好了，其实<code>Atomic</code>包最核心的思想就是用无阻塞的<code>CAS</code>来代替锁实现高性能操作，是实现线程安全的一种可行方法，理解了<code>CAS</code>原理和他们的基本用法和场景使用，基本就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，volatile保证了可见性，但是不能保证原子性，在面对线程安全问题时，就显地力不从心，那么除了synchronized关键字外，还有什么方式可以实现线程安全更新呢？本文首先介绍CAS是什么，引出JUC下一个重要的包：Atomic包。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile详解</title>
    <link href="http://yoursite.com/2019/02/11/thread/volatile%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/11/thread/volatile详解/</id>
    <published>2019-02-11T13:13:55.833Z</published>
    <updated>2019-02-11T13:16:10.932Z</updated>
    
    <content type="html"><![CDATA[<p>volatile是比较重要的关键字，它涉及JMM，我们需要对其进行深入了解。</p><a id="more"></a><h2>一、java内存模型JMM</h2><p>JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。</p><p>请务必区分HMM和JAVA内存区域，JMM描述的是一组规则，围绕原子性、有序性以及可见性展开。</p><p><img src="http://bloghello.oursnail.cn/thread8-1.png" alt="image"></p><p>大多数的变量是只能存储在主内存中的，线程也不能直接去主内存中读取数据，而是获取数据的副本，每个线程对这个副本进行修改后，会在某个时机刷新回主内存。每个线程之间的工作内存的值是互不透明的，因此不能互相访问，线程间的通信必须通过主内存来完成。</p><h2>二、JMM主内存和工作内存都放些什么</h2><ul><li>主内存<ul><li>存储JAVA实例对象</li><li>包括实例变量、类信息、常量、静态变量等</li><li>属于数据共享的区域，多线程并发操作时会引起线程安全问题</li></ul></li><li>工作内存<ul><li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见(方法里的基本数据类型会直接被存储在工作内存的栈帧结构中)</li><li>字节码行号指示器、Native方法信息</li><li>如果是引用类型，引用存储在工作内存中，实例存储在主内存中</li><li>属于线程私有数据区域，不存在线程安全问题</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/thread8-2.jpg" alt="image"></p><h2>三、指令重排序</h2><p>为了提高执行性能，JVM会进行一定的指令重排序，禁止方式就是加入内存屏障指令，下面会说。</p><p>当然了，指令重排序需要满足一定的条件：</p><ul><li>在单线程环境下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li></ul><p>无法通过<code>happend-before</code>原则推导出来的，才能进行指令的重排序。</p><h2>四、happend-before</h2><p>多线程有两个基本的问题，就是原子性和可见性，而<code>happens-before</code>规则就是用来解决可见性的。</p><p>即：在时间上，动作A发生在动作B之前，能不能<strong>保证</strong>B可以看见A？如果可以保证的话，那么就可以说<code>hb(A,B)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行<code>writer()</code>方法之后，线程B执行<code>reader()</code>方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p><ul><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据volatile规则，2 happens before 3。</li><li>根据happens before 的传递性规则，1 happens before 4。</li></ul><p>上述<code>happens before</code> 关系的图形化表现形式如下：</p><p><img src="http://bloghello.oursnail.cn/thread8-3.png" alt="image"></p><p>在上图中，每一个箭头链接的两个节点，代表了一个<code>happens before</code> 关系。黑色箭头表示程序顺序规则；橙色箭头表示<code>volatile</code>规则；蓝色箭头表示组合这些规则后提供的<code>happens before</code>保证。</p><p>这里A线程写一个<code>volatile</code>变量后，B线程读同一个<code>volatile</code>变量。A线程在写<code>volatile</code>变量之前所有可见的共享变量，在B线程读同一个<code>volatile</code>变量后，将立即变得对B线程可见。</p><p>说了那么多，java中是如何保证这种可见性的呢？<code>Volatile</code>闪亮登场。</p><h2>五、什么是volatile</h2><p><code>volatile</code>关键字的目的是保证被它修饰的共享变量对所有线程总是可见的。</p><h2>六、为什么要用volatile</h2><p><code>Volatile</code>变量修饰符如果使用恰当的话，它比<code>synchronized</code>的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</p><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被<code>volatile</code>修饰之后，那么就具备了两层语义：</p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ul><h2>七、volatile如何保证可见性</h2><p><code>voliatile</code>关键字保证了在进程中变量的变化的可见性。</p><p>在多线程的应用里，如果线程操作了一个没有被<code>volatile</code>关键字标记的变量，那么每个线程都会在使用到这个变量时从主存里拷贝这个变量到CPU的<code>cache</code>里面（为了性能！CPU缓存可比内存快多了）。如果你的电脑有多于一个CPU，那么每个线程都会在不同的CPU上面运行，这意味着每个线程都会把这个变量拷贝到不同的CPU <code>cache</code>里面，正如下图所示：</p><p><img src="http://bloghello.oursnail.cn/thread8-4.png" alt="image"></p><p>一个不带有<code>volatile</code>关键字的变量在JVM从主存里面读取数据到CPU cache或者从cache里面写入数据到主存时是没有保证的。</p><p>想象这样一个场景，当一到两个线程允许去共享一个包含了一个计数变量的对象，这个计数变量如下所定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">//无关键字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这线程一增加了<code>counter</code>变量的值，但是，但是同时线程一和线程二都有可能随时读取这个<code>counter</code>变量。</p><p>如果这个<code>counter</code>变量未曾使用<code>volatile</code>声明，那么我们就无法保证这个变量在两个线程中所位于的CPU的cache和主存中的值是否保持一致了。示意图如下：</p><p><img src="http://bloghello.oursnail.cn/thread8-5.png" alt="image"></p><p>那么部分的线程就不能看到这个变量最新的样子，因为这个变量还没有被线程写回到主存中，这就是可见性的问题，这个线程更新的变量对于其他线程是不可视的。</p><p>在声明了<code>counter</code>变量的<code>volatile</code>关键字后，所有写入到<code>counter</code>变量的值会被立即写回到主存中。同时，所有读取这个变量的线程会先把对应的工作内存置为无效，从主存里面读取这个变量，下面的代码就是声明带<code>volatile</code>关键字的变量的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此声明这个变量就保证了这个变量对于其他写这个变量的线程的可见性。</p><p>总结：</p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了<code>Volatile</code>变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><h2>八、来详细说说volatile写-读的内存语义</h2><p><strong>volatile写的内存语义如下</strong>：</p><blockquote><p>当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</p></blockquote><p>以上面示例程序<code>VolatileExample</code>为例，假设线程A首先执行<code>writer()</code>方法，随后线程B执行<code>reader()</code>方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行<code>volatile</code>写后，共享变量的状态示意图：</p><p><img src="http://bloghello.oursnail.cn/thread8-6.png" alt="image"></p><p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p><p><strong>volatile读的内存语义如下</strong>：</p><blockquote><p>当读一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></blockquote><p><img src="http://bloghello.oursnail.cn/thread8-7.png" alt="image"></p><p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把<code>volatile</code>写和<code>volatile</code>读这两个步骤综合起来看的话，在读线程B读一个<code>volatile</code>变量后，写线程A在写这个<code>volatile</code>变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p><p>下面对<code>volatile</code>写和<code>volatile</code>读的内存语义做个总结：</p><ul><li>线程A写一个<code>volatile</code>变量，实质上是线程A向接下来将要读这个<code>volatile</code>变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程B读一个<code>volatile</code>变量，实质上是线程B接收了之前某个线程发出的（在写这个<code>volatile</code>变量之前对共享变量所做修改的）消息。</li><li>线程A写一个<code>volatile</code>变量，随后线程B读这个<code>volatile</code>变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h2>九、volatile如何禁止指令重排序</h2><p>这就不得不提一个指令叫做：内存屏障了。</p><p>它可就厉害了，</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ul><p>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化。</p><p>这个指令对编译器和CPU的执行都是起作用的，可用强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><p>因此，从根本上来说，是内存屏障指令实现了<code>volatile</code>的可见性和禁止指令重排序的。</p><h2>十、volatile的应用场景</h2><blockquote><p><code>volatile</code>关键字只能对32位和64位的变量使用</p></blockquote><p><code>synchronized</code>关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而<code>volatile</code>关键字在某些情况下性能要优于<code>synchronized</code>，但是要注意<code>volatile</code>关键字是无法替代<code>synchronized</code>关键字的，因为<code>volatile</code>关键字无法保证操作的原子性。通常来说，使用<code>volatile</code>必须具备以下2个条件：</p><blockquote><p>1）对变量的写操作不依赖于当前值</p></blockquote><blockquote><p>2）该变量没有包含在具有其他变量的不变式中</p></blockquote><p>下面列举几个Java中使用<code>volatile</code>的几个场景。</p><p>①.状态标记量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②.单例模式中的<code>double check</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>instance = new Singleton();</code>//非原子操作</p></blockquote><p>执行这一句，JVM发生了如下事情：</p><ul><li>给 <code>instance</code> 分配内存</li><li>调用 <code>Singleton</code> 的构造函数来初始化成员变量</li><li>将<code>instance</code>对象指向分配的内存空间（执行完这步 <code>instance</code> 就为非 <code>null</code> 了）</li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 <code>instance</code> 已经是非 <code>null</code> 了（但却没有初始化），所以线程二会直接返回 <code>instance</code>，然后使用，然后顺理成章地出错了，不再是单例了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;volatile是比较重要的关键字，它涉及JMM，我们需要对其进行深入了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读写锁ReentrantReadWriteLock</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/"/>
    <id>http://yoursite.com/2019/02/11/thread/读写锁ReentrantReadWriteLock/</id>
    <published>2019-02-11T11:35:01.023Z</published>
    <updated>2019-02-11T11:38:36.811Z</updated>
    
    <content type="html"><![CDATA[<p>读写锁的出现是为了提高性能，思想是：读读不互斥，读写互斥，写写互斥。本文来了解一下读写锁的使用和锁降级的概念。</p><a id="more"></a><h2>1. 锁的分类</h2><ul><li>排他锁：在同一时刻只允许一个线程进行访问，其他线程等待；</li><li>读写锁：在同一时刻允许多个读线程访问，但是当写线程访问，所有的写线程和读线程均被阻塞。读写锁维护了一个读锁加一个写锁，通过读写锁分离的模式来保证线程安全，性能高于一般的排他锁。</li></ul><h2>2. 读写锁</h2><p>我们对数据的操作无非两种：“读”和“写”，试想一个这样的情景，当十个线程同时读取某个数据时，这个操作应不应该加同步。答案是没必要的。只有以下两种情况需要加同步：</p><ul><li>这十个线程对这个公共数据既有读又有写</li><li>这十个线程对公共数据进行写操作</li><li>以上两点归结起来就一点就是有对数据进行改变的操作就需要同步</li></ul><p>所以</p><p><strong>java5提供了读写锁这种锁支持多线程读操作不互斥，多线程读写互斥，多线程写互斥</strong>。读操作不互斥这样有助于性能的提高，这点在java5以前没有。</p><h2>3. java并发包提供的读写锁</h2><p>java并发包提供了读写锁的具体实现<code>ReentrantReadWriteLock</code>，它主要提供了一下特性：</p><ul><li>公平性选择：支持公平和非公平（默认）两种获取锁的方式，非公平锁的吞吐量优于公平锁；</li><li>可重入：支持可重入，读线程在获取读锁之后能够再次获取读锁，写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁；</li><li>锁降级：线程获取锁的顺序遵循获取写锁，获取读锁，释放写锁，写锁可以降级成为读锁。</li></ul><h2>4. 先看个小例子</h2><p><strong>读取数据和写入数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个map用来读取和存放数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化ReentrantReadWriteLock</span></span><br><span class="line"><span class="keyword">private</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据实例化对象分别获取读锁和写锁</span></span><br><span class="line"><span class="keyword">private</span> Lock r = rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上读锁</span></span><br><span class="line">r.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 读操作开始执行"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">System.out.println(map.get(key));</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解读锁</span></span><br><span class="line">r.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 读操作执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入数据，即写数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上写锁</span></span><br><span class="line">w.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 写操作开始执行"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">map.put(key, value);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//解写锁</span></span><br><span class="line">w.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 写操作执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main进行创建多线程测试：先来测试一下存在写的情况(只有写或者写读都有)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 写操作开始执行</span><br><span class="line">Thread-0 写操作执行完毕</span><br><span class="line">Thread-1 读操作开始执行</span><br><span class="line">value1</span><br><span class="line">Thread-1 读操作执行完毕</span><br><span class="line">Thread-2 写操作开始执行</span><br><span class="line">Thread-2 写操作执行完毕</span><br><span class="line">Thread-3 写操作开始执行</span><br><span class="line">Thread-3 写操作执行完毕</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>发现存在写的情况，那么就是一个同步等待的过程，即开始执行，然后等待3秒，执行完毕，符合第2个目录中提到的规则。</p><p><strong>对只有读操作的情形进行测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">demo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">demo.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">demo.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 读操作开始执行</span><br><span class="line">Thread-1 读操作开始执行</span><br><span class="line">Thread-2 读操作开始执行</span><br><span class="line">value1</span><br><span class="line">Thread-0 读操作执行完毕</span><br><span class="line">value2</span><br><span class="line">Thread-1 读操作执行完毕</span><br><span class="line">value3</span><br><span class="line">Thread-2 读操作执行完毕</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>在主线程中先<code>put</code>进去几个数用于读的测试，下面开辟三个读线程，我们可以从执行结果中发现，其中一个线程进去之后，另外的线程能够立即再次进入，即这三把锁不是互斥的。</p><h2>5. 锁降级</h2><p>锁降级是指写锁将为读锁。</p><p>锁降级：从写锁变成读锁；锁升级：从读锁变成写锁。读锁是可以被多线程共享的，写锁是单线程独占的。也就是说写锁的并发限制比读锁高，这可能就是升级/降级名称的来源。</p><p>如下代码会产生死锁，因为同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，<code>ReentrantReadWriteLock</code>是不支持的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line">rtLock.readLock().lock();  <span class="comment">//上读锁</span></span><br><span class="line">System.out.println(<span class="string">"get readLock."</span>);  </span><br><span class="line">rtLock.writeLock().lock();  <span class="comment">//读锁还没有释放，不允许上死锁</span></span><br><span class="line">System.out.println(<span class="string">"blocking"</span>);</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>支持锁降级，如下代码不会产生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line">rtLock.writeLock().lock();  <span class="comment">//上写锁</span></span><br><span class="line">System.out.println(<span class="string">"writeLock"</span>);  </span><br><span class="line">  </span><br><span class="line">rtLock.readLock().lock();  <span class="comment">//可以在写锁没有释放的时候立即上读锁</span></span><br><span class="line">System.out.println(<span class="string">"get read lock"</span>);</span><br></pre></td></tr></table></figure><p>利用这个机制：<strong>同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，<code>ReentrantReadWriteLock</code>是不支持的。</strong></p><p>在写锁没有释放的时候，先获取到读锁，然后再释放写锁，保证后面读到的数据的一致性。</p><p><img src="https://segmentfault.com/img/bVOGUM?w=1063&amp;h=246" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isUpdate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">r.lock();<span class="comment">//为了保证isUpdate能够拿到最新的值</span></span><br><span class="line"><span class="keyword">if</span>(isUpdate)&#123;</span><br><span class="line">r.unlock();</span><br><span class="line">w.lock();</span><br><span class="line">map.put(<span class="string">"xxx"</span>,<span class="string">"xxx"</span>);</span><br><span class="line">r.lock();<span class="comment">//写锁还没有释放，立即获取读锁，阻塞本线程，保证本线程下面读的一致性</span></span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">String value = map.get(<span class="string">"xxx"</span>); <span class="comment">//读到的数据是本线程自己更新的数据，不会被其他线程打扰</span></span><br><span class="line">System.out.println(value);</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读写锁的出现是为了提高性能，思想是：读读不互斥，读写互斥，写写互斥。本文来了解一下读写锁的使用和锁降级的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从ReentrantLock引出AQS的原理</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E4%BB%8EReentrantLock%E5%BC%95%E5%87%BAAQS%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/11/thread/从ReentrantLock引出AQS的原理/</id>
    <published>2019-02-11T10:45:59.507Z</published>
    <updated>2019-02-13T09:47:09.238Z</updated>
    
    <content type="html"><![CDATA[<p>如果对并发编程稍微熟悉的话，就不会对ReentrantLock陌生，也可能对一些组件比如CountDownLatch,FutureTask以及Semaphore等同步组件耳闻过，他们都是JUC包下的类或者工具，他们都有一个共同的基础：AQS，即AbstractQueuedSynchronizer，从今天开始，让我们记住它，并且尝试去理解它。</p><a id="more"></a><h2>一、ReentrantLock</h2><p>首先我们先来看看<code>ReentrantLock</code>这个可重入锁的性质和使用，因为它往往会在面试中被面试官拿来同<code>synchronized</code>相比较。如果这种基本的比较都不知道的话，那就没有后续深入的探讨了，面试可能也会结束了。</p><p>它的用法极其简单，如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-1.jpg" alt="image"></p><p>他们两兄弟的区别是：</p><ul><li><code>synchronized</code>是关键字，<code>ReentrantLock</code>是一个类</li><li><code>ReentrantLock</code>可以对获取锁的等待时间进行设置，避免死锁</li><li><code>ReentrantLock</code>可以获取各种锁的信息</li><li><code>ReentrantLock</code>可以灵活地实现多路通知</li><li>机制：<code>synchronized</code>操作<code>MarkWord</code>，<code>lock</code>调用<code>Unsafe</code>类的<code>park()</code>方法</li><li><code>ReentrantLock</code>可以设置锁的公平性</li><li><code>ReentrantLock</code>调用<code>lock()</code>之后必须调用<code>unlock()</code>释放锁</li><li>性能上<code>ReentrantLock</code>未必就比<code>synchronized</code>高，他们都是可重入的</li></ul><p>可以看出，<code>ReentrantLock</code>更加灵活，可以更加细腻度操作锁，而<code>synchronized</code>看起来则相对比较笨拙，但是笨拙的是简单的，不存在忘记释放锁的问题。可谓存在即合理嘛！</p><p>针对上文中提到的<code>Unsafe</code>类，其中最经典的一个方法是：<code>compareAndSwapXXX</code>这类<code>CAS</code>方法，它其实是JAVA留的一个后门，它可以直接操作内存，因此如果普通开发者拿来用的话，可能会出现各种问题，因此被成为不安全的类。</p><p>好了，关于区别已经说的差不多了，下面我们就要来真格的了，首先来翻翻源码。<strong>前方高能预警，请非战斗人员紧急撤离现场，老司机要开车了。</strong></p><p>首先呢，我们来看看<code>lock()</code>方法的实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里多了一个东西叫<code>Sync</code>，<code>Sync</code>为<code>ReentrantLock</code>里面的一个内部类，它继承<code>AQS</code>，它有两个子类：公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>。</p><p><code>ReentrantLock</code>里面大部分的功能都是委托给<code>Sync</code>来实现的，同时<code>Sync</code>内部定义了<code>lock()</code>抽象方法由其子类去实现，默认实现了<code>nonfairTryAcquire(int acquires)</code>方法，可以看出它是非公平锁的默认实现方式。</p><p><img src="http://bloghello.oursnail.cn/thread7-2.jpg" alt="image"></p><p>几乎每一个方法都是通过<code>sync.xxx</code>来实现的，而<code>Sync</code>这个内部类在<code>AQS</code>的基础上增加一些东西而已，所以本质上都是基于<code>AQS</code>来实现的。</p><p>不仅仅是这个，JUC包基本都是以<code>AQS</code>为基础构成，因此<code>AQS</code>可以理解为JUC的一个实现框架。既然<code>AQS</code>这么重要，下面有必要挖地三尺掘出它的原理。</p><h2>二、AQS简介</h2><p>java的内置锁一直都是备受争议的，在JDK 1.6之前，<code>synchronized</code>这个重量级锁性能一直都是较为低下，虽然在1.6后，进行大量的锁优化策略,但是与<code>Lock</code>相比<code>synchronized</code>还是存在一些缺陷的：虽然<code>synchronized</code>提供了便捷性的隐式获取锁释放锁机制（基于JVM机制），但是它却缺少了获取锁与释放锁的可操作性，可中断、超时获取锁，且它为独占式在高并发场景下性能大打折扣。</p><p>AQS：<code>AbstractQueuedSynchronizer</code>，即队列同步器。它是构建锁或者其他同步组件的基础框架（如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<br><code>Semaphore</code>等），JUC并发包的作者（<code>Doug Lea</code>）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。</p><p>AQS解决了在实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS使用一个<code>int</code>类型的成员变量<code>state</code>来表示同步状态，当<code>state&gt;0</code>时表示已经获取了锁，当<code>state = 0</code>时表示释放了锁。它提供了三个方法（<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect,int update)</code>）来对同步状态<code>state</code>进行操作，当然AQS可以确保对<code>state</code>的操作是安全的。</p><p>AQS通过内置的<code>FIFO</code>同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><h2>三、CLH同步队列</h2><p><code>CLH</code>同步队列是一个<code>FIFO</code>双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>在<code>CLH</code>同步队列中，一个节点表示一个线程，它保存着线程的引用（<code>thread</code>）、状态（<code>waitStatus</code>）、前驱节点（<code>prev</code>）、后继节点（<code>next</code>），<code>CLH</code>同步队列结构图如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-9.jpg" alt="image"></p><p>举例理解：假设目前有三个线程<code>Thread1</code>、<code>Thread2</code>、<code>Thread3</code>同时去竞争锁，如果结果是<code>Thread1</code>获取了锁，<code>Thread2</code>和<code>Thread3</code>进入了等待队列，那么他们的样子如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-10.jpg" alt="image"></p><p>AQS的等待队列基于一个双向链表实现的，<code>HEAD</code>节点不关联线程，后面两个节点分别关联<code>Thread2</code>和<code>Thread3</code>，他们将会按照先后顺序被串联在这个队列上。这个时候如果后面再有线程进来的话将会被当做队列的<code>TAIL</code>。</p><h2>四、入列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWaiter(Node node)</code>先通过快速尝试设置尾节点，如果失败，则调用<code>enq(Node node)</code>方法设置尾节点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多次尝试，直到成功为止 </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置为尾节点 </span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就很明了了，首先是尝试快速用<code>CAS</code>设置当前的节点为尾节点，但是可能存在并发问题设置不成功，下面用死循环的方式不断地尝试添加节点并且设置为尾节点，直到成功。</p><p>过程如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-4.jpg" alt="image"></p><h2>五、出列</h2><p>CLH同步队列遵循<code>FIFO</code>，首节点的线程释放同步状态后，将会唤醒它的后继节点（<code>next</code>），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的<code>next</code>和当前节点的<code>prev</code>即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。</p><p><img src="http://bloghello.oursnail.cn/thread7-5.jpg" alt="image"></p><p>其实这里按照源码的解释，是将第一个获取到同步状态的<code>node</code>作为新的<code>head</code>，然后将原来的<code>head</code>置空。</p><h2>六、同步状态的获取与释放</h2><p>在前面提到过，AQS是构建Java同步组件的基础，我们期待它能够成为实现大部分同步需求的基础。AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情况。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。</p><p><strong>下面具体来解释一下独占式和共享式的含义</strong></p><p>在具体分析之前，我们先解释两种同步的方式，独占模式和共享模式：</p><ul><li>独占模式：资源是独占的，一次只能一个线程获取。</li><li>共享模式：同时可以被多个线程获取，具体的资源的个数可以通过参数指定。</li></ul><p>如果我们自己实现一个同步器的框架，我们怎么设计呢？下面可能是我们想到的比较通用的设计方案（独占模式）:</p><ul><li>定义一个变量<code>int state=0</code>，使用这个变量表示被获取的资源的数量。</li><li>线程在获取资源前要先检查<code>state</code>的状态，如果为0，则修改为1，表示获取资源成功，否则表示资源已经被其他线程占用，此时线程要堵塞以等待其他线程释放资源。</li><li>为了能使得资源释放后找到那些为了等待资源而堵塞的线程，我们把这些线程保存在FIFO队列中。</li><li>当占有资源的线程释放掉资源后，可以从队列中唤醒一个堵塞的线程，由于此时资源已经释放，因此这个被唤醒的线程可以获取资源并且执行。</li></ul><p>这个<code>state</code>变量到底是什么呢？</p><ul><li>当<code>AQS</code>的子类实现独占功能时，如<code>ReentrantLock</code>，资源是否可以被访问被定义为：只要<code>AQS</code>的<code>state</code>变量不为0，并且持有锁的线程不是当前线程，那么代表资源不可访问。此时，<code>state</code>是用来表示当前线程获取锁的可重入次数；</li><li>当<code>AQS</code>的子类实现共享功能时，如<code>CountDownLatch</code>，资源是否可以被访问被定义为：只要<code>AQS</code>的<code>state</code>变量不为0，那么代表资源不可以为访问。此时，<code>state</code>用来表示当前计数器的值。</li></ul><h2>七、独占式-独占式同步状态获取</h2><p>独占式，同一时刻仅有一个线程持有同步状态。</p><p>独占式同步状态获取<code>acquire(int arg)</code>方法为AQS提供的模板方法，该方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire</code>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现(<code>ReentrantLock</code>中实现公平锁和非公平锁就是分别重写了这个方法实现的，下面看<code>ReentrantLock</code>的原理的时候就明白了)，该方法必须要保证线程安全的获取同步状态。</li><li><code>addWaiter</code>：如果<code>tryAcquire</code>返回<code>FALSE</code>（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li><code>acquireQueued</code>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt</code>：产生一个中断。</li></ul><p>对这里的<code>acquireQueued</code>有疑惑，下面来看看它做了什么。<code>acquireQueued</code>方法为一个自旋的过程，也就是说当前线程（<code>Node</code>）进入同步队列后，就会先进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点node的前驱结点p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果p确实是head，那说明当前节点node是可用的第一个线程</span></span><br><span class="line">            <span class="comment">//即为当前队列的第一个线程，则最先处理它</span></span><br><span class="line">            <span class="comment">//当前线程则尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//从这里可以看出，更新当前节点为头节点</span></span><br><span class="line">                <span class="comment">//将原来头节点的next引用置空以供JVM回收</span></span><br><span class="line">                <span class="comment">//具体见出列小标题下的示意图</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前驱节点不是头节点就继续阻塞继续等待呗</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p><ul><li>保持FIFO同步队列原则。</li><li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li></ul><p>对这个的理解简单来说就是：</p><blockquote><p>在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的队尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果当前节点的前驱节点就是头节点，则表明当前节点是当前队列中的第一个可用线程，则让其不断尝试获取同步状态，如果获取到，则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p></blockquote><p>继续，我们看到，如果发现前驱节点并不是<code>head</code>，那么就说明是比较靠后的节点了，这个时候，很有可能需要一段时间之后才会用到它，所以根本不需要再参与自旋浪费CPU的性能了，即下面一个if:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>通过这段代码我们可以看到，在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法，该方法主要靠前驱节点判断当前线程是否应该被阻塞，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//状态为signal，表示当前线程处于等待状态，直接放回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//前驱节点状态 &gt; 0 ，则为Cancelled,表明该节点已经超时或者被中断了，需要从同步队列中取消</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前驱节点状态为Condition、propagate</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要检查当前线程是否需要被阻塞，具体规则如下：</p><ul><li>如果当前线程的前驱节点状态为<code>SINNAL</code>，则表明当前线程需要被阻塞，调用<code>unpark()</code>方法唤醒，直接返回true，当前线程阻塞</li><li>如果当前线程的前驱节点状态为<code>CANCELLED（ws &gt; 0）</code>，则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li><li>如果前驱节点非<code>SINNAL</code>，非<code>CANCELLED</code>，则通过CAS的方式将其前驱节点设置为<code>SINNAL</code>，返回false</li></ul><p>针对<code>pred.waitStatus</code>的几种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法返回<code>true</code>，则调用<code>parkAndCheckInterrupt()</code>方法阻塞当前线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parkAndCheckInterrupt()</code> 方法主要是把当前线程挂起，从而阻塞住线程的调用栈，同时返回当前线程的中断状态。其内部则是调用<code>LockSupport</code>工具类的<code>park()</code>方法来阻塞该方法。</p><p>那么，此时，当第一个线程已经执行完毕，释放锁了，就需要唤醒队列中后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>unparkSuccessor(Node node)</code>唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//当前状态 &lt; 0 则设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从tail节点来找可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会存在当前线程的后继节点为<code>null</code>，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，但是为何是从<code>tail</code>尾节点开始，而不是从<code>node.next</code>开始呢？原因在于<code>node.next</code>仍然可能会存在<code>null</code>或者取消了，所以采用<code>tail</code>回溯办法找第一个可用的线程。最后调用<code>LockSupport</code>的<code>unpark(Thread thread)</code>方法唤醒该线程。</p><p>从上面我可以看到，当需要阻塞或者唤醒一个线程的时候，AQS都是使用LockSupport这个工具类来完成的。</p><p><code>LockSupport</code>定义了一系列以<code>park</code>开头的方法来阻塞当前线程，<code>unpark(Thread thread)</code>方法来唤醒一个被阻塞的线程。这些方法的实现都是通过<code>Unsafe</code>类调用<code>native</code>方法来实现的。</p><p>好了，至此就完完全全地搞明白了独占式同步状态获取<code>acquire(int arg)</code>方法的原理，特别是其中节点如何进出、队列第一个节点如何尝试获取同步状态、如何阻塞后继线程以及如何唤醒。</p><h2>八、独占式获取响应中断</h2><p><code>AQS</code>提供了<code>acquire(int arg)</code>方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于<code>CLH</code>同步队列中等待着获取同步状态。为了响应中断，<code>AQS</code>提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常<code>InterruptedException</code>。</p><p>具体原理就不深究了，其实源码跟上面个相差不大，只是不再是使用<code>interrupted</code>标志，而是直接抛出<code>InterruptedException</code>异常。再深究这博客没法继续写啦。</p><h2>九、独占式超时获取</h2><p><code>AQS</code>除了提供上面两个方法外，还提供了一个增强版的方法：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为<code>acquireInterruptibly</code>方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回<code>false</code>，否则返回<code>true</code>。</p><p>针对超时控制，程序首先记录唤醒时间<code>deadline</code> :<code>deadline</code> = <code>System.nanoTime()</code> +<code>nanosTimeout</code>（时间间隔）。</p><p>如果获取同步状态失败，则需要计算出需要休眠的时间间隔<code>nanosTimeout</code> = <code>deadline</code> - <code>System.nanoTime()</code>，如果<code>nanosTimeout</code> &lt;= 0 表示已经超时了，返回<code>false</code>;</p><p>如果大于<code>spinForTimeoutThreshold(1000L)</code>则需要休眠<code>nanosTimeout</code> ;</p><p>如果<code>nanosTimeout</code> &lt;= <code>spinForTimeoutThreshold</code> ，就不需要休眠了，直接进入快速自旋的过程。原因在于 <code>spinForTimeoutThreshold</code> 已经非常小了，非常短的时间等待无法做到十分精确，如果这时再次进行超时等待，相反会让<code>nanosTimeout</code> 的超时从整体上面表现得不是那么精确，所以在超时非常短的场景中，AQS会进行无条件的快速自旋。</p><p>流程图如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-8.jpg" alt="image"></p><h2>十、共享式-共享式同步状态获取</h2><p>共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p><p><code>AQS</code>提供<code>acquireShared(int arg)</code>方法共享式获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面程序可以看出，方法首先是调用<code>tryAcquireShared(int arg)</code>方法尝试获取同步状态，如果获取失败则调用<code>doAcquireShared(int arg)</code>自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。自旋方式获取同步状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且<code>tryAcquireShared(arg)</code>返回值大于等于0即能成功获得同步状态。</p><p><code>acquireShared(int arg)</code>方法不响应中断，与独占式相似，AQS也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，这里就不做解释了。</p><h2>十一、共享式同步状态释放</h2><p>获取同步状态后，需要调用<code>release(int arg)</code>方法释放同步状态，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</p><h2>十二、再回过头来看看ReentrantLock的原理</h2><p>在对AQS原理进行大概了梳理之后，再来理解<code>ReentrantLock</code>就比较容易了，因为大部分的事情都由AQS做完了，剩下的只要重写几个个性化的方法即可。</p><p>还是要看看最核心的方法：<code>lock()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看这个<code>lock()</code>，一点点进了抽象静态内部类<code>Sync</code>中去了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>上面说过，<code>ReentrantLock</code>里面大部分的功能都是委托给<code>Sync</code>来实现的，同时<code>Sync</code>内部定义了<code>lock()</code>抽象方法由其子类去实现的，所以这个<code>lock</code>方法的具体实现是在子类中完成的。<code>Sync</code>的子类有<code>NonfairSync</code>和<code>FairSync</code>这两个，一看就知道了，一个是非公平一个是公平。</p><h2>十三、非公平锁</h2><p>先来看看比较简单的非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，这个<code>lock()</code>方法里面首先用<code>CAS</code>尝试获取锁，获取不到则执行<code>acquire()</code>方法，这个方法就恰好是完全由<code>AQS</code>实现，那么就回到了上面介绍过的内容了。这里为了方便再贴一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是调用<code>tryAcquire()</code>这个方法，即尝试获取锁，这个方法上面也提过，是留给具体的类自己去实现的，所以我们还要回到<code>ReentrantLock</code>中来看看，果然，在上面贴的<code>NonfairSync</code>这个类中对这个方法进行了重写。即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的方法就是实现尝试获取锁的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//state == 0,表示该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取锁成功，设置为当前线程所有</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程重入</span></span><br><span class="line">    <span class="comment">//判断锁持有的线程是否为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就很简单了，值得注意的是，为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作。</p><p>另外需要注意的是，这是非公平锁，就是说，一个线程进来，可能是比先进来的线程先获取锁，就像在开车的时候，总是会由一些车插到你的前面一样。但是如果它没有获取锁，则入队。</p><p>那么尝试获取锁的逻辑我们知道了，那么释放锁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。</p><h2>十四、公平锁</h2><p>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足<code>FIFO</code>。<code>ReentrantLock</code>的构造方法无参时是构造非公平锁。</p><p>提供了有参构造函数，可传入一个<code>boolean</code>值，<code>true</code>时为公平锁，<code>false</code>时为非公平锁，源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面非公平锁获取时（<code>nonfairTryAcquire</code>方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑与<code>nonfairTryAcquire</code>基本上一致，唯一的不同在于增加了<code>hasQueuedPredecessors</code>的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。</p><h2>十五、公平锁 VS 非公平锁</h2><ul><li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。</li><li>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，<code>ReentrantLock</code>默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果对并发编程稍微熟悉的话，就不会对ReentrantLock陌生，也可能对一些组件比如CountDownLatch,FutureTask以及Semaphore等同步组件耳闻过，他们都是JUC包下的类或者工具，他们都有一个共同的基础：AQS，即AbstractQueuedSynchronizer，从今天开始，让我们记住它，并且尝试去理解它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从底层理解synchronized</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3synchronized/"/>
    <id>http://yoursite.com/2019/02/11/thread/从底层理解synchronized/</id>
    <published>2019-02-11T06:21:16.472Z</published>
    <updated>2019-02-11T06:21:44.186Z</updated>
    
    <content type="html"><![CDATA[<p>上一章了解了synchronized的基本使用方式之后，接下来我们来深入了解了解其底层原理，并且说明对它的优化。</p><a id="more"></a><h2>一、synchronized底层实现原理</h2><p>首先给出一个不是结论的结论，<code>synchronized</code>的实现基础是：<code>JAVA</code>对象头和<code>Monitor</code>，理解了这两者的作用就理解了<code>synchronized</code>的实现原理。下面进行详细讲解。</p><p>⭐然后在正式开始之前，先介绍一下锁的内存语义：</p><ul><li>当线程释放锁时，JAVA内存模型会把该线程对应额本地内存中的共享变量刷新到主内存中</li><li>当线程获取锁时，JAVA内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</li></ul><p>在<a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/" target="_blank" rel="noopener">JAVA内存模型-线程共享</a>这篇文章中介绍了对象头里面的基本构成。</p><p><img src="http://bloghello.oursnail.cn/thread6-1.jpg" alt="image"></p><p>我们着重看一下对象头，下面两个这里不需要关心。我们可以看到一个关键字：锁状态标志。因此<code>Mark Word</code>是实现锁的关键了。</p><p>我们也知道，<code>Mark Word</code>是一个可变的结构，可变的部分主要有如下：</p><p><img src="http://bloghello.oursnail.cn/thread6-2.jpg" alt="image"></p><p>其中，偏向所和轻量级锁是JDK1.6之后对<code>synchronized</code>优化所新加的，后文会探讨对<code>synchronized</code>的优化。</p><p>OK，到这里我们知道了每个对象区域的对象头这一块存储了关于锁的信息，即锁状态。仔细看表格，比如重量级锁，就是我们熟知的<code>synchronized</code>对象锁，它的说明是：指向重量级锁的指针。那这个锁是什么呢？指向的是什么位置呢？这个就不得不提及第二个关键字啦：<code>Monitor</code></p><p><code>Monitor</code>:每个对象打娘胎生下来就自带了一把看不见的锁，成为内部锁或者<code>Monitor</code>锁，也称为管程或者监视器锁。我们可以理解为一种同步工具，也可以理解为同步对象。</p><p>那么回到上面的问题上来，这个指针指向的就是<code>Monitor</code>对象的起始地址，因此，每个对象都会存在一个<code>Monitor</code>与之关联，当这个<code>Monitor</code>被一个线程持有时，它就会处于锁定状态。</p><p>在<code>Hotspot</code>虚拟机中，这个<code>Monitor</code>是由<code>ObjectMonitor</code>实现的，位于虚拟机源码中，用<code>C++</code>实现。我们一起来看看吧！</p><p>这个源码地址为：<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/76a9c9cf14f1/src/share/vm/runtime/objectMonitor.hpp" target="_blank" rel="noopener">objectMonitor.hpp</a></p><p><img src="http://bloghello.oursnail.cn/thread6-3.jpg" alt="image"></p><p>我们看到了几个比较重要的关键字，首先，每个等待获取锁的线程都会被封装为<code>ObjectWaiter</code>对象。<code>_WaitSet</code>就是之前说的所有<code>wait</code>状态的线程都会被放在这里等待唤醒再去竞争锁；<code>_EntryList</code>就是所有等待获取锁的线程对象存放的地方。<code>_owner</code>指向的是当前获取到锁的线程对象。<code>_count</code>为计数，这个就跟可重入相关了，线程进来一次就加一次，为0的时候就说明释放锁了，那么此时处于<code>_EntryList</code>池中的线程都可以去竞争这把锁了。</p><p>将上面文字转换为图来理解就是：</p><p><img src="http://bloghello.oursnail.cn/thread6-4.jpg" alt="image"></p><p>以上就是<code>Synchronized</code>实现锁的原理。</p><h2>二、synchronized在字节码层面的语义</h2><p>我们拿下面这段程序作为示例：</p><p><img src="http://bloghello.oursnail.cn/thread6-5.jpg" alt="image"></p><p>我们对这两个方法进行<code>javap</code>的分析，针对第一个同步代码块：</p><p><img src="http://bloghello.oursnail.cn/thread6-6.jpg" alt="image"></p><p>我们可以看出来，<code>synchronized</code>同步代码块实现同步的关键指令是<code>monitorenter</code>和<code>monitorexit</code>。这恰好与上面说的<code>monitor</code>锁对应上，即多个线程在<code>_EntryList</code>中竞争，看谁能拿到<code>monitor</code>锁的指向全，拿到了就可以进来，拿不到就阻塞在<code>monitorenter</code>处继续等待。知道这个锁被释放了为止。</p><p>那么对于<code>synchronized</code>修饰的方法呢？</p><p><img src="http://bloghello.oursnail.cn/thread6-7.jpg" alt="image"></p><p>如果是同步方法，在字节码层面的表示是略有不同的。我们注意到，是在某个标识位上给其打上<code>ACC_SYNCHRONIZED</code>标志，表示这是一个<code>synchronized</code>修饰的同步方法，那么下面对于锁竞争啥的都与上面一样，所以只是字节码层面的表示不同而已，原理都一样。</p><h2>三、对synchronized的优化</h2><p>对于<code>synchronized</code>的性能，在以前一直是嗤之以鼻的，这种观念从老一代的程序猿们口口相传到如今，可谓是根深蒂固，在以前的版本中，确实是很慢，原因如下：</p><ul><li>早期版本中，<code>synchronized</code>属于重量级锁，依赖于<code>Mutex Lock</code>实现</li><li>线程之间的切换需要从用户态转换到核心态，开销较大</li></ul><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h5>3.1 自旋锁</h5><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p>何谓自旋锁？</p><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p><p>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用<code>-XX:+UseSpinning</code>开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数<code>-XX:PreBlockSpin</code>来调整；</p><p>如果通过参数<code>-XX:preBlockSpin</code>来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h5>3.2 适应自旋锁</h5><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p><p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h5>3.3 锁消除</h5><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。</p><p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如<code>StringBuffer</code>、<code>Vector</code>、<code>HashTable</code>等，这个时候会存在隐形的加锁操作。比如<code>StringBuffer</code>的<code>append()</code>方法，<code>Vector</code>的<code>add()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM可以明显检测到变量<code>vector</code>没有逃逸出方法<code>vectorTest()</code>之外，所以JVM可以大胆地将<code>vector</code>内部的加锁操作消除。</p><h5>3.4 锁粗化</h5><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p><p>在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。</p><p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：<code>vector</code>每次add的时候都需要加锁操作，JVM检测到对同一个对象（<code>vector</code>）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到<code>for</code>循环之外。</p><h5>3.5 偏向锁</h5><p>在大多数情况下，锁不存在多线程竞争，总是由同一个线程多次获得。</p><blockquote><p>⭐⭐⭐核心的思想是：如果一个线程获得了锁，那么锁就会进入偏向模式，此时<code>Mark Word</code>的结构也变为偏向锁结构，当该结构再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查<code>Mark Word</code>的锁标记位位偏向锁以及当前线程ID等于<code>Mark Word</code>的<code>ThreadId</code>即可，这样省去了大量有关锁申请的操作。</p></blockquote><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换<code>ThreadID</code>的时候依赖一次<code>CAS</code>原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的<code>CAS</code>原子指令的性能消耗）。<strong>上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><p>它的思想可以理解为<code>CAS</code>，因此这种锁不适合于锁竞争比较激烈的多线程场合。</p><p>偏向锁的获取和释放：</p><blockquote><ul><li>访问 Mark Word 中偏向锁的标识位是否为1，如果是1，则确定为偏向锁。<ul><li>如果偏向锁的标识位为0，说明此时是处于无锁状态，则当前线程通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；并且将偏向标识位设为1。</li><li>如果偏向锁的标识位不为1，也不为0(此时偏向锁的标识位没有值)，说明发生了竞争，偏向锁已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁。</li></ul></li><li>如果是偏向锁，则判断 Mark Word 中的偏向线程ID是否指向当前线程，如果偏向线程ID指向当前线程，则表明当前线程已经获取到了锁；</li><li>如果偏向线程ID并未指向当前线程，则通过CAS操作尝试获取偏向锁，如果获取锁成功，则将 Mark Word 中的偏向线程ID设置为当前线程ID；</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时(在这个时间点上没有正在执行的字节码)，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>偏向锁的释放：<ul><li>当其它的线程尝试获取偏向锁时，持有偏向锁的线程才会释放偏向锁。</li><li>释放偏向锁需要等待全局安全点(在这个时间点上没有正在执行的字节码)。<ul><li>- 首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，</li><li>- 如果线程还活着，说明此时发生了竞争，则偏向锁升级为轻量级锁，然后刚刚被暂停的线程会继续往下执行同步代码。</li></ul></li></ul></li></ul></blockquote><h5>3.6 轻量级锁</h5><p>引入轻量级锁的主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p><p><strong>⭐轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><p>轻量级锁的加锁过程：</p><blockquote><p>1.当使用轻量级锁(锁标识位为00)时，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(注:锁记录中的标识字段称为Displaced Mark Word)。</p><p>2.将对象头中的MarkWord复制到栈桢中的锁记录中之后，虚拟机将尝试使用CAS将对象头中Mark Word替换为指向该线程虚拟机栈中锁记录的指针，此时如果没有线程占有锁或者没有线程竞争锁，则当前线程成功获取到锁，然后执行同步块中的代码。</p><p>3.如果在获取到锁的线程执行同步代码的过程中，另一个线程也完成了栈桢中锁记录的创建，并且已经将对象头中的MarkWord复制到了自己的锁记录中，然后尝试使用CAS将对象头中的MarkWord修改为指向自己的锁记录的指针，但是由于之前获取到锁的线程已经将对象头中的MarkWord修改过了(并且现在还在执行同步体中的代码,即仍然持有着锁)，所以此时对象头中的MarkWord与当前线程锁记录中MarkWord的值不同，导致CAS操作失败，然后该线程就会不停地循环使用CAS操作试图将对象头中的MarkWord替换为自己锁记录中MarkWord的值，(当循环次数或循环时间达到上限时停止循环)如果在循环结束之前CAS操作成功，那么该线程就可以成功获取到锁，如果循环结束之后依然获取不到锁，则锁获取失败，对象头中的MarkWord会被修改为指向重量级锁的指针，然后这个获取锁失败的线程就会被挂起，阻塞了。</p><p>4.当持有锁的那个线程执行完同步体之后，使用CAS操作将对象头中的MarkWord还原为最初的状态时(将对象头中指向锁记录的指针替换为Displaced Mark Word )，发现MarkWord已被修改为指向重量级锁的指针，因此CAS操作失败，该线程会释放锁并唤起阻塞等待的线程，开始新一轮夺锁之争，而此时，轻量级锁已经膨胀为重量级锁，所有竞争失败的线程都会阻塞，而不是自旋。</p></blockquote><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>试用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章了解了synchronized的基本使用方式之后，接下来我们来深入了解了解其底层原理，并且说明对它的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从卖票程序初步看synchronized的特性</title>
    <link href="http://yoursite.com/2019/02/10/thread/%E4%BB%8E%E5%8D%96%E7%A5%A8%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5%E7%9C%8Bsynchronized%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/02/10/thread/从卖票程序初步看synchronized的特性/</id>
    <published>2019-02-10T12:33:14.847Z</published>
    <updated>2019-02-13T02:30:31.538Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第五篇，在多线程学习和编程中，synchronized都是我们第一个要碰见的关键字，它很重要，因为它被认为还有优化的空间，并且它代表的是互斥锁的基本思想，JDK或者其他地方的源码随处可见，本文用一个卖票程序来切入synchronized的学习，从语法和使用上进行全面了解，并且对其引申出来的一些概念进行说明。</p><a id="more"></a><h2>1. 线程安全问题产生原因</h2><ul><li>存在共享数据</li><li>存在多条线程共同操作这些共享数据</li></ul><h2>2. 线程安全问题解决方法</h2><p>上面的问题归根结底是由于两个线程访问相同的资源造成的。对于并发编程，需要采取措施防止两个线程来访问相同的资源。</p><p>一种措施是当资源被一个线程访问时，为其加锁。第一个访问资源的线程必须锁定该资源，是其他任务在资源被解锁前不能访问该资源。</p><p>基本上所有的并发模式在解决线程安全问题时，都采用“序列化访问临界资源”的方案。即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。</p><p>这里来好好谈谈<code>Synchronized</code>实现加锁的方式。</p><h2>3. synchronized修饰符</h2><p><code>synchronized</code>：可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”.</p><p><code>synchronized</code>满足了以下重要特性：</p><ul><li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块进行访问，互斥性也称为操作的原子性。</li><li>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致</li></ul><p>⭐<code>synchronized</code>锁的不是代码，是对象！</p><h5>3.1 不使用synchronized会出现线程不安全问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sellTicket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SellTicket sellTicket = <span class="keyword">new</span> SellTicket();</span><br><span class="line"><span class="comment">//同时开启五个线程去卖票</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某一次运行的结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread2,还剩2</span><br><span class="line">thread1,还剩2</span><br><span class="line">thread3,还剩2</span><br><span class="line">thread4,还剩0</span><br><span class="line">thread5,还剩0</span><br></pre></td></tr></table></figure><p>很显然，多个线程之间打架了，数据混乱了。这是因为，多个线程同时操作<code>run（）</code>方法，对<code>count</code>进行修改，进而造成错误。</p><h5>3.2 使用synchronized来加锁</h5><p>对卖票的核心方法上加上<code>synchronized</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者写成同步代码块的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果只有一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1 count:4</span><br><span class="line">thread4 count:3</span><br><span class="line">thread5 count:2</span><br><span class="line">thread3 count:1</span><br><span class="line">thread2 count:0</span><br></pre></td></tr></table></figure><p>结果是正确的，可以看出代码A和代码B的区别就是在<code>sellTicket()</code>方法上加上了<code>synchronized</code>修饰。</p><p><strong>说明</strong>：当多个线程访问<code>MyThread</code> 的<code>run</code>方法的时候，如果使用了<code>synchronized</code>修饰，那个多线程就会以排队的方式进行处理（这里排队是按照CPU分配的先后顺序而定的），一个线程想要执行<code>synchronized</code>修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行<code>synchronized</code>代码体的内容，如果拿不到锁的话，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且多个线程同时去竞争这把锁，也就是会出现锁竞争的问题。</p><h5>3.3 一个对象有一把锁！不同对象不同锁！</h5><p>每次开启一个线程就new一个对象的话，即对每个不同的对象加锁，则互不干扰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程任务<code>SellTicket()</code>无论给不给<code>sellTicket()</code>加锁，结果都是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1,还剩4</span><br><span class="line">thread2,还剩4</span><br><span class="line">thread3,还剩4</span><br><span class="line">thread5,还剩4</span><br><span class="line">thread4,还剩4</span><br></pre></td></tr></table></figure><p>这是因为我这里是五个不同的对象，每个对象各自获取自己的锁，互不影响，所以都是4.</p><p>关键字<code>synchronized</code>取得的锁都是对象锁，而不是把一段代码或方法当做锁，所以上述实例代码C中哪个线程先执行<code>synchronized</code> 关键字的方法，那个线程就持有该方法所属对象的锁，五个对象，线程获得的就是两个不同对象的不同的锁，他们互不影响的。</p><p>那么，我们在正常的场景的时候，肯定是有一种情况的就是，一个类<code>new</code>出来的所有对象会对一个变量<code>count</code>进行操作，那么如何实现哪？很简单就是加<code>static</code>，我们知道，用<code>static</code>修改的方法或者变量，在该类的所有对象是具有相同的引用的，这样的话，无论实例化多少对象，调用的都是一个方法。</p><p><code>Main</code>函数不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SellTicket</code>则在卖票方法上增加<code>static</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sellTicket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者显示地锁住<code>Class</code>对象，即锁住类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1,还剩4</span><br><span class="line">thread2,还剩3</span><br><span class="line">thread4,还剩2</span><br><span class="line">thread3,还剩1</span><br><span class="line">thread5,还剩0</span><br></pre></td></tr></table></figure><p>仔细看，我们给<code>sellTicket</code>设定为<code>static</code>静态方法，那么这个方法就从之前的对象方法上升到类级别方法，这个类所有的对象都调用的同一个方法。实现资源的共享和加锁。</p><p>上面讲的时对象锁和类锁，前者锁定的是某个实例对象，后者锁定的是Class对象。下面总结一下：</p><ul><li>有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块</li><li>若锁住的时同一个对象，一个线程在访问对象的同步代码块(同步方法)时，另一个访问对象的同步代码块(同步方法)的线程会被阻塞</li><li>同一个类的不同对象的对象锁互不干扰</li><li>类锁由于也是一种特殊的对象锁，因此表现与上述一致，只是由于一个类只有一把类锁，所以同一个类的不同对象使用类锁是同步的</li><li>类锁和对象锁互不干扰</li></ul><h2>4. Synchronized锁重入</h2><h5>4.1 什么是可重入锁</h5><p>锁的概念就不用多解释了,当某个线程A已经持有了一个锁,当线程B尝试进入被这个锁保护的代码段的时候.就会被阻塞.</p><p><strong>⭐而锁的操作粒度是&quot;线程”,而不是调用.同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁,这就是可重入锁。</strong></p><h5>4.2 可重入锁的小例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDubbo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method1..."</span>);</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method2..."</span>);</span><br><span class="line">method3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method3..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SyncDubbo syncDubbo = <span class="keyword">new</span> SyncDubbo();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">syncDubbo.method1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码向我们演示了，如何在一个已经被<code>synchronized</code>关键字修饰过的方法再去调用对象中其他被<code>synchronized</code>修饰的方法。</p><h5>4.3 为什么要可重入</h5><p>我们上一篇文章中介绍了“一个对象一把锁，多个对象多把锁”，可重入锁的概念就是：<strong>自己可以获取自己的内部锁</strong>。</p><p><strong>假如有1个线程T获得了对象A的锁，那么该线程T如果在未释放前再次请求该对象的锁时</strong>，如果没有可重入锁的机制，是不会获取到锁的，这样的话就会出现死锁的情况。</p><p>就如代码A体现的那样，线程T在执行到<code>method1（）</code>内部的时候，由于该线程已经获取了该对象<code>syncDubbo</code> 的对象锁，当执行到调用<code>method2（）</code> 的时候，会再次请求该对象的对象锁，如果没有可重入锁机制的话，由于该线程T还未释放在刚进入<code>method1（）</code> 时获取的对象锁，当执行到调用<code>method2（）</code> 的时候，就会出现死锁。</p><h5>4.4 可重入锁到底有什么用哪？</h5><p>正如上述代码A和（4.3）中解释那样，最大的作用是避免死锁。假如有一个场景：用户名和密码保存在本地txt文件中，则登录验证方法和更新密码方法都应该被加<code>synchronized</code>，那么当更新密码的时候需要验证密码的合法性，所以需要调用验证方法，此时是可以调用的。</p><h5>4.5  什么是死锁？</h5><p>线程A当前持有互斥所锁<code>lock1</code>，线程B当前持有互斥锁<code>lock2</code>。接下来，当线程A仍然持有<code>lock1</code>时，它试图获取<code>lock2</code>，因为线程B正持有<code>lock2</code>，因此线程A会阻塞等待线程B对<code>lock2</code>的释放。如果此时线程B在持有<code>lock2</code>的时候，也在试图获取<code>lock1</code>，因为线程A正持有<code>lock1</code>，因此线程B会阻塞等待A对<code>lock1</code>的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p><p>一个例子来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">System.out.println(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">System.out.println(<span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">DeadLock d = <span class="keyword">new</span> DeadLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">d.a();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">d.b();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>产生死锁的原因主要是：</strong></p><ul><li>（1） 因为系统资源不足。</li><li>（2） 进程运行推进的顺序不合适。</li><li>（3） 资源分配不当等。</li></ul><p><strong>如何解决死锁：</strong></p><ul><li>尽量一个线程只获取一个锁。</li><li>一个线程只占用一个资源。</li><li>尝试使用定时锁，至少能保证锁最终会被释放。</li></ul><h5>4.6 可重入锁支持在父子类继承的环境中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">super</span>.doSomething();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行子类的方法的时候,先获取了一次<code>Widget</code>的锁,然后在执行<code>super</code>的时候,就要获取一次,如果不可重入,那么就跪了.</p><p>在这里，可能会产生疑问：</p><blockquote><p>重入”代表一个线程可以再次获得同一个对象的锁。可是你给出的代码示例中，我理解的是一个线程调用<code>Child</code>的<code>doSomething</code>方法前或得了<code>Child</code>对象的锁，<code>super.doSomething</code>方法调用时，次线程获得了<code>Child</code>对象父对象的锁。两个锁属于不同的对象，这还算是重入吗？</p></blockquote><p>解释：当<code>Child</code>实例对象调用<code>doSomething</code>方法时，此时持有的是<code>Child</code>实例对象的锁，之后调用<code>super.doSomething();</code>，这时仍然对于<code>Child</code>实例对象加锁，因为此时仍然使用的是<code>Child</code>实例对象内存空间的数据。</p><p>至于这句话的理解，就牵涉到继承的机制：</p><blockquote><p>在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。</p></blockquote><p>之所以网上有很多说只继承<code>protected</code>或者<code>private</code>的，是因为从语言的角度出发的：</p><p><img src="https://uploadfiles.nowcoder.net/images/20171019/1829253_1508380548300_1372D420D0F13C1126C6FCB3DC35A515" alt="image"></p><p>从内存的角度来看，的确是继承了的，可以写一个简单的继承类，debug看子类的属性是否存在父类的private属性，事实证明是有的。</p><p>针对这里有人说：不是创建一个父类对象，而只是创建一个父类空间并进行相应的初始化。对此，我一开始也是这么想的，不过当我看到这个答案的时候，又觉得很有道理：</p><blockquote><p>会创建父类对象。《Java编程思想》（第四版）129页，当创建一个导出类对象时，该对象包含了一个基类的子对象，这子对象与你用基类直接创建的对象是一样的，二者区别在于后者来源于外部，而基类的子对象被包装在导出类对象内部。</p></blockquote><h2>5. 发生异常时会自动释放锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" , i= "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                Integer.parseInt(<span class="string">"a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SyncException se = <span class="keyword">new</span> SyncException();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                se.operation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t1 , i= 2</span><br><span class="line">t1 , i= 3</span><br><span class="line">t1 , i= 4</span><br><span class="line">t1 , i= 5</span><br><span class="line">t1 , i= 6</span><br><span class="line">t1 , i= 7</span><br><span class="line">t1 , i= 8</span><br><span class="line">t1 , i= 9</span><br><span class="line">t1 , i= 10</span><br><span class="line">java.lang.NumberFormatException: For input string: &quot;a&quot;</span><br><span class="line">    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">    //其他输出信息</span><br></pre></td></tr></table></figure><p>关于<code>synchronized</code>的优化放到后文去讲。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第五篇，在多线程学习和编程中，synchronized都是我们第一个要碰见的关键字，它很重要，因为它被认为还有优化的空间，并且它代表的是互斥锁的基本思想，JDK或者其他地方的源码随处可见，本文用一个卖票程序来切入synchronized的学习，从语法和使用上进行全面了解，并且对其引申出来的一些概念进行说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程重要的相关方法</title>
    <link href="http://yoursite.com/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/10/thread/线程重要的相关方法/</id>
    <published>2019-02-10T09:41:16.298Z</published>
    <updated>2019-02-10T09:41:44.654Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第四篇，本篇文章主要来看看线程相关的几个重要方法。</p><a id="more"></a><h2>wait和sleep</h2><p>他们最基本的差异是：</p><ul><li><code>wait</code>是<code>Object</code>的一个方法，<code>sleep</code>是<code>Thread</code>类的方法</li><li><code>sleep</code>可以在任何地方使用，但是<code>wait</code>方法只能在<code>synchronied</code>方法或<code>synchronied</code>块中使用</li></ul><p>本质的区别是：</p><ul><li><code>Thread.sleep</code>只会让出CPu，不会导致锁行为的改变</li><li><code>Object.wait</code>不仅让出CPU，还会释放已经占用的同步资源锁</li></ul><p>这个区别也就解释了为什么<code>wait</code>方法只能在<code>synchronied</code>方法或<code>synchronied</code>块中使用，因为没有获取过锁哪里来的释放锁呢？所以释放锁的前提是要获取锁。</p><p>下面来验证一下，眼见为实！</p><p><img src="http://bloghello.oursnail.cn/thread4-1.jpg" alt="image"></p><p>对于<code>sleep</code>来说是没有锁的要求的，既不用获取锁也不用释放锁，关于这一点就不再验证了。</p><h2>notify和notifyAll</h2><p>先来了解一下锁池和等待池的概念。</p><ul><li>锁池EntryLisy</li></ul><blockquote><p>假设线程A已经拥有了某个对象(不是类)的锁，而其他线程B、C想要调用这个对象的某个synchronized方法或块，由于B、C线程在进入对象的synchronized方法或块之前必须先获得该对象锁得拥有权，而恰巧该对象的锁正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待所得释放，这个地方就是该对象得锁池。</p></blockquote><ul><li>等待池WaitSet</li></ul><blockquote><p>假设线程A调用了某个对象的wait方法后，线程A就会释放该对象得锁，同时线程A句进入到该对象得等待池中，进入到等待池中得线程不会去竞争该对象的锁。</p></blockquote><p><code>notify</code>的作用就是<strong>随机</strong>唤醒<strong>一个</strong>线程进入等待池的线程，而<code>notifyAll</code>是唤醒所有处于等待池中线程，唤醒之后就可以再去竞争获得锁的机会了。</p><p>刚才的例子稍微改造一下，来了解一下<code>notify</code>的作用。还拿刚才那个例子：</p><p><img src="http://bloghello.oursnail.cn/thread4-2.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/thread4-3.jpg" alt="image"></p><h2>yield</h2><p><img src="http://bloghello.oursnail.cn/thread4-4.jpg" alt="image"></p><p>当调用<code>Thread.yield()</code>函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。并且它也不会释放当前线程占用的锁。</p><p><code>yield()</code>与无参的<code>wait()</code>的区别：</p><ul><li>执行<code>yield()</code>后，当前线程由运行状态变为就绪状态。执行<code>wait</code>后，当前线程会失去对象的锁，状态变为<code>WAITING</code>状态。</li><li>执行<code>yield()</code>后，当前线程不会释放锁。执行<code>wait</code>后，当前线程会释放锁。</li></ul><p>比较简单，就不举例了。</p><h2>interrupt</h2><p>它只是通知线程应该中断了。</p><ul><li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个<code>interruptedException</code>异常</li><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><p>也就是说，中断一个线程是由被调用的线程状态和自己程序判断决定的。</p><ul><li>阻塞状态下，线程会立即退出，并抛出异常</li><li>正常状态下，需要被调用的线程检查中断标志位，然后再根据中断标志位自行地停止线程</li></ul><p>下面写一个demo来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable interruptTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程</span></span><br><span class="line">                    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                        i++;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" ("</span> + Thread.currentThread().getState() + <span class="string">") loop "</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ("</span> + Thread.currentThread().getState() + <span class="string">") catch InterruptedException."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(interruptTask, <span class="string">"t1"</span>);</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is new."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.启动“线程t1”</span></span><br><span class="line">        t1.start();                      </span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.主线程休眠300ms，然后主线程给t1发“中断”指令。</span></span><br><span class="line">        Thread.sleep(<span class="number">400</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.主线程休眠300ms，然后查看t1的状态。</span></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted now."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 (NEW) is new.</span><br><span class="line">t1 (RUNNABLE) is started.</span><br><span class="line">t1 (RUNNABLE) loop 1</span><br><span class="line">t1 (RUNNABLE) loop 2</span><br><span class="line">t1 (RUNNABLE) loop 3</span><br><span class="line">t1 (TIMED_WAITING) is interrupted.</span><br><span class="line">t1 (RUNNABLE) catch InterruptedException.</span><br><span class="line">t1 (TERMINATED) is interrupted now.</span><br></pre></td></tr></table></figure><p>首先，是就绪状态，为<code>new</code>；接下来启动这个线程，状态变为<code>started</code>，由于此时一切安好，没有“打扰”这个线程的执行，所以每隔100毫秒打印一句<code>(RUNNABLE) loop i</code>出来；在400毫秒的安好之后，给他一个<code>t1.interrupt();</code>，此时线程可能恰好在执行<code>sleep</code>睡觉呢，这个<code>interrupt</code>一看你在阻塞(睡觉)，那还得了，立马停止这个线程并且抛出异常。</p><p>但是话说回头，本程序还用了if判断，只要标志位为<code>false</code>就不停循环，一旦标志位变为<code>true</code>则立马退出循环。所以即使你不睡觉，但是我还是能通过这个If来终止你的循环。</p><h2>join</h2><p><code>join</code>是加入的意思，非常形象生动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die.</span></span><br><span class="line"><span class="comment"> * 调用方线程（调用join方法的线程）执行等待操作，</span></span><br><span class="line"><span class="comment"> * 直到被调用的线程（join方法所属的线程）结束，再被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现如下：</p><p><img src="http://bloghello.oursnail.cn/thread4-5.jpg" alt="image"></p><p>我们知道<code>wait</code>是需要释放当前线程所占的对象锁的，而<code>join</code>基于<code>wait</code>实现，显然是可以的。</p><p>这里判断如果线程还在运行中的话，则继续等待，如果指定时间到了，或者线程运行完成了，则代码继续向下执行，调用线程就可以执行后面的逻辑了。</p><p>但是在这里没有看到哪里调用<code>notify</code>或者<code>notifyAll</code>方法，如果没有调用的话，那调用方线程会一直等待下去，那是哪里调用了唤醒它的方法呢？通过查证得知，原来在线程结束时，java虚拟机会执行该线程的本地<code>exit</code>方法，这个<code>exit</code>方法里面会调用<code>notifyAll</code>方法，唤醒所有等待的线程。</p><p>下面来两个例子来彻底理解它的用法。</p><p>例子一：有耐心的男孩：</p><p><img src="http://bloghello.oursnail.cn/thread4-6.jpg" alt="image"></p><blockquote><p>男孩和女孩准备出去逛街</p><p>女孩开始化妆,男孩在等待。。。</p><p>女孩化妆完成！，耗时5000</p><p>男孩和女孩开始去逛街了</p></blockquote><p>就是男孩和女孩准备去逛街，女孩要化妆先，等女孩化妆完成了，再一起去逛街。</p><p>例子二：没有耐心的男孩：</p><p><img src="http://bloghello.oursnail.cn/thread4-7.jpg" alt="image"></p><blockquote><p>男孩和女孩准备出去逛街</p><p>女孩开始化妆,男孩在等待。。。</p><p>男孩等了2000, 不想再等了，去逛街了</p><p>女孩化妆完成！，耗时5000</p></blockquote><p>男孩等了<code>join(time)</code>中的<code>time</code>时间，如果这个<code>time</code>时间到达之后，女孩所在的线程还没执行完，则不等待了，继续执行后面的逻辑，就是不等女孩了，自己去逛街。</p><h2>总结</h2><p>了解了这些核心方法之后，就可以对下面这幅图简单说一说啦：</p><p><img src="http://bloghello.oursnail.cn/thread2-9.jpg" alt="image"></p><p>首先是<code>new Thread()</code>只是新建状态，只有<code>start</code>之后才会进入<code>runnable</code>状态，注意这个状态里面可能有两种状态，一种是正在运行，即<code>running</code>，还有一种是就绪状态即<code>ready</code>，这两个状态归属于一类的原因是他们之间是在不断切换的，即CPU的时间片内临幸到这个进程，这个进程中有若干个线程的话，就会高速地切换各个线程逐个执行，达到宏观上是并行执行的效果。我们知道<code>yield</code>是给线程调度器一个暗示让出当前执行的线程的时间片，至于这个线程调度器听不听那就不知道了，所以存在一定的随机性。如果正常执行结束就进入最后的终止状态。往右边看，如果发生带时间的超时等待，如<code>sleep(100)</code>，本线程会阻塞，让出CPU执行权并且不改变锁状态，与之区别的是<code>wait(100)</code>这个方法不仅让出CPU执行权，还会释放锁，所以要调用<code>wait</code>方法必然要先获取锁，所以一般都是在<code>synchronized</code>中调用它。至于<code>join(100)</code>是指阻塞当前线程，让其他的线程先执行，底层是<code>wait</code>所以也会释放锁。超时等待只要等它时间过了就可以跳出阻塞状态了，或者用<code>notify</code>或者<code>interrupt</code>之类的来唤醒或者打断它。往左下角看，是锁获取的时候可能发生阻塞，这个时候只能等其他线程释放锁才行了。往左边看，是无限期等待的代表，唤醒手段与有限期等待是一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第四篇，本篇文章主要来看看线程相关的几个重要方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的状态</title>
    <link href="http://yoursite.com/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/02/10/thread/线程的状态/</id>
    <published>2019-02-10T07:36:13.461Z</published>
    <updated>2019-02-10T07:36:38.852Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第三篇，主要介绍一下线程的几个状态的含义。</p><a id="more"></a><p><code>Thread</code>类源码中规定了几种线程的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实源码中已经详细说明了这几种状态的含义以及发生的时机。下面还是再看看：</p><ul><li>新建(<code>new</code>)：创建后尚未启动的线程的状态</li><li>运行(<code>Runnable</code>)：包含<code>Running</code>和<code>Ready</code>两种状态</li><li>无限期等待(<code>Waiting</code>)：不会被分配CPU执行时间，需要显式被唤醒<ul><li>无<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>无<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.park()</code>方法</li></ul></li><li>限期等待(<code>Timed Waiting</code>)：不会被分配CPU执行时间，在一定时间后会由系统自动唤醒<ul><li><code>Thread.sleep()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.parkNanos()</code>方法</li><li><code>LockSupport.parkUntil()</code>方法</li></ul></li><li>阻塞(<code>Blocked</code>)：等待获取排他锁</li><li>结束(<code>Terminated</code>)：已终止线程的状态，线程已经结束执行</li></ul><p>既然有这么多线程状态，那么必然会存在状态的转换，他们的状态是如何转换的呢？下面这张图就是比较全面的状态转换图：</p><p><img src="http://bloghello.oursnail.cn/thread2-9.jpg" alt="image"></p><p>初学者看到这张图一张是比较晕的，各种乱七八糟的东西堆在这里实在是难以下咽，不过一开始不能完全看懂是很正常的，需要进一步地学习一些细节，不断地来回顾，总有一天就会真正理解了。</p><p>下面就是要详细说说<code>Thread</code>类里面的一些方法啦，理解了这些方法，状态的切换图便一目了然。为了限制篇幅，本文先说到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第三篇，主要介绍一下线程的几个状态的含义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程之传参和返回值处理</title>
    <link href="http://yoursite.com/2019/02/10/thread/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/10/thread/java多线程之传参和返回值处理/</id>
    <published>2019-02-10T06:36:37.569Z</published>
    <updated>2019-02-15T14:10:58.702Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第二篇，对于传参和返回值的问题，是面试中关于多线程这一块问得比较多的问题了，这里进行详细的说明。</p><a id="more"></a><h2>一、如何给run()方法传参</h2><p>我们知道多线程是通过<code>star()</code>方法让线程处于准备就绪状态，而实际运行的业务逻辑是放在<code>run()</code>方法体中的，但是<code>run()</code>方法是没有参数的方法，实际的业务场景中，我们可能需要向方法体中传递参数，实现的方式主要有三种：</p><ul><li>构造函数传参，这个在上一篇文章中已经演示了。</li><li>成员变量传参，这个就是依靠<code>set</code>方法。</li><li>回调函数传参，这个稍微特殊一点。这里说明一下。</li></ul><p>上面的两种向线程中传递数据的方法是最常用的。但这两种方法都是<code>main</code>方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。</p><p>然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的<code>run</code>方法中产生了3个随机数，然后通过<code>Work</code>类的<code>process</code>方法求这三个随机数的和，并通过<code>Data</code>类的<code>value</code>将结果返回。从这个例子可以看出，在返回<code>value</code>之前，必须要得到三个随机数。也就是说，这个 <code>value</code>是无法事先就传入线程类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span>  value =  <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Work</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">process</span><span class="params">(Data data, Integer[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>  ( <span class="keyword">int</span>  n : numbers) &#123;</span><br><span class="line">            data.value += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">MyThread3</span>  <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Work work;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">MyThread3</span><span class="params">(Work work)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span> .work = work;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.随机生成3个数放进数组中</span></span><br><span class="line">        java.util.Random random =  <span class="keyword">new</span>  java.util.Random();</span><br><span class="line">        Data data =  <span class="keyword">new</span>  Data();</span><br><span class="line">        <span class="keyword">int</span>  n1 = random.nextInt( <span class="number">1000</span> );</span><br><span class="line">        <span class="keyword">int</span>  n2 = random.nextInt( <span class="number">2000</span> );</span><br><span class="line">        <span class="keyword">int</span>  n3 = random.nextInt( <span class="number">3000</span> );</span><br><span class="line">        Integer[] numbers = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">        numbers[<span class="number">0</span>] = n1;</span><br><span class="line">        numbers[<span class="number">1</span>] = n2;</span><br><span class="line">        numbers[<span class="number">2</span>] = n3;</span><br><span class="line">        <span class="comment">//调用函数去计算这三个数之和，计算的结果存在Data实例中的value属性中</span></span><br><span class="line">        <span class="comment">//这里process相当于回调函数，我调用这个函数，给我一个计算结果</span></span><br><span class="line">        work.process(data, numbers);    </span><br><span class="line">        System.out.println(String.valueOf(n1) +  <span class="string">"+"</span>  + String.valueOf(n2) +  <span class="string">"+"</span></span><br><span class="line">                + String.valueOf(n3) +  <span class="string">"="</span>  + data.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t =  <span class="keyword">new</span>  MyThread3( <span class="keyword">new</span>  Work());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一次的执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">707+678+173=1558</span><br></pre></td></tr></table></figure><p>在上面代码中的<code>process</code>方法被称为回调函数。从本质上说，回调函数就是事件函数。在<code>Windows API</code>中常使用回调函数和调用API的程序之间进行数据交互。因此，调用回调函数的过程就是最原始的引发事件的过程。在这个例子中调用了<code>process</code>方法来获得数据也就相当于在<code>run</code>方法中引发了一个事件。</p><h2>二、如何处理线程返回值</h2><p>由于线程相当于一个异步的处理函数，想要获取它的结果就不能像传统的获取它的<code>return</code>的值那么简单了，主要问题就在于它什么时候能处理好是不知道的，需要一定的机制去等待它处理好了再去获取它的处理结果。方式一般有三种。</p><h5>2.1 主线程等待法</h5><p>这个方法是最简单也是最容易想到的处理方式。下面搞个实例来看看大概是如何操作的。</p><p>首先写一个类，写这个的含义是，假如主线程不等待，将会一口气执行到最后一行，此时子线程可能还没执行完。就会出现打印空。</p><p><img src="http://bloghello.oursnail.cn/thread2-1.jpg" alt="image"></p><p>那么我们的主线程如何获取到子线程中赋予的值呢？一种方式就是死等，不停地轮询看你的值是否已经计算好了，一旦计算好就可以拿到这个值。类似于以下：</p><p><img src="http://bloghello.oursnail.cn/thread2-2.jpg" alt="image"></p><p>其实这就是自旋，即CPU停在这里等待，不能干其他事情，这必然会大大浪费CPU资源，所以虽然这种方式实现起来非常简单，但是不适合用。另外的缺点就是代码臃肿，比如我要等待的值不止一个，有多个，那是不是要写多个while循环来等待呢？此外，我们大多时候根本不知道这个子线程到底要执行多久，因为我们这里是每隔100毫秒轮询一次，那假如这个值在这100毫秒内值已经有了，那么是不能立即获取的。</p><p>针对以上不能精准控制的缺点，这里便有了第二种方法。</p><h2>Join方法</h2><p><code>Thread</code>类中的<code>join</code>方法可以阻塞当前线程以等待子线程处理完毕。</p><p><img src="http://bloghello.oursnail.cn/thread2-3.jpg" alt="image"></p><p>在这里，由于是在主线程中调用的<code>join</code>，所以阻塞主线程，让子线程执行完毕再继续执行。</p><p>这种方法更简单，但是存在多个子线程的情况下，做到灵活以及精准控制是做不到的。</p><h2>Callable接口实现</h2><p>JAVA提供了有返回值的任务，即实现了<code>Callable</code>接口的任务，执行这个任务之后可以获取一个叫做<code>Futrue</code>的对象，通过<code>get()</code>就可以获取<code>Callable</code>任务返回的内容。</p><p>具体是如何获取返回的内容呢？有两种方式，一个是通过<code>FutureTask</code>这个类来获取，一个是通过线程池获取。</p><p>对于第一种方式，我们通过例子来理解。</p><p>先新建一个实现了<code>Callable</code>接口的任务：</p><p><img src="http://bloghello.oursnail.cn/thread2-5.jpg" alt="image"></p><p>把<code>Callable</code>任务放进<code>FutureTask</code>中，这个<code>FutureTask</code>再放进<code>Thread</code>中去执行：</p><p><img src="http://bloghello.oursnail.cn/thread2-4.jpg" alt="image"></p><p>发现我们的程序并没有显示地等待，<code>FutureTask</code>的<code>get()</code>方法完成了等待和获取返回值。下面来看看<code>Future</code>的继承关系：</p><p><img src="http://bloghello.oursnail.cn/thread2-6.jpg" alt="image"></p><p>我们发现，<code>FutureTask</code>实质上都是<code>Runnable</code>接口的实例，只是它还是<code>Futrue</code>接口的实例，所以不仅可以作为一个线程任务被执行，还可以接受一个<code>Callable</code>接口去接受它的返回值。因此是一个升级版的<code>Runnable</code>实例。</p><p>说完了<code>FutureTask</code>的实现方式，下面再来看看另一种方式，即线程池来实现。关于线程池，后文还会详细介绍，这里只是简单先运用一下。</p><p><img src="http://bloghello.oursnail.cn/thread2-7.jpg" alt="image"></p><p>达到了一样的效果。我们来分析分析。</p><p><img src="http://bloghello.oursnail.cn/thread2-8.jpg" alt="image"></p><p>我们发现，其实两种方式的根本就是<code>Future</code>这个接口，第一种是直接用了<code>FutureTask</code>这个类来手动实现，即不仅需要它接收一个<code>Callable</code>任务，还需要将其作为一个线程任务去手动执行。而第二种方式就比较简单了，有了线程池，我直接把<code>Callable</code>任务扔线程池去<code>submit</code>，就可以得到一个可以获取返回值的<code>Future</code>类型对象，就可以根据这个对象获取到值了。</p><p>所以两种方式本质上是一样一样的。</p><p>下面补充一下关于<code>Runnable</code>和<code>Callable</code>两者的区别：</p><p>表面区别：</p><ul><li><code>Runnable</code>不返回任务执行结果，<code>Callable</code>可返回任务执行结果</li><li><code>Callable</code>在任务无法计算结果时抛出异常，而<code>Runnable</code>不能</li></ul><p>本质区别：</p><ul><li><code>Runnable</code>的<code>call</code>方法是被线程调用的，在<code>run</code>方法中是异步执行的；而<code>callable</code>的<code>call</code>方法不是异步执行的，是由<code>Future</code>的<code>run</code>方法调用的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第二篇，对于传参和返回值的问题，是面试中关于多线程这一块问得比较多的问题了，这里进行详细的说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程基本知识梳理</title>
    <link href="http://yoursite.com/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/10/thread/线程基本知识梳理/</id>
    <published>2019-02-10T04:15:17.009Z</published>
    <updated>2019-02-10T04:33:58.796Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第一篇，主要说明基本概念，这是面试中最基本的要会的东西，如果这些都回答不了，基本上就没有机会了，本文从源码稍微深入一点去探讨常见的基本概念。本文并不会从最最最最基本的知识开始说起，将不费笔墨直击要害，所以需要一点多线程的基本知识才行，这也符合本博客的宗旨，即知识点再次提炼和升级。</p><a id="more"></a><h2>一、进程和线程的区别</h2><p>这一块详见 <a href="http://fourcolor.oursnail.cn/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">面试-进程与线程</a> 里面的内容，相信已经够用了。</p><h2>二、start()和run()方法的区别</h2><p>以一个小例子入手，在主函数中尝试新建一个线程，并且以<code>t.run()</code>的形式去调用，从结果可以看出，java默认开启主线程来执行，当我们用<code>t.run()</code>去执行的时候，只是相当于简单的函数调用，因为从打印结果可以看出都是<code>main</code>进程，那么，实质上并没有新建一个子线程。</p><p><img src="http://bloghello.oursnail.cn/thread1-1.jpg" alt="image"></p><p>（注意，不是一调用就会去执行，而是说这个线程处于就绪状态，将有资格获得CPU的临幸，关于线程状态，后文会再次详细说明，关于start之后处于就绪状态这一点默认读者是清楚的，下面表述可能不会太顾及说明这一点）：</p><p><img src="http://bloghello.oursnail.cn/thread1-2.jpg" alt="image"></p><p>那么，从表象上我们已经知道，<code>run</code>只是简单的函数调用，<code>start</code>才会真正地开启一个新线程来执行，下面从源码层面来看看<code>start()</code>的基本实现方式。</p><p><img src="http://bloghello.oursnail.cn/thread1-3.jpg" alt="image"></p><p>说明一下，本源码是基于JDK1.8，我们看到它的核心实现是一个<code>native</code>方法，IDEA上已经看不了，只好去看看<code>openJDK</code>了。</p><p>直接打开网址： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/f0b93fbd8cf8/src/share/native/java/lang/Thread.c" target="_blank" rel="noopener">Thread.c</a>  我们可以看到：</p><p><img src="http://bloghello.oursnail.cn/thread1-4.jpg" alt="image"></p><p>我们看到很多关于线程的方法，但是这里是看不到具体的实现的，我们看到上面引入了<code>jvm.h</code>的库，所以实现应该是在<code>jvm</code>相关的代码中，直接点开： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/76a9c9cf14f1/src/share/vm/prims/jvm.cpp" target="_blank" rel="noopener">jvm.cpp</a>  可以看到如下：</p><p><img src="http://bloghello.oursnail.cn/thread1-5.jpg" alt="image"></p><p>emmm，虽然不大看得懂，但是我们确实看到了<code>start()</code>会调用虚拟机去创建一个新的线程，最终再去调用<code>run</code>方法去执行。所以流程如下：</p><p><img src="http://bloghello.oursnail.cn/thread1-6.jpg" alt="image"></p><p>最终总结：</p><ul><li>调用<code>start()</code>方法会创建一个新的子线程并启动</li><li><code>run()</code>方法只是<code>thread</code>的一个普通方法的调用</li></ul><h2>三、Thread和Runnable是什么关系</h2><p>还是老规矩，先来翻翻源码：</p><p>我们可以看到，<code>Thread</code>是一个<code>class</code>，而<code>Runnable</code>是一个<code>interface</code>，而<code>Runnable</code>中只有一个抽象方法就是<code>run()</code>.</p><p><img src="http://bloghello.oursnail.cn/thread1-7.jpg" alt="image"></p><p>那么，我们上面说到，新建一个线程是要靠<code>start()</code>来实现的，那么<code>Runnable</code>是如何来新建一个线程呢？它不是只有一个<code>run()</code>方法吗？</p><p>此时再来看<code>Thread</code>类，它里面有大量的方法，就包含了<code>run()</code>和<code>start()</code>方法，它还有一个重要的构造函数为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>就是说，传入<code>Runable</code>接口实例，再调用<code>Thread</code>的<code>start()</code>方法创建子线程，再来调用重写的<code>run()</code>方法就可以了。下面举个例子。</p><p>先说说用<code>Thread</code>的方式来创建一个子线程类：</p><p><img src="http://bloghello.oursnail.cn/thread1-8.jpg" alt="image"></p><p>这也从侧面证明了，线程是交替执行的，但是因为属于同一个进程，共享同一个地址和资源，所以不需要进行切换，极大提高了CPU执行效率。</p><p>下面再来看看<code>Runnable</code>接口是怎么实现多线程的：</p><p><img src="http://bloghello.oursnail.cn/thread1-9.jpg" alt="image"></p><p>总结一下他们俩：</p><ul><li><code>Thread</code>是一个类，<code>Runnable</code>是一个接口，前者实现后者</li><li><code>Thread</code>有<code>start</code>方法，结合<code>run()</code>可以实现多线程，但是<code>Runnable</code>没有<code>start()</code>方法，所以要通过<code>Thread()</code>来实现，所以，两种方式最终都是通过<code>Thread</code>的<code>start()</code>来实现<code>run()</code>的多线程特性</li><li>由于JAVA是单一继承的，所以推荐多使用<code>Runnable</code>接口</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第一篇，主要说明基本概念，这是面试中最基本的要会的东西，如果这些都回答不了，基本上就没有机会了，本文从源码稍微深入一点去探讨常见的基本概念。本文并不会从最最最最基本的知识开始说起，将不费笔墨直击要害，所以需要一点多线程的基本知识才行，这也符合本博客的宗旨，即知识点再次提炼和升级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
