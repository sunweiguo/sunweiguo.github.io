<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-27T11:46:44.159Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础算法8-归并排序</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%958-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法8-归并排序/</id>
    <published>2019-02-27T11:39:19.969Z</published>
    <updated>2019-02-27T11:46:44.159Z</updated>
    
    <content type="html"><![CDATA[<p>从本文开始就要介绍O(nlogn)复杂度级别的排序算法了，首先登场的是归并排序，这个排序可以解决一些问题，会在文章的后面给出，并且是一个经典的分治思想，即先分隔再合并，将复杂的大问题瓦解为小问题，将若干小问题解决了之后大问题也就迎刃而解了。下面我们来学习一下归并排序的基本原理。</p><a id="more"></a><h2>1. 原理</h2><p>归并排序（<code>MERGE-SORT</code>）是利用归并的思想实现的排序方法，该算法采用经典的分治（<code>divide-and-conquer</code>）策略（分治法将问题分(<code>divide</code>)成一些小的问题然后递归求解，而治(<code>conquer</code>)的阶段则将分的阶段得到的各答案&quot;修补&quot;在一起，即分而治之)。</p><p>复杂度为(<code>nlogN</code>),这里采用自顶向下和递归来完成的。</p><p><img src="http://bloghello.oursnail.cn/suanfa8-1.png" alt="image"></p><p>归并排序的原理是，先把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p>归并的前提是先把要排序的序列分为若干个字序列，然后才归并。在拆分数列的时候，就要用到拆分，直到不能再拆为止。</p><blockquote><p>如一个数列{9,8,7,6,5,4,3,2,1}</p><p>先分成{9,8,7,6,5}和{4,3,2,1}</p><p>然后再分成{9,8,7}和{6,5}和{4,3}和{2,1}</p><p>然后再分{9,8}、{6}、{5}、{4}、{3}、{2}、{1}</p><p>然后再合并起来，小在的前面，大的在后面，没有比较的在后面填充数列。</p></blockquote><p>具体如何合并的呢？下面展示的最后的一步合并过程：</p><p><img src="http://bloghello.oursnail.cn/suanfa8-2.png" alt="image"></p><p>我们注意到，归并排序是需要额外的空间来辅助的。动态图为：</p><p><img src="http://bloghello.oursnail.cn/suanfa7-4.gif" alt="image"></p><h2>2. 代码</h2><h5>2.1 左右分开</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int mid = (low + high) / 2;</span></span><br><span class="line"><span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">    sort(a, low, mid);</span><br><span class="line">        <span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">    sort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>2.2 合并过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//临时指针</span></span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">        a[k2 + low] = temp[k2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于它的理解，一句话就是先对半分，分到不能分为止，然后再倒过来将卡擦分开的两组数进行比较合并成有序序列，最终逐渐合并成有序序列。</p><h2>3. 归并排序应用1–小和问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序的应用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  例子：</span></span><br><span class="line"><span class="comment"> *  [1,3,4,2,5]</span></span><br><span class="line"><span class="comment"> *  1左边比1小的数，没有；</span></span><br><span class="line"><span class="comment"> *  3左边比3小的数，1；</span></span><br><span class="line"><span class="comment"> *  4左边比4小的数，1、3；</span></span><br><span class="line"><span class="comment"> *  2左边比2小的数，1；</span></span><br><span class="line"><span class="comment"> *  5左边比5小的数，1、3、4、2；</span></span><br><span class="line"><span class="comment"> *  所以小和为1+1+3+1+1+3+4+2=16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortApply1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(merge_sort(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,low,mid) +</span><br><span class="line">                sortProcess(arr,mid+<span class="number">1</span>,high) +</span><br><span class="line">                  merge(arr,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= high)&#123;</span><br><span class="line">            <span class="comment">//核心的是增加这一句，当发现arr[p1] &lt; arr[p2]时</span></span><br><span class="line">            <span class="comment">//那么p2后面的数必然都大于它，所以这一次合并过程中</span></span><br><span class="line">            <span class="comment">//p1位置比(high-p2+1)这些位置都小，那么针对这个p1位置的数字，一次性全部累计起来即可</span></span><br><span class="line">            count += arr[p1] &lt; arr[p2] ? (high-p2+<span class="number">1</span>)*arr[p1] : <span class="number">0</span>;</span><br><span class="line">            help[k++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">            help[k++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= high)&#123;</span><br><span class="line">            help[k++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;help.length;ii++)&#123;</span><br><span class="line">            arr[ii+low] = help[ii];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>4. 归并排序应用2–逆序对问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序的应用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对的数量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortApply2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(merge_sort(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortProcess(arr,low,mid) +</span><br><span class="line">                sortProcess(arr,mid+<span class="number">1</span>,high) +</span><br><span class="line">                  merge(arr,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[high-low+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= high)&#123;</span><br><span class="line">            <span class="comment">//归并的过程中发现前面大于后面的话就算一组</span></span><br><span class="line">            count += arr[p1] &gt; arr[p2] ? (high-p2+<span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">            help[k++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">            help[k++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 &lt;= high)&#123;</span><br><span class="line">            help[k++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ii=<span class="number">0</span>;ii&lt;help.length;ii++)&#123;</span><br><span class="line">            arr[ii+low] = help[ii];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本文开始就要介绍O(nlogn)复杂度级别的排序算法了，首先登场的是归并排序，这个排序可以解决一些问题，会在文章的后面给出，并且是一个经典的分治思想，即先分隔再合并，将复杂的大问题瓦解为小问题，将若干小问题解决了之后大问题也就迎刃而解了。下面我们来学习一下归并排序的基本原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法7-基本排序之冒泡、选择、插入</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%957-%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法7-基本排序之冒泡、选择、插入/</id>
    <published>2019-02-27T08:45:32.009Z</published>
    <updated>2019-02-27T08:45:53.912Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法毋庸置疑，是最重要最重要的基础算法，真正的实际应用中，往往是几种排序算法的组合，因为没有完美的算法，只有适合的算法。学好算法的第一步应该是熟练手写出基本的排序算法，本文应该被放在一篇文章，但是命运的巧合，我还是选择了递归。因为排序算法就摆在那，思想比较清晰，理解上没有难度，但是递归也摆在那，好像简单但是又无从下手。本文先从复杂度比较高但是比较简单的几种排序算法入手。这几种都是O(n^2)的时间复杂度。</p><a id="more"></a><h2>1. 冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>算法的基本步骤：</p><ul><li>比较相邻的元素。如果第一个比第二个大(注意相等不要交换，所谓冒泡是稳定的排序)，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p>动态图：</p><p><img src="http://bloghello.oursnail.cn/suanfa7-1.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 冒泡排序整体思路：每一趟的比较，都会将最大的一个数排到最后面</span></span><br><span class="line"><span class="comment">         * 0。。。。。。。n-1   第一趟一直比较到最后一个，把最大的放到对后面</span></span><br><span class="line"><span class="comment">         * 0。。。。。n-2   第二趟比较的数组长度会减少一个，因为最大的已经确定了</span></span><br><span class="line"><span class="comment">         * 0。。。。n-3    第三趟比较的就再少两个，因为两个最大的已经确定了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//两两比较交换</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>2. 选择排序</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：不断地在未排序序列中找到最小元素，交换到数组的最前面。</p><p><img src="http://bloghello.oursnail.cn/suanfa7-2.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 基本思想是：每一趟都将最小值的索引确定好，然后放到前</span></span><br><span class="line"><span class="comment">         * 所以每一趟结束之后，前面是已经排好序的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,min,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>3. 插入排序</h2><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><img src="http://bloghello.oursnail.cn/suanfa7-3.gif" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr= &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        insert_sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 插入排序主要思想是：每一趟都保证当前索引前的所有元素都小于当前索引</span></span><br><span class="line"><span class="comment">         * 比如【5,4,3,2,1】，那么第一趟是【4,5,3,2,1】，第二趟是【3,4,5,2,1】</span></span><br><span class="line"><span class="comment">         * 第三趟是【2,3,4,5,1】，第四趟是【1,2,3,4,5】</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 其实这是优化后的方法，简单的插入排序是这样子的：</span></span><br><span class="line"><span class="comment">         *    for(int i=1;i&lt;arr.length;i++)&#123;</span></span><br><span class="line"><span class="comment">         *        for(int j=i; j&gt;0 &amp;&amp; array[j-1]&gt;array[j]; j--)&#123;</span></span><br><span class="line"><span class="comment">         *           swap(array, j, j-1);</span></span><br><span class="line"><span class="comment">         *        &#125;</span></span><br><span class="line"><span class="comment">         *    &#125;</span></span><br><span class="line"><span class="comment">         * 这里的优化是考虑到原始方法要不断地进行交换，其实是没有必要的，直接赋值就好了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j-<span class="number">1</span>] &gt; tmp ;j--)&#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法毋庸置疑，是最重要最重要的基础算法，真正的实际应用中，往往是几种排序算法的组合，因为没有完美的算法，只有适合的算法。学好算法的第一步应该是熟练手写出基本的排序算法，本文应该被放在一篇文章，但是命运的巧合，我还是选择了递归。因为排序算法就摆在那，思想比较清晰，理解上没有难度，但是递归也摆在那，好像简单但是又无从下手。本文先从复杂度比较高但是比较简单的几种排序算法入手。这几种都是O(n^2)的时间复杂度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法6-关于二叉树的经典面试题分析</title>
    <link href="http://yoursite.com/2019/02/27/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%956-%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/02/27/algorithms-basic/基础算法6-关于二叉树的经典面试题分析/</id>
    <published>2019-02-27T06:45:13.480Z</published>
    <updated>2019-02-27T06:45:39.240Z</updated>
    
    <content type="html"><![CDATA[<p>掌握对树的基本操作是很重要的，这里所谓的操作是指对树的遍历，以及对树的构造等等。下面通过一些题目来好好研究研究。由于篇幅、时间以及精力有限，本文着重提取两种题型进行分析，都是高频面试问题。</p><a id="more"></a><h2>问题1</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-1.png" alt="image"></p><p>这是一道比较常见的题目，虽然难度是<code>medium</code>，但是也没有那么难，这个题目主要是要求我们根据前序遍历和中序遍历构造出整棵树。</p><p>基本的思路是：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-2.png" alt="image"></p><p>也就是说，前序遍历的第一个元素必然是整棵树的头节点，那么我在中序遍历找到头节点的位置后，就可以根据中序遍历的特点，前面的都是左子树，后面的都是右子树。找到了这一个，下面就让计算机递归去找，所以问题的关键就是第一步的缩小范围。无需关心构造树的细节。</p><p>我的解题方案是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//6.递归的停止条件，最后考虑，先考虑下面的一般情况</span></span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.根据前序遍历的结果，第一个元素就是树的root</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.根据root的值去inorder中去找，题目规定这个序列是没有重复元素的</span></span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.找到了之后，我们就可以确定root的左子树和右子树的所有元素了</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.下面就交给计算机了，我们只要考虑第一次的缩小规模，即root的左子树是什么范围，递归下去，相信它一定可以给我们一个正确的root的左子树</span></span><br><span class="line">        <span class="comment">//这个范围的确定也是很简单的，根据前序遍历和中序遍历的关系就可以获得</span></span><br><span class="line">        <span class="comment">//不过额外需要注意的是Arrays.copyOfRange是一个[)的结果集，需要注意以下边界</span></span><br><span class="line">        root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,<span class="number">1</span>+rootIndex),Arrays.copyOfRange(inorder,<span class="number">0</span>,rootIndex));</span><br><span class="line">        <span class="comment">//递归下去，相信它一定可以给我们一个正确的root的右子树</span></span><br><span class="line">        root.right = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>+rootIndex,preorder.length),Arrays.copyOfRange(inorder,rootIndex+<span class="number">1</span>,inorder.length));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.返回root，构造完毕</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题2</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-3.png" alt="image"></p><p>根据前序和后序构建的二叉树不唯一，理由是前序与后序都没有明确规定节点间的父子关系，例如下图所示：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-4.png" alt="image"></p><p>本题比较人性化，要求只要输出其中一种可能性即可。还是可以根据一般的思路，采用递归思想，对于每一个先序序列，划分出对应的根节点、左子树、右子树范围即可自上而下构建出二叉树。</p><p>例如对于上例中的先序序列[1,2,4,5,3,6,7]，第一个节点一定为根节点，第2到第i个节点为左子树，第i+1到最后一个节点为右子树，那么问题就可以简化为：<strong>如何确定左右子树分界点？</strong></p><p><img src="http://bloghello.oursnail.cn/suanfa6-5.png" alt="image"></p><p>对于这个简化过后的问题，从后序遍历序列上很容易得到答案：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-6.png" alt="image"></p><p>根据上图的思路，就可以写代码啦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组还有元素，则取出第一个元素作为root</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组长度为1 的时候直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到左子树根节点在后序遍历中的位置，找到之后，元素前面的都是左子树元素，后面除了最后一个元素都是右子树元素</span></span><br><span class="line">        <span class="keyword">int</span> leftRootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftRootVal = pre[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;post.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(post[i] == leftRootVal)&#123;</span><br><span class="line">                leftRootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">//递归构造</span></span><br><span class="line">        root.left = constructFromPrePost(Arrays.copyOfRange(pre,<span class="number">1</span>,leftRootIndex+<span class="number">2</span>),</span><br><span class="line">                                        Arrays.copyOfRange(post,<span class="number">0</span>,leftRootIndex+<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        root.right = constructFromPrePost(Arrays.copyOfRange(pre,leftRootIndex+<span class="number">2</span>,pre.length),</span><br><span class="line">                                         Arrays.copyOfRange(post,leftRootIndex+<span class="number">1</span>,post.length-<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题3</h2><p><img src="http://bloghello.oursnail.cn/suanfa6-7.png" alt="image"></p><p>到现在为止，我们对于中序排序的规则已经很熟悉，下面图示:</p><p><img src="http://bloghello.oursnail.cn/suanfa6-8.png" alt="image"></p><p>我们从这个图上可以看到，找下一个节点是可以分为几种情况的。</p><p>第一种情况，就是一个节点有右子树。比如要求节点B的下一个节点，其实是找到它的右子树的最左孩子，就是G节点。</p><p>第二种情况，就是一个节点没有右子树，此时又可以分为两种情况。</p><p>对于G这个节点来说，没有右子节点了，它的父亲节点是E，G是E的左子节点，即E的左子节点是G，那么G的下一个节点就是E。</p><p>对于E这个节点来说，也没有右子节点，它的父亲节点是B，此时E是B的右子节点，根据实际情况来说，E的下一个节点绝对不是B，因为E是B的右子节点，根据中序遍历的规则，此时肯定是先遍历B再遍历E，所以B肯定在E的前面，而不是后面，所以我们还需要再往上找父亲节点，此时B的父亲节点为A，B为A的左子节点，此时根据实际情况，A就是我们要找的E的下一个节点。</p><p>所以，对于一个没有右子节点的节点来说，只需要判断它有没有父节点并且是不是父节点的左子节点，是的话，就找到了，不是则要不断地向上找。</p><p>如果一直找到根还是找不到，像节点F，那就返回null，因为实际上F节点就是中序遍历的最后一个节点，没有所谓的下一个节点了。</p><p>将上面所述转换为图示为：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-9.png" alt="image"></p><p>总之，我们不关心当前节点的左子节点，因为它不在我们的考虑范围内，它必定出现在当前节点的前面。</p><p>我们主要就是考虑有没有右子节点，或者没有右子节点的话就考虑父亲节点。有右子节点比较简单，一直找最左边的子节点即可。但是没有右子节点的时候，就需要去查询父亲节点了。理解了这些，程序也就呼之欲出了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.判断当前节点是否有右子节点，有则去里面找</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> firstInRightTree(pNode);</span><br><span class="line">        <span class="comment">//2.没有右子节点，就需要去父节点找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3.直到找到符合条件的父节点为止，跳出循环时pNode的父节点符合条件，这个父节点就是我们要的东西</span></span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span> &amp;&amp; pNode.next.left != pNode)&#123;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到右子树中找符合条件的，显然就是找最最最左边的子节点即可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeLinkNode <span class="title">firstInRightTree</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        TreeLinkNode curr = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对比较常见的树的一些算法题进行了分析，关于树的题目还有很多，并且很多重要的题目也还每设计到，后面有时间整理一下leetcode上比较经典的二叉树的算法题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌握对树的基本操作是很重要的，这里所谓的操作是指对树的遍历，以及对树的构造等等。下面通过一些题目来好好研究研究。由于篇幅、时间以及精力有限，本文着重提取两种题型进行分析，都是高频面试问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法5-二分搜索树</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%955-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法5-二分搜索树/</id>
    <published>2019-02-26T14:29:31.521Z</published>
    <updated>2019-02-26T14:29:49.786Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。普通的二叉树其实没什么好讲的，就是最多只有两个孩子的树，而二叉搜索树赋予了它一些额外的条件，使得它有了使用的价值，例如根据它的性质，那么中序遍历出来的结果恰好就是有序的结果，故本文着重说明二叉搜索树。</p><a id="more"></a><h2>一、二叉树</h2><p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。它本身对里面的数据是没有说明要求的，只是个数要满足二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2的(i-1)次方个结点；深度为k的二叉树至多有2的k次方-1个结点；</p><p><img src="http://bloghello.oursnail.cn/suanfa5-1.png" alt="image"></p><h2>二、满二叉树和完全二叉树</h2><p>一张图就可以看出它们的区别了：</p><p><img src="http://bloghello.oursnail.cn/suanfa5-2.png" alt="image"></p><h2>三、二叉搜索树概念</h2><p><strong>二叉查找树定义</strong>：又称为是二叉排序树（<code>Binary Sort Tree</code>）或二叉搜索树,不需要是一棵完全二叉树。具有以下性质：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ul><p><strong>二叉查找树的性质</strong>：对二叉查找树进行中序遍历，即可得到有序的数列。</p><p><strong>二叉查找树的时间复杂度</strong>：它和二分查找一样，插入和查找的时间复杂度均为<code>O(logn)</code>，但是在最坏的情况下仍然会有<code>O(n)</code>的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p><p>二叉查找树的高度决定了二叉查找树的查找效率。</p><h2>四、树的定义</h2><p>就是说如果我要定义一个二叉树，那么这个<code>Node</code>如何定义呢？其实很简单，无非就是<code>left</code>,<code>right</code>,<code>val</code>这三个变量而已，也有可能是<code>key</code>和<code>value</code>这种类型，这个定义是在《算法4》上看到的，二叉搜索树判断大小的依据就是这个<code>key</code>.不必对这个纠结.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分搜索树</span></span><br><span class="line"><span class="comment">//由于Key需要能够进行比较，所以需要extends Comparable&lt;Key&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 树中的节点为私有的类, 外界不需要了解二分搜索树节点的具体实现</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Key key;</span><br><span class="line">     <span class="keyword">private</span> Value value;</span><br><span class="line">     <span class="keyword">private</span> Node left, right;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.key = key;</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">         left = right = <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Node root;  <span class="comment">// 根节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> count;  <span class="comment">// 树种的节点个数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>五、插入新节点</h2><p>查看以下动画演示了解插入新节点的算法思想：（其插入过程充分利用了二分搜索树的特性）</p><p>例如待插入数据60，首先与根元素41比较，大于根元素，则与其右孩子再进行比较，大于58由于58无右孩子，则60为58的右孩子，过程结束。（注意其递归过程）</p><p><img src="http://bloghello.oursnail.cn/%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9.gif" alt="image"></p><blockquote><p>判断node节点是否为空，为空则创建节点并将其返回（ 判断递归到底的情况）。</p></blockquote><blockquote><p>若不为空，则继续判断根元素的key值是否等于根元素的key值：若相等则直接更新value值即可。若不相等，则根据其大小比较在左孩子或右孩子部分继续递归直至找到合适位置为止。、</p></blockquote><p>代码实现(递归实现)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中插入一个新的(key, value)数据对</span></span><br><span class="line"><span class="comment">// 返回的是最后插入完成之后二叉树的根</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">    root = insert(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//********************</span></span><br><span class="line"><span class="comment">//* 二分搜索树的辅助函数</span></span><br><span class="line"><span class="comment">//********************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法</span></span><br><span class="line"><span class="comment">// 返回插入新节点后的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">insert</span><span class="params">(Node node, Key key, Value value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) == <span class="number">0</span> )</span><br><span class="line">        node.value = value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )</span><br><span class="line">        node.left = insert( node.left , key, value);</span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        node.right = insert( node.right, key, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>六、二分搜索树的查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看二分搜索树中是否存在键key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contain(root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contain</span><span class="params">(Node node, Key key)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( key.compareTo(node.key) == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( key.compareTo(node.key) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> contain( node.left , key );</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// key &gt; node-&gt;key</span></span><br><span class="line">        <span class="keyword">return</span> contain( node.right , key );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>七、二分搜索树的遍历</h2><p>这块内容其实我想删除的，但是吧，这一段对树的前中后序遍历的动态图是非常不错的，对理解树的遍历是非常有利的，所以保留在这里。下面进入正文。</p><p>遍历分为前序遍历、中序遍历以及后序遍历三种，如何理解其遍历顺序呢？</p><p>对于每个节点而言，可能会有左、右两个孩子，所以分成下图中3个点，每次递归过程中会经过这3个点。</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%81%8D%E5%8E%86%E5%8E%9F%E7%90%86.png" alt="image"></p><blockquote><p>前序遍历：先访问当前节点，再依次递归访问左右子树</p></blockquote><blockquote><p>中序遍历：先递归访问左子树，再访问自身，再递归访问右子树</p></blockquote><blockquote><p>后续遍历：先递归访问左右子树，再访问自身节点</p></blockquote><p>下面分别来看看是如何遍历的。</p><h5>7.1 前序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%89%8D%E5%BA%8F%E4%BE%BF%E5%88%A9.gif" alt="image"></p><p>我们注意看，先找到28的第一个点，然后将28返回，下面看有没有左儿子，有就先来到左儿子的节点，然后将16弹出…</p><p>最终的打印结果:</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.2 中序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>最终的打印结果:</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.3 后序遍历</h5><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>最终打印结果：</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C.png" alt="image"></p><h5>7.4 递归代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行前序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行中序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对以node为根的二叉搜索树进行后序遍历, 递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( node != <span class="keyword">null</span> )&#123;</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对非递归的写法，推荐用第二篇文章中说明的方式，那种方式具有较好的通用性。当然了，此时应该认识到学好递归的重要性了。</p><h2>八、层序遍历</h2><h5>8.1 算法思想</h5><p>层序遍历即一层一层地向下遍历，查看以下动画：</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.gif" alt="image"></p><p>查看以上动画，实现其过程需要引入先进先出的“队列”数据结构，首先将28入队，第一层遍历完毕，可进行操作，将28出队并打印。遍历第二层16、30依次入队，再出队进行打印操作，依次类推。</p><h5>8.2 代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分搜索树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们使用LinkedList来作为我们的队列</span></span><br><span class="line">    LinkedList&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span>( !q.isEmpty() )&#123;</span><br><span class="line"></span><br><span class="line">        Node node = q.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(node.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( node.left != <span class="keyword">null</span> )</span><br><span class="line">            q.add( node.left );</span><br><span class="line">        <span class="keyword">if</span>( node.right != <span class="keyword">null</span> )</span><br><span class="line">            q.add( node.right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>九、局限性来源</h2><p>它的局限性来源于哪？注意其二分搜索树的创建，如下图所示，同样的数据，可以对应不同的二分搜索树。</p><p><img src="http://bloghello.oursnail.cn/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%B1%80%E9%99%90.png" alt="image"></p><p>如上图，第一种创建情况可能是大部分人心中设想，但是第二种情况也是符合二分搜索树的特征，如此一来，二分搜索树可能退化成链表。二分搜索树的查找过程是与其高度相关，此时高度为n，时间复杂度为O(n^2)。</p><h2>十、初识红黑树</h2><p>其实二分搜索树的性能总体而言还是十分优异的，它所有的有关操作时间复杂度为O(n)，出现以上情况的概率很小，但如果创建时其数据都是有序的，那么就会令人担忧了。也许你会想到快速排序中也有此问题，不过它通过随机获取标志点的方法解决了此问题。</p><p>所以类似以上解决办法，将其顺序打乱再插入到二分搜索树即可？这是一个解决办法，但是需要一开始获取所有数据，其实这些数据是慢慢流入系统的，所以在创建其过程中才会发现数据是否几乎有序。</p><p>为了解决此问题，可以改造二叉树的实现，使得其无法退化成链表—–平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 <code>logn</code> 级别的，此概念的经典实现就是红黑树。</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、2-3树、红黑树等等。普通的二叉树其实没什么好讲的，就是最多只有两个孩子的树，而二叉搜索树赋予了它一些额外的条件，使得它有了使用的价值，例如根据它的性质，那么中序遍历出来的结果恰好就是有序的结果，故本文着重说明二叉搜索树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法4-二分查找算法</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%954-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法4-二分查找算法/</id>
    <published>2019-02-26T13:05:21.351Z</published>
    <updated>2019-02-26T13:05:48.546Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是比较常见的查找算法，但是它需要一个条件就是数组有序，因此当面试中听到有序数组这个关键词的时候，不妨往二分查找法想一想，或许它就是解开问题的钥匙。</p><a id="more"></a><p>算法思想：</p><blockquote><p>注意该算法的前提条件：有序数组。想查找元素value，先查看数组中间元素值v与value的大小，若相等则刚好，否则根据比较结果选择左、右半部分再次寻找。</p></blockquote><p>时间复杂度：</p><blockquote><p>整个查找过程可构成一棵树，时间复杂度为O(logn)。</p></blockquote><h2>问题1</h2><p>给定一个有序的数组，查找value是否在数组中，不存在返回-1。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * arr:数组</span></span><br><span class="line"><span class="comment"> * n:数组数据长度</span></span><br><span class="line"><span class="comment"> * target:就是要查找的被返回的值</span></span><br><span class="line"><span class="comment"> * while循环迭代的方式实现二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在arr[l...r]之中查找target</span></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( lo &lt;= hi )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int mid = (l + r)/2;防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归的方式实现二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( lo &gt; hi )</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( arr[mid] == target )</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &gt; target )</span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, lo, mid-<span class="number">1</span>, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, mid+<span class="number">1</span>, hi, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>问题2</h2><p><img src="http://bloghello.oursnail.cn/suanfa4-1.png" alt="image"></p><p>这就是一道经典的用二分查找解决的问题。下面给出解题答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//这边相等的话，就要找它周围的数字是否相等，直到找到一个区间为止</span></span><br><span class="line">                <span class="keyword">int</span> low = mid;</span><br><span class="line">                <span class="keyword">int</span> high = mid;</span><br><span class="line">                <span class="keyword">while</span>(low - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[low-<span class="number">1</span>] == target)&#123;</span><br><span class="line">                    low--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(high + <span class="number">1</span> &lt;= nums.length-<span class="number">1</span> &amp;&amp; nums[high+<span class="number">1</span>] == target)&#123;</span><br><span class="line">                    high++;</span><br><span class="line">                &#125;</span><br><span class="line">                res[<span class="number">0</span>] = low;</span><br><span class="line">                res[<span class="number">1</span>] = high;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我的思路很简单，就是在找到符合条件的mid之后，我就尝试在mid的两边再去找是否有相等的数字，由于是递增的数组，所以很好判断。</p><h2>问题3</h2><p><img src="http://bloghello.oursnail.cn/suanfa4-2.png" alt="image"></p><p>这是《剑指offer》上的一道题目，原本的数列一个非递减的序列，这里在中间咔了一刀变成两截，并且颠倒，那么就被划成了两段非递减的序列，并且前面的非递减数列要比后面的非递减数列要大于等于。所以，是有一定的规律的，这里还是推荐使用二分查找，只是是二分查找法的变体了。</p><p>当然了这个题目的暴力解法其实已经很简单了，就是从头开始遍历，只要出现一个数比前面一个数小，那么这个数就是原来序列的最前面的数，那么其实就是最小的数。</p><p>而二分查找在比较极端的条件下，比如元素都相等，可能就会退化为O(n)复杂度，但是如果原来的数列是一个严格递增的数列，那么还是快一点的。因为缩小的范围比较快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[right])&#123;</span><br><span class="line">                <span class="comment">//最小的元素一定在mid后面</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[right])&#123;</span><br><span class="line">                <span class="comment">//最小的元素在mid或者mid之前，注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字</span></span><br><span class="line">                <span class="comment">//比如 array = [4,6]</span></span><br><span class="line">                <span class="comment">//array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;</span></span><br><span class="line">                <span class="comment">//如果high = mid - 1，就会产生错误， 因此high = mid</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]</span></span><br><span class="line">                <span class="comment">//此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 </span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找法最主要的注意点就是边界，一定要注意边界的选取，这直接影响了程序的实现细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找是比较常见的查找算法，但是它需要一个条件就是数组有序，因此当面试中听到有序数组这个关键词的时候，不妨往二分查找法想一想，或许它就是解开问题的钥匙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法3-循环控制</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%953-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法3-循环控制/</id>
    <published>2019-02-26T10:00:17.013Z</published>
    <updated>2019-02-26T10:11:50.268Z</updated>
    
    <content type="html"><![CDATA[<p>在第一篇文章中为了说明递归如何写，所以对于链表的操作都是用递归来写的，我们发现递归写起来比较简洁，但是执行的过程有点复杂，并且往往在实际的算法中都是要将递归改成循环来做，可以一定程度上减少开销提高性能。下面我们来看看循环如何实现的。</p><a id="more"></a><h2>链表的反转</h2><p>需要验证准确性的话，可以去leetcode上去做这道题，题号为206.这道题还是比较经典的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = currentNode.next;</span><br><span class="line">            currentNode.next = newHead;</span><br><span class="line">            newHead = currentNode;</span><br><span class="line">            currentNode = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始学的时候看的答案就是这个方法，显然是要比递归好的，但是如果不理解的话，光靠背很容易出错，并且也不大背的上，如今重温这道题，其实是很简单的，我们下面用图示来阐述。</p><p>主要的思想是用两个指针，其中<code>newHead</code>指向的是反转成功的链表的头部，<code>currentHead</code>指向的是还没有反转的链表的头部：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-1.png" alt="image"></p><p>初始状态是<code>newHead</code>指向<code>null</code>，<code>currentHead</code>指向的是第一个元素，一直往后遍历直到<code>newHead</code>指向最后一个元素为止：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-3.png" alt="image"></p><p>下面展示的是其中某个时间点的指向细节：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-2.png" alt="image"></p><p>理解了上面的图示，程序就呼之欲出了。</p><h2>删除链表节点</h2><p>题目为：给一个数值，找到链表中这个等于这个数的所有节点并且删除。效果如下，比如给的数是2，则表示删除链表中所有为2的节点。</p><p><img src="http://bloghello.oursnail.cn/suanfa3-4.png" alt="image"></p><p>这个题目也是非常地经典，面试中经常会看到。我们务必要掌握。</p><p>这个其实有两种解题思路，比较简单的是增加一个虚拟的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造一个虚拟的头节点，指向head</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用一个指针指向虚拟头节点，因为虚拟头节点还要表示去重后的链表的头节点</span></span><br><span class="line">        ListNode curr = dummy;</span><br><span class="line">        <span class="comment">//进入循环，看虚拟头节点下一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果下一个节点不为空并且值是等于val的，那么就说明要删除掉这个节点</span></span><br><span class="line">            <span class="comment">//所谓的删除，只是改变指针，使得这个要删除的节点没有任何引用即可，java会自动回收它</span></span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">                ListNode delNode = curr.next;</span><br><span class="line">                curr.next = delNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明值不等于val，那么就后移一个即可</span></span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现的方式相对来说比较简单。大体的解决思路为：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-6.png" alt="image"></p><p>另一种是比较特殊的处理方式，不需要虚拟的头节点就可以实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于比较特殊的，就是head也与val相等的情况，需要出一下</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，还需要判断一下head是否为null，因为有可能这个链表全部都等于val</span></span><br><span class="line">        <span class="comment">//那么经过上一步之后这个链表已经为null了，那么就不需要进入下一步了</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时链表开头的重复元素全部剔除了，下面就是普通的后续的元素，循环判断删除即可</span></span><br><span class="line">        ListNode prev = head;</span><br><span class="line">        <span class="keyword">while</span>(prev.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.next.val == val)&#123;</span><br><span class="line">                ListNode delNode = prev.next;</span><br><span class="line">                prev.next = delNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，代码大体是相似的，特殊的处理在于一开始的节点的值与val相等的处理，所以我们需要先处理一下head以及head的后面连续的都是等于val的节点，直到处理到不为val的节点为止，即把开头相等的节点全部剔除掉，下面再继续循环判断是否相等。</p><p>关于链表的题目还有很多，由于链表数据结构比较简单，但是算法并不简单，所以面试中经常会被问道，需要好好准备一下。后面会进行相应的总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一篇文章中为了说明递归如何写，所以对于链表的操作都是用递归来写的，我们发现递归写起来比较简洁，但是执行的过程有点复杂，并且往往在实际的算法中都是要将递归改成循环来做，可以一定程度上减少开销提高性能。下面我们来看看循环如何实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法2-汉诺塔问题</title>
    <link href="http://yoursite.com/2019/02/26/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%952-%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/26/algorithms-basic/基础算法2-汉诺塔问题/</id>
    <published>2019-02-26T06:16:12.421Z</published>
    <updated>2019-02-26T06:16:36.020Z</updated>
    
    <content type="html"><![CDATA[<p>为什么还要再来说说递归问题，因为数据结构中二叉树是比较重要也是比较难的数据结构，它的结构是天生递归的，所以对于二叉树的很多操作都可以用递归来实现，因此递归这一关能尽量理解是最好的，本章从汉诺塔的问题出发，来看看递归的实现原理。</p><a id="more"></a><h2>汉诺塔问题</h2><p>这个问题估计大多数人都是知道的，汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p>抽象为数学问题：如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-1.png" alt="image"></p><p>其实核心的思想已经在上篇文章中说明了，就是数学归纳法的思想，就拿简单又不失一般性的三个盘子先说事。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-2.png" alt="image"></p><p>其实我们发现，最核心的一个状态就是：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-3.png" alt="image"></p><p>就是说，我们已经有了中间B这个符合条件的2个盘子的情况，那么我只需要将这两个想办法将这B上两个盘子放到C上就结束了。</p><p>同理，更多的盘子n，我就是想办法将n-1个符合条件的盘子放到第n个盘子上不就可以了。大概的思想如下：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-7.png" alt="image"></p><p>OK，下面展示程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> A,<span class="keyword">char</span> B,<span class="keyword">char</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(A+<span class="string">" -&gt; "</span>+C);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//上面n-1个盘子从A通过C想办法移到B上，对应上图的第一行图示</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,A,C,B);</span><br><span class="line">        <span class="comment">//将A剩下的盘子移到C上</span></span><br><span class="line">        System.out.println(A+<span class="string">" -&gt; "</span>+C);</span><br><span class="line">        <span class="comment">//这个n-1个盘子再想办法从B通过A移到C上，对应上如的第三行图示</span></span><br><span class="line">        hanoi(n-<span class="number">1</span>,B,A,C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先拿2测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   hanoi(<span class="number">2</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B</span><br><span class="line">A -&gt; C</span><br><span class="line">B -&gt; C</span><br></pre></td></tr></table></figure><p>是符合我们的预期的。并且尝试更多的时候，按照它一步一步是正确的。</p><p>如果理解了上面说的，那么这个程序是非常好理解的。但是真正想深入进递归里面，一旦多起来还是比较复杂的。其实我们可以这样理解：</p><blockquote><p>一个小朋友坐在第10排，他的作业本被小组长扔到了第1排，小朋友要拿回他的作业本，可以怎么办？他可以拍拍第9排小朋友，说：“帮我拿第1排的本子”，而第9排的小朋友可以拍拍第8排小朋友，说：“帮我拿第1排的本子”…如此下去，消息终于传到了第1排小朋友那里，于是他把本子递给第2排，第2排又递给第3排…终于，本子到手啦！这就是递归，拍拍小朋友的背可以类比函数调用，而小朋友们都记得要传消息、送本子，是因为他们有记忆力，这可以类比栈。</p><p>更严谨一些，递归蕴含的思想其实是数学归纳法：为了求解问题p（n），首先解决基础情形p（1），然后假定p（n-1）已经解决，在此基础上若p（n）得解，那所有问题均得解。这也启发我们：使用递归，切忌纠结中间步骤，因为这样做的代价是手动推理中间的若干步骤，而这些脏活，应该是计算机给我们干的!</p></blockquote><p>所以理解递归还是不能太纠结具体的过程，这样只会更加地糊涂，我们注重的应该是思想以及写递归的一些注意事项，比如对于参数的确定，停止条件以及每次都要缩小范围并且都是以1这个段位缩小，不要跨段不要跨段。</p><h2>递归与栈</h2><p>虽然说我们不能纠结于递归的过程，但是递归与栈关系紧密，区别只是这个栈是计算机系统栈帮我们实现，而迭代是我们自己控制栈来实现，两者的基本思想都是栈，那么我们就来探讨探讨递归与栈。这个问题也是我之前面试被问过的一个问题，希望再这里能有个比较清晰的理解。</p><p>前面说过，树是一个天然递归的数据结构，这里拿二叉树的前序遍历作为分析点，并且拿最简单的三个节点的二叉树作为示例。</p><p>对于树这个数据结构暂且不多说，我们如果用递归的方式来实现前序遍历还是非常简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个直接放到leetcode上竟然也是可以通过的，说明对这个递归答案还是认可的。不过这里想说明一下递归与栈的关系，所以需要详细说明一下它里面是如何通过系统栈来进行调用的。（前序遍历：144号，中序遍历84号，后序遍历145号）。</p><p>当然了，我们也知道递归相当于一个函数调用另一个子函数，它是自己再调用自己而已，递归借助了系统栈自己来实现的。我们这里以遍历最简单的二叉树为例：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-10.png" alt="image"></p><p>当执行到第一个<code>preorder</code>的时候，此时系统栈里面已经标志一下前面两句执行完毕，还剩下遍历右孩子的操作。此时就是已经遍历了1这个节点，下面就是准备进入1的左孩子即2这个节点的遍历。</p><p><img src="http://bloghello.oursnail.cn/suanfa2-8.png" alt="image"></p><p>此时进入递归重新执行<code>preorder</code>，那么此时又将这个重新执行的函数的参数压到栈顶：</p><p><img src="http://bloghello.oursnail.cn/suanfa2-9.png" alt="image"></p><p>此时2这个节点已经打印出来了，此时又要进入<code>preorder</code>重新执行了，再将2的左孩子放进<code>preorder</code>进行遍历，此时为null，那么就会直接结束<code>preorder</code>函数，返回来继续执行，此时<code>go 2-R</code>还没有执行，那么就是看看2的右孩子，也是null，那么此时关于2的节点的孩子们都遍历完毕了，就会出栈，回到一开始继续执行<code>go 1-R</code>。同理再去遍历1的右孩子们。</p><p>我们从上面的过程中知道，系统栈会保留递归调用的时候调用方的参数以及执行情况，等递归返回的时候，就可以将现场恢复并且继续执行。我们还明确，比如对于节点1来说，系统栈的处理方式是：先<code>count 1</code>即打印1，然后递归访问左孩子<code>go 1-L</code>，最后递归访问右孩子<code>go 1-R</code>，那么我们也可以用栈来模拟这个过程，那么压栈的过程必然是<code>go 1-R</code>–<code>go 1-L</code>–<code>count 1</code>，这样根据后进先出的原则，出来的顺序正好是<code>count 1</code>–<code>go 1-L</code>–<code>go 1-R</code>。</p><p>根据这个思路，我们完全可以将上面的递归程序改成用栈来实现。</p><p>首先将<code>root</code>入栈，并且标识为<code>go</code>，下面进入循环判断栈是否为空，不为空则进入循环。</p><p>首先是判断如果当前节点为<code>go</code>，则表示进行入栈操作，这里首先演示的是前序遍历，所以入栈的顺序是右孩子(go 1-R)–左孩子(go 1-L)–自身(print 1)，此时栈中已经有了这三个信息，那么进入下一次循环，首先出栈的就是自身(print 1)，那么则打印，继续循环，此时出栈的是左孩子(go 1-L)，因为是<code>go</code>所以要添加左右孩子，但是它没有左右孩子，则直接将<code>print 2</code>压入栈中，那么下次循环就会打印出来。最后同理就是右孩子出栈，跟2一样没有左右子孩子则直接将<code>print 3</code>压入栈中下次循环打印出来。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(String str,TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Command&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,root));</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            Command command = stack.pop();</span><br><span class="line">            <span class="comment">//遇到go则按照顺序入栈</span></span><br><span class="line">            <span class="keyword">if</span> (command.str.equals(<span class="string">"go"</span>))&#123;</span><br><span class="line">                <span class="comment">//首先压入的是当前节点的右子节点</span></span><br><span class="line">                <span class="keyword">if</span>(command.node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,command.node.right));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//然后压入的是当前节点的左子节点</span></span><br><span class="line">                <span class="keyword">if</span>(command.node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,command.node.left));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后压入的是当前节点，准备打印</span></span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="string">"print"</span>,command.node));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//等于`print`的节点则打印出来</span></span><br><span class="line">                System.out.println(command.node.val);</span><br><span class="line">                res.add(command.node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的小伙伴可能会发现这个写法好像跟主流的写法不大一样，后面介绍二叉树的话会介绍一下主流的写法是什么，但是这个写法是比较通用的。原因在于这个写法是真正模拟了系统栈的执行流程，思路会比较清晰一点，并且它具有通用性，如果我想改为中序遍历或者后续遍历是非常简单的，只需要简单地调整<code>if (command.str.equals(&quot;go&quot;))</code>里面的顺序即可。</p><p>至此，简单地昭示了系统栈的执行流程，阐明了递归与栈之间的关系，并且用自己的栈来模拟系统栈写出了非递归的版本。递归在树这种数据结构中是随处可见的，应该对它重视起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么还要再来说说递归问题，因为数据结构中二叉树是比较重要也是比较难的数据结构，它的结构是天生递归的，所以对于二叉树的很多操作都可以用递归来实现，因此递归这一关能尽量理解是最好的，本章从汉诺塔的问题出发，来看看递归的实现原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法1-递归入门</title>
    <link href="http://yoursite.com/2019/02/25/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%951-%E9%80%92%E5%BD%92%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/02/25/algorithms-basic/基础算法1-递归入门/</id>
    <published>2019-02-25T13:19:57.931Z</published>
    <updated>2019-02-25T13:24:44.792Z</updated>
    
    <content type="html"><![CDATA[<p>算法入门系列以递归开头，我们知道，递归的编码往往是比较简单的，但是递归的思想往往又是难以理解。在写完这篇笔记之后仍然无法得递归之要领，不过对于如何写递归是有了一定得章法，一句话就是用数据归纳法，先尝试n得情况，再去考虑0或者1得情况，并且保证范围在逐渐缩小并且一定可以结束，下面我们来详细说一说递归。</p><a id="more"></a><h2>一、什么是递归</h2><p>我们可以把”递归“比喻成”查字典“，当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词。</p><p>可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。（摘自知乎的一个回答）</p><p>从程序本身来看，就是一个函数直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</p><p>我们这里以计算阶乘为切入点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;    </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> n * Factorial(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以上述代码为例，取 n=3，则过程如下：</p><p>第 1~4 步，都是入栈过程，<code>Factorial(3)</code>调用了<code>Factorial(2)</code>，<code>Factorial(2)</code>又接着调用<code>Factorial(1)</code>，直到<code>Factorial(0)</code>；</p><p>第 5 步，因 0 是递归结束条件，故不再入栈，此时栈高度为 4，即为我们平时所说的递归深度；</p><p>第 6~9 步，<code>Factorial(0)</code>做完，出栈，而<code>Factorial(0)</code>做完意味着<code>Factorial(1)</code>也做完，同样进行出栈，重复下去，直到所有的都出栈完毕，递归结束。</p><p>可以看出来，递归的本质就是由一个系统栈不停地保存每一层调用的方法及其参数，直到遇到终止条件为止，一层一层地结束返回，但是当层数过深的时候就有可能出现<code>stack overflow</code>这样的栈溢出错误。</p><p>也可以看出来，每一个递归程序都可以把它改写为非递归版本。但是并不是每个递归程序都是那么容易被改写为非递归的。某些递归程序比较复杂，其入栈和出栈非常繁琐，给编码带来了很大难度，而且易读性极差，所以条件允许的情况下，推荐使用递归。</p><h2>二、如何思考递归</h2><p>在初学递归的时候, 看到一个递归实现, 我们总是难免陷入不停的验证之中，比如上面提及的阶乘，求解<code>Factorial(n)</code>时，我们总会情不自禁的发问，<code>Factorial(n-1)</code>可以求出正确的答案么？接着我们就会再用<code>Factorial(n-2)</code>去验证，，，不停地往下验证直到<code>Factorial(0)</code>。</p><p>对递归这样的不适应，和我们平时习惯的思维方式有关。我们习惯的思维是：已知<code>Factorial(0)</code>，乘上 1 就等于<code>Factorial(1)</code>，再乘以 2 就等于<code>Factorial(2)</code>，，，直到乘到 n。</p><p>因此，递归和我们的思维方式正好相反。这就会给我们编程造成相当大的思维干扰。</p><p>其实，递归的数学思想是数学归纳法：</p><ul><li>如果下面这两点是成立的，我们就知道这个递归对于所有的 n 都是正确的。</li><li>1）当 n=0,1 时，结果正确；</li><li>2）假设递归对于 n 是正确的，同时对于 n+1 也正确。</li></ul><p>在递归中，我们通常把第 1 点称为终止条件，因为这样更容易理解，其作用就是终止递归，防止递归无限地运行下去。</p><p>对于第二点就是假定如果n-1的情况是正确的，那么n的情况就是正确的，然后再假定n-2的情况是正确的，那么n-1的情况也是正确的，那么就会一直推导到特殊情况比如0的时候，这个时候是正确的，那么前面所有的都是正确的。</p><p>从而达到了上面说的，将一个复杂的问题一层一层地转化为相似的小规模的问题，这样，解决了小规模问题之后一层一层地就可以返回来求出复杂的问题。</p><p>根据数学归纳法，其实我们还可以归纳出编写递归程序的一些准则：</p><ul><li>严格定义递归函数作用，包括参数、返回值、<code>side-effect</code></li><li>先一般再特殊</li><li>每次调用必须缩小问题规模</li><li>每次问题规模缩小程度必须为1</li></ul><p>这里简单地再解释一下，第一条中注意的是<code>side-effect</code>，这些是一些存储状态的变量，比如一些全局的变量来控制递归里面的一些逻辑等等。</p><p>考虑问题的时候可以从特殊的问题来考虑，但是在编写递归程序的时候，最好是先考虑一般的场景，最后再来看特殊的场景从而终止递归。并且每次缩小程度为1，不能为2或者3等。</p><p>好了，其实递归真正说起来好像也就那回事，但是真正用好确实是需要大量的训练，即递归的思维训练。</p><h2>三、递归的方式创建单向链表</h2><p>首先定义一下链表类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(head.val+<span class="string">"-&gt;"</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"null"</span>);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个数组：1，2，3，4，5，目标是将它们转换为链表。</p><p>正常的思维是：创建节点<code>node1</code>，<code>node2</code>，然后<code>node1</code>的<code>next</code>指向<code>node2</code>，依次类推直到最后。但是用递归的时候就不要这么想了，我们的思维方式变为：</p><p>假设2，3，4，5已经组装好了，那么我只需要再将1插到这个组装好的链表的最前面即可：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-1.png" alt="image"></p><p>那么，首先我们确定函数参数，返回值等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，首先，我取出1作为<code>firstNode</code>，然后我这个1指向的是后面已经排好的(2-&gt;3-&gt;4-&gt;5)这个链表，此时不就成功了嘛！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取数组第一个元素</span></span><br><span class="line">    Node firstNode = <span class="keyword">new</span> Node(values.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//获取后面排好的链表的头节点</span></span><br><span class="line">    Node fisrtSubNode = createLinkedList(values.subList(<span class="number">1</span>,values.size()));</span><br><span class="line">    <span class="comment">//第一个元素指向后面排好的链表的头节点即可</span></span><br><span class="line">    firstNode.setNext(fisrtSubNode);</span><br><span class="line">    <span class="comment">//返回整个链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> firstNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们只要知道：<code>createLinkedList(values.subList(1,values.size()));</code>这个就可以帮助我们拼接成我们需要的(2-&gt;3-&gt;4-&gt;5)这个链表，下面我只需要将1指向这个链表就可以成功了。我们仔细来看这个函数，就是调用自身，即递归，里面参数是：除了第一个元素外剩余的元素，并且每一层就剔除掉第一个元素，那么此时还需要一个终止条件，就是这个数组已经没有元素了就停止。所以完整的程序是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">createLinkedList</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">    <span class="comment">//5.递归停止的条件就是没有元素了</span></span><br><span class="line">    <span class="keyword">if</span> (values.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.获取数组第一个元素</span></span><br><span class="line">    Node firstNode = <span class="keyword">new</span> Node(values.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//2.获取后面排好的链表的头节点，用subList来截取，逐渐地截短使得问题的规模变小</span></span><br><span class="line">    Node fisrtSubNode = createLinkedList(values.subList(<span class="number">1</span>,values.size()));</span><br><span class="line">    <span class="comment">//3.第一个元素指向后面排好的链表的头节点即可</span></span><br><span class="line">    firstNode.setNext(fisrtSubNode);</span><br><span class="line">    <span class="comment">//4.返回整个链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> firstNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以想象，一层一层地剔除第一个元素，过程是(2-&gt;3-&gt;4-&gt;5)，(3-&gt;4-&gt;5)，(4-&gt;5)，（5)，()，此时为空了停止，就会返回到上一层执行的地方，即<code>Node fisrtSubNode = null</code>这一句，此时，上一层的<code>firstNode</code>就是5，那么继续执行就是<code>5.setNext(null)</code>，<code>return 5</code>，这一层又结束了返回到上一层，上一层此时<code>firstNode=4</code>，那么<code>fisrtSubNode = 5</code>，然后继续执行就是<code>4.setNext(5)</code>，最后<code>return 4</code>，此时链表已经是<code>4-&gt;5-&gt;null</code>了，再重复以上的过程直到<code>2-&gt;3-&gt;4-&gt;5-&gt;null</code>，此时回到最上层，即一开始的地方，即假定1后面就是拼接好的链表，此时确实也是拼接好的。所以这里用的就是数学归纳法的思想。</p><h2>四、递归的方式反转单向链表</h2><p>链表的反转效果为：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-2.png" alt="image"></p><p>我们跟上面一样考虑，考虑一般的情况，那就是1后面的所有元素已经全部反转好了，初始状态为：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-3.png" alt="image"></p><p>此时假定后面全部反转好了：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-4.png" alt="image"></p><p>下面只需要将2指向1，并且1指向null即可：</p><p><img src="http://bloghello.oursnail.cn/suanfa1-5.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node newHead = reverseLinkedList(head.getNext());</span><br><span class="line">    head.getNext().setNext(head);</span><br><span class="line">    head.setNext(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>六、递归存在的问题</h2><p>比如计算斐波那契数列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index==<span class="number">1</span>||index==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fib(index-<span class="number">1</span>)+fib(index-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个递归里做了冗余的工作，如图，我们在f4里面已经计算了f2，可是f3里有同样计算了f2，以此类推那些冗余的工作，在数值比较小的情况下，计算机还是可以接受的。但是，当求解的数值比较大，它是成指数级增长的，所以不要再递归中做重复的工作。</p><p><img src="http://bloghello.oursnail.cn/suanfa1-7.png" alt="image"></p><p>下一节通过经典得汉诺塔问题再来探讨一下递归的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法入门系列以递归开头，我们知道，递归的编码往往是比较简单的，但是递归的思想往往又是难以理解。在写完这篇笔记之后仍然无法得递归之要领，不过对于如何写递归是有了一定得章法，一句话就是用数据归纳法，先尝试n得情况，再去考虑0或者1得情况，并且保证范围在逐渐缩小并且一定可以结束，下面我们来详细说一说递归。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记12-分布式锁</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B012-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记12-分布式锁/</id>
    <published>2019-02-23T08:48:05.271Z</published>
    <updated>2019-02-23T08:51:35.857Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁在分布式系统中是非常常见的，redis以及ZK都可以实现分布式锁，在文章<a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">Curator</a>从实战的层面进行了实际的分布式锁的实现，具体看这个文章即可。下面是再唠叨唠叨。</p><a id="more"></a><h2>redis实现分布式锁</h2><p>之前，在<a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">redis实现分布式锁</a>实现过一个基于redis的分布式锁，用来保证一个系统去定时关单。</p><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V2.png" alt="image"></p><p>这上面两个例子，一个是针对多个系统修改同一个资源，一个是面临高并发下订单时控制同一时间只能有一个用户拿到锁然后下订单（可能是多个系统，比如是订单服务器和库存服务器，当然，为了解耦和提高速度，那么可以把写订单表这个逻辑用MQ异步出去），首先我要判断库存是不是真的够，那么这个时候我就要用分布式锁控制，防止两个用户同时来查库存数量然后都觉得自己可以下订单（极端情况，库存只有1，那么这两个用户同时查到为1，那么都认为自己可以下订单咋办？），其他的用户必须等到这个用户释放锁或者超时才可以再拿到锁再去执行操作。这样，有效地解决了商品的超卖问题。</p><p>优点：实现简单，吞吐量十分客观，对于高并发情况应付自如，自带超时保护，对于网络抖动的情况也可以利用超时删除策略保证不会阻塞所有流程。但是redis存在一些问题：</p><ul><li><strong>单点问题</strong>：因为redis一般都是单实例使用，那么对于单点问题，可以做一个主从。当然主从切换的时候也是不可用的，因为主从同步是异步的，可能会并发问题。如果对于主从还是不能保证可靠性的话，可以上Redis集群，对于Redis集群，因为使用了类一致性Hash算法，虽然不能避免节点下线的并发问题(当前的任务没有执行完，其他任务就开始执行)，但是能保证Redis是可用的。可用性的问题是出了问题之后的备选方案，如果我们系统天天都出问题还玩毛啊，对于突发情况牺牲一两个请求还是没问题的。</li><li><strong>锁删除失败</strong>：分布式锁基本都有这个问题，可以对key设置失效时间。这个超时时间需要把控好，过大那么系统吞吐量低，很容易导致超时。如果过小那么会有并发问题，部分耗时时间比较长的任务就要遭殃了。</li></ul><p><strong>redis集群的同步策略是需要时间的，有可能A线程setNX成功后拿到锁，但是这个值还没有更新到B线程执行setNX的这台服务器，那就会产生并发问题。</strong></p><h3>zookeeper实现分布式锁</h3><p>Zookeeper是一个分布式一致性协调框架，主要可以实现选主、配置管理和分布式锁等常用功能，因为Zookeeper的写入都是顺序的，在一个节点创建之后，其他请求再次创建便会失败，同时可以对这个节点进行Watch，如果节点删除会通知其他节点抢占锁。</p><p>Zookeeper实现分布式锁虽然是比较重量级的，但实现的锁功能十分健全，由于Zookeeper本身需要维护自己的一致性，所以性能上较Redis还是有一定差距的。</p><p>“惊群”就是在一个节点删除的时候，大量对这个节点的删除动作有订阅Watcher的线程会进行回调，这对Zk集群是十分不利的。所以需要避免这种现象的发生。</p><p>为了解决“惊群“问题，我们需要放弃订阅一个节点的策略，那么怎么做呢？详细看这里：<a href="https://www.jianshu.com/p/5d12a01018e1" target="_blank" rel="noopener">https://www.jianshu.com/p/5d12a01018e1</a></p><p>最后想说明一点，其实对于Zookeeper的一些常用功能是有一些成熟的包实现的，像Curator。Curator的确是足够牛逼，不仅封装了Zookeeper的常用API，也包装了很多常用Case的实现。形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"><span class="keyword">if</span> ( lock.acquire(maxWait, waitUnit) ) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do some work inside of the critical section here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的时间在<a href="https://github.com/sunweiguo/mama-buy" target="_blank" rel="noopener">分布式电商项目-码码购</a>中用<code>Curator</code>实现分布式锁实现了某些场景的需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式锁在分布式系统中是非常常见的，redis以及ZK都可以实现分布式锁，在文章&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Curator&lt;/a&gt;从实战的层面进行了实际的分布式锁的实现，具体看这个文章即可。下面是再唠叨唠叨。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记11-Apache Curator客户端的使用（二）</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B011-Apache%20Curator%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记11-Apache Curator客户端的使用（二）/</id>
    <published>2019-02-23T08:46:29.028Z</published>
    <updated>2019-02-23T08:47:11.188Z</updated>
    
    <content type="html"><![CDATA[<p>本文来继续来看Apache Curator客户端的使用！</p><a id="more"></a><h2>zk-watcher应用实例之模拟统一更新N台节点的配置文件</h2><p>zookeeper有一个比较常见的应用场景就是统一管理、更新分布式集群环境中每个节点的配置文件，我们可以在代码中监听集群中的节点，当节点数据发生改变时就同步到其他节点上。如下图：</p><p><img src="http://bloghello.oursnail.cn/18-12-10/90520428.jpg" alt="image"></p><p>因为我们使用的json作为节点存储的数据格式，所以需要准备一个工具类来做json与pojo对象的一个转换，也就是所谓的反序列化。创建一个 JsonUtils 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义jackson对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将对象转换成json字符串。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Title: pojoToJson&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Description: &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">objectToJson</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String string = MAPPER.writeValueAsString(data);</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json结果集转化为对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanType 对象中的object类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">jsonToPojo</span><span class="params">(String jsonData, Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T t = MAPPER.readValue(jsonData, beanType);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将json数据转换成pojo对象list</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Title: jsonToList&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Description: &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function">List&lt;T&gt; <span class="title">jsonToList</span><span class="params">(String jsonData, Class&lt;T&gt; beanType)</span> </span>&#123;</span><br><span class="line">        JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要额外的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后创建客户端类，客户端类就是用来监听集群中的节点的。由于是模拟，所以这里的部分代码是伪代码。客户端类我们这里创建了三个，因为集群中有三个节点，由于代码基本上是一样的，每个客户端分别监听watch事件，所以这里只贴出客户端_1的代码。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerIp = <span class="string">"192.168.190.128:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化重连策略以及客户端对象并启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerIp)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  public final static String CONFIG_NODE = "/super/testNode/redis-config";</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONFIG_NODE_PATH = <span class="string">"/super/testNode"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SUB_PATH = <span class="string">"/redis-config"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CountDownLatch countDown = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Client_1 cto = <span class="keyword">new</span> Client_1();</span><br><span class="line">        System.out.println(<span class="string">"client1 启动成功..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启子节点缓存</span></span><br><span class="line">        <span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(cto.client, CONFIG_NODE_PATH, <span class="keyword">true</span>);</span><br><span class="line">        childrenCache.start(StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加子节点监听事件</span></span><br><span class="line">        childrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 监听节点的数据更新事件</span></span><br><span class="line">                <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) &#123;</span><br><span class="line">                    String configNodePath = event.getData().getPath();</span><br><span class="line">                    <span class="keyword">if</span> (configNodePath.equals(CONFIG_NODE_PATH + SUB_PATH)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"监听到配置发生变化，节点路径为:"</span> + configNodePath);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取节点数据</span></span><br><span class="line">                        String jsonConfig = <span class="keyword">new</span> String(event.getData().getData());</span><br><span class="line">                        System.out.println(<span class="string">"节点"</span> + CONFIG_NODE_PATH + <span class="string">"的数据为: "</span> + jsonConfig);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 从json转换配置</span></span><br><span class="line">                        RedisConfig redisConfig = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotBlank(jsonConfig)) &#123;</span><br><span class="line">                            redisConfig = JsonUtils.jsonToPojo(jsonConfig, RedisConfig.class);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 配置不为空则进行相应操作</span></span><br><span class="line">                        <span class="keyword">if</span> (redisConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            String type = redisConfig.getType();</span><br><span class="line">                            String url = redisConfig.getUrl();</span><br><span class="line">                            String remark = redisConfig.getRemark();</span><br><span class="line">                            <span class="comment">// 判断事件</span></span><br><span class="line">                            <span class="keyword">if</span> (type.equals(<span class="string">"add"</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"\n-------------------\n"</span>);</span><br><span class="line">                                System.out.println(<span class="string">"监听到新增的配置，准备下载..."</span>);</span><br><span class="line">                                <span class="comment">// ... 连接ftp服务器，根据url找到相应的配置</span></span><br><span class="line">                                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                                System.out.println(<span class="string">"开始下载新的配置文件，下载路径为&lt;"</span> + url + <span class="string">"&gt;"</span>);</span><br><span class="line">                                <span class="comment">// ... 下载配置到你指定的目录</span></span><br><span class="line">                                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                                System.out.println(<span class="string">"下载成功，已经添加到项目中"</span>);</span><br><span class="line">                                <span class="comment">// ... 拷贝文件到项目目录</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"update"</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"\n-------------------\n"</span>);</span><br><span class="line">                                System.out.println(<span class="string">"监听到更新的配置，准备下载..."</span>);</span><br><span class="line">                                <span class="comment">// ... 连接ftp服务器，根据url找到相应的配置</span></span><br><span class="line">                                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                                System.out.println(<span class="string">"开始下载配置文件，下载路径为&lt;"</span> + url + <span class="string">"&gt;"</span>);</span><br><span class="line">                                <span class="comment">// ... 下载配置到你指定的目录</span></span><br><span class="line">                                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                                System.out.println(<span class="string">"下载成功..."</span>);</span><br><span class="line">                                System.out.println(<span class="string">"删除项目中原配置文件..."</span>);</span><br><span class="line">                                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                                <span class="comment">// ... 删除原文件</span></span><br><span class="line">                                System.out.println(<span class="string">"拷贝配置文件到项目目录..."</span>);</span><br><span class="line">                                <span class="comment">// ... 拷贝文件到项目目录</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"delete"</span>)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"\n-------------------\n"</span>);</span><br><span class="line">                                System.out.println(<span class="string">"监听到需要删除配置"</span>);</span><br><span class="line">                                System.out.println(<span class="string">"删除项目中原配置文件..."</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// TODO 视情况统一重启服务</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        countDown.await();</span><br><span class="line"></span><br><span class="line">        cto.closeZKClient();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上代码的编写后，将所有的客户类都运行起来。然后到zookeeper服务器上，进行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 14] set /workspace/super/testNode/redis-config &#123;&quot;type&quot;:&quot;add&quot;,&quot;url&quot;:&quot;ftp://192.168.10.123/config/redis.xml&quot;,&quot;remark&quot;:&quot;add&quot;&#125;</span><br><span class="line">cZxid = 0xc00000039</span><br><span class="line">ctime = Mon Apr 30 01:43:47 CST 2018</span><br><span class="line">mZxid = 0xc00000043</span><br><span class="line">mtime = Mon Apr 30 01:52:35 CST 2018</span><br><span class="line">pZxid = 0xc00000039</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 75</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 15] set /workspace/super/testNode/redis-config &#123;&quot;type&quot;:&quot;update&quot;,&quot;url&quot;:&quot;ftp://192.168.10.123/config/redis.xml&quot;,&quot;remark&quot;:&quot;update&quot;&#125;</span><br><span class="line">cZxid = 0xc00000039</span><br><span class="line">ctime = Mon Apr 30 01:43:47 CST 2018</span><br><span class="line">mZxid = 0xc00000044</span><br><span class="line">mtime = Mon Apr 30 01:53:46 CST 2018</span><br><span class="line">pZxid = 0xc00000039</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 81</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 16] set /workspace/super/testNode/redis-config &#123;&quot;type&quot;:&quot;delete&quot;,&quot;url&quot;:&quot;&quot;,&quot;remark&quot;:&quot;delete&quot;&#125;   </span><br><span class="line">cZxid = 0xc00000039               </span><br><span class="line">ctime = Mon Apr 30 01:43:47 CST 2018</span><br><span class="line">mZxid = 0xc00000045</span><br><span class="line">mtime = Mon Apr 30 01:54:06 CST 2018</span><br><span class="line">pZxid = 0xc00000039</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 44</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 17]</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/18-12-10/55655494.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-12-10/45175373.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-12-10/92597884.jpg" alt="image"></p><p>如上，从三个客户端的控制台输出信息可以看到，三个节点都进行了同样操作，触发了同样的watch事件，这样就可以完成统一的配置文件管理。</p><h2>curator之acl权限操作与认证授权</h2><p>我们先演示在创建节点时设置acl权限，现在/workspace/super只有如下节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 27] ls /workspace/super</span><br><span class="line">[xxxnode, testNode]</span><br></pre></td></tr></table></figure><p>然后新建一个 CuratorAcl 类，关于acl权限的概念以及部分API代码都在之前的zk原生API使用一文中介绍过了，所以这里就不赘述了。编写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorAcl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Curator客户端</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集群模式则是多个ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerIps = <span class="string">"192.168.190.128:2181,192.168.190.129:2181,192.168.190.130:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorAcl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder().authorization(<span class="string">"digest"</span>, <span class="string">"user1:123456a"</span>.getBytes())  <span class="comment">// 认证授权，登录用户</span></span><br><span class="line">                .connectString(zkServerIps)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorAcl cto = <span class="keyword">new</span> CuratorAcl();</span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = cto.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line"></span><br><span class="line">        String nodePath = <span class="string">"/super/testAclNode/testOne"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义权限列表</span></span><br><span class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">        Id user1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, AclUtils.getDigestUserPwd(<span class="string">"user1:123456a"</span>));</span><br><span class="line">        Id user2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, AclUtils.getDigestUserPwd(<span class="string">"user2:123456b"</span>));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.ALL, user1));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ, user2));</span><br><span class="line">        acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.DELETE | ZooDefs.Perms.CREATE, user2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点，使用自定义权限列表来设置节点的acl权限</span></span><br><span class="line">        <span class="keyword">byte</span>[] nodeData = <span class="string">"child-data"</span>.getBytes();</span><br><span class="line">        cto.client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).withACL(acls).forPath(nodePath, nodeData);</span><br><span class="line"></span><br><span class="line">        cto.closeZKClient();</span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted2 = cto.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted2 ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类，然后到zookeeper服务器上，通过命令行进行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 19] ls /workspace/super/testAclNode    </span><br><span class="line">[testOne]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 20] getAcl /workspace/super/testAclNode</span><br><span class="line">&apos;world,&apos;anyone</span><br><span class="line">: cdrwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 21] getAcl /workspace/super/testAclNode/testOne</span><br><span class="line">&apos;digest,&apos;user1:TQYTqd46qVVbWpOd02tLO5qb+JM=</span><br><span class="line">: cdrwa</span><br><span class="line">&apos;digest,&apos;user2:CV4ED0rE6SxA3h/DN/WyScDMbCs=</span><br><span class="line">: r</span><br><span class="line">&apos;digest,&apos;user2:CV4ED0rE6SxA3h/DN/WyScDMbCs=</span><br><span class="line">: cd</span><br></pre></td></tr></table></figure><p>如上，可以看到，创建的全部节点的acl权限都是我们设置的自定义权限。</p><p>最后我们再来演示如何修改一个已存在的节点的acl权限，修改 CuratorAcl 类中的main方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化</span></span><br><span class="line">    CuratorAcl cto = <span class="keyword">new</span> CuratorAcl();</span><br><span class="line">    <span class="keyword">boolean</span> isZkCuratorStarted = cto.client.isStarted();</span><br><span class="line">    System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line"></span><br><span class="line">    String nodePath = <span class="string">"/super/testAclNodeTwo/testOne"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义权限列表</span></span><br><span class="line">    List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</span><br><span class="line">    Id user1 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, AclUtils.getDigestUserPwd(<span class="string">"user1:123456a"</span>));</span><br><span class="line">    Id user2 = <span class="keyword">new</span> Id(<span class="string">"digest"</span>, AclUtils.getDigestUserPwd(<span class="string">"user2:123456b"</span>));</span><br><span class="line">    acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ | ZooDefs.Perms.CREATE | ZooDefs.Perms.ADMIN, user1));</span><br><span class="line">    acls.add(<span class="keyword">new</span> ACL(ZooDefs.Perms.READ | ZooDefs.Perms.DELETE | ZooDefs.Perms.CREATE, user2));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定节点的acl权限</span></span><br><span class="line">    cto.client.setACL().withACL(acls).forPath(nodePath);</span><br><span class="line"></span><br><span class="line">    cto.closeZKClient();</span><br><span class="line">    <span class="keyword">boolean</span> isZkCuratorStarted2 = cto.client.isStarted();</span><br><span class="line">    System.out.println(<span class="string">"当前客户的状态："</span> + (isZkCuratorStarted2 ? <span class="string">"连接中"</span> : <span class="string">"已关闭"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类，然后到zookeeper服务器上，通过命令行进行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 31] getAcl /workspace/super/testAclNodeTwo/testOne</span><br><span class="line">&apos;digest,&apos;user1:TQYTqd46qVVbWpOd02tLO5qb+JM=</span><br><span class="line">: cra</span><br><span class="line">&apos;digest,&apos;user2:CV4ED0rE6SxA3h/DN/WyScDMbCs=</span><br><span class="line">: cdr</span><br><span class="line">[zk: localhost:2181(CONNECTED) 32]</span><br></pre></td></tr></table></figure><p>可以看到，成功修改了该节点的acl权限。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来继续来看Apache Curator客户端的使用！&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记10-Apache Curator客户端的使用（一）</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B010-Apache%20Curator%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记10-Apache Curator客户端的使用（一）/</id>
    <published>2019-02-23T08:43:42.684Z</published>
    <updated>2019-02-23T08:45:37.497Z</updated>
    
    <content type="html"><![CDATA[<p>本文来看看Apache Curator客户端的使用吧！</p><a id="more"></a><h2>一、前言</h2><p>对于上一章中应用的java 原生API来操作节点。来看看他的不足：</p><ul><li>超时重连，不支持自动，需要手动操作</li><li>watcher注册一次后会失效</li><li>不支持递归创建节点</li></ul><p>对于Apache Curator开源客户端，具有以下的优点：</p><ul><li>Apache的开源项目，值得信赖</li><li>解决watcher的注册一次就失效的问题</li><li>API更加简单易用</li><li>提供更多解决方案并且实现简单，比如分布式锁</li><li>提供常用的zookeeper工具类</li><li>编程风格更爽</li></ul><p>本篇文章为上半部分，主要学习了一下自动重连、创建节点、查询节点数据和子节点、删除和修改节点数据。还有就是用nodeCache以及PathChildrenCache缓存节点数据来解决注册一次就失效的问题。</p><h2>二、使用</h2><p>首先新建一个maven工程，我这里直接新建了一个SpringBoot工程，依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--curator--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2>三、连接&amp;自动重连</h2><p>配置完依赖后，我们就可以来写一个简单的demo测试与zookeeper服务端的连接。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorConnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * （推荐）</span></span><br><span class="line"><span class="comment">         * 同步创建zk示例，原生api是异步的</span></span><br><span class="line"><span class="comment">         * 这一步是设置重连策略</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 构造器参数：</span></span><br><span class="line"><span class="comment">         *  curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment">         *  baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment">         *  maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment">         *  maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>,<span class="number">5</span>);</span><br><span class="line">        client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkServerPath)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">10</span>*<span class="number">1000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(client != <span class="keyword">null</span>)&#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="keyword">boolean</span> isZkClientStart = curatorConnect.client.isStarted();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端是否打开:"</span>+isZkClientStart);</span><br><span class="line"></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        isZkClientStart = curatorConnect.client.isStarted();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端是否打开:"</span>+isZkClientStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>curator连接zookeeper服务器时有自动重连机制，而curator的重连策略有五种。</p><ul><li>第一种就是上面提到的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （推荐）</span></span><br><span class="line"><span class="comment"> * 同步创建zk示例，原生api是异步的</span></span><br><span class="line"><span class="comment"> * 这一步是设置重连策略</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造器参数：</span></span><br><span class="line"><span class="comment"> *  curator链接zookeeper的策略:ExponentialBackoffRetry</span></span><br><span class="line"><span class="comment"> *  baseSleepTimeMs：初始sleep的时间</span></span><br><span class="line"><span class="comment"> *  maxRetries：最大重试次数</span></span><br><span class="line"><span class="comment"> *  maxSleepMs：最大重试时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>第二种，可设定重连n次：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （推荐）</span></span><br><span class="line"><span class="comment"> * curator链接zookeeper的策略:RetryNTimes</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造器参数：</span></span><br><span class="line"><span class="comment"> * n：重试的次数</span></span><br><span class="line"><span class="comment"> * sleepMsBetweenRetries：每次重试间隔的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(<span class="number">3</span>, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><ul><li>第三种，只会重连一次：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （不推荐）</span></span><br><span class="line"><span class="comment"> * curator链接zookeeper的策略:RetryOneTime</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造器参数：</span></span><br><span class="line"><span class="comment"> * sleepMsBetweenRetry:每次重试间隔的时间</span></span><br><span class="line"><span class="comment"> * 这个策略只会重试一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy2 = <span class="keyword">new</span> RetryOneTime(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>第四种，永远重连：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 永远重试，不推荐使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy3 = <span class="keyword">new</span> RetryForever(retryIntervalMs)</span><br></pre></td></tr></table></figure><ul><li>第五种，可设定最大重试时间：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * curator链接zookeeper的策略:RetryUntilElapsed</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造器参数：</span></span><br><span class="line"><span class="comment"> * maxElapsedTimeMs:最大重试时间</span></span><br><span class="line"><span class="comment"> * sleepMsBetweenRetries:每次重试间隔</span></span><br><span class="line"><span class="comment"> * 重试时间超过maxElapsedTimeMs后，就不再重试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RetryPolicy retryPolicy4 = <span class="keyword">new</span> RetryUntilElapsed(<span class="number">2000</span>, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2>四、zk命名空间以及创建节点</h2><p>zookeeper的命名空间就类似于我们平时使用Eclipse等开发工具的工作空间一样，我们该连接中所有的操作都是基于这个命名空间的。curator提供了设置命名空间的方法，这样我们任何的连接都可以去设置一个命名空间。设置了命名空间并成功连接后，zookeeper的根节点会多出一个以命名空间名称所命名的节点。然后我们在该连接的增删查改等操作都会在这个节点中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorCreateNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Curator客户端</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集群模式则是多个ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerIps = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorCreateNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化Curator客户端</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder() <span class="comment">// 使用工厂类来建造客户端的实例对象</span></span><br><span class="line">                .connectString(zkServerIps)  <span class="comment">// 放入zookeeper服务器ip</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)  <span class="comment">// 设定会话时间以及重连策略</span></span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();  <span class="comment">// 设置命名空间以及开始建立连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动Curator客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭zk客户端连接</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorCreateNode curatorConnect = <span class="keyword">new</span> CuratorCreateNode();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建节点</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;  <span class="comment">// 节点路径</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">"this is a test data"</span>.getBytes();  <span class="comment">// 节点数据</span></span><br><span class="line">        String result = curatorConnect.client.create().creatingParentsIfNeeded()  <span class="comment">// 创建父节点，也就是会递归创建</span></span><br><span class="line">                .withMode(CreateMode.PERSISTENT)  <span class="comment">// 节点类型</span></span><br><span class="line">                .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)  <span class="comment">// 节点的acl权限</span></span><br><span class="line">                .forPath(nodePath, data);</span><br><span class="line"></span><br><span class="line">        System.out.println(result + <span class="string">"节点，创建成功..."</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类，控制台输出信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前客户端的状态：连接中...</span><br><span class="line">/super/testNode节点，创建成功...</span><br><span class="line">当前客户端的状态：已关闭...</span><br></pre></td></tr></table></figure><h2>五、修改节点以及删除节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Curator客户端</span></span><br><span class="line">    <span class="keyword">public</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 集群模式则是多个ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String zkServerIps = <span class="string">"192.168.190.128:2181,192.168.190.129:2181,192.168.190.130:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化Curator客户端</span></span><br><span class="line">        client = CuratorFrameworkFactory.builder() <span class="comment">// 使用工厂类来建造客户端的实例对象</span></span><br><span class="line">                .connectString(zkServerIps)  <span class="comment">// 放入zookeeper服务器ip</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">10000</span>).retryPolicy(retryPolicy)  <span class="comment">// 设定会话时间以及重连策略</span></span><br><span class="line">                .namespace(<span class="string">"workspace"</span>).build();  <span class="comment">// 设置命名空间以及开始建立连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动Curator客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭zk客户端连接</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeZKClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新节点数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] newData = <span class="string">"this is a new data"</span>.getBytes();</span><br><span class="line">        Stat resultStat = curatorConnect.client.setData().withVersion(<span class="number">0</span>)  <span class="comment">// 指定数据版本</span></span><br><span class="line">                .forPath(nodePath, newData);  <span class="comment">// 需要修改的节点路径以及新数据</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"更新节点数据成功，新的数据版本为："</span> + resultStat.getVersion());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        curatorConnect.client.delete()</span><br><span class="line">                .guaranteed()  <span class="comment">// 如果删除失败，那么在后端还是会继续删除，直到成功</span></span><br><span class="line">                .deletingChildrenIfNeeded()  <span class="comment">// 子节点也一并删除，也就是会递归删除</span></span><br><span class="line">                .withVersion(resultStat.getVersion())</span><br><span class="line">                .forPath(nodePath);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>六、查询节点相关信息</h2><p>1.获取某个节点的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取节点数据</span></span><br><span class="line">        Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line">        <span class="keyword">byte</span>[] nodeData = curatorConnect.client.getData().storingStatIn(stat).forPath(nodePath);</span><br><span class="line">        System.out.println(<span class="string">"节点 "</span> + nodePath + <span class="string">" 的数据为："</span> + <span class="keyword">new</span> String(nodeData));</span><br><span class="line">        System.out.println(<span class="string">"该节点的数据版本号为："</span> + stat.getVersion());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.获取某个节点下的子节点列表，现有一个节点的子节点列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 33] ls /workspace/super/testNode</span><br><span class="line">[threeNode, twoNode, oneNode]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 34]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取子节点列表</span></span><br><span class="line">        List&lt;String&gt; childNodes = curatorConnect.client.getChildren().forPath(nodePath);</span><br><span class="line">        System.out.println(nodePath + <span class="string">" 节点下的子节点列表："</span>);</span><br><span class="line">        <span class="keyword">for</span> (String childNode : childNodes) &#123;</span><br><span class="line">            System.out.println(childNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.查询某个节点是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询某个节点是否存在，存在就会返回该节点的状态信息，如果不存在的话则返回空</span></span><br><span class="line">        Stat statExist = curatorConnect.client.checkExists().forPath(nodePath);</span><br><span class="line">        <span class="keyword">if</span> (statExist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(nodePath + <span class="string">" 节点不存在"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(nodePath + <span class="string">" 节点存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>七、curator之usingWatcher</h2><p>curator在注册watch事件上，提供了一个usingWatcher方法，使用这个方法注册的watch事件和默认watch事件一样，监听只会触发一次，监听完毕后就会销毁，也就是一次性的。而这个方法有两种参数可选，一个是zk原生API的Watcher接口的实现类，另一个是Curator提供的CuratorWatcher接口的实现类，不过在usingWatcher方法上使用哪一个效果都是一样的，都是一次性的。</p><p>新建一个 MyWatcher 实现类，实现 Watcher 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: zookeeper-connection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:  zk原生API的Watcher接口实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-04-28 13:41</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Watcher事件通知方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"触发watcher，节点路径为："</span> + watchedEvent.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个 MyCuratorWatcher 实现类，实现 CuratorWatcher 接口。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: zookeeper-connection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Curator提供的CuratorWatcher接口实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2018-04-28 13:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCuratorWatcher</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Watcher事件通知方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"触发watcher，节点路径为："</span> + watchedEvent.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 watcher 事件，当使用usingWatcher的时候，监听只会触发一次，监听完毕后就销毁</span></span><br><span class="line">        curatorConnect.client.getData().usingWatcher(<span class="keyword">new</span> MyCuratorWatcher()).forPath(nodePath);</span><br><span class="line">        <span class="comment">// curatorConnect.client.getData().usingWatcher(new MyWatcher()).forPath(nodePath);</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类，然后到zookeeper服务器上修改/super/testNode节点的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">35</span>] set /workspace/<span class="keyword">super</span>/testNode <span class="keyword">new</span>-data</span><br><span class="line">cZxid = <span class="number">0xb00000015</span></span><br><span class="line">ctime = Sat Apr <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">57</span> CST <span class="number">2018</span></span><br><span class="line">mZxid = <span class="number">0xb0000002b</span></span><br><span class="line">mtime = Sat Apr <span class="number">28</span> <span class="number">21</span>:<span class="number">40</span>:<span class="number">58</span> CST <span class="number">2018</span></span><br><span class="line">pZxid = <span class="number">0xb0000001c</span></span><br><span class="line">cversion = <span class="number">3</span></span><br><span class="line">dataVersion = <span class="number">2</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x0</span></span><br><span class="line">dataLength = <span class="number">8</span></span><br><span class="line">numChildren = <span class="number">3</span></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">36</span>]</span><br></pre></td></tr></table></figure><p>修改完成后，此时控制台输出内容如下，因为workspace是命名空间节点，所以不会被打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">触发watcher，节点路径为：/super/testNode</span><br></pre></td></tr></table></figure><h2>八、curator之nodeCache一次注册N次监听</h2><p>想要实现watch一次注册n次监听的话，我们需要使用到curator里的一个NodeCache对象。这个对象可以用来缓存节点数据，并且可以给节点添加nodeChange事件，当节点的数据发生变化就会触发这个事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// NodeCache: 缓存节点，并且可以监听数据节点的变更，会触发事件</span></span><br><span class="line">        <span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(curatorConnect.client, nodePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数 buildInitial : 初始化的时候获取node的值并且缓存</span></span><br><span class="line">        nodeCache.start(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取缓存里的节点初始化数据</span></span><br><span class="line">        <span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"节点初始化数据为："</span> + <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"节点初始化数据为空..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为缓存的节点添加watcher，或者说添加监听器</span></span><br><span class="line">        nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">            <span class="comment">// 节点数据change事件的通知方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 防止节点被删除时发生错误</span></span><br><span class="line">                <span class="keyword">if</span> (nodeCache.getCurrentData() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"获取节点数据异常，无法获取当前缓存的节点数据，可能该节点已被删除"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取节点最新的数据</span></span><br><span class="line">                String data = <span class="keyword">new</span> String(nodeCache.getCurrentData().getData());</span><br><span class="line">                System.out.println(nodeCache.getCurrentData().getPath() + <span class="string">" 节点的数据发生变化，最新的数据为："</span> + data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">200000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该类后，我们到zookeeper服务器上，对/super/testNode节点进行如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">2</span>] set /workspace/<span class="keyword">super</span>/testNode change-data     </span><br><span class="line">cZxid = <span class="number">0xb00000015</span></span><br><span class="line">ctime = Sat Apr <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">57</span> CST <span class="number">2018</span></span><br><span class="line">mZxid = <span class="number">0xb00000037</span></span><br><span class="line">mtime = Sat Apr <span class="number">28</span> <span class="number">23</span>:<span class="number">49</span>:<span class="number">42</span> CST <span class="number">2018</span></span><br><span class="line">pZxid = <span class="number">0xb0000001c</span></span><br><span class="line">cversion = <span class="number">3</span></span><br><span class="line">dataVersion = <span class="number">6</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x0</span></span><br><span class="line">dataLength = <span class="number">11</span></span><br><span class="line">numChildren = <span class="number">3</span>      </span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">3</span>] set /workspace/<span class="keyword">super</span>/testNode change-agin-data</span><br><span class="line">cZxid = <span class="number">0xb00000015</span></span><br><span class="line">ctime = Sat Apr <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">57</span> CST <span class="number">2018</span></span><br><span class="line">mZxid = <span class="number">0xb00000038</span></span><br><span class="line">mtime = Sat Apr <span class="number">28</span> <span class="number">23</span>:<span class="number">50</span>:<span class="number">01</span> CST <span class="number">2018</span></span><br><span class="line">pZxid = <span class="number">0xb0000001c</span></span><br><span class="line">cversion = <span class="number">3</span></span><br><span class="line">dataVersion = <span class="number">7</span></span><br><span class="line">aclVersion = <span class="number">0</span></span><br><span class="line">ephemeralOwner = <span class="number">0x0</span></span><br><span class="line">dataLength = <span class="number">16</span></span><br><span class="line">numChildren = <span class="number">3</span></span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">8</span>] delete /workspace/<span class="keyword">super</span>/testNode</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">9</span>] create /workspace/<span class="keyword">super</span>/testNode test-data</span><br><span class="line">Created /workspace/<span class="keyword">super</span>/testNode</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>此时控制台输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前客户端的状态：连接中...</span><br><span class="line">节点初始化数据为：new-data</span><br><span class="line">/super/testNode 节点的数据发生变化，最新的数据为：change-data</span><br><span class="line">/super/testNode 节点的数据发生变化，最新的数据为：change-agin-data</span><br><span class="line">获取节点数据异常，无法获取当前缓存的节点数据，可能该节点已被删除</span><br><span class="line">/super/testNode 节点的数据发生变化，最新的数据为：test-data</span><br><span class="line">当前客户端的状态：已关闭...</span><br></pre></td></tr></table></figure><p>从控制台输出的内容可以看到，只要数据发生改变了都会触发这个事件，并且是可以重复触发的，而不是一次性的。</p><h2>九、curator之PathChildrenCache子节点监听</h2><p>使用NodeCache虽然能实现一次注册n次监听，但是却只能监听一个nodeChanged事件，也就是说创建、删除以及子节点的事件都无法监听。如果我们要监听某一个节点的子节点的事件，或者监听某一个特定节点的增删改事件都需要借助PathChildrenCache来实现。从名称上可以看到，PathChildrenCache也是用缓存实现的，并且也是一次注册n次监听。当我们传递一个节点路径时是监听该节点下的子节点事件，如果我们要限制监听某一个节点，只需要加上判断条件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorConnect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        CuratorConnect curatorConnect = <span class="keyword">new</span> CuratorConnect();</span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父节点路径</span></span><br><span class="line">        String nodePath = <span class="string">"/super/testNode"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为子节点添加watcher</span></span><br><span class="line">        <span class="comment">// PathChildrenCache: 监听数据节点的增删改，可以设置触发的事件</span></span><br><span class="line">        <span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(curatorConnect.client, nodePath, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * StartMode: 初始化方式</span></span><br><span class="line"><span class="comment">         * POST_INITIALIZED_EVENT：异步初始化，初始化之后会触发事件</span></span><br><span class="line"><span class="comment">         * NORMAL：异步初始化</span></span><br><span class="line"><span class="comment">         * BUILD_INITIAL_CACHE：同步初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        childrenCache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列出子节点数据列表，需要使用BUILD_INITIAL_CACHE同步初始化模式才能获得，异步是获取不到的</span></span><br><span class="line">        List&lt;ChildData&gt; childDataList = childrenCache.getCurrentData();</span><br><span class="line">        System.out.println(<span class="string">"当前节点的子节点详细数据列表："</span>);</span><br><span class="line">        <span class="keyword">for</span> (ChildData childData : childDataList) &#123;</span><br><span class="line">            System.out.println(<span class="string">"\t* 子节点路径："</span> + <span class="keyword">new</span> String(childData.getPath()) + <span class="string">"，该节点的数据为："</span> + <span class="keyword">new</span> String(childData.getData()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加事件监听器</span></span><br><span class="line">        childrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 通过判断event type的方式来实现不同事件的触发</span></span><br><span class="line">                <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED)) &#123;  <span class="comment">// 子节点初始化时触发</span></span><br><span class="line">                    System.out.println(<span class="string">"\n--------------\n"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子节点初始化成功"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)) &#123;  <span class="comment">// 添加子节点时触发</span></span><br><span class="line">                    System.out.println(<span class="string">"\n--------------\n"</span>);</span><br><span class="line">                    System.out.print(<span class="string">"子节点："</span> + event.getData().getPath() + <span class="string">" 添加成功，"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"该子节点的数据为："</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) &#123;  <span class="comment">// 删除子节点时触发</span></span><br><span class="line">                    System.out.println(<span class="string">"\n--------------\n"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子节点："</span> + event.getData().getPath() + <span class="string">" 删除成功"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)) &#123;  <span class="comment">// 修改子节点数据时触发</span></span><br><span class="line">                    System.out.println(<span class="string">"\n--------------\n"</span>);</span><br><span class="line">                    System.out.print(<span class="string">"子节点："</span> + event.getData().getPath() + <span class="string">" 数据更新成功，"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"子节点："</span> + event.getData().getPath() + <span class="string">" 新的数据为："</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">200000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭客户端</span></span><br><span class="line">        curatorConnect.closeZKClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前客户端的状态</span></span><br><span class="line">        isZkCuratorStarted = curatorConnect.client.isStarted();</span><br><span class="line">        System.out.println(<span class="string">"当前客户端的状态："</span> + (isZkCuratorStarted ? <span class="string">"连接中..."</span> : <span class="string">"已关闭..."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来看看Apache Curator客户端的使用吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记9-原生Java API使用</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B09-%E5%8E%9F%E7%94%9FJava%20API%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记9-原生Java API使用/</id>
    <published>2019-02-23T08:41:33.698Z</published>
    <updated>2019-02-23T08:44:39.765Z</updated>
    
    <content type="html"><![CDATA[<p>本文来介绍原生的API来操作ZK节点，从而引出下节要说明的Curator客户端。</p><a id="more"></a><h2>环境准备</h2><p>新建一个普通的java项目即可，然后引入一些jar包的依赖：</p><p><img src="http://bloghello.oursnail.cn/18-12-9/86051910.jpg" alt="image"></p><p>代码在<code>code-for-chapter9</code></p><h2>客户端与ZK建立连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConnect</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String serverPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * serverPath:可以是一个ip，也可以是多个ip</span></span><br><span class="line"><span class="comment">         * sessionTimeout：超时时间，心跳收不到，就超时</span></span><br><span class="line"><span class="comment">         * watcher：通知事件，如果有对应的事件发生触发，则客户端会收到通知</span></span><br><span class="line"><span class="comment">         * canBeReadOnly：可读，当这个物理机节点断开以后，还是可以读到数据的，只是不能写</span></span><br><span class="line"><span class="comment">         * 此时数据被读取到的可能是旧数据，此处建议设置为false</span></span><br><span class="line"><span class="comment">         * sessionId：会话的ID</span></span><br><span class="line"><span class="comment">         * sessionPassword：会话密码 当会话消失以后，可以一句sessionId和sessionPasswd重新获取会话</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(serverPath,<span class="number">5</span>*<span class="number">1000</span>,<span class="keyword">new</span> ZKConnect());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"客户端开始连接zk...，连接状态为:"</span>+zk.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 休息一段时间，保证让节点状态看到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"连接状态为:"</span>+zk.getState());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接受到的watch通知："</span>+watchedEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>会话重连机制</h2><p>主要的思路就是上一个程序注释中所描述:用上一次连接的sessionId和sessionPasswd这两个参数代入到下次连接中，就可以重新获取上一次的连接了。</p><p>下面就是不断地看seesionId来判断是否为同一个连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConnectSessionWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String serverPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line">        <span class="keyword">long</span> sessionId = <span class="number">999L</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] sessionPasswd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(serverPath,<span class="number">5</span>*<span class="number">1000</span>,<span class="keyword">new</span> ZKConnectSessionWatcher());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果状态时已连接了，就获取sessionId</span></span><br><span class="line">        <span class="keyword">if</span> (zk.getState().equals(ZooKeeper.States.CONNECTED))&#123;</span><br><span class="line">            sessionId = zk.getSessionId();</span><br><span class="line">            System.out.println(sessionId);</span><br><span class="line"></span><br><span class="line">            String ssid = <span class="string">"0x"</span> + Long.toHexString(sessionId);</span><br><span class="line">            <span class="comment">//对sessionId经过64位编码之后的值，也就是dump命令查出来的sessionId值</span></span><br><span class="line">            System.out.println(ssid);</span><br><span class="line"></span><br><span class="line">            sessionPasswd = zk.getSessionPasswd();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第2次连接，会话重连，那么用sessionID和password来进行来重新获取连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"会话重连..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ZooKeeper zkSession = <span class="keyword">new</span> ZooKeeper(serverPath,<span class="number">5</span>*<span class="number">1000</span>,<span class="keyword">new</span> ZKConnectSessionWatcher(),sessionId,sessionPasswd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"重连之后的sessionId为："</span>+zkSession.getSessionId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接受到的watch通知："</span>+watchedEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>节点的增删改查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKNodeOperator</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String serverPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZooKeeper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZooKeeper</span><span class="params">(ZooKeeper zooKeeper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKNodeOperator</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKNodeOperator</span><span class="params">(String connectionString,<span class="keyword">int</span> sessionTimeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(connectionString,sessionTimeout,<span class="keyword">new</span> ZKNodeOperator());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span>(zooKeeper != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zooKeeper.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZKNodeOperator zkServer = <span class="keyword">new</span> ZKNodeOperator(serverPath,<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 同步创建节点</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * zkServer.syncCreateZkNode(path,data,acls);</span></span><br><span class="line"><span class="comment">         * path：节点路径</span></span><br><span class="line"><span class="comment">         * data：节点数据</span></span><br><span class="line"><span class="comment">         * acls：节点权限，有Id ANYONE_ID_UNSAFE = new Id("world", "anyone");和Id AUTH_IDS = new Id("auth", "");</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            zkServer.getZooKeeper().create("/testNode1","123".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (KeeperException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 异步创建节点</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * path：节点路径</span></span><br><span class="line"><span class="comment">         * data：节点数据</span></span><br><span class="line"><span class="comment">         * acls：权限</span></span><br><span class="line"><span class="comment">         * mode：持久类型还是其他类型</span></span><br><span class="line"><span class="comment">         * callback：异步的回调函数</span></span><br><span class="line"><span class="comment">         * ctx：回调内容</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        String ctx = "&#123;'create':'success'&#125;";</span></span><br><span class="line"><span class="comment">        zkServer.getZooKeeper().create("/testNode2","456".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT,new CreateCallBack(),ctx);</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 同步修改节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            zkServer.getZooKeeper().setData("/testNode1","update123".getBytes(),0);//版本必须要对</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (KeeperException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 异步修改节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        String ctx = "&#123;'update':'success'&#125;";</span></span><br><span class="line"><span class="comment">        zkServer.getZooKeeper().setData("/testNode1","update123456".getBytes(),1,new UpdateCallBack(),ctx);</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 同步删除节点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            zkServer.getZooKeeper(). delete("/testNode1",2);</span></span><br><span class="line"><span class="comment">            Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">        &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (KeeperException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 异步删除数据</span></span><br><span class="line">        </span><br><span class="line">        String ctx = <span class="string">"&#123;'delete':'success'&#125;"</span>;</span><br><span class="line">        zkServer.getZooKeeper().delete(<span class="string">"/testNode1"</span>,<span class="number">0</span>,<span class="keyword">new</span> DeleteCallBack(),ctx);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"watch被触发..."</span>+watchedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>countDownLatch</h2><p>上面学习了对于节点的增删改，还差一个查，这里先学习一下<code>countDownLatch</code>：</p><p>demo的场景是：有一个监控中心，监控很多地方的调度中心的情况，每检查一个，就返回一个状态，直到所有的调度中心都检查完。</p><p>代码在文件夹<code>countdownlatchdemo</code>.</p><p>这个玩意就是一个计数器。引入这个玩意，是为了配合下面的案例，使得线程能挂起，我们可以测试数据变化一下，然后触发watcher,拿到变化后的值，然后主线程执行结束。</p><h2>获取父节点数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKGetNodeData</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String serverPath = <span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKGetNodeData</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKGetNodeData</span><span class="params">(String connectionString,<span class="keyword">int</span> sessionTimeout)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(connectionString,sessionTimeout,<span class="keyword">new</span> ZKGetNodeData());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span>(zooKeeper != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zooKeeper.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        ZKGetNodeData zkServer = <span class="keyword">new</span> ZKGetNodeData(serverPath,<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] resByte = zkServer.getZooKeeper().getData(<span class="string">"/hello"</span>,<span class="keyword">true</span>,stat);</span><br><span class="line">        String result = <span class="keyword">new</span> String(resByte);</span><br><span class="line">        System.out.println(<span class="string">"当前值:"</span>+result);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(event.getType() == Event.EventType.NodeDataChanged)&#123;</span><br><span class="line">                ZKGetNodeData zkServer = <span class="keyword">new</span> ZKGetNodeData(serverPath,<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] resByte = zkServer.getZooKeeper().getData(<span class="string">"/hello"</span>,<span class="keyword">true</span>,stat);</span><br><span class="line">                String result = <span class="keyword">new</span> String(resByte);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"更改后的值："</span>+result);</span><br><span class="line">                System.out.println(<span class="string">"版本："</span>+stat.getVersion());</span><br><span class="line"></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType() == Event.EventType.NodeCreated)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType() == Event.EventType.NodeChildrenChanged)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.getType() == Event.EventType.NodeDeleted)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">getZooKeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZooKeeper</span><span class="params">(ZooKeeper zooKeeper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zooKeeper = zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>获取子节点数据</h2><p>基本同上，见代码<code>ZKGetChildrenList</code></p><h2>判断节点是否存在</h2><p>基本同上，见代码<code>ZKNodeExist</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来介绍原生的API来操作ZK节点，从而引出下节要说明的Curator客户端。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记8-典型应用场景详解</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B08-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记8-典型应用场景详解/</id>
    <published>2019-02-23T08:17:03.090Z</published>
    <updated>2019-02-23T08:17:46.045Z</updated>
    
    <content type="html"><![CDATA[<p>本章对于zk的应用场景和解决方案进行详细的介绍。</p><a id="more"></a><h2>一、从应用程序的角度看ZooKeeper</h2><p><img src="http://bloghello.oursnail.cn/18-12-9/13282729.jpg" alt="image"></p><p>ZNode之间的层级关系就像文件系统的目录结构一样，但和传统的磁盘文件系统不同的是全量数据都存储在内存中，以此来实现提高服务器吞吐、减少延迟的目的，从这一点来说应用只应该存储控制信息和配置信息到ZNode，而不应该用它来存储大量数据。</p><p>ZNode可以分为持久节点和临时节点两类。持久节点是指一旦该ZNode被创建了，除非主动进行删除操作，这个节点就会一直存在；而临时节点的生命周期会和客户端会话绑定在一起，一旦客户端会话失效其所创建的所有临时节点都会被删除。</p><p>ZK还支持客户端创建节点时指定一个特殊的SEQUENTIAL属性，这个节点被创建的时候ZK会自动在其节点名后面追加上一个整形数字，该数字是一个由服务端维护的自增数字，以此实现创建名称自增的顺序节点。</p><h2>二、监听器Watcher</h2><p>Watcher是ZK中很重要的特性，ZK允许用户在指定节点上注册一些Watcher，在该节点相关特定事件（比如节点添加、删除、子节点变更等）发生时Watcher会监听到，ZK服务端会将事件通知到感兴趣的客户端上去，该机制是ZK实现分布式协调服务的重要特性。</p><p>通知的时候服务端只会告诉客户端一个简单的事件（通知状态、事件类型、节点路径）而不包含具体的变化信息（如原始数据及变更后的数据），客户端如要具体信息再次主动去重新获取数据；此外，无论是服务端还是客户端，只要Watcher被触发ZK就会将其删除，因此在Watcher的使用上需要反复注册，这样轻量的设计有效减轻了服务端压力，如果Watcher一直有效，节点更新频繁时服务端会不断向客户端发送通知，对网络及服务端性能影响会非常大。</p><h2>三、典型应用场景</h2><h3>3.1 数据发布/订阅（以Dubbo注册中心为例）</h3><p>Dubbo是阿里集团开源的分布式服务框架，致力于提供高性能和透明化的远程服务调用解决方案和基于服务框架展开的完整SOA服务治理方案。</p><p>其中服务自动发现是最核心的模块之一，该模块提供基于注册中心的目录服务，使服务消费方能够动态的查找服务提供方，让服务地址透明化，同时服务提供方可以平滑的对机器进行扩容和缩容，其注册中心可以基于提供的外部接口来实现各种不同类型的注册中心，例如数据库、ZK和Redis等。接下来看一下基于ZK实现的Dubbo注册中心。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/10130945.jpg" alt="image"></p><ul><li><code>/dubbo</code>: 这是Dubbo在ZK上创建的根节点。</li><li><code>/dubbo/com.foo.BarService</code>: 这是服务节点，代表了Dubbo的一个服务。</li><li><code>/dubbo/com.foo.BarService/Providers</code>: 这是服务提供者的根节点，其子节点代表了每个服务的真正提供者。</li><li><code>/dubbo/com.foo.BarService/Consumers</code>: 这是服务消费者的根节点，其子节点代表了没一个服务的真正消费者</li><li>Dubbo基于ZK实现注册中心的工作流程：<ul><li>服务提供者：在初始化启动的时候首先在<code>/dubbo/com.foo.BarService/Providers</code>节点下创建一个子节点，同时写入自己的url地址，代表这个服务的一个提供者。</li><li>服务消费者：在启动的时候读取并订阅ZooKeeper上<code>/dubbo/com.foo.BarService/Providers</code>节点下的所有子节点，并解析所有提供者的url地址类作为该服务的地址列表，开始发起正常调用。同时在Consumers节点下创建一个临时节点，写入自己的url地址，代表自己是BarService的一个消费者</li><li>监控中心：监控中心是Dubbo服务治理体系的重要一部分，它需要知道一个服务的所有提供者和订阅者及变化情况。监控中心在启动的时候会通过ZK的<code>/dubbo/com.foo.BarService</code>节点来获取所有提供者和消费者的url地址，并注册Watcher来监听其子节点变化情况</li></ul></li></ul><p><strong>所有服务提供者在ZK上创建的节点都是临时节点</strong>，利用的是临时节点的生命周期和客户端会话绑定的特性，一旦提供者机器挂掉无法对外提供服务时该临时节点就会从ZK上摘除，这样服务消费者和监控中心都能感知到服务提供者的变化。</p><h3>3.2 命名服务</h3><p>命名服务也是分布式系统中比较常见的一类场景，被命名的实体通常可以是集群中的机器、提供的服务地址或远程对象，其中较为常见的是一些分布式服务框架中的服务地址列表，通过使用命名服务客户端应用能够指定名字来获取资源的实体、服务地址和提供者的信息等。</p><h3>3.3 Master选举</h3><p>当前系统的mater节点挂了怎么办？那就要重新选出一个master来。</p><p>ZK创建节点时有一个重要的特性，利用ZK的强一致性能够很好的保证在分布式高并发情况下节点的创建一定能够保证全局唯一，即ZK会保证客户端无法重复创建一个已经存在的数据节点。也就是说同时有多个客户端请求创建同一个节点最终一定只有一个客户端能够请求创建成功，利用这个特性就能很容易的在分布式环境中进行Master选举了。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/39480696.jpg" alt="image"></p><p>进行Master选举时客户端启动后可以向ZK请求创建一个临时节点，例如<code>/master_election/master</code>。在多个客户端创建时只有一个能创建成功，那么这个创建成功的客户端所在的机器就成为了Master。</p><p>同时其他没有创建成功的客户端都可以在节点<code>/master_election</code>上注册一个子节点变更的Watcher来监控当前Master是否在线，一旦发现Master挂了临时节点会被删除，其它客户端会收到通知，开始重新进行Master选举。</p><h3>3.4 分布式锁</h3><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同系统或同一系统不同机器之间共享了同一资源，那访问这些资源时通常需要一些互斥手段来保证一致性，这种情况下就需要用到分布式锁了。</p><p>接下来看下使用ZK如何实现排他锁。排他锁的核心是如何保证当前有且只有一个事务获得锁，并且锁被释放后所有等待获取锁的事务能够被通知到。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/33804933.jpg" alt="image"></p><p>和Master选举类似，在需要获取排他锁时，所有客户端都会试图在<code>/exclusive_lock</code>下创建临时子节点<code>/exclusive_lock/lock</code>，最终只有一个客户端能创建成功，该客户端就获取到了锁。</p><p>同时没有获取到锁的客户端需要到<code>/exclusive_lock</code>节点上注册一个子节点变更的Watcher监听，用于实时监听lock节点的变更情况。</p><p><code>/exclusive_lock/lock</code>是一个临时节点，在一下两种情况下都有可能释放锁：</p><ul><li>当获取锁的客户端挂掉，ZK上的该节点会被删除</li><li>正常执行完业务逻辑之后客户端会主动将自己创建的临时节点删除。</li></ul><p>无论在什么情况下删除了lock临时节点ZK都会通知在<code>/exclusive_lock</code>节点上注册了子节点变更Watcher监听的客户端，重新发起锁的获取。</p><h3>3.5 分布式屏障</h3><p>分布式屏障，举个栗子，在大规模分布式并行计算的场景下，最终的合并计算需要基于很多并行计算的子结果来进行，即系统需要满足特定的条件，一个队列的元素必须都聚齐之后才能进行后续处理，否则一直等待。看下如何用ZK来支持这种场景。</p><p><img src="http://bloghello.oursnail.cn/18-12-9/11515311.jpg" alt="image"></p><p>开始时<code>/queue_barrier</code>是一个存在的节点，数据内容赋值为一个数字n来代表满足条件的机器总数，例如n=10表示只有当<code>/queue_barrier</code>节点下的子节点数量达到10后才会打开屏障继续处理。</p><p>然后所有的客户端都会到<code>/queue_barrier</code>节点下创建一个临时节点，如<code>/queue_barrier/192.168.0.1</code>。创建完节点之后根据以下步骤来确定执行顺序:</p><ul><li>1、调用获取节点数据的api获取<code>/queue_barrier</code>节点的内容：10</li><li>2、调用获取子节点总数的api获取<code>/queue_barrier</code>下的所有子节点，并且注册对子节点变更的Watcher监听</li><li>3、统计子节点个数</li><li>4、如果子节点个数小于10则继续等待，否则打开屏障继续处理</li><li>5、接收到Watcher通知后，重复步骤2</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章对于zk的应用场景和解决方案进行详细的介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记7-ZK的基本操作以及权限控制</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B07-ZK%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记7-ZK的基本操作以及权限控制/</id>
    <published>2019-02-23T07:46:23.228Z</published>
    <updated>2019-02-23T07:48:52.697Z</updated>
    
    <content type="html"><![CDATA[<p>说了那么久的理论，但是其实对于大多数人来说，会用才是王道，在会用的基础上再去深入探讨原理可能是最佳的实践方式，但是对于笔记来说，先原理再实践可能更为稳妥，本文介绍zk最基本的一些操作，比如查看节点、增加一个节点、Watch机制以及ACL权限控制等基本命令，最后还介绍了一下为了方便而产生的四字命令。</p><a id="more"></a><h2>基本数据模型</h2><ul><li>树形结构，每个节点成为znode，它可以有子节点，也可以有数据</li><li>临时节点和永久节点，临时节点在客户端断开后消失</li><li>每个zk节点都有各自的版本号，可以通过命令行来显示节点信息</li><li>每当节点数据发生变化，那么该节点的版本号会累加（<strong>乐观锁</strong>）</li><li>删除/修改过时节点，版本号不匹配则会报错</li><li>每个zk节点存储的数据不宜过大，几k即可</li><li>节点可以设置acl，可以通过权限来限制用户的访问</li></ul><h2>zk的作用</h2><ul><li>master选举，保证集群是高可用的</li><li>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器</li><li>发布与订阅，dubbo发布者把数据存在znode上，订阅者可以读取这个数据</li><li>分布式锁</li><li>集群管理，集群中保证数据的强一致性</li></ul><h2>zk的基本操作</h2><ul><li><code>ls /</code> 显示根节点名称</li><li><code>ls2 /</code> 显示了根节点的状态信息（stat也可以看状态）</li><li><code>get /</code> 拿出节点的数据和信息</li><li><code>create [-s] [-e] path data acl</code> 创建节点，如果是默认创建，则是非顺序的、 持久的节点。加上-e则是临时节点；加上-s表示顺序节点</li><li><strong>【注1】</strong>：如果是持久节点，状态信息中的ephemeralOwner=0x0；临时节点的这个属性，是后面一串比较长的字符</li><li><strong>【注2】</strong>：客户端断开连接了，一段时间之后，那么临时节点就会消失（主要是有个时效，超出这个时间还不收到来自客户端的心跳包则才认定客户端挂了）</li><li><strong>【注3】</strong>：在加上-s后，创建的节点会重命名为一个累加的名称</li><li><code>set path newData</code> 每次修改值后<code>dataVersion</code>数据版本号会增1</li><li><strong>【注4】</strong>：如何实现乐观锁？<code>set path data version</code>,就是说带上版本号，如果这个版本不对应，那么就修改失败</li><li><code>delete path version</code> 删除节点</li></ul><h2>watcher机制</h2><ul><li>针对每个节点的操作，都会有一个监督者<code>watcher</code></li><li>当监控的某个对象(znode)发生了变化，则触发watcher事件</li><li>zk中watcher是一次性的，触发后立即销毁（用其他的开源客户端开源让其不会销毁，重复触发）</li><li>父节点以及他的子孙们的 增 删 改 都能够触发其watcher</li><li>针对不同类型的事件，触发的watcher事件也不同：<ul><li>（子）节点创建事件</li><li>（子）节点删除事件</li><li>（子）节点数据变化事件</li></ul></li><li>通过<code>get path [watch]</code>或者<code>stat path [watch]</code>或者<code>ls path [watch]</code>都可以设置watcher</li><li>父节点 增 删 改 操作触发watcher</li><li>子节点 增 删 改 操作触发watcher</li></ul><h3>【创建父节点触发】：NodeCreated</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 24] stat /hello watch  </span><br><span class="line">Node does not exist: /hello</span><br><span class="line">[zk: localhost:2181(CONNECTED) 25] create /hello world</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">Created /hello</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeCreated path:/hello</span><br></pre></td></tr></table></figure><h3>【修改父节点数据触发】：NodeDataChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 26] stat /hello watch</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 27] get /hello</span><br><span class="line">world</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 28] set /hello lalala</span><br><span class="line"></span><br><span class="line">WATCHER::cZxid = 0x300000011</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/helloctime = Sat Dec 08 20:00:53 CST 2018</span><br></pre></td></tr></table></figure><h3>【删除父节点触发】：NodeDeleted</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 32] get /hello watch</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 33] delete /hello</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">[zk: localhost:2181(CONNECTED) 34]</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDeleted path:/hello</span><br></pre></td></tr></table></figure><h3>【创建子节点触发】：ls为父节点设置watcher，创建子节点触发NodeChildrenChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 52] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 53] create /hello world</span><br><span class="line">Created /hello</span><br><span class="line">[zk: localhost:2181(CONNECTED) 54] ls /hello watch</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 55] create /hello/helloson worldson</span><br><span class="line"></span><br><span class="line">WATCHER::Created /hello/helloson</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/hello</span><br></pre></td></tr></table></figure><h3>【删除子节点触发】：ls为父节点设置watcher，删除子节点触发NodeChildrenChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 56] ls /hello</span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 57] ls /hello watch</span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 58] delete /hello/helloson</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">[zk: localhost:2181(CONNECTED) 59]</span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/hello</span><br></pre></td></tr></table></figure><h3>【更新子节点触发】：ls为父节点设置watcher，更新子节点不触发事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 59] ls /hello</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 60] create /hello/helloson worldson</span><br><span class="line">Created /hello/helloson</span><br><span class="line">[zk: localhost:2181(CONNECTED) 61] ls /hello watch </span><br><span class="line">[helloson]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 62] set /hello/helloson worldsonhahaha</span><br><span class="line">cZxid = 0x300000020</span><br><span class="line">ctime = Sat Dec 08 20:15:05 CST 2018</span><br><span class="line">mZxid = 0x300000021</span><br><span class="line">mtime = Sat Dec 08 20:16:06 CST 2018</span><br><span class="line">pZxid = 0x300000020</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 14</span><br><span class="line">numChildren = 0</span><br><span class="line">[zk: localhost:2181(CONNECTED) 63] get /hello/helloson</span><br><span class="line">worldsonhahaha</span><br></pre></td></tr></table></figure><p>就算是设置成<code>ls /hello/helloson watch</code>也不行。只有这样才可以触发watcher:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 72] get /swg/swgson watch</span><br><span class="line">8080</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 74] set /swg/swgson 7070</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line">cZxid = 0x300000024</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeDataChanged path:/swg/swgsonctime = Sat Dec 08 20:18:53 CST 2018</span><br></pre></td></tr></table></figure><p>为什么更新子节点的时候ls不行，但是get就行呢？客户端要想收到更新子节点内容的消息的话，不能通过子节点的事件来触发，必须把子节点当作父节点来做。然而<code>ls path [watch] ：查询指定路径下的子节点</code>所以是针对的子节点，所以不能触发这个事件；而<code>get path [watch] : 查询指定节点中的数据，如果节点中有数据</code>或者<code>stat path [watch] : 查询指定节点的一些描述信息</code>这些直接是操作这个节点，把这个节点当作是父节点，所以能起作用。</p><h2>watcher使用场景</h2><p>Watcher是ZK中很重要的特性，ZK允许用户在指定节点上注册一些Watcher，在该节点相关特定事件（比如节点添加、删除、子节点变更等）发生时Watcher会监听到，ZK服务端会将事件通知到感兴趣的客户端上去，该机制是ZK实现分布式协调服务的重要特性。</p><p>通知的时候服务端只会告诉客户端一个简单的事件（通知状态、事件类型、节点路径）而不包含具体的变化信息（如原始数据及变更后的数据），客户端如要具体信息再次主动去重新获取数据；此外，无论是服务端还是客户端，只要Watcher被触发ZK就会将其删除，因此在Watcher的使用上需要反复注册，这样轻量的设计有效减轻了服务端压力，如果Watcher一直有效，节点更新频繁时服务端会不断向客户端发送通知，对网络及服务端性能影响会非常大。</p><p>比如统一资源配置。</p><h2>ACL 权限控制列表</h2><ul><li>针对节点可以设置相关读写等权限，目的是为了保障数据安全性</li><li>权限permissions可以指定不同的权限范围以及角色</li><li><code>getAcl</code>：获取某个节点的acl权限信息</li><li><code>setAcl</code>：设置某个节点的acl权限信息</li><li><code>addauth</code>：注册某个用户，要把某个用户的用户名和密码输入到系统中进行注册，用户才能登陆。</li><li>默认权限：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 76] getAcl /swg</span><br><span class="line">&apos;world,&apos;anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure><ul><li>ACL构成：zk的acl通过[scheme🆔permissions]来构成权限列表，其中<code>scheme</code>指采用的某种权限机制；<code>id</code>指允许访问的用户；<code>permissions</code>指权限组合字符串</li><li><code>scheme</code>：主要是四种<ul><li><code>world</code>：<code>world</code>下只有一个<code>id</code>，即只有一个用户，也就是<code>anyone</code>，那么组合的写法就是<code>world:anyone:[permissions]</code></li><li><code>auth</code>：代表认证登陆，需要注册用户有权限就可以，形式为<code>auth:user:password:[permissions]</code>,密码是明文</li><li><code>degest</code>：需要对密码加密才能访问，组合形式为<code>digest:username:BASE64(SHA(password)):[permissions]</code>，密码是加密的</li><li><code>ip</code>：当设置为ip指定的ip地址，此时限制ip进行访问，比如<code>ip:192.168.1.1:[permissions]</code></li><li><code>super</code>：代表超级管理员，拥有所有权限</li></ul></li><li><code>id</code>：代表允许访问的用户</li><li><code>permissions</code>：<ul><li><code>c</code>：create,创建当前节点的子节点权限</li><li><code>r</code>：read,获取当前节点或者子节点列表</li><li><code>w</code>：write,设置当前节点的数据</li><li><code>d</code>：delete，删除子节点</li><li><code>a</code>：admin，是比较高的权限，可以去设置和修改权限，即拥有分配权限的权限</li></ul></li></ul><ul><li><code>world:anyone:cdrwa</code>：对于默认权限，我们可以修改他的权限字符串，如<code>setAcl path world:anyone:crwa</code></li><li><code>auth</code>和<code>digest</code>：先<code>addauth digest username:password（明文密码）</code>注册用户,然后<code>setAcl path auth:username:password（明文密码）:cdrwa</code>就可以设置ACL了。再去<code>getAcl path</code>查询到的密码时加密后的。</li><li><code>digest</code>：要先退出刚才的<code>auth</code>的账号，直接重启当前客户端即可。<code>setAcl path digest:username:password（密文密码）:cdrwa</code>。再去<code>getAcl path</code>查询到的密码时加密后的。此时访问、删除、创建节点比如<code>get path</code>是需要登陆的，即先<code>addauth digest username:password（明文密码）</code>登陆。</li><li><code>ip</code>：<code>setAcl path ip:192.168.1.1:cdrwa</code></li><li><code>super</code>：最高权限，修改<code>zkServer.sh</code>增加super管理员，重启<code>zkServer.sh</code>。到<code>bin</code>目录下修改<code>zkServer.sh</code>增加配置：</li></ul><p>找到这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup $JAVA &quot;-Dzookeeper.log.dir=$&#123;ZOO_LOG_DIR&#125;&quot; &quot;-Dzookeeper.root.logger=$&#123;ZOO_LOG4J_PROP&#125;&quot;</span><br></pre></td></tr></table></figure><p>在后面继续添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=username:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</span><br></pre></td></tr></table></figure><h2>ACL常用使用场景</h2><ul><li>开发/测试环境分离，开发者无权限操作测试库的节点，只能看。比如分为开发节点和测试节点。</li><li>生产环境上控制指定ip的服务可以访问相关节点防止混乱</li></ul><h2>zk四字命令</h2><ul><li>zk可以通过它自身提供的简写命令来和服务器进行交互</li><li>需要使用到 <code>nc</code> 命令，<code>yum install nc</code></li><li><code>echo [command] | nc [ip] [port]</code><ul><li>【stat】查看zk的状态信息，以及是单机还是集群状态：<code>echo stat | nc ip或者localhost 2181</code></li><li>【ruok】查看当前zkServer是否启动，正常返回imok：<code>echo ruok | nc ip 2181</code></li><li>【dump】列出未经处理的会话和临时节点：<code>echo dump | nc ip 2181</code></li><li>【conf】查看服务配置</li><li>【cons】展示连接到服务器的客户端信息</li><li>【envi】环境变量，显示jdk和zk等环境变量的信息</li><li>【mntr】监控zk健康信息</li><li>【wchs】展示watch的信息</li><li>【wchc】与【wchp】：分别展示session与watch及path与watcher的信息，默认这两个命令是不能访问的，需要将他们列入白名单才行</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说了那么久的理论，但是其实对于大多数人来说，会用才是王道，在会用的基础上再去深入探讨原理可能是最佳的实践方式，但是对于笔记来说，先原理再实践可能更为稳妥，本文介绍zk最基本的一些操作，比如查看节点、增加一个节点、Watch机制以及ACL权限控制等基本命令，最后还介绍了一下为了方便而产生的四字命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记6-zk安装和集群搭建</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B06-zk%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记6-zk安装和集群搭建/</id>
    <published>2019-02-23T07:24:59.806Z</published>
    <updated>2019-02-23T07:25:21.850Z</updated>
    
    <content type="html"><![CDATA[<p>本章会回顾一下ZAB协议，然后介绍一下集群搭建的配置文件。</p><a id="more"></a><h2>前言</h2><p>回顾一下<code>ZAB</code>协议。<code>Zab</code>协议包括两个核心：</p><p><strong>第一，原子广播</strong></p><p>客户端提交事务请求时<code>Leader</code>节点为每一个请求生成一个事务<code>Proposal</code>，将其发送给集群中所有的<code>Follower</code>节点，收到过半<code>Follower</code>的反馈后开始对事务进行提交。</p><p>这也导致了<code>Leader</code>崩溃后可能会出现数据不一致的情况，ZAB使用了崩溃恢复来处理数字不一致问题；</p><p>消息广播使用了TCP协议进行通讯所有保证了接受和发送事务的顺序性。广播消息时<code>Leader</code>节点为每个事务<code>Proposal</code>分配一个全局递增的<code>ZXID</code>（事务ID），每个事务<code>Proposal</code>都按照<code>ZXID</code>顺序来处理；</p><p><code>Leader</code>节点为每一个<code>Follower</code>节点分配一个队列按事务<code>ZXID</code>顺序放入到队列中，且根据队列的规则FIFO来进行事务的发送。</p><p><code>Follower</code>节点收到事务<code>Proposal</code>后会将该事务以事务日志方式写入到本地磁盘中，成功后反馈<code>Ack</code>消息给<code>Leader</code>节点。</p><p>收到过半<code>ACK</code>反馈之后，同时向所有的<code>Follower</code>节点广播<code>Commit</code>消息，<code>Follower</code>节点收到<code>Commit</code>后开始对事务进行提交；</p><p><strong>第二，Master选举</strong></p><p>里面用的算法叫做：<code>Fast Leader Election</code>。</p><ul><li><code>epoch</code>：选举轮数,即周期，就是之前说的逻辑时钟<code>logicClock</code></li><li><code>Zxid</code>: <code>Zxid</code> 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，针对客户端每一个事务请求，计数器加 1；而高 32 位则代表 <code>Leader</code> 周期 <code>epoch</code> 的编号，每个当选产生一个新的 <code>Leader</code> 服务器，就会从这个 <code>Leader</code> 服务器上取出其本地日志中最大事务的<code>ZXID</code>，并从中读取 <code>epoch</code> 值，然后加 1，以此作为新的 <code>epoch</code>，并将低 32 位从 0 开始计数。</li></ul><p><strong>成为leader的条件</strong></p><ul><li>选<code>epoch</code>最大的</li><li><code>epoch</code>相等，选 <code>zxid</code> 最大的</li><li><code>epoch</code>和<code>zxid</code>都相等，选择<code>server id</code>最大的（就是我们配置<code>zoo.cfg</code>中的<code>myid</code>）</li></ul><p><strong>选举的基本步骤</strong></p><ol><li>每个从节点都向其他节点发送选自身为<code>Leader</code>的<code>Vote</code>投票请求，等待回复；</li><li>从节点接受到的<code>Vote</code>如果比自身的大（ZXID更新）时则投票，并更新自身的<code>Vote</code>，否则拒绝投票；</li><li>每个从节点中维护着一个投票记录表，当某个节点收到过半的投票时，结束投票并把该从节点选为<code>Leader</code>，投票结束；</li></ol><p>具体一点的步骤：</p><ul><li>1、发起一轮投票选举，推举自己作为<code>leader</code>，通知所有的服务器，等待接收外部选票。</li><li>2、只要当前服务器状态为<code>LOOKING</code>，进入循环，不断地读取其它<code>Server</code>发来的通知、进行比较、更新自己的投票、发送自己的投票、统计投票结果，直到<code>leader</code>选出或出错退出。具体做法：<ul><li>2.1 如果发送过来的逻辑时钟大于目前的逻辑时钟，那么说明这是更新的一次选举投票，此时更新本机的逻辑时钟（<code>logicalclock</code>），清空投票箱（因为已经过期没有用了）调用<code>totalOrderPredicate</code>函数判断对方的投票是否优于当前的投票（见下面代码），是的话用对方推荐的<code>leader</code>更新下一次的投票，否则使用初始的投票（投自己），调用<code>sendNotifications()</code> 通知所有服务器我的选择，跳到2.4。</li><li>2.2 如果对方处于上轮投票，不予理睬，回到2。</li><li>2.3 如果对方也处于本轮投票，调用<code>totalOrderPredicate</code>函数判断对方的投票是否优于当前的投票，是的话更新当前的投票，否则使用初始的投票（投自己）并新生成<code>notification</code>消息放入发送队列。调用<code>sendNotifications()</code> 通知所有服务器我的选择。</li><li>2.4 将收到的投票放入自己的投票箱中。</li><li>2.5 调用计票器的<code>containsQuorum</code>函数，判断所推荐的leader是否得到集群多数人的同意，如果得到多数人同意，那么还需等待一段时间，看是否有比当前更优的提议，如果没有，则认为投票结束。根据投票结果修改自己的状态。以上任何一条不满足，则继续循环。</li></ul></li></ul><p>关于<code>totalOrderPredicate</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">totalOrderPredicate</span><span class="params">(<span class="keyword">long</span> newId, <span class="keyword">long</span> newZxid, <span class="keyword">long</span> newEpoch, <span class="keyword">long</span> curId, <span class="keyword">long</span> curZxid, <span class="keyword">long</span> curEpoch)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    LOG.debug(<span class="string">"id: "</span> + newId + <span class="string">", proposed id: "</span> + curId + <span class="string">", zxid: 0x"</span> +</span><br><span class="line">    </span><br><span class="line">            Long.toHexString(newZxid) + <span class="string">", proposed zxid: 0x"</span> + Long.toHexString(curZxid));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用计票器判断当前server的权重是否为0</span></span><br><span class="line">    <span class="keyword">if</span>(self.getQuorumVerifier().getWeight(newId) == <span class="number">0</span>)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Epoch、zxid、id来比较两个候选leader</span></span><br><span class="line">    <span class="keyword">return</span> ((newEpoch &gt; curEpoch) ||</span><br><span class="line">    </span><br><span class="line">            ((newEpoch == curEpoch) &amp;&amp;</span><br><span class="line">    </span><br><span class="line">            ((newZxid &gt; curZxid) || ((newZxid == curZxid) &amp;&amp; (newId &gt; curId)))));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>总结起来就是一句话：若干个节点，第一次都是投给自己；后面就是，尽量向数据最新的节点靠拢，可以理解为：每个节点贫富有差距，富有的节点让贫穷的节点投自己一票，那么贫穷的节点会接受，反之不行，那么最先拿到超过一半的贫穷的节点的投票，就成为leader。（贫穷与富有都是相对的，越富有越可能成为leader）。</strong></p><h2>zk集群搭建</h2><p>首先准备三份解压文件，每一份中都新建一个叫<code>data</code>的文件夹：里面新建一个叫做myid的文件，第一个写1，后面递增。</p><p>每一份中配置文件改为<code>zoo.cfg</code>。zk1对应的zoo.cfg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick 心跳检测时间</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line"># 集群启动后，相互连接，如果在initLimit*tickTime时间内没有连接成功，那么认为连接失败</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># Masrer和slave之间或者slave和slave之间的数据同步时间，在syncLimit*tickTime是按内没有返回一个ACk，则</span><br><span class="line"># 认为该节点宕机，如果是Master宕机了，就要重新选举了</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 数据存放的目录，这是我新建的</span><br><span class="line">dataDir=D:/zookeeper1-3.4.10/data</span><br><span class="line"># dataLogDir = xx</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># 客户端连接集群的端口号</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第一个端口是数据同步的端口号  第二个端口是选举的端口号</span><br><span class="line">server.1=127.0.0.1:2887:3887</span><br><span class="line">server.2=127.0.0.1:2888:3888</span><br><span class="line">server.3=127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure><p>后面一次递增这个<code>clientPort</code>和<code>data</code>文件夹位置。</p><p>依次启动即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章会回顾一下ZAB协议，然后介绍一下集群搭建的配置文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记5-ZAB协议</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B05-ZAB%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记5-ZAB协议/</id>
    <published>2019-02-23T07:09:59.185Z</published>
    <updated>2019-02-23T07:20:23.561Z</updated>
    
    <content type="html"><![CDATA[<p>在zookeeper中其实使用的ZAB协议来实现数据的一致性，并且主要依靠的是leader和follower这两种角色控制数据的一致性，而leader是里面最重要的一个角色，它是主要负责写操作的节点，然后与其他的follower进行数据同步，所以我们也要保证leader宕机的时候要快速选举出新的leader并且进行数据恢复。</p><a id="more"></a><h2>一、前言</h2><p>ZooKeeper是一个分布式协调服务，可用于服务发现、分布式锁、分布式领导选举、配置管理等。</p><p><strong>这一切的基础，都是ZooKeeper提供了一个类似于Linux文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。</strong></p><p>既然是一个文件系统，就不得不提ZooKeeper是如何保证数据的一致性的。本节将将介绍ZooKeeper如何保证数据一致性，如何进行领导选举，以及数据监控/通知机制的语义保证。</p><h2>二、ZAB-原子广播（重点）</h2><p><code>ZooKeeper</code>集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种：</p><ul><li><code>Leader</code>： 一个<code>ZooKeeper</code>集群同一时间只会有一个实际工作的<code>Leader</code>，它会发起并维护与各<code>Follwer</code>及<code>Observer</code>间的心跳。所有的写操作必须要通过<code>Leader</code>完成再由<code>Leader</code>将写操作广播给其它服务器。</li><li><code>Follower</code>： 一个<code>ZooKeeper</code>集群可能同时存在多个<code>Follower</code>，它会响应<code>Leader</code>的心跳。<code>Follower</code>可直接处理并返回客户端的读请求，同时会将写请求转发给<code>Leader</code>处理，并且负责在<code>Leader</code>处理写请求时对请求进行投票。</li><li><code>Observer</code>： 角色与<code>Follower</code>类似，但是无投票权。</li></ul><p><img src="http://bloghello.oursnail.cn/18-12-4/8438336.jpg" alt="image"></p><p><font color="red">为了保证写操作的一致性与可用性，ZooKeeper专门设计了一种名为原子广播（ZAB）的支持崩溃恢复的一致性协议。基于该协议，ZooKeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。</font></p><p>根据ZAB协议，所有的写操作都必须通过<code>Leader</code>完成，<code>Leader</code>写入本地日志后再复制到所有的<code>Follower</code>节点。</p><p>一旦<code>Leader</code>节点无法工作，ZAB协议能够自动从<code>Follower</code>节点中重新选出一个合适的替代者，即新的<code>Leader</code>，该过程即为领导选举。该领导选举过程，是ZAB协议中最为重要和复杂的过程。</p><h3>1、写Leader</h3><p>通过Leader进行写操作流程如下图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/18727361.jpg" alt="image"></p><p>由上图可见，通过<code>Leader</code>进行写操作，主要分为五步：</p><ul><li>客户端向<code>Leader</code>发起写请求</li><li><code>Leader</code>将写请求以<code>Proposal</code>的形式发给所有<code>Follower</code>并等待<code>ACK</code></li><li><code>Follower</code>收到<code>Leader</code>的<code>Proposal</code>后返回<code>ACK</code></li><li><code>Leader</code>得到过半数的<code>ACK</code>（<code>Leader</code>对自己默认有一个<code>ACK</code>）后向所有的<code>Follower</code>和<code>Observer</code>发送<code>Commmit</code></li><li><code>Leader</code>将处理结果返回给客户端</li></ul><p><font color="red">这里要注意：</font></p><ul><li><code>Leader</code>并不需要得到<code>Observer</code>的<code>ACK</code>，即<code>Observer</code>无投票权</li><li><code>Leader</code>不需要得到所有<code>Follower</code>的<code>ACK</code>，只要收到过半的<code>ACK</code>即可，同时<code>Leader</code>本身对自己有一个<code>ACK</code>。上图中有4个<code>Follower</code>，只需其中两个返回<code>ACK</code>即可，因为(2+1) / (4+1) &gt; 1/2</li><li><code>Observer</code>虽然无投票权，但仍须同步<code>Leader</code>的数据从而在处理读请求时可以返回尽可能新的数据</li></ul><h3>2、写Follower/Observer</h3><p>通过<code>Follower</code>/<code>Observer</code>进行写操作流程如下图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/92869076.jpg" alt="image"></p><p>从上图可见：</p><ul><li><code>Follower</code>/<code>Observer</code>均可接受写请求，但不能直接处理，而需要将写请求转发给<code>Leader</code>处理</li><li>除了多了一步请求转发，其它流程与直接写<code>Leader</code>无任何区别</li></ul><h2>3、读操作</h2><p><code>Leader</code>/<code>Follower</code>/<code>Observer</code>都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。</p><p><img src="http://bloghello.oursnail.cn/18-12-4/63826294.jpg" alt="image"></p><p>由于处理读请求不需要服务器之间的交互，<code>Follower</code>/<code>Observer</code>越多，整体可处理的读请求量越大，也即读性能越好。</p><p><font color="red">在整个消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个事务Proposal分配一个全局单调递增的唯一ID，我们称之为事务ID(即ZXID)。由于ZAB协议需要保证每一个消息严格的因果关系，因此必须将每一个事务Proposal按照其ZXID的先后顺序进行排序和处理。</font></p><p>具体的，在消息广播过程中，<code>Leader</code>服务器会为每个<code>Follower</code>服务器都<font color="red">各自分配一个单独的队列</font>，然后将需要广播的事务<code>Proposal</code>依次放入这些队列中取，并且根据FIFO策略进行消息发送。每一个<code>Follower</code>服务器在接收到这个事务<code>Proposal</code>之后，都会首先将其以事务日志的形式写入本地磁盘中，并且成功写入后反馈给<code>Leader</code>服务器一个Ack相应。当<code>Leader</code>服务器接收到过半数<code>Follower</code>的Ack响应后，就会广播一个<code>Commit</code>消息给所有的<code>Follower</code>服务器以通知其进行事务提交，同时<code>Leader</code>自身也会完成对事务的提交，而每个<code>Follower</code>服务器在接收到<code>Commit</code>消息后，也会完成对事务的提交。</p><p><font color="red">然而，在这种简化的二阶段提交模型下，无法处理Leader服务器崩溃退出而带来的数据不一致问题，因此ZAB协议添加了崩溃恢复模式来解决这个问题</font>。另外，整个消息广播协议是基于有FIFO特性的TCP协议来进行网络通信的，因此很容易地保证消息广播过程中消息接收和发送的顺序性。</p><p>在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的<code>Leader</code>服务器。因此，ZAB协议需要一个高效且可靠的<code>Leader</code>选举算法，从而确保能够快速选举出新的<code>Leader</code>。同时，<code>Leader</code>选举算法不仅仅需要让<code>Leader</code>自己知道其自身已经被选举为<code>Leader</code>，同时还需要让集群中的所有其他服务器也快速地感知到选举产生的新的<code>Leader</code>服务器。<font color="red">崩溃恢复主要包括Leader选举和数据恢复两部分</font>，下面将详细讲解<code>Leader</code>选举和数据恢复流程。</p><h2>三、支持的领导选举算法</h2><p>在3.4.10版本中，默认值为3，也即基于TCP的<code>FastLeaderElection</code>。另外三种算法已经被弃用，并且有计划在之后的版本中将它们彻底删除而不再支持。</p><p>何时触发选举？</p><p>选举<code>Leader</code>不是随时选举的，毕竟选举有产生大量的通信，造成网络IO的消耗。因此下面情况才会出现选举：</p><ul><li>集群启动</li><li>服务器处于寻找<code>Leader</code>状态</li><li>当服务器处于<code>LOOKING</code>状态时，表示当前没有<code>Leader</code>，需要进入选举流程</li><li>崩溃恢复</li><li><code>Leader</code>宕机</li><li>网络原因导致过半节点与<code>Leader</code>心跳中断</li></ul><p>下面学习一下<code>FastLeaderElection</code>的原理。</p><h2>四、名词解释</h2><h3>1、myid</h3><p>每个<code>ZooKeeper</code>服务器，都需要在数据文件夹下创建一个名为<code>myid</code>的文件，该文件包含整个<code>ZooKeeper</code>集群唯一的ID（整数）。例如，某<code>ZooKeeper</code>集群包含三台服务器，<code>hostname</code>分别为<code>zoo1</code>、<code>zoo2</code>和<code>zoo3</code>，其<code>myid</code>分别为1、2和3，则在配置文件中其ID与<code>hostname</code>必须一一对应，如下所示。在该配置文件中，server.后面的数据即为<code>myid</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=zoo1:2888:3888</span><br><span class="line">server.2=zoo2:2888:3888</span><br><span class="line">server.3=zoo3:2888:3888</span><br></pre></td></tr></table></figure><ul><li>第1个端口是通信和数据同步端口，默认是2888</li><li>第2个端口是投票端口，默认是3888</li></ul><p>数小的向数大的发起TCP连接。比如有3个节点，myid文件内容分别为1,2,3。zk集群的tcp连接顺序是1向2发起TCP连接，2向3发起TCP连接。如果有n个节点，那么tcp连接顺序也以此类推。这样整个zk集群就会连接起来</p><h3>2、zxid</h3><p>类似于<code>RDBMS</code>中的事务ID，用于标识一次更新操作的<code>Proposal ID</code>。为了保证顺序性，该<code>zxid</code>必须<strong>单调递增</strong>。因此<code>ZooKeeper</code>使用一个64位的数来表示，<strong>高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加一。低32位为该epoch内的序号，每次epoch变化，<strong>都将低32位的序号重置</strong></strong>。这样保证了<code>zxid</code>的全局递增性。</p><h3>3、服务器状态</h3><ul><li><code>LOOKING</code> 不确定<code>Leader</code>状态。该状态下的服务器认为当前集群中没有<code>Leader</code>，会发起<code>Leader</code>选举。</li><li><code>FOLLOWING</code> 跟随者状态。表明当前服务器角色是<code>Follower</code>，并且它知道<code>Leader</code>是谁。</li><li><code>LEADING</code> 领导者状态。表明当前服务器角色是<code>Leader</code>，它会维护与<code>Follower</code>间的心跳。</li><li><code>OBSERVING</code> 观察者状态。表明当前服务器角色是<code>Observer</code>，与<code>Folower</code>唯一的不同在于不参与选举，也不参与集群写操作时的投票。</li></ul><h3>4、选票数据结构</h3><p>每个服务器在进行领导选举时，会发送如下关键信息：</p><ul><li><code>logicClock</code> 每个服务器会维护一个自增的整数，名为<code>logicClock</code>，它表示这是该服务器发起的第多少轮投票</li><li><code>state</code> 当前服务器的状态</li><li><code>self_id</code> 当前服务器的myid</li><li><code>self_zxid</code> 当前服务器上所保存的数据的最大zxid</li><li><code>vote_id</code> 被推举的服务器的myid</li><li><code>vote_zxid</code> 被推举的服务器上所保存的数据的最大zxid</li></ul><h2>五、leader的判定标准</h2><ul><li>数据新旧程度，只有拥有最新数据的节点才能有机会成为<code>Leader</code>，通过<code>zxid</code>的大小来表示数据的新，<code>zxid</code>越大代表数据越新</li><li><code>myid</code>:集群启动时，会在<code>data</code>目录下配置<code>myid</code>文件，里面的数字代表当前zk服务器节点的编号.当zk服务器节点数据一样新时， <code>myid</code>中数字越大的就会被选举成<code>Leader</code></li><li>当集群中已经有<code>Leader</code>时，新加入的节点不会影响原来的集群</li><li>投票数量，只有得到集群中多半的投票，才能成为<code>Leader</code>，多半即：n/2+1,其中n为集群中的节点数量</li></ul><h2>六、Leader选举流程</h2><h3>1、自增选举轮次</h3><p><code>ZooKeeper</code>规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的<code>logicClock</code>进行自增操作。</p><h3>2、发送初始化选票</h3><p>每个服务器最开始都是通过广播把票投给自己。</p><h3>4、更新选票</h3><p>根据选票<code>logicClock</code> -&gt; <code>vote_zxid</code> -&gt; <code>vote_id</code>依次判断</p><h5>4.1 判断选举轮次收到外部投票后，首先会根据投票信息中所包含的logicClock来进行不同处理：</h5><p><strong>外部投票的logicClock &gt; 自己的logicClock：</strong><br>说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的<code>logicClock</code>更新为收到的<code>logicClock</code>，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去;</p><p><strong>外部投票的logicClock &lt; 自己的logicClock：</strong><br>当前服务器直接忽略该投票，继续处理下一个投票;</p><p><strong>外部投票的logickClock = 自己的：</strong> 进行下一步的进行选票PK。</p><h5>4.2 选票PK是基于(self_id, self_zxid)与(vote_id, vote_zxid)的对比：</h5><p>若<code>logicClock</code>一致，则对比二者的<code>vote_zxid</code>。</p><p>若外部投票的<code>vote_zxid</code>比较大，则将自己的票中的<code>vote_zxid</code>与<code>vote_myid</code>更新为收到的票中的<code>vote_zxid</code>与<code>vote_myid</code>并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(<code>self_myid</code>, <code>self_zxid</code>)相同的选票，则直接覆盖</p><p>若二者<code>vote_zxid</code>一致，则比较二者的<code>vote_myid</code>。</p><p>若外部投票的<code>vote_myid</code>比较大，则将自己的票中的<code>vote_myid</code>更新为收到的票中的<code>vote_myid</code>并广播出去，另外将收到的票及自己更新后的票放入自己的票箱</p><h3>5、统计选票</h3><p>如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。</p><h3>6、更新服务器状态</h3><p>投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为<code>LEADING</code>，否则将自己的状态更新为<code>FOLLOWING</code>。</p><h2>七、图示Leader选举流程</h2><p><img src="http://bloghello.oursnail.cn/18-12-4/35769576.jpg" alt="image"></p><p>说明：</p><p>图中箭头上的(1,1,0) 三个数依次代表</p><ul><li>该选票的服务器的<code>LogicClock</code>（即投票轮数）;</li><li>被推荐的服务器的<code>myid</code> (即<code>vote_myid</code>);</li><li>被推荐的服务器的最大事务ID(即<code>vote_zxid</code>)；</li></ul><p>(1, 1)表示：</p><ul><li>投票服务器<code>myid</code>(即<code>self_myid</code>)</li><li>被推荐的服务器的<code>myid</code> (即<code>vote_myid</code>)</li></ul><p>所以(1,1,0)在这里的意思是：第一轮投票中，投给server 1，并且自己的最大事务ID都是0(这里可能会比较乱，ZXID可用这样理解：前32位是年号，比如万历年间；后32位是多少年，比如万历15年)，我们这里先不考虑年号的更迭，就假设这个投票发生在万历15年这一年，并且只考虑第一轮投票。即(1,vote_id,0)，所以暂时只考虑中间个数字。后面接受外部选票的时候，我们只要关注中间个数字即可，比如(1,2,0)说明是投给server 2的。</p><p>这里的示例只考虑第一轮，并且ZXID就是0.</p><h3>第一步：自增选票轮次&amp;初始化选票&amp;发送初始化选票</h3><p>首先，三台服务器自增选举轮次将<code>LogicClock=1</code>；然后初始化选票，清空票箱；最后发起初始化投票给自己将各自的票通过广播的形式投个自己并保存在自己的票箱里。</p><p>所以都是自己投给自己一票(1,1,0),(1,2,0),(1,3,0)</p><p>投完票之后的状态时(1,1),(2,2),(3,3)</p><h3>第二步：接受外部投票&amp;更新选票</h3><p>以<code>Server 1</code> 为例，分别经历 <code>Server 1 PK Server 2</code> 和 <code>Server 1 PK Server 3</code> 过程</p><h5>Server 1 PK Server 2</h5><p><code>Server 1</code> 接收到<code>Server 2</code>的选票(1,2,0) 表示投给<code>server 2</code>.</p><p>这时<code>Server 1</code>将自身的选票轮次和<code>Server 2</code> 的选票轮次比较，发现<code>LogicClock=1</code>相等，接着<code>Server 2</code>比较比较最大事务ID，发现也<code>zxid=0</code>也相等，最后比较各自的<code>myid</code>，发现<code>Server 2</code>的<code>myid=2</code> 大于自己的<code>myid=1</code>；</p><p>根据选票PK规则，<code>Server 1</code>将自己的选票由 (1, 1) 更正为 (1, 2)，表示选举<code>Server 2</code>为<code>Leader</code>，然后将自己的新选票 (1, 2)广播给 <code>Server 2</code> 和 <code>Server 3</code>，同时更新票箱子中自己的选票并保存<code>Server 2</code>的选票，至此<code>Server 1</code>票箱中的选票为(1, 2) 和 (2, 2)；</p><p><code>Server 2</code>收到<code>Server 1</code>的选票同样经过轮次比较和选票PK后确认自己的选票保持不变，并更新票箱中<code>Server 1</code>的选票由(1, 1)更新为(1, 2)，注意此次<code>Server 2</code>自己的选票并没有改变所有不用对外广播自己的选票。</p><p>此时便认为已经选出了<code>Leader</code>。但是这里可能会等一会看看有没有最优的情况，可能就会来到下面一步。</p><h5>Server 1 PK Server 3</h5><p><code>Server 1</code> 接收到<code>Server 3</code>的选票(1,3,0) 表示投给<code>server 3</code>.</p><p>根据<code>Server 1 PK Server 2</code>的流程类推，<code>Server 1</code>自己的选票由(1, 2)更新为(1, 3), 同样更新自己的票箱并广播给<code>Server 2</code> 和 <code>Server 3</code>；</p><p><code>Server 2</code>再次接收到<code>Server 1</code>的选票(1, 3)时经过比较后根据规则也要将自己的选票从(1, 2)更新为(1, 3), 并更新票箱里自己的选票和<code>Server 1</code>的选票，同时向<code>Server 1</code>和 <code>Server 3</code>广播；</p><p>同理 <code>Server 2</code> 和 <code>Server 3</code>也会经历上述投票过程，依次类推，<code>Server 1</code> 、<code>Server 2</code> 和<code>Server 3</code> 在俩俩之间在经历多次选举轮次比较和选票PK后最终确定各自的选票。</p><p>最后更新服务器状态：</p><p><img src="http://bloghello.oursnail.cn/18-12-4/82571929.jpg" alt="image"></p><p>选票确定后服务器根据自己票箱中的选票确定各自的角色和状态，票箱中超过半数的选票投给自己的则为<code>Leader</code>，更新自己的状态为<code>LEADING</code>，否则为<code>Follower</code>角色，状态为<code>FOLLOWING</code>，成为<code>Leader</code>的服务器要主动向<code>Follower</code>发送心跳包，<code>Follower</code>做出<code>ACK</code>回应，以维持他们之间的长连接。</p><ul><li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener">https://dbaplus.cn/news-141-1875-1.html</a></li><li><a href="https://www.jianshu.com/p/3fec1f8bfc5f" target="_blank" rel="noopener">https://www.jianshu.com/p/3fec1f8bfc5f</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在zookeeper中其实使用的ZAB协议来实现数据的一致性，并且主要依靠的是leader和follower这两种角色控制数据的一致性，而leader是里面最重要的一个角色，它是主要负责写操作的节点，然后与其他的follower进行数据同步，所以我们也要保证leader宕机的时候要快速选举出新的leader并且进行数据恢复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记4-Zookeeper介绍</title>
    <link href="http://yoursite.com/2019/02/23/zookeeper/Zookeeper%E7%AC%94%E8%AE%B04-Zookeeper%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/02/23/zookeeper/Zookeeper笔记4-Zookeeper介绍/</id>
    <published>2019-02-23T03:12:26.405Z</published>
    <updated>2019-02-23T03:15:16.676Z</updated>
    
    <content type="html"><![CDATA[<p>关于zookeeper最基本的介绍已经在笔记一中介绍了。不再赘述。ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。本文再来稍微深入一点介绍一下zookeeper的一些特性。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/18-12-3/61282486.jpg" alt="image"></p><ul><li>1、 <strong>配置维护</strong>：在分布式系统中，一般会把服务部署到n台机器上，服务配置文件都是相同的，如果配置文件的配置选项发生了改变，那我们就得一台一台的去改动。这时候zookeeper就起作用了，可以把zk当成一个高可用的配置存储器，把这样配置的事情交给zk去进行管理，将集群的配置文件拷贝到zookeeper的文件系统的某个节点上，然后用zk监控所有分布式系统里的配置文件状态，一旦发现有配置文件发生了变化，那么每台服务器同步zk的配置文件，zk同时保证同步操作的原子性，确保每个服务器的配置文件都能被更新。</li><li>2、 <strong>命名服务</strong>：在分布式应用中，通常需要一个完整的命名规则，既能够产生唯一的名称又便于人识别和记住。Zk就提供了这种服务，类似于域名和ip之间对应关系，域名容易记住，通过名称来获取资源和服务的地址，提供者等信息。</li><li>3、 <strong>分布式锁</strong>：分布式程序分布在不同主机上的进程对互斥资源进行访问的时候需要加锁。这样理解：很多分布式系统有多个服务窗口，但是某个时刻只让一个服务去干活，当这台服务器出问题的时候锁释放，里脊fail over到另外的服务。举例子，比如去某个地方办理证件的时候，只能有一个窗口对你服务，如果这个窗口的柜员有急事走了，那么系统或者经理给你指定另外一个窗口继续服务。</li><li>4、 <strong>集群管理</strong>：分布式集群中，经常会由于各种原因，比如硬件故障，网络问题，有些节点挂掉、有些节点加进来。这个时候机器需要感知到变化，然后根据变化做出对应的决策，那么zk就实现了类似这种集群的管理。</li></ul><h2>一、特性</h2><ul><li><strong>顺序一致性</strong>：<br>从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到ZooKeeper中。</li><li><strong>原子性</strong>：<br>所有事务请求的结果在集群中所有机器上的应用情况是一致的，也就是说要么整个集群所有集群都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</li><li><strong>单一视图</strong>：<br>无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性</strong>：<br>一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</li><li><strong>实时性</strong>：<br>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</li></ul><h2>二、集群角色</h2><p>最典型集群模式： Master/Slave 模式（主备模式）。在这种模式中，通常 Master服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p><p>但是，在 ZooKeeper 中没有选择传统的  Master/Slave 概念，而是引入以下三种角色：</p><ul><li>Leader</li><li>Follower</li><li>Observer</li></ul><p><img src="http://bloghello.oursnail.cn/18-12-3/61465262.jpg" alt="image"></p><p><code>zookeeper-server status</code>可以看当前节点的ZooKeeper是什么角色。</p><p>ZooKeeper默认只有Leader和Follower两种角色，没有Observer角色。</p><p>ZooKeeper集群的所有机器通过一个Leader选举过程来选定一台被称为『Leader』的机器，Leader服务器为客户端提供读和写服务。</p><p>Follower和Observer都能提供读服务，不能提供写服务。两者唯一的区别在于，Observer机器不参与Leader选举过程，也不参与写操作的『过半写成功』策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。</p><p><img src="http://bloghello.oursnail.cn/18-12-3/74661512.jpg" alt="image"></p><p>系统模型如图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-3/19717816.jpg" alt="image"></p><h2>三、关于<code>ZooKeeper</code>的一些重要概念</h2><ul><li><code>ZooKeeper</code>本身就是一个分布式程序（<strong>只要半数以上节点存活，<code>ZooKeeper</code>就能正常服务</strong>）</li><li>为了保证高可用，最好是以集群形态来部署<code>ZooKeeper</code>，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么<code>ZooKeeper</code>本身仍然是可用的。</li><li><code>ZooKeeper</code>将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持<code>znode</code>中存储的数据量较小的进一步原因）。</li><li><strong><code>ZooKeeper</code>是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。</strong>（“读”多于“写”是协调服务的典型场景。）</li><li><code>ZooKeeper</code>有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个<code>ZNode</code>被创建了，除非主动进行<code>ZNode</code>的移除操作，否则这个<code>ZNode</code>将一直保存在<code>Zookeeper</code>上。</li><li><code>ZooKeeper</code>底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提交数据节点监听服务。</li></ul><p>只要半数以上节点存活，<code>ZooKeeper</code>就能正常服务，<font color="red">这也解释了为什么集群个数一般是奇数</font>。</p><p>我们知道在<code>Zookeeper</code>中<code>Leader</code>选举算法采用了<code>Zab</code>协议。<code>Zab</code>核心思想是当多数<code>Server</code>写成功，则任务数据写成功。</p><p>①如果有3个<code>Server</code>，则最多允许1个<code>Server</code>挂掉。</p><p>②如果有4个<code>Server</code>，则同样最多允许1个<code>Server</code>挂掉。</p><p>既然3个或者4个<code>Server</code>，同样最多允许1个<code>Server</code>挂掉，那么它们的可靠性是一样的，所以选择奇数个<code>ZooKeeper Server</code>即可，这里选择3个<code>Server</code>。</p><h2>四、会话</h2><p><code>Session</code>是指客户端会话，在讲解客户端会话之前，我们先来了解下客户端连接。在<code>ZooKeeper</code>中，一个客户端连接是指客户端和<code>ZooKeeper</code>服务器之间的TCP长连接。<code>ZooKeeper</code>对外的服务端口默认是2181，客户端启动时，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测和服务器保持有效的会话，也能够向<code>ZooKeeper</code>服务器发送请求并接受响应，同时还能通过该连接接收来自服务器的<code>Watch</code>事件通知。</p><p><code>Session</code>的<code>SessionTimeout</code>值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>SessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个<code>sessionID</code>。由于<code>sessionID</code> 是<code>Zookeeper</code>会话的一个重要标识，许多与会话相关的运行机制都是基于这个<code>sessionID</code>的，因此，无论是哪台服务器为客户端分配的<code>sessionID</code>，都务必保证全局唯一。</p><h2>五、数据节点</h2><p><code>Zookeeper</code>将所有数据存储在内存中，数据模型是一棵树（<code>Znode Tree</code>)，由斜杠（/）的进行分割的路径，就是一个<code>Znode</code>，例如<code>/foo/path1</code>。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p><h2>六、Watcher</h2><p><code>Watcher</code>（事件监听器），是<code>Zookeeper</code>中的一个很重要的特性。<code>Zookeeper</code>允许用户在指定节点上注册一些<code>Watcher</code>，并且在一些特定事件触发的时候，<code>ZooKeeper</code>服务端会将事件通知到感兴趣的客户端上去，该机制是<code>Zookeeper</code>实现分布式协调服务的重要特性。</p><h2>七、版本</h2><p>在前面我们已经提到，<code>Zookeeper</code>的每个<code>ZNode</code>上都会存储数据，对应于每个<code>ZNode</code>，<code>Zookeeper</code>都会为其维护一个叫作<code>Stat</code>的数据结构，<code>Stat</code>中记录了这个<code>ZNode</code>的三个数据版本，分别是<code>version</code>（当前ZNode的版本）、<code>cversion</code>（当前ZNode子节点的版本）和 <code>cversion</code>（当前ZNode的ACL版本）。</p><p><code>Zookeeper</code>采用<code>ACL</code>（<code>AccessControlLists</code>）策略来进行权限控制，类似于<code>UNIX</code>文件系统的权限控制。</p><ul><li>CREATE: 创建子节点的权限。</li><li>READ: 获取节点数据和子节点列表的权限。</li><li>WRITE：更新节点数据的权限。</li><li>DELETE: 删除子节点的权限。</li><li>ADMIN: 设置节点ACL的权限。</li></ul><p>注意：<code>CREATE</code> 和 <code>DELETE</code> 都是针对子节点的权限控制。</p><p>下一节先说说ZAB协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于zookeeper最基本的介绍已经在笔记一中介绍了。不再赘述。ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。本文再来稍微深入一点介绍一下zookeeper的一些特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记3-paxos算法</title>
    <link href="http://yoursite.com/2019/02/22/zookeeper/Zookeeper%E7%AC%94%E8%AE%B03-paxos%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/22/zookeeper/Zookeeper笔记3-paxos算法/</id>
    <published>2019-02-22T08:34:47.187Z</published>
    <updated>2019-02-22T08:38:28.648Z</updated>
    
    <content type="html"><![CDATA[<p>有人说一千个人就有一千个paxos算法理解，算法本身晦涩难懂，如何快速生动理解paxos核心要点一直是一个老大难的问题，本文集结多篇文章精华，算是理顺了其中的门道。</p><a id="more"></a><h2>一、paxos解决了什么问题</h2><p>在上一章节中，我们着重提到了解决一致性问题的两种协议：2PC和3PC。但是在分布式环境中，这两种协议都无法真正实现一致性(分布式的一致性问题其实主要是指分布式系统中的数据一致性问题。所以，为了保证分布式系统的一致性，就要保证分布式系统中的数据是一致的。)</p><p>分布式系统中的节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。基于消息传递通信模型的分布式系统，不可避免的会发生以下错误：</p><ul><li>进程可能会慢、被杀死或者重启</li><li>消息可能会延迟、丢失、重复</li></ul><p>（在基础 Paxos 场景中，先不考虑可能出现消息篡改即拜占庭错误的情况）</p><p><strong>⭐Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。</strong></p><p>那么我们可用形象地理解为：Paxos可以说是一个民主选举的算法——大多数节点的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的节点同意。取值一旦确定将不再更改，并且可以被获取到(不可变性，可读取性)。</p><h2>二、典型场景</h2><p>一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。</p><p>所以，<strong>paxos算法主要解决的问题就是如何保证分布式系统中各个节点都能执行一个相同的操作序列</strong>。</p><p><img src="http://bloghello.oursnail.cn/18-12-2/77123681.jpg" alt="image"></p><p>上图中，C1是一个客户端，N1、N2、N3是分布式部署的三个服务器，初始状态下N1、N2、N3三个服务器中某个数据的状态都是S0。当客户端要向服务器请求处理操作序列：op1–op2–op3时（op表示operation）</p><p>如果想保证在处理完客户端的请求之后，N1、N2、N3三个服务器中的数据状态都能从S0变成S1并且一致的话（或者没有执行成功，还是S0状态），就要保证N1、N2、N3在接收并处理操作序列op1–op2–op3时，严格按照规定的顺序正确执行opi，要么全部执行成功，要不就全部都不执行。</p><p>所以，针对上面的场景，paxos解决的问题就是如何依次确定不可变操作opi的取值，也就是确定第i个操作什么，在确定了opi的内容之后，就可以让各个副本执行opi操作。</p><h2>三、paxos算法</h2><h3>1、算法涉及的主要角色：</h3><ul><li>Proposer：提议者，提出议案(同时存在一个或者多个，他们各自发出提案)</li><li>Acceptor：接受者，收到议案后选择是否接受</li><li>Learner：最终决策学习者，只学习正确的决议</li><li>Client：产生议题者，发起新的请求</li></ul><p><img src="http://bloghello.oursnail.cn/18-12-3/34413307.jpg" alt="image"></p><p>主要的角色就是“提议者”和“接受者”。先有提议，再来表决。（注：实际应用中，可以将一堆服务器任意指定角色，一部分做“提议者”、一部分做“接受者”，也可以指定特定的服务器做“提议者”，剩下的都是“接受者”。）</p><p><code>Proposer</code>就像<code>Client</code>的代理人，由<code>Proposer</code>拿着<code>Client</code>的议题去向<code>Acceptor</code>提议，让<code>Acceptor</code>来做出决策。</p><p>这幅图表示的是角色之间的逻辑关系，每一种角色就代表了一种节点类型。在物理部署环节，可以把每一种角色都部署在一台物理机器上，也可以组合任何两种或者多种角色部署在一台物理机器上，甚至于，把这四种角色都部署在同一台物理机器上也是可以的。</p><h3>2、关于这两阶段的理解</h3><p>从一个故事说起。</p><p>从前，在国王Leslie Lamport的统治下，有个黑暗的希腊城邦叫paxos。城邦里有3类人，</p><ul><li>决策者</li><li>提议者</li><li>群众</li></ul><p>虽然这是一个黑暗的城邦但是很民主，按照议会民主制的政治模式制订法律，群众有什么建议和意见都可以写提案交给提议者，提议者会把提案交给决策者来决策，决策者有奇数个，为什么要奇数个？很简单因为决策的方式很无脑，少数服从多数。最后决策者把刚出炉的决策昭告天下，群众得知决策结果。</p><p>等一下，那哪里黑暗呢？问题就出在“提议者会把提案交给决策者来决策”，那么多提案决策者先决策谁的？谁给的钱多就决策谁的。</p><p>那这样会有几个问题，决策者那么多，怎么保证最后决策的是同一个提案，以及怎么保证拿到所有提议者中最高的报价。</p><p>聪明又贪婪的决策者想到了一个办法：分两阶段报价</p><p><strong>第一阶段</strong>：</p><ul><li>决策者接受所有比他当前持有报价高的报价，且不会通知之前报价的人</li><li>提议者给所有(一半以上即可)决策者报价，若有人比自己报价高就加价，有半数以上决策者接受自己报价就停止报价。</li></ul><p>一旦某个提议者收到了所有决策者中一半以上的人同意的回复。就会进入第二阶段。</p><p><strong>第二阶段</strong>：</p><p>提议者去找收过自己钱的大佬签合同，这里有3种情况：</p><ul><li>很多大佬收了别人更高的价，达不到一半人数了，只好回去拿钱继续贿赂，回到第一阶段重新升级;</li><li>大佬收到的最高报价是自己的，美滋滋，半数以上成功签合同，提案成功;</li><li>提议者回去拿钱回来继续贿赂的时候发现合同已经被签了且半数以上都签了这个提案，不干了，赶快把自己的提案换成已经签了的提案，再去提给所有大佬，看看能不能分一杯羹遇见还没签的大佬。</li></ul><p>最后一步就是让所有节点知道这个过半通过的提议是什么，从而达到最终的一致。</p><h2>三、深化理解</h2><p>假设有两个“提议者”和三个“接受者”。下面这一坨的内容一开始如果看不明白不要紧，立即转到下面的图示过程，看懂图示再回过头来就会理解了。</p><ul><li>怎么明确意见领袖呢？通过编号。每个“提议者”在第一阶段先报个号，谁的号大，谁就是意见领袖。如果不好理解，可以想象为贿选。每个提议者先拿着钞票贿赂一圈“接受者”，谁给的钱多，第二阶段“接受者”就听谁的。<strong>意见领袖理解为贿赂中胜出的“提议者”即可</strong>。</li><li>有个跟选举常识不一样的地方，<strong>就是每个“提议者”不会执着于让自己的提议通过，而是每个“提议者”会执着于让提议尽快达成一致意见</strong>。所以，为了这个目标，如果“提议者”在贿选的时候，发现“接受者”已经接受过前面意见领袖的提议了，即便“提议者”贿选成功，也会默默的把自己的提议改为前面意见领袖的提议。所以一旦贿赂成功，胜出的“提议者”再提出提议，提议内容也是前面意见领袖的提议（这样，在谋求尽早形成多数派的路上，又前进了一步）。</li><li>钱的多少很重要，如果钱少了，无论在第一还是第二阶段“接受者”都不会鸟你，直接拒绝。</li><li>上面讲到，如果“提议者”在贿选时，发现前面已经有意见领袖的提议，那就将自己的提议默默改成前面意见领袖的提议。这里有一种情况，如果你是“提议者”，在贿赂的时候，“接受者1”跟你说“他见过的意见领袖的提议是方案1”，而“接受者2”跟你说“他见过的意见领袖提议是方案2”，你该怎么办？这时的原则也很简单，还是：钱的多少很重要！你判断一下是“接受者1”见过的意见领袖有钱，还是“接受者2”见过的意见领袖有钱？如何判断呢？因为“接受者”在被“提议者”贿赂的时候，自己会记下贿赂的金额。所以当你贿赂“接受者”时，一旦你给的贿赂多而胜出，“接受者”会告诉你两件事情：a.前任意见领袖的提议内容（如果有的话），b.前任意见领袖当时贿赂了多少钱。这样，再面对刚才的情景时，你只需要判断一下“接受者1”和“接受者2”告诉你的信息中，哪个意见领袖当时给的钱多，那你就默默的把自己的提议，改成那个意见领袖的提议。</li><li>在整个选举过程中，每个人谁先来谁后到，“接受者”什么时间能够接到“提议者”的信息，是完全不可控的。所以很可能一个意见领袖已经产生了，但是由于这个意见领袖的第二阶段刚刚开始，绝大部分“接受者”还没有收到这个意见领袖的提议。结果，这时突然冲进来了一个新的土豪“提议者”，那么这个土豪“提议者”也是有机会让自己的提议胜出的！这时就形成了一种博弈：a.上一个意见领袖要赶在土豪“提议者”贿赂到“接受者”前，赶到“接受者”面前让他接受自己的提议，否则会因为自己的之前贿赂的钱比土豪少而被拒绝。b.土豪“提议者”要赶在上一个意见领袖将提议传达给“接受者”前，贿赂到“接受者”，否则土豪“提议者”即便贿赂成功，也要默默的将自己的提议改为前任意见领袖的提议。这整个博弈的过程，最终就看这两个“提议者”谁的进展快了。但最终一定会有一个意见领袖，先得到多数“接受者”的认可，那他的提议就胜出了。这一块不理解就看下面的分解说明。</li></ul><p>1）首先“提议者1”贿赂了3个“接受者”</p><p><img src="http://bloghello.oursnail.cn/zk3-1.png" alt="image"></p><p>2）3个“接受者”记录下贿赂金额，因为目前只有一个“提议者”出价，因此$1就是最高的了，所以“接受者”们返回贿赂成功。此外，因为没有任何先前的意见领袖提出的提议，因此“接受者”们告诉“提议者1”没有之前接受过的提议（自然也就没有上一个意见领袖的贿赂金额了）。</p><p>假如此时由于贿赂的人数超过了一半，那么第一阶段成功，准备进入第二阶段，就是正式签合同，签超过半数的合同才真正表示本轮成功。</p><p><img src="http://bloghello.oursnail.cn/zk3-2.png" alt="image"></p><p>3）“提议者1”发现有超过一半人接受了自己的贿赂，下面就要真正发起提议了，先向“接受者1”提出了自己的提议：1号提议，并告知自己之前已贿赂$1。</p><p><img src="http://bloghello.oursnail.cn/zk3-3.png" alt="image"></p><p>4）“接受者1”检查了一下，目前记录的贿赂金额就是$1，于是接受了这一提议，并把1号提议记录在案。</p><p><img src="http://bloghello.oursnail.cn/zk3-4.png" alt="image"></p><p>5）在“提议者1”向“接受者2”“接受者3”发起提议前，土豪“提议者2”出现，他开始用$2贿赂“接受者1”与“接受者2”。</p><p><img src="http://bloghello.oursnail.cn/zk3-5.png" alt="image"></p><p>6）“接受者1”与“接受者2”立刻被收买，将贿赂金额改为$2。但是，不同的是：“接受者1”告诉“提议者2”,之前我已经接受过1号提议了，同时1号提议的“提议者”贿赂过$1；而，“接受者2”告诉“提议者2”，之前没有接受过其他意见领袖的提议，也没有上一个意见领袖的贿赂金额。</p><p><img src="http://bloghello.oursnail.cn/zk3-6.png" alt="image"></p><p>7）这时，“提议者1”回过神来了，他向“接受者2”和“接受者3”发起1号提议，并带着信息“我前期已经贿赂过$1”。</p><p><img src="http://bloghello.oursnail.cn/zk3-7.png" alt="image"></p><p>8）“接受者2”“接受者3”开始答复：“接受者2”检查了一下自己记录的贿赂金额，然后表示，已经有人出价到$2了，而你之前只出到$1，不接受你的提议，再见。但“接受者3”检查了一下自己记录的贿赂金额，目前记录的贿赂金额就是$1，于是接受了这一提议，并把1号提议记录在案。</p><p><img src="http://bloghello.oursnail.cn/zk3-8.png" alt="image"></p><p>9）到这里，“提议者1”已经得到两个接受者的赞同，已经得到了多数“接受者”的赞同。于是“提议者1”确定1号提议最终通过。</p><p>10）此时“提议者2”发现1号提议已经被通过了，为了最快达成一致，那么他就默默地将自己的提议也改为与1号提议一致，然后开始向“接受者1”“接受者2”发起提议（提议内容仍然是1号提议），并带着信息：之前自己已贿赂过$2。</p><p><img src="http://bloghello.oursnail.cn/zk3-9.png" alt="image"></p><p>11）这时“接受者1”“接受者2”收到“提议者2”的提议后，照例先比对一下贿赂金额，比对发现“提议者2”之前已贿赂$2，并且自己记录的贿赂金额也是$2，所以接受他的提议，也就是都接受1号提议。</p><p><img src="http://bloghello.oursnail.cn/zk3-10.png" alt="image"></p><p>12）于是，“提议者2”也拿到了多数派的意见，最终通过的也是1号提议。</p><p>回到上面的第5）步，如果“提议者2”第一次先去贿赂“接受者2”“接受者3”会发生什么？那很可能1号提议就不会成为最终选出的提议。因为当“提议者2”先贿赂到了“接受者2”“接受者3”，那等“提议者1”带着议题再去找这两位的时候，就会因为之前贿赂的钱少（$1&lt;$2）而被拒绝。所以，这也就是刚才讲到可能存在博弈的地方：a.“提议者1”要赶在“提议者2”贿赂到“接受者2”“接受者3”之前，让“接受者2”“接受者3”接受自己的意见，否则“提议者1”会因为钱少而被拒绝；b.“提议者2”要赶在“提议者1”之前贿赂到“接受者”，否则“提议者2”即便贿赂成功，也要默默的将自己的提议改为“提议者1”的提议。但你往后推演会发现，无论如何，总会有一个“提议者”的提议获得多数票而胜出。</p><h2>五、总结</h2><p>好啦，故事到这里基本讲述完了，咱们来总结一下，其实Paxos算法就下面这么几个原则：</p><ul><li>Paxos算法包括两个阶段：第一个阶段主要是贿选，还没有提出提议；第二个阶段主要根据第一阶段的结果，明确接受谁的提议，并明确提议的内容是什么（这个提议可能是贿选胜出“提议者”自己的提议，也可能是前任意见领袖的提议，具体是哪个提议，见下面第3点原则）。</li><li>编号（贿赂金额）很重要，无论在哪个阶段，编号（贿赂金额）小的，都会被鄙视（被拒绝）。</li><li>在第一阶段中，一旦“接受者”已经接受了之前意见领袖的提议，那后面再来找这个“接受者”的“提议者”，即便在贿赂中胜出，也要被洗脑，默默将自己的提议改为前任意见领袖的提议，然后他会在第二阶段提出该提议（也就是之前意见领袖的提议，以力争让大家的意见趋同）。如果“接受者”之前没有接受过任何提议，那贿选胜出的“提议者”就可以提出自己的提议了。</li></ul><p>还有一个问题需要考量，假如<code>proposer A</code>发起ID为n的提议，在提议未完成前<code>proposer B</code>又发起ID为n+1的提议，在n+1提议未完成前<code>proposer C</code>又发起ID为n+2的提议…… 如此<code>acceptor</code>不能完成决议、形成活锁(<code>livelock</code>)，虽然这不影响一致性，但我们一般不想让这样的情况发生。解决的方法是从<code>proposer</code>中选出一个<code>leader</code>，提议统一由<code>leader</code>发起。</p><ul><li><a href="https://www.zhihu.com/question/19787937" target="_blank" rel="noopener">如何浅显易懂地解说 Paxos 的算法？</a></li><li><a href="https://zhuanlan.zhihu.com/p/44997221" target="_blank" rel="noopener">共识算法之：Paxos</a></li><li><a href="http://blog.51cto.com/9587671/2286358" target="_blank" rel="noopener">讲一个关于paxos的故事</a></li><li><a href="https://zhuanlan.zhihu.com/p/21895686" target="_blank" rel="noopener">浅显易懂地解读Paxos算法</a></li><li><a href="http://www.cnblogs.com/bangerlee/p/5655754.html" target="_blank" rel="noopener">分布式系统理论进阶 - Paxos</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有人说一千个人就有一千个paxos算法理解，算法本身晦涩难懂，如何快速生动理解paxos核心要点一直是一个老大难的问题，本文集结多篇文章精华，算是理顺了其中的门道。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记2-2PC&amp;3PC</title>
    <link href="http://yoursite.com/2019/02/22/zookeeper/Zookeeper%E7%AC%94%E8%AE%B02-2PC&amp;3PC/"/>
    <id>http://yoursite.com/2019/02/22/zookeeper/Zookeeper笔记2-2PC&amp;3PC/</id>
    <published>2019-02-22T03:21:19.880Z</published>
    <updated>2019-02-22T03:25:43.424Z</updated>
    
    <content type="html"><![CDATA[<p>很多人对解决分布式系统中一致性问题的难度还没有一个直观的感受，本节详细讲解分布式系统中一致性面临的种种挑战，并且详细说明2PC和3PC这些比较简单的解决方案的原理和存在的问题，为后面引出zk的解决方案做铺垫。</p><a id="more"></a><h2>一、前言</h2><p>分布式系统中，一致性问题是一个比较重要的问题，zookeeper解决的就是分布式系统的一致性问题。下面我们从一致性问题、特定条件下解决一致性问题的两种方法(2PC、3PC)入门，了解最基础的分布式系统理论。</p><h2>二、一致性</h2><p>何为一致性问题？简单而言，一致性问题就是相互独立的节点之间如何达成一项决议的问题。分布式系统中，进行数据库事务提交(commit transaction)、Leader选举、序列号生成等都会遇到一致性问题。这个问题在我们的日常生活中也很常见，比如牌友怎么商定几点在哪打几圈麻将.</p><p>假设一个具有N个节点的分布式系统，当其满足以下条件时，我们说这个系统满足一致性：</p><ul><li><strong>全认同(agreement):</strong> 所有N个节点都认同一个结果</li><li><strong>值合法(validity)</strong>: 该结果必须由N个节点中的节点提出</li><li><strong>可结束(termination)</strong>: 决议过程在一定时间内结束，不会无休止地进行下去</li></ul><p>有人可能会说，决定什么时候在哪搓搓麻将，4个人商量一下就ok，这不很简单吗？</p><p>但就这样看似简单的事情，分布式系统实现起来并不轻松，因为它面临着上一节所说的这些问题：</p><ul><li><strong>消息传递异步无序(asynchronous)</strong>: 现实网络不是一个可靠的信道，存在消息延时、丢失，节点间消息传递做不到同步有序(synchronous)</li><li><strong>节点宕机(fail-stop)</strong>: 节点持续宕机，不会恢复</li><li><strong>节点宕机恢复(fail-recover)</strong>: 节点宕机一段时间后恢复，在分布式系统中最常见</li><li><strong>网络分化(network partition)</strong>: 网络链路出现问题，将N个节点隔离成多个部分</li><li><strong>拜占庭将军问题(byzantine failure)</strong>: 节点或宕机或逻辑失败，甚至不按套路出牌抛出干扰决议的信息</li></ul><p>假设现实场景中也存在这样的问题，我们看看结果会怎样：</p><blockquote><p>第一种情况：</p><p>我: 老王，今晚7点老地方，搓够48圈不见不散！</p><p>……</p><p>(第二天凌晨3点) 隔壁老王: 没问题！       // 消息延迟</p><p>我: ……</p><hr><p>第二种情况：</p><p>我: 小张，今晚7点老地方，搓够48圈不见不散！</p><p>小张: No ……</p><p>(两小时后……)</p><p>小张: No problem！                     // 宕机节点恢复</p><p>我: ……</p><hr><p>第三种情况：</p><p>我: 老李头，今晚7点老地方，搓够48圈不见不散！</p><p>老李: 必须的，大保健走起！               // 拜占庭将军</p><p>(这是要打麻将呢？还是要大保健？还是一边打麻将一边大保健……)</p></blockquote><p>还能不能一起愉快地玩耍…</p><p>正如上节所说，在分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）中最多只能满足两个。那么，第三个是一定要满足的了。那么强一致性和高可用必定不能同时满足。</p><p>对于一致性，2PC、3PC是相对简单的解决强一致性问题的协议，下面我们就来了解2PC和3PC。</p><h2>三、协调者</h2><p>在分布式系统中，每一个机器节点虽然都能明确的知道自己执行的事务是成功还是失败，但是却无法知道其他分布式节点的事务执行情况。因此，当一个事务要跨越多个分布式节点的时候（比如，淘宝下单流程，下单系统和库存系统可能就是分别部署在不同的分布式节点中），为了保证该事务可以满足ACID，就要引入一个协调者（Cooradinator）。其他的节点被称为参与者（Participant）。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。</p><h2>四、2PC(二阶提交)</h2><p>顾名思义它分成两个阶段，先由一方进行提议(<code>propose</code>)并收集其他节点的反馈(<code>vote</code>)，再根据反馈决定提交(<code>commit</code>)或中止(<code>abort</code>)事务。我们将提议的节点称为协调者(<code>coordinator</code>)，其他参与决议节点称为参与者(<code>participants</code>, 或<code>cohorts</code>)。</p><p>在阶段1中，协调者发起一个提议，分别问询各参与者是否接受。只要有一个参与者没有准备好就中止。</p><p><strong>值得注意的是，二阶段提交协议的第一阶段准备阶段不仅仅是回答YES or NO，还是要执行事务操作的，只是执行完事务操作，并没有进行commit还是roolback</strong>。也就是说，一旦事务执行之后，在没有执行commit或者roolback之前，<strong>资源是被锁定的。这会造成阻塞</strong>。</p><blockquote><p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p><p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息(用于失败时的回滚)和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p><p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p></blockquote><p>在阶段2中，协调者根据参与者的反馈，提交或中止事务，如果参与者全部同意则提交，只要有一个参与者不同意就中止。释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><p><img src="http://bloghello.oursnail.cn/18-12-2/40570941.jpg" alt="image"></p><p>问题：</p><blockquote><p>1、<strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p><p>2、<strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p><p>3、<strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p><p>二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p></blockquote><p>为了解决这些问题，衍生出了对2PC的改进3PC。我们接下来看看3PC是如何解决这些问题的。</p><h2>五、3PC(三阶段提交)</h2><p><strong>3PC最关键要解决的是单点和阻塞。</strong></p><p>所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。在第一阶段，只是询问所有参与者是否可可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行<code>commit</code>或者<code>rollback</code>。</p><p><img src="http://bloghello.oursnail.cn/18-12-2/7007072.jpg" alt="image"></p><h4>5.1 CanCommit阶段</h4><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><p>但是此时不执行事务的操作，也就时说不会锁住资源。</p><h4>5.2 PreCommit阶段</h4><p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。此时会执行事务操作和将undo和redo信息记录到事务日志中。如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><h4>5.3 doCommit阶段</h4><p>加入协调接收到所有参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p><p>协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><p><strong>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</strong></p><p>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。</p><p>但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><h2>六、总结</h2><p>了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， <code>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.</code> 意即世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人对解决分布式系统中一致性问题的难度还没有一个直观的感受，本节详细讲解分布式系统中一致性面临的种种挑战，并且详细说明2PC和3PC这些比较简单的解决方案的原理和存在的问题，为后面引出zk的解决方案做铺垫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper笔记1-CAP和BASE理论</title>
    <link href="http://yoursite.com/2019/02/22/zookeeper/Zookeeper%E7%AC%94%E8%AE%B01-CAP%E5%92%8CBASE%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/02/22/zookeeper/Zookeeper笔记1-CAP和BASE理论/</id>
    <published>2019-02-22T02:48:24.749Z</published>
    <updated>2019-02-22T02:49:36.371Z</updated>
    
    <content type="html"><![CDATA[<p>随着应用规模的迅速扩张，单台机器的部署已经难以支撑用户大规模、高并发的请求了， 因此服务化、集群化、分布式概念应运而生。 然而， 集群的维护和多节点应用程序的协作运行远比单机模式复杂，需要顾及到的细节问题实在太多，比如说同一分配置在多台机器上的同步， 客户端程序实时感知服务机状态，应用与应用之间的公共资源的互斥访问等等一系列的问题。zookeeper能够给我们非常完美的解决这些问题，zookeeper天生的就是为解决分布式协调服务这个问题而来。</p><a id="more"></a><h2>一、前言</h2><p>学习<code>zookeeper</code>才算是真正跨进分布式这个大门。比较经典的应用是可以作为<code>dubbo</code>推荐的注册中心。</p><p>首先，我们必须要明确几个我们之前可能不会遇到的但是在分布式系统中又很常见的问题：</p><ul><li>网络相当可靠</li><li>延迟为0</li><li>传输带宽是无限的</li><li>网络相当安全</li><li>拓扑结构不会改变</li><li>必须要有一个管理员</li><li>传输成本为0</li><li>网络同质化</li></ul><p>总结起来，分布式系统中最常出现的问题是：通信异常，表现为网络通信成功，失败和超时；节点故障，包括宕机和OOM。</p><h2>二、Zookeeper是什么</h2><p>官方解释：</p><blockquote><p>它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p></blockquote><p>上面的解释有点抽象，简单来说<strong>zookeeper=文件系统+监听通知机制</strong>。我们这里拿比较简单的分布式应用配置管理为例来说明。</p><p>假设我们的程序是分布式部署在多台机器上，如果我们要改变程序的配置文件，需要逐台机器去修改，非常麻烦，现在把这些配置全部放到<code>zookeeper</code>上去，保存在 <code>zookeeper</code> 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 <code>zookeeper</code> 的通知，然后从 <code>zookeeper</code> 获取新的配置信息应用到系统中。</p><p><img src="http://bloghello.oursnail.cn/18-12-2/72299928.jpg" alt="image"></p><h2>三、Zookeeper设计目的</h2><ul><li>1、最终一致性：<code>client</code>不论连接到哪个<code>Server</code>，展示给它都是同一个视图，这是<code>zookeeper</code>最重要的性能。</li><li>2、可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。</li><li>3、实时性：<code>Zookeeper</code>保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，<code>Zookeeper</code>不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用<code>sync()</code>接口。</li><li>4、等待无关（wait-free）：慢的或者失效的<code>client</code>不得干预快速的<code>client</code>的请求，使得每个<code>client</code>都能有效的等待。</li><li>5、原子性：更新只能成功或者失败，没有中间状态。</li><li>6、顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。</li></ul><h2>四、CAP理论</h2><p>指的是在一个分布式系统中，不可能同时满足<code>Consistency</code>（一致性）、 <code>Availability</code>（可用性）、<code>Partition tolerance</code>（分区容错性）这三个基本需求，最多只能满足其中的两项。</p><ul><li>1、一致性：<br>指数据在多个副本之间是否能够保持一致的特性。当执行数据更新操作后，仍然保证系统数据处于一致的状态。</li><li>2、可用性（高可用）：<br>系统提供的服务必须一直处于可用的状态。对于用户的每一个操作请求总是能够在“有限的时间内”返回结果。这个有限时间是系统设计之初就指定好的系统运行指标。返回的结果指的是系统返回用户的一个正常响应结果，而不是“out ot memory error”之类的系统错误信息。</li><li>3、分区容错性（数据分片）：<br>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。组成分布式系统的每个节点的加入与退出都可以看成是一个特殊的网络分区。</li></ul><p>一个分布式系统无法同时满足这三个条件，只能满足两个，意味着我们要抛弃其中的一项，如下图所示：</p><p><img src="http://bloghello.oursnail.cn/18-12-2/16526528.jpg" alt="image"></p><ul><li>1、CA，放弃P：将所有数据都放在一个分布式节点上。这同时放弃了系统的可扩展性。</li><li>2、CP，放弃A：一旦系统遇到故障时，受影响的服务器需要等待一段时间，在恢复期间无法对外提供正常的服务。</li><li>3、AP，放弃C：这里的放弃一致性是指放弃数据强一致性，而保留数据的最终一致性。系统无法实时保持数据的一致，但承诺在一个限定的时间窗口内，数据最终能够达到一致的状态。</li></ul><p>对于分布式系统而言，分区容错性是一个最基本的要求，因为分布式系统中的组件必然需要部署到不通的节点，必然会出现子网络，在分布式系统中，网络问题是必定会出现的异常。因此分布式系统只能在C（一致性）和A（可用性）之间进行权衡。</p><h2>五、BASE理论</h2><p><code>Basically Available</code>（基本可用）、<code>Soft-state</code>（ 软状态/柔性事务）、<code>Eventual Consistency</code>（最终一致性）。是基于CAP定理演化而来，是对CAP中一致性和可用性权衡的结果。</p><p>核心思想：即使无法做到强一致性，但每个业务根据自身的特点，采用适当的方式来使系统达到最终一致性。</p><ul><li>1、基本可用：<br>指分布式系统在出现故障的时候，允许损失部分可用性，保证核心可用。但不等价于不可用。比如：搜索引擎0.5秒返回查询结果，但由于故障，2秒响应查询结果；网页访问过大时，部分用户提供降级服务，等。</li><li>2、软状态：<br>软状态是指允许系统存在中间状态，并且该中间状态不会影响系统整体可用性。即允许系统在不同节点间副本同步的时候存在延时。</li><li>3、最终一致性：<br>系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，不需要实时保证系统数据的强一致性。最终一致性是弱一致性的一种特殊情况。</li></ul><p>BASE理论面向的是大型高可用可扩展的分布式系统，通过牺牲强一致性来获得可用性。ACID是传统数据库常用的概念设计，追求强一致性模型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着应用规模的迅速扩张，单台机器的部署已经难以支撑用户大规模、高并发的请求了， 因此服务化、集群化、分布式概念应运而生。 然而， 集群的维护和多节点应用程序的协作运行远比单机模式复杂，需要顾及到的细节问题实在太多，比如说同一分配置在多台机器上的同步， 客户端程序实时感知服务机状态，应用与应用之间的公共资源的互斥访问等等一系列的问题。zookeeper能够给我们非常完美的解决这些问题，zookeeper天生的就是为解决分布式协调服务这个问题而来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookpeeper" scheme="http://yoursite.com/tags/zookpeeper/"/>
    
  </entry>
  
</feed>
