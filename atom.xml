<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-24T11:18:24.742Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>06-dubbo基本配置之本地存根</title>
    <link href="http://yoursite.com/2019/03/24/dubbo/06-dubbo%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9/"/>
    <id>http://yoursite.com/2019/03/24/dubbo/06-dubbo基本配置之本地存根/</id>
    <published>2019-03-24T11:17:53.906Z</published>
    <updated>2019-03-24T11:18:24.742Z</updated>
    
    <content type="html"><![CDATA[<h2>本地存根</h2><p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 <code>ThreadLocal</code> 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 <code>Stub</code>，客户端生成 <code>Proxy</code> 实例，会把 <code>Proxy</code> 通过构造函数传给 <code>Stub</code> ，然后把 <code>Stub</code> 暴露给用户，<code>Stub</code> 可以决定要不要去调 <code>Proxy</code>。</p><p><img src="http://bloghello.oursnail.cn/dubbo6-1.jpg" alt="image"></p><p>简单而言就是，所有的逻辑都在<code>provider</code>这一端实现了，<code>consumer</code>只能调用，那么能不能在调用前先判断一下呢？比如我希望传入的名字是<code>fossi</code>说明接头成功，否则你就是特务我不跟你bb，直接返回一句脏话。</p><p>由于<code>srpingboot</code>的注解方式一直没搞成功，所以我将<code>comsumer</code>端搞成了xml方式实现，具体代码见<a href="https://github.com/sunweiguo/dubbo-example/tree/%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A0%B9demo" target="_blank" rel="noopener">本地存根demo分支</a></p><p>主要就是在<code>consumer</code>里面写一个<code>StubService</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StubService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DemoService demoService;</span><br><span class="line">    <span class="comment">//dubbo的代理对象自动传进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StubService</span><span class="params">(DemoService demoService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.demoService = demoService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"本地存根开始执行..."</span>);</span><br><span class="line">        <span class="keyword">if</span>(name.equalsIgnoreCase(<span class="string">"fossi"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"你就是fossi啊，对对对"</span>);</span><br><span class="line">            <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"你他娘不是fossi!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"你搞错了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.njupt.swg.DemoService"</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">stub</span>=<span class="string">"com.njupt.swg.service.StubService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最后分别启动，在浏览器输入：<code>http://localhost:8080/test/fossi</code>显示<code>Hello, fossi</code>;但是当我输入<code>http://localhost:8080/test/hh</code>显示<code>你搞错了</code>；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;本地存根&lt;/h2&gt;
&lt;p&gt;远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做 &lt;code&gt;ThreadLocal&lt;/code&gt; 缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在 API 中带上 &lt;code&gt;
      
    
    </summary>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>05-dubbo基本配置之超时、重试、多版本</title>
    <link href="http://yoursite.com/2019/03/24/dubbo/05-dubbo%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%B6%85%E6%97%B6%E3%80%81%E9%87%8D%E8%AF%95%E3%80%81%E5%A4%9A%E7%89%88%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/03/24/dubbo/05-dubbo基本配置之超时、重试、多版本/</id>
    <published>2019-03-24T11:14:56.259Z</published>
    <updated>2019-03-24T11:15:22.342Z</updated>
    
    <content type="html"><![CDATA[<p>dubbo的基本配置还有一些，本文逐一来攻克</p><a id="more"></a><h2>一、超时机制</h2><p>如果没有超时机制，那么服务提供者一旦出现问题，十几秒才给响应，服务消费者线程大量阻塞等待，就会造成很大的问题，因此，超时时间的配置一定是dubbo考虑的问题。</p><p><img src="http://bloghello.oursnail.cn/dubbo5-1.jpg" alt="image"></p><p>其中，服务提供方配置，这个时间是指通过 URL 经由注册中心传递给消费方。</p><p>如何配置，这张图说明了，优先级是从上往下依次下降。也就是说，有两大原则：</p><ul><li>方法级优先，接口级次之，全局配置再次之。</li><li>如果级别一样，则消费方优先，提供方次之。</li></ul><p>其它 <code>retries</code>, <code>loadbalance</code>, <code>actives</code> 等类似。并且<code>dubbo</code>默认有一个超时时间就是<code>1000ms</code>。</p><p>（建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置）。</p><p>⭐<code>springboot</code>中配置差不多，形如：<code>@Service(timeout = 3000)</code>.但是对于这种方式我们似乎不能再精确到方法级别上了。</p><h2>二、重试机制</h2><p>写法与上面的<code>timeout</code>类似，就是<code>retries=&quot;3&quot;</code>表示默认的连接依次之外，如果出现意外还可以再次连接三次，那么总次数就是4次。</p><p>当服务的提供方有多台呢？那么就会去一台一台地试而不是在一棵树上吊死。</p><p>额外需要注意的一点使重试机制不能放在非幂等的接口上。</p><p>⭐<code>springboot</code>中配置差不多，形如<code>@Service(retries = 3)</code></p><h2>三、多版本</h2><p>当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。</p><p>可以按照以下的步骤进行版本迁移：</p><p>在低压力时间段，先升级一半提供者为新版本<br>再将所有消费者升级为新版本<br>然后将剩下的一半提供者升级为新版本<br>老版本服务提供者配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>新版本服务提供者配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>老版本服务消费者配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>新版本服务消费者配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果不需要区分版本，随机选择一个都行，可以按照以下的方式配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"barService"</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">version</span>=<span class="string">"*"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>⭐<code>springboot</code>中配置差不多，形<code>@Service(version = &quot;1.0&quot;)</code></p><h2>四、三种方式整合springboot</h2><p>我们之前整合<code>springboot</code>的方式是：引入<code>dubbo-starter</code>，在<code>application.properties</code>文件中配置属性，用<code>@Service</code>暴露服务，用<code>@Reference</code>来使用服务。最后用<code>@EnableDubbo</code>来启动<code>dubbo</code>功能。这个注解点进去看是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@EnableDubboConfig</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span></span><br></pre></td></tr></table></figure><p>包含了包扫描的功能。这种自动扫描包可以换成在配置文件中指定扫描位置：<code>dubbo.scan.base-packages=xxx</code>即可。</p><p>现在我们遇到一个问题，就是传统的xml可以做到精确的方法级别的配置，但是上一种方式是无法做到的，那么如何才能做到对方法级别的控制呢？</p><p>其实我们还是可以将传统的xml文件拷贝到我们的<code>resources</code>文件夹下，一个字都不用动，只需要将<code>@EnableDubbo</code>注解以及暴露服务用的<code>@Service</code>都注释掉，换成：<code>@ImportResource(locations=&quot;classpath:provider.xml&quot;)</code>即可。我们来改造之前的<code>provider-service</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"provider-service"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4、暴露服务   ref：指向服务的真正的实现对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.njupt.swg.DemoService"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"sayHello"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 服务的实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"com.njupt.swg.service.DemoServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接监控中心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在版本<code>&lt;dubbo.starter.version&gt;0.2.1.REALEASE&lt;/dubbo.starter.version&gt;</code>和<code>&lt;dubbo.version&gt;2.6.5&lt;/dubbo.version&gt;</code>中一直报错，莫名其妙，无奈我降级为<code>&lt;dubbo.starter.version&gt;0.2.0&lt;/dubbo.starter.version&gt;</code>和<code>&lt;dubbo.version&gt;2.6.2&lt;/dubbo.version&gt;</code>启动成功。这个代码存放在<a href="https://github.com/sunweiguo/dubbo-example/tree/dubbo2.6.2" target="_blank" rel="noopener">2.6.2分支代码</a>中。</p><p>这是第二种方式。我们引入的话虽说是完美融合了两者，但是作为一个<code>springboot</code>使用者，再用回去好像很奇怪，本来就是为了免去注解，但是这个时候又引入注解，搞成了四不像。下面就要介绍第三种方式了，就是注解的方式，简单来说就是用一个<code>config</code>来代替这个xml中所有的标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationConfig config = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        config.setName(<span class="string">"provider-service"</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RegistryConfig config = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        config.setProtocol(<span class="string">"zookeeper"</span>);</span><br><span class="line">        config.setAddress(<span class="string">"127.0.0.1:2181"</span>);</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的配置都同理，这样在<code>spring</code>容器启动的时候就自动把这些配置加载进来，达到了相同的效果。这里我嫌麻烦就没去验证。其中方法级的配置，对应的xml是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.njupt.swg.DemoService"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">ref</span>=<span class="string">"demoService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"sayHello"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如何改写呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceConfig&lt;DemoService&gt; <span class="title">demoServiceConfig</span><span class="params">(DemoService demoService)</span></span>&#123;</span><br><span class="line">    ServiceConfig&lt;DemoService&gt; config = <span class="keyword">new</span> ServiceConfig&lt;&gt;();</span><br><span class="line">    config.setInterface(DemoService.class);</span><br><span class="line">    config.setRef(demoService);</span><br><span class="line">    <span class="comment">//配置方法信息</span></span><br><span class="line">    MethodConfig methodConfig = <span class="keyword">new</span> MethodConfig();</span><br><span class="line">    methodConfig.setName(<span class="string">"sayHello"</span>);</span><br><span class="line">    methodConfig.setTimeout(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//method放到ServiceConfig中</span></span><br><span class="line">    config.setMethods(Arrays.asList(methodConfig));</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就完成了手动注册的功能，就是第三种实现方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dubbo的基本配置还有一些，本文逐一来攻克&lt;/p&gt;
    
    </summary>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>04-dubbo基本特性之启动检查</title>
    <link href="http://yoursite.com/2019/03/24/dubbo/04-dubbo%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%A3%80%E6%9F%A5/"/>
    <id>http://yoursite.com/2019/03/24/dubbo/04-dubbo基本特性之启动检查/</id>
    <published>2019-03-24T11:13:26.051Z</published>
    <updated>2019-03-24T11:14:26.131Z</updated>
    
    <content type="html"><![CDATA[<p>我们首先来看看第一个比较重要的dubbo特性：启动检查特性。</p><a id="more"></a><h2>一、启动时检查</h2><p><code>Dubbo</code> 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 <code>Spring</code> 初始化完成，以便上线时，能及早发现问题，默认 <code>check=&quot;true&quot;</code>。</p><p>可以通过 <code>check=&quot;false&quot;</code> 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。</p><p>另外，如果你的 <code>Spring</code> 容器是懒加载的，或者通过 <code>API</code> 编程延迟引用服务，请关闭 <code>check</code>，否则服务临时不可用时，会抛出异常，拿到 <code>null</code> 引用，如果 <code>check=&quot;false&quot;</code>，总是会返回引用，当服务恢复时，能自动连上。</p><h2>二、xml文件配置启动时不检查</h2><p>关闭某个服务的启动时检查 (没有提供者时报错)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">check</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>关闭所有服务的启动时检查 (没有提供者时报错)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>关闭注册中心启动时检查 (注册订阅失败时报错)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">check</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2>三、dubbo.properties配置启动时不检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dubbo.reference.com.foo.BarService.check=false</span><br><span class="line">dubbo.reference.check=false</span><br><span class="line">dubbo.consumer.check=false</span><br><span class="line">dubbo.registry.check=false</span><br></pre></td></tr></table></figure><h2>四、通过 -D 参数配置启动时不检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -Ddubbo.reference.com.foo.BarService.check=false</span><br><span class="line">java -Ddubbo.reference.check=false</span><br><span class="line">java -Ddubbo.consumer.check=false </span><br><span class="line">java -Ddubbo.registry.check=false</span><br></pre></td></tr></table></figure><p>其中：<code>dubbo.registry.check=false</code>，前面两个都是指订阅成功，但提供者列表是否为空是否报错，如果注册订阅失败时，也允许启动，需使用此选项，将在后台定时重试。</p><p>还是建议开着，因为在上线的时候不会因为一个服务未启动而导致出现线上BUG.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们首先来看看第一个比较重要的dubbo特性：启动检查特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>03-dubbo实战</title>
    <link href="http://yoursite.com/2019/03/24/dubbo/03-dubbo%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/03/24/dubbo/03-dubbo实战/</id>
    <published>2019-03-24T06:30:41.215Z</published>
    <updated>2019-03-24T06:33:38.650Z</updated>
    
    <content type="html"><![CDATA[<p>本文整合spring boot2.x和dubbo2.6.5版本，新版本才出来，暂时先不管他，包括全新的控制台也暂时不管。</p><a id="more"></a><h2>一、传统xml方式</h2><p>一个服务者，一个消费者，服务者将服务注册到<code>Registry</code>，这个用<code>zookeeper</code>来实现。</p><p>服务者：服务层，即<code>taotao-manager-service</code>的<code>applicationContext-service.xml</code>将接口注册到<code>zookeeper</code>上。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 发布dubbo服务 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"taotao-manager"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注册中心的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"ip address:2181"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.njupt.swg.service.ItemService"</span> <span class="attr">ref</span>=<span class="string">"itemServiceImpl"</span> <span class="attr">timeout</span>=<span class="string">"300000"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>消费者：表现层，即<code>taotao-manager-web的apringmvc.xml</code>中订阅到注册上去的服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用dubbo服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"taotao-manager-web"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"ip地址:2181"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.njupt.swg.service.ItemService"</span> <span class="attr">id</span>=<span class="string">"itemService"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>主要就是以上几个配置，截取于淘淘商城某笔记。依赖就是dubbo和zookeeper客户端。这个就不做了，下面直接上springboot.具体可参考官方文档：<a href="https://dubbo.incubator.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">快速启动</a>以及<a href="https://dubbo.incubator.apache.org/zh-cn/docs/user/references/xml/dubbo-service.html" target="_blank" rel="noopener">schemal含义</a></p><h2>二、springboot2.x+dubbo2.6.5实战</h2><p>本节的代码为：<a href="https://github.com/sunweiguo/dubbo-example" target="_blank" rel="noopener">dubbo-example</a></p><h5>1、创建聚合工程</h5><p>创建一个父亲项目，管理pom，所有的<code>modules</code>都受其管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.njupt.swg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-example<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dubbo-example<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>provider-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dubbo-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">curator-framework.version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">curator-framework.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">zookeeper.version</span>&gt;</span>3.4.13<span class="tag">&lt;/<span class="name">zookeeper.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo.starter.version</span>&gt;</span>0.2.1.RELEASE<span class="tag">&lt;/<span class="name">dubbo.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo.version</span>&gt;</span>2.6.5<span class="tag">&lt;/<span class="name">dubbo.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--dubbo-springboot--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--curator相关，操作zookeeper--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator-framework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator-framework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--zookeeper--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zookeeper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5>2、公共的API接口</h5><p>新创建一个<code>module</code>叫做<code>dubbo-api</code>，里面放的是公共的调用接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>3、服务提供者</h5><p>首先就是pom文件，处理继承父类意外，额外需要注意的是需要依赖于上面一个公共的接口工程，由于API工程是以jar形式存在，所以跟引用普通jar文件一样去依赖它：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.njupt.swg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，服务提供者就可以用这个接口了，后面的消费者也一样，就可以拿到这个接口去消费了。这里先完成服务提供者的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> com.njupt.swg.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dubbo的注解，表示暴露服务</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">//如果这个组件还要被作为bean使用，则开源用@Component来让spring扫描到，再写个@Service会比较模糊</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的注解<code>@Service</code>不是<code>spring</code>中的包注解，而是<code>dubbo</code>中用于暴露服务出去的注解，所以千万不要搞错。需要注意的是，如果还是需要将其作为<code>spring</code>的一个<code>bean</code>的话，则可以用<code>@Component</code>来注解，避免混淆。</p><p>另外最需要注意的就是配置文件了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot 应用名称</span><br><span class="line">spring.application.name=provider-service</span><br><span class="line">server.port=9001</span><br><span class="line"></span><br><span class="line"># Dubbo服务名称</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">dubbo.application.name=provider-service</span><br><span class="line"></span><br><span class="line"># 通信使用dubbo协议，端口为20880</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=20880</span><br><span class="line"></span><br><span class="line"># 以zookeeper为注册中心</span><br><span class="line">dubbo.registry.address=127.0.0.1:2181</span><br><span class="line">dubbo.registry.protocol=zookeeper</span><br><span class="line"></span><br><span class="line"># monitor监控台</span><br><span class="line">dubbo.monitor.protocol=registry</span><br></pre></td></tr></table></figure><p>这些其实跟传统的xml配置方式是一样的，所以大体都是一样的。最后在启动函数上添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubbo</span></span><br></pre></td></tr></table></figure><p>这样启动服务提供者，不报错的话，那么在服务管理中心就可以查看到这个服务已经起来了，加上我们已经准备好的<code>monitor</code>，此时应该有两个服务在上面了。</p><h5>4、服务消费者</h5><p>关于配置文件、pom文件以及启动函数上的注解都跟上面类似，不再赘述。下面直接尝试去调用服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.njupt.swg.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String res = demoService.sayHello(<span class="string">"fossi!"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>@Reference</code>不要引用错了。启动，此时不出意外的话，应该在服务治理页面上会看到如下：</p><p><img src="http://bloghello.oursnail.cn/dubbo3-1.jpg" alt="image"></p><p>我们来消费一下：</p><p><img src="http://bloghello.oursnail.cn/dubbo3-2.jpg" alt="image"></p><p>监控台也可以接受到消费的信息：</p><p><img src="http://bloghello.oursnail.cn/dubbo3-3.jpg" alt="image"></p><p>这样，一次完整的服务提供和消费的实战就完成了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整合spring boot2.x和dubbo2.6.5版本，新版本才出来，暂时先不管他，包括全新的控制台也暂时不管。&lt;/p&gt;
    
    </summary>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>006-binary-tree-postorder-traversal</title>
    <link href="http://yoursite.com/2019/03/23/leetcode-classic/006-binary-tree-postorder-traversal/"/>
    <id>http://yoursite.com/2019/03/23/leetcode-classic/006-binary-tree-postorder-traversal/</id>
    <published>2019-03-23T12:48:36.882Z</published>
    <updated>2019-03-23T12:49:32.403Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第六题，指定非递归来实现二叉树的后序遍历。</p><a id="more"></a><h2>题目描述</h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p><p>For example:</p><p>Given binary tree{1,#,2,3},</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>return[3,2,1].</p><p>Note: Recursive solution is trivial, could you do it iteratively?</p><h2>解题思路</h2><p>就是二叉树的后序遍历，它的意思是，递归程序没啥意思，要不你用非递归来实现一个？</p><p>我们知道，递归就是系统栈实现的，那么其实对于本题，我倾向于自己用一个栈来模拟系统栈，这样，无论是前序中序还是后序，改代码跟递归版本是一样，具有较强的通用性，至于另外的解法，每种都不一样，导致不好记忆。</p><h2>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(String str,TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Command&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//遇到“go”则添加左右孩子以及自己入栈</span></span><br><span class="line">        <span class="comment">//遇到“print”则添加进结果集</span></span><br><span class="line">        stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,root));</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            Command c = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(c.str == <span class="string">"go"</span>)&#123;</span><br><span class="line">                <span class="comment">//先自己</span></span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="string">"print"</span>,c.node));</span><br><span class="line">                <span class="comment">//再右</span></span><br><span class="line">                <span class="keyword">if</span>(c.node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,c.node.right));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//再左</span></span><br><span class="line">                <span class="keyword">if</span>(c.node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>,c.node.left));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//出栈的顺序必然是左-右-中，即后序遍历顺序</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(c.node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要想改成前序或者中序遍历，只需要将<code>stack.push(new Command(&quot;print&quot;,c.node));</code>调换一下位置即可，十分方便，这样对递归的实现原理的理解也加深了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第六题，指定非递归来实现二叉树的后序遍历。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>005-insertion-sort-list</title>
    <link href="http://yoursite.com/2019/03/23/leetcode-classic/005-insertion-sort-list/"/>
    <id>http://yoursite.com/2019/03/23/leetcode-classic/005-insertion-sort-list/</id>
    <published>2019-03-23T12:07:23.540Z</published>
    <updated>2019-03-23T12:08:07.033Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第五题，指定用插入排序对链表进行排序。</p><a id="more"></a><h2>题目描述</h2><p>Sort a linked list using insertion sort.</p><h2>解题思路</h2><p>解题思路就是根据插入排序的思想，每次遍历都保证前n个数都是排好序的，那么按照原生的插入排序，是从当前元素前一个元素开始一个一个往前判断，只要比前面元素小，则往前移动，一直移动到有一个元素小于它或者移动到头部了则停止，这个位置就是当前元素在这一趟中应该在的位置。但是链表中不好往前移，只能每次都从头部开始往后判断，一直找到第一个比当前元素大的元素停止，然后调整一下指针，就是让当前元素插入到本趟合适的位置。由于有可能要与第一个元素交换，所以搞一个虚拟头节点处理起来会简单一点。</p><h2>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判断一下</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.新建一个虚拟节点，后面要用</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.curr指向的节点及其后面所有节点都是未排序的，前面的都是排好序的</span></span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.每次循环，pre都重新指向dummy，dummy后一个节点到curr前一个节点都是排好序的</span></span><br><span class="line">            ListNode pre = dummy;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//5.保存一下当前节点后面一个节点的引用</span></span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//6.每次都从dummy节点下一个开始找，前面都是排好序的，如果小于当前节点则指针后移，一直找到pre.next为空</span></span><br><span class="line">            <span class="comment">//或者比当前节点大的时候，停止，表明pre的下一个节点就是当前节点应该放的位置</span></span><br><span class="line">            <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.val &lt; curr.val)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//7.找到当前节点应该放的位置之后，下面的工作就是移动指针，让curr插到pre和pre.next中间</span></span><br><span class="line">            <span class="comment">//然后让curr后移一位，前面都是排好序的</span></span><br><span class="line">            curr.next = pre.next;</span><br><span class="line">            pre.next = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//8.dummy后面就是我们所需要的用插入排序排好序的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第五题，指定用插入排序对链表进行排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>02-搭建注册中心和控制台</title>
    <link href="http://yoursite.com/2019/03/23/dubbo/02-%E6%90%AD%E5%BB%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%B0/"/>
    <id>http://yoursite.com/2019/03/23/dubbo/02-搭建注册中心和控制台/</id>
    <published>2019-03-23T09:40:08.242Z</published>
    <updated>2019-03-24T03:39:38.028Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了dubbo基本的架构之后，我们先学会使用它，会使用了才有可能理解它的原理。本节先来搭建注册中心和dubbo的可视化控制台界面，为后续的dubbo应用的搭建做好准备。</p><a id="more"></a><h2>一、注册中心</h2><p>打开官方文档，我们会看到dubbo支持很多种注册中心，但是它写了：**推荐使用 Zookeeper 注册中心。**关于zookeeper我已经做了系统学习。</p><p><a href="https://dubbo.incubator.apache.org/zh-cn/docs/user/references/registry/zookeeper.html" target="_blank" rel="noopener">zookeeper 注册中心</a>详细说明了zk的作用以及代码中客户端的使用。</p><p><img src="http://bloghello.oursnail.cn/dubbo2-1.jpg" alt="image"></p><p>我们知道zk是一颗树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心</p><p>流程说明：</p><ul><li>服务提供者启动时: 向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li>服务消费者启动时: 订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li>监控中心启动时: 订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址。</li></ul><p>支持以下功能：</p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求</li><li>当设置 &lt;dubbo:registry check=“false” /&gt; 时，记录失败注册和订阅请求，后台定时重试</li><li>可通过 &lt;dubbo:registry username=“admin” password=“1234” /&gt; 设置 zookeeper 登录信息</li><li>可通过 &lt;dubbo:registry group=“dubbo” /&gt; 设置 zookeeper 的根节点，不设置将使用无根树</li><li>支持 * 号通配符 &lt;dubbo:reference group=&quot; * &quot; version=&quot; * &quot; /&gt;，可订阅服务的所有分组和所有版本的提供者</li></ul><p><code>Dubbo</code> 支持 <code>zkclient</code> 和 <code>curator</code> 两种 <code>Zookeeper</code> 客户端实现。</p><h2>二、zookeeper 安装</h2><p>就在windows下先安装练习吧！其他系统的也差不多。</p><p>注意一下直接启动不行的，要将<code>conf</code>下的<code>zoo_sample.cfg</code>改为<code>zoo.cfg</code>才行，默认的端口是2181，注意修改一下临时数据存放的路径。这些修改完成之后，windows下就可以直接在命令行中用<code>zkServer.cmd</code>启动了。</p><h2>三、new dubbo admin</h2><p>什么是<code>dubbo admin</code>？是图形化服务管理页面，安装时需要指定注册中心地址，即可从注册中心中获取到所有的提供者/消费者进行配置管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/incubator-dubbo-ops.git</span><br><span class="line">cd incubator-dubbo-ops</span><br><span class="line">mvn clean package</span><br><span class="line">cd dubbo-admin-distribution/target</span><br><span class="line">java -jar dubbo-admin-0.1.jar</span><br></pre></td></tr></table></figure><p>访问http://localhost:8080即可。</p><p><img src="http://bloghello.oursnail.cn/dubbo2-2.jpg" alt="image"></p><p>我们看到克隆下来之后其实有三个文件：<code>dubbo-admin-distribution</code>，<code>dubbo-admin-server</code>，<code>dubbo-admin-ui</code>，根据官网介绍，我们只需要对第一个进行打包然后<code>java -jar</code>即可。后面两个是前后端分离的部署方式。所以我们主要来看看<code>dubbo-admin-server</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admin.config-center=zookeeper://127.0.0.1:2181</span><br><span class="line">admin.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">admin.metadata-report.address=zookeeper://127.0.0.1:2181</span><br></pre></td></tr></table></figure><p>三个配置项分别指定了配置中心，注册中心和元数据中心的地址。这个以后再去了解。OK，下一节来看看dubbo的<code>provider</code>和<code>consumer</code>是如何暴露服务以及消费服务的。</p><p>以上为新版的管理控制台，但是我看还是develop分支，说明还不是很稳定，文档啥的也不是很全，就暂时不入坑了。我们还是回到2.6版本。上一版本，admin管理台和monitor监控是分开的。这里说一下老版本的admin。</p><h2>四、old dubbo admin</h2><p>下载地址：<a href="http://bloghello.oursnail.cn/incubator-dubbo-ops-master.zip" target="_blank" rel="noopener"><br>incubator-dubbo-ops-master.zip</a></p><p>主要是先关注里面的<code>dubbo-admin</code>，他就是老版本服务治理的管理页面。注意源码里面里面的<code>application.properties</code>中连接zk的信息，匹配即可。先启动zk，然后对这个文件夹打包运行。默认是用<code>localhost:7001</code>打开。需要额外输入用户名和密码，默认都是<code>root</code>。</p><p><img src="http://bloghello.oursnail.cn/dubbo2-3.jpg" alt="image"></p><p>下面我就还是用这个版本对服务进行管理吧！</p><h2>五、dubbo-monitor-simple</h2><p>这是一个简单的监控中心。</p><p>在<code>incubator-dubbo-ops-master</code>文件夹下有一个文件叫做<code>dubbo-monitor-simple</code>，进行<code>mvn package</code>之后为：</p><p><img src="http://bloghello.oursnail.cn/dubbo2-4.jpg" alt="image"></p><p>将其拷贝到另外一个地方解压。里面有三个文件夹，有一个是<code>conf</code>文件夹，我们编辑<code>dubbo.properties</code>这个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dubbo.container=log4j,spring,registry,jetty-monitor</span><br><span class="line">dubbo.application.name=simple-monitor</span><br><span class="line">dubbo.application.owner=dubbo</span><br><span class="line">#dubbo.registry.address=multicast://224.5.6.7:1234</span><br><span class="line">//ZK的地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">#dubbo.registry.address=redis://127.0.0.1:6379</span><br><span class="line">#dubbo.registry.address=dubbo://127.0.0.1:9090</span><br><span class="line">//与本控制台通信的端口</span><br><span class="line">dubbo.protocol.port=7070</span><br><span class="line">//可视化界面的访问端口</span><br><span class="line">dubbo.jetty.port=8080</span><br><span class="line">dubbo.jetty.directory=$&#123;user.home&#125;/monitor</span><br><span class="line">dubbo.charts.directory=$&#123;user.home&#125;/monitor/charts</span><br><span class="line">dubbo.statistics.directory=$&#123;user.home&#125;/monitor/statistics</span><br><span class="line">dubbo.log4j.file=logs/dubbo-monitor-simple.log</span><br><span class="line">dubbo.log4j.level=WARN</span><br></pre></td></tr></table></figure><p>一切没有问题，来到<code>assembly.bin</code>下去启动吧！启动成功的话为：</p><p><img src="http://bloghello.oursnail.cn/dubbo2-5.jpg" alt="image"></p><p>下面进行实操并且结合这边搭建的监控台一起观察观察。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍了dubbo基本的架构之后，我们先学会使用它，会使用了才有可能理解它的原理。本节先来搭建注册中心和dubbo的可视化控制台界面，为后续的dubbo应用的搭建做好准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>01-分布式基础知识</title>
    <link href="http://yoursite.com/2019/03/23/dubbo/01-%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/03/23/dubbo/01-分布式基础知识/</id>
    <published>2019-03-23T08:01:40.403Z</published>
    <updated>2019-03-23T08:07:45.405Z</updated>
    
    <content type="html"><![CDATA[<p>由于我对分布式系统学习接触的稍微较晚，因为一直在打基础，在我认为基础有所起色的时候，我顺便系统学习了一下spring cloud技术栈，然后再回过头来学习看以下dubbo怎么用的时候，会发现还是spring cloud比较厉害，因为它是一站式的解决方案，但是dubbo仅仅解决了服务治理功能，其他的所有都要借助其他的框架来实现。但是看到国内用dubbo这么广泛，并且阿里重新对dubbo进行维护，因此学习它也是非常必要的。这样对于spring cloud的理解可能也会有帮助吧！并且我想理解dubbo这款优秀的RPC框架的基本原理，日后以自己造出小轮子为目标。本文还是从基本的说起。</p><a id="more"></a><h2>一、什么是分布式系统</h2><p>《分布式系统原理与范型》定义：</p><blockquote><p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”</p></blockquote><p>这里注意集群和分布式的区别，打个比方，青椒炒肉丝，如果是两个厨师各自炒半碗青椒肉丝，最后合起来一碗青椒肉丝，这两个厨师集群；一个厨师炒青椒，一个厨师炒肉丝，合起来又是一碗青椒肉丝，这两个厨师是分布式。在软件系统中，一个系统可能有很多的业务，比如京东，有商品业务，订单业务，支付业务，物流业务等等，一个服务器肯定是无法支撑的，那么这些业务就需要分散到不同的机器集群上，这些集群分别对外提供各自的业务功能，整个分布式系统对外提供京东商城的服务。</p><p>引入分布式，那就引入了及其复杂的问题，因为服务与服务之间肯定是需要互相通信的，这属于进程间的通信，所以需要一个东西可以帮助我们实现这个功能，这就是RPC框架解决的事情。</p><h2>二、发展演变</h2><p>我们去看看dubbo的官网。以下内容为对官方文档部分介绍的解释。</p><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p><p><img src="http://bloghello.oursnail.cn/dubbo-architecture-roadmap.jpg" alt="image"></p><h5>单一应用架构</h5><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p><p><img src="http://bloghello.oursnail.cn/dubbo1-1.png" alt="image"></p><p>缺点十分明显：</p><ul><li>性能扩展比较难</li><li>协同开发问题</li><li>不利于升级维护</li></ul><h5>垂直应用架构</h5><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><p><img src="http://bloghello.oursnail.cn/dubbo1-2.png" alt="image"></p><p>优点：通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p><p>缺点：公用模块无法重复利用，开发性的浪费</p><h5>分布式服务架构</h5><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p><p><img src="http://bloghello.oursnail.cn/dubbo1-3.png" alt="image"></p><h5>流动计算架构</h5><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><p><img src="http://bloghello.oursnail.cn/dubbo1-4.png" alt="image"></p><h2>三、RPC</h2><p><code>RPC</code>【<code>Remote Procedure Call</code>】是指远程过程调用，<strong>是一种进程间通信方式</strong>，他是一种技术的思想，而不是规范。<strong>它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数</strong>，而不用程序员显式编码这个远程调用的细节。<strong>即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同</strong>。</p><p>下面这张图简单说明了RPC的基本原理，左边进程要调用右边进程中某个方法，那么左边首先通过<code>client stub</code>这样的小助手将要调用的方法名称参数都包装好，通过<code>socket</code>将消息发送到右边，右边接受之后也通过小助手拿到要调用的方法和参数，处理完毕将结果再返回给左边进程。</p><p><img src="http://bloghello.oursnail.cn/dubbo1-5.png" alt="image"></p><p>具体一点的细节，就是需要将调用的方法名以及参数等序列化，然后进程间通信，最后反序列化，处理。</p><p><img src="http://bloghello.oursnail.cn/dubbo1-6.png" alt="image"></p><p>这里就体现了RPC的两个核心模块：通讯，序列化。两者速度决定了这个RPC框架的优劣。</p><h2>Dubbo</h2><p><img src="http://bloghello.oursnail.cn/dubbo1-7.png" alt="image"></p><p>我们先来看看dubbo的优秀特性。第一条是面向接口，以接口为粒度，这对于java开发来说是天生的优势。第二条支持智能负载均衡，因为可能有多台服务器符合条件，快速找出一台比较空闲一点的来执行也是关键点。第三条是支持多种注册中心服务，比如大名鼎鼎的<code>zookeeper</code>。第四条是可扩展，内部的模块也可以扩展。第五条是运行期流量调度，其中提到灰度发布，就是从一部分的机器慢慢提供新服务开始逐渐到所有机器提供新服务，这个过程就是灰度发布。最后一条是可视化，dubbo提供可视化界面方便查看和操作。</p><p>下面我们来看看dubbo的架构图：</p><p><img src="http://bloghello.oursnail.cn/dubbo1-8.png" alt="image"></p><p>我们看到，主体是四个部分，最上面是注册中心，这个注册中心有什么用呢？由于服务众多，如果不用注册中心，一台主机调用另一台主机上的服务，我不知道这个服务在哪，也不知道这个服务有没有挂，如果是每个主机都维护这个关系那就比较麻烦了，注册中心帮助我们解决这个问题，所有的服务都注册到注册中心上，那么调用方就订阅这个注册中心，它就知道要调用的服务在不在工作，在哪台机器工作等，十分方便。</p><p>介绍完了注册中心，右边是<code>Provider</code>，它像注册中心注册自己。左边是<code>Consumer</code>，它向注册中心订阅相关服务(自己感兴趣的服务)。这个<code>Provider</code>建立在dubbo容器之上，这样一个服务才拥有RPC功能，可以让别人调用也可以去调用别人。</p><p>最下面是监控器，就是监控服务之间的状态。</p><p>那么启动顺序是什么呢？第一步就是启动dubbo容器，启动完成，<code>Provider</code>就可以向注册中心注册自己的服务了，下面<code>Consumer</code>在启动的时候就会去注册中心订阅相关的服务。以上是初始化过程。</p><p>如果注册中心里面，<code>Provider</code> 列表有变化的话，<code>Consumer</code> 也会得到通知。这是异步调用的过程。所有服务的状态信息也都会异步传给监视器。</p><p><code>Consumer</code>要调用服务了，从订阅消息中就可以拿到感兴趣的<code>Provider</code>信息，就可以直接与<code>Provider</code>建立通信了。这是一个同步调用过程。如果<code>Provider</code>有多个，再根据一定的负载均衡策略，精确地调用到某台 <code>Provider</code> 上去。</p><p>以上就是分布式的基础知识以及dubbo的基础知识，其中dubbo的基础架构要了然于心，这是学习dubbo贯穿始终的基本点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于我对分布式系统学习接触的稍微较晚，因为一直在打基础，在我认为基础有所起色的时候，我顺便系统学习了一下spring cloud技术栈，然后再回过头来学习看以下dubbo怎么用的时候，会发现还是spring cloud比较厉害，因为它是一站式的解决方案，但是dubbo仅仅解决了服务治理功能，其他的所有都要借助其他的框架来实现。但是看到国内用dubbo这么广泛，并且阿里重新对dubbo进行维护，因此学习它也是非常必要的。这样对于spring cloud的理解可能也会有帮助吧！并且我想理解dubbo这款优秀的RPC框架的基本原理，日后以自己造出小轮子为目标。本文还是从基本的说起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="dubbo" scheme="http://yoursite.com/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>004-sort-list</title>
    <link href="http://yoursite.com/2019/03/22/leetcode-classic/004-sort-list/"/>
    <id>http://yoursite.com/2019/03/22/leetcode-classic/004-sort-list/</id>
    <published>2019-03-22T08:20:14.190Z</published>
    <updated>2019-03-22T08:20:57.218Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第四题，对链表进行排序。</p><a id="more"></a><h2>题目描述</h2><p>Sort a linked list in O(n log n) time using constant space complexity.</p><p>Example 1:</p><blockquote><p>Input: 4-&gt;2-&gt;1-&gt;3</p><p>Output: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p>Example 2:</p><blockquote><p>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</p><p>Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h2>解题思路</h2><p>最近忙着追《都挺好》，差点忘记每天的任务。这一题要求时间复杂度为O(n log n) 并且用常数级别的空间复杂度。对于链表这种数据结构，不像数组那么方便，因此堆排序以及快速排序不是很方便，因此这一题用归并排序比较合适，并且对于本题，空间上不需要用数组来存储，因此是常数级别的。</p><h2>代码提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归并排序的归过程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.判定是否为空或者只有一个元素，这也是归并排序中归的停止条件</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.将链表截成两段</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.此时pre跟slow指的一样，现在将链表从中间断开</span></span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.继续再对上面分开的链表再分</span></span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.递归分开之后就应该按照一定的规则合并了</span></span><br><span class="line">        <span class="keyword">return</span> merge(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并排序的并过程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//新建一个结点用于串联并过程结果</span></span><br><span class="line">        ListNode tmp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//并的过程，谁小谁就接到p后面</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果有一段没有结束，直接接到后面即可</span></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回下一个结点</span></span><br><span class="line">        <span class="keyword">return</span> tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第四题，对链表进行排序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>003-Max Points on a Line</title>
    <link href="http://yoursite.com/2019/03/21/leetcode-classic/003-Max%20Points%20on%20a%20Line/"/>
    <id>http://yoursite.com/2019/03/21/leetcode-classic/003-Max Points on a Line/</id>
    <published>2019-03-21T04:33:04.880Z</published>
    <updated>2019-03-21T04:33:51.164Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第三题，关于求坐标共线问题。</p><a id="more"></a><h2>题目描述</h2><p><img src="http://bloghello.oursnail.cn/leetcode3-1.png" alt="image"></p><h2>解题思路</h2><p>点共线，那么最容易想到的思路就是确定斜率，斜率相同不就共线了。但是还有两点特殊情况需要考虑，二是当两个点重合时，无法确定一条直线，但这也是共线的情况，需要特殊处理。二是斜率不存在的情况，由于两个点(x1, y1)和(x2, y2)的斜率k表示为(y2 - y1) / (x2 - x1)，那么当x1 = x2时斜率不存在，这种共线情况需要特殊处理。这里我对重合的情况，斜率不存在的情况以及斜率为0的情况进行了讨论，因为这比较好处理，所以处理一下斜率为0的没什么问题。最后就是通用情况，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(points.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> points.length;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Double,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="keyword">int</span> overlap = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> vertical = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> horizon = <span class="number">0</span>;   </span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">double</span> rate = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="keyword">double</span> gapx = <span class="keyword">new</span> Double(points[i].x) - <span class="keyword">new</span> Double(points[j].x);</span><br><span class="line">                <span class="keyword">double</span> gapy = <span class="keyword">new</span> Double(points[i].y) - <span class="keyword">new</span> Double(points[j].y);</span><br><span class="line">                <span class="keyword">if</span>(gapx == <span class="number">0</span> &amp;&amp; gapy == <span class="number">0</span>)&#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gapx == <span class="number">0</span>)&#123;</span><br><span class="line">                    vertical++;</span><br><span class="line">                    max = Math.max(max,vertical);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gapy == <span class="number">0</span>)&#123;</span><br><span class="line">                    horizon++;</span><br><span class="line">                    max = Math.max(max,horizon);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    rate = gapy/gapx;</span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(rate))&#123;</span><br><span class="line">                        map.put(rate,map.get(rate)+<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        map.put(rate,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    max = Math.max(max,map.get(rate));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result=Math.max(result, max+overlap+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然可以在牛客上通过，但是这个思路在leetcode上已经不行了，它给的例子是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input      [[0,0],[94911151,94911150],[94911152,94911151]]</span><br><span class="line">Output     3</span><br><span class="line">Expected   2</span><br></pre></td></tr></table></figure><p>我们注意到，由于精度丢失问题，我们算出来的斜率竟然是一样的了，所以这个程序错误地认为这三个点都共线了。因此错误。那怎么办呢？</p><h2>代码提交</h2><p>由于通过斜率来判断共线需要用到除法，而用double表示的双精度小数在有的系统里不一定准确，为了更加精确无误的计算共线，<strong>我们应当避免除法</strong>，从而避免无线不循环小数的出现，那么怎么办呢，我们把除数和被除数都保存下来，不做除法，但是<u><strong>我们要让这两数分别除以它们的最大公约数，这样例如8和4，4和2，2和1，这三组商相同的数就都会存到一个映射里面，同样也能实现我们的目标。</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(points.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> points.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//key为每个数组除以最大公约数后的结果，比如[8,4],[4,2],[2,1]最后都变成[2,1]存储</span></span><br><span class="line">        Map&lt;Map&lt;Integer,Integer&gt;,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="comment">//每次循环完毕要清空map，否则会把上次统计结果带到下一次循环来</span></span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="comment">//重复个数，自己算重复元素，所以初始元素为1</span></span><br><span class="line">            <span class="keyword">int</span> dup = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="comment">//计算出两者间隔</span></span><br><span class="line">                <span class="keyword">int</span> x = points[i].x - points[j].x;</span><br><span class="line">                <span class="keyword">int</span> y = points[i].y - points[j].y;</span><br><span class="line">                <span class="comment">//重合的话就将dup加一</span></span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">                    dup++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算最大公约数</span></span><br><span class="line">                <span class="keyword">int</span> d = gcd(x, y);</span><br><span class="line">                Map&lt;Integer,Integer&gt; tmpMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                tmpMap.put(x/d,y/d);</span><br><span class="line">                <span class="comment">//次数</span></span><br><span class="line">                map.put(tmpMap, map.getOrDefault(tmpMap, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//每次都将最大的放到max中，避免最后还要遍历判断map中最大次数</span></span><br><span class="line">                max = Math.max(max,map.get(tmpMap));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后的结果就是map+dup</span></span><br><span class="line">            result = Math.max(result,max+dup);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b == <span class="number">0</span>) ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第三题，关于求坐标共线问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>javascript基础扫尾</title>
    <link href="http://yoursite.com/2019/03/20/front/javascript%E5%9F%BA%E7%A1%80%E6%89%AB%E5%B0%BE/"/>
    <id>http://yoursite.com/2019/03/20/front/javascript基础扫尾/</id>
    <published>2019-03-20T13:09:32.070Z</published>
    <updated>2019-03-20T13:09:54.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文继续对js的基础知识进行学习。</p><a id="more"></a><h2>一、日期操作</h2><p>对于日期一般都是简单的显示，因为处理都是在后端的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(now);<span class="comment">//当前时间：Wed Mar 20 2019 14:58:09 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以自定义时间</span></span><br><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2019-03-20 15:04:14"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以set也可以get</span></span><br><span class="line"><span class="built_in">console</span>.log(now.getDay());</span><br><span class="line"><span class="built_in">console</span>.log(now.getMonth());<span class="comment">//注意0代表的是一月份</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>二、字符串的一些操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//字符串处理</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"HELLO fossi"</span>;</span><br><span class="line"><span class="comment">//str = str.replace("o","O");//替换o为O</span></span><br><span class="line">str = str.replace(<span class="regexp">/o/gi</span>,<span class="string">"e"</span>);<span class="comment">//g全局，i表示忽略大小写，这里用到了正则表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line">str = <span class="string">"HELLO fossi"</span>;</span><br><span class="line"><span class="keyword">var</span> res = str.split(<span class="string">" "</span>);<span class="comment">//按照空格进行切割，返回的是数组</span></span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">// ["HELLO", "fossi"]</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>关于字符串的操作有很多很多，且与其他主流语言支持的差不多，所以就不赘述了。</p><h2>三、函数的调用和声明位置</h2><p>一般情况下，函数是先定义再调用。但是在js中如果是普通的函数，那么无论是先声明再调用还是先调用再声明，都是可以的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//1.先调用函数，再声明函数</span></span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.先声明函数再调用</span></span><br><span class="line"><span class="comment">//console.log(add1(2,3));//OK</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>但是另一种方式，就是一个函数作为一个变量的写法，就必须先声明再调用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">console</span>.log(add2(<span class="number">2</span>,<span class="number">3</span>));<span class="comment">//ERROR</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//作为一个变量的话，必须先声明后使用</span></span><br><span class="line"><span class="keyword">var</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(add2(2,3));//OK</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>四、函数作为参数传递</h2><p>js非常灵活，一个函数就可以作为参数传递进另一个函数中。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//函数可以作为参数传递给另一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num+<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFuntion</span>(<span class="params">someFuntion,arg</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> someFuntion(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callFuntion(addTen,<span class="number">100</span>));<span class="comment">//110</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>五、根据属性对对象进行排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">// 自定义的排序</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">name:<span class="string">"fossi"</span>,</span><br><span class="line">age:<span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">name:<span class="string">"swg"</span>,</span><br><span class="line">age:<span class="number">30</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person3 = &#123;</span><br><span class="line">name:<span class="string">"swg"</span>,</span><br><span class="line">age:<span class="number">25</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [person1,person2,person3];</span><br><span class="line"><span class="comment">//用createComparator进行排序的定义</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(createComparator(<span class="string">"age"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparator</span>(<span class="params">propertyName</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> value1 = obj1[propertyName];</span><br><span class="line"><span class="keyword">var</span> value2 = obj2[propertyName];</span><br><span class="line"><span class="keyword">if</span>(value1 &gt; value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1 &lt; value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>六、apply和call</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">// apply call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="comment">//1.第一种写法</span></span><br><span class="line"><span class="comment">// return sum.apply(this,arguments);</span></span><br><span class="line"><span class="comment">//2.第二种写法</span></span><br><span class="line"><span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,[num1,num2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum.call(<span class="keyword">this</span>,num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><code>apply</code>和<code>call</code>方法类似，简单理解，都是相当于调用其他的方法。它有个显著的特点就是改变作用域，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//可以改变作用域</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">color</span>:<span class="string">"green"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showColor();<span class="comment">//red</span></span><br><span class="line">showColor.apply(person);<span class="comment">//green</span></span><br><span class="line">showColor.call(person);<span class="comment">//green</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>直接调用必然是全局域中的<code>red</code>，但是用<code>apply</code>方法的话，传禁区的是<code>person</code>这个对象，那么此时打印出来的就是这个对象中的属性值。</p><h2>七、包装类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">//基本类型的包装类型</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"hello fossi"</span>;</span><br><span class="line"><span class="comment">// 等价于：var s = new String("hello fossi");</span></span><br><span class="line"><span class="keyword">var</span> res = s.split(<span class="string">" "</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是一旦包装类型创建成功后就不能再像普通对象一样添加属性</span></span><br><span class="line">s.name = <span class="string">"fossi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.name);<span class="comment">//undefined</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>包装类型可以提供一些方法让你调用，十分方便。上面说的是字符串，还有布尔和number类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> falseObj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);<span class="comment">//尽量不要用,会引起一些必要的问题</span></span><br><span class="line"><span class="keyword">var</span> fal = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> falseObj);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fal);<span class="comment">//boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//number类型</span></span><br><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> number = <span class="number">10.005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number.toFixed(<span class="number">2</span>));<span class="comment">//指定显示的小数的位数，这里就是10.01</span></span><br><span class="line"><span class="keyword">var</span> number2 = <span class="number">2374281472</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number2.toExponential());<span class="comment">//指数来表示</span></span><br><span class="line"><span class="built_in">console</span>.log(number2.toPrecision(<span class="number">3</span>));<span class="comment">//自己指定位数显示</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>八、eval</h2><p>这玩意可就厉害了，可以把js的语句包在字符串里面，可以直接执行和调用，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//可以在eval里面嵌套语句或者函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"console.log(a)"</span>);<span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"function say()&#123;alert(a)&#125;"</span>);</span><br><span class="line">say();<span class="comment">//hello world</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>九、面向对象</h2><p>我们知道定义一个对象，如果没有任何处理的话，可以直接修改它的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"swg"</span>; <span class="comment">//如果不让随意做修改怎么办呢?</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>此时就需要给它加上一些规则，允许对它干什么，不允许对它干什么，都规定好。那么如果不允许对它的属性进行修改的话，那么就不能通过上面的方式进行随意修改了，这如何实现的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>));</span><br><span class="line"><span class="comment">//主要显示的是四个属性:</span></span><br><span class="line"><span class="comment">//&#123;value: "fossi", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">//value:值;</span></span><br><span class="line"><span class="comment">//writable是否可以修改;</span></span><br><span class="line"><span class="comment">//enumerable是否支持for-in遍历;</span></span><br><span class="line"><span class="comment">//configurable是否允许删除</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>下面我们来实际操作一下这几个属性。</p><p>首先我配置它不允许被删除，下面再删除属性试试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据属性-控制对象的数据</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">configurable:<span class="literal">false</span>,<span class="comment">//不允许删除此属性</span></span><br><span class="line">value:<span class="string">"swg"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//swg</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//没有报错,还是swg</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>下面配是一下不能修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">20</span>,</span><br><span class="line">sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据属性-控制对象的数据</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">configurable:<span class="literal">false</span>,<span class="comment">//不允许删除此属性</span></span><br><span class="line">writable:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//fossi</span></span><br><span class="line">person.name = <span class="string">"swg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//fossi</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>修改不成功，说明不让在外面修改了。好了，关于数据属性就介绍这么多，下面说一下访问器属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">_age: <span class="number">0</span>,</span><br><span class="line">sex: <span class="number">1</span>,</span><br><span class="line">birth:<span class="number">1994</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据属性-控制对象的数据</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"age"</span>,&#123;</span><br><span class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._age = <span class="number">2019</span>-<span class="keyword">this</span>.birth;</span><br><span class="line">&#125;,</span><br><span class="line">set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>._age = newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.age);<span class="comment">//25</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>就是说一调用<code>person.name</code>的时候就会自动调用<code>get</code>来获取，这里就可以实现动态的获取年龄。</p><p>注意，这里的age用_age代替.前面加下划线是常用的用法,表示只能用对象方法访问的属性.如果用age回导致死循环赋值.</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"fossi"</span>,</span><br><span class="line">age: <span class="number">0</span>,</span><br><span class="line">sex: <span class="number">1</span>,</span><br><span class="line">birth:<span class="number">1994</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据属性-控制对象的数据</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"age"</span>,&#123;</span><br><span class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age = <span class="number">2019</span>-<span class="keyword">this</span>.birth;</span><br><span class="line">&#125;,</span><br><span class="line">set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person.age);<span class="comment">//25</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test.html:22 Uncaught RangeError: Maximum call stack size exceeded</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br><span class="line">    at Object.set [as age] (test.html:22)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文继续对js的基础知识进行学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>002-evaluate-reverse-polish-notation</title>
    <link href="http://yoursite.com/2019/03/20/leetcode-classic/002-evaluate-reverse-polish-notation/"/>
    <id>http://yoursite.com/2019/03/20/leetcode-classic/002-evaluate-reverse-polish-notation/</id>
    <published>2019-03-20T03:45:59.138Z</published>
    <updated>2019-03-20T03:46:30.140Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第二题，关于栈的操作。</p><a id="more"></a><h2>题目描述</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.<br>Valid operators are+,-,*,/. Each operand may be an integer or another expression.<br>Some examples:</p><p><img src="http://bloghello.oursnail.cn/leetcode2-1.png" alt="image"></p><h2>解题思路</h2><p>这一题提示信息是用栈来实现，那么思路为：如果当前元素是数字就入栈，否则就是运算符，那么就将这个运算符前面两个数字进行相应操作，并且将这个操作结果重新再放入栈中，参与下一次的运算。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tokens == <span class="keyword">null</span> || tokens.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tokens.length == <span class="number">1</span>)&#123;</span><br><span class="line">            res = Integer.valueOf(tokens[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">"+"</span>) || str.equals(<span class="string">"-"</span>) || str.equals(<span class="string">"*"</span>) || str.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> v1 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> v2 = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(str.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">                    res = v1+v2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"-"</span>))&#123;</span><br><span class="line">                    res = v2-v1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"*"</span>))&#123;</span><br><span class="line">                    res = v1*v2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">                    res = v2/v1;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(res);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(str));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第二题，关于栈的操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>001-Minimum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2019/03/20/leetcode-classic/001-Minimum%20Depth%20of%20Binary%20Tree/"/>
    <id>http://yoursite.com/2019/03/20/leetcode-classic/001-Minimum Depth of Binary Tree/</id>
    <published>2019-03-20T03:15:24.805Z</published>
    <updated>2019-03-20T03:16:23.477Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode经典例题第一题，关于树。</p><a id="more"></a><h2>题目描述</h2><p>Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><h2>解题思路</h2><p>解决树的问题，递归肯定是最简单的代码。我们之前练习过求树的最大深度，但是要注意，求最小深度和最大深度是稍微有点不一样的，因为最大深度只需要考虑哪边大即可，即使是单子树（树只有一侧有结点），方式与求双子树的最大深度是一样的。但是对于求最小深度而言，如果出现单子树的情况，那么按照最小深度的定义：根结点到叶子结点的最小距离，那么显然这个最小深度是表示有结点的那一侧。</p><h2>提交代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口条件1</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归出口条件2</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意点是要考虑是单子树的情况，因为很有可能只有一侧有节点，那么最小深度就是这以一侧</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> run(root.right)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> run(root.left)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是双子树，则对比树两边谁小即可，与求最大深度一样</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(run(root.left),run(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode经典例题第一题，关于树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode经典" scheme="http://yoursite.com/tags/leetcode%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>javascript基础学习</title>
    <link href="http://yoursite.com/2019/03/19/front/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/19/front/javascript基础学习/</id>
    <published>2019-03-19T13:56:39.529Z</published>
    <updated>2019-03-19T14:04:31.654Z</updated>
    
    <content type="html"><![CDATA[<p>js和其他的语言很像，很多的操作都是一样的，比如数值的运算符、循环的控制等，这些基础的语法知识就不再赘述了，本文着重是对比较重要的知识点进行总结，尤其是关于对象和数组这块的处理，因为对于前端来说，大多数数据不是对象(json)就是数组，所以掌握其中的一些api会事半功倍。</p><a id="more"></a><h2>一、数据类型</h2><p>虽然说定义变量都是<code>var</code>，但是其实是分为几种类型的，下面我们来看看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="string">'hello'</span>;</span><br><span class="line">     <span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">var</span> d;</span><br><span class="line">     <span class="keyword">var</span> e = alert;</span><br><span class="line">     <span class="keyword">var</span> f = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*基本数据类型*/</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> d);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> e);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>我们看到，可以用<code>typeof</code>来查看每个变量的类型，它们是：</p><p><img src="http://bloghello.oursnail.cn/js1-1.png" alt="image"></p><h2>二、无限大</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/*无限大以及NAN*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="number">3</span>*<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE/<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>/<span class="number">0</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>执行的结果是：</p><p><img src="http://bloghello.oursnail.cn/js1-2.png" alt="image"></p><p>我们看到，无穷与0想成则为NAN，就是说它也不知道这到底是啥玩意，其他的基本都是表示无限大的<code>Infinity</code></p><h2>三、函数参数问题</h2><p>在我们比较熟悉的静态语言比如C，C++以及Java中，调用函数的话，参数一定要明确，否则会出错。比如一个函数明明没有任何形参，但是你调用的时候硬生生地传递几个参数进去，那么编译的时候就会报错。但是js中是不会的。一个函数可以定义为无参，但是调用的时候，你可以添加几个参数进去，所以是动态的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//可以没有形式参数</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">         <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">             sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(add(a,b));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>所以上面这个程序是可以正常执行的。</p><h2>四、作用域问题</h2><p>如果是一个局部变量，那么在外面正常情况下是无法访问到的，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//作用域</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">             <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log(a);<span class="comment">//error</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这里的a就无法在函数外面访问到，因为这个a是函数f的内部局部变量，外面的只能访问全局变量。这也符合我们其他语言的规范，但是这里要注意，定义在<code>if</code>,<code>while</code>以及<code>for</code>代码块中的局部变量我们依然可以在外面访问到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log(a);<span class="comment">//ok</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>五、数组如何定义</h2><p>数组是一种引用类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        alert(<span class="string">"arr 是数组"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在对于传入的参数不清楚的情况下，我们可以先判断一下类型是不是符合我们的要求，这可以提高程序的健壮性，就像先判断是否为空再操作的原则。</p><h2>六、定义一个对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//第一种 new Object</span></span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    person.name = <span class="string">"fossi"</span>;</span><br><span class="line">    person.age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这跟java中定义形式几乎一样，访问它的属性也一样，就是<code>person.name</code>即可。</p><p>还有一种比较常用的定义对象的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//第二种 new Object</span></span><br><span class="line">    <span class="keyword">var</span> person = &#123;<span class="string">"name"</span>:<span class="string">"fossi"</span>,</span><br><span class="line">                  <span class="string">"age"</span>:<span class="number">20</span>,</span><br><span class="line">                  <span class="string">"fun"</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                     alert(<span class="string">"i am a person"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">    person.fun();</span><br><span class="line">    <span class="built_in">console</span>.log(person[<span class="string">"age"</span>]);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>注意，一个函数也可以作为它的成员变量，类似于java中的成员方法。</p><h2>七、数组打印</h2><p>数组非常重要，掌握数组常用的技巧将事半功倍。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//opeartion of array</span></span><br><span class="line">    <span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"yellow"</span>,<span class="string">"blue"</span>];</span><br><span class="line">    colors[<span class="number">8</span>] = <span class="string">"pink"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    <span class="built_in">console</span>.log(colors.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.valueOf());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.toLocaleString());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.join(<span class="string">"|"</span>));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这几个基本都是以不同的形式打印出数组来，最后一个是指用<code>|</code>来拼接数组元素再打印。</p><p><img src="http://bloghello.oursnail.cn/js1-3.png" alt="image"></p><h2>八、数组实现栈以及队列</h2><p>数组可以直接用<code>push</code>和<code>pop</code>实现栈的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//stack</span></span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    stack.push(<span class="string">"fossi"</span>);</span><br><span class="line">    stack.push(<span class="string">"vainda"</span>);</span><br><span class="line">    stack.push(<span class="string">"xiaoxu"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果也显而易见：</p><p><img src="http://bloghello.oursnail.cn/js1-4.png" alt="image"></p><p>下面再用数组来模拟队列，<code>shift()</code> 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值，也是非常简单的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//queue push+shift or unshift+pop</span></span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    queue.push(<span class="string">"fossi"</span>);</span><br><span class="line">    queue.push(<span class="string">"vainda"</span>);</span><br><span class="line">    queue.push(<span class="string">"xiaoxu"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果也显而易见：</p><p><img src="http://bloghello.oursnail.cn/js1-6.png" alt="image"></p><h2>九、数组的拼接和删除</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"yellow"</span>,<span class="string">"blue"</span>,<span class="string">"pink"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.后面拼接一个元素进去</span></span><br><span class="line">    <span class="built_in">console</span>.log(colors.concat(<span class="string">"green"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.从0号开始删除一个元素</span></span><br><span class="line">    colors.splice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.从2号元素开始删除一个元素,再插入两个新元素</span></span><br><span class="line">    colors.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"black"</span>,<span class="string">"white"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.根据元素获取下标索引</span></span><br><span class="line">    <span class="built_in">console</span>.log(colors.indexOf(<span class="string">"yellow"</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(colors.lastIndexOf(<span class="string">"yellow"</span>));<span class="comment">//不存在则返回-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.遍历数组</span></span><br><span class="line">    colors.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">        <span class="built_in">console</span>.log(index);</span><br><span class="line">        <span class="built_in">console</span>.log(array);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>关于第5个，每个参数都是啥呢？</p><p><img src="http://bloghello.oursnail.cn/js1-7.png" alt="image"></p><h2>十、数组的高级操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全部都要满足条件，有一个不满足就返回false</span></span><br><span class="line">    <span class="keyword">var</span> flag = num.every(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//每一个item都必须小于4才返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> num &lt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(flag);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只要有一个满足条件即可，也是返回true或者false</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.some(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">         <span class="comment">//只要有一个满足条件即可</span></span><br><span class="line">        <span class="keyword">return</span> item &lt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//过滤出符合条件的值</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每一个元素进行同样的操作</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item*<span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对元素进行统计</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> sum = num.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre,curr,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre+curr;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>前面的几个都比较好理解，最后两个可能比较抽象一点。其实这个在大数据中式比较常用的概念，比较典型的就是<code>MapReduce</code>这个组件，其实就是两个过程，一个是<code>map</code>一个是<code>reduce</code>，前者是对每个值进行相应的操作，后者是对这些处理完的值进行合并。从而达到一些数据统计的目的。比如这里，我对每个值简单乘以2，那么数组就变为<code>[2,8,4,12,16,6,2]</code>；下面一个实现的是求和功能，算出来是25.还可以进行很多的操作。</p><p>ok，后续其他的再学习，且记录到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js和其他的语言很像，很多的操作都是一样的，比如数值的运算符、循环的控制等，这些基础的语法知识就不再赘述了，本文着重是对比较重要的知识点进行总结，尤其是关于对象和数组这块的处理，因为对于前端来说，大多数数据不是对象(json)就是数组，所以掌握其中的一些api会事半功倍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>05-软件设计七大原则-接口隔离原则</title>
    <link href="http://yoursite.com/2019/03/19/design-pattern/05-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/03/19/design-pattern/05-软件设计七大原则-接口隔离原则/</id>
    <published>2019-03-19T11:06:56.699Z</published>
    <updated>2019-03-19T11:07:23.947Z</updated>
    
    <content type="html"><![CDATA[<p>本文来了解一下什么是接口隔离原则。</p><a id="more"></a><h2>定义</h2><ul><li>用多个专门的接口，而不适用单一的总接口，客户端不应该依赖它不需要的接口</li><li>一个类对一个类的依赖应该建立在最小的接口上</li><li>建立单一接口，不要建立庞大臃肿的接口</li><li>尽量细化接口，接口中的方法尽量少</li></ul><p>也就是说，我们提供接口的时候，只暴露需要的方法，而将不需要的方法隐藏起来。</p><h2>例子</h2><p>定义一个接口叫做动物行为接口，但是呢，由于没有细化，比如狗子，一旦实现这个接口，那就要实现所有的方法，包括它不会的飞翔。</p><p><img src="http://bloghello.oursnail.cn/uml5-1.png" alt="image"></p><p>将接口进行细化（这里要注意是要适当）。哪个要实现什么，就去实现，不需要的方法就可以不用去实现。</p><p>注意，接口隔离原则好像与上一章的单一职责原则有点像，这里说明一下区别：单一职责原则强调职责，一个class或者接口只负责一个职责，可以有很多的方法。但是接口隔离原则强调的是适当地设计接口，尽量地给不同的调用者适当的接口，不要设计的太臃肿，注重的是接口依赖的隔离。</p><p>这里强调适当，接口也不能太多，效果反而会适得其反。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来了解一下什么是接口隔离原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>04-软件设计七大原则-单一职责原则</title>
    <link href="http://yoursite.com/2019/03/19/design-pattern/04-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/03/19/design-pattern/04-软件设计七大原则-单一职责原则/</id>
    <published>2019-03-19T04:09:02.740Z</published>
    <updated>2019-03-19T04:09:28.971Z</updated>
    
    <content type="html"><![CDATA[<p>本文来了解一下什么是单一职责原则。</p><a id="more"></a><h2>定义</h2><p>假设一个类(class)中有两个职责，一个是指责A，一个是指责B，当我们修改A时，可能会导致B出现问题。就是说，职责A和职责B发生改变时都会影响这个class，从而使这个class可能发生变更。</p><p>解决方案：对于这两个指责分别建立class1和class2，使他们互相不影响。这个原则就是单一职责原则。</p><p>即一个类/接口/方法只负责一项职责。</p><p>好处：降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。</p><h2>例子</h2><p>单一职责原则是很好理解的，下面配以代码举一个小例子。</p><p>比如有一个类，描述的是鸟移动的模式，正常情况下鸟是飞的，但是如果传进来一只不会飞的鸟咋办呢，比如鸵鸟，这就需要判断一下了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdMoveMode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(birdName.equals(<span class="string">"鸵鸟"</span>))&#123;</span><br><span class="line">            System.out.println(birdName+<span class="string">"是跑的..."</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(birdName+<span class="string">"是飞的..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，最好是将这个类分离成两类，一个是会飞的，一个是走的：</p><p><img src="http://bloghello.oursnail.cn/um4-1.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyBird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        System.out.println(birdName+<span class="string">"是飞的..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WalkBird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        System.out.println(birdName+<span class="string">"是跑的..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于接口和方法也一样，接口里面的方法声明分开；方法重载来分开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来了解一下什么是单一职责原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题66-机器人的运动范围】</title>
    <link href="http://yoursite.com/2019/03/19/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9866-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/19/剑指offer/【面试题66-机器人的运动范围】/</id>
    <published>2019-03-19T03:55:00.344Z</published>
    <updated>2019-03-19T03:59:09.212Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十六题。</p><a id="more"></a><h2>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2>解题思路</h2><p>基本的思路是同上一题的，就不再赘述思路了。至此，《剑指offer》66题全部刷完，这是我第三遍刷了，很多答案进行了优化，总体上是把比较好的方案总结在这上面，而不是只贪图简单而采取暴力解法，那样达不到真正的目的。下面的刷题主要是围绕牛客网的《leetcode在线编程训练》进行练习，后面的刷题进度可能总体较慢。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//根据m行n列的方格，构造一个数组来标识是否已经判断过，已经判断过的话置为true，否则置为false</span></span><br><span class="line">        <span class="comment">//这里初始化默认是false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="comment">//下面开始走，边走边判断周围是否符合</span></span><br><span class="line">        <span class="comment">//judge(初始横坐标i，初始横坐标j，行数，列数，k值，标识是否走过)</span></span><br><span class="line">        <span class="keyword">return</span> judge(<span class="number">0</span>,<span class="number">0</span>,rows,cols,threshold,flag);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> threshold,<span class="keyword">boolean</span>[][] flag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界、flsg=true说明已经走过，就不要再走了、行坐标和列坐标的数位之和大于k也跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || flag[i][j]==<span class="keyword">true</span> || getK(i)+getK(j)&gt;threshold)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//机器人从[0,0]出发，必定是满足的，先置为true,所以要先加个1</span></span><br><span class="line">        flag[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//基于回溯的思想，就是到达一个格子后，不断地判断他的周围四个格子是否满足要求，递归判断下去，必定走遍所有格子</span></span><br><span class="line">        <span class="keyword">return</span> judge(i-<span class="number">1</span>,j,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i,j-<span class="number">1</span>,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i+<span class="number">1</span>,j,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i,j+<span class="number">1</span>,rows,cols,threshold,flag)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//计算数字每一位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getK</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum += num%<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>((num=num/<span class="number">10</span>) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题65-矩阵中的路径】</title>
    <link href="http://yoursite.com/2019/03/19/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9865-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/19/剑指offer/【面试题65-矩阵中的路径】/</id>
    <published>2019-03-19T03:27:52.563Z</published>
    <updated>2019-03-19T03:28:15.510Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十五题。</p><a id="more"></a><h2>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2>解题思路</h2><p>回溯</p><p>基本思想：</p><p>0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次</p><p>1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge</p><p>2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组</p><p>3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通</p><p>4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的</p><p>5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。</p><p>6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//标志位，初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                 <span class="comment">//循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法</span></span><br><span class="line">                 <span class="keyword">if</span>(judge(matrix,i,j,rows,cols,flag,str,<span class="number">0</span>))&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">boolean</span>[] flag,<span class="keyword">char</span>[] str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先根据i和j计算匹配的第一个元素转为一维数组的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == str.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//要走的第一个位置置为true，表示已经走过了</span></span><br><span class="line">        flag[index] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回溯，递归寻找，每次找到了就给k加一，找不到，还原</span></span><br><span class="line">        <span class="keyword">if</span>(judge(matrix,i-<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i+<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j-<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j+<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>)  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，说明这一条路不通，还原，再试其他的路径</span></span><br><span class="line">        flag[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>02-分布式文件系统HDFS(一)</title>
    <link href="http://yoursite.com/2019/03/18/hadoop/02-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FHDFS(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/03/18/hadoop/02-分布式文件系统HDFS(一)/</id>
    <published>2019-03-18T09:40:05.844Z</published>
    <updated>2019-03-18T09:45:18.254Z</updated>
    
    <content type="html"><![CDATA[<p>从本文开始了解HDFS的基本原理，为后续的实际操作打下理论基础。</p><a id="more"></a><h2>HDFS概述及设计目标</h2><p>如果让我们自己设计一个分布式文件系统，如何来设计呢？可能会简单地这样想：为了保障数据稳定性，那么就可以多存几份，放在不同的节点上，这样，即使某个节点挂了，相应的数据还可以从其他地方读到，如下图所示：</p><p><img src="http://bloghello.oursnail.cn/hadoop2-1.png" alt="image"></p><p>我们看到，这样设计的好处是即使第一个存放数据的节点挂了，也不会有什么影响，后面其他的节点上还是有它的副本的。但是这样设计的缺点也很明显：</p><ul><li>不管文件多大，都存储在一个节点上，在进行数据处理的时候很难进行并行处理，节点可能就成为网络瓶颈，很难进行大数据的处理</li><li>存储负载很难均衡，每个节点的利用率很低</li></ul><p>HDFS是如何设计的呢？这里简单先说一下，它是先将每个文件进行拆分，默认是128兆，这些拆分出来的block也是多副本进行存储。这样，数据分布会比较均匀，并且可以并行处理，提高并行计算能力。</p><h2>HDFS设计目标</h2><ul><li>能构建非常巨大的分布式文件系统</li><li>运行在普通廉价的硬件上</li><li>易扩展、为用户提供性能不错的文件存储服务</li></ul><h2>HDFS架构</h2><p>我们来官网看看HDFS的架构以及说明，其中有一段描述是：</p><blockquote><p>HDFS has a master/slave architecture. An HDFS cluster consists of a single NameNode, a master server that manages the file system namespace and regulates access to files by clients. In addition, there are a number of DataNodes, usually one per node in the cluster, which manage storage attached to the nodes that they run on. HDFS exposes a file system namespace and allows user data to be stored in files. Internally, a file is split into one or more blocks and these blocks are stored in a set of DataNodes. The NameNode executes file system namespace operations like opening, closing, and renaming files and directories. It also determines the mapping of blocks to DataNodes. The DataNodes are responsible for serving read and write requests from the file system’s clients. The DataNodes also perform block creation, deletion, and replication upon instruction from the NameNode.</p></blockquote><p>首先，<font color="red">HDFS是一个主从的架构</font>，包含一个<code>NameNode</code>，它主要负责的是管理<code>namespace</code>以及用户访问的文件；此外，还包含一些<code>DataNodes</code>，主要是负责数据管理。</p><p><font color="red">命名空间的作用：</font>HDFS暴露一个文件系统命名空间允许用户数据保存在这里。<code>NameNode</code>执行系统命名空间操作比如打开、关闭、重命名文件以及目录。这个命名空间还确定了<code>block</code>到<code>DataNode</code>的映射。</p><p><font color="red"><code>DataNode</code>和<code>block</code>：</font>在内部，一个文件是被切割为多个<code>block</code>的，这些<code>block</code>是存储在一系列的<code>DataNode</code>上的。这些<code>DataNode</code>负责提供读写请求，还可以根据<code>NameNode</code>的指令进行<code>block</code>的创建、删除以及复制。</p><p>下面总结一下两者的功能：</p><ul><li><code>NameNode</code>（Master/NN）:<ul><li>负责客户端请求的响应</li><li>负责元数据（文件的名称、副本系数、block存放的DN）的管理</li></ul></li><li><code>DataNode</code>（Slaves/DN）:<ul><li>存储用户的文件对应的数据块（block）</li><li>要定期向NN发送心跳信息，汇报本身及其所有的block信息，健康状况</li></ul></li></ul><p>官网贴了一张架构图：</p><p><img src="http://bloghello.oursnail.cn/hadoop2-2.png" alt="image"></p><p>这里感觉有很多东西要额外注意，暂时先学习到这里。</p><h2>HDFS副本机制</h2><blockquote><p>HDFS supports a traditional hierarchical file organization. A user or an application can create directories and store files inside these directories. The file system namespace hierarchy is similar to most other existing file systems; one can create and remove files, move a file from one directory to another, or rename a file.</p></blockquote><p>HDFS支持传统的分层文件组织。 用户或应用程序可以在这些目录中创建目录并存储文件。 文件系统命名空间层次结构与大多数其他现有文件系统类似; 可以创建和删除文件，将文件从一个目录移动到另一个目录，或重命名文件。</p><blockquote><p>The NameNode maintains the file system namespace. Any change to the file system namespace or its properties is recorded by the NameNode. An application can specify the number of replicas of a file that should be maintained by HDFS. The number of copies of a file is called the replication factor of that file. This information is stored by the NameNode.</p></blockquote><p><code>NameNode</code>维护文件系统名称空间。 <code>NameNode</code>记录对文件系统命名空间或其属性的任何更改。 应用程序可以指定应由HDFS维护的文件的副本数。 文件的副本数称为该文件的复制因子。 该信息由<code>NameNode</code>存储。</p><blockquote><p>HDFS is designed to reliably store very large files across machines in a large cluster. It stores each file as a sequence of blocks. The blocks of a file are replicated for fault tolerance. The block size and replication factor are configurable per file.</p></blockquote><p>HDFS旨在可靠地在集群上存储非常大的文件。 它将每个文件切割为为一系列的块进行存储。这些块被复制成多个副本以达到一定的容错性。 块大小和复制因子可根据文件进行配置。</p><blockquote><p>An application can specify the number of replicas of a file. The replication factor can be specified at file creation time and can be changed later. Files in HDFS are write-once (except for appends and truncates) and have strictly one writer at any time.</p></blockquote><p>应用程序可以指定文件的副本数。 复制因子可以在文件创建时指定，并可以在以后更改。 HDFS中的文件是一次写入的（除了追加和删除），并且在任何时候都有一个在写入，也就是说不支持并发写。</p><blockquote><p>The NameNode makes all decisions regarding replication of blocks. It periodically receives a Heartbeat and a Blockreport from each of the DataNodes in the cluster. Receipt of a Heartbeat implies that the DataNode is functioning properly. A Blockreport contains a list of all blocks on a DataNode.</p></blockquote><p>它定期从群集中的每个<code>DataNode</code>接收<code>Heartbeat</code>和<code>Blockreport</code>。 收到心跳意味着<code>DataNode</code>正常运行。 <code>Blockreport</code>包含<code>DataNode</code>上所有块的列表。</p><p><img src="http://bloghello.oursnail.cn/hadoop2-3.png" alt="image"></p><h2>HDFS副本存放策略</h2><p>为了提高可用性，大型Hadoop集群以机架的形式来组织的，同一个机架上不同节点间的网络状况比不同机架之间更为理想。</p><p>那么副本是如何存储呢？</p><p><img src="http://bloghello.oursnail.cn/hadoop2-4.png" alt="image"></p><p>如图所示，这里以默认的三个副本为例子说明，一般策略是这样的：同一个机架的同一台机器上先放一个副本，然后不同机架随机选择两个机器放副本。这样，一旦其中一个机架挂了，另一个机架还可以继续工作。</p><p>至此，关于HDFS基础的理论都已经说明完毕了，下面就要来实际操作一把了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本文开始了解HDFS的基本原理，为后续的实际操作打下理论基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>【面试题64-滑动窗口的最大值】</title>
    <link href="http://yoursite.com/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9864-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/18/剑指offer/【面试题64-滑动窗口的最大值】/</id>
    <published>2019-03-18T04:19:13.557Z</published>
    <updated>2019-03-18T04:19:31.932Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十四题。</p><a id="more"></a><h2>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2>解题思路</h2><p>比较简单的思路是每次用一个<code>ArrayList</code>来存放窗口内的数，进行排序，然后得到最大的添加进外面的<code>ArrayList</code>中，最后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num.length == <span class="number">0</span> || size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (ArrayList)result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=num.length-size;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+size;j++)&#123;</span><br><span class="line">                list.add(num[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            result.add(list.get(size-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ArrayList)result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历再排序，时间复杂度还是挺高的，遍历一遍是不可避免的，优化点在于如何以O(1)的时间复杂度拿到当前窗口的最大值。下面介绍一下优化方法。</p><p>以输入数字{2,3,4,2,6,2,5,1}为例一步分析。</p><p>数组的第一个数字是 2，把它存入队列中。第二个数字是3.由于它比前一个数字 2 大，因此 2不可能成为滑动窗口中的最大值。2 先从队列里删除，再把3存入到队列中。此时队列中只有一个数字 3。针对第三个数字 4 的步骤类似，最终在队列中只剩下一个数字 4。此时滑动窗口中已经有 3 个数字，而它的最大值 4 位于队列的头部。</p><p>接下来处理第四个数字 2。2 比队列中的数字 4 小。当 4 滑出窗口之后 2 还是有可能成为滑动窗口的最大值，因此把 2 存入队列的尾部。现在队列中有两个数字 4 和 2，其中最大值 4 仍然位于队列的头部。</p><p>下一个数字是 6。由于它比队列中已有的数字 4 和 2 都大，因此这时 4 和 2 已经不可能成为滑动窗口中的最大值。先把 4 和 2 从队列中删除，再把数字 6 存入队列。这个时候最大值 6 仍然位于队列的头部。</p><p>第六个数字是 2。由于它比队列中已有的数字 6 小，所以 2 也存入队列的尾部。此时队列中有两个数字，其中最大值 6 位于队列的头部。</p><p>接下来的数字是 5。在队列中已有的两个数字 6 和 2 里，2 小于 5，因此 2 不可能是一个滑动窗口的最大值，可以把它从队列的尾部删除。删除数字 2 之后，再把数字 5 存入队列。此时队列里剩下两个数字 6 和 5，其中位于队列头部的是最大值 6。</p><p>数组最后一个数字是 1，把 1 存入队列的尾部。注意到位于队列头部的数字 6 是数组的第 5 个数字，此时的滑动窗口已经不包括这个数字了，因此应该把数字 6 从队列删除。那么怎么知道滑动窗口是否包括一个数字？<strong>应该在队列里存入数字在数组里的下标，而不是数值</strong>。当一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字已经从滑动窗口中滑出，可以从队列中删除了。</p><p><img src="http://bloghello.oursnail.cn/offer64.jpg" alt="image"></p><p>框框里的都是下标。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存放当前窗口中最大值</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//队列的头部存放的是当前窗口最大值</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length &lt;= <span class="number">0</span> || size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="comment">//比如当前数据比队尾的数字大，说明当前这个数字最起码在从现在起到后面的过程中可能是最大值</span></span><br><span class="line">            <span class="comment">//而之前队尾的数字不可能最大了，所以要删除队尾元素。</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt; num[i])&#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            <span class="comment">//队头的元素是否超过窗口的范围</span></span><br><span class="line">            <span class="keyword">if</span>(queue.peekFirst() == i-size)&#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在包含了三个元素之后才开始记录，其中最大值就在队列的头部</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= size - <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(num[queue.peekFirst()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
