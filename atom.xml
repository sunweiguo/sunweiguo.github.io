<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-06T09:33:22.829Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【面试题11-二进制中1的个数】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9811-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题11-二进制中1的个数】/</id>
    <published>2019-03-06T09:27:02.941Z</published>
    <updated>2019-03-06T09:33:22.829Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十一题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2>解题思路</h2><p>这个题目求一个数的二进制形式的1的个数，比较简单的思路是：每次与1进行&amp;操作，看是不是1，是则奇数，无论如何都后移一位再判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果输入时负数会陷入死循环，因为负数右移时，在最高位补得是1。那么就死循环了。</p><p>比较好的解法是：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。</p><p>循环是判断n是不是为0了，只要不为0，就循环。一进循环说明n是有至少一个1的，二话不说，先count++;</p><p>比如：一个二进制数1100，减去1之后是1011。</p><p>两者一&amp;则变为1000，原来最右边的1就变成了0.</p><p>由于n不为0，则再次进入循环：</p><p>1000减去1是0111，两者一&amp;就是0000.退出循环。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题10-矩形覆盖】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9810-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题10-矩形覆盖】/</id>
    <published>2019-03-06T08:15:38.532Z</published>
    <updated>2019-03-06T08:16:13.778Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十题。</p><a id="more"></a><h2>题目描述</h2><p>我们可以用 <code>2*1</code> 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个 <code>2*1</code> 的小矩形无重叠地覆盖一个 <code>2*n</code> 的大矩形，总共有多少种方法？</p><h2>解题思路</h2><p><img src="http://bloghello.oursnail.cn/offer10-1.png" alt="image"></p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题9-变态跳台阶】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%989-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题9-变态跳台阶】/</id>
    <published>2019-03-06T08:05:21.845Z</published>
    <updated>2019-03-06T08:12:08.793Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第九题。</p><a id="more"></a><h2>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2>解题思路</h2><p>这就是上一题的延申，上一题要么跳一个要么跳两个，这一题是从1个到n个，那么同样地，找出f(n)与f(n-1)的关系就好了。</p><ul><li>f(1) = 1：一个台阶只有一种跳法，就是跳一个</li><li>f(2) = f(2-1) + f(2-2)：两个台阶有两种跳法，跳一个或者跳两个</li><li>①f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) = f(0) + f(1) + f(2) + … + f(n-2) + f(n-1)：n个台阶就有n个跳法</li></ul><p>根据上一个式子，我们可以得出：</p><p>②f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + … + f(n-2)：n-1个台阶有n-1个跳法</p><p>根据①②可以得出：</p><p>f(n) = f(n-1) + f(n-1) =2*f(n-1)</p><p>这个问题就解决了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题8-跳台阶】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%988-%E8%B7%B3%E5%8F%B0%E9%98%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题8-跳台阶】/</id>
    <published>2019-03-06T08:03:07.323Z</published>
    <updated>2019-03-06T08:03:56.808Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第八题。</p><a id="more"></a><h2>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2>解题思路</h2><p>对于本题,前提只有 一次 1阶或者2阶的跳法。</p><ul><li>如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);</li><li>假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)</li><li>可以得出总跳法为: f(n) = f(n-1) + f(n-2)</li><li>然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</li></ul><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题7-斐波那契数列】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%987-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题7-斐波那契数列】/</id>
    <published>2019-03-06T08:01:44.875Z</published>
    <updated>2019-03-06T08:02:57.584Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第七题。</p><a id="more"></a><h2>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><h2>解题思路</h2><p>最简单的解法就是递归了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是递归存在重复子问题，所以时间复杂度较高，但是这里竟然通过了？斐波那契数列我认为最优的一个解法是用两个变量存储。</p><p>这题目用动态规划来解其实是不好的，至少逆向思考问题本身就是比较问难的，我觉得这种记忆化搜索对于这种问题是最好理解并且解是比较优的解。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题6-旋转数组的最小数字】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%986-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题6-旋转数组的最小数字】/</id>
    <published>2019-03-06T07:58:30.451Z</published>
    <updated>2019-03-06T07:58:55.710Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六题。</p><a id="more"></a><h2>题目描述</h2><p>一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2>解题思路</h2><p>当我们看到关键字“非减排序的数组&quot;的时候，我们要想到这题目的最优解可能是用二分查找法。</p><p>我们知道，二分查找法适用于有序数组的查找，这里对这个非减排序的数组进行了旋转，那么旋转之后这个数组的一个明显特征是：前面的一段序列必然大于等于后面的一段序列。</p><p>这题目可以认为是二分查找法的变种题目，下面我们来具体分析一下编程思路。</p><p>我们可以找一个基准数，比如数组的最优一个元素<code>target</code>，我们比较中间元素比如叫做<code>arr[mid]</code>和这个<code>target</code>的大小：</p><ul><li>如果<code>arr[mid]</code>&gt;<code>target</code>:那么表明截取的时候，后面比前面长，那么最小值必然存在于索引mid的后面</li><li>如果<code>arr[mid]</code>&lt;<code>target</code>:那么表明截取的时候，前面比后面长，那么最小值必然存在于索引mid的前面(此时应该包含mid对应的元素，因为极限情况比如只有两个元素，那么反转之后前面可能比后面大，如果不包含这个mid就错了)</li><li>如果<code>arr[mid]</code>=<code>target</code>:这个时候元素组比如为[0,1,1,1,1]，那么旋转之后可能为 [1,0,1,1,1] 或者[1,1,1,0,1]，不好判断，一个一个试。</li></ul><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[end])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[end])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题5-用两个栈实现队列】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%985-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题5-用两个栈实现队列】/</id>
    <published>2019-03-06T07:52:05.206Z</published>
    <updated>2019-03-06T07:57:49.667Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五题。</p><a id="more"></a><h2>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为int类型。</p><h2>解题思路</h2><p>队列是先进先出，栈是先进后出，如何用两个栈来实现这种先进先出呢？</p><p>其实很简单，我们假设用<code>stack1</code>专门来装元素，那么直接<code>stack1.pop</code>肯定是不行的，这个时候<code>stack2</code>就要发挥作用了。</p><p>我们的规则是：只要<code>stack2</code>中有元素就<code>pop</code>，如果<code>stack2</code>为空，则将<code>stack1</code>中所有元素倒进<code>satck2</code>中，就是说，新元素只进<code>stack1</code>，元素出来只从<code>stack2</code>出来。</p><p>这样子，就能保证每次从<code>stack2</code>中<code>pop</code>出来的元素就是最老的元素了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//负责装元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//负责出元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主要思想是：stack2有元素就pop，没有元素就将stack1中所有元素倒进来再pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> node = stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"no valid element"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题4-重建二叉树】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%984-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题4-重建二叉树】/</id>
    <published>2019-03-06T06:35:16.987Z</published>
    <updated>2019-03-06T07:48:48.341Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四题。</p><a id="more"></a><h2>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2>解题思路</h2><p>因为是树的结构，一般都是用递归来实现。</p><p>用数学归纳法的思想就是，假设最后一步，就是root的左右子树都已经重建好了，那么我只要考虑将root的左右子树安上去即可。</p><p>根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。</p><p>根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。</p><p>正如上面所说，只需要将确定的左右子树安到root上即可。递归要注意出口，假设最后只有一个元素了，那么就要返回。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组长度为0的时候要处理</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组长度仅为1的时候就要处理</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//我们先找到root所在的位置，确定好前序和中序中左子树和右子树序列的范围</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rootVal == in[i])&#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归，假设root的左右子树都已经构建完毕，那么只要将左右子树安到root左右即可</span></span><br><span class="line">        <span class="comment">//这里注意Arrays.copyOfRange(int[],start,end)是[)的区间</span></span><br><span class="line">        root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,rootIndex+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,rootIndex));</span><br><span class="line">        root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,rootIndex+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,rootIndex+<span class="number">1</span>,in.length));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题3-从尾到头打印链表】</title>
    <link href="http://yoursite.com/2019/03/05/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%983-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/05/剑指offer/【面试题3-从尾到头打印链表】/</id>
    <published>2019-03-05T13:57:55.460Z</published>
    <updated>2019-03-05T13:58:12.374Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第三题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><h2>解题思路</h2><p>这一题给一个单向链表，然后你反向打印出来。其实最容易想到的就是两个方案，一个是将这个链表进行反置，然后依次打印即可。一个就是通过栈这个数据结构，先进后出，那么也可以反向打印出来。由于用栈比较简单，但是链表的反置稍微难一点并且重要，所以本文用反置链表的方式解决。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = listNode;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pre就是反向链表的头结点</span></span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(pre.val);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题2-替换空格】</title>
    <link href="http://yoursite.com/2019/03/05/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%982-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/05/剑指offer/【面试题2-替换空格】/</id>
    <published>2019-03-05T13:49:24.362Z</published>
    <updated>2019-03-05T14:04:17.044Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第二题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h2>解题思路</h2><p>由于<code>java</code>给的参数是<code>StringBuilder</code>，这在一定程度上给我们一定的提示，我们利用<code>StringBuilder</code>的<code>charAt(i)</code>和<code>setCharAt(i,xxx)</code>这两个函数可以轻易实现获取索引处元素以及对这个索引处元素进行赋值。</p><p>由于是将空格替换成<code>%20</code>，空格本身就算一个地方，所以我需要将原来的字符串进行扩充。扩充的长度也非常好算，就是原来的长度+空格个数*2即可。然后遍历原字符串，不是空格的就一个个搬到新长度对应的位置上，否则就塞入<code>%20</code>三个字符。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取空格数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.拿到原来字符串的长度，计算新的字符串长度</span></span><br><span class="line">        <span class="comment">//并且我是从尾巴开始往前遍历，所以我需要获取起始的两个索引值</span></span><br><span class="line">        <span class="keyword">int</span> oldLength = str.length();</span><br><span class="line">        <span class="keyword">int</span> oldIndex = oldLength - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> newLength = oldLength + <span class="number">2</span>*count;</span><br><span class="line">        <span class="keyword">int</span> newIndex = newLength - <span class="number">1</span>;</span><br><span class="line">        str.setLength(newLength);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.从后往前遍历原字符串，赋值给“新”的字符串，不过是原地进行的，没有开辟新的空间</span></span><br><span class="line">        <span class="keyword">for</span>(;oldIndex &gt;= <span class="number">0</span> &amp;&amp; oldIndex &lt; newIndex;oldIndex--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(oldIndex) == <span class="string">' '</span>)&#123;</span><br><span class="line">                str.setCharAt(newIndex--,<span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(newIndex--,<span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(newIndex--,<span class="string">'%'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str.setCharAt(newIndex--,str.charAt(oldIndex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题1-二维数组中的查找】</title>
    <link href="http://yoursite.com/2019/03/05/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%981-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/05/剑指offer/【面试题1-二维数组中的查找】/</id>
    <published>2019-03-05T12:58:02.150Z</published>
    <updated>2019-03-05T14:04:26.172Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第一题。</p><a id="more"></a><h2>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2>解题思路</h2><p>考察数组的特性，我们如果从右上角的元素开始找，比如我们要找4，比9小，那么直接删除列即可，因为这个列上的元素看到都大于9；那么我们这时锁定8，发现还是比他小，再删除一列；这时变成了2，发现4比他大，则删除行；这个是后就锁定了4，就是我们想要的答案。</p><p>规律：首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；</p><p>如果该数字大于要查找的数字，剔除这个数字所在的列：如果该数字小于要查找的数字，剔除这个数字所在的行。</p><p>也就是说如果要查找的数字不在数组的右上角，则每－次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;=array.length-<span class="number">1</span> &amp;&amp; j&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>基础算法14-二叉搜索树</title>
    <link href="http://yoursite.com/2019/03/04/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9514-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/03/04/algorithms-basic/基础算法14-二叉搜索树/</id>
    <published>2019-03-04T13:55:21.777Z</published>
    <updated>2019-03-04T13:58:22.719Z</updated>
    
    <content type="html"><![CDATA[<p>本文比较轻松简单，就是动态生成一个二叉搜索而已。</p><a id="more"></a><h2>动态构建二叉搜索树</h2><p>首先明确二叉搜索树基本性质，就是根节点的值一定比左孩子的值要大，一定比右孩子的值要小。(为了简单起见，假定元素都是不重复的)</p><p>如何动态生成一颗二叉搜索树呢？思路其实是很简单的，就是判断与根节点的左孩子和右孩子分别比较大小，一直到末梢就可以插入元素了。</p><p>先准备一个<code>TreeNode</code>：</p><p><img src="http://bloghello.oursnail.cn/suanfa14-1.png" alt="image"></p><p>下面就是对节点进行操作了：</p><p><img src="http://bloghello.oursnail.cn/suanfa14-2.png" alt="image"></p><p>我们来进行前序遍历和中序遍历以及后序遍历看看生成的二叉搜索树是否正确：</p><p><img src="http://bloghello.oursnail.cn/suanfa14-3.png" alt="image"></p><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前序遍历为：  6 3 2 1 5 8 7 </span><br><span class="line">中序遍历为：  1 2 3 5 6 7 8 </span><br><span class="line">后序遍历为：  1 2 5 3 7 8 6</span><br></pre></td></tr></table></figure><p>经过验证发现完全是正确的。并且我们发现，中序遍历后是一个有序的序列，说明二叉搜索树中序遍历之后有序。</p><p>二叉树天生递归，关于它的很多题目用递归就可以解决，后序会有一个单独的文章专门来刷关于二叉树的题目。这里先不赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文比较轻松简单，就是动态生成一个二叉搜索而已。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法13-动态规划入门</title>
    <link href="http://yoursite.com/2019/03/04/algorithms-basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%9513-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/03/04/algorithms-basic/基础算法13-动态规划入门/</id>
    <published>2019-03-04T13:54:58.069Z</published>
    <updated>2019-03-04T13:55:10.377Z</updated>
    
    <content type="html"><![CDATA[<p>在求解某个序列的最优解的时候，经常会用到动态规划来解决。动态规划的核心是找出一个关系式，并且借助于选或者不选找出两个迭代的路径进行比较，最终遍历整个序列之后也就得到了选或者不选中的最优解，也就是整个序列的最优解。由于还是比较复杂的，所以是对动态规划学习的一个入门之作。</p><a id="more"></a><h2>什么是动态规划</h2><blockquote><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。引自百度百科</p></blockquote><p>我们以解决一个小例子入手。</p><h2>例子</h2><p><img src="http://bloghello.oursnail.cn/suanfa13-1.png" alt="image"></p><p>如图所示，横轴是时间，上面是一段一段的长方形，将其想象为工作时间，比如第一块，是1点到4点的工作，收益为5，第二块是3点到5点的工作，收益是1.一个人不可能同时做两份工作，即时间不能重叠，请问这个人如何安排做哪几个工作最终收益是最大的？</p><p>这道题目如何思考呢？正常的思维可能是：假设我做第一个工作，那么我做完之后只能做第四个工作才不冲突，做完第四个再做第8个工作，但是这个不一定是最优解，那么我还需要判断各种情况，比如我第一个工作做完了可能会去做第6个工作，好像很混乱，无从下手了。</p><p>各位，现在转换一下思维，我们不从第一个开始考虑，我们从最后一个开始考虑。怎么考虑呢？</p><p>对于第八份工作而言，我有两个选择，一个是做，一个是不做。不做就很简单，我再从第七份工作开始考虑。做的话，那么我下面就要考虑前面可以做的最好的工作了，我们发现第五份工作以及之前的工作都可以做做，那么就是说对前五个工作找到一个收益最大的方案就即刻。我们用OPT(i)函数表示第i个参数之前最优解的话，那么对于上述可以表示为：</p><p><img src="http://bloghello.oursnail.cn/suanfa13-2.png" alt="image"></p><p>其实根据这个情况，我们递推出一个通用一点的关系式：</p><p><img src="http://bloghello.oursnail.cn/suanfa13-3.png" alt="image"></p><p>对于这个<code>prev(i)</code>表示在选择当前i元素之后，可以考虑的最优的子集的第一个元素（这个元素是反着找的）。比如选了8，那么我前面能考虑的只能是1，2，3，4，5这几块，因为6和7都不能选的。即使3或者4可能不满足条件，但是我们只要找到最接近的5即可。</p><p><img src="http://bloghello.oursnail.cn/suanfa13-4.png" alt="image"></p><p>我们会发现这种问题是存在重叠子问题的，这个就是问题的关键，一个问题分解为若干子问题，为了避免重复的计算，是需要将这些子问题存储起来的，下次用到的时候直接去内存中查出来即可。</p><p>这个问题根据上面的表达式就可以求出最优的一个情况。对于这个例子我们只需要理解它的解体思想即可，下面我们真正实践一个题目。</p><h2>小偷偷东西</h2><p><img src="http://bloghello.oursnail.cn/suanfa13-5.png" alt="image"></p><p>这个问题大概就是说，一个小偷偷东西，但是它不能偷相邻的两家人的东西，这样会被抓住，只能隔着偷，请问，怎么偷才能利益最大化，因为每个房子的价值不一样，假如有两家，一家有100块，一家有一个亿，你选择不好，选了100的那家，那就亏大发了，一个亿的下次再来偷吧。</p><p>按照上面的思路，我们来思考这个问题，我们从最后一家开始考虑，选择就两个，偷或者不偷，偷了会怎么样，不偷会怎么样，其实关系式跟上面是差不多的，我偷了的话，比如偷的是n，那么下次只能从n-2开始考虑它的最大价值方案。不偷的话，就是考虑n-1的最大价值方案。</p><p>最简单的实现就是递归来实现，主要是要考虑一下函数的出口条件，即偷到第一家了是什么样，以及第一家之前没有人家了怎么办。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rob(nums,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> A = rob(nums,n-<span class="number">2</span>) + nums[n];</span><br><span class="line">            <span class="keyword">int</span> B = rob(nums,n-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> A &gt; B ? A : B;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很可惜，虽然逻辑上正确，但是由于是递归，在数据规模大一点之后，就不行了，因为我们前面也说到，存在大量的重叠子问题，问题多一个输入，那么计算的规模就要乘上2，所以时间复杂度为2^n这个级别。所以此方案放在leetcode上会超时，下面就是想办法把他改成非递归的版本。</p><p>前面提到，计算出来的子问题完全可以存在一个地方，下次要用直接取。OK，用非递归版本的数组版本实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        tmp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        tmp[<span class="number">1</span>] = nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? nums[<span class="number">0</span>] : nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> A = tmp[i-<span class="number">2</span>] + nums[i];</span><br><span class="line">            <span class="keyword">int</span> B = tmp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> max = A &gt; B ? A : B;</span><br><span class="line">            tmp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主体还是上面提到的那个关系，只是我们将子问题的结果放在了一个临时数组中。临时数组中存放的都是子问题的最优解。比如tmp[1]里面存放的就是前两个元素中最大值，即最优解。当计算前三个数中最优解的时候，我只要做一个选择，即要不要选择nums[2]这个元素，选择的话，那么我就从tmp[2-2]中得到最优解，加起来就是当前最优解，不选择的话，就从tmp[2-1]中选择最优解。依次下去，tmp中最后一个值就是整个序列中组合的最优解了。</p><p>这里注意一下，这里其实是记忆化搜索的思想来实现的，我们可以注意到，其实是自顶向下来看的，从第一个数字来一直推到最后。然而动态规划的思想是从底向上的，参见第一个递归版本的实现。我们先考虑的是最终的n，而不是考虑从0开始。所以在设计思想上是有所区别的，但是又是非常类似，有的人将他们归位一类，我想，它们在大多数场景下可以互换的化，可以认为都是广义上的DP算法吧，因为DP毕竟只是一种思想，正过来实现反过来实现也未尝不可。</p><p>我们用一个数组来存放子问题的最优解，大大降低了时间复杂度，leetcode上也顺利通过。其实这个是一种记忆化搜索的思想，上面这个用了一个数组，其实完全没有必要用数组，用两个变量即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> b = nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>] ? nums[<span class="number">0</span>] : nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> A = a + nums[i];</span><br><span class="line">            <span class="keyword">int</span> B = b;</span><br><span class="line">            <span class="keyword">int</span> max = A &gt; B ? A : B;</span><br><span class="line">            a = b;</span><br><span class="line">            b = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度不变，空间上占用的更少了。下面我们还是从底向上的思想来解决一下这个问题吧。所以我们还是从最后一个元素开始思考，从后往前找，一直找到第一个结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        tmp[n-<span class="number">1</span>] = nums[n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                tmp[i] = Math.max(tmp[i],nums[j] + (j+<span class="number">2</span>&lt;n?tmp[j+<span class="number">2</span>]:<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下来的效果是要比上面的记忆化搜索效果差的，但是都通过了。</p><p>⭐墙裂推荐：</p><ul><li><a href="https://www.bilibili.com/video/av16544031" target="_blank" rel="noopener">动态规划 (第1讲)</a></li><li><a href="https://www.bilibili.com/video/av18512769/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">动态规划 (第2讲)</a></li></ul><p>部分图片截取于他的视频。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在求解某个序列的最优解的时候，经常会用到动态规划来解决。动态规划的核心是找出一个关系式，并且借助于选或者不选找出两个迭代的路径进行比较，最终遍历整个序列之后也就得到了选或者不选中的最优解，也就是整个序列的最优解。由于还是比较复杂的，所以是对动态规划学习的一个入门之作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础算法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTML标签学习</title>
    <link href="http://yoursite.com/2019/03/04/front/HTML%E6%A0%87%E7%AD%BE%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/04/front/HTML标签学习/</id>
    <published>2019-03-04T11:32:14.142Z</published>
    <updated>2019-03-04T11:33:04.469Z</updated>
    
    <content type="html"><![CDATA[<p>学习前端的第一步是学习html的基本标签，比较重要的标签并不多，多用用就好了。下面一一过一下，复习一下即可。</p><a id="more"></a><h2>一、文本标签</h2><ul><li>p标签</li></ul><p><code>&lt;p&gt;xxxx&lt;/p&gt;</code>对文本可以进行段落划分。</p><ul><li>斜体</li></ul><p><code>&lt;i&gt;xxx&lt;/i&gt;</code>或者<code>&lt;em&gt;xxx&lt;/em&gt;</code></p><ul><li>删除线</li></ul><p><code>&lt;s&gt;xxx&lt;/s&gt;</code>或者<code>&lt;del&gt;xxx&lt;/del&gt;</code></p><ul><li>加粗</li></ul><p><code>&lt;strong&gt;xxx&lt;/strong&gt;</code>或者<code>&lt;b&gt;xxx&lt;/b&gt;</code></p><ul><li>下划线</li></ul><p><code>&lt;u&gt;xxx&lt;/u&gt;</code>或者<code>&lt;ins&gt;xxx&lt;/ins&gt;</code></p><h2>二、图片</h2><p>没什么好说的：<code>&lt;img src=&quot;xxx&quot; alt=&quot;图裂了&quot; title=&quot;本图片提示信息&quot;&gt;</code></p><h2>三、超链接</h2><ul><li>原地跳转新页面：<code>&lt;a href=&quot;http://www.google.com&quot; target=&quot;_self&quot;&gt;超链接&lt;/a&gt;</code></li><li>新开页面跳转：<code>&lt;a href=&quot;http://www.google.com&quot; target=&quot;_blank&quot;&gt;超链接&lt;/a&gt;</code></li></ul><p>这里顺便说一下锚点定位。就是点一下页面移动到指定的地方开始显示。</p><p><code>&lt;a href=&quot;#hello&quot;&gt;移动到hello处&lt;/a&gt;</code></p><p><code>&lt;h1 id=&quot;hello&quot;&gt;我是hello&lt;/h1&gt;</code></p><p>点一下就移动到对应的地方了。</p><h2>四、列表</h2><ul><li>无序列表：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>有序列表：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所谓的顺序其实只是后者显示了123而已，并不是说对内容进行排序。</p><ul><li>自定义列表</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>3<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>4<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>5<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>6<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>⭐在<code>webstorm</code>中，我们这样一个一个打有点累，其实是有快捷键的。比如我写一个有5个<code>&lt;li&gt;</code>的<code>&lt;ul&gt;</code>，快捷写法是<code>ul&gt;li*5</code>再按<code>tab</code>即可。</p><p>比如我要五组这样的呢？<code>(ul&gt;li*5)*5</code>+<code>tab</code>即可。</p><h2>五、表格</h2><p>这个也没什么好说的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>111<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>222<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>333<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>444<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>666<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以有表头用<code>&lt;th&gt;</code>即可。下面注意一下，如果我们想要<code>111</code>一下占两列咋办呢？就是跟<code>excel</code>中差不多的单元格合并功能。</p><ul><li>占两列：<code>&lt;td colspan=&quot;2&quot;&gt;111&lt;/td&gt;</code></li><li>占两行：<code>&lt;td rowspan=&quot;2&quot;&gt;111&lt;/td&gt;</code></li></ul><h2>六、表单</h2><ul><li>输入框：<code>&lt;input type=&quot;text&quot;&gt;</code></li></ul><p>往往下面这个是成对出现的：效果是点击<code>label</code>的提示语鼠标的焦点就会进入输入框了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"text"</span>&gt;</span>请输入：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>按钮：<code>&lt;input type=&quot;button&quot; value=&quot;我是按钮&quot;&gt;</code></li></ul><ul><li>勾选框：<code>&lt;input type=&quot;checkbox&quot;&gt;</code></li></ul><ul><li>单选按钮：<code>&lt;input type=&quot;radio&quot;&gt;</code></li></ul><p>比如男女是一组<code>radio</code>，如何只让用户选择一个呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"male"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>文本输入框：<code>&lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;</code></p></li><li><p>下拉框：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2>七、name属性</h2><p>表单提交，比如登陆功能，我们需要将输入的用户名和密码发送到服务器校验。那么后端如何接收这个参数呢？其实就是根据<code>name</code>来识别的，后端受到的数据形如<code>username:xxx</code>，那么后端就可以根据<code>username</code>这个<code>name</code>属性接受到xxx这个内容。</p><p>id只是标识这个标签，要唯一。两者不要混淆。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"服务器接口地址"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好了，关键的标签就全部说完了。其实猛然回首才发现，这不正是我们初学html的时候一个一个学习的标签吗?真是时光荏苒呐！下面就要进军CSS了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习前端的第一步是学习html的基本标签，比较重要的标签并不多，多用用就好了。下面一一过一下，复习一下即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>注解-属性赋值和自动装配</title>
    <link href="http://yoursite.com/2019/03/03/spring/%E6%B3%A8%E8%A7%A3-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    <id>http://yoursite.com/2019/03/03/spring/注解-属性赋值和自动装配/</id>
    <published>2019-03-03T04:47:58.720Z</published>
    <updated>2019-03-03T04:51:45.925Z</updated>
    
    <content type="html"><![CDATA[<p>对于属性的赋值以及如何自动装配是我们在实际编程中经常要实现的功能，spring为我们提供了应有尽有的方式来实现，特别地方便，用好spring还是先用好spring给我们提供的注解开始。理解它们的不同之处也是面试中常问的点。</p><a id="more"></a><h2>1. @Value赋值</h2><p>给一个<code>Person</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册到容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动查看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig3.class);</span><br><span class="line">    System.out.println(<span class="string">"容器已经启动成功..."</span>);</span><br><span class="line">    Person person = applicationContext.getBean(Person.class);</span><br><span class="line">    System.out.println(person);<span class="comment">//Person(name=null, age=null)</span></span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在以前写配置文件的时候，我们可以在xml中给属性注入值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.swg.bean.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么现在的注解可以实现这样的功能吗？</p><ul><li>@Value</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><ul><li>@SpEL表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;20-6&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure><h2>2. @PropertySource加载外部配置文件</h2><h4>${}注入属性文件的值</h4><ul><li>新建一个配置文件<code>db.properties</code>，在里面写:</li></ul><blockquote><p>person.nickname = hello</p></blockquote><ul><li>首先在配置类中声明要引入的配置文件：</li></ul><blockquote><p>@PropertySource(value = “classpath:/db.properties”)</p></blockquote><ul><li>然后再引入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;person.nickname&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String nickname;</span><br></pre></td></tr></table></figure><ul><li>以前在用xml的时候，是这样引入这个值的：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//然后下面就引入这个属性文件的值</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nickname"</span> <span class="attr">value</span>=<span class="string">"$&#123;person.nickname&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><p>自动装配：spring利用依赖注入DI，完成对IOC容器中各个组件依赖关系赋值</p><h2>3. @Autowired &amp; @Qualifier &amp; @Primary</h2><p><code>@Autowired</code>：默认是按照类型去容器中找相应的组件。找到就赋值。</p><blockquote><p>applicationContext.getBean(Person.class)</p></blockquote><p>如果找到多个相同类型的组件，再将属性名(默认是小写字母开头的id或者用<code>@Bean(&quot;xxx&quot;)</code>中的xxx为属性名)作为组件的id去容器中查找。</p><blockquote><p>applicationContext.getBean(“person”)</p></blockquote><p>所以，最好名字不一样。</p><p>如果有多个相同类型的组件，可以用<code>@Qualifier(&quot;xxx&quot;)</code>可以指定装配的id，而不是属性名。</p><p><strong>@Primary：让spring自动装配的时候，默认使用首选的bean；但是如果@Qualifier明确指定了要装配哪一个，还是以@Qualifier为准。</strong></p><p>默认，如果容器中没有这个组件，那么@Autowired就会报错。那么可不可以有就装配，没有就算了呢？</p><blockquote><p>@Autowired（required=false）</p></blockquote><h2>4. @Resource &amp; @Inject</h2><p>这两个都是java规范的注解。</p><ul><li>@Resource–JSR250</li></ul><p>默认是按照组件名称进行装配的。没有能支持<code>@Primary</code>和<code>@Autowired（required=false）</code>这个功能。</p><ul><li>@Inject–JSR330</li></ul><p>还需要一个依赖：<code>javax.inject</code></p><p>和<code>@Autowired</code>差不多，但是比<code>@Autowired</code>稍弱，虽然支持<code>@Primary</code>，但是没有<code>required=false</code></p><p><code>@Autowired</code>是<code>spring</code>定义的，后两者都是java的规范。</p><p>那么这些自动装配功能的注解是如何实现的呢？原来是<code>AutowiredAnnotationBeanPostProcessor</code>来实现的。</p><h2>5. 方法、构造器位置的自动装配</h2><p><code>@Autowired</code>能标注的位置：构造器、参数、方法、属性</p><ul><li>写在属性上面：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Car car;</span><br></pre></td></tr></table></figure><ul><li>写在方法上：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spring容器创建当前对象，就会调用方法，完成赋值；</span></span><br><span class="line"><span class="comment">//方法使用的参数，自定义类型的值从ioc容器中获取，就是这里的参数car。</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function">publlic <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写在构造器上：</li></ul><p>因为注册到ioc容器的组件，容器启动的时候回调用无参构造器创建对象，然后在进行初始化赋值等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放在有参构造器上面，这样容器启动的时候就会调用这个有参构造器</span></span><br><span class="line"><span class="comment">//构造器中要用的组件car，也是从容器中获取</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function">publlic <span class="title">Boss</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果当前类只有一个有参构造器，@Autowired是可以省略的。</strong></p><ul><li>写在参数前面：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//car都是从容器中获取的</span></span><br><span class="line"><span class="function">publlic <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(@Autowired Car car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>6. Aware注入Spring底层组件及原理</h2><p>自定义组件想使用spring容器底层的一些组件，比如<code>applicationContext</code>或者<code>beanFactory</code>等。只需要实现<code>xxxAware</code>接口即可。在创建对象的时候，会调用接口规定的方法注入相关组件。</p><p>比如<code>ApplicationContextAware</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以将它传进来的<code>ApplicationContext</code>保存一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snail</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>7. @Profile环境搭建和根据环境注册bean</h2><p>spring为我们提供的可用根据当前环境，动态地激活和切换一系列组件的功能。</p><p>开发环境、测试环境、生产环境，可能用不同的数据源，那么不想改动很多代码的话，就可以用<code>@Profile</code>切换。</p><p><code>@Profile</code>：指定组件在哪个环境的情况下才能被注册到容器中，<strong>不指定，在任何环境下都能注册这个组件</strong>。</p><p><strong>加了@Profile的@Bean，只有这个环境被激活的时候才能注册到容器中，但是有一个默认注册的：@Profile(“default”)</strong></p><p>那么如何指定某个环境注册到spring容器中呢？</p><ul><li>第一种方式：使用命令行动态参数</li></ul><blockquote><p>VM arguments: -Dspring.profiles.active=test</p></blockquote><ul><li>第二种方式：代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,创建一个applicationContext</span></span><br><span class="line"><span class="comment">//2,设置需要激活的环境</span></span><br><span class="line">applicationContext.getEnvironment().setActiveProfiles(<span class="string">"test"</span>,<span class="string">"dev"</span>);</span><br><span class="line"><span class="comment">//3,注册配置类</span></span><br><span class="line">applicationContext.register(MainConfigOfProfile.class);</span><br><span class="line"><span class="comment">//4,启动刷新容器</span></span><br><span class="line">applicationContext.refresh();</span><br></pre></td></tr></table></figure><h2>8. 总结</h2><ol><li><code>@Value</code>赋值</li><li><code>@PropertySource</code>加载外部配置文件</li><li><code>@Autowired</code> &amp; <code>@Qualifier</code> &amp; <code>@Primary</code> &amp; <code>@Resource</code> &amp; <code>@Inject</code>以及<code>@Autowired</code>在方法、构造器、参数位置的自动装配</li><li>通过实现<code>Aware</code>接口可以注入<code>Spring</code>底层的一些组件</li><li><code>@Profile</code>环境搭建和根据环境注册<code>bean</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于属性的赋值以及如何自动装配是我们在实际编程中经常要实现的功能，spring为我们提供了应有尽有的方式来实现，特别地方便，用好spring还是先用好spring给我们提供的注解开始。理解它们的不同之处也是面试中常问的点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>注解-生命周期</title>
    <link href="http://yoursite.com/2019/03/03/spring/%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/03/03/spring/注解-生命周期/</id>
    <published>2019-03-03T04:21:05.538Z</published>
    <updated>2019-03-03T04:54:26.639Z</updated>
    
    <content type="html"><![CDATA[<p>我们在之前说到过bean的生命周期，其中提到了很多初始化方法，搞得我们晕头晕脑，本文就是来解决这个问题，对bean生命周期中重要的几个初始化和销毁接口或注解进行消息阐述，使得对bean的生命周期理解更加轻松。</p><a id="more"></a><h2>1. @Bean指定初始化和销毁方法</h2><p>bean生命周期：bean创建----初始化----销毁的过程</p><p>容器管理bean的生命周期，我们可以自定义初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法。</p><ul><li>指定初始化和销毁方法</li></ul><p>用xml配置的方式，可以指定<code>init-method</code>和<code>destory-method</code>；</p><p>那么注解如何做到自定义的初始化和销毁方法呢？</p><p>我们先来创建一个Dog的类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog constructor...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dog destory..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个配置类来注册这个Dog：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来启动容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);</span><br><span class="line">    System.out.println(<span class="string">"容器已经启动成功..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么打印结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog constructor....</span><br><span class="line">容器已经启动成功...</span><br></pre></td></tr></table></figure><p>那如何指定我们自定义的初始化和销毁方法呢？</p><p>首先修改一下测试方法，增加一句关闭容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);</span><br><span class="line">    System.out.println(<span class="string">"容器已经启动成功..."</span>);</span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在@Bean注解上指定初始化方法和销毁方法：</p><blockquote><p>@Bean(initMethod = “init”,destroyMethod = “destory”)</p></blockquote><p>再次启动，显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dog constructor....</span><br><span class="line">Dog init...</span><br><span class="line">容器已经启动成功...</span><br><span class="line">Dog destory...</span><br></pre></td></tr></table></figure><p>但是注意单例和多例的区别，现在我将其配置成多例，由于多例是每次访问才会创建bean，所以我们还需要访问一下。</p><p>最后的打印结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器已经启动成功...</span><br><span class="line">Dog constructor....</span><br><span class="line">五月 28, 2018 3:49:33 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@16f65612: startup date [Mon May 28 15:49:32 CST 2018]; root of context hierarchy</span><br><span class="line">Dog init...</span><br></pre></td></tr></table></figure><p>说明在多例的情况下，容器最后不会销毁这个bean。</p><p><strong>⭐总结一下：</strong></p><blockquote><p>注解如何指定bean的初始化和销毁：@Bean注解后面指定init-method和destory-method</p><p>初始化：对象创建完成之后，并赋值好，在调用初始化方法</p><p>销毁方法：单例：容器关闭的时候销毁；多例：容器不会管理这个bean，容器不会调用销毁方法</p></blockquote><h2>2. InitializingBean和DisposableBean</h2><p>除了上一种用<code>@Bean</code>的方式来指定<code>bean</code>的初始化和销毁之外，spring还提供了另外的方法来实现。</p><p>初始化：</p><p>让<code>Bean</code>实现<code>InitializingBean</code>接口并且实现它的<code>afterPropertiesSet</code>方法，他的作用时机是：当一个<code>BeanFactory</code>创建之后并且所有的属性值已经被设置完成之后，可以调用这个方法来进行初始化的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁：</p><p>让<code>Bean</code>实现<code>DisposableBean</code>接口并且实现<code>destroy</code>方法，他的作用时机是<code>BeanFactory</code>销毁的时候也将单实例bean给销毁掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat destory..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat afterPropertiesSet init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后打印一下，发现达到了一样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat constructor...</span><br><span class="line">cat afterPropertiesSet init...</span><br><span class="line">容器已经启动成功...</span><br><span class="line">cat destory...</span><br></pre></td></tr></table></figure><h2>3. @PostConstruct&amp;@PreDestory</h2><p><code>@PostConstruct</code>：bean创建好并且赋值好属性值之后执行一些初始化工作</p><p><code>@PreDestory</code>：在容器销毁bean之前通知我们进行清理工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pig</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pig constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pig init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pig destory..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样的效果。</p><h2>4. BeanPostProcessor-后置处理器</h2><p>这是一个接口，bean的后置处理器，在bean初始化前后进行一些处理工作，有两个方法，一个是初始化之前处理，一个是初始化之后处理。</p><p><strong>具体的执行时机：</strong></p><blockquote><p>postProcessBeforeInitialization是在bean实例生成之后，在任何的初始化方法之前（比如InitializingBean接口的afterPropertiesSet方法；比如init-method方法）</p></blockquote><blockquote><p>postProcessAfterInitialization与上面个完全相反，在任何的初始化方法完成之后再调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object var1, String var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><p>我这里将上面的Dog，Cat，Pig全部用起来。pig用到init-destory和destory-method方法；cat实现InitializingBean,DisposableBean这两个接口；pig是实现@PostConstruct和@PreDestory这两个接口。</p><p>再加上后置处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean 还未初始化的bean对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName 这个bean对象在容器中的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回我们要用的bean实例对象，可以直接返回传进来的bean，也可以包装一下再返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessBeforeInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line">        <span class="keyword">return</span> bean;<span class="comment">//返回null的话，下面个方法就不会再执行了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessAfterInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一起启动，看看是什么先后顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//1.首先是Dog对象创建</span><br><span class="line">//2.然后是在任何的初始化方法之前执行postProcessBeforeInitialization</span><br><span class="line">//3.然后初始化init</span><br><span class="line">//4.init初始化之后执行postProcessAfterInitialization</span><br><span class="line">Dog constructor....</span><br><span class="line">postProcessBeforeInitialization...dog=&gt;com.swg.bean.Dog@157632c9</span><br><span class="line">Dog init...</span><br><span class="line">postProcessAfterInitialization...dog=&gt;com.swg.bean.Dog@157632c9</span><br><span class="line">//同理</span><br><span class="line">cat constructor...</span><br><span class="line">postProcessBeforeInitialization...cat=&gt;com.swg.bean.Cat@64c87930</span><br><span class="line">cat afterPropertiesSet init...</span><br><span class="line">postProcessAfterInitialization...cat=&gt;com.swg.bean.Cat@64c87930</span><br><span class="line">//同理</span><br><span class="line">pig constructor...</span><br><span class="line">postProcessBeforeInitialization...pig=&gt;com.swg.bean.Pig@4de5031f</span><br><span class="line">pig init...</span><br><span class="line">postProcessAfterInitialization...pig=&gt;com.swg.bean.Pig@4de5031f</span><br><span class="line"></span><br><span class="line">容器已经启动成功...</span><br><span class="line">五月 28, 2018 4:29:27 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext doClose</span><br><span class="line">信息: Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@16f65612: startup date [Mon May 28 16:29:26 CST 2018]; root of context hierarchy</span><br><span class="line"></span><br><span class="line">pig destory...</span><br><span class="line">cat destory...</span><br><span class="line">Dog destory...</span><br></pre></td></tr></table></figure><p>⭐⭐⭐其实顺序是这样的：<code>Constructor</code> &gt; <code>@BeanPostProcessor</code>前置处理 &gt; <code>@PostConstruct</code> &gt; <code>InitializingBean</code> &gt; <code>init-method</code> &gt; <code>@BeanPostProcessor</code>后置处理</p><p><img src="http://bloghello.oursnail.cn/Spring%E4%B8%ADBean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt="image"></p><h2>5. BeanPostProcessor原理</h2><p>首先是创建IOC容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);</span><br></pre></td></tr></table></figure><p>进去之后是构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="keyword">this</span>.register(annotatedClasses);</span><br><span class="line">    <span class="keyword">this</span>.refresh();<span class="comment">//刷新IOC容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>refresh</code>方法中有<code>finishBeanFactoryInitialization</code>这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化剩下的所有非懒记载的单例bean</span></span><br><span class="line"><span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure><p><code>finishBeanFactoryInitialization</code>这个方法中有一个方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//真正初始化剩下的所有非懒记载的单例bean</span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure><p>下面就是获取bean，获取不到就创建对象。</p><p>上面已经完成了对象的创建。下面就是进行属性赋值和初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、赋值</span><br><span class="line">先执行populateBean方法，是对bean进行属性赋值</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、初始化</span><br><span class="line"><span class="comment">//遍历得到容器中所有的BeanPostProcessor：挨个执行beforeInitialization,一旦返回null，后置处理器就不会再执行</span></span><br><span class="line">applyBeanPostProcessorsBeforeInitialization<span class="comment">//初始化之前处理</span></span><br><span class="line">invokeInitMethods：执行初始化方法</span><br><span class="line">applyBeanPostProcessorsAfterInitialization<span class="comment">//初始化之后处理</span></span><br></pre></td></tr></table></figure><h2>6. BeanPostProcessor在spring底层的使用</h2><p>aop最基本的原理就是通过动态代理（jdk，cglib）来构造出一个代理对象，在容器创建bean的时候替换原来的bean。</p><p>是谁来创建这个代理对象呢？<code>AnnotationAwareAspectJAutoProxyCreator</code>，这个玩意就是<code>BeanPostProcessor</code>的某个子类。</p><p>关于Spring AOP的具体实现，还是比较复杂的，具体的代码以后再去研究，这里给出一个大概的步骤：</p><ul><li><code>@EnableAspectJAutoProxy</code> 会注册一个<code>AnnotationAwareAspectJAutoProxyCreator</code></li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>是一个<code>InstantiationAwareBeanPostProcessor</code></li><li>创建流程<ul><li><code>registerBeanPostProcessors()</code> 注册后置处理器，创建<br><code>AnnotationAwareAspectJAutoProxyCreator</code></li><li><code>finishBeanFactoryInitialization</code> 初始化剩下的单实例<code>Bean</code><ul><li>创建<code>Bean</code>和切面</li><li><code>AnnotationAwareAspectJAutoProxyCreator</code>拦截创建过程</li><li>创建完<code>Bean</code>判断是否需要增强。通过<code>BeanPostProcessorsAfterInitialization</code>，<br><code>wrapIfNecessary()</code> 包装代理对象</li></ul></li></ul></li><li>执行目标方法<ul><li>获取拦截器链（<code>advisor</code>包装为<code>Interceptor</code>）</li><li>递归调用拦截器链<ul><li>前置通知、目标方法、后置通知、返回通知、异常通知</li></ul></li></ul></li></ul><h2>总结</h2><ul><li>执行初始化和销毁方法<ul><li>通过<code>@Bean</code>指定<code>init-destory</code>和<code>destory-method</code>方法</li></ul></li><li>通过让<code>Bean</code>实现<code>InitializingBean</code>（定义初始化逻辑）,<code>DisposableBean</code>（定义销毁前的逻辑）</li><li>通过使用JSR250规范中的<code>@PostConstruct</code>和<code>@PreDestory</code>来进行初始化工作和销毁之前的工作</li><li><code>BeanPostProcessor</code>：<code>bean</code>的后置处理器，在<code>bean</code>初始化前后进行一些处理工作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在之前说到过bean的生命周期，其中提到了很多初始化方法，搞得我们晕头晕脑，本文就是来解决这个问题，对bean生命周期中重要的几个初始化和销毁接口或注解进行消息阐述，使得对bean的生命周期理解更加轻松。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>注解--组件注册</title>
    <link href="http://yoursite.com/2019/03/03/spring/%E6%B3%A8%E8%A7%A3--%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/"/>
    <id>http://yoursite.com/2019/03/03/spring/注解--组件注册/</id>
    <published>2019-03-03T03:44:21.165Z</published>
    <updated>2019-03-03T04:55:57.987Z</updated>
    
    <content type="html"><![CDATA[<p>所有的组件都应该放进IOC容器中，组件之间的关系通过容器实现自动装配，也就是依赖注入。对于如何将组件注册到容器中，本文从使用的角度出发详细阐述配置文件和注解的实现方式。涉及的注解还是挺多的，不过还是需要记忆一下，尤其是设置bean作用域的注解，面试中被问到过如何设置为多例。</p><a id="more"></a><p>新建一个<code>maven</code>工程，引入<code>spring-context</code>依赖。</p><h2>1. @Configuration &amp; @Bean给容器注册组件</h2><h5>以往的方式注册一个bean</h5><p>新建一个实体类Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们可以在beans.xml中注册这个bean，给他赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.swg.bean.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，我们就可以拿到张三这个人了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Person person = (Person) applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//输出：Person(name=张三, age=10)</span></span><br></pre></td></tr></table></figure><h5>注解的方式注册bean</h5><ul><li>配置类 = 配置文件</li><li>@Configuration 告诉spring这是一个配置类</li><li>@Bean 给容器注册一个Bean，类型为返回值类型，id默认是方法名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取这个bean呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">Person person = applicationContext.getBean(Person.class);</span><br><span class="line">System.out.println(person);<span class="comment">//Person(name=李四, age=20)</span></span><br></pre></td></tr></table></figure><p>我们还可以根据类型来获取这个bean在容器中名字是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] names = applicationContext.getBeanNamesForType(Person.class);</span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">    System.out.println(name);<span class="comment">//person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到，id默认是方法名。如果我们修改MainConfig中的person这个方法名，果然打印结果也随着这个方法名改变而改变；也可以自己另外指定这个bean在容器中的名字：@Bean(“hello”)，那么这个bean的名字就变成了hello.</p><h2>2. @ComponentScan自动扫描组件以及扫描规则</h2><p>配置文件中配置包扫描时这样配置的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--包扫描，只要标注了@Controller，@Service，@Repository，@Component，就会被自动扫描到加入到容器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>现在用注解来实现这个功能：</p><p>只需要加上注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>)<span class="comment">//java8可以写多个@ComponentScan</span></span><br><span class="line"><span class="comment">//java8以前虽然不能写多个，但是也可以实现这个功能，用@ComponentScans配置即可</span></span><br></pre></td></tr></table></figure><p>我们增加BookController.java,BookService.java以及BookDao.java三个类，并且分别加上注解：@Controller，@Service，@Repository；那么包扫描就可以把这些类全部注册到IOC容器中了。</p><p>我们来打印一下目前所有注册到IOC容器的类的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldAnswerWithTrue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">    String[] names = applicationContext.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">//以上是spring IOC容器自身需要的组件，下面是我们自定义的组件</span><br><span class="line">mainConfig//主配置类，因为有注解@Configuration，而这个注解本身是有@Component的，所以也是一个bean</span><br><span class="line">bookController//@Controller</span><br><span class="line">bookDao//@Repository</span><br><span class="line">bookService//@Service</span><br><span class="line">person//这是由自己@Bean注册进去的</span><br></pre></td></tr></table></figure><p>上面的扫描路径是扫描所有的，有的时候我们需要排除掉一些扫描路径或者只扫描某个路径，如何做到呢？</p><p>用<code>excludeFilters</code>来排除，里面可以指定排除规则，这里是按照<code>ANNOTATION</code>来排除，排除掉所有<code>@Controller</code>注解的类。<code>classes</code>也是个数组，可以排除很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>,excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么效果就是<code>controller</code>没有了，但是<code>service</code>和<code>dao</code>都在。</p><p>那如果我想只包含<code>controller</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>, includeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)</span><br><span class="line">&#125;,useDefaultFilters = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>注意要<code>useDefaultFilters = false</code>，因为默认为<code>true</code>，就是扫描所有，不设置为<code>false</code>无效。</p><h2>3. 自定义TypeFilter制定过滤规则</h2><p>上面包扫描是按照<code>FilterType.ANNOTATION</code>规则来实现的，他还有其他几种规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FilterType &#123;</span><br><span class="line">    ANNOTATION,<span class="comment">//注解，最常用</span></span><br><span class="line">    ASSIGNABLE_TYPE,<span class="comment">//按照给定的类型，比如指定是BookService.class，那么只要是BookService这个类型就会被规则配置进来，子类或者实现类都可以</span></span><br><span class="line">    ASPECTJ,<span class="comment">//ASPECTJ表达式，不常用</span></span><br><span class="line">    REGEX,<span class="comment">//正则</span></span><br><span class="line">    CUSTOM;<span class="comment">//自定义规则</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FilterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最后的<code>CUSTOM</code>，这里着重说一说怎么用。</p><p>首先是要求实现<code>FilterType</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReader:读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadataReaderFactory：可以获取到其他任何类信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前类注解信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">//获取当前正在扫描的类的类信息,可以获取子类，父类，接口等信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        System.out.println(<span class="string">"----&gt;"</span>+className);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回false，表示不匹配，返回true的就匹配。这里默认是false；</p><p>在<code>mainConfig</code>类中配置这个自定义的过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>, includeFilters = &#123;</span><br><span class="line"><span class="meta">@ComponentScan</span>.Filter(type = FilterType.CUSTOM,classes = &#123;MyTypeFilter.class&#125;)</span><br><span class="line">&#125;,useDefaultFilters = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>那么此时输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">----&gt;com.swg.AppTest</span><br><span class="line">----&gt;com.swg.bean.Person</span><br><span class="line">----&gt;com.swg.controller.BookController</span><br><span class="line">----&gt;com.swg.dao.BookDao</span><br><span class="line">----&gt;com.swg.FilterType.MyTypeFilter</span><br><span class="line">----&gt;com.swg.MainTest</span><br><span class="line">----&gt;com.swg.service.BookService</span><br><span class="line"></span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalRequiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">mainConfig</span><br><span class="line">person</span><br></pre></td></tr></table></figure><p>就是显示了所有他处理的类，最后由于都返回fasle，那么那些controller，service都将被过滤掉。</p><p>下面指定通过一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(className.contains(<span class="string">"er"</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mainConfig</span><br><span class="line">person</span><br><span class="line">bookController//new</span><br><span class="line">myTypeFilter//new</span><br><span class="line">bookService//new</span><br></pre></td></tr></table></figure><h2>4. @Scope-设置组件作用域</h2><p>spring的bean默认是单实例，下面佐证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br><span class="line">    String[] names = applicationContext.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean  = applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">    Object bean1  = applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">    System.out.println(bean == bean1);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以配置bean为多例吗？显然是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Scope</code>注解中有四个选项：</p><ul><li><code>prototype</code>:多例</li><li><code>singleton</code>:单例，默认</li><li><code>request</code>:同一次请求创建一个实例</li><li><code>session</code>:同一个session创建一个实例</li></ul><p>着重看一下<code>singleton</code>和<code>prototype</code>，他们的加载时机？</p><p>⭐⭐⭐<code>singleton</code>：<strong>IOC容器启动时调用方法创建对象放到IOC容器中，以后每次获取都直接从容器中拿，类似于map.get();</strong></p><p>⭐⭐⭐<code>prototype</code><strong>:IOC容器启动时不会创建对象，而是在每次获取时才会调用方法创建对象；并且是新new出来的对象，都是不一样的。</strong></p><h2>5. @lazy-bean-懒加载</h2><p>单实例bean，默认在容器启动时创建对象。</p><p>即只要执行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br></pre></td></tr></table></figure><p>Person这个对象就会加载在容器中。测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建对象Person"</span>);<span class="comment">//容器启动的时候就会执行这个方法，创建Perosn对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒加载：容器启动时不创建对象，第一次使用(获取)Bean创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建对象Person"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，就不会在容器一启动的时候就加载了。那什么时候加载呢？</p><p>我获取一下这个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br><span class="line">Object bean  = applicationContext.getBean(<span class="string">"person"</span>);</span><br></pre></td></tr></table></figure><p>这个时候，@Bean就被创建了。这就是懒加载。</p><h2>6. @Conditional-按照条件注册bean</h2><p>按照一定的条件进行判断，满足条件给容器注册bean。</p><p>先创建三个bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"bill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Bill"</span>,<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"linus"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"linus"</span>,<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印一下创建的bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig2.class);</span><br><span class="line">    String[] names = applicationContext.getBeanNamesForType(Person.class);</span><br><span class="line">    <span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">        System.out.println(<span class="string">"---&gt;"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Person&gt; types = applicationContext.getBeansOfType(Person.class);</span><br><span class="line">    System.out.println(types);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---&gt;person</span><br><span class="line">---&gt;bill</span><br><span class="line">---&gt;linus</span><br><span class="line">&#123;person=Person(name=李四, age=20), bill=Person(name=Bill, age=60), linus=Person(name=linus, age=50)&#125;</span><br></pre></td></tr></table></figure><p>那假设一个场景：如果系统是windows,给容器注册“bill”；如果系统是linux,给容器注册“linus”；</p><p>至于获取操作系统是什么，我们可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();</span><br><span class="line">String osName = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">System.out.println(osName);<span class="comment">//wondows 7</span></span><br></pre></td></tr></table></figure><p>那么我们如何根据条件来注册bean呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否是linux系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取IOC使用的bean factory，这个factory就是创建对象并进行装配的工厂</span></span><br><span class="line">        ConfigurableListableBeanFactory factory = conditionContext.getBeanFactory();</span><br><span class="line">        <span class="comment">//2.获取类加载器</span></span><br><span class="line">        ClassLoader classLoader = conditionContext.getClassLoader();</span><br><span class="line">        <span class="comment">//3.获取当前环境信息</span></span><br><span class="line">        Environment environment = conditionContext.getEnvironment();</span><br><span class="line">        <span class="comment">//4.获取到bean定义的注册类</span></span><br><span class="line">        BeanDefinitionRegistry registry = conditionContext.getRegistry();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是liunx系统，就让其注册进容器，windows也是如此</span></span><br><span class="line">        String osName = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        <span class="keyword">if</span>(osName.contains(<span class="string">"Linux"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Conditional</span>(&#123;WindowsCondition.class&#125;)<span class="comment">//传condition数组</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"bill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"Bill"</span>,<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition.class)</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"linus"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"linus"</span>,<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么运行结果可以预测到：由于我们是windows系统，所以linux的就不能注册进容器了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Windows 7</span><br><span class="line">---&gt;person</span><br><span class="line">---&gt;bill</span><br><span class="line">&#123;person=Person(name=李四, age=20), bill=Person(name=Bill, age=60)&#125;</span><br></pre></td></tr></table></figure><h2>7. @Import-给容器中快速导入一个组件</h2><p>上面所说得给容器注册组件的方式是：</p><p>包扫描+组件标注注解：<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>，<br><code>@Component</code></p><p>比较方便，但是有局限性：如果是注册第三方包怎么办呢？</p><p>有一种是：<code>@Bean</code>[导入第三方包里面的组件],对于简单的可用这样用</p><p>还有一种是：<code>@Import</code>，快速给容器导入一个组件</p><p>比如我随便新建一个类叫<code>Dog</code>，里面啥注解和内容都不写。默认他是不会导入进去的。但是我在<code>webconfig</code>类上增加注解：</p><blockquote><p>@Import(Dog.class)</p></blockquote><p>那么再次打印出所有注册进容器的组件时，会出现</p><blockquote><p>com.swg.bean.Dog</p></blockquote><p>可见，<code>@import</code>注解可以方便快速地导入一个组件，并且id默认是组件的全类名</p><p>那如何导入多个呢？</p><blockquote><p>@Import({Dog.class, Cat.class})</p></blockquote><h2>8. @Import-使用ImportSelector</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义逻辑返回需要导入的组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationMetadata 当前标注Import注解的类的所有注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值就是导入到容器中的组件的全类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"com.swg.bean.Dog"</span>,<span class="string">"com.swg.bean.Cat"</span>,<span class="string">"com.swg.bean.pig"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打上注解导入进来即可：</p><blockquote><p>@Import(MyImportSelector.class)</p></blockquote><p>这里导入的实际上不是<code>MyImportSelector.class</code>这个类，而是他返回的组件全类名</p><h2>9. @Import-使用ImportBeanDefinitionRegistrar</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationMetadata 当前类的注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry  beanDefinition注册类；</span></span><br><span class="line"><span class="comment">     *                   把所有需要添加进容器的bean：调用BeanDefinitionRegistry.registerBeanDefinition</span></span><br><span class="line"><span class="comment">     *                   来手工注册进来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断这两个bean是否都已经存在于容器中</span></span><br><span class="line">        <span class="keyword">boolean</span> definition = registry.containsBeanDefinition(<span class="string">"com.swg.bean.Pig"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> definition2 = registry.containsBeanDefinition(<span class="string">"com.swg.bean.Cat"</span>);</span><br><span class="line">        <span class="comment">//如果两个bean都有，则注册一头牛</span></span><br><span class="line">        <span class="keyword">if</span>(definition &amp;&amp; definition2)&#123;</span><br><span class="line">            <span class="comment">//指定bean定义信息</span></span><br><span class="line">            RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(Bull.class);</span><br><span class="line">            <span class="comment">//注册一个bean，指定bean的名字</span></span><br><span class="line">            registry.registerBeanDefinition(<span class="string">"bull"</span>,rootBeanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后打上注解导入进来即可：</p><blockquote><p>@Import(MyImportBeanDefinitionRegistrar.class)</p></blockquote><h2>10. 使用FactoryBean注册组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个Pig对象，这个对象会添加到容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AnimalFactory...getObject()..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Pig.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是单例吗？返回true表示是单例，在容器中保存一份</span></span><br><span class="line"><span class="comment">     * false：表示是多例，每次获取都创建新的，每次调用getObject()这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先将它用@Bean添加进容器看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnimalFactory <span class="title">animalFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnimalFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示的id是animalFactory，我们根据这个id获取一下这个bean的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object bean = applicationContext.getBean(<span class="string">"animalFactory"</span>);</span><br><span class="line">System.out.println(<span class="string">"bean的类型："</span>+bean.getClass());</span><br></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AnimalFactory...getObject()...</span><br><span class="line">bean的类型：class com.swg.bean.Pig</span><br></pre></td></tr></table></figure><p>就是说，这个bean的类型就是getObject方法中返回的Pig对象。</p><p>那如果我们想获取这个工厂对象呢？也是可以的，id前面加上&amp;即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object bean = applicationContext.getBean(<span class="string">"&amp;animalFactory"</span>);</span><br><span class="line">System.out.println(<span class="string">"bean的类型："</span>+bean.getClass());<span class="comment">//bean的类型：class com.swg.bean.AnimalFactory</span></span><br></pre></td></tr></table></figure><p>原因是在BeanFactory中定义了一个前缀&amp;，只要是以&amp;为前缀，表示拿FactoryBean本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br></pre></td></tr></table></figure><h2>11. 总结</h2><p>给容器中注册组件：</p><ol><li><p>包扫描+组件标注注解：@Controller，@Service，@Repository，@Component</p></li><li><p>@Bean[导入第三方包里面的组件]</p></li><li><p><strong>@Import，快速给容器导入一个组件—重要</strong></p><p>1).@Import(要导入到容器中的组件)；容器会自动注册这个组件，id默认是全类名</p><p>2).@ImportSelector：返回要导入的组件的全类名数组</p><p>3).@ImportBeanDefinitionRegistrar：手动注册bean到容器中</p></li><li><p>使用spring提供的@FactoryBean（工厂bean）来注册bean</p></li><li><p><strong>@Conditional按照条件注册bean—重要</strong></p></li><li><p>@Scope作用域</p></li><li><p>懒加载，单例和多例是不一样的</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有的组件都应该放进IOC容器中，组件之间的关系通过容器实现自动装配，也就是依赖注入。对于如何将组件注册到容器中，本文从使用的角度出发详细阐述配置文件和注解的实现方式。涉及的注解还是挺多的，不过还是需要记忆一下，尤其是设置bean作用域的注解，面试中被问到过如何设置为多例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean</title>
    <link href="http://yoursite.com/2019/03/02/spring/Spring%20Bean/"/>
    <id>http://yoursite.com/2019/03/02/spring/Spring Bean/</id>
    <published>2019-03-02T13:33:29.306Z</published>
    <updated>2019-03-03T04:27:07.002Z</updated>
    
    <content type="html"><![CDATA[<p>一提到Spring的IOC，那么里面的Bean基本就会被问到，我们也知道，Spring的任务就是对这些bean进行管理和装配，所以bean就是spring IOC处理的对象，如此关键的对象，我们需要了解它核心的两点：作用域和生命周期。</p><a id="more"></a><h2>一、Spring Bean的作用域</h2><ul><li><code>singleton</code>：Spring默认作用域，容器里拥有唯一的Bean实例</li><li><code>prototype</code>：针对每个getBean请求，容器都会创建一个bean实例</li><li><code>request</code>：会为每个HTTP请求创建一个Bean实例</li><li><code>session</code>：会为每个session创建一个Bean实例</li><li><code>globalSession</code>：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效</li></ul><p>对于这个问题面试中我也被问过，即spring中bean默认作用域，如何设置为多例。这个问题我在<a href="http://fourcolor.oursnail.cn/2019/03/03/spring/%E6%B3%A8%E8%A7%A3--%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/" target="_blank" rel="noopener">注解–组件注册</a>这篇文章中会详细谈论。</p><h2>二、Bean的生命周期</h2><p><code>beanDefinition</code>（容器启动阶段）只完成<code>bean</code>的定义，并未完成初始化。初始是通过<code>beanFactory</code>的<code>getBean()</code>时才进行的。</p><p>对于普通的Java对象，当new的时候创建对象，当它没有任何引用的时候被垃圾回收机制回收。而由Spring IoC容器托管的对象，它们的生命周期完全由容器控制。Spring中每个Bean的生命周期如下：</p><p><img src="http://bloghello.oursnail.cn/spring4-1.png" alt="image"></p><h5>2.1 实例化Bean</h5><p>对于<code>BeanFactory</code>容器，当客户向容器请求一个尚未初始化的<code>bean</code>时，或初始化<code>bean</code>的时候需要注入另一个尚未初始化的依赖时，容器就会调用<code>createBean</code>进行实例化。</p><p>容器通过获取<code>BeanDefinition</code>对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。</p><p>实例化对象被包装在<code>BeanWrapper</code>对象中，<code>BeanWrapper</code>提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h5>2.2 设置对象属性（依赖注入）</h5><p>实例化后的对象被封装在<code>BeanWrapper</code>对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。</p><p>紧接着，<code>Spring</code>根据<code>BeanDefinition</code>中的信息进行依赖注入。</p><p>并且通过<code>BeanWrapper</code>提供的设置属性的接口完成依赖注入。</p><h5>2.3 注入Aware接口</h5><p>紧接着，Spring会检测该对象是否实现了<code>xxxAware</code>接口，并将相关的<code>xxxAware</code>实例注入给bean。</p><h5>2.4 BeanPostProcessor</h5><p>当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过<code>BeanPostProcessor</code>接口实现。</p><p>该接口提供了两个函数：</p><ul><li><code>postProcessBeforeInitialzation( Object bean, String beanName )</code><ul><li>当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。</li><li>这个函数会先于<code>InitialzationBean</code>执行，因此称为前置处理。</li><li>所有Aware接口的注入就是在这一步完成的。</li></ul></li><li><code>postProcessAfterInitialzation( Object bean, String beanName )</code><ul><li>当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。</li><li>这个函数会在<code>InitialzationBean</code>完成后执行，因此称为后置处理。</li></ul></li></ul><h5>2.5 InitializingBean与init-method</h5><p>当<code>BeanPostProcessor</code>的前置处理完成后就会进入本阶段。</p><p><code>InitializingBean</code>接口只有一个函数：</p><ul><li><code>afterPropertiesSet()</code></li></ul><p>这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行<code>afterPropertiesSet</code>函数。</p><h5>2.6 DisposableBean和destroy-method</h5><p>和<code>init-method</code>一样，通过给<code>destroy-method</code>指定函数，就可以在bean销毁前执行指定的逻辑。</p><p>对于上面的过程只能理解并且记忆，还是很容易被问到的，是spring的一个高频考点。或许你对这些所说的方法一脸懵逼，对于生命周期这一块，我对里面涉及的所有初始化以及销毁方法进行了汇总，详情见文章:<a href="http://fourcolor.oursnail.cn/2019/03/03/spring/%E6%B3%A8%E8%A7%A3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" target="_blank" rel="noopener">注解-生命周期</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一提到Spring的IOC，那么里面的Bean基本就会被问到，我们也知道，Spring的任务就是对这些bean进行管理和装配，所以bean就是spring IOC处理的对象，如此关键的对象，我们需要了解它核心的两点：作用域和生命周期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>AOP基本使用和原理</title>
    <link href="http://yoursite.com/2019/03/02/spring/AOP%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/02/spring/AOP基本使用和原理/</id>
    <published>2019-03-02T11:06:02.574Z</published>
    <updated>2019-03-03T05:00:31.178Z</updated>
    
    <content type="html"><![CDATA[<p>除了IOC之外，spring核心的东西就是AOP。主要的目标是实现关注业务逻辑，解耦非业务逻辑，比如比较典型的日志处理。将日志的处理划分出来，在运行时动态地添加到要拦截的接口方法上，对这个方法的执行前后以及发生异常时实现日志的监控。这种动态的功能是非常重要的功能，本文来介绍一下AOP最基本的使用。</p><a id="more"></a><h2>一、什么是aop</h2><p>AOP（Aspect Oriented Programming），即面向切面编程（也叫面向方面编程，面向方法编程）。其主要作用是，在不修改源代码的情况下给某个或者一组操作添加额外的功能。像日志记录，事务处理，权限控制等功能，都可以用AOP来“优雅”地实现，使这些额外功能和真正的业务逻辑分离开来，软件的结构将更加清晰。AOP是OOP的一个强有力的补充。</p><h2>二、先简单用一下spring aop</h2><h5>首先要导入依赖：spring-aspects</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5>写一个业务逻辑类：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathCaculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要向在这个业务逻辑方法运行前，运行结束时，方法出现异常时都将日志文件打印。</p><h5>定义一个日志切面类</h5><p>切面类里面的方法需要动态感知MathCaculator.div运行到哪里。</p><p>通知方法：</p><ul><li>前置通知(<code>@Before</code>)：<code>logStart()</code>：在目标方法div运行之前运行</li><li>后置通知(<code>@After</code>)：<code>logEnd()</code>:在目标方法div运行结束之后运行</li><li>返回通知(<code>@AfterReturning</code>)：<code>logReturn()</code>:在目标方法div运行正常返回之后运行</li><li>异常通知(<code>@AfterThrowing</code>)：<code>logException()</code>:在目标方法div出现异常之后运行</li><li>环绕通知(<code>@Around</code>)：动态代理，手动推进目标方法运行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.swg.aop.MathCaculator.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(<span class="string">"【@Before】...方法名：&#123;"</span>+methodName+<span class="string">"&#125;...参数列表是-&gt;&#123;"</span>+ Arrays.asList(args)+<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【@After】...&#123;"</span>+joinPoint.getSignature().getName()+<span class="string">"&#125;结束..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"pointCut()"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【@AfterReturning】...&#123;"</span>+joinPoint.getSignature().getName()+<span class="string">"&#125;正常返回，运行结果是&#123;"</span>+result+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"pointCut()"</span>,throwing = <span class="string">"exception"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"【@AfterThrowing】...&#123;"</span>+joinPoint.getSignature().getName()+<span class="string">"&#125;发生异常,异常信息是&#123;"</span>+exception.getMessage()+<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>切面类和业务逻辑类都加入到容器中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MathCaculator <span class="title">mathCaculator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MathCaculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LogAspect <span class="title">aspect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LogAspect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>容器启动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfAop.class);</span><br><span class="line">    System.out.println(<span class="string">"容器已经启动成功..."</span>);</span><br><span class="line">    MathCaculator caculator = applicationContext.getBean(MathCaculator.class);</span><br><span class="line">    caculator.div(<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>无异常的情况输出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器已经启动成功...</span><br><span class="line">【@Before】...方法名：&#123;div&#125;...参数列表是-&gt;&#123;[6, 2]&#125;</span><br><span class="line">div...</span><br><span class="line">【@After】...&#123;div&#125;结束...</span><br><span class="line">【@AfterReturning】...div正常返回，运行结果是&#123;3&#125;</span><br></pre></td></tr></table></figure><h5>有异常的情况输出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器已经启动成功...</span><br><span class="line">【@Before】...方法名：&#123;div&#125;...参数列表是-&gt;&#123;[6, 0]&#125;</span><br><span class="line">div...</span><br><span class="line">【@After】...&#123;div&#125;结束...</span><br><span class="line">【@AfterThrowing】...&#123;div&#125;发生异常,异常信息是&#123;/ by zero&#125;</span><br></pre></td></tr></table></figure><p>主要是有三步：</p><blockquote><p>将业务逻辑组件和切面类都加入到容器中，告诉spring哪个是切面类(@Aspect)</p><p>在切面类上的每一个通知方法上标注通知注释，告诉spring合适何地运行(切入点表达式)</p><p>开启基于注解的aop模式(@EnableAspectJAutoProxy)</p></blockquote><h2>三、基本原理</h2><p>AOP是具有特定的应用场合的，它只适合那些具有横切逻辑的应用场合，如性能检测、访问控制、事务管理及日志纪录。</p><p>Spring AOP使用动态代理技术在运行期织入增强的代码，Spring AOP使用了两种代理机制：<strong>一种是基于JDK的动态代理；另一种是基于CGLib的动态代理</strong>。这两种机制就是AOP最根本的实现原理，面试中把这两者说清楚即可。</p><h5>3.1 JDK动态代理</h5><p>Java1.3后，Java提供了动态代理技术，运行开发者在运行期间创建接口的代理实例。JDK动态代理主要涉及<code>java.lang.reflect</code>包中的两个类：<code>Proxy</code>和<code>InvocationHandler</code>。<code>InvocationHandler</code>是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。</p><p>具体请看笔记<a href="http://fourcolor.oursnail.cn/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">java基础之JDK动态代理</a></p><h5>3.2 CGLib动态代理</h5><p>CGLib采用底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p><p>需要注意的是，由于CGLib采用动态创建子类的方式生成代理对象，所以不能对目标类中的final或private方法进行代理。</p><h5>3.3 为什么会有两种代理机制</h5><ul><li>JDK创建代理有一个限制，即它只能为接口创建代理实例，虽然面向接口编程是好的编程习惯，但有时候并不是必须的，这是JDK动态代理的局限性。</li><li>就性能来说，CGLib所创建的动态代理对象的性能比JDK所创建的动态代理对象的性能高差不多10倍，CGLib在创建代理对象时所话费的时间却比JDK动态代理大概多8倍，但是对于singleton的代理对象或者具有实例池的代理，因为无需频繁创建代理对象，所以比较合适采用CGLib动态代理技术，反之则适合采用JDK动态代理技术。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了IOC之外，spring核心的东西就是AOP。主要的目标是实现关注业务逻辑，解耦非业务逻辑，比如比较典型的日志处理。将日志的处理划分出来，在运行时动态地添加到要拦截的接口方法上，对这个方法的执行前后以及发生异常时实现日志的监控。这种动态的功能是非常重要的功能，本文来介绍一下AOP最基本的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>IOC的用法</title>
    <link href="http://yoursite.com/2019/03/02/spring/IOC%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2019/03/02/spring/IOC的用法/</id>
    <published>2019-03-02T10:29:16.202Z</published>
    <updated>2019-03-03T03:38:01.368Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经知道了IOC的基本思想，它用一种倒置的思想帮助我们实现高层建筑需要什么直接引入底层就行，而不需要关心底层的具体实现，因为具体实现已经交给了我们的IOC去实现了。了解了这些之后，光说不练肯定是不行的，下面我们来看看这种依赖倒置到底是如何去用的。首先介绍一下传统的方式，就是spring中经常用的方式。然后再介绍一下springBoot中是什么样子的。其实它们两是差不多的。</p><a id="more"></a><p>我们知道，要想用<code>Bean</code>，那么必然是要先注册进去才行。<code>Spring</code> 启动时读取应用程序提供的<code>Bean</code>配置信息，并在<code>Spring</code>容器中生成一份相应的<code>Bean</code>配置注册表，然后根据这张注册表实例化<code>Bean</code>，装配好<code>Bean</code>之间的依赖关系，为上层应用提供准备就绪的运行环境。</p><p><img src="http://bloghello.oursnail.cn/spring2-1.png" alt="image"></p><h2>一、@Configuration 和 @Bean给容器注册组件</h2><p>新建一个<code>maven</code>工程，引入<code>spring-context</code>依赖。</p><h5>1.1 以往的方式注册一个bean</h5><p>新建一个实体类<code>Person</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们可以在<code>beans.xml</code>中注册这个<code>bean</code>，给他赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.swg.bean.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，我们就可以拿到张三这个人了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Person person = (Person) applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//输出：Person(name=张三, age=10)</span></span><br></pre></td></tr></table></figure><h5>1.2 注解的方式注册bean</h5><ul><li>配置类 = 配置文件</li><li><code>@Configuration</code> 告诉<code>spring</code>这是一个配置类</li><li><code>@Bean</code> 给容器注册一个<code>Bean</code>，类型为返回值类型，<code>id</code>默认是方法名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取这个<code>bean</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfig.class);</span><br><span class="line">Person person = applicationContext.getBean(Person.class);</span><br><span class="line">System.out.println(person);<span class="comment">//Person(name=李四, age=20)</span></span><br></pre></td></tr></table></figure><p>我们还可以根据类型来获取这个bean在容器中名字是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] names = applicationContext.getBeanNamesForType(Person.class);</span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">    System.out.println(name);<span class="comment">//person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到，<code>id</code>默认是方法名。如果我们修改<code>MainConfig</code>中的<code>person</code>这个方法名，果然打印结果也随着这个方法名改变而改变；也可以自己另外指定这个<code>bean</code>在容器中的名字：<code>@Bean(&quot;hello&quot;)</code>，那么这个<code>bean</code>的名字就变成了<code>hello</code>.</p><h5>1.3 springboot中用这种方式注册bean以及获取</h5><p><code>springboot</code>那就更简单了。</p><p>定义<code>bean</code>跟注解的方式是一样的，不再赘述。只是，我们来到它的启动类，直接可以获取到<code>ApplicationContext</code>，然后就可以直接获取到<code>bean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootdemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = SpringApplication.run(SpringbootdemoApplication.class, args);</span><br><span class="line">        Person person = (Person) ctx.getBean(<span class="string">"person"</span>);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们点进<code>run</code>里面：</p><p><img src="http://bloghello.oursnail.cn/spring2-2.png" alt="image"></p><p>我们这里不深入探讨里面的实现细节，我们这里只要知道可以用<code>ApplicationContext</code>来接收即可。</p><p>只是，到现在，我们一直在用这个<code>ApplicationContext</code>，它到底是何方神圣？</p><h2>二、BeanFactory和ApplicationContext</h2><p>我们知道，IOC会帮助我们完成对象的创建并将其送到服务对象即完成对象的绑定，即IOC要实现这两件事情：</p><ul><li>对象的构建</li><li>对象的绑定</li></ul><p>spring提供了两种类型的容器来实现对<code>bean</code>的管理，一个是<code>BeanFactory</code>,一个是<code>ApplicationContext</code>(可以认为是<code>BeanFactory</code>的扩展)，这两者是<code>spring core</code>中最核心的两个基础接口。下面我们将介绍这两种容器如何实现对对象的管理。</p><p><code>Spring</code> 通过一个配置文件描述 <code>Bean</code> 及 <code>Bean</code> 之间的依赖关系，利用 <code>Java</code> 语言的反射功能实例化 <code>Bean</code> 并建立 <code>Bean</code> 之间的依赖关系。 <code>Spring</code> 的 <code>IoC</code> 容器在完成这些底层工作的基础上，还提供了 <code>Bean</code> 实例缓存、生命周期管理、 <code>Bean</code> 实例代理、事件发布、资源装载等高级服务。</p><p><code>BeanFactory</code> 是 <code>Spring</code> 框架的基础设施，面向 <code>Spring</code> 本身；</p><p><code>ApplicationContext</code> 面向使用 <code>Spring</code>框架的开发者，几乎所有的应用场合我们都直接使用 <code>ApplicationContext</code> 而非底层的 <code>BeanFactory</code>。</p><p>我们先来看看 <code>BeanFactory</code> ，再来看看 <code>ApplicationContext</code> 。</p><h5>2.1 BeanFactory</h5><p><code>BeanFactory</code> 体系架构：</p><p><img src="http://bloghello.oursnail.cn/spring2-3.png" alt="image"></p><ul><li><code>BeanDefinitionRegistry</code>： <code>Spring</code> 配置文件中每一个节点元素在 <code>Spring</code> 容器里都通过一个 <code>BeanDefinition</code> 对象表示，它描述了 <code>Bean</code> 的配置信息。而 <code>BeanDefinitionRegistry</code> 接口提供了向容器手工注册 <code>BeanDefinition</code> 对象的方法。</li><li><code>BeanFactory</code> 接口位于类结构树的顶端 ，它最主要的方法就是 <code>getBean(String beanName)</code>，该方法从容器中返回特定名称的 <code>Bean</code>，<code>BeanFactory</code> 的功能通过其他的接口得到不断扩展.</li><li><code>ListableBeanFactory</code>：该接口定义了访问容器中 <code>Bean</code> 基本信息的若干方法，如查看<code>Bean</code> 的个数、获取某一类型 <code>Bean</code> 的配置名、查看容器中是否包括某一 <code>Bean</code> 等方法；</li><li><code>HierarchicalBeanFactory</code>：父子级联 <code>IoC</code>容器的接口，子容器可以通过接口方法访问父容器； 通过 <code>HierarchicalBeanFactory</code> 接口， <code>Spring</code> 的 <code>IoC</code> 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 <code>Bean</code>，但父容器不能访问子容器的 <code>Bean</code>。<code>Spring</code> 使用父子容器实现了很多功能，比如在 <code>Spring MVC</code> 中，展现层 <code>Bean</code> 位于一个子容器中，而业务层和持久层的 <code>Bean</code> 位于父容器中。这样，展现层 <code>Bean</code> 就可以引用业务层和持久层的 <code>Bean</code>，而业务层和持久层的 <code>Bean</code> 则看不到展现层的 <code>Bean</code>。</li><li><code>ConfigurableBeanFactory</code>：是一个重要的接口，增强了 <code>IoC</code> 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li><li><code>AutowireCapableBeanFactory</code>：定义了将容器中的 <code>Bean</code>按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li><li><code>SingletonBeanRegistry</code>：定义了允许在运行期间向容器注册单实例 <code>Bean</code> 的方法；</li></ul><p>⭐⭐⭐其中，我们最关心的是<code>BeanDefinition</code>、<code>BeanDefinitionRegistry</code>、<br><code>BeanFactory</code>。注意，<code>BeanDefinition</code>,它完成了<code>Bean</code>的生成过程。<code>BeanDefinitionRegistry</code>是将定义好的<code>bean</code>，注册到容器中。<code>BeanFactory</code> 是一个<code>bean</code>工厂类，从容器中可以取到任意定义过的<code>bean</code>。</p><p><code>Bean</code>的生成大致可以分为两个阶段：容器启动阶段和<code>bean</code>实例化阶段：</p><p><img src="http://bloghello.oursnail.cn/spring2-6.png" alt="image"></p><p>它是面向<code>spring</code>管理<code>bean</code>的最核心的一个接口，但是作为使用者，我们往往更关心的是<code>ApplicationContext</code>.</p><h5>2.2 ApplicationContext</h5><p><code>ApplicationContext</code> 由 <code>BeanFactory</code> 派生而来，提供了更多面向实际应用的功能。</p><p>在<code>BeanFactory</code> 中，很多功能需要以编程的方式实现，而在 <code>ApplicationContext</code> 中则可以通过配置的方式实现。</p><p><img src="http://bloghello.oursnail.cn/spring2-4.png" alt="image"></p><p><code>ApplicationContext</code> 继承了 <code>HierarchicalBeanFactory</code> 和 <code>ListableBeanFactory</code> 接口，在此基础上，还通过多个其他的接口扩展了 <code>BeanFactory</code> 的功能：</p><ul><li><code>ClassPathXmlApplicationContext</code>：默认从类路径加载配置文件</li><li><code>FileSystemXmlApplicationContext</code>：默认从文件系统中装载配置文件</li><li><code>ApplicationEventPublisher</code>：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了 <code>ApplicationListener</code> 事件监听接口的 <code>Bean</code> 可以接收到容器事件 ， 并对事件进行响应处理 。 在 <code>ApplicationContext</code> 抽象实现类<code>AbstractApplicationContext</code> 中，我们可以发现存在一个 <code>ApplicationEventMulticaster</code>，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。</li><li><code>MessageSource</code>：为应用提供 i18n 国际化消息访问的功能；</li><li><code>ResourcePatternResolver</code> ： 加载资源文件</li><li><code>LifeCycle</code>：该接口是 <code>Spring 2.0</code> 加入的，该接口提供了 <code>start()</code>和 <code>stop()</code>两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 <code>ApplicationContext</code> 实现及具体 <code>Bean</code> 实现， <code>ApplicationContext</code> 会将 <code>start/stop</code> 的信息传递给容器中所有实现了该接口的 <code>Bean</code>，以达到管理和控制 <code>JMX</code>、任务调度等目的。</li><li><code>ConfigurableApplicationContext</code> 扩展于 <code>ApplicationContext</code>，它新增加了两个主要的方法： <code>refresh()</code>和 <code>close()</code>，让 <code>ApplicationContext</code> 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 <code>refresh()</code> 即可启动应用上下文，在已经启动的状态下，调用 <code>refresh()</code>则清除缓存并重新装载配置信息，而调用<code>close()</code>则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。</li></ul><h5>2.3 两者的区别</h5><ul><li><code>BeanFactory</code>是<code>Spring</code>框架的基础设施，面向<code>Spring</code></li><li><code>ApplicationContext</code>面向使用<code>Spring</code>框架的开发者</li></ul><p><code>BeanFactory</code>可以理解为汽车的发动机，<code>ApplicationContext</code>可以理解为比较完整的一辆汽车。</p><h2>三、@ComponentScan自动扫描组件以及扫描规则</h2><p>每次都用<code>@Configure</code>和<code>@Bean</code>着实太麻烦了，有没有什么办法可以自动地装载为<code>Bean</code>呢？答案就是这个自动扫描的注解。下面来看看是如何使用的。</p><p>配置文件中配置包扫描时这样配置的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--包扫描，只要标注了@Controller，@Service，@Repository，@Component，就会被自动扫描到加入到容器中--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.swg&quot;/&gt;</span><br></pre></td></tr></table></figure><p>现在用注解来实现这个功能，只需要加上注解<code>@ComponentScan</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>)<span class="comment">//java8可以写多个@ComponentScan</span></span><br><span class="line"><span class="comment">//java8以前虽然不能写多个，但是也可以实现这个功能，用@ComponentScans配置即可</span></span><br></pre></td></tr></table></figure><p>表示自动扫描<code>com.swg</code>包路径下以及子目录下所有的<code>Bean</code>，装载进容器中。</p><p>上面的扫描路径是扫描所有的，有的时候我们需要排除掉一些扫描路径或者只扫描某个路径，如何做到呢？</p><p>用<code>excludeFilters</code>来排除，里面可以指定排除规则，这里是按照<code>ANNOTATION</code>来排除，排除掉所有<code>@Controller</code>注解的类。<code>classes</code>也是个数组，可以排除很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>,excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么效果就是<code>controller</code>没有了，但是<code>service</code>和<code>dao</code>都在。</p><p>那如果我想只包含<code>controller</code>呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.swg"</span>, includeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)</span><br><span class="line">&#125;,useDefaultFilters = <span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><p>注意要<code>useDefaultFilters = false</code>，因为默认为<code>true</code>，就是扫描所有，不设置为<code>false</code>无效。</p><p>关于<code>springboot</code>这里强调一下， 启动方法上的注解中已经默认有了扫描的注解，默认扫描的范围是这个启动类所在的路径及其子路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们已经知道了IOC的基本思想，它用一种倒置的思想帮助我们实现高层建筑需要什么直接引入底层就行，而不需要关心底层的具体实现，因为具体实现已经交给了我们的IOC去实现了。了解了这些之后，光说不练肯定是不行的，下面我们来看看这种依赖倒置到底是如何去用的。首先介绍一下传统的方式，就是spring中经常用的方式。然后再介绍一下springBoot中是什么样子的。其实它们两是差不多的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring面试" scheme="http://yoursite.com/tags/spring%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
