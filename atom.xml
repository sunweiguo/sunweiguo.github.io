<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-19T14:04:31.654Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript基础学习</title>
    <link href="http://yoursite.com/2019/03/19/front/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/19/front/javascript基础学习/</id>
    <published>2019-03-19T13:56:39.529Z</published>
    <updated>2019-03-19T14:04:31.654Z</updated>
    
    <content type="html"><![CDATA[<p>js和其他的语言很像，很多的操作都是一样的，比如数值的运算符、循环的控制等，这些基础的语法知识就不再赘述了，本文着重是对比较重要的知识点进行总结，尤其是关于对象和数组这块的处理，因为对于前端来说，大多数数据不是对象(json)就是数组，所以掌握其中的一些api会事半功倍。</p><a id="more"></a><h2>一、数据类型</h2><p>虽然说定义变量都是<code>var</code>，但是其实是分为几种类型的，下面我们来看看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="string">'hello'</span>;</span><br><span class="line">     <span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">var</span> d;</span><br><span class="line">     <span class="keyword">var</span> e = alert;</span><br><span class="line">     <span class="keyword">var</span> f = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*基本数据类型*/</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> d);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> e);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>我们看到，可以用<code>typeof</code>来查看每个变量的类型，它们是：</p><p><img src="http://bloghello.oursnail.cn/js1-1.png" alt="image"></p><h2>二、无限大</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/*无限大以及NAN*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="number">3</span>*<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE/<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE*<span class="built_in">Number</span>.MAX_VALUE);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>/<span class="number">0</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>执行的结果是：</p><p><img src="http://bloghello.oursnail.cn/js1-2.png" alt="image"></p><p>我们看到，无穷与0想成则为NAN，就是说它也不知道这到底是啥玩意，其他的基本都是表示无限大的<code>Infinity</code></p><h2>三、函数参数问题</h2><p>在我们比较熟悉的静态语言比如C，C++以及Java中，调用函数的话，参数一定要明确，否则会出错。比如一个函数明明没有任何形参，但是你调用的时候硬生生地传递几个参数进去，那么编译的时候就会报错。但是js中是不会的。一个函数可以定义为无参，但是调用的时候，你可以添加几个参数进去，所以是动态的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//可以没有形式参数</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">         <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">             sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(add(a,b));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>所以上面这个程序是可以正常执行的。</p><h2>四、作用域问题</h2><p>如果是一个局部变量，那么在外面正常情况下是无法访问到的，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//作用域</span></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">             <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log(a);<span class="comment">//error</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这里的a就无法在函数外面访问到，因为这个a是函数f的内部局部变量，外面的只能访问全局变量。这也符合我们其他语言的规范，但是这里要注意，定义在<code>if</code>,<code>while</code>以及<code>for</code>代码块中的局部变量我们依然可以在外面访问到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">console</span>.log(a);<span class="comment">//ok</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2>五、数组如何定义</h2><p>数组是一种引用类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span>(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        alert(<span class="string">"arr 是数组"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>在对于传入的参数不清楚的情况下，我们可以先判断一下类型是不是符合我们的要求，这可以提高程序的健壮性，就像先判断是否为空再操作的原则。</p><h2>六、定义一个对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//第一种 new Object</span></span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    person.name = <span class="string">"fossi"</span>;</span><br><span class="line">    person.age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这跟java中定义形式几乎一样，访问它的属性也一样，就是<code>person.name</code>即可。</p><p>还有一种比较常用的定义对象的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//第二种 new Object</span></span><br><span class="line">    <span class="keyword">var</span> person = &#123;<span class="string">"name"</span>:<span class="string">"fossi"</span>,</span><br><span class="line">                  <span class="string">"age"</span>:<span class="number">20</span>,</span><br><span class="line">                  <span class="string">"fun"</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                     alert(<span class="string">"i am a person"</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">    person.fun();</span><br><span class="line">    <span class="built_in">console</span>.log(person[<span class="string">"age"</span>]);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>注意，一个函数也可以作为它的成员变量，类似于java中的成员方法。</p><h2>七、数组打印</h2><p>数组非常重要，掌握数组常用的技巧将事半功倍。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//opeartion of array</span></span><br><span class="line">    <span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"yellow"</span>,<span class="string">"blue"</span>];</span><br><span class="line">    colors[<span class="number">8</span>] = <span class="string">"pink"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    <span class="built_in">console</span>.log(colors.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.valueOf());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.toLocaleString());</span><br><span class="line">    <span class="built_in">console</span>.log(colors.join(<span class="string">"|"</span>));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这几个基本都是以不同的形式打印出数组来，最后一个是指用<code>|</code>来拼接数组元素再打印。</p><p><img src="http://bloghello.oursnail.cn/js1-3.png" alt="image"></p><h2>八、数组实现栈以及队列</h2><p>数组可以直接用<code>push</code>和<code>pop</code>实现栈的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//stack</span></span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    stack.push(<span class="string">"fossi"</span>);</span><br><span class="line">    stack.push(<span class="string">"vainda"</span>);</span><br><span class="line">    stack.push(<span class="string">"xiaoxu"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果也显而易见：</p><p><img src="http://bloghello.oursnail.cn/js1-4.png" alt="image"></p><p>下面再用数组来模拟队列，<code>shift()</code> 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值，也是非常简单的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//queue push+shift or unshift+pop</span></span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    queue.push(<span class="string">"fossi"</span>);</span><br><span class="line">    queue.push(<span class="string">"vainda"</span>);</span><br><span class="line">    queue.push(<span class="string">"xiaoxu"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">    <span class="built_in">console</span>.log(queue.shift());</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>打印结果也显而易见：</p><p><img src="http://bloghello.oursnail.cn/js1-6.png" alt="image"></p><h2>九、数组的拼接和删除</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"yellow"</span>,<span class="string">"blue"</span>,<span class="string">"pink"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.后面拼接一个元素进去</span></span><br><span class="line">    <span class="built_in">console</span>.log(colors.concat(<span class="string">"green"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.从0号开始删除一个元素</span></span><br><span class="line">    colors.splice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.从2号元素开始删除一个元素,再插入两个新元素</span></span><br><span class="line">    colors.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"black"</span>,<span class="string">"white"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(colors);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.根据元素获取下标索引</span></span><br><span class="line">    <span class="built_in">console</span>.log(colors.indexOf(<span class="string">"yellow"</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(colors.lastIndexOf(<span class="string">"yellow"</span>));<span class="comment">//不存在则返回-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.遍历数组</span></span><br><span class="line">    colors.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">        <span class="built_in">console</span>.log(index);</span><br><span class="line">        <span class="built_in">console</span>.log(array);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>关于第5个，每个参数都是啥呢？</p><p><img src="http://bloghello.oursnail.cn/js1-7.png" alt="image"></p><h2>十、数组的高级操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//全部都要满足条件，有一个不满足就返回false</span></span><br><span class="line">    <span class="keyword">var</span> flag = num.every(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//每一个item都必须小于4才返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> num &lt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(flag);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只要有一个满足条件即可，也是返回true或者false</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.some(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">         <span class="comment">//只要有一个满足条件即可</span></span><br><span class="line">        <span class="keyword">return</span> item &lt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//过滤出符合条件的值</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt; <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对每一个元素进行同样的操作</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> res = num.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item*<span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对元素进行统计</span></span><br><span class="line">    <span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> sum = num.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre,curr,index,array</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre+curr;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>前面的几个都比较好理解，最后两个可能比较抽象一点。其实这个在大数据中式比较常用的概念，比较典型的就是<code>MapReduce</code>这个组件，其实就是两个过程，一个是<code>map</code>一个是<code>reduce</code>，前者是对每个值进行相应的操作，后者是对这些处理完的值进行合并。从而达到一些数据统计的目的。比如这里，我对每个值简单乘以2，那么数组就变为<code>[2,8,4,12,16,6,2]</code>；下面一个实现的是求和功能，算出来是25.还可以进行很多的操作。</p><p>ok，后续其他的再学习，且记录到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js和其他的语言很像，很多的操作都是一样的，比如数值的运算符、循环的控制等，这些基础的语法知识就不再赘述了，本文着重是对比较重要的知识点进行总结，尤其是关于对象和数组这块的处理，因为对于前端来说，大多数数据不是对象(json)就是数组，所以掌握其中的一些api会事半功倍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>05-软件设计七大原则-接口隔离原则</title>
    <link href="http://yoursite.com/2019/03/19/design-pattern/05-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/03/19/design-pattern/05-软件设计七大原则-接口隔离原则/</id>
    <published>2019-03-19T11:06:56.699Z</published>
    <updated>2019-03-19T11:07:23.947Z</updated>
    
    <content type="html"><![CDATA[<p>本文来了解一下什么是接口隔离原则。</p><a id="more"></a><h2>定义</h2><ul><li>用多个专门的接口，而不适用单一的总接口，客户端不应该依赖它不需要的接口</li><li>一个类对一个类的依赖应该建立在最小的接口上</li><li>建立单一接口，不要建立庞大臃肿的接口</li><li>尽量细化接口，接口中的方法尽量少</li></ul><p>也就是说，我们提供接口的时候，只暴露需要的方法，而将不需要的方法隐藏起来。</p><h2>例子</h2><p>定义一个接口叫做动物行为接口，但是呢，由于没有细化，比如狗子，一旦实现这个接口，那就要实现所有的方法，包括它不会的飞翔。</p><p><img src="http://bloghello.oursnail.cn/uml5-1.png" alt="image"></p><p>将接口进行细化（这里要注意是要适当）。哪个要实现什么，就去实现，不需要的方法就可以不用去实现。</p><p>注意，接口隔离原则好像与上一章的单一职责原则有点像，这里说明一下区别：单一职责原则强调职责，一个class或者接口只负责一个职责，可以有很多的方法。但是接口隔离原则强调的是适当地设计接口，尽量地给不同的调用者适当的接口，不要设计的太臃肿，注重的是接口依赖的隔离。</p><p>这里强调适当，接口也不能太多，效果反而会适得其反。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来了解一下什么是接口隔离原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>04-软件设计七大原则-单一职责原则</title>
    <link href="http://yoursite.com/2019/03/19/design-pattern/04-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/03/19/design-pattern/04-软件设计七大原则-单一职责原则/</id>
    <published>2019-03-19T04:09:02.740Z</published>
    <updated>2019-03-19T04:09:28.971Z</updated>
    
    <content type="html"><![CDATA[<p>本文来了解一下什么是单一职责原则。</p><a id="more"></a><h2>定义</h2><p>假设一个类(class)中有两个职责，一个是指责A，一个是指责B，当我们修改A时，可能会导致B出现问题。就是说，职责A和职责B发生改变时都会影响这个class，从而使这个class可能发生变更。</p><p>解决方案：对于这两个指责分别建立class1和class2，使他们互相不影响。这个原则就是单一职责原则。</p><p>即一个类/接口/方法只负责一项职责。</p><p>好处：降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。</p><h2>例子</h2><p>单一职责原则是很好理解的，下面配以代码举一个小例子。</p><p>比如有一个类，描述的是鸟移动的模式，正常情况下鸟是飞的，但是如果传进来一只不会飞的鸟咋办呢，比如鸵鸟，这就需要判断一下了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdMoveMode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(birdName.equals(<span class="string">"鸵鸟"</span>))&#123;</span><br><span class="line">            System.out.println(birdName+<span class="string">"是跑的..."</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(birdName+<span class="string">"是飞的..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，最好是将这个类分离成两类，一个是会飞的，一个是走的：</p><p><img src="http://bloghello.oursnail.cn/um4-1.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyBird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        System.out.println(birdName+<span class="string">"是飞的..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WalkBird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String birdName)</span></span>&#123;</span><br><span class="line">        System.out.println(birdName+<span class="string">"是跑的..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于接口和方法也一样，接口里面的方法声明分开；方法重载来分开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来了解一下什么是单一职责原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题66-机器人的运动范围】</title>
    <link href="http://yoursite.com/2019/03/19/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9866-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/19/剑指offer/【面试题66-机器人的运动范围】/</id>
    <published>2019-03-19T03:55:00.344Z</published>
    <updated>2019-03-19T03:59:09.212Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十六题。</p><a id="more"></a><h2>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2>解题思路</h2><p>基本的思路是同上一题的，就不再赘述思路了。至此，《剑指offer》66题全部刷完，这是我第三遍刷了，很多答案进行了优化，总体上是把比较好的方案总结在这上面，而不是只贪图简单而采取暴力解法，那样达不到真正的目的。下面的刷题主要是围绕牛客网的《leetcode在线编程训练》进行练习，后面的刷题进度可能总体较慢。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//根据m行n列的方格，构造一个数组来标识是否已经判断过，已经判断过的话置为true，否则置为false</span></span><br><span class="line">        <span class="comment">//这里初始化默认是false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="comment">//下面开始走，边走边判断周围是否符合</span></span><br><span class="line">        <span class="comment">//judge(初始横坐标i，初始横坐标j，行数，列数，k值，标识是否走过)</span></span><br><span class="line">        <span class="keyword">return</span> judge(<span class="number">0</span>,<span class="number">0</span>,rows,cols,threshold,flag);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> threshold,<span class="keyword">boolean</span>[][] flag)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界、flsg=true说明已经走过，就不要再走了、行坐标和列坐标的数位之和大于k也跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || flag[i][j]==<span class="keyword">true</span> || getK(i)+getK(j)&gt;threshold)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//机器人从[0,0]出发，必定是满足的，先置为true,所以要先加个1</span></span><br><span class="line">        flag[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//基于回溯的思想，就是到达一个格子后，不断地判断他的周围四个格子是否满足要求，递归判断下去，必定走遍所有格子</span></span><br><span class="line">        <span class="keyword">return</span> judge(i-<span class="number">1</span>,j,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i,j-<span class="number">1</span>,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i+<span class="number">1</span>,j,rows,cols,threshold,flag)+</span><br><span class="line">                judge(i,j+<span class="number">1</span>,rows,cols,threshold,flag)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//计算数字每一位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getK</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            sum += num%<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>((num=num/<span class="number">10</span>) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题65-矩阵中的路径】</title>
    <link href="http://yoursite.com/2019/03/19/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9865-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/19/剑指offer/【面试题65-矩阵中的路径】/</id>
    <published>2019-03-19T03:27:52.563Z</published>
    <updated>2019-03-19T03:28:15.510Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十五题。</p><a id="more"></a><h2>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h2>解题思路</h2><p>回溯</p><p>基本思想：</p><p>0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次</p><p>1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge</p><p>2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组</p><p>3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通</p><p>4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的</p><p>5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。</p><p>6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//标志位，初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                 <span class="comment">//循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法</span></span><br><span class="line">                 <span class="keyword">if</span>(judge(matrix,i,j,rows,cols,flag,str,<span class="number">0</span>))&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">boolean</span>[] flag,<span class="keyword">char</span>[] str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//先根据i和j计算匹配的第一个元素转为一维数组的位置</span></span><br><span class="line">        <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || matrix[index] != str[k] || flag[index] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可</span></span><br><span class="line">        <span class="keyword">if</span>(k == str.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//要走的第一个位置置为true，表示已经走过了</span></span><br><span class="line">        flag[index] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回溯，递归寻找，每次找到了就给k加一，找不到，还原</span></span><br><span class="line">        <span class="keyword">if</span>(judge(matrix,i-<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i+<span class="number">1</span>,j,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j-<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>) ||</span><br><span class="line">           judge(matrix,i,j+<span class="number">1</span>,rows,cols,flag,str,k+<span class="number">1</span>)  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这，说明这一条路不通，还原，再试其他的路径</span></span><br><span class="line">        flag[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>02-分布式文件系统HDFS(一)</title>
    <link href="http://yoursite.com/2019/03/18/hadoop/02-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FHDFS(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/03/18/hadoop/02-分布式文件系统HDFS(一)/</id>
    <published>2019-03-18T09:40:05.844Z</published>
    <updated>2019-03-18T09:45:18.254Z</updated>
    
    <content type="html"><![CDATA[<p>从本文开始了解HDFS的基本原理，为后续的实际操作打下理论基础。</p><a id="more"></a><h2>HDFS概述及设计目标</h2><p>如果让我们自己设计一个分布式文件系统，如何来设计呢？可能会简单地这样想：为了保障数据稳定性，那么就可以多存几份，放在不同的节点上，这样，即使某个节点挂了，相应的数据还可以从其他地方读到，如下图所示：</p><p><img src="http://bloghello.oursnail.cn/hadoop2-1.png" alt="image"></p><p>我们看到，这样设计的好处是即使第一个存放数据的节点挂了，也不会有什么影响，后面其他的节点上还是有它的副本的。但是这样设计的缺点也很明显：</p><ul><li>不管文件多大，都存储在一个节点上，在进行数据处理的时候很难进行并行处理，节点可能就成为网络瓶颈，很难进行大数据的处理</li><li>存储负载很难均衡，每个节点的利用率很低</li></ul><p>HDFS是如何设计的呢？这里简单先说一下，它是先将每个文件进行拆分，默认是128兆，这些拆分出来的block也是多副本进行存储。这样，数据分布会比较均匀，并且可以并行处理，提高并行计算能力。</p><h2>HDFS设计目标</h2><ul><li>能构建非常巨大的分布式文件系统</li><li>运行在普通廉价的硬件上</li><li>易扩展、为用户提供性能不错的文件存储服务</li></ul><h2>HDFS架构</h2><p>我们来官网看看HDFS的架构以及说明，其中有一段描述是：</p><blockquote><p>HDFS has a master/slave architecture. An HDFS cluster consists of a single NameNode, a master server that manages the file system namespace and regulates access to files by clients. In addition, there are a number of DataNodes, usually one per node in the cluster, which manage storage attached to the nodes that they run on. HDFS exposes a file system namespace and allows user data to be stored in files. Internally, a file is split into one or more blocks and these blocks are stored in a set of DataNodes. The NameNode executes file system namespace operations like opening, closing, and renaming files and directories. It also determines the mapping of blocks to DataNodes. The DataNodes are responsible for serving read and write requests from the file system’s clients. The DataNodes also perform block creation, deletion, and replication upon instruction from the NameNode.</p></blockquote><p>首先，<font color="red">HDFS是一个主从的架构</font>，包含一个<code>NameNode</code>，它主要负责的是管理<code>namespace</code>以及用户访问的文件；此外，还包含一些<code>DataNodes</code>，主要是负责数据管理。</p><p><font color="red">命名空间的作用：</font>HDFS暴露一个文件系统命名空间允许用户数据保存在这里。<code>NameNode</code>执行系统命名空间操作比如打开、关闭、重命名文件以及目录。这个命名空间还确定了<code>block</code>到<code>DataNode</code>的映射。</p><p><font color="red"><code>DataNode</code>和<code>block</code>：</font>在内部，一个文件是被切割为多个<code>block</code>的，这些<code>block</code>是存储在一系列的<code>DataNode</code>上的。这些<code>DataNode</code>负责提供读写请求，还可以根据<code>NameNode</code>的指令进行<code>block</code>的创建、删除以及复制。</p><p>下面总结一下两者的功能：</p><ul><li><code>NameNode</code>（Master/NN）:<ul><li>负责客户端请求的响应</li><li>负责元数据（文件的名称、副本系数、block存放的DN）的管理</li></ul></li><li><code>DataNode</code>（Slaves/DN）:<ul><li>存储用户的文件对应的数据块（block）</li><li>要定期向NN发送心跳信息，汇报本身及其所有的block信息，健康状况</li></ul></li></ul><p>官网贴了一张架构图：</p><p><img src="http://bloghello.oursnail.cn/hadoop2-2.png" alt="image"></p><p>这里感觉有很多东西要额外注意，暂时先学习到这里。</p><h2>HDFS副本机制</h2><blockquote><p>HDFS supports a traditional hierarchical file organization. A user or an application can create directories and store files inside these directories. The file system namespace hierarchy is similar to most other existing file systems; one can create and remove files, move a file from one directory to another, or rename a file.</p></blockquote><p>HDFS支持传统的分层文件组织。 用户或应用程序可以在这些目录中创建目录并存储文件。 文件系统命名空间层次结构与大多数其他现有文件系统类似; 可以创建和删除文件，将文件从一个目录移动到另一个目录，或重命名文件。</p><blockquote><p>The NameNode maintains the file system namespace. Any change to the file system namespace or its properties is recorded by the NameNode. An application can specify the number of replicas of a file that should be maintained by HDFS. The number of copies of a file is called the replication factor of that file. This information is stored by the NameNode.</p></blockquote><p><code>NameNode</code>维护文件系统名称空间。 <code>NameNode</code>记录对文件系统命名空间或其属性的任何更改。 应用程序可以指定应由HDFS维护的文件的副本数。 文件的副本数称为该文件的复制因子。 该信息由<code>NameNode</code>存储。</p><blockquote><p>HDFS is designed to reliably store very large files across machines in a large cluster. It stores each file as a sequence of blocks. The blocks of a file are replicated for fault tolerance. The block size and replication factor are configurable per file.</p></blockquote><p>HDFS旨在可靠地在集群上存储非常大的文件。 它将每个文件切割为为一系列的块进行存储。这些块被复制成多个副本以达到一定的容错性。 块大小和复制因子可根据文件进行配置。</p><blockquote><p>An application can specify the number of replicas of a file. The replication factor can be specified at file creation time and can be changed later. Files in HDFS are write-once (except for appends and truncates) and have strictly one writer at any time.</p></blockquote><p>应用程序可以指定文件的副本数。 复制因子可以在文件创建时指定，并可以在以后更改。 HDFS中的文件是一次写入的（除了追加和删除），并且在任何时候都有一个在写入，也就是说不支持并发写。</p><blockquote><p>The NameNode makes all decisions regarding replication of blocks. It periodically receives a Heartbeat and a Blockreport from each of the DataNodes in the cluster. Receipt of a Heartbeat implies that the DataNode is functioning properly. A Blockreport contains a list of all blocks on a DataNode.</p></blockquote><p>它定期从群集中的每个<code>DataNode</code>接收<code>Heartbeat</code>和<code>Blockreport</code>。 收到心跳意味着<code>DataNode</code>正常运行。 <code>Blockreport</code>包含<code>DataNode</code>上所有块的列表。</p><p><img src="http://bloghello.oursnail.cn/hadoop2-3.png" alt="image"></p><h2>HDFS副本存放策略</h2><p>为了提高可用性，大型Hadoop集群以机架的形式来组织的，同一个机架上不同节点间的网络状况比不同机架之间更为理想。</p><p>那么副本是如何存储呢？</p><p><img src="http://bloghello.oursnail.cn/hadoop2-4.png" alt="image"></p><p>如图所示，这里以默认的三个副本为例子说明，一般策略是这样的：同一个机架的同一台机器上先放一个副本，然后不同机架随机选择两个机器放副本。这样，一旦其中一个机架挂了，另一个机架还可以继续工作。</p><p>至此，关于HDFS基础的理论都已经说明完毕了，下面就要来实际操作一把了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本文开始了解HDFS的基本原理，为后续的实际操作打下理论基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>【面试题64-滑动窗口的最大值】</title>
    <link href="http://yoursite.com/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9864-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/18/剑指offer/【面试题64-滑动窗口的最大值】/</id>
    <published>2019-03-18T04:19:13.557Z</published>
    <updated>2019-03-18T04:19:31.932Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十四题。</p><a id="more"></a><h2>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2>解题思路</h2><p>比较简单的思路是每次用一个<code>ArrayList</code>来存放窗口内的数，进行排序，然后得到最大的添加进外面的<code>ArrayList</code>中，最后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num.length == <span class="number">0</span> || size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (ArrayList)result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=num.length-size;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+size;j++)&#123;</span><br><span class="line">                list.add(num[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            result.add(list.get(size-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ArrayList)result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历再排序，时间复杂度还是挺高的，遍历一遍是不可避免的，优化点在于如何以O(1)的时间复杂度拿到当前窗口的最大值。下面介绍一下优化方法。</p><p>以输入数字{2,3,4,2,6,2,5,1}为例一步分析。</p><p>数组的第一个数字是 2，把它存入队列中。第二个数字是3.由于它比前一个数字 2 大，因此 2不可能成为滑动窗口中的最大值。2 先从队列里删除，再把3存入到队列中。此时队列中只有一个数字 3。针对第三个数字 4 的步骤类似，最终在队列中只剩下一个数字 4。此时滑动窗口中已经有 3 个数字，而它的最大值 4 位于队列的头部。</p><p>接下来处理第四个数字 2。2 比队列中的数字 4 小。当 4 滑出窗口之后 2 还是有可能成为滑动窗口的最大值，因此把 2 存入队列的尾部。现在队列中有两个数字 4 和 2，其中最大值 4 仍然位于队列的头部。</p><p>下一个数字是 6。由于它比队列中已有的数字 4 和 2 都大，因此这时 4 和 2 已经不可能成为滑动窗口中的最大值。先把 4 和 2 从队列中删除，再把数字 6 存入队列。这个时候最大值 6 仍然位于队列的头部。</p><p>第六个数字是 2。由于它比队列中已有的数字 6 小，所以 2 也存入队列的尾部。此时队列中有两个数字，其中最大值 6 位于队列的头部。</p><p>接下来的数字是 5。在队列中已有的两个数字 6 和 2 里，2 小于 5，因此 2 不可能是一个滑动窗口的最大值，可以把它从队列的尾部删除。删除数字 2 之后，再把数字 5 存入队列。此时队列里剩下两个数字 6 和 5，其中位于队列头部的是最大值 6。</p><p>数组最后一个数字是 1，把 1 存入队列的尾部。注意到位于队列头部的数字 6 是数组的第 5 个数字，此时的滑动窗口已经不包括这个数字了，因此应该把数字 6 从队列删除。那么怎么知道滑动窗口是否包括一个数字？<strong>应该在队列里存入数字在数组里的下标，而不是数值</strong>。当一个数字的下标与当前处理的数字的下标之差大于或者等于滑动窗口的大小时，这个数字已经从滑动窗口中滑出，可以从队列中删除了。</p><p><img src="http://bloghello.oursnail.cn/offer64.jpg" alt="image"></p><p>框框里的都是下标。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//存放当前窗口中最大值</span></span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//队列的头部存放的是当前窗口最大值</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length &lt;= <span class="number">0</span> || size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="comment">//比如当前数据比队尾的数字大，说明当前这个数字最起码在从现在起到后面的过程中可能是最大值</span></span><br><span class="line">            <span class="comment">//而之前队尾的数字不可能最大了，所以要删除队尾元素。</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; num[queue.peekLast()] &lt; num[i])&#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            <span class="comment">//队头的元素是否超过窗口的范围</span></span><br><span class="line">            <span class="keyword">if</span>(queue.peekFirst() == i-size)&#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在包含了三个元素之后才开始记录，其中最大值就在队列的头部</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= size - <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(num[queue.peekFirst()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题63-数据流中的中位数】</title>
    <link href="http://yoursite.com/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9863-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/18/剑指offer/【面试题63-数据流中的中位数】/</id>
    <published>2019-03-18T02:39:33.366Z</published>
    <updated>2019-03-18T02:39:57.320Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十三题。</p><a id="more"></a><h2>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h2>解题思路</h2><ul><li>先用java集合<code>PriorityQueue</code>来设置一个小顶堆和大顶堆</li><li>主要的思想是：因为要求的是中位数，那么这两个堆，<strong>大顶堆用来存较小的数，从大到小排列</strong>；<br><strong>小顶堆存较大的数，从小到大的顺序排序</strong>，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。</li><li>⭐保证：小顶堆中的元素都大于等于大顶堆中的元素，所以每次塞值，并不是直接塞进去，而是从另一个堆中poll出一个最大（最小）的塞值</li><li>⭐当数目为偶数的时候，将这个值插入大顶堆中，再将大顶堆中根节点（即最大值）插入到小顶堆中；</li><li>⭐当数目为奇数的时候，将这个值插入小顶堆中，再讲小顶堆中根节点（即最小值）插入到大顶堆中；</li><li>⭐取中位数的时候，如果当前个数为偶数，显然是取小顶堆和大顶堆根结点的平均值；如果当前个数为奇数，显然是取小顶堆的根节点</li></ul><p>理解了上面所述的主体思想，下面举个例子辅助验证一下。</p><p>例如，传入的数据为：[5,2,3,4,1,6,7,0,8],那么按照要求，输出是&quot;5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 &quot;</p><p>那么整个程序的执行流程应该是（用min表示小顶堆，max表示大顶堆）：</p><ul><li>5先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[<font color="red">5</font>],max=[无]，avg=[5.00]</li><li>2先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[<font color="red">5</font>],max=[<font color="red">2</font>],avg=[(5+2)/2]=[3.50]</li><li>3先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[<font color="red">3</font>,5],max=[2],avg=[3.00]</li><li>4先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[<font color="red">4</font>,5],max=[<font color="red">3</font>,2],avg=[(4+3)/2]=[3.50]</li><li>1先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[<font color="red">3</font>,4,5],max=[2,1]，avg=[3/00]</li><li>6先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[<font color="red">4</font>,5,6],max=[<font color="red">3</font>,2,1],avg=[(4+3)/2]=[3.50]</li><li>7先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[<font color="red">4</font>,5,6,7],max=[3,2,1],avg=[4]=[4.00]</li><li>0先进入小顶堆，然后将小顶堆中最大值放入小顶堆中，此时min=[<font color="red">4</font>,5,6,7],max=[<font color="red">3</font>,2,1,0],avg=[(4+3)/2]=[3.50]</li><li>8先进入大顶堆，然后将大顶堆中最小值放入大顶堆中，此时min=[<font color="red">4</font>,5,6,7,8],max=[3,2,1,0],avg=[4.00]</li></ul><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">//大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录偶数个还是奇数个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次插入小顶堆的是当前大顶堆中最大的数</span></span><br><span class="line">    <span class="comment">//每次插入大顶堆的是当前小顶堆中最小的数</span></span><br><span class="line">    <span class="comment">//这样保证小顶堆中的数永远大于等于大顶堆中的数</span></span><br><span class="line">    <span class="comment">//中位数就可以方便地从两者的根结点中获取了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//个数为偶数的话，则先插入到大顶堆，然后将大顶堆中最大的数插入小顶堆中</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> max = maxHeap.poll();</span><br><span class="line">            minHeap.offer(max);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//个数为奇数的话，则先插入到小顶堆，然后将小顶堆中最小的数插入大顶堆中</span></span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> min = minHeap.poll();</span><br><span class="line">            maxHeap.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前为偶数个，则取小顶堆和大顶堆的堆顶元素求平均</span></span><br><span class="line">        <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek() + maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前为奇数个，则直接从小顶堆中取元素即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题62-二叉搜索树的第k个结点】</title>
    <link href="http://yoursite.com/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9862-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/18/剑指offer/【面试题62-二叉搜索树的第k个结点】/</id>
    <published>2019-03-18T01:22:44.681Z</published>
    <updated>2019-03-18T01:25:38.450Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十二题。</p><a id="more"></a><h2>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><h2>解题思路</h2><p>二叉搜索树的中序遍历就是其排序好的序列，然后取第k个值即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list = fun(pRoot);</span><br><span class="line">        <span class="keyword">if</span>(k&gt;list.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LinkedList&lt;TreeNode&gt; <span class="title">fun</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fun(root.left);</span><br><span class="line">            list.add(root);</span><br><span class="line">            fun(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>01-初识Hadoop</title>
    <link href="http://yoursite.com/2019/03/15/hadoop/1.%E5%88%9D%E8%AF%86Hadoop/"/>
    <id>http://yoursite.com/2019/03/15/hadoop/1.初识Hadoop/</id>
    <published>2019-03-15T09:24:24.454Z</published>
    <updated>2019-03-15T09:31:23.220Z</updated>
    
    <content type="html"><![CDATA[<p>关于大数据的学习终于开始了，对java后台开发比较熟悉的同学会发现，部分的组件比如zookeeper就是从Hadoop生态圈中诞生的，但是纵观hadoop的生态圈，大多数还是比较陌生，本节来说一说比较核心的组件，找到学习的入口。</p><a id="more"></a><h2>一、概述</h2><p>我们来到它的官网来看看Hadoop到底是什么。</p><p><img src="http://bloghello.oursnail.cn/hadoop1-1.png" alt="image"></p><p>大概就是说：Haadoop项目旨在发展可靠的、可扩展的、分布式计算的开源软件。允许用简单的编程跨越集群来分布式处理大数据集。可以从单体服务扩展到上千台机器，每个机器都可以提供本地计算和存储。相比于依赖硬件来保证高可用，Hadoop是在应用层监测和处理错误从而保证可靠性，允许单个机器出现故障。</p><p>可以看到，Hadoop旨在提供高可用、可扩展、分布式计算一种能力，是应对海量数据的存储以及处理的一个方案。</p><p>这个<code>Hadoop project</code>包含了几个核心的子模块：</p><ul><li>Hadoop Common: 为其他的模块提供基础支持。</li><li>Hadoop Distributed File System (HDFS™): 一个高吞吐量的分布式文件系统</li><li>Hadoop YARN: 一个作业调度和集群资源管理的框架</li><li>Hadoop MapReduce: 基于YARN实线的用于并行处理大数据集的系统</li></ul><h2>二、核心组件之HDFS</h2><ul><li>源自于谷歌的GFS论文，论文发表于2003年10月</li><li>HDFS是GFS的克隆版</li><li>HDFS特点：扩展性&amp;容错性&amp;海量数据存储</li></ul><p>HDFS是一种分布式文件系统，文件系统是什么，我们需要知道他的基本功能是：管理和调度文件的存储空间，提供文件的逻辑结构、物理结构和存储方法;实现文件从标识到实际地址的映射。也就是对文件进行管理和调度的。</p><p>海量的数据，我们需要良好的扩展性来存放，也需要容错性来防止数据丢失，因此HDFS是在文件系统基本要求的基础上，实现更可靠的存储。</p><p>这里简单说一下的它的容错性是如何做到的：将文件切分为指定带线啊哦的数据块并以多副本的方式存储在多个机器上，而数据切分、多副本、容错等操作对用户是透明的。</p><h2>三、核心组件之资源调度系统YARN</h2><ul><li>负责整个集群资源的管理和调度：比如有一个作业要提交上来执行，需要占用多少CPU，多少内存都是YARN来计算完成的。</li><li>具有扩展性&amp;容错性&amp;多框架资源统一调度</li></ul><p>这里注意，YARN可以为上层应用提供统一的资源管理和调度，是什么意思呢？</p><p><img src="http://bloghello.oursnail.cn/hadoop1-2.png" alt="image"></p><p>这张图从下面开始，<code>HDFS2</code>其实就是表示<code>hadoop2.x</code>，他是做存储的，往上看有一个<code>YARN</code>，他就是做集群的资源管理的（<code>cluster resource management</code>），再往上看，对于批处理我们可以用<code>mapreduce</code>这种执行引擎，对于交互式的我们可以使用<code>tez</code>，在线的我们可以使用<code>hbase</code>，流处理可以采用<code>storm</code>，图计算用<code>giraph</code>，内存式的计算我们可以使用<code>spark</code>。。。。。</p><p>有了<code>YARN</code>之后就可以执行不同类型的计算框架，我们可以把<code>YARN</code>理解为操作系统级别的资源调度框架，可以让更多的计算框架<code>mapreduce</code>，<code>spark</code>，<code>storm</code>等等都运行在同一个集群里面，而且不同的计算框架可以共享同一个<code>hdfs</code>上的数据，享受整体的资源调度。</p><h2>四、核心组件之分布式计算框架MapReduce</h2><p>也是根据谷歌的论文实线的。不再赘述。下面我们来看看它是如何简单地统计单词出现频率的：</p><p><img src="http://bloghello.oursnail.cn/hadoop1-3.png" alt="image"></p><p>这是比较经典的一个案例。</p><p>大概是分成下面几个环节：</p><ul><li>Map阶段<ul><li>主要完成<code>key-value</code>对生成，这里是每看到一个单词，就输出(单词，1)的kv对</li></ul></li><li>排序阶段<ul><li>对刚才的kv对进行排序，这样相同单词就在一块儿了</li></ul></li><li>Reduce阶段<ul><li>对同一个单词的次数进行汇总，得到(词，频次)对</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/hadoop1-4.png" alt="image"></p><h2>五、Hadoop优势</h2><ul><li>高可用性：<ul><li>数据存储：数据块多副本</li><li>数据计算：发生异常的时候会重新调度作业计算</li></ul></li><li>高扩展性<ul><li>可以横向增加机器</li></ul></li><li>其他<ul><li>可以存储在廉价机器上，降低成本</li><li>成熟的生态圈</li></ul></li></ul><h2>六、狭义Hadoop和广义Hadoop</h2><p>狭义上的Hadoop：是一个适合大数据分布式存储(HDFS)、分布式计算(MapReduce)和资源调度(YARN)的平台。</p><p>广义上的Hadoop：指的是Hadoop生态系统。我们要知道，完成一些任务仅靠上面几个是不够的，比如<code>MapReduce</code>只能做离线批处理，要想做实时计算时无法完成的，所以需要其他的软件来完成。Hadoop生态系统是一个很庞大的概念，Hadoop是其中最重要最基础的一个部分；生态系统中的每一个子系统只解决某一个特定的问题域，不搞统一型的一个全能系统，而实小而精的多个小系统。</p><h2>七、Hadoop生态圈介绍</h2><p><img src="http://bloghello.oursnail.cn/hadoop1-5.png" alt="image"></p><p>我们从图中可以大概知道每个组件的用途。下面我们来简单说一说。</p><p><code>HDFS</code>是<code>GFS</code>的一种实现，他的完整名字是分布式文件系统，类似于<code>FAT32</code>，<code>NTFS</code>，是一种文件格式，是底层的。</p><p><code>Hive</code>与<code>Hbase</code>的数据一般都存储在<code>HDFS</code>上。<code>hadoop HDFS</code>为他们提供了高可靠性的底层存储支持。</p><p><code>hive</code>不支持更改数据的操作，<code>Hive</code>基于数据仓库，提供静态数据的动态查询。其使用类SQL语言，底层经过编译转为<code>MapReduce</code>程序，在<code>Hadoop</code>上运行，数据存储在<code>HDFS</code>上。</p><p><code>Hbase</code>是<code>Hadoop database</code>，即<code>Hadoop</code>数据库。它是一个适合于非结构化数据存储的数据库，<code>HBase</code>基于列的而不是基于行的模式。</p><p><code>HBase</code>是<code>Google Bigtable</code>的开源实现，类似<code>Google Bigtable</code>利用<code>GFS</code>作为其文件存储系统，<code>HBase</code>利用<code>Hadoop HDFS</code>作为其文件存储系统；<code>Google</code>运行<code>MapReduce</code>来处理<code>Bigtable</code>中的海量数据，<code>HBase</code>同样利用<code>Hadoop MapReduce</code>来处理<code>HBase</code>中的海量数据。</p><p><code>Pig</code>的语言层包括一个叫做<code>PigLatin</code>的文本语言,<code>Pig Latin</code>是面向数据流的编程方式。<code>Pig</code>和<code>Hive</code>类似更侧重于数据的查询和分析，底层都是转化成<code>MapReduce</code>程序运行。</p><p><code>Pig</code>和<code>Hive</code>的区别是<code>Hive</code>是类SQL的查询语言，要求数据存储于表中，而Pig是面向数据流的一个程序语言。</p><p>总结：</p><p><code>Hadoop HDFS</code>为<code>HBase</code>提供了高可靠性的底层存储支持，<code>Hadoop MapReduce</code>为<code>HBase</code>提供了高性能的计算能力，<code>Zookeeper</code>为<code>HBase</code>提供了稳定服务和<code>failover</code>机制(<code>zookeeper</code> = 通知机制 + 文件系统)。<code>Pig</code>和<code>Hive</code>还为<code>HBase</code>提供了高层语言支持，使得在<code>HBase</code>上进行数据统计处理变的非常简单。</p><h2>八、选型</h2><ul><li>Apache Hadoop</li><li>CDH:Cloudera Distributed Hadoop</li><li>HDP:Hortonworks Data Platform</li></ul><p>优先选择CDH，比较全，解决了版本冲突问题。</p><h2>九、总结</h2><p>我们可以看到，Hadoop的生态圈是极其庞大的，每个组件都是小而精，是为了解决特定问题而产生的，因此需要具体情况具体分析选用什么组件，也需要对核心的组件原理和使用了如指掌，下面我们先逐个来学习一下狭义Hadoop核心组件，从HDFS开始。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于大数据的学习终于开始了，对java后台开发比较熟悉的同学会发现，部分的组件比如zookeeper就是从Hadoop生态圈中诞生的，但是纵观hadoop的生态圈，大多数还是比较陌生，本节来说一说比较核心的组件，找到学习的入口。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>【面试题61-序列化二叉树】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9861-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题61-序列化二叉树】/</id>
    <published>2019-03-15T07:26:00.625Z</published>
    <updated>2019-03-15T07:26:21.175Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十一题。</p><a id="more"></a><h2>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h2>解题思路</h2><p>比较简单的解题思路是：层序遍历二叉树，将这遍历结果组装成字符串，那么序列化就完成了。下面就是根据这个字符串想办法再还原为原来的二叉树。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//层序遍历放进StringBuilder中，空的则为#</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                sb.append(node.val+<span class="string">","</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="string">"#,"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() != <span class="number">0</span>)&#123;</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.trim().length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析StringBuilder，拆分为数组</span></span><br><span class="line">        String[] strChar = str.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//新建一个一样长度的TreeNode类型的数组</span></span><br><span class="line">        TreeNode[] nodeArr = <span class="keyword">new</span> TreeNode[strChar.length];</span><br><span class="line">        <span class="comment">//将不为#的字符都转为TreeNode类型，为#的则默认为Null</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strChar.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!strChar[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">                nodeArr[i] = <span class="keyword">new</span> TreeNode(Integer.valueOf(strChar[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次遍历，还原二叉树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;strChar.length&amp;&amp;j&lt;strChar.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodeArr[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nodeArr[i].left = nodeArr[j++];</span><br><span class="line">                nodeArr[i].right = nodeArr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题60-把二叉树打印成多行】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9860-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题60-把二叉树打印成多行】/</id>
    <published>2019-03-15T04:01:14.697Z</published>
    <updated>2019-03-15T04:01:38.691Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六十题。</p><a id="more"></a><h2>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2>解题思路</h2><p>一开始我以为就是简单的层序遍历嘛：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.pop();</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用例:</span><br><span class="line">&#123;8,6,10,5,7,9,11&#125;</span><br><span class="line"></span><br><span class="line">对应输出应该为:</span><br><span class="line"></span><br><span class="line">[[8],[6,10],[5,7,9,11]]</span><br><span class="line"></span><br><span class="line">你的输出为:</span><br><span class="line"></span><br><span class="line">[[8],[6],[10],[5],[7],[9],[11]]</span><br></pre></td></tr></table></figure><p>事实上，这里需要将在同一层的数放到一个集合之中，所以还需要加工一下才行。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.add(pRoot);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先把root放进结果集</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(pRoot.val);</span><br><span class="line">        res.add(list);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//统计一下当前队列中的个数，因为当前队列中存放的都是同一层的数据</span></span><br><span class="line">            <span class="comment">//所以需要对这一层进行处理</span></span><br><span class="line">            <span class="keyword">int</span> num = queue.size();</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node = queue.pop();</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(node.left.val);</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                    list.add(node.right.val);</span><br><span class="line">                &#125;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题59-按之字形顺序打印二叉树】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9859-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题59-按之字形顺序打印二叉树】/</id>
    <published>2019-03-15T03:35:42.514Z</published>
    <updated>2019-03-15T03:36:02.923Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十九题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2>解题思路</h2><p>思路是搞两个栈，一个栈专门保存奇数层数据，一个栈专门保存偶数层数据。注意保存的顺序，保存偶数层的时候是从左到右，保存奇数层的时候从右到左。这样依次出栈的时候顺序是第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，依次类推。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//存放奇数层</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack1.push(pRoot);</span><br><span class="line">        <span class="comment">//存放偶数层</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(layer%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//说明是奇数层</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                    TreeNode tmp = stack1.pop();</span><br><span class="line">                    <span class="keyword">if</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(tmp.val);</span><br><span class="line">                        stack2.push(tmp.left);</span><br><span class="line">                        stack2.push(tmp.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    layer++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明是偶数层</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">                    TreeNode tmp = stack2.pop();</span><br><span class="line">                    <span class="keyword">if</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(tmp.val);</span><br><span class="line">                        stack1.push(tmp.right);</span><br><span class="line">                        stack1.push(tmp.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    layer++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题58-对称的二叉树】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9858-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题58-对称的二叉树】/</id>
    <published>2019-03-15T03:02:08.386Z</published>
    <updated>2019-03-15T03:14:05.098Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十八题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2>解题思路</h2><p>递归下去，不赘述了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> judge(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左子树为空的话，右子树必须为空才符合条件</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (right == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树不为空，右子树为空了，false</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右结点的值不相等则false</span></span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归下去</span></span><br><span class="line">        <span class="keyword">return</span> judge(left.right,right.left) &amp;&amp; judge(left.left,right.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题57-二叉树的下一个结点】</title>
    <link href="http://yoursite.com/2019/03/15/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9857-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/15/剑指offer/【面试题57-二叉树的下一个结点】/</id>
    <published>2019-03-15T02:31:46.627Z</published>
    <updated>2019-03-15T02:33:03.847Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十七题。</p><a id="more"></a><h2>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2>解题思路</h2><p>我们对于中序排序的规则已经很熟悉，下面图示:</p><p><img src="http://bloghello.oursnail.cn/suanfa6-8.png" alt="image"></p><p>我们从这个图上可以看到，找下一个节点是可以分为几种情况的。</p><p>第一种情况，就是一个节点有右子树。比如要求节点B的下一个节点，其实是找到它的右子树的最左孩子，就是G节点。</p><p>第二种情况，就是一个节点没有右子树，此时又可以分为两种情况。</p><p>对于G这个节点来说，没有右子节点了，它的父亲节点是E，G是E的左子节点，即E的左子节点是G，那么G的下一个节点就是E。</p><p>对于E这个节点来说，也没有右子节点，它的父亲节点是B，此时E是B的右子节点，根据实际情况来说，E的下一个节点绝对不是B，因为E是B的右子节点，根据中序遍历的规则，此时肯定是先遍历B再遍历E，所以B肯定在E的前面，而不是后面，所以我们还需要再往上找父亲节点，此时B的父亲节点为A，B为A的左子节点，此时根据实际情况，A就是我们要找的E的下一个节点。</p><p>所以，对于一个没有右子节点的节点来说，只需要判断它有没有父节点并且是不是父节点的左子节点，是的话，就找到了，不是则要不断地向上找。</p><p>如果一直找到根还是找不到，像节点F，那就返回null，因为实际上F节点就是中序遍历的最后一个节点，没有所谓的下一个节点了。</p><p>将上面所述转换为图示为：</p><p><img src="http://bloghello.oursnail.cn/suanfa6-9.png" alt="image"></p><p>总之，我们不关心当前节点的左子节点，因为它不在我们的考虑范围内，它必定出现在当前节点的前面。</p><p>我们主要就是考虑有没有右子节点，或者没有右子节点的话就考虑父亲节点。有右子节点比较简单，一直找最左边的子节点即可。但是没有右子节点的时候，就需要去查询父亲节点了。理解了这些，程序也就呼之欲出了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.判断当前节点是否有右子节点，有则去里面找</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> firstInRightTree(pNode);</span><br><span class="line">        <span class="comment">//2.没有右子节点，就需要去父节点找</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3.直到找到符合条件的父节点为止，跳出循环时pNode的父节点符合条件，这个父节点就是我们要的东西</span></span><br><span class="line">            <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span> &amp;&amp; pNode.next.left != pNode)&#123;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//到右子树中找符合条件的，显然就是找最最最左边的子节点即可</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeLinkNode <span class="title">firstInRightTree</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        TreeLinkNode curr = pNode.right;</span><br><span class="line">        <span class="keyword">while</span>(curr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题56-删除链表中重复的结点】</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9856-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/14/剑指offer/【面试题56-删除链表中重复的结点】/</id>
    <published>2019-03-14T12:44:16.412Z</published>
    <updated>2019-03-14T12:44:37.359Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十六题。</p><a id="more"></a><h2>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><h2>解题思路</h2><p>我的解题思路就是新建一个头节点，因为最极端的情况是，全部都相等，不搞一个新结点处理起来会比较麻烦。当遇到当前结点<code>curr</code>等于下一个节点<code>curr.next</code>的时候，则保存<code>curr.val</code>为<code>val</code>，拿这个值不停地与<code>curr.next</code>的值比较，找出一串等于<code>curr.val</code>的结点（因为是排序的，所以相等的肯定聚集在一起），直到<code>curr.next.val != val</code>的值，此时<code>curr = curr.next</code>,<code>dummy.next = curr</code>即可，这一串等于<code>val</code>的值就全部删除掉了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个结点,next指向pHead</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = pHead;</span><br><span class="line">        <span class="comment">//新建一个指向pHead的指针</span></span><br><span class="line">        ListNode curr = pHead;</span><br><span class="line">        <span class="comment">//临时指针，保存dummy初始状态</span></span><br><span class="line">        ListNode newHead = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前结点的指不等于下一个结点的之，curr和dummy都往后移动一格</span></span><br><span class="line">            <span class="keyword">if</span>(curr.val != curr.next.val)&#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                dummy = dummy.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//等于记录当前值，不停地找下一个，直至不相等为止，这一段就可以直接去除掉了</span></span><br><span class="line">                <span class="keyword">int</span> val = curr.val;</span><br><span class="line">                <span class="keyword">while</span>(curr.next != <span class="keyword">null</span> &amp;&amp; val == curr.next.val)&#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                dummy.next = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>03-软件设计七大原则-依赖倒置原则</title>
    <link href="http://yoursite.com/2019/03/14/design-pattern/03-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/03/14/design-pattern/03-软件设计七大原则-依赖倒置原则/</id>
    <published>2019-03-14T12:09:46.299Z</published>
    <updated>2019-03-14T12:10:26.775Z</updated>
    
    <content type="html"><![CDATA[<p>本文来了解一下什么是依赖倒置原则。</p><a id="more"></a><h2>定义</h2><ul><li>定义：高层模块不应该依赖底层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>针对接口编程，不要针对实现编程</li><li>优点：减少耦合性，提高稳定性</li></ul><h2>例子</h2><p>比如我叫swg，我学习java的课程，也要学习前端的课程，如何写呢？</p><p><img src="http://bloghello.oursnail.cn/um3-1.png" alt="image"></p><h2>第一个版本-V1</h2><p>最直接的，就是写一个类，里面写两个方法，一个学习java，一个学习前端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyCourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyJava</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"swg is studying java..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyFE</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"swg is studying fe..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，调用就是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StudyCourse studyCourse = <span class="keyword">new</span> StudyCourse();</span><br><span class="line">        studyCourse.studyJava();</span><br><span class="line">        studyCourse.studyFE();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此时，我又要学python了，那么咋办呢？直接在<code>studyCourse</code>中再新增一个方法？</p><p>那么，就会违背依赖倒置原则，即高层模块不应该依赖于低层模块。也就是说，我不能面向实现编程。</p><h2>第二个版本-V2</h2><p>我们应该面向接口编程，达到高层与低层实现解耦的目的。首先定义一个课程接口，里面一个声明是<code>study()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果是java课，就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Swg is stydying java..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是前端课就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FECourse</span> <span class="keyword">implements</span> <span class="title">ICourse</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Swg is stydying FE..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意的课程都可以取拓展。。。</p><p>那么，如何实现调用类，即高层与这些具体的实现类解耦呢？这里直接传入一个接口类型的参数进去，高层只要调用这个接口的某一种实现类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">studyCourse</span><span class="params">(ICourse iCourse)</span> </span>&#123;</span><br><span class="line">        iCourse.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Swg swg = <span class="keyword">new</span> Swg();</span><br><span class="line">        swg.studyCourse(<span class="keyword">new</span> JavaCourse());</span><br><span class="line">        swg.studyCourse(<span class="keyword">new</span> FECourse());</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>第三个版本-V3</h2><p>上面是用参数传进去，我们还可以用构造函数的方式传入，主要是修改<code>Swg</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ICourse iCourse;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Swg</span><span class="params">(ICourse iCourse)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iCourse = iCourse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iCourse.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Swg swg = <span class="keyword">new</span> Swg(<span class="keyword">new</span> JavaCourse());</span><br><span class="line">        swg.study();</span><br><span class="line">        swg = <span class="keyword">new</span> Swg(<span class="keyword">new</span> FECourse());</span><br><span class="line">        swg.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>第四个版本-V4</h2><p>我们还可以用<code>set</code>进行注入，具体为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ICourse iCourse;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setiCourse</span><span class="params">(ICourse iCourse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iCourse = iCourse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        iCourse.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来了解一下什么是依赖倒置原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题55-链表中的入口结点】</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9855-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/14/剑指offer/【面试题55-链表中的入口结点】/</id>
    <published>2019-03-14T10:21:29.731Z</published>
    <updated>2019-03-14T10:21:57.110Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十五题。</p><a id="more"></a><h2>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><h2>解题思路</h2><blockquote><p>定理：两个指针一个fast、一个slow同时从一个链表的头部出发</p></blockquote><blockquote><p>fast一次走2步，slow一次走一步，如果该链表有环，两个指针必然在环内相遇</p></blockquote><blockquote><p>此时只需要把其中的一个指针重新指向链表头部，另一个不变（还在环内），</p></blockquote><blockquote><p>这次两个指针一次走一步，相遇的地方就是入口节点。</p></blockquote><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空链表或者一个节点肯定没有环</span></span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode fast = pHead;</span><br><span class="line">    ListNode slow = pHead;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fast一次跳两个节点，slow一次跳一个节点</span></span><br><span class="line">    <span class="comment">//若有环，一定相遇，在环的某个节点停住</span></span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个重新指向头，一个不动，相遇点就是入口节点</span></span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题54-字符流中第一个不重复的字符】</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9854-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/14/剑指offer/【面试题54-字符流中第一个不重复的字符】/</id>
    <published>2019-03-14T09:59:51.334Z</published>
    <updated>2019-03-14T10:00:14.407Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十四题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。</p><h2>解题思路</h2><p>常规的解法是用一个map来存储，这样空间复杂度为O(n)，然后每次都遍历map获取第一个不重复的字符，时间复杂度也为O(n)。下面显示i代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用有序的Map：LinkedHashMap来存放char，并且记录其出现次数</span></span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;Character,Integer&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(ch))&#123;</span><br><span class="line">            map.put(ch,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(ch,map.get(ch)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.get(ch);</span><br><span class="line">            <span class="comment">//目前第一个只出现一次的字符，返回</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种很容易想到，但是能不能再优化一点呢？我们知道，ASCII码一共只有128个字符，那么我可以直接定义一个长度为128的数组，空间复杂度为O(n)，时间复杂度控制在常数级别，虽然我获取第一个只出现一次的元素需要一个while循环，但是这个循环不可能超过128，一般很快就可以拿到。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//英文字符不会逃出128个ascii码的范围，所以定义这个长度的数组</span></span><br><span class="line">    <span class="comment">//第一个ASCII码是一个空字符，所以我都是相对于` `进行一一排列</span></span><br><span class="line">    <span class="comment">//比如数字'0'是30，那'0'-''等于30，就存在tmp[30]这个地方即可</span></span><br><span class="line">    <span class="comment">//注意，tmp存的是出现的子树，即'0'出现了两次，那么tmp[30]就是2</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//维护一个队列，只保存一次进来的元素，重复的丢掉</span></span><br><span class="line">    LinkedList&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//第一次进来的元素放进队列尾部</span></span><br><span class="line">        <span class="keyword">if</span>(tmp[ch-<span class="string">' '</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            queue.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进来一次，就对相应坐标加一，统计出出现次数</span></span><br><span class="line">        tmp[ch-<span class="string">' '</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//取得时候是从队列得头部取，因为头部是比较早的数据</span></span><br><span class="line">        <span class="comment">//出现次数大于等于2的话就不断丢弃，知道找到第一个出现次数为1的字符跳出循环</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; tmp[queue.getFirst()-<span class="string">' '</span>]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            queue.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿到这个第一个只出现一次的字符</span></span><br><span class="line">        <span class="keyword">if</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.getFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿不到了，说明没有只出现一次的字符，那么就返回#</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题53-表示数值的字符串】</title>
    <link href="http://yoursite.com/2019/03/14/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9853-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/14/剑指offer/【面试题53-表示数值的字符串】/</id>
    <published>2019-03-14T09:13:38.371Z</published>
    <updated>2019-03-14T09:15:57.788Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五十三题。</p><a id="more"></a><h2>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,“5e2”,&quot;-123&quot;,“3.1416&quot;和”-1E-16&quot;都表示数值。 但是&quot;12e&quot;,“1a3.14”,“1.2.3”,&quot;±5&quot;和&quot;12e+4.3&quot;都不是。</p><h2>解题思路</h2><ol><li><code>12e</code>说明e的后面必须有数字，不能有两个e</li><li><code>+-5</code>说明符号位要么出现一次在首位，要么出现一次在e的后一位，其他地方都不能有</li><li><code>12e4.3</code>说明e的后面不能有小数，<code>1.2.3</code>说明不能有两个小数点</li><li><code>1a3.14</code>说明不能有其他的非法字符，比如这里的<code>a</code></li></ol><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//signal表示符号，decimal表示小树点，hasE表示含有符号e</span></span><br><span class="line">        <span class="keyword">boolean</span> signal = <span class="keyword">false</span>,decimal = <span class="keyword">false</span>,hasE = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">'E'</span> || str[i] == <span class="string">'e'</span>)&#123;</span><br><span class="line">                <span class="comment">//e后面必须有数字，所以是最后一位肯定不通过</span></span><br><span class="line">                <span class="keyword">if</span>(i==str.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不能有两个e</span></span><br><span class="line">                <span class="keyword">if</span>(hasE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hasE = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'+'</span> || str[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="comment">//不是第一次出现，那么后面能出现符合的地方只有紧贴着e的后面一位，不是则不通过</span></span><br><span class="line">                <span class="keyword">if</span>(signal &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次出现，如果不是出现在第一位，那么还是判断一下是不是出现在e的后面一位</span></span><br><span class="line">                <span class="keyword">if</span>(!signal &amp;&amp; i&gt;<span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'E'</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">'e'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                signal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="comment">//如果存在e并且e后面为小数则不通过</span></span><br><span class="line">                <span class="keyword">if</span>(hasE)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(str[i] == <span class="string">'e'</span> || str[i] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不能有两个小数点</span></span><br><span class="line">                <span class="keyword">if</span>(decimal)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                decimal = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="comment">//不是e也不是+-符号也不是小数点，那么只能是数字，不是数字就是非法的字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
