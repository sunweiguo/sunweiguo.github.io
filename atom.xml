<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-08T06:10:40.248Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【面试题24-二叉树中和为某一值的路径】</title>
    <link href="http://yoursite.com/2019/03/08/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9824-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/08/剑指offer/【面试题24-二叉树中和为某一值的路径】/</id>
    <published>2019-03-08T06:10:22.801Z</published>
    <updated>2019-03-08T06:10:40.248Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第二十三题。</p><a id="more"></a><h2>题目描述</h2><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h2>解题思路</h2><p>递归到叶子节点，每次递归都减掉当前节点的值，到最后剩下的值与叶子结点是否相等。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//保存多条路径，每条路径是值的集合</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths =<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        find(paths,<span class="keyword">new</span> ArrayList&lt;&gt;(),root,target);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ArrayList&lt;Integer&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                      TreeNode root,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将当前的root结点添加进去</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="comment">//到叶子结点，符合条件的就添加进去</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == root.val)&#123;</span><br><span class="line">                paths.add(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这是相当于path的一个副本，是为了左右两个分支互不影响而新建的，但是值与path是一样的</span></span><br><span class="line">        ArrayList&lt;Integer&gt; path2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        path2.addAll(path);</span><br><span class="line">        <span class="comment">//左右分别递归</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            find(paths,path,root.left,target-root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            find(paths,path2,root.right,target-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第二十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题23-二叉搜索树后序遍历序列】</title>
    <link href="http://yoursite.com/2019/03/08/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9823-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/08/剑指offer/【面试题23-二叉搜索树后序遍历序列】/</id>
    <published>2019-03-08T05:39:37.574Z</published>
    <updated>2019-03-08T05:40:01.670Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第二十三题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h2>解题思路</h2><p>首先要了解二叉搜索树的重要性质：根节点root的所有左子树的值都小于他，右子树的所有值都大于他。并且一个节点的值大于他的左孩子的值，小于右孩子的值。</p><p>比如这个树就满足二叉搜索树的性质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二叉搜索树示例：</span><br><span class="line"></span><br><span class="line">         20</span><br><span class="line">       /  \</span><br><span class="line">      15   25</span><br><span class="line">     / \  </span><br><span class="line">    10 18</span><br></pre></td></tr></table></figure><p>那么它的后续遍历是 10 18 15 25 20</p><p>显然，数组的最后一个值是树的root，25是其右子树，10-15都是其左子树，那么前三个数都要比20小，这样才能满足条件。然后再以15为root，递归判断。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span>[] sequence,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归的停止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后往前找到第一个比end小的数</span></span><br><span class="line">        <span class="keyword">int</span> i = end-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;start &amp;&amp; sequence[i] &gt; sequence[end])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//0-end都应该是左子树，所以值必须都比root小，有一个大则false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[j] &gt; sequence[end])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对左右子树再做递归判断</span></span><br><span class="line">        <span class="keyword">return</span> judge(sequence,<span class="number">0</span>,i) &amp;&amp; judge(sequence,i,end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第二十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题22-从上往下打印二叉树】</title>
    <link href="http://yoursite.com/2019/03/08/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9822-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/08/剑指offer/【面试题22-从上往下打印二叉树】/</id>
    <published>2019-03-08T03:44:21.653Z</published>
    <updated>2019-03-08T03:44:48.178Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第二十二题。</p><a id="more"></a><h2>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h2>解题思路</h2><p>树的层序遍历，没啥好说的了。常规题目，面试常见。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode tmpNode = queue.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmpNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(tmpNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(tmpNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(tmpNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第二十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题21-栈的压入、弹出序列】</title>
    <link href="http://yoursite.com/2019/03/08/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9821-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/08/剑指offer/【面试题21-栈的压入、弹出序列】/</id>
    <published>2019-03-08T03:43:22.395Z</published>
    <updated>2019-03-08T03:44:06.506Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第二十一题。</p><a id="more"></a><h2>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2>解题思路</h2><p>一开始都看不懂题目…</p><p>后来才好像明白是什么个意思…</p><p>假设有一串数字要将他们压栈: 1 2 3 4 5</p><p>如果这个栈是很大很大，那么一次性全部压进去，再出栈：5 4 3 2 1</p><p>但是，如果这个栈高度为4，会发生什么？ 1 2 3 4都顺利入栈，但是满了，那么要先出栈一个，才能入栈，那么就是先出4，然后压入5，随后再全部出栈：4 5 3 2 1</p><p>那么我总结了所有可能的出栈情况:</p><p>5 4 3 2 1//栈高度为5</p><p>4 5 3 2 1//栈高度为4</p><p>3 4 5 2 1//栈高度为3</p><p>2 3 4 5 1//栈高度为2</p><p>1 2 3 4 5//栈高度为1</p><p>借助一个辅助的栈，遍历压栈的顺序，依次放进辅助栈中。</p><p>对于每一个放进栈中的元素，栈顶元素都与出栈的popIndex对应位置的元素进行比较，是否相等，相等则popIndex++，再判断，直到为空或者不相等为止。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组为空的情况</span></span><br><span class="line">        <span class="keyword">if</span>(pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//弹出序列的下表索引</span></span><br><span class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">            <span class="comment">//不停地将pushA中的元素压入栈中，一旦栈顶元素与popA相等了，则开始出栈</span></span><br><span class="line">            <span class="comment">//不相等则继续入栈</span></span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()==popA[popIndex])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈中没有元素了说明元素全部一致，并且符合弹出顺序，那么返回true</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第二十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题20-包含min函数的栈】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9820-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题20-包含min函数的栈】/</id>
    <published>2019-03-07T12:15:50.331Z</published>
    <updated>2019-03-07T12:16:14.298Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第二十题。</p><a id="more"></a><h2>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h2>解题思路</h2><p>思路：利用一个辅助栈来存放最小值</p><p>栈 3，4，2，5，1</p><p>辅助栈 3，3，2，2，1</p><p>每入栈一次，就与辅助栈顶比较大小，如果小就入栈，如果大就入栈当前的辅助栈顶；</p><p>当出栈时，辅助栈也要出栈</p><p>这种做法可以保证辅助栈顶一定都当前栈的最小值</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存放元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//存放当前stack1中的最小元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//stack1直接塞，stack2要塞比栈顶小的元素，要不然就重新塞一下栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty() || stack2.peek() &gt; node)&#123;</span><br><span class="line">            stack2.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack2.push(stack2.peek());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//都要pop一下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"no element valid"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        stack1.pop();</span><br><span class="line">        stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第二十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题19-顺时针打印矩阵】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9819-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题19-顺时针打印矩阵】/</id>
    <published>2019-03-07T11:56:36.879Z</published>
    <updated>2019-03-07T11:57:02.054Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十九题。</p><a id="more"></a><h2>题目描述</h2><p>题目描述<br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h2>解题思路</h2><p>旋转打印有点难，不过也是有办法的。我们可以把矩阵想象为一个魔方，我读完第一行之后，我就把魔方左转90度，再读取第一行，这样循环，直到最后一行结束。具体看代码中注释。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**************************</span></span><br><span class="line"><span class="comment">用旋转魔方的方式，一直取出第一行；</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">例如</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    1 2 3</span></span><br><span class="line"><span class="comment">    4 5 6</span></span><br><span class="line"><span class="comment">    7 8 9</span></span><br><span class="line"><span class="comment">输出并删除第一行后，变为</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    4 5 6</span></span><br><span class="line"><span class="comment">    7 8 9</span></span><br><span class="line"><span class="comment">再进行一次逆时针旋转，就变成：</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    6 9</span></span><br><span class="line"><span class="comment">    5 8</span></span><br><span class="line"><span class="comment">    4 7</span></span><br><span class="line"><span class="comment">继续重复上述操作即可。</span></span><br><span class="line"><span class="comment">***************************/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//作为存放结果的容器</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//拿到出事数组的行数</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(row != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//将数组的第一行先添加进容器中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix[<span class="number">0</span>].length;i++)</span><br><span class="line">                list.add(matrix[<span class="number">0</span>][i]);</span><br><span class="line">            <span class="comment">//当行数等于1时就没有必要再继续执行了，在上面打印完之后就可以停止了</span></span><br><span class="line">            <span class="keyword">if</span>(row == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//删除上面遍历的数组的第一行，然后旋转这个数组并返回</span></span><br><span class="line">            matrix = revert(matrix);</span><br><span class="line">            <span class="comment">//更新行数</span></span><br><span class="line">            row = matrix.length;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//返回</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] revert(<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line">        <span class="comment">//拿到matrix的行数和列数</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//因为我们要将原数组遍历过的第一行删除，然后旋转变成一个新的数组，所以先初始化一下这个新数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] newMatrix = <span class="keyword">new</span> <span class="keyword">int</span>[cols][rows-<span class="number">1</span>];</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//对这个新数组进行赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=cols-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rows;i++)&#123;</span><br><span class="line">                newMatrix[cols-j-<span class="number">1</span>][i-<span class="number">1</span>] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//返回新数组</span></span><br><span class="line">        <span class="keyword">return</span> newMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题18-二叉树的镜像】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9818-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题18-二叉树的镜像】/</id>
    <published>2019-03-07T09:44:15.108Z</published>
    <updated>2019-03-07T09:44:38.530Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十八题。</p><a id="more"></a><h2>题目描述</h2><p><img src="http://bloghello.oursnail.cn/offer18-1.png" alt="image"></p><h2>解题思路</h2><p>我们或许还记得递归的终极思想是数学归纳法，我们思考递归的时候一定不要去一步一步看它执行了啥，只会更绕。我们牢牢记住，思考的方式是我们首先假设子问题都已经完美处理，我只需要处理一下最终的问题即可，子问题的处理方式与最终那个处理方式一样，但是问题规模一定要以1的进制缩小。最后给一个递归出口条件即可。</p><p>对于本题，首先假设<code>root</code>的左右子树已经都处理好了，即左子树自身已经镜像了，右子树自身也镜像了，那么最后一步就是交换左右子树，问题解决。所以我只需要将<code>root.left</code>和<code>root.right</code>交换即可。下面进入递归，就是处理子问题。子问题的处理方式与<code>root</code>一样，只是要缩小问题规模，所以只需要考虑<code>root.left</code>是什么情况，<code>root.right</code>是什么情况即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        reverseTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//为空则结束</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//假设root两边的子树自己都已经翻转成功了，那么只需要再将左右子树互换一下就成功了</span></span><br><span class="line">        <span class="comment">//交换root的左右子树</span></span><br><span class="line">        swap(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左右子树翻转自己去处理就行了，我们规定每个子树的root都跟最终的root处理方式一样即可</span></span><br><span class="line">        reverseTree(root.left);</span><br><span class="line">        reverseTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        node = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题17-树的子结构】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9817-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题17-树的子结构】/</id>
    <published>2019-03-07T09:08:53.574Z</published>
    <updated>2019-03-07T09:09:17.170Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十七题。</p><a id="more"></a><h2>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2>解题思路</h2><p>针对树的结构，肯定是要用递归了，本题我觉得还是比较难的，需要注意很多东西，但是理解上比较轻松，直接看代码，理解了就好了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//都不为空的话再去判断，因为空树不是任意一个树的子树</span></span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//相等，则进入另外一个函数递归判断</span></span><br><span class="line">            <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                res = doTree1ContainsTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上面个不符合条件的话，则继续找下一个相等的结点，再去遍历</span></span><br><span class="line">            <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                res = HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                res = HasSubtree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doTree1ContainsTree2</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口1：子树已经判断完毕了则结束，表明整个过程都为true，最终返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归出口2：子树还没空，父树先走到空了，那么肯定是不是子树结构的</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归出口3：两个数的结点值不相等的话停止</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> doTree1ContainsTree2(root1.left,root2.left) &amp;&amp; doTree1ContainsTree2(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题16-合并两个排序的链表】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9816-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题16-合并两个排序的链表】/</id>
    <published>2019-03-07T08:27:25.043Z</published>
    <updated>2019-03-07T08:36:46.535Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十六题。</p><a id="more"></a><h2>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2>解题思路</h2><p>跟归并排序的并过程很类似。理解了归并排序，这个就很简单了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//newHead是为了表示头节点用的</span></span><br><span class="line">        <span class="comment">//node是为了穿针引线，将两个链表连起来</span></span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//两个指针不停比较，把较小的用node串起来，并且焦较小的指针往后移动即可</span></span><br><span class="line">            <span class="keyword">if</span>(list1.val &gt; list2.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    newHead = list2;</span><br><span class="line">                    node = list2;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = list2;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    newHead = list1;</span><br><span class="line">                    node = list1;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.next = list1;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//走到这里，最多只有一个链表还没遍历完，下面补全就可以了</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            node.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题15-反转链表】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9815-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题15-反转链表】/</id>
    <published>2019-03-07T03:44:50.327Z</published>
    <updated>2019-03-07T03:45:20.193Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十五题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2>解题思路</h2><p>一开始学的时候看的答案就是这个方法，显然是要比递归好的，但是如果不理解的话，光靠背很容易出错，并且也不大背的上，如今重温这道题，其实是很简单的，我们下面用图示来阐述。</p><p>主要的思想是用两个指针，其中<code>newHead</code>指向的是反转成功的链表的头部，<code>currentHead</code>指向的是还没有反转的链表的头部：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-1.png" alt="image"></p><p>初始状态是<code>newHead</code>指向<code>null</code>，<code>currentHead</code>指向的是第一个元素，一直往后遍历直到<code>newHead</code>指向最后一个元素为止：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-3.png" alt="image"></p><p>下面展示的是其中某个时间点的指向细节：</p><p><img src="http://bloghello.oursnail.cn/suanfa3-2.png" alt="image"></p><p>理解了上面的图示，程序就呼之欲出了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode currentHead = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(currentHead != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = currentHead.next;</span><br><span class="line">            currentHead.next = newHead;</span><br><span class="line">            newHead = currentHead;</span><br><span class="line">            currentHead = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题14-链表中倒数第k个结点】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9814-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题14-链表中倒数第k个结点】/</id>
    <published>2019-03-07T03:43:20.812Z</published>
    <updated>2019-03-07T03:44:40.517Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十四题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2>解题思路</h2><p>做过这个题目或者了解过，思路一下就有了。要求倒数第k个结点，而这个单向链表只能next，所以往前找是不行的。怎么办呢？我们可以先派一个指针走k个结点，然后另一个指针从头开始，两个指针同时后移，当前面个指针到最后一个结点的下一个结点即null的时候，后面个指针恰好指向的就是倒数第k个结点。</p><h2>我的答案</h2><p>答案稍微有点繁琐了，但是我觉得思路清晰是最重要的，代码再精简是需要在思路清晰的基础上再加以磨练才行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算出链表的长度，判断k是否超出</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(tmp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k &gt; count)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到第k个结点</span></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一个结点指向head，一个结点指向第k个，两者同时后移</span></span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此时ehad就是倒数第k个结点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题13-调整数组顺序使奇数位于偶数前面】</title>
    <link href="http://yoursite.com/2019/03/07/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9813-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/07/剑指offer/【面试题13-调整数组顺序使奇数位于偶数前面】/</id>
    <published>2019-03-07T02:41:50.142Z</published>
    <updated>2019-03-07T02:42:15.123Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十三题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2>解题思路</h2><p>这个题目最简单的思路自然是新开一个数组来存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                temp[e++] = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[count++] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">            array[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过确实有点low，应该不是出题者本意。我们可以在原地进行处理，基本思想同插入排序。</p><p>首先说明一下，本题用快排的话会非常复杂，几乎是做不出来。因为他要保证偶数与偶数，奇数与奇数相对的顺序不变。</p><p>要想保证偶数与偶数，奇数与奇数相对顺序不变，那么就不能简单地交换，办法是整体移动。我首先找到第一个偶数，然后从这个偶数开始找第一个奇数。两者不能直接交换，因为交换的话，在前面的偶数被调到了后面，不符合题意。</p><p>从偶数位置开始，依次往后挪一格，然后将第一个奇数放到当前偶数的位置。依次循环，到最后i或者j越界了说明已经全部调整好了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非法判断</span></span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span> || array == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> , j;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; array.length)&#123;</span><br><span class="line">            <span class="comment">//找到第一个偶数停止</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; array.length &amp;&amp; !isEven(array[i]))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从偶数位置开始，找第一个奇数</span></span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; array.length &amp;&amp; isEven(array[j]))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这个j越界说明找不到奇数了，则后面没有奇数就结束了</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; array.length)&#123;</span><br><span class="line">                <span class="comment">//从偶数位置开始到奇数位置整体向后移动一格，然后把这个奇数放到偶数位置即可</span></span><br><span class="line">                <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j2 = j-<span class="number">1</span>;j2 &gt;= i;j2--)&#123;</span><br><span class="line">                    array[j2+<span class="number">1</span>] = array[j2];</span><br><span class="line">                &#125;</span><br><span class="line">                array[i++] = tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">break</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否为偶数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题12-数值的整数次方】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9812-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题12-数值的整数次方】/</id>
    <published>2019-03-06T09:55:01.132Z</published>
    <updated>2019-03-06T09:56:03.483Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十二题。</p><a id="more"></a><h2>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2>解题思路</h2><p>把两个问题考虑清楚就可以了。第一个问题是判断指数是不是小于0，这关系到要不要取倒数；第二个问题是判断底数是不是负数，这个时候，如果指数是偶数，则为正数，如果指数为奇数则为负数。</p><p>我们将问题简化，将底数设置为正数，设好标识符最后统一处理，我们的首要目标是计算出次方数，最后再判断上面的两种情况，对结果进行调整。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先把指数全部搞成正数，后面再处理</span></span><br><span class="line">        <span class="keyword">int</span> e = exponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            e = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//看看是不是奇数,如果是奇数并且base为负数，那么最终还是负数，其余情况都是正数</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(base % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算次方的结果</span></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(e &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res *= base;</span><br><span class="line">            e--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果指数小于0，则要取倒数</span></span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            res = <span class="number">1</span>/res;</span><br><span class="line">            <span class="comment">//base为负数并且指数为基数的时候，要取反</span></span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                res = <span class="number">0</span>-res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：貌似有更快的方法，暂时先不考虑了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题11-二进制中1的个数】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9811-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题11-二进制中1的个数】/</id>
    <published>2019-03-06T09:27:02.941Z</published>
    <updated>2019-03-06T09:33:22.829Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十一题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h2>解题思路</h2><p>这个题目求一个数的二进制形式的1的个数，比较简单的思路是：每次与1进行&amp;操作，看是不是1，是则奇数，无论如何都后移一位再判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果输入时负数会陷入死循环，因为负数右移时，在最高位补得是1。那么就死循环了。</p><p>比较好的解法是：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。</p><p>循环是判断n是不是为0了，只要不为0，就循环。一进循环说明n是有至少一个1的，二话不说，先count++;</p><p>比如：一个二进制数1100，减去1之后是1011。</p><p>两者一&amp;则变为1000，原来最右边的1就变成了0.</p><p>由于n不为0，则再次进入循环：</p><p>1000减去1是0111，两者一&amp;就是0000.退出循环。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题10-矩形覆盖】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9810-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题10-矩形覆盖】/</id>
    <published>2019-03-06T08:15:38.532Z</published>
    <updated>2019-03-06T08:16:13.778Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第十题。</p><a id="more"></a><h2>题目描述</h2><p>我们可以用 <code>2*1</code> 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个 <code>2*1</code> 的小矩形无重叠地覆盖一个 <code>2*n</code> 的大矩形，总共有多少种方法？</p><h2>解题思路</h2><p><img src="http://bloghello.oursnail.cn/offer10-1.png" alt="image"></p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>) + RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题9-变态跳台阶】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%989-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题9-变态跳台阶】/</id>
    <published>2019-03-06T08:05:21.845Z</published>
    <updated>2019-03-06T08:12:08.793Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第九题。</p><a id="more"></a><h2>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2>解题思路</h2><p>这就是上一题的延申，上一题要么跳一个要么跳两个，这一题是从1个到n个，那么同样地，找出f(n)与f(n-1)的关系就好了。</p><ul><li>f(1) = 1：一个台阶只有一种跳法，就是跳一个</li><li>f(2) = f(2-1) + f(2-2)：两个台阶有两种跳法，跳一个或者跳两个</li><li>①f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) = f(0) + f(1) + f(2) + … + f(n-2) + f(n-1)：n个台阶就有n个跳法</li></ul><p>根据上一个式子，我们可以得出：</p><p>②f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + … + f(n-2)：n-1个台阶有n-1个跳法</p><p>根据①②可以得出：</p><p>f(n) = f(n-1) + f(n-1) =2*f(n-1)</p><p>这个问题就解决了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题8-跳台阶】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%988-%E8%B7%B3%E5%8F%B0%E9%98%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题8-跳台阶】/</id>
    <published>2019-03-06T08:03:07.323Z</published>
    <updated>2019-03-06T08:03:56.808Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第八题。</p><a id="more"></a><h2>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2>解题思路</h2><p>对于本题,前提只有 一次 1阶或者2阶的跳法。</p><ul><li>如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);</li><li>假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)</li><li>可以得出总跳法为: f(n) = f(n-1) + f(n-2)</li><li>然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</li></ul><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> JumpFloor(target-<span class="number">1</span>) + JumpFloor(target-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题7-斐波那契数列】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%987-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题7-斐波那契数列】/</id>
    <published>2019-03-06T08:01:44.875Z</published>
    <updated>2019-03-06T08:02:57.584Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第七题。</p><a id="more"></a><h2>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><h2>解题思路</h2><p>最简单的解法就是递归了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是递归存在重复子问题，所以时间复杂度较高，但是这里竟然通过了？斐波那契数列我认为最优的一个解法是用两个变量存储。</p><p>这题目用动态规划来解其实是不好的，至少逆向思考问题本身就是比较问难的，我觉得这种记忆化搜索对于这种问题是最好理解并且解是比较优的解。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题6-旋转数组的最小数字】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%986-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题6-旋转数组的最小数字】/</id>
    <published>2019-03-06T07:58:30.451Z</published>
    <updated>2019-03-06T07:58:55.710Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第六题。</p><a id="more"></a><h2>题目描述</h2><p>一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2>解题思路</h2><p>当我们看到关键字“非减排序的数组&quot;的时候，我们要想到这题目的最优解可能是用二分查找法。</p><p>我们知道，二分查找法适用于有序数组的查找，这里对这个非减排序的数组进行了旋转，那么旋转之后这个数组的一个明显特征是：前面的一段序列必然大于等于后面的一段序列。</p><p>这题目可以认为是二分查找法的变种题目，下面我们来具体分析一下编程思路。</p><p>我们可以找一个基准数，比如数组的最优一个元素<code>target</code>，我们比较中间元素比如叫做<code>arr[mid]</code>和这个<code>target</code>的大小：</p><ul><li>如果<code>arr[mid]</code>&gt;<code>target</code>:那么表明截取的时候，后面比前面长，那么最小值必然存在于索引mid的后面</li><li>如果<code>arr[mid]</code>&lt;<code>target</code>:那么表明截取的时候，前面比后面长，那么最小值必然存在于索引mid的前面(此时应该包含mid对应的元素，因为极限情况比如只有两个元素，那么反转之后前面可能比后面大，如果不包含这个mid就错了)</li><li>如果<code>arr[mid]</code>=<code>target</code>:这个时候元素组比如为[0,1,1,1,1]，那么旋转之后可能为 [1,0,1,1,1] 或者[1,1,1,0,1]，不好判断，一个一个试。</li></ul><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[end])&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; array[end])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题5-用两个栈实现队列】</title>
    <link href="http://yoursite.com/2019/03/06/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%985-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/06/剑指offer/【面试题5-用两个栈实现队列】/</id>
    <published>2019-03-06T07:52:05.206Z</published>
    <updated>2019-03-06T07:57:49.667Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第五题。</p><a id="more"></a><h2>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为int类型。</p><h2>解题思路</h2><p>队列是先进先出，栈是先进后出，如何用两个栈来实现这种先进先出呢？</p><p>其实很简单，我们假设用<code>stack1</code>专门来装元素，那么直接<code>stack1.pop</code>肯定是不行的，这个时候<code>stack2</code>就要发挥作用了。</p><p>我们的规则是：只要<code>stack2</code>中有元素就<code>pop</code>，如果<code>stack2</code>为空，则将<code>stack1</code>中所有元素倒进<code>satck2</code>中，就是说，新元素只进<code>stack1</code>，元素出来只从<code>stack2</code>出来。</p><p>这样子，就能保证每次从<code>stack2</code>中<code>pop</code>出来的元素就是最老的元素了。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//负责装元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//负责出元素</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主要思想是：stack2有元素就pop，没有元素就将stack1中所有元素倒进来再pop</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> node = stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"no valid element"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
