<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-05T08:22:06.887Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双亲委派模型</title>
    <link href="http://yoursite.com/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/02/05/JVM/双亲委派模型/</id>
    <published>2019-02-05T08:18:14.365Z</published>
    <updated>2019-02-05T08:22:06.887Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第三篇文章，谈到JVM类加载机制，双亲委派模型是绕不开的话题，名字看好像是个高大上、深不可测的玩意，其实逐步揭开面纱之后很简单。下面我们就来揭揭看。</p><a id="more"></a><h2>回顾类加载器</h2><p>上一节简单说明了类加载器的作用，只说到一个核心功能是加载class文件。但是，绝对没有这么简单，神书《深入理解Java虚拟机》第二版对类加载器的说明：</p><blockquote><p>代码编译的结果从本地机器码转变成字节码，是存储格式的一小步，却是编程语言发展的一大步。</p><p>Java虚拟机把描述类的数据从Class文件加载进内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这动作的代码模块成为“类加载器”。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。这句话可以表达的更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</p></blockquote><p>对于上面进行一些说明：</p><p>注意，加载之后要将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）</p><p>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。这个<code>Class</code>对象并没有规定是在<code>Java</code>堆内存中，它比较特殊，虽为对象，但存放在方法区中。</p><p>这样，就可以使用这个类了。</p><p>还有，关于相等，只有在满足如下三个类“相等”判定条件，才能判定两个类相等。</p><ul><li>两个类来自同一个Class文件</li><li>两个类是由同一个虚拟机加载</li><li>两个类是由同一个类加载器加载</li></ul><h2>什么是双亲委派模型</h2><p>我们上一节已经知道了有四种类加载器，它们的实际关系为：</p><p><img src="http://bloghello.oursnail.cn/jvm3-1.png" alt="image"></p><p>从这个图来看，是一个继承的关系，是这样吗？我们用代码来看看是不是真的是这样。</p><p>代码还是用上一篇文章自定义类加载器来测试：</p><p><img src="http://bloghello.oursnail.cn/jvm3-3.png" alt="image"></p><p>结果是：</p><p><img src="http://bloghello.oursnail.cn/jvm3-4.png" alt="image"></p><p>从这个结果就很容易看出，层级关系是与上图所述的一样。</p><p>那么，这个层级关系其实就是我们下面要说的双亲委派模型的结构。</p><p>结合代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//2.首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">//3.如果当前类加载器没有加载过，进来</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//4.看是否有父类加载器，有则进来</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//5.父类加载器看看是否已经加载过</span></span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//进到这个，是来看看bootstrap类加载器是否加载过，没有加载过则加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一开始是false</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，就是先一级一级往上查询是否已经加载过，加载过直接返回即可；一直查询到<code>bootstrap</code>类加载器，都没有加载过，那么就从<code>bootstrap</code>类加载器开始一级一级向下到他们的扫描范围内尝试加载这个class文件，知道自定义类加载(如果有的话)，没有则返回找不到。</p><p>说一下代码的实现思路。代码使用递归实现的，先一级一级找父亲，即一级一级向上入栈，某一个查到了就返回，每一层递归停留在<code>c = parent.loadClass(name, false);</code>；都查不到，再一级一级出栈去执行，那么就从<code>c = findBootstrapClassOrNull(name);</code>后面的代码继续执行，那么显然就是执行<code>if (c == null) {...}</code>尝试去加载。</p><h2>为什么要用双亲委派模型</h2><p>为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：</p><blockquote><p>黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只<br>是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，<br>黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲<br>委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，<br>导致“病毒代码”被执行。</p></blockquote><p>而有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。</p><p>或许你会想，我在自定义的类加载器里面强制加载自定义的<code>java.lang.String</code>类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回<code>false</code>。</p><p>举个简单例子：</p><blockquote><p>ClassLoader1、ClassLoader2都加载java.lang.String类，对应Class1、Class2对象。<br>那么Class1对象不属于ClassLoad2对象加载的java.lang.String类型。</p></blockquote><p>委托机制的意义：防止内存中出现多份同样的字节码</p><p>比如两个类A和类B都要加载<code>System</code>类：</p><p>如果不用委托而是自己加载自己的，那么类A就会加载一份<code>System</code>字节码，然后类B又会加载一份<code>System</code>字节码，这样内存中就出现了两份<code>System</code>字节码。</p><p>如果使用委托机制，会递归的向父类查找，也就是首选用<code>Bootstrap</code>尝试加载，如果找不到再向下。这里的<code>System</code>就能在<code>Bootstrap</code>中找到然后加载，如果此时类B也要加载<code>System</code>，也从<code>Bootstrap</code>开始，此时<code>Bootstrap</code>发现已经加载过了<code>System</code>那么直接返回内存中的<code>System</code>即可而不需要重新加载，这样内存中就只有一份<code>System</code>的字节码了。</p><h2>一个面试题</h2><p>能不能自己写个类叫<code>java.lang.System</code>？</p><p>显然是不可以的，可能方案是自己搞一个这个类放在特殊目录，用自定义类加载器去加载，然而系统自身的类加载器会先去加载使用，下次再用的时候，是先逐级向上查询是否已经加载过，根本没有机会让自定义类加载器去加载。</p><p>所以，如果非要用，那么必定是要破坏双亲委派模型了，那么又回到为什么要用双亲委派模型的问题上了，所以，为了自己写一个<code>java.lang.System</code>而破坏双亲委派模型，我只能说，脑子秀逗了。所以不要搞这些东西，包名或类名写的不一样即可。</p><h2>一个问题</h2><p>那么为什么不能用一个加载器去一个目录加载所有呢？还要分这么多的类加载器，不是麻烦么？</p><p>其实，这个问题也是比较可笑的，毕竟每个层级的功能是不一样的，比如<code>bootstrap</code>是加载最核心的文件，没有它，都玩不起来。而自定义的呢？是比较特殊的需求，需要的时候才用到。对于这种有个性化的要求，一套代码来实现，显然是不合理的。</p><p>比如这个回答是根据加载的方式来思考的：</p><blockquote><p>每一个类加载器都是为了去在不同的情景下去加载类。比如，你可以从联网服务器上加载一个class文件，也可以从远程web服务器下载二进制类。这么设计是因为我们需要类加载器提供一致的接口，这样客户端就可以加载类但是却不用管类加载器到底是怎么实现的。启动类加载器能够加载JVM_HOME/lib 下的类，但如果我们需要在其他的情况下加载类呢？简单来说，加载类的方法有无数种，我们需要一个灵活的加载器系统去在特定的情况下按照我们的想法来加载类。</p></blockquote><p>还有一个回答是说更方便地对特定类进行优化：</p><blockquote><p>虽然 对java 虚拟机没有研究过，java 为什么不能 一个加载器 加载全部的类<br>很明显， 实现起来也可以<br>但是需要 的 代码 更多，也更难 为各种类进行 优化，为了更简单的抽象<br>我在明确知道 该类是启动类的情况下，我就会 为该类 进行优化。<br>如果是自定义类，可能就 不会进行 此类优化。<br>在明确 目的的情况下， 专用代码 比 通用代码 更简单，也更有效。</p></blockquote><p>总之，就是为了清晰和方便，这也是我们在进行软件设计的时候最基本的要求，即不能写死代码，影响扩展性；层次结构也不能写的太乱，影响后续的优化。</p><p>至此，双亲委派模型就讲完了。我们也清晰地知道了其设计思想和好处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第三篇文章，谈到JVM类加载机制，双亲委派模型是绕不开的话题，名字看好像是个高大上、深不可测的玩意，其实逐步揭开面纱之后很简单。下面我们就来揭揭看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>浅谈ClassLoader</title>
    <link href="http://yoursite.com/2019/02/05/JVM/%E6%B5%85%E8%B0%88ClassLoader/"/>
    <id>http://yoursite.com/2019/02/05/JVM/浅谈ClassLoader/</id>
    <published>2019-02-05T06:44:35.075Z</published>
    <updated>2019-02-05T08:17:49.416Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第二篇文章，上一篇文章初步提到了class文件，以及一个最简单程序执行的指令含义，我们提到，是由JAVA虚拟机先加载这些编译好的class文件，然后再去根据解析出来的指令去转换为具体平台上的机器指令执行，但是加载这个class文件时如何加载的呢？其实就涉及比较重要的东西：ClassLoader</p><a id="more"></a><p>有一个基本认识，从编译到实例化对象的过程可以概括为以下三个阶段：</p><ul><li>编译器将<code>xxx.java</code>源文件编译为<code>xxx.class</code>字节码文件</li><li><code>ClassLoader</code>将字节码转换为JVM种的<code>Class&lt;xxx&gt;</code>对象</li><li>JVM利用<code>Class&lt;xxx&gt;</code>对象实例化为<code>xxx</code>对象</li></ul><h2>一、JVM系统结构</h2><p><img src="http://bloghello.oursnail.cn/jvm2-1.png" alt="image"></p><ul><li><code>ClassLoader</code>：依据特定格式，加载class文件到内存</li><li><code>Execution Engine</code>：对命令进行解析</li><li><code>Native Interface</code>：融合不同开发语言的原生库为Java所用</li><li><code>Runtime Data Area</code>：JVM内存空间结构模型</li></ul><p>首先通过<code>ClassLoader</code>加载符合条件的字节码文件到内存中，然后通过<code>Execution Engine</code>解析字节码指令，交由操作系统去执行。</p><h2>二、什么是ClassLoader</h2><p><code>ClassLoader</code>在java中有着非常重要的作用，它主要工作在<code>Class</code>装载的加载阶段，其主要作用是从系统外部获得<code>Class</code>二进制数据流。他是JAVA的核心组件，所有的<code>Class</code>都是由<code>ClassLoader</code>进行加载的，<code>ClassLoader</code>负责通过将<code>Class</code>文件里的二进制数据流装载进系统，然后交给JAVA虚拟机进行连接、初始化等操作。</p><p>简而言之，就是加载字节码文件。</p><p>我们翻开<code>ClassLoader</code>源码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>它是一个抽象类，下面我们再来说具体的实现类。</p><p>里面比较重要的是<code>loadClass()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是根据<code>name</code>来加载字节码文件，返回<code>Class</code>实例，加载不到则抛出<code>ClassNotFoundException</code>异常。</p><h2>三、ClassLoader的种类</h2><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：由<code>C++</code>语言实现（针对<code>HotSpot</code>）,加载核心库<code>java.*</code>。</li></ul><ul><li>扩展类加载器（<code>Extension ClassLoader</code>）：Java编写，加载扩展库<code>javax.*</code></li></ul><p>它扫描的是哪个路径呢？</p><p><img src="http://bloghello.oursnail.cn/jvm2-2.png" alt="image"></p><p>我们看到，它负责将 <code>&lt;JAVA_HOME &gt;/lib/ext</code>或者由系统变量<code>-Djava.ext.dir</code>指定位置中的类库 加载到内存中。</p><ul><li>应用程序类加载器（<code>Application ClassLoader</code>）：Java编写，加载程序所在目录</li></ul><p><img src="http://bloghello.oursnail.cn/jvm2-3.png" alt="image"></p><p>它负责将 用户类路径(<code>java -classpath</code>或<code>-Djava.class.path</code>变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，看截图的最后一行，显示的是当前项目路径。</p><ul><li>自定义<code>ClassLoader</code>：自定义</li></ul><h2>四、如何自定义ClassLoader</h2><p>要自己实现一个<code>ClassLoader</code>，其核心涉及两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先想一下为什么是这两个类？</p><p>其实答案在<code>loadClass()</code>这个方法里面。如果已经熟悉双亲委派模型的同学，都会知道加载<code>Class</code>对象是先委派给父亲，看父亲是否已经加载，如果没有加载过，则从最顶层父亲开始逐层往下进行加载，这一块详细在下一篇文章中解释，我们先走马观花看看这个的核心方法长啥样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不去重写<code>findClass(name)</code>方法，默认是直接抛出找不到的异常，所以我们要对这个方法进行重写。</p><p>由于字节码文件是一堆二进制流，所以需要一个方法来根据这个二进制流来定义成一个类，即<code>defineClass()</code>这个方法来实现这个功能。</p><p>说的比较抽象，下面来真正实践一把！</p><h2>五、实践自定义ClassLoader</h2><p>首先写一个类：Robot.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello , i am a robot!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对<code>Robot.java</code>用<code>javac</code>编译之后形成<code>Robot.class</code>文件，就要删除本项目下的这个<code>Robot.java</code>文件，要不然就会被<code>AppClassLoader</code>类加载先加载了，而无法再被我们的自定义类加载器再去加载。这个<code>Robot.class</code>文件我就直接放到桌面去了。路径为<code>C:/Users/swg/Desktop/</code>.</p><p>然后定义一个自定义的<code>ClassLoader</code>，按照上面的理论，只要重写<code>findClass</code>就可以指定到某个地方获取class字节码文件，此时获取的是二进制流文件，转换为字节数组，最后借用<code>defineClass</code>获取真正的<code>Class</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行加载的class文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">//自定义类加载器的名字</span></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    MyClassLoader(String path,String classLoaderName)&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于寻找类文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于加载类文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        name = path + name + <span class="string">".class"</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in  = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试一下能不能用自定义类加载器去加载到<code>Robot</code>对应的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\swg\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"Robot"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader@677327b6</span><br><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><p>好了，学习了关于<code>ClassLoader</code>的分类以及如何自定义<code>ClassLoader</code>，我们知道了类加载器的基本实现，上面谈到了一个重要方法是<code>loadClass</code>，这就涉及了类加载器的双亲委派模型。下一节从代码层面好好来说说这个，其实很简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第二篇文章，上一篇文章初步提到了class文件，以及一个最简单程序执行的指令含义，我们提到，是由JAVA虚拟机先加载这些编译好的class文件，然后再去根据解析出来的指令去转换为具体平台上的机器指令执行，但是加载这个class文件时如何加载的呢？其实就涉及比较重要的东西：ClassLoader&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2019年展望</title>
    <link href="http://yoursite.com/2019/02/05/suibi/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/"/>
    <id>http://yoursite.com/2019/02/05/suibi/2019年展望/</id>
    <published>2019-02-05T05:38:52.590Z</published>
    <updated>2019-02-05T05:49:45.176Z</updated>
    
    <content type="html"><![CDATA[<p>今天是大年初一，算是真正步入2019年了。保存几张老家门口拍的照片，以作纪念。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/suibi1-2.jpg" alt="image"></p><p>老家的后面是一片田地。</p><p><img src="http://bloghello.oursnail.cn/suibi1-3.jpg" alt="image"></p><p>老家越来越冷清，越来越萧条。</p><p>今年四月底顺利毕业的话，就真的工作了，在南京，本科+研究生读了七年书，加上小时候每年暑假都来南京玩，对南京的熟悉的程度远远大于家乡盐城。</p><p>所以希望可以努力，在南京能扎下根，然后一家人全搬过去。</p><p>在找工作方面，找的并不理想，可能还在不好的几个offer之中选择了更不好的一个，心里甚是难受。不过，凡事都没有绝对，往好处多想想就好了，关键还是靠自己努力。</p><p>在2018年，算是学习java的进阶之年，自己学习了很多新的技术，也好好地夯实了基础，把以前很多模糊的问题搞清楚了，确实，基础真的太重要的，光学时髦的框架，可以写写简单的CRUD应用，是远远不够的，我觉得程序员的目标是可以造出大家都认可并且乐于使用的开源作品，没有好的基础，便是天方夜谭，也只能永远做一个普通的码农。</p><p>所以，我给自己定一个三年的目标，三年以后，无论是搞java还是搞大数据还是其他，我希望能达到中高级水平，在这个行业方向上有较好的基础和较深的认识。为后续更高的发展打下坚实的基础。</p><p>我希望，github真正能成为我出发的地方，并且能够走很远。犹记得，14年在大神室友的推荐下，注册了github，但是真正使用还是从去年开始吧。所以甚是惭愧，如果早一点上路，虽然追赶不上大神的脚步（已经进了google），但是进个二线比如京东、美团等都是轻而易举吧，但是谈这些确实是废话，没有人有假如。</p><p>除了对未来三年的一些初步想法之外，我还是希望我与家人都有一个健健康康的身体，所以工作以后身体的锻炼是必不可少的，八块腹肌是不指望了，至少爬几层楼不用喘吧。</p><p>一切还是视实际情况而定，但是终身学习的信念要埋藏在心里，这个时代以及未来的时代，选择了这一行，掉头发是注定的了，但是如果仅仅以掉头发的代价，可以让家人舒舒服服，健健康康，开开心心的话，那给我剃个光头也无妨了。</p><p>废话不多说了，我要继续完成本笔记的JVM部分了，不忘初心，套用喜剧之王的台词：努力，奋斗！</p><p><img src="http://bloghello.oursnail.cn/suibi1-4.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是大年初一，算是真正步入2019年了。保存几张老家门口拍的照片，以作纪念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>彻底理解java反射机制</title>
    <link href="http://yoursite.com/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/02/04/java-basic/彻底理解java反射/</id>
    <published>2019-02-04T08:33:13.519Z</published>
    <updated>2019-02-04T08:42:30.505Z</updated>
    
    <content type="html"><![CDATA[<p>反射机制这一块也是面试经常会被问到的，我从反射的基本概念到反射的一些面试题出发，好好理一理反射的知识。</p><a id="more"></a><h2>1. 什么是反射</h2><p>标准定义：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用方法的功能成为反射机制。</p><p>注意几个关键字：运行状态中，动态获取。</p><h2>2. Class对象和实例对象</h2><p>想要理解反射首先需要知道<code>Class</code>这个类，它的全称是<code>java.lang.Class</code>类。java是面向对象的语言，讲究万物皆对象，即使强大到一个类，它依然是另一个类（<code>Class</code>类）的对象，换句话说，普通类是<code>Class</code>类的对象，即<code>Class</code>是所有类的类（<code>There is a class named Class</code>）。</p><p>我们知道java世界是运行在JVM之上的，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的<code>.class</code>文件，这个就是JVM可以加载执行的字节码。</p><p>运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(<code>class loader</code>)的<code>defineClass()</code>被JVM调用，便会为这个类产生一个<code>Class</code>对象（一个<code>Class</code>类的实例），用来表达这个类，该类的所有实例都共同拥有着这个<code>Class</code>对象，而且是唯一的。</p><p>也就是说，加载<code>.class</code>文件之后会生成一个对应的<code>Class</code>对象。下面说说如何获取这个<code>Class</code>对象。</p><h2>3. 取得Class对象的三种方式</h2><p>我们假设有这么一个类叫<code>MyClass</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li>第一种方式：通过“类名.class”的方式取得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class classInstance= MyClass.class;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Car.class;</span><br><span class="line">Class cls1 = int.class;</span><br><span class="line">Class cls2 = String.class;</span><br></pre></td></tr></table></figure><ul><li>第二种方式：通过类创建的实例对象的<code>getClass</code>方法取得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">Class classInstance = myClass.getClass();</span><br></pre></td></tr></table></figure><ul><li>第三种方式：通过<code>Class</code>类的静态方法<code>forName</code>方法取得（参数是带包名的完整的类名）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class classInstance = Class.forName(<span class="string">"mypackage.MyClass"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种方法取得的对象都是相同的，所以效果上等价。</p><p><code>classInstance</code>是类类型，通过类类型可以得到一个类的属性和方法等参数，这是反射的基础。</p><h2>4. 利用反射API全面分析类的信息——方法，成员变量，构造器</h2><p>反射的一大作用是用于分析类的结构，或者说用于分析和这个类有关的所有信息。而这些信息就是类的基本的组成： 方法，成员变量和构造器。</p><p>在java种万物皆对象，一个类中的方法，成员变量和构造器也分别对应着一个对象</p><ol><li>每个方法都对应有一个保存和该方法有关信息的<strong>Method对象</strong>， 这个对象所属的类是<code>java.lang.reflect.Method</code>;</li><li>每个成员变量都对应有一个保存和该变量有关信息的<strong>Field对象</strong>，这个对象所属的类是 <code>java.lang.reflect.Field</code></li><li>每个构造器都对应有一个保存和该构造器有关信息的<strong>Constructor对象</strong>，这个对象所属的类是<code>java.lang.reflect.Constructor</code></li></ol><p>假设c是一个类的Class对象：</p><ul><li>通过 <code>c.getDeclaredMethods()</code>可取得这个类中所有声明方法对应的<code>Method</code>对象组成的数组</li><li>通过 <code>c.getDeclaredFields()</code>可取得这个类中所有声明的成员变量对应的<code>Field</code>对象组成的数组</li><li>通过 <code>c.getConstructors()</code>; 可取得这个类中所有构造函数所对应的<code>Constructor</code>对象所组成的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method [] methods = c.getDeclaredMethods(); <span class="comment">// 获取方法对象列表</span></span><br><span class="line"> </span><br><span class="line">Field [] fields = c.getDeclaredFields();   <span class="comment">// 获取成员变量对象列表</span></span><br><span class="line"></span><br><span class="line">Constructor [] constructors = c.getConstructors();  <span class="comment">// 获取构造函数对象列表</span></span><br><span class="line"></span><br><span class="line">xxx.getName()就可以打印出对应的名字了。</span><br></pre></td></tr></table></figure><h2>5. 更多的反射api</h2><h5>getMethods和getDeclaredMethods方法</h5><ul><li><code>getMethods</code>取得的<code>method</code>对应的方法<strong>包括从父类中继承的那一部分</strong>，而</li><li><code>getDeclaredMethods</code>取得的<code>method</code>对应的方法<strong>不包括从父类中继承的那一部分</strong></li></ul><p>一个普通的类，他们的基类都是<code>Object</code>，那么如果用<code>getMethods</code>，遍历得到的结果，会发现<code>Object</code>中的基础方法名都会被打印出来。</p><p>诸如<code>wait()</code>,<code>equals()</code>,<code>toString()</code>,<code>getClass()</code>,<br><code>notify()</code>,<code>notifyAll()</code>,<code>hashCode()</code>等等。</p><h5>通过method.getReturnType()获取方法返回值对应的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class returnClass = method.getReturnType(); <span class="comment">// 获取方法返回值对应的Class对象</span></span><br><span class="line">String returnName = returnClass.getName();  <span class="comment">//获取返回值所属类的类名——也即返回值类型</span></span><br></pre></td></tr></table></figure><h5>通过method.getParameterTypes()获取方法各参数的Class对象组成的数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class [] paramsClasses = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class pc: paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName(); <span class="comment">// 获取当前参数类型</span></span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>获取成员变量类型对应的的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = c.getDeclaredField(<span class="string">"name"</span>);  <span class="comment">// 取得名称为name的field对象</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 这一步很重要！！！设置为true才能访问私有成员变量name的值！</span></span><br><span class="line">String nameValue = (String) field.get(obj); <span class="comment">// 获取obj中name成员变量的值</span></span><br></pre></td></tr></table></figure><h5>通过getType方法读取成员变量类型的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = class1.getDeclaredField(number<span class="string">");</span></span><br><span class="line"><span class="string">System.out.print(field.getType().getName());</span></span><br></pre></td></tr></table></figure><p>因为java权限的原因，直接读取私有成员变量的值是非法的（加了<code>field.setAccessible(true)</code>后就可以了），但仍可以直接读取私有成员变量的类型</p><h5>利用反射API分析类中构造器信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> a, String str)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printContructorsMessage</span> <span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">Class c = obj.getClass();  <span class="comment">// 取得obj所属类对应的Class对象</span></span><br><span class="line">Constructor [] constructors = c.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">  Class [] paramsClasses =  constructor.getParameterTypes();</span><br><span class="line">  String paramsStr = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (Class pc : paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName();</span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"构造函数的所有参数的类型列表："</span> + paramsStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数的所有参数的类型列表：<span class="keyword">int</span>  java.lang.String</span><br></pre></td></tr></table></figure><h2>6. 利用反射动态加载类，并用该类创建实例对象</h2><p>我们用普通的方式使用一个类的时候，类是静态加载的<br>，<strong>而使用Class.forName(“XXX”)这种方式，则属于动态加载一个类</strong></p><p>静态加载的类在编译的时候就能确定该类是否存在，但动态加载一个类的时候却无法在编译阶段确定是否存在该类，而是在运行时候才能够确定是否有这个类，所以要捕捉可能发生的异常.</p><p>Class对象有一个<code>newInstance</code>方法，我们可以用它来创建实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class classInstance = Class.forName(<span class="string">"mypackage.MyClass"</span>);</span><br><span class="line">MyClass myClass = (MyClass) classInstance.newInstance();</span><br></pre></td></tr></table></figure><h2>7. 总结</h2><ul><li>反射为我们提供了全面的分析类信息的能力，例如类的方法，成员变量和构造器等的相关信息，反射能够让我们很方便的获取这些信息， 而实现这个获取过程的关键是取得类的<code>Class</code>对象，然后根据<code>Class</code>对象取得相应的<code>Method</code>对象，<code>Field</code>对象和<code>Constructor</code>对象，再分别根据各自的API取得信息。</li><li>反射还为我们提供动态加载类的能力</li><li>API中<code>getDeclaredXXX</code>和<code>getXXX</code>的区别在于前者只获取本类声明的XXX（如成员变量或方法），而不获取超类中继承的XXX， 后者都可以获取</li><li>API中， <code>getXXXs</code>（注意后面的s）返回的是一个数组， 而对应的 <code>getXXX</code>（“键”）按键获取一个值（这个时候因为可能报已检查异常所以要用try*catch语句包裹）</li><li>私有成员变量是不能直接获取到值的！因为java本身的保护机制，允许你取得私有成员变量的类型，但是不允许直接获取值，所以要对对应的<code>field</code>对象调用<code>field.setAccessible(true)</code> 放开权限</li></ul><h2>8. 面试</h2><h4>什么是反射</h4><p>反射是一种能够在程序运行时动态访问、修改某个类中任意属性（状态）和方法（行为）的机制</p><h4>反射到底有什么具体的用处</h4><ul><li>操作因访问权限限制的属性和方法；</li><li>实现自定义注解；</li><li>动态加载第三方jar包，解决android开发中方法数不能超过65536个的问题；</li><li>按需加载类，节省编译和初始化APK的时间；</li></ul><h4>反射的原理是什么</h4><p>当我们编写完一个Java项目之后，每个java文件都会被编译成一个.class文件，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被ClassLoader加载到虚拟机中。当一个类被加载以后，Java虚拟机就会在内存中自动产生一个Class对象。我们通过new的形式创建对象实际上就是通过这些Class来创建，只是这个过程对于我们是透明的而已。</p><p>反射的工作原理就是借助<code>Class.java</code>、<code>Constructor.java</code>、<br><code>Method.java</code>、<code>Field.java</code>这四个类在程序运行时动态访问和修改任何类的行为和状态。</p><h4>如何获取Class对象</h4><ul><li><code>Class</code>的<code>forName()</code>方法的返回值就是<code>Class</code>类型，也就是动态导入类的<code>Class</code>对象的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure><ul><li>每个类都会有一个名称为<code>Class</code>的静态属性，通过它也是可以获取到<code>Class</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz = Student.class;</span><br></pre></td></tr></table></figure><ul><li><code>Object</code>类中有一个名为<code>getClass</code>的成员方法，它返回的是对象的运行时类的<code>Class</code>对象。因为<code>Object</code>类是所有类的父类，所以，所有的对象都可以使用该方法得到它运行时类的<code>Class</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">Class&lt;Student&gt; clazz = stu.getClass();</span><br></pre></td></tr></table></figure><h4>反射的特点</h4><blockquote><p>优点</p></blockquote><ul><li>灵活、自由度高：不受类的访问权限限制，想对类做啥就做啥</li></ul><blockquote><p>缺点</p></blockquote><ul><li>性能问题</li></ul><p>通过反射访问、修改类的属性和方法时会远慢于直接操作，但性能问题的严重程度取决于在程序中是如何使用反射的。如果使用得很少，不是很频繁，性能将不会是什么问题；</p><ul><li>安全性问题</li></ul><p>反射可以随意访问和修改类的所有状态和行为，破坏了类的封装性，如果不熟悉被反射类的实现原理，随意修改可能导致潜在的逻辑问题；</p><h4>如何提高反射性能</h4><p>java应用反射的时候，性能往往是java程序员担心的地方，那么在大量运用反射的时候，性能的微弱提升，对这个系统而言都是如旱地逢甘霖。</p><ul><li><code>setAccessible(true)</code>,可以防止安全性检查（做这个很费时）</li><li>做缓存，把要经常访问的元数据信息放入内存中，<code>class.forName</code> 太耗时</li><li><code>getMethods()</code> 等方法尽量少用，尽量调用<code>getMethod(name)</code>指定方法的名称，减少遍历次数</li></ul><h4>java面试中面试官让你讲讲反射，应该从何讲起？</h4><p>先讲反射机制，反射就是程序运行期间JVM会对任意一个类洞悉它的属性和方法，对任意一个对象都能够访问它的属性和方法。依靠此机制，可以动态的创建一个类的对象和调用对象的方法。</p><p>其次就是反射相关的API，只讲一些常用的，比如获取一个<code>Class</code>对象。<code>Class.forName(完整类名)</code>。通过<code>Class</code>对象获取类的构造方法，<code>class.getConstructor</code>。根据<code>Class</code>对象获取类的方法，<code>getMethod</code>和<code>getMethods</code>。使用<code>Class</code>对象创建一个对象，<code>class.newInstance</code>等。</p><p>最后可以说一下反射的优点和缺点，优点就是增加灵活性，可以在运行时动态获取对象实例。缺点是反射的效率很低，而且会破坏封装，通过反射可以访问类的私有方法，不安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射机制这一块也是面试经常会被问到的，我从反射的基本概念到反射的一些面试题出发，好好理一理反射的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java如何执行一个最简单的程序</title>
    <link href="http://yoursite.com/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/03/JVM/Java如何执行一个最简单的程序/</id>
    <published>2019-02-03T03:44:31.998Z</published>
    <updated>2019-02-03T06:09:47.192Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第一篇文章，需要之前对JVM有一定了解的基础。我们都知道，JAVA号称：一次编译多处运行。这就离不开字节码文件和虚拟机啦！那么，虚拟机到底是如何去执行一个简单的程序的呢？理解了这个，我们就可以理解java时如何做到平台无关的了。下面我们来分析分析。</p><a id="more"></a><p>首先，写一个最简单的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">5</span>;</span><br><span class="line">        i++;</span><br><span class="line">        ++j;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后的结果想必就一目了然，我们就通过这个程序来分析分析到底是怎么执行这个程序额的。</p><p>首先呢，java程序的执行经历编译，编译成系统能识别的文件，这里的系统对应java语言就是JVM，即JAVA虚拟机。JVM在识别之后，再去与我们真正的操作系统进行交互和处理。</p><p>所以，我们要执行一个.java程序，必须要先进行编译。初学者都会学习一个指令叫做<code>javac</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-1.png" alt="image"></p><p>我们会发现路径下面就会多一个.class文件，这就是编译之后的文件。直接点开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> var1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> var2 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> var3 = var1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> var4 = var2 + <span class="number">1</span>;</span><br><span class="line">        System.out.println(var3);</span><br><span class="line">        System.out.println(var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看第一行注释，说的是编译后的文件已经自动被<code>IDEA</code>反编译了，所以我们还能看得懂。真正的文件是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">漱壕   4 </span><br><span class="line">    </span><br><span class="line">     &lt;init&gt; ()V Code LineNumberTable main ([Ljava/lang/String;)V </span><br><span class="line">SourceFile Main.java         Main java/lang/Object java/lang/System out Ljava/io/PrintStream; java/io/PrintStream println (I)V !                    *? ?             </span><br><span class="line">      E     &lt;=??? ? ? ? ?</span><br></pre></td></tr></table></figure><p>我们可以看到，其实是一堆乱码，根本看不懂。而在执行的时候，class文件是一种8位字节的二进制流文件。放在<code>sublime</code>中可以看到二进制文件（以16进制显示，在JAVA虚拟机中将来了解这各文件的含义，我们可以看到第一个单词是cafe babe，表明这是一个class字节码文件）：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-2.png" alt="image"></p><p>那么我们想看看.class中的信息，还是需要反编译，这个时候可以用<code>javap</code>指令来做。如果我们对其不熟悉，可以先执行<code>javap -help</code>来了解了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>我们注意到，有一个<code>-c</code>是进行反汇编，那么就用它试试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;javap -c Main.class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Compiled from &quot;Main.java&quot;</span><br><span class="line">public class Main &#123;</span><br><span class="line">  public Main();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_5</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iinc          1, 1</span><br><span class="line">       7: iinc          2, 1</span><br><span class="line">      10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      13: iload_1</span><br><span class="line">      14: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      17: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: iload_2</span><br><span class="line">      21: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      24: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这反汇编出来的东西是什么呢？这是一连串的指令，其实这些是加载class文件时真正执行的java虚拟机指令。</p><p>我们来看看它的含义吧！</p><p><img src="http://bloghello.oursnail.cn/javabasic6-3.png" alt="image"></p><p>仔细看看，其实发现并不神秘，一个函数的执行是一个入栈出栈的过程。ok，大体了解了字节码文件是什么以及里面的指令含义之后，我们对java如何执行它已经大体清楚了。下面执行一下：</p><p>那么如何运行呢？</p><p><img src="http://bloghello.oursnail.cn/javabasic6-4.png" alt="image"></p><p>其实这是废话，初学java其实是<code>java Main</code>运行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;java Main</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>这个时候，class文件可以移植到任何平台上去，比如直接上传到<code>linux</code>上，只要JDK或者JRE环境类似即可，就可以直接运行了，不需要编译，也不需要关心是什么系统。这就做到了一次编译到处运行。</p><p>下面总结一下：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-5.png" alt="image"></p><p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，JAVA语言在不同平台上运行时不需要进行重新编译，JAVA虚拟机在执行字节码的时候，把字节码转换为具体平台上的机器指令，然后各种操作系统就可以正确识别了。这就是JAVA如何执行代码和平台无关性的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第一篇文章，需要之前对JVM有一定了解的基础。我们都知道，JAVA号称：一次编译多处运行。这就离不开字节码文件和虚拟机啦！那么，虚拟机到底是如何去执行一个简单的程序的呢？理解了这个，我们就可以理解java时如何做到平台无关的了。下面我们来分析分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>关于Redis一些重要的面试点</title>
    <link href="http://yoursite.com/2019/02/02/redis/%E5%85%B3%E4%BA%8ERedis%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%82%B9/"/>
    <id>http://yoursite.com/2019/02/02/redis/关于Redis一些重要的面试点/</id>
    <published>2019-02-02T13:39:56.932Z</published>
    <updated>2019-02-02T13:40:28.368Z</updated>
    
    <content type="html"><![CDATA[<p>这里整理一些面试题目，很多已经在前面的文章中详细说明了，这里算是总结一下。也补充了一点新的知识。</p><a id="more"></a><h2>Redis有哪些数据结构？</h2><p>字符串 <code>String</code>、字典 <code>Hash</code> 、列表 <code>List</code> 、集合 <code>Set</code> 、有序集合 <code>SortedSet</code>。</p><p>如果你是Redis中高级用户，还需要加上下面几种数据结构<code>HyperLogLog</code>、<code>Geo</code>、<code>Pub/Sub</code>。</p><h2>String类型的底层数据结构</h2><p>Redis 是一个键值对数据库, 数据库的值可以是字符串、集合、列表等多种类型的对象， 而数据库的键则总是字符串对象。</p><p>对于那些包含字符串值的字符串对象来说， 每个字符串对象都包含一个 <code>sds</code> 值。</p><div class="tip">“包含字符串值的字符串对象”，这种说法初听上去可能会有点奇怪， 但是在 Redis 中， 一个字符串对象除了可以保存字符串值之外， 还可以保存 long 类型的值， 所以为了严谨起见， 这里需要强调一下： 当字符串对象保存的是字符串时， 它包含的才是 sds 值， 否则的话， 它就是一个 long 类型的值。</div><p>举个例子， 以下命令创建了一个新的数据库键值对， 这个键值对的键和值都是字符串对象， 它们都包含一个 <code>sds</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET book &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET book</span><br><span class="line">&quot;Mastering C++ in 21 days&quot;</span><br></pre></td></tr></table></figure><p>目前来说， 只要记住这个事实即可： 在 <code>Redis</code> 中， 客户端传入服务器的协议内容、 aof 缓存、 返回给客户端的回复， 等等， 这些重要的内容都是由 <code>sds</code> 类型来保存的。</p><p>在 C 语言中，字符串可以用一个 <code>\0</code> 结尾的 <code>char</code> 数组来表示。</p><p>比如说， <code>hello world</code> 在 C 语言中就可以表示为 <code>&quot;hello world\0&quot;</code> 。</p><p>这种简单的字符串表示，在大多数情况下都能满足要求，但是，它并不能高效地支持长度计算和追加（<code>append</code>）这两种操作：</p><ul><li>每次计算字符串长度（<code>strlen(s)</code>）的复杂度为 θ(N) 。</li><li>对字符串进行 N 次追加，必定需要对字符串进行 N 次内存重分配（<code>realloc</code>）。</li></ul><p>在 <code>Redis</code> 内部， 字符串的追加和长度计算很常见， 而 <code>APPEND</code> 和 <code>STRLEN</code> 更是这两种操作，在 <code>Redis</code> 命令中的直接映射， 这两个简单的操作不应该成为性能的瓶颈。</p><p>另外， <code>Redis</code> 除了处理字符串之外， 还需要处理单纯的字节数组， 以及服务器协议等内容， 所以为了方便起见， <code>Redis</code> 的字符串表示还应该是二进制安全的： 程序不应对字符串里面保存的数据做任何假设， 数据可以是以 \0 结尾的 C 字符串， 也可以是单纯的字节数组， 或者其他格式的数据。</p><p>考虑到这两个原因， <code>Redis</code> 使用 <code>sds</code> 类型替换了 C 语言的默认字符串表示： sds 既可高效地实现追加和长度计算， 同时是二进制安全的。</p><p>在前面的内容中， 我们一直将 <code>sds</code> 作为一种抽象数据结构来说明， 实际上， 它的实现由以下两部分组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 已占用长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 剩余可用长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，类型 <code>sds</code> 是 <code>char *</code> 的别名（alias），而结构 <code>sdshdr</code> 则保存了 <code>len</code> 、 <code>free</code> 和 <code>buf</code> 三个属性。</p><p>作为例子，以下是新创建的，同样保存 <code>hello world</code> 字符串的 <code>sdshdr</code> 结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    len = 11;</span><br><span class="line">    free = 0;</span><br><span class="line">    buf = &quot;hello world\0&quot;;  // buf 的实际长度为 len + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>len</code> 属性， <code>sdshdr</code> 可以实现复杂度为 θ(1) 的长度计算操作。</p><p>另一方面， 通过对 <code>buf</code> 分配一些额外的空间， 并使用 <code>free</code> 记录未使用空间的大小， <code>sdshdr</code> 可以让执行追加操作所需的内存重分配次数大大减少。</p><p>为了易于理解，我们用一个 <code>Redis</code> 执行实例作为例子，解释一下，当执行以下代码时， <code>Redis</code> 内部发生了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND msg <span class="string">" again!"</span></span><br><span class="line">(integer) <span class="number">18</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world again!"</span></span><br></pre></td></tr></table></figure><p>首先， <code>SET</code> 命令创建并保存 <code>hello world</code> 到一个 <code>sdshdr</code> 中，这个 <code>sdshdr</code> 的值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    buf = <span class="string">"hello world\0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <code>APPEND</code> 命令时，相应的 <code>sdshdr</code> 被更新，字符串 &quot; again!&quot; 会被追加到原来的 “hello world” 之后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">18</span>;</span><br><span class="line">    buf = <span class="string">"hello world again!\0                  "</span>;     <span class="comment">// 空白的地方为预分配空间，共 18 + 18 + 1 个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中， 保存 “hello world again!” 共需要 18 + 1 个字节， 但程序却为我们分配了 18 + 18 + 1 = 37 个字节 —— 这样一来， 如果将来再次对同一个 <code>sdshdr</code> 进行追加操作， 只要追加内容的长度不超过 <code>free</code> 属性的值， 那么就不需要对 <code>buf</code> 进行内存重分配。</p><div class="tip">这种分配策略会浪费内存吗？执行过 APPEND 命令的字符串会带有额外的预分配空间， 这些预分配空间不会被释放， 除非该字符串所对应的键被删除， 或者等到关闭 Redis 之后， 再次启动时重新载入的字符串对象将不会有预分配空间。<p>因为执行 APPEND 命令的字符串键数量通常并不多， 占用内存的体积通常也不大， 所以这一般并不算什么问题。</p><p>另一方面， 如果执行 APPEND 操作的键很多， 而字符串的体积又很大的话， 那可能就需要修改 Redis 服务器， 让它定时释放一些字符串键的预分配空间， 从而更有效地使用内存。</p></div><p>当然， <code>sds</code> 也对操作的正确实现提出了要求 —— 所有处理 <code>sdshdr</code> 的函数，都必须正确地更新 <code>len</code> 和 <code>free</code> 属性，否则就会造成 bug 。</p><p>更多参见：<a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html" target="_blank" rel="noopener">简单动态字符串</a></p><h2>从海量数据中查询某一固定前缀的key</h2><p>使用<code>keys</code>指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<code>scan</code>指令，scan指令可以<strong>无阻塞</strong>的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><p>基于游标的迭代器，需要使用上一次游标延续之前的迭代过程。游标为0的时候代表开始或结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#模式</span><br><span class="line">scan cursor match pattern count</span><br><span class="line">#示例</span><br><span class="line">scan 0 match k* count 10</span><br></pre></td></tr></table></figure><h2>Redis做异步队列</h2><p>一般使用<code>list</code>结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当<code>lpop</code>没有消息的时候，要适当<code>sleep</code>一会再重试。</p><p>如果对方追问可不可以不用<code>sleep</code>呢？<code>list</code>还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p><p>如果对方追问能不能生产一次消费多次呢？使用<code>pub/sub</code>主题订阅者模式，可以实现1:N的消息队列。</p><p>如果对方追问<code>pub/sub</code>有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>rabbitmq</code>等。</p><p>如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用<code>sortedset</code>，拿时间戳作为<code>score</code>，消息内容作为<code>key</code>调用<code>zadd</code>来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理。</p><h2>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2>Redis如何做持久化的？</h2><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><p>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><p>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h2>Redis的同步机制了解么？</h2><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h2>是否使用过Redis集群，集群的原理是什么？</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p><p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><p>整理自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32540678" target="_blank" rel="noopener">天下无难试之Redis面试题刁难大全</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里整理一些面试题目，很多已经在前面的文章中详细说明了，这里算是总结一下。也补充了一点新的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>几种主流缓存框架介绍</title>
    <link href="http://yoursite.com/2019/02/02/redis/%E5%87%A0%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/02/02/redis/几种主流缓存框架介绍/</id>
    <published>2019-02-02T09:23:55.705Z</published>
    <updated>2019-02-02T09:25:59.892Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第十二篇文章。本文对Guava Cache,Memcache以及redis进行简单介绍和对比。</p><a id="more"></a><h2>缓存特征</h2><p>缓存都会涉及：命中率、最大元素、清空策略(<code>FIFO</code>,<code>LFU</code>,<code>LRU</code>,过期时间，随机)</p><h2>影响缓存命中率因素</h2><ul><li>业务场景和业务需求：适合读多写少的场景</li><li>缓存的设计(粒度和策略)：缓存粒度越小，命中率越高</li><li>缓存容量(经常用LRU)和基础设施(是否可扩展，避免缓存失效-一致性hash算法和几点冗余)</li></ul><h2>缓存分类</h2><ul><li>本地缓存：编程实现（成员变量、局部变量、静态变量）、Guava Cache</li><li>分布式缓存：Memcache，Redis</li></ul><p>本地缓存：各应用之间无法很好地共享，与应用本身耦合过紧；而分布式缓存，本身就是独立的应用，各独立应用之间共享缓存。</p><h2>Guava Cache</h2><p><img src="http://bloghello.oursnail.cn/GuavaCache.png" alt="image"></p><p>设计思想类似于jdk1.7中的<code>ConcurrentHashMap</code>，也是用多个<code>segments</code>的细粒度锁，在保证线程安全的同时，支持高并发场景的需求。</p><p>下面数据存储就是以键值对的形式存储，另外，需要处理缓存过期、动态加载等算法逻辑，所以需要一些额外的信息来实现这些操作。</p><p>主要实现的功能有：自动将节点加入到缓存结构中，当缓存的数据超过设置的最大值时，用LRU算法来移除。他具备根据节点上次被访问或者写入的时间来计算他的过期机制。</p><h2>memcache</h2><h5>memcache简单认识</h5><p><code>memcache</code>是一个高性能的分布式的内存对象缓存系统，它在内存里维护一个统一的巨大的<code>hash</code>表。能用来缓存各种格式的数据，包括图像、视频、文件以及数据库检索等结果.</p><p><code>memcache</code>是以守护程序方式运行于一个或多个服务器中，随时会接收客户的连接和操作。</p><p>存在<code>memcache</code>中的对象实际放置在内存中，这也是<code>memcache</code>如此高效的原因。</p><p>本身是不提供分布式的解决方案的。分布式是在客户端实现的，通过客户端的路由来处理达到分布式的目的。</p><p>应用服务器每次在存储某个<code>key</code>和<code>value</code>的时候，通过某种算法把<code>key</code>映射到某台服务器上。</p><h5>一致性hash算法</h5><p>客户端实现分布式：一致性<code>hash</code>算法，<a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">这个算法已经详细介绍过了</a>。</p><p><img src="http://bloghello.oursnail.cn/memcache%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="image"></p><h5>memcache一些特性</h5><blockquote><p><code>Memcached</code>单进程在32位系统中最大使用内存为2G，若在64位系统则没有限制,这是由于32位系统限制单进程最多可使用2G内存,要使用更多内存，可以分多个端口开启多个<code>Memcached</code>进程。</p></blockquote><p>32 位寻址空间只有 4GB 大小，于是 32 位应用程序进程最大只能用到 4GB 的内存。然而，除了应用程序本身要用内存，操作系统内核也需要使用。应用程序使用的内存空间分为用户空间和内核空间，每个 32 位程序的用户空间可独享前 2GB 空间（指针值为正数），而内核空间为所有进程共享 2GB 空间（指针值为负数）。所以，32 位应用程序实际能够访问的内存地址空间最多只有 2GB。</p><blockquote><p>最大30天的数据过期时间，设置为永久也会在这个时间过期。最长键长为250字节，大于该长度无法存储。最大同时连接数是200;</p></blockquote><blockquote><p><code>memcache</code>是一种无阻塞的<code>socket</code>通信方式服务，基于<code>libevent</code>库，犹豫无阻塞通信，对内存读写速度非常快。</p></blockquote><h5>不适用memcached的业务场景？</h5><blockquote><p>缓存对象的大小大于1MB</p></blockquote><blockquote><p>虚拟主机不让运行<code>memcached</code>服务</p></blockquote><blockquote><p>key的长度大于250字符</p></blockquote><blockquote><p>需要持久化</p></blockquote><h5>不能够遍历memcached中所有的item？</h5><p>这个操作的速度相对缓慢且阻塞其他的操作</p><h5>memcache如何分配内存？</h5><p>这张图片里面涉及了<code>slab_class</code>、<code>slab</code>、<code>page</code>、<code>chunk</code>四个概念，它们之间的关系是：</p><ul><li><code>MemCache</code>将内存空间分为一组<code>slab</code></li><li>每个<code>slab</code>下又有若干个<code>page</code>，每个<code>page</code>默认是1M，如果一个<code>slab</code>占用100M内存的话，那么这个slab下应该有100个page</li><li>每个page里面包含一组<code>chunk</code>，<code>chunk</code>是真正存放数据的地方，同一个<code>slab</code>里面的<code>chunk</code>的大小是固定的</li><li>有相同大小<code>chunk</code>的<code>slab</code>被组织在一起，称为<code>slab_class</code></li></ul><p><img src="http://bloghello.oursnail.cn/memcache%E5%8E%9F%E7%90%86.png" alt="image"></p><p><strong>那么是具体如何分配的呢？</strong></p><blockquote><p><code>MemCache</code>中的<code>value</code>过来存放的地方是由<code>value</code>的大小决定的，<code>value</code>总是会被存放到与<code>chunk</code>大小最接近的一个<code>slab</code>中，比如<code>slab[1]</code>的<code>chunk</code>大小为80字节、<code>slab[2]</code>的<code>chunk</code>大小为100字节、<code>slab[3]</code>的<code>chunk</code>大小为128字节（相邻<code>slab</code>内的<code>chunk</code>基本以1.25为比例进行增长，<code>MemCache</code>启动时可以用-f指定这个比例），那么过来一个88字节的<code>value</code>，这个<code>value</code>将被放到2号<code>slab</code>中。</p></blockquote><blockquote><p>放<code>slab</code>的时候，首先<code>slab</code>要申请内存，申请内存是以<code>page</code>为单位的，所以在放入第一个数据的时候，无论大小为多少，都会有1M大小的<code>page</code>被分配给该<code>slab</code>。申请到<code>page</code>后，<code>slab</code>会将这个<code>page</code>的内存按<code>chunk</code>的大小进行切分，这样就变成了一个<code>chunk</code>数组，最后从这个<code>chunk</code>数组中选择一个用于存储数据。</p></blockquote><blockquote><p>如果这个slab中没有<code>chunk</code>可以分配了怎么办，如果<code>MemCache</code>启动没有追加-M（禁止LRU，这种情况下内存不够会报<code>Out Of Memory</code>错误），那么<code>MemCache</code>会把这个<code>slab</code>中最近最少使用的<code>chunk</code>中的数据清理掉，然后放上最新的数据。</p></blockquote><blockquote><ol><li><code>MemCache</code>的内存分配<code>chunk</code>里面会有内存浪费，88字节的<code>value</code>分配在128字节（紧接着大的用）的<code>chunk</code>中，就损失了30字节，但是这也避免了管理内存碎片的问题</li></ol></blockquote><blockquote><ol start="2"><li><code>MemCache</code>的<code>LRU</code>算法不是针对全局的，是针对<code>slab</code>的</li></ol></blockquote><blockquote><ol start="3"><li>该可以理解为什么<code>MemCache</code>存放的<code>value</code>大小是限制的，因为一个新数据过来，<code>slab</code>会先以<code>page</code>为单位申请一块内存，申请的内存最多就只有1M，所以<code>value</code>大小自然不能大于1M了</li></ol></blockquote><h5>最后再总结一下memcache</h5><ul><li><code>MemCache</code>中可以保存的<code>item</code>数据量是没有限制的，只要内存足够</li><li><code>MemCache</code>单进程在32位机中最大使用内存为2G，64位机则没有限制</li><li><code>Key</code>最大为250个字节，超过该长度无法存储</li><li>单个<code>item</code>最大数据是1MB，超过1MB的数据不予存储</li><li><code>MemCache</code>服务端是不安全的，比如已知某个<code>MemCache</code>节点，可以直接<code>telnet</code>过去，并通过<code>flush_all</code>让已经存在的键值对立即失效</li><li>不能够遍历<code>MemCache</code>中所有的<code>item</code>，因为这个操作的速度相对缓慢且会阻塞其他的操作</li><li><code>MemCache</code>的高性能源自于两阶段哈希结构：第一阶段在客户端，通过<code>Hash</code>算法根据<code>Key</code>值算出一个节点；第二阶段在服务端，通过一个内部的<code>Hash</code>算法，查找真正的<code>item</code>并返回给客户端。从实现的角度看，<code>MemCache</code>是一个非阻塞的、基于事件的服务器程序</li><li><code>MemCache</code>设置添加某一个<code>Key</code>值的时候，传入<code>expire</code>为0表示这个<code>Key</code>值永久有效，这个<code>Key</code>值也会在30天之后失效</li></ul><h2>redis</h2><h5>redis特点</h5><ul><li>支持数据持久化，可以将内存中的数据保存到磁盘。</li><li>支持更多的数据结构</li><li>支持数据备份</li><li>性能极高，读可以达到11万次每秒；写达到8万1千次每秒</li><li>redis所有操作都是原子性，并且支持几个操作一起的原子性</li><li>支持发布-订阅功能</li></ul><h5>redis适用场景</h5><ul><li>取最新n个数据、排行榜</li><li>精准过期时间</li><li>计数器</li><li>唯一性检查</li><li>实时系统、垃圾系统、缓存等</li></ul><h2>redis VS memcache</h2><p>当提到<code>redis</code>就问<code>memcache</code>，当提到<code>memcache</code>就提到<code>redis</code>，说明这两者用的都十分广泛，<code>redis</code>号称“强化版<code>memcached</code>”，他们之间的区别到底是啥呢？</p><ul><li>基本命令</li></ul><blockquote><p><code>memcache</code>支持的命令很少，因为他只支持<code>String</code>的操作，通讯协议包括文本格式和二进制格式，用于满足简单网络客户端工具（如<code>telnet</code>）和对性能要求更高的客户端的不同需求；<code>redis</code>操作类似，只是数据结构更复杂以支持更多的特性，如发布订阅、消息队列等。<code>redis</code>的客户端-服务器通讯协议完全采用文本格式(Redis Cluster服务端节点之间通讯采用二进制格式)。</p></blockquote><ul><li>事务</li></ul><blockquote><p><code>redis</code>通过<code>multi</code> / <code>watch</code> / <code>exec</code>等命令可以支持事务的概念，原子性的执行一批命令;</p><p><code>memcache</code>:即使在多线程模式，所有的命令都是原子的；命令序列不是原子的。在并发的情况下，您也可能覆写了一个被其他进程set的item。<code>memcached 1.2.5</code>以及更高版本，提供了<code>gets</code>和<code>cas</code>命令，它们可以解决上面的问题。如果您使用<code>gets</code>命令查询某个<code>key</code>的<code>item</code>，<code>memcached</code>会给您返回该<code>item</code>当前值的唯一标识。如果您覆写了这个<code>item</code>并想把它写回到<code>memcached</code>中，您可以通过<code>cas</code>命令把那个唯一标识一起发送给 <code>memcached</code>。如果该<code>item</code>存放在<code>memcached</code>中的唯一标识与您提供的一致，您的写操作将会成功。如果另一个进程在这期间也修改了这个 <code>item</code>，那么该<code>item</code>存放在<code>memcached</code>中的唯一标识将会改变，您的写操作就会失败。</p></blockquote><ul><li>数据备份，有效性，持久化等</li></ul><blockquote><p><code>memcached</code>不保证存储的数据的有效性，<code>slab</code>内部基于<code>LRU</code>也会自动淘汰旧数据;<code>memcached</code>也不做数据的持久化工作;</p><p><code>redis</code>可以以<code>master-slave</code>的方式配置服务器，<code>slave</code>节点对数据进行<code>replica</code>备份，<code>slave</code>节点也可以充当<code>read only</code>的节点分担数据读取的工作;<code>redis</code>内建支持两种持久化方案，<code>snapshot</code>快照和<code>AOF</code>增量<code>Log</code>方式。</p></blockquote><ul><li>性能</li></ul><blockquote><p><code>memcached</code>自身并不主动定期检查和标记哪些数据需要被淘汰，只有当再次读取相关数据时才检查时间戳，或者当内存不够使用需要主动淘汰数据时进一步检查<code>LRU</code>数据。</p><p><code>redis</code>为了减少大量小数据CMD操作的网络通讯时间开销 <code>RTT (Round Trip Time)</code>，支持<code>pipeline</code>和<code>script</code>技术。</p></blockquote><ul><li>集群</li></ul><blockquote><p><code>memcached</code>的服务器端互相完全独立，客户端通常通过对键值应用<code>hash</code>算法决定数据的分区，为了减少服务器的增减对<code>hash</code>结果的影响，导致大面积的缓存失效，多数客户端实现了一致性<code>hash</code>算法。</p><p><code>redis3.0</code>已经支持服务端集群了。</p></blockquote><ul><li>性能对比</li></ul><blockquote><p>由于<code>redis</code>只使用单核，而<code>memcached</code>可以使用多核，所以平均每一个核上<code>redis</code>在存储小数据时比<code>memcached</code>性能更高。而在100k以上的数据中，<code>memcached</code>性能要高于<code>redis</code>，虽然<code>redis</code>最近也在存储大数据的性能上进行优化，但是比起<code>memcached</code>，还是稍有逊色</p></blockquote><ul><li>内存使用效率</li></ul><blockquote><p>使用简单的<code>key-value</code>存储的话，<code>memcached</code>的内存利用率更高，而如果<code>redis</code>采用<code>hash</code>结构来做<code>key-value</code>存储，由于其组合式的压缩，其内存利用率会高于<code>memcached</code>。另外，<code>memcached</code>使用预分配的内存池的方式，带来一定程度的空间浪费 并且在内存仍然有很大空间时，新的数据也可能会被剔除，而<code>redis</code>使用现场申请内存的方式来存储数据，不会剔除任何非临时数据 redis更适合作为存储而不是<code>cache</code>。</p></blockquote><ul><li><code>redis</code>支持服务器端的数据操作</li></ul><blockquote><p><code>redis</code>相比<code>memcached</code>来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在<code>memcached</code>里，你需要将数据拿到客户端来进行类似的修改再<code>set</code>回去。这大大增加了网络IO的次数和数据体积。在<code>redis</code>中，这些复杂的操作通常和一般的<code>GET/SET</code>一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么<code>redis</code>会是不错的选择</p></blockquote><hr><p>何时应该使用<code>memcache</code>:</p><blockquote><p>首先就是对小型静态数据进行缓存处理，最具代表性的例子就是HTML代码片段。这是因为<code>memcached</code>在处理元数据时所消耗的内存资源相对更少.</p><p>在以前，<code>redis3.0</code>版本之前，<code>memcached</code>在横向扩展方面也比<code>redis</code>更具优势。由于其在设计上的思路倾向以及相对更为简单的功能设置，<code>memcached</code>在实现扩展时的难度比redis低得多。</p></blockquote><p>何时应该使用<code>redis</code>：</p><blockquote><p>其他场景都可以用<code>redis</code>来替换。</p><p>相比于武断的<code>LRU</code>(即最低近期使用量)算法，<code>redis</code>允许用户更为精准地进行细化控制，利用六种不同回收策略确切提高缓存资源的实际利用率。<code>redis</code>还采用更为复杂的内存管理与回收对象备选方案。</p><p><code>memcached</code>将键名限制在250字节，值也被限制在不超过1MB，且只适用于普通字符串。<code>redis</code>则将键名与值的最大上限各自设定为512MB，且支持二进制格式。</p><p>它所保存的数据具备透明化特性，也就是说服务器能够直接对这些数据进行操作.</p><p><code>redis</code>还提供可选而且能够具体调整的数据持久性方案</p><p><code>redis</code>能够提供复制功能。复制功能旨在帮助缓存体系实现高可用性配置方案，从而在遭遇故障的情况下继续为应用程序提供不间断的缓存服务。</p></blockquote><p>使用<code>redis</code>的正确姿势：</p><blockquote><p>要进行<code>master-slave</code>配置，出现服务故障时可以支持切换。</p><p>在<code>master</code>侧禁用数据持久化，只需在<code>slave</code>上配置数据持久化。</p><p>物理内存+虚拟内存不足，这个时候<code>dump</code>一直死着，时间久了机器挂掉。这个情况就是灾难。</p><p>当<code>redis</code>物理内存使用超过内存总容量的3/5时就会开始比较危险了，就开始做<code>swap</code>,内存碎片大。</p><p>当达到最大内存时，会清空带有过期时间的<code>key</code>，即使<code>key</code>未到过期时间。</p><p><code>redis</code>与<code>DB</code>同步写的问题，先写<code>DB</code>，后写<code>redis</code>，因为写内存基本上没有问题。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第十二篇文章。本文对Guava Cache,Memcache以及redis进行简单介绍和对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务</title>
    <link href="http://yoursite.com/2019/02/02/redis/Redis%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/02/02/redis/Redis事务/</id>
    <published>2019-02-02T08:40:34.945Z</published>
    <updated>2019-02-02T08:40:46.136Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第十一篇文章。详细探讨redis事务的用法和原理。</p><a id="more"></a><p>redis 事务是一组命令的集合，至少是两个或两个以上的命令，redis 事务保证这些命令被执行时中间不会被任何其他操作打断。</p><h3>事务基本认识</h3><p>当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行。</p><p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队。</p><p><img src="http://xiaozhao.oursnail.cn/redis%E4%BA%8B%E5%8A%A1.svg" alt="image"></p><h3>事务执行</h3><p>前面说到， 当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。</p><p>但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 <code>EXEC</code> 、 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code> 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：</p><p><img src="http://xiaozhao.oursnail.cn/redis%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1.svg" alt="image"></p><p>如果客户端正处于事务状态， 那么当 <code>EXEC</code> 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（<code>FIFO</code>）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p><h3>事务基本命令介绍</h3><p>除了 <code>EXEC</code> 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code> 。</p><p><code>DISCARD</code> 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。</p><p><code>Redis</code> 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 <code>MULTI</code> 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 <code>MULTI</code> 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p><p><code>WATCH</code> 只能在客户端进入事务状态之前执行， 在事务状态下发送 <code>WATCH</code> 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 <code>MULTI</code> 的情况一样）。</p><h3>正常情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//命令入队</span><br><span class="line">exec//提交事务（执行命令）</span><br></pre></td></tr></table></figure><h3>异常情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">set key//错误命令，直接报错</span><br><span class="line">exec//事务被丢弃，提交失败</span><br></pre></td></tr></table></figure><h3>例外情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">incr key//虽然字符串不能增一，但是不报错，入队</span><br><span class="line">exec//自增会失败，但是key被设置成功了，整个事务没有回滚</span><br></pre></td></tr></table></figure><h3>放弃事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">discard</span><br></pre></td></tr></table></figure><h3>乐观锁</h3><p>乐观锁：每次拿数据的时候都认为别人不会修改该数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这条数据，一般使用版本号进行判断，乐观锁使用于读多写少的应用类型，这样可以提高吞吐量。</p><p>乐观锁大多情况是根据数据版本号(<code>version</code>)的机制实现的，何为数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库添加一个<code>version</code>字段来实现读取出数据时，将此版本号一起读出，之后更新时，对此版本号加1，此时将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库表的当前版本，则予以更新，否则认为是过期数据，不予更新。</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>读出版本号为1，操作</td><td>A操作时，读出版本号也为1，进行某个操作(修改)</td></tr><tr><td>执行修改，version+1=2，因为2&gt;1，所以更新</td><td>…</td></tr><tr><td>…</td><td>执行修改，version+1=2，发现数据库记录的版本也为2，2=2,更新失败</td></tr></tbody></table><h3>watch机制</h3><p><code>WATCH</code> 命令用于在事务开始之前监视任意数量的键： 当调用 <code>EXEC</code> 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set k1 1     //设置k1值为1</span><br><span class="line">watch k1     //监视k1(其他客户端不能修改k1值)</span><br><span class="line">set k1 2     //设置k1值为2</span><br><span class="line">multi        //开始事务</span><br><span class="line">set k1 3     //修改k1值为3</span><br><span class="line">exex         //提交事务，k1值仍为2，因为事务开始之前k1值被修改了</span><br></pre></td></tr></table></figure><h3>watch机制举例</h3><p>大家可能知道<code>redis</code>提供了基于<code>incr</code>命令来操作一个整数型数值的原子递增，那么我们假设如果<code>redis</code>没有这个<code>incr</code>命令，我们该怎么实现这个<code>incr</code>的操作呢？</p><p>正常情况下我们想要对一个整形数值做修改是这么做的(伪代码实现)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure><p>但是上述的代码会出现一个问题,因为上面吧正常的一个<code>incr</code>(原子递增操作)分为了两部分,那么在多线程(分布式)环境中，这个操作就有可能不再具有原子性了。</p><p>研究过<code>java</code>的<code>juc</code>包的人应该都知道<code>cas</code>，那么<code>redis</code>也提供了这样的一个机制，就是利用<code>watch</code>命令来实现的。</p><p>具体做法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>和此前代码不同的是，新代码在获取<code>mykey</code>的值之前先通过<code>WATCH</code>命令监控了该键，此后又将<code>set</code>命令包围在事务中，这样就可以有效的保证每个连接在执行<code>EXEC</code>之前，如果当前连接获取的<code>mykey</code>的值被其它连接的客户端修改，那么当前连接的<code>EXEC</code>命令将执行失败。这样调用者在判断返回值后就可以获悉<code>val</code>是否被重新设置成功。</p><p>由于<code>WATCH</code>命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以在一般的情况下我们需要在<code>EXEC</code>执行失败后重新执行整个函数。</p><p>执行<code>EXEC</code>命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用<code>UNWATCH</code>命令来取消监控。</p><h3>watch机制原理</h3><h4>WATCH 命令的实现</h4><p>在每个代表数据库的 <code>redis.h/redisDb</code> 结构类型中， 都保存了一个 <code>watched_keys</code> 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。</p><p>比如说，以下字典就展示了一个 <code>watched_keys</code> 字典的例子：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%861.svg" alt="image"></p><p>其中， 键 <code>key1</code> 正在被 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p><p><code>WATCH</code> 命令的作用， 就是将当前客户端和要监视的键在 <code>watched_keys</code> 中进行关联。</p><p>举个例子， 如果当前客户端为 <code>client10086</code> ， 那么当客户端执行 <code>WATCH key1 key2</code> 时， 前面展示的 <code>watched_keys</code> 将被修改成这个样子：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%862.svg" alt="image"></p><p>通过 <code>watched_keys</code> 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p><h4>WATCH 的触发</h4><p>在任何对数据库键空间（<code>key space</code>）进行修改的命令成功执行之后 （比如 <code>FLUSHDB</code> 、 <code>SET</code> 、 <code>DEL</code> 、 <code>LPUSH</code> 、 <code>SADD</code> 、 <code>ZREM</code> ，诸如此类）， <code>multi.c/touchWatchedKey</code> 函数都会被调用 —— 它检查数据库的 <code>watched_keys</code> 字典， 看是否有客户端在监视已经被命令修改的键， 如果有的话， 程序将所有监视这个/这些被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%863.svg" alt="image"></p><p>当客户端发送 <code>EXEC</code> 命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p><ul><li>如果客户端的 <code>REDIS_DIRTY_CAS</code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li><li>如果 <code>REDIS_DIRTY_CAS</code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li></ul><p>举个例子，假设数据库的 <code>watched_keys</code> 字典如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%864.svg" alt="image"></p><p>如果某个客户端对 <code>key1</code> 进行了修改（比如执行 <code>DEL key1</code> ）， 那么所有监视 <code>key1</code> 的客户端， 包括 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 的 <code>REDIS_DIRTY_CAS</code> 选项都会被打开， 当客户端 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 执行 <code>EXEC</code> 的时候， 它们的事务都会以失败告终。</p><p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code>watched_keys</code> 字典中和这个客户端相关的资料都会被清除。</p><h3>事务的 ACID 性质</h3><p><code>Redis</code> 事务保证了其中的一致性（偶尔也有可能不一致）和隔离性，但并不保证原子性和持久性。</p><h4>原子性（Atomicity）</h4><p>单个 <code>Redis</code> 命令的执行是原子性的，但 <code>Redis</code> 没有在事务上增加任何维持原子性的机制，所以 <code>Redis</code> 事务的执行并不是原子性的。</p><p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p><p>另一方面，如果 <code>Redis</code> 服务器进程在执行事务的过程中被停止 —— 比如接到 <code>KILL</code> 信号、宿主机器停机，等等，那么事务执行失败。</p><p>当事务失败时，<code>Redis</code> 也不会进行任何的重试或者回滚动作。</p><h4>一致性（Consistency）</h4><p><code>Redis</code> 的一致性问题可以分为三部分来讨论：入队错误、执行错误、<code>Redis</code> 进程被终结。</p><p>前面两者上面已经讨论过了，这里再重复一下.</p><ul><li>入队错误</li></ul><p>入队错误一般是错误的命令(不考虑能不能执行，命令本身就是错误的)，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性；</p><ul><li>执行错误</li></ul><p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 <code>key</code> 执行了错误的操作， 那么 <code>Redis</code> 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。</p><ul><li><code>Redis</code> 进程被终结</li></ul><p>如果 <code>Redis</code> 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 <code>Redis</code> 所使用的持久化模式，可能有以下情况出现：</p><blockquote><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p></blockquote><blockquote><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。所以显然会造成不一致</p></blockquote><blockquote><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行,如果事务语句未写入到 AOF 文件，那么显然是一致的，因为事务里的操作全部失败；如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p></blockquote><h4>隔离性（Isolation）</h4><p><code>Redis</code> 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<code>Redis</code> 的事务是总是带有隔离性的。</p><h4>持久性（Durability）</h4><ul><li>在单纯的内存模式下，事务肯定是不持久的。</li><li>在 <code>RDB</code> 模式下，服务器可能在事务执行之后、<code>RDB</code> 文件更新之前的这段时间宕机，所以 <code>RDB</code> 模式下的 <code>Redis</code> 事务也是不持久的。</li><li>在 <code>AOF</code> 的“总是 <code>SYNC</code> ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code>fsync</code> 或 <code>fdatasync</code> 将事务数据写入到 <code>AOF</code> 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，服务器也有可能出现问题，所以这种模式下的事务也是不持久的。</li><li>都是不持久的。</li></ul><h3>总结</h3><ul><li><code>MULTI</code> 命令的执行标记着事务的开始</li><li>当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队</li><li><code>Redis</code> 的事务保证了 <code>ACID</code> 中的一致性（C）（偶尔也有可能不一致）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li><li>不加入到事务队列而直接执行的四个命令为：<code>EXEC</code> 、 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code></li><li><code>DISCARD</code> 命令用于取消一个事务</li><li><code>Redis</code> 的事务是不可嵌套的</li><li><code>WATCH</code> 只能在客户端进入事务状态之前执行</li><li><code>WATCH</code>机制的原理</li></ul><p>参考：</p><ul><li><a href="http://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">事务</a></li><li><a href="https://www.jianshu.com/p/361cb9cd13d5" target="_blank" rel="noopener">redis的事务和watch</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第十一篇文章。详细探讨redis事务的用法和原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存更新</title>
    <link href="http://yoursite.com/2019/02/02/redis/Redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/02/redis/Redis缓存更新问题/</id>
    <published>2019-02-02T08:20:25.621Z</published>
    <updated>2019-02-02T08:21:28.514Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第十篇文章。redis缓存更新策略学习。</p><a id="more"></a><p>更新缓存的的<code>Design Pattern</code>有四种：<code>Cache aside</code>, <code>Read through</code>, <code>Write through</code>, <code>Write behind caching</code>，我们下面一一来看一下这四种<code>Pattern</code>。这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，<strong>我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）</strong>。</p><p>先来看看缓存可能存在的一些问题，目的是突出缓存使用策略选择的重要性。</p><h2>1.缓存穿透</h2><p>缓存穿透是说访问一个缓存中没有的数据，但是这个数据数据库中也不存在。</p><p>解决方案是：</p><ul><li>缓存空对象。如果缓存未命中，而数据库中也没有这个对象，则可以缓存一个空对象到缓存。如果使用<code>Redis</code>，这种<code>key</code>需设置一个较短的时间，以防内存浪费。</li><li>缓存预测。预测<code>key</code>是否存在。如果缓存的量不大可以使用<code>hash</code>来判断，如果量大可以使用布隆过滤器来做判断。采用布隆，将所有可能存在的数据哈希到一个足够大的<code>BitSet</code>中，不存在的数据将会被拦截掉，从而避免了对存储系统的查询压力。</li></ul><h2>2.缓存并发</h2><p>多个客户端同时访问一个没有在<code>cache</code>中的数据，这时每个客户端都会执行从<code>DB</code>加载数据<code>set</code>到缓存，就会造成缓存并发。</p><ul><li>缓存预热。提前把所有预期的热数据加到缓存。定位热数据还是比较复杂的事情，需要根据自己的服务访问情况去评估。这个方案只能减轻缓存并发的发生次数不能全部抵制。</li><li>缓存加锁。 如果多个客户端访问不存在的缓存时，在执行加载数据并<code>set</code>缓存这个逻辑之前先加锁，只能让一个客户端执行这段逻辑。</li></ul><h2>3.缓存雪崩</h2><p>缓存雪崩是缓存服务暂时不能提供服务，导致所有的请求都直接访问DB。</p><p>解决方案：</p><ul><li>构建高可用的缓存系统。目前常用的缓存系统<code>Redis</code>和<code>Memcache</code>都支持高可用的部署方式，所以部署的时候不防先考虑是否要以高可用的集群方式部署。</li><li>限流。<code>Netflix</code>的<code>Hystrix</code>是非常不错的工具，在用缓存时不妨搭配它来使用。</li></ul><h2>4.Cache Aside Pattern</h2><p><strong>一种错误的做法是</strong>：先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，直到这个缓存失效为止。</p><p><code>Cache Aside Pattern</code>是最常用最常用的<code>pattern</code>了。其具体逻辑如下：</p><ul><li>失效：应用程序先从<code>cache</code>取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从<code>cache</code>中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p><strong>注意，我们的更新是先更新数据库，成功后，让缓存失效</strong>。那么，这种方式是否可以没有文章前面提到过的那个问题呢？</p><p>一个是查询操作，一个是更新操作的并发，首先，没有了删除<code>cache</code>数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。<strong>而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据</strong>。</p><p><strong>但还是存在问题的</strong>。比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。不过，实际上出现的概率可能非常低.</p><p>所以，这也就是<code>Quora</code>上的那个答案里说的，要么通过<code>2PC</code>或是<code>Paxos</code>协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而<code>Facebook</code>使用了这个降低概率的玩法，因为<code>2PC</code>太慢，而<code>Paxos</code>太复杂。当然，最好还是为缓存设置上过期时间。</p><h2>5.Read/Write Through Pattern</h2><ul><li><code>Read Through</code>：读取数据的时候如果当前缓存中没有数据，惯常的操作都是应用程序去<code>DB</code>加载数据，然后加入到缓存中。<code>Read Through</code>与之不同的是我们不需要在应用程序自己加载数据了，缓存层会帮忙做件事。</li><li><code>Write Through</code>：更新数据的时候，如果命中缓存，则先更新缓存然后缓存在负责把数据更新到数据库；如果没有命中缓存则直接更新数据库。</li></ul><p>这种方式缓存层直接屏蔽了DB，应用程序只需要更缓存打交道。优点是应用逻辑简单了，而且更高效了；缺点是缓存层的实现相对复杂一些。</p><h2>6.Write Back Pattern</h2><p><code>Write Back</code>套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的<code>I/O</code>操作飞快无比（因为直接操作内存嘛 ），因为异步，<code>write backg</code>还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p><p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道<code>Unix/Linux</code>非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。</p><p>另外，<code>Write Back</code>实现逻辑比较复杂，因为他需要<code>track</code>有哪数据是被更新了的，需要刷到持久层上。操作系统的<code>write back</code>会在仅当这个<code>cache</code>需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫<code>lazy write</code>。</p><h2>7.实际使用的一些策略</h2><h4>业务方（调用者）更新</h4><p>传统上，更新缓存都是由业务方来做，也就是由调用者负责更新DB和缓存。</p><h4>DB中间件监听DB变化，更新缓存</h4><p>现在有种新的办法就是利用<code>DB</code>中间件监听<code>DB</code>变化（比如阿里的<code>Canal</code>中间件，点评的<code>Puma</code>），从而对缓存进行更新。<br>这种办法的一个好处就是：把缓存的更新逻辑，和业务逻辑解藕。业务只更新DB，缓存的更新被放在另外一个专门的系统里面。</p><h2>8.总结</h2><p>一句话，无论谁先谁后，只要更新缓存和更新DB不是原子的，就可能导致不一致。</p><p>总之，只是从实际业务来讲，一般缓存也都是保持“最终一致性“，而不是和<code>DB</code>的强一致性。</p><p><strong>并且一般建议先更新DB，再更新缓存，优先保证DB数据正确。</strong></p><h2>9.一致性问题</h2><p>上面，我们没有考虑缓存（<code>Cache</code>）和持久层（<code>Repository</code>）的整体事务的问题。比如，更新<code>Cache</code>成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——<code>prepare</code>, <code>commit/rollback</code>.后续再探讨。</p><ul><li>参考1：<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a></li><li>参考2：<a href="https://www.jianshu.com/p/3c111e4719b8" target="_blank" rel="noopener">https://www.jianshu.com/p/3c111e4719b8</a></li><li>参考3：<a href="https://blog.csdn.net/chunlongyu/article/details/53384933" target="_blank" rel="noopener">缓存更新策略/缓存穿透/缓存雪崩</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第十篇文章。redis缓存更新策略学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存设计与优化</title>
    <link href="http://yoursite.com/2019/02/01/redis/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/02/01/redis/缓存设计与优化/</id>
    <published>2019-02-01T13:46:13.441Z</published>
    <updated>2019-02-01T13:48:51.350Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第九篇文章。介绍redis缓存中 一些重要的问题。</p><a id="more"></a><h2>1. 缓存收益和成本</h2><h4>1.1 收益</h4><ul><li>加速读写</li><li>降低后端负载(降低mysql负载)</li></ul><h4>1.2 成本</h4><ul><li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</li><li>代码维护成本：多了一层缓存逻辑</li><li>运维成本：例如<code>redis cluster</code></li></ul><h4>1.3 使用场景</h4><ul><li>降低后端负载：对于高消耗的SQL：join结果集、分组统计结果；对这些结果进行缓存。</li><li>加速请求响应</li><li>大量写合并为批量写：如计数器先redis累加再批量写入DB</li></ul><h2>2. 缓存的更新策略</h2><ul><li><code>LRU/LFU/FIFO</code>算法剔除：例如<code>maxmemory-policy</code></li></ul><blockquote><p><code>FIFO(first in first out)</code></p><p>先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。</p><p><code>LFU(less frequently used)</code></p><p>最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。</p><p><code>LRU(least recently used)</code></p><p>最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</p></blockquote><ul><li>超时剔除：例如<code>expire</code></li><li>主动更新：开发控制生命周期（最终一致性，时间间隔比较短）</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/51026002.jpg" alt="image"></p><ul><li>低一致性：最大内存和淘汰策略</li><li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底。</li></ul><h2>3. 缓存粒度控制</h2><p><img src="http://bloghello.oursnail.cn/18-5-12/56376367.jpg" alt="image"></p><h4>3.1 缓存粒度控制三个角度</h4><ul><li>通用性：全量属性更好(添加删除属性不需要改东西)</li><li>占用空间：部分属性更好</li><li>代码维护：表面上全量属性更好(添加删除属性不需要改东西)</li></ul><h2>4. 缓存穿透优化</h2><h4>4.1 定义</h4><p>大量请求不命中,缓存已经没有存在的意义了：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/69826621.jpg" alt="image"></p><h4>4.2 产生原因</h4><ul><li>业务代码自身问题</li><li>恶意攻击、爬虫等</li></ul><h4>4.3 如何发现</h4><ul><li>业务响应时间</li><li>业务本身问题</li><li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ul><h4>4.4 解决方案</h4><ul><li>方案一：缓存空对象</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/30770379.jpg" alt="image"></p><blockquote><p>存在的问题</p><p>需要更多的键:恶意攻击、爬虫会有很多乱七八糟的键，当量很大时，会有风险，所以会对这种空对象设置缓存时间控制风险</p><p>缓存层和存储层数据“短期”不一致：缓存了空对象，但是当业务恢复了，真实数据又存在于DB中了，那么在这个空对象过期时间内，取到的仍然是空对象，造成短期内数据不一致的问题。解决：可以订阅消息，当恢复正常后接受到消息，然后刷新缓存。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/91489515.jpg" alt="image"></p><ul><li>方案二：布隆过滤器拦截</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/74465100.jpg" alt="image"></p><p>什么是<code>Bloom Filter</code>？</p><blockquote><p>布隆过滤器（<code>Bloom Filter</code>）是1970年由布隆提出的, “<code>a space-efficient probabilistic data structure</code>”。它实际上是一个很长的二进制矢量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，<code>Hash table</code>）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为<code>O(n),O(log n),O(n/k)</code>。</p><p><strong>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1</strong>。</p><p>优点：相比于其它的数据结构，<ins>布隆过滤器在空间和时间方面都有巨大的优势</ins>。布隆过滤器存储空间和插入/查询时间都是常数（O（k））。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。布隆过滤器可以表示全集，其它任何数据结构都不能；k和m相同，使用同一组散列函数的两个布隆过滤器的交并差运算可以使用位操作进行。</p><p>缺点：但是布隆过滤器的缺点和优点一样明显。<ins>误算率是其中之一</ins>。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。另外，<ins>一般情况下不能从布隆过滤器中删除元素</ins>。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1,这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/60082067.jpg" alt="image"></p><p>检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：<ins>如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在</ins>。这就是布隆过滤器的基本思想。</p><p><code>Bloom Filter</code>应用场景？</p><p><img src="http://bloghello.oursnail.cn/18-5-12/1394689.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-5-12/76148797.jpg" alt="image"></p><p>用<code>Redis</code>的<code>Bitmap</code>作为位数组构建起来的可扩展的布隆过滤器。</p><p><a href="https://blog.csdn.net/NEWCIH/article/details/78934420" target="_blank" rel="noopener">Redis实现的布隆过滤器如何快速有效删除数据？</a>：EXPIRE “bitmap的key值” 0</p><h4>4.5 解决方案对比</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/38205091.jpg" alt="image"></p><h2>5. 无底洞问题优化</h2><h4>5.1 问题描述</h4><ul><li>2010年，facebook有了3000个<code>Memcache</code>节点</li><li>发现问题：&quot;加&quot;机器性能没能提升，反而下降</li></ul><h4>5.2 问题原因</h4><p>当存在的节点异常多的时候，IO的代价已经超过数据传输，上文提到的facebook的节点已经超过3000个，在这种情况下再增加节点已经没法再提高效率了。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/45516608.jpg" alt="image"></p><h4>5.3 问题解决—优化IO</h4><ul><li>命令本身的效率：例如sql优化，命令优化</li><li>网络次数：减少通信次数</li><li>降低接入成本:长连/连接池,NIO等。</li><li>IO访问合并:O(n)到O(1)过程:批量接口(mget)，就是上一篇文章中介绍的对于mget的四个方案。</li></ul><h2>6. 缓存雪崩优化</h2><h4>6.1 什么是缓存雪崩？</h4><p>从下图可以很清晰出什么是缓存雪崩：由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 缓存雪崩的英文原意是 stampeding herd（奔逃的野牛），指的是缓存层宕掉后，流量会像奔逃的野牛一样，打向后端存储。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/92547625.jpg" alt="image"></p><h4>6.2 如何防止缓存雪崩？</h4><ul><li>保证缓存层服务高可用性。</li></ul><p>和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 <code>Redis Sentinel</code> 和 <code>Redis Cluster</code> 都实现了高可用。</p><ul><li>依赖隔离组件为后端限流并降级</li></ul><p>无论是缓存层还是存储层都会有出错的概率，可以将它们视同为资源。作为并发量较大的系统，假如有一个资源不可用，可能会造成线程全部 hang 在这个资源上，造成整个系统不可用。降级在高并发系统中是非常正常的：比如推荐服务中，如果个性化推荐服务不可用，可以降级补充热点数据，不至于造成前端页面是开天窗。</p><p><strong>在实际项目中，我们需要对重要的资源 ( 例如 <code>Redis</code>、 <code>MySQL</code>、 <code>Hbase</code>、外部接口 ) 都进行隔离</strong>，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响。但是线程池如何管理，比如如何关闭资源池，开启资源池，资源池阀值管理，这些做起来还是相当复杂的，这里推荐一个 Java 依赖隔离工具 <code>Hystrix</code>。超出范围了。不再赘述。</p><h2>7. 热点key重建优化</h2><h4>7.1 问题</h4><p>热点<code>key</code>( 例如一个热门的娱乐新闻）+较长的重建时间（可能是一个复杂计算，例如复杂的 SQL、多次 IO、多个依赖等）</p><p>就是说在高并发的情况下，某个key在缓存中重建时间太长，以至于高并发下缓存查不到，都去DB进行查询。对于DB压力很大，并且响应时间长。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/85568274.jpg" alt="image"></p><p>三个目标：<strong>要减少缓存重建次数、数据尽可能一致、减少潜在危险</strong>。</p><p>两个解决：互斥锁、永远不过期</p><h4>7.2 互斥锁—setex,setnx</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/40535698.jpg" alt="image"></p><p>存在问题：有等待时间。</p><p>伪代码：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/13945208.jpg" alt="image"></p><blockquote><p>(1) 从 <code>Redis</code> 获取数据，如果值不为空，则直接返回值，否则执行 (2.1) 和 (2.2)。</p><p>(2) 如果 <code>set(nx 和 ex)</code> 结果为 true，说明此时没有其他线程重建缓存，那么当前线程执行缓存构建逻辑。</p><p>(2.2) 如果 <code>setnx(nx 和 ex)</code> 结果为 false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程将休息指定时间 ( 例如这里是 50 毫秒，取决于构建缓存的速度 ) 后，重新执行函数，直到获取到数据。</p></blockquote><h4>7.3 永远不过期</h4><blockquote><p>这里我想了很久到底是什么意思，，，我感觉这是一个场景：保证数据的定期更新。对于热点<code>key</code>,无非是并发特别大并且重建缓存时间比较长，如果直接设置过期时间，那么时间到的时候，巨大的访问量会压迫到数据库上，所以我们实际上，是不给他设置过期时间，但是不设置过期时间，怎么做到定时更新呢？这里的方案是给热点key的val增加一个逻辑过期时间字段，并发访问的时候，判断这个逻辑字段的时间值是否大于当前时间，大于了说明要对缓存进行更新了，那么这个时候，依然让所有线程访问老的缓存，因为缓存并没有设置过期，但是另开一个线程对缓存进行重构。等重构成功，即执行了<code>redis set</code>操作之后，所有的线程就可以访问到重构后的缓存中的新的内容了。不知道我的理解是不是正确。</p></blockquote><p>“永远不过期”包含两层意思：</p><blockquote><p>从缓存层面来看，确实没有设置过期时间，所以不会出现热点 <code>key</code> 过期后产生的问题，也就是“物理”不过期。</p><p>从功能层面来看，为每个 <code>value</code> 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</p></blockquote><p>2018/6/19 号补充：物理上缓存确实是不过期的，保证所有线程都能访问到，但是有可能是老的数据；逻辑上给 value 增加过期时间，如果当过期时间超过当前时间(每一个线程拿缓存数据的时候都会判断一下，<strong>也就是说这里仍然使用互斥锁</strong>，其中一个线程发现过期时间超过当前时间了，那么锁住，另开一个线程去完成数据重建)，新开一个线程去构建缓存，构建成功之后，设置新内容到缓存中并且删除老缓存，就完成了热点 key 的重建。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/84104163.jpg" alt="image"></p><p>伪代码实现：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/97521024.jpg" alt="image"></p><h4>两种方案对比</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/92977181.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第九篇文章。介绍redis缓存中 一些重要的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Cluster理论详解</title>
    <link href="http://yoursite.com/2019/02/01/redis/Redis-Cluster%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/01/redis/Redis-Cluster理论详解/</id>
    <published>2019-02-01T13:18:07.079Z</published>
    <updated>2019-02-01T13:49:35.733Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第八篇文章。<a href="http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" target="_blank" rel="noopener">上一篇</a>我们学习了redis sentinel，知道了它是redis高可用的一种实现方案。但是面对要求很高的场景，一台master是一定不能解决问题的，redis 3.0给我们带来了服务端集群方案，解决了这个问题。</p><a id="more"></a><h2>1. 数据分区</h2><p>集群，那么就会涉及到数据是如何分片的。有两种方式：顺序分区和哈希分区</p><p><img src="http://bloghello.oursnail.cn/18-5-11/75952046.jpg" alt="image"></p><p>两者对比：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/86878706.jpg" alt="image"></p><p>直接<code>hash</code>取模进行数据分片时，当节点增加，会有很多数据命中不了，需要重新映射。如果大多数数据在增加或者减少节点之后进行迁移的话，对于性能影响是很大的，因为数据迁移，那么缓存中现在是无法命中的，必须去数据库取，是灾难性的行为。</p><p>早期的做法就是这样，在客户端<code>hash</code>取余节点个数来进行数据分片。如果非要这样，采取翻倍扩容会稍微好一点，迁移数据量会小一点。不过无论如何，这种方式在大数据量情况下是不可行的。</p><h2>2. 一致性hash算法</h2><p>对于上面提到的直接hash取余的方式，会导致大量数据的迁移。那么有没有一种方式，在增加或减少节点时，只有少部分数据迁移呢？</p><p>针对一致性<code>hash</code>算法，已经在<a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">简明理解一致性hash算法</a>中详细说明了，不再赘述。</p><p>对于redis 3.0之前，客户端可以用这种方式来实现数据分片。在redis 3.0之后，就不需要客户端来实现分片算法了，而是直接给我们提供了服务端集群方案<code>redis cluster</code>.</p><h2>3. 虚拟槽</h2><p><code>redis cluster</code>引入槽的概念，一定要与一致性<code>hash</code>的槽区分！这里每一个槽映射一个数据集。</p><blockquote><p>CRC16(key) &amp; 16383</p></blockquote><p>这里计算结果发送给<code>redis cluster</code>任意一个<code>redis</code>节点，这个<code>redis</code>节点发现他是属于自己管辖范围的，那就将它放进去；不属于他的槽范围的话，由于<code>redis</code>之间是相互通信的，这个节点是知道其他<code>redis</code>节点的槽的信息，那么会告诉他去那个<code>redis</code>节点去看看。</p><p>那么就实现了服务端对于槽、节点、数据的管理。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/92222837.jpg" alt="image"></p><p>当<code>master</code>节点增加时，即扩容时，对于以上两种方案，都会出现数据迁移，那么只能作为缓存场景使用。但是<code>redis cluster</code>，由于每个节点维护的槽的范围是固定的，当有新加入的节点时，是不会干扰到其他节点的槽的，必须是以前的节点将使用槽的权利分配给你，并且将数据分配给你，这样，新的节点才会真正拥有这些槽和数据。这种实现还处于半自动状态，需要人工介入。-----主要的思想是：槽到集群节点的映射关系要改变，不变的是键到槽的映射关系.</p><p><code>Redis</code>集群，要保证16384个槽对应的<code>node</code>都正常工作，<strong>如果某个<code>node</code>发生故障，那它负责的<code>slots</code>也就失效，整个集群将不能工作</strong>。为了增加集群的可访问性，官方推荐的方案是将<code>node</code>配置成主从结构，即一个<code>master</code>主节点，挂n个<code>slave</code>从节点。这时，如果主节点失效，<code>Redis Cluster</code>会根据选举算法从<code>slave</code>节点中选择一个上升为主节点，整个集群继续对外提供服务。</p><h2>4. 某个Master又怎么知道某个槽自己是不是拥有呢？</h2><p><code>Master</code>节点维护着一个16384/8字节的位序列，<code>Master</code>节点用bit来标识对于某个槽自己是否拥有。比如对于编号为1的槽，<code>Master</code>只要判断序列的第二位（索引从0开始）是不是为1即可。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/45417990.jpg" alt="image"></p><p>如上面的序列，表示当前<code>Master</code>拥有编号为1，134的槽。集群同时还维护着槽到集群节点的映射，是由长度为16384类型为节点的数组实现的，槽编号为数组的下标，数组内容为集群节点，这样就可以很快地通过槽编号找到负责这个槽的节点。位序列这个结构很精巧，即不浪费存储空间，操作起来又很便捷。</p><p>具体参照：<a href="http://blog.jobbole.com/103258/" target="_blank" rel="noopener">http://blog.jobbole.com/103258/</a> ,还提到了<code>slot</code>迁移的一些细节。</p><h2>5. redis节点之间如何通信的？</h2><p><img src="http://bloghello.oursnail.cn/18-5-11/14610782.jpg" alt="image"></p><ul><li><code>gossip</code>协议：节点之间彼此不断通信交换信息，一段时间后所有节点都会知道集群完整的信息。</li><li>节点与节点之间通过<strong>二进制协议</strong>进行通信。</li><li>客户端和集群节点之间通信和通常一样，通过文本协议进行。</li><li>集群节点不会代理查询。</li></ul><h2>6. 集群伸缩</h2><p>这里6385为新加入的节点，一开始是没有槽的，所以进行<code>slot</code>的迁移。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/10996863.jpg" alt="image"></p><p>集群伸缩：槽和数据在节点之间的移动。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/8930549.jpg" alt="image"></p><p>迁移数据的流程图：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/7140273.jpg" alt="image"></p><p><strong>迁移key可以用<code>pipeline</code>进行批量的迁移。</strong></p><p>对于扩容，原理已经很清晰了，至于具体操作，网上很多。至于缩容，也是先手动完成数据迁移，再关闭<code>redis</code>。</p><h2>7. 客户端路由</h2><h4>7.1 moved重定向</h4><p><img src="http://bloghello.oursnail.cn/18-5-11/69037262.jpg" alt="image"></p><p>其中，槽直接命中的话，就直接返回槽编号：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/48809003.jpg" alt="image"></p><p>槽不命中，返回带提示信息的异常，客户端需要重新发送一条命令：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/38968206.jpg" alt="image"></p><p>对于命令行的实验，用<code>redis-cli</code>去连接集群：</p><p><code>redis -c -p 7000</code>:加上<code>-c</code>，表示使用集群模式，帮助我们在第一次不命中的情况下自动跳转到对应的节点上：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/53223278.jpg" alt="image"></p><p>如果不加-c的话，会返回moved异常，不会自动跳转：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/7791978.jpg" alt="image"></p><h4>7.2 ask重定向</h4><p>在扩容缩容的时候，由于需要遍历这个节点上的所有的<code>key</code>然后进行迁移，是比较慢的，对客户端是一个挑战。因为假设一个场景，客户端访问某个key，节点告诉客户端这个<code>key</code>在源节点，当我们再去源节点访问的时候，却发现<code>key</code>已经迁移到目标节点。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/35563321.jpg" alt="image"></p><h4>7.3 moved重定向和ask重定向对比</h4><ul><li>两者都是客户端的重定向</li><li>moved：槽已经确定转移</li><li>ask:槽还在迁移中</li></ul><p>问题：如果节点众多，那么让客户端随机访问节点，那么直接命中的概率只有百分之一，还有就是发生<code>ask</code>异常时（即节点正在迁移时）客户端如何还能高效运转？</p><p>总结一句话就是<code>redis cluster</code>的客户端的实现会更复杂。</p><h2>8. smart客户端</h2><h4>8.1 追求目标</h4><p>追求性能，不会使用代理模式，而是直连对应节点。需要对<code>moved</code>异常和<code>ask</code>异常做兼容。也就是说，需要有一个这个语言对应的客户端来高效实现查找等操作。</p><h4>8.2 smart原理</h4><ul><li>从集群中选一个可运行节点，使用<code>cluster slots</code>初始化槽和节点映射</li><li>将<code>slot</code>与<code>node</code>节点的结果映射到本地，为每个节点创建<code>JedisPool</code></li><li>准备执行命令</li></ul><p>第一步中将<code>slot</code>与<code>node</code>节点的对应关系放在了<code>map</code>中，形成一个映射关系；<code>key</code>是通过<code>CRC16</code>算法再取余得到<code>slot</code>，所以<code>key</code>与<code>slot</code>的映射关系也是确定的。我们就可以直接发送命令。只要后面集群没有发生数据迁移，那么就会连接成功。但是如果在连接的时候出现了连接出错，说明这个<code>key</code>已经迁移到其他的<code>node</code>上了。如果发现<code>key</code>不停地迁移，超过5次就报错。</p><p>在发生<code>moved</code>异常的时候，则需要刷新缓存，即一开始维护的<code>map</code>。<br><img src="http://bloghello.oursnail.cn/18-5-12/49065180.jpg" alt="image"></p><p>有一个情况比较全的图：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/16371398.jpg" alt="image"></p><p><code>java redis cluster</code>客户端：<code>jedisCluster</code>基本使用–伪代码</p><p><img src="http://bloghello.oursnail.cn/18-5-12/31666045.jpg" alt="image"></p><p><code>jedisCluster</code>内部已经封装好池的借还操作等。</p><p>先写一个<code>JedisClusterFactory</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hostPortList;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里可以设置相关参数</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从配置文件中读取ip:port的参数放进Set中</span></span><br><span class="line">        Set&lt;HostAndPort&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String hostPort : hostPortList)&#123;</span><br><span class="line">            String[] arr = hostPort.split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr.length != <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(<span class="keyword">new</span> HostAndPort(arr[<span class="number">0</span>],Integer.parseInt(arr[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedisCluster = <span class="keyword">new</span> JedisCluster(nodeSet,timeout,jedisPoolConfig);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedisCluster != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jedisCluster.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisCluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring注入hostPortList和timeout</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHostPortList</span><span class="params">(List&lt;String&gt; hostPortList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hostPortList = hostPortList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hostPortList</code> 放入<code>spring bean</code>中，<code>spring</code>自动完成注入。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/83900230.jpg" alt="image"></p><h4>8.3 多节点命令实现</h4><p>有的时候我们想操作所有节点的数据。如何实现呢？</p><p><img src="http://bloghello.oursnail.cn/18-5-12/68192871.jpg" alt="image"></p><h4>8.4 批量操作</h4><p><strong><code>mget</code>,<code>mset</code>必须在一个槽</strong>。这个条件比较苛刻，一般是不能保证的，那么如何实现批量的操作呢？</p><blockquote><p><code>Redis Cluster</code>的行为和<code>Redis</code> 的单节点不同，甚至和一个<code>Sentinel</code> 监控的主从模式也不一样。主要原因是集群自动分片，将一个<code>key</code> 映射到16384个槽中的一个，这些槽分布在多个节点上。因此操作多个<code>key</code> 的命令必须保证所有的<code>key</code> 都映射到同一个槽上，避免跨槽执行错误。更进一步说，今后一个单独的集群节点，只服务于一组专用的<code>keys</code>，请求一个命令到一个<code>Server</code>，只能得到该<code>Server</code> 上拥有<code>keys</code> 的对应结果。一个非常简单的例子是执行<code>KEYS</code>命令，当发布该命令到集群环境中的某个节时，只能得到该节点上拥有的<code>keys</code>，而不是集群中所有的<code>keys</code>。所以要得到集群中所有的<code>keys</code>，必须从集群的所有主节点上获取所有的<code>keys</code>。</p></blockquote><p>对于分散在<code>redis</code>集群中不同节点的数据，我们如何比较高效地批量获取数据呢？？？？</p><ol><li>串行mget–原始方案，整一个for循环</li></ol><p><img src="http://bloghello.oursnail.cn/18-5-12/58584180.jpg" alt="image"></p><ol start="2"><li>串行IO</li></ol><p>对key进行RCR16和取余操作得到<code>slot</code>，将<code>slots</code>按照节点进行分批传送：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/35132332.jpg" alt="image"></p><ol start="3"><li>并行IO</li></ol><p><img src="http://bloghello.oursnail.cn/18-5-12/42467098.jpg" alt="image"></p><ol start="4"><li>hash_tag</li></ol><p>不做任何改变的话，<code>hash</code>之后就比较均匀地散在每个节点上：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/67459261.jpg" alt="image"></p><p>那么我们能不能像使用单机<code>redis</code>一样，一次IO将所有的<code>key</code>取出来呢？<code>hash-tag</code>提供了这样的功能，如果将上述的<code>key</code>改为如下，<strong>也就是用大括号括起来相同的内容，那么这些key就会到指定的一个节点上</strong>。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/77254754.jpg" alt="image"></p><p>在<code>mget</code>的时候只需要在一台机器上去即可。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/77494164.jpg" alt="image"></p><ol start="5"><li>对比</li></ol><p>方案三比较复杂，一般不用；方案四可能会出现数据倾斜，也不用。方案一在key小的时候可以用；方案二相对来说有一点优势；</p><p><img src="http://bloghello.oursnail.cn/18-5-12/2180496.jpg" alt="image"></p><p>为什么说是一点优势呢？<code>pipeline</code>批量处理不应该比串行处理好很多吗？</p><ul><li><a href="http://xiezefan.me/2015/12/13/redis_cluster_research_2/" target="_blank" rel="noopener">http://xiezefan.me/2015/12/13/redis_cluster_research_2/</a></li><li><a href="http://trumandu.github.io/2016/05/09/RedisCluster%E6%9E%84%E5%BB%BA%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%8E%A2%E8%AE%A8/" target="_blank" rel="noopener">http://trumandu.github.io/2016/05/09/RedisCluster构建批量操作探讨/</a></li></ul><h2>9. 故障转移</h2><h4>9.1 故障发现</h4><ul><li>通过<code>ping/pong</code>消息实现故障发现：不需要<code>sentinel</code></li><li>分为主观下线和客观下线</li></ul><p>主观下线：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/34676048.jpg" alt="image"></p><p>客观下线：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/16678200.jpg" alt="image"></p><p>pfail消息就是主观下线的信息，维护在一个链表中，链表中包含了所有其他节点对其他节点所有的主观信息，是有时间周期的，为了防止很早以前的主观下线信息还残留在这里。对这个链表进行分析，符合条件就尝试客观下线。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/42802351.jpg" alt="image"></p><h4>9.2 故障恢复</h4><p>从节点接收到他的主节点客观下线的通知，则进行故障恢复的操作。</p><ul><li>资格检查</li></ul><p>选取出符合条件的从节点：当从节点和故障主节点的断线时间太长，会被取消资格。</p><ul><li>准备选举时间</li></ul><p>就是为了保证偏移量大的从节点优先被选举投票</p><p><img src="http://bloghello.oursnail.cn/18-5-12/46928842.jpg" alt="image"></p><ul><li>选举投票</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/64039470.jpg" alt="image"></p><ul><li>替换主节点</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/70736400.jpg" alt="image"></p><p>这些所有步骤加起来，差不多十几秒左右。最后如果故障节点又恢复功能了，就称为新的<code>Master</code>的<code>slave</code>节点。</p><h2>10. 常见问题</h2><h4>10.1 集群完整性</h4><p><code>cluster-require-full-coverage</code>默认为yes</p><pre><code>- 要求所有节点都在服务，集群中16384个槽全部可用：保证集群完整性- 节点故障或者正在故障转移：`(error)CLUSTERDOWN the cluster is down`</code></pre><p><strong>但是大多数业务都无法容忍。需要将<code>cluster-require-full-coverage</code>设置为<code>no</code></strong></p><h4>10.2 带宽消耗</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/18544066.jpg" alt="image"></p><ul><li>消息发送频率：节点发现与其他节点最后通信时间超过<code>cluster-node-timeout/2</code>时会直接发送<code>Ping</code>消息</li><li>消息数据量：<code>slots</code>槽数组(2k空间)和整个集群1、10的状态数据(10个节点状态数据约10k)</li><li>节点部署的机器规模：进去分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽越高。</li><li>优化：避免“大”集群，：避免多业务使用一个集群，大业务可用多集群；<code>cluster-node-timeout</code>时间设置要注意是带宽和故障转移速度的均衡；尽量均匀分配到多机器上：保证高可用和带宽。</li></ul><h4>10.3 PubSub广播</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/49491067.jpg" alt="image"></p><ul><li>问题：<code>publish</code>在集群中每个节点广播：加重带宽。</li><li>解决：单独“走”一套<code>redis sentinel</code>。就是针对目标的几个节点构建<code>redis sentinel</code>，在这个里面实现广播。</li></ul><h4>10.4 数据倾斜</h4><ul><li>节点和槽分配不均匀<ul><li><code>./redis-trib.rb info ip:port</code>查看节点、槽、键值分布</li><li>慎用<code>rebalance</code>命令</li></ul></li><li>不同槽位对应键数量差异较大<ul><li>CRC16正常情况下比较均匀</li><li>可能存在<code>hash_tag</code></li><li><code>cluster countKeysinslot {slot}</code>获取槽对应键值个数</li></ul></li><li>包含<code>bigkey</code><ul><li>例如大字符串、几百万的元素的<code>hash</code>、<code>set</code>等</li><li>在从节点上执行:<code>redis-cli --bigkeys</code>来查看<code>bigkey</code>情况</li><li>优化：优化数据结构</li></ul></li><li>内存相关配置不一致<ul><li>因为某种情况下，某个节点对<code>hash</code>或者<code>Set</code>这种数据结构进行了单独的优化，而其他节点都没有配置，会出现配置不一致的情况。</li></ul></li></ul><h4>10.5 请求倾斜</h4><ul><li>热点key：重要的<code>key</code>或者<code>bigkey</code></li><li>优化：避免<code>bigkey;</code>热键不使用<code>hash_tag</code>；当一致性不高时，可以用本地缓存+MQ</li></ul><h4>10.6 读写分离</h4><ul><li>只读连接：集群模式的从节点不接受任何读写请求</li></ul><blockquote><p>重定向到负责槽的主节点(对从节点进行读，都是重定向到主节点再返回信息)</p><p>readonly命令可以读：连接级别命令(每次重新连接都要写一次)</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/57749242.jpg" alt="image"></p><p>上图可以看出，<strong><code>redis cluster</code> 默认<code>slave</code> 也是不能读的，如果要读取，需要执行 <code>readonly</code></strong>，就可以了。</p><ul><li>读写分离：更加复杂（成本很高，尽量不要使用）</li></ul><blockquote><p>同样的问题：复制延迟、读取过期数据、从节点故障</p><p>修改客户端</p></blockquote><h4>10.7 数据迁移</h4><p>分为离线迁移和在线迁移(唯品会<code>redis-migrate-tool</code>和豌豆荚<code>redis-port</code>)。</p><p>官方的方式：只能从单机迁移到集群、不支持在线迁移、不支持断点续传、单线程迁移影响速度</p><blockquote><p><code>./redis-trib.rb import --from 源ip:port --copy 目标ip:port</code></p></blockquote><p>加入在迁移时再往源<code>redis</code>插入几条数据，这几条数据会丢失(丢失一部分)</p><h4>10.8 集群vs单机</h4><p>集群也有一定的限制：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/73133214.jpg" alt="image"></p><p>分布式<code>redis</code>不一定是好的：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/6295367.jpg" alt="image"></p><h2>11. 简单总结</h2><p><img src="http://bloghello.oursnail.cn/18-5-12/415428.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-5-12/24688449.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第八篇文章。&lt;a href=&quot;http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇&lt;/a&gt;我们学习了redis sentinel，知道了它是redis高可用的一种实现方案。但是面对要求很高的场景，一台master是一定不能解决问题的，redis 3.0给我们带来了服务端集群方案，解决了这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>简明理解一致性hash算法</title>
    <link href="http://yoursite.com/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/01/miscellany/15简明理解一致性hash算法/</id>
    <published>2019-02-01T12:49:04.348Z</published>
    <updated>2019-02-01T12:50:12.033Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的。</p><a id="more"></a><h2>环形Hash空间</h2><p>按照常用的hash算法来将对应的key哈希到一个具有2^32 次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图</p><p><img src="http://bloghello.oursnail.cn/zaji15-1.png" alt="image"></p><p>把数据通过一定的hash算法处理后映射到环上<br>现在我们将<code>object1</code>、<code>object2</code>、<code>object3</code>、<code>object4</code>四个对象通过特定的<code>Hash</code>函数计算出对应的<code>key</code>值，然后散列到<code>Hash</code>环上。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hash(object1) = key1；</span><br><span class="line">Hash(object2) = key2；</span><br><span class="line">Hash(object3) = key3；</span><br><span class="line">Hash(object4) = key4；</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/zaji15-2.png" alt="image"></p><p>将机器通过hash算法映射到环上<br>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有<code>NODE1</code>，<code>NODE2</code>，<code>NODE3</code>三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hash(NODE1) = KEY1;</span><br><span class="line">Hash(NODE2) = KEY2;</span><br><span class="line">Hash(NODE3) = KEY3;</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/zaji15-3.png" alt="image"></p><p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动<code>object1</code>存储到了<code>NODE1</code>中，<code>object3</code>存储到了<code>NODE2</code>中，<code>object2</code>、<code>object4</code>存储到了<code>NODE3</code>中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p><h2>机器的删除与添加</h2><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p><h3>节点（机器）的删除</h3><p>以上面的分布为例，如果<code>NODE2</code>出现故障被删除了，那么按照顺时针迁移的方法，<code>object3</code>将会被迁移到<code>NODE3</code>中，这样仅仅是<code>object3</code>的映射位置发生了变化，其它的对象没有任何的改动。如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-4.png" alt="image"></p><h3>节点（机器）的添加</h3><p>如果往集群中添加一个新的节点<code>NODE4</code>，通过对应的哈希算法得到<code>KEY4</code>，并映射到环中，如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-5.png" alt="image"></p><p>通过按顺时针迁移的规则，那么<code>object2</code>被迁移到了<code>NODE4</code>中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p><h2>平衡性</h2><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。</p><p>hash算法是不保证平衡的，如上面只部署了<code>NODE1</code>和<code>NODE3</code>的情况（<code>NODE2</code>被删除的图），<code>object1</code>存储到了<code>NODE1</code>中，而<code>object2</code>、<code>object3</code>、<code>object4</code>都存储到了<code>NODE3</code>中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。</p><blockquote><p>“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</p></blockquote><p>以上面只部署了<code>NODE1</code>和<code>NODE3</code>的情况（<code>NODE2</code>被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p><p><img src="http://bloghello.oursnail.cn/zaji15-6.png" alt="image"></p><p>根据上图可知对象的映射关系：<code>object1</code>-&gt;<code>NODE1-1</code>，<code>object2</code>-&gt;<code>NODE1-2</code>，<code>object3</code>-&gt;<code>NODE3-2</code>，<code>object4</code>-&gt;<code>NODE3-1</code>。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，真正的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-7.png" alt="image"></p><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设<code>NODE1</code>的IP地址为<code>192.168.1.100</code>。引入“虚拟节点”前，计算 <code>cache A</code> 的 <code>hash</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100”);</span><br></pre></td></tr></table></figure><p>引入“虚拟节点”后，计算“虚拟节”点<code>NODE1-1</code>和<code>NODE1-2</code>的<code>hash</code>值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100#1”); // NODE1-1</span><br><span class="line">Hash(“192.168.1.100#2”); // NODE1-2</span><br></pre></td></tr></table></figure><p>整理自：</p><ul><li><a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">五分钟理解一致性哈希算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Sentinel实现高可用读写分离</title>
    <link href="http://yoursite.com/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://yoursite.com/2019/02/01/redis/Redis-Sentinel实现高可用读写分离/</id>
    <published>2019-02-01T12:21:44.756Z</published>
    <updated>2019-02-01T12:28:17.975Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第七篇文章。Redis Sentinel 是一个分布式系统，你可以在一个架构中运行多个 Sentinel 进程，这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息，并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。</p><a id="more"></a><p>虽然 <code>Redis Sentinel</code> 是一个单独的可执行文件 <code>redis-sentinel</code> ，但实际上它只是一个运行在特殊模式下的 <code>Redis</code> 服务器，你可以在启动一个普通 <code>Redis</code> 服务器时通过给定 <code>–sentinel</code> 选项来启动 <code>Redis Sentinel</code> 。</p><ul><li>启动方式一：使用<code>sentinel</code>可执行文件 <code>redis-sentinel</code> 程序来启动 <code>Sentinel</code> 系统，命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure><ul><li><code>sentinel</code>只是运行在特殊模式下的<code>redis</code>服务器，你可以用启动<code>redis</code>服务的命令来启动一个运行在 <code>Sentinel</code> 模式下的 <code>Redis</code> 服务器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure><h2>1. redis sentinel</h2><p>首先来看看什么是 <code>redis sentinel</code>，中文翻译是redis哨兵。顾名思义，哨兵是站岗监督突发情况的，那么这里具体的功能上很类似：</p><ul><li>监控：<code>Sentinel</code> 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒：当被监控的某个 <code>Redis</code> 服务器出现问题时，<code>Sentinel</code> 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移：当一个主服务器不能正常工作时，<code>Sentinel</code> 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li></ul><p><img src="http://bloghello.oursnail.cn/redis_sentinel%E7%BB%93%E6%9E%84.png" alt="image"></p><p>其中总结一下故障转移的基本原理：</p><ul><li>多个<code>sentinel</code>发现并确认<code>master</code>有问题</li><li>选举出一个<code>sentinel</code>作为领导</li><li>选出一个可以成为新的<code>master</code>的<code>slave</code></li><li>通知其他的<code>slave</code>称为新的<code>master</code>的<code>slave</code></li><li>通知客户端主从变化</li><li>等待老的<code>master</code>复活称为新的<code>master</code>的<code>slave</code></li></ul><p>也支持多个<code>master-slave</code>结构：</p><p><img src="http://bloghello.oursnail.cn/%E5%A4%9A%E4%B8%AAmaster_slave.png" alt="image"></p><h2>2. 安装与配置</h2><ol><li>配置开启主从节点</li><li>配置开启<code>sentinel</code>监控主节点（<code>sentinel</code>是特殊的<code>redis</code>）</li><li>实际应该多台机器，但是演示方便，只用一台机器来搭建</li><li>详细配置节点</li></ol><p>本地安装的结构图：</p><p><img src="http://bloghello.oursnail.cn/%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="image"></p><p>对于<code>master:redis-7000.conf</code>配置：</p><p><img src="http://bloghello.oursnail.cn/redis-7000.conf.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /usr/local/redis/data/redis-7000.pid</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br></pre></td></tr></table></figure><p>对于<code>slave:redis-7001</code>和<code>redis-7002</code>配置：</p><p><img src="http://bloghello.oursnail.cn/redis-slave.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /usr/local/redis/data/redis-7001.pid</span><br><span class="line">logfile &quot;7001.log&quot;</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br><span class="line">slaveof 127.0.0.1 7000</span><br></pre></td></tr></table></figure><p>启动<code>redis</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server ../config/redis-7000.conf</span><br></pre></td></tr></table></figure><p>访问7000端口的<code>master redis</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 info replication</span><br></pre></td></tr></table></figure><p>显示他有两个从节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=7002,state=online,offset=99550,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=7001,state=online,offset=99816,lag=0</span><br><span class="line">master_repl_offset:99816</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:99815</span><br></pre></td></tr></table></figure><p>对于<code>sentinel</code>主要配置：</p><p><img src="http://bloghello.oursnail.cn/sentinel%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE.png" alt="image"></p><p><code>master sentinel config</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>启动<code>redis sentinel</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel ../config/redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure><p>访问26379 <code>redis sentinel master</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 info sentinel</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:7000,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看这六个进程是否都起来了：ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>注意，如果上面是配置在虚拟机的话，需要将127.0.0.1改为虚拟机的ip，要不然找不着。</p><h2>3. 故障转移演练</h2><h4>3.1 java客户端程序</h4><p><code>JedisSentinelPool</code>只是一个配置中心，不需要具体连接某个<code>redis</code>，注意它不是代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(AppTest.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//哨兵配置，我们访问redis，就通过sentinel来访问</span></span><br><span class="line">    String masername = <span class="string">"mymaster"</span>;</span><br><span class="line">    Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26379"</span>);</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26380"</span>);</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26381"</span>);</span><br><span class="line"></span><br><span class="line">    JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masername,sentinels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个while死循环，每隔一秒往master塞入一个值，并且日志打印</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = sentinelPool.getResource();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">100000</span>);</span><br><span class="line">            String key = <span class="string">"k-"</span> + index;</span><br><span class="line">            String value = <span class="string">"v-"</span> + index;</span><br><span class="line">            jedis.set(key,value);</span><br><span class="line">            logger.info(<span class="string">"&#123;&#125;  value is &#123;&#125;"</span>,key,jedis.get(key));</span><br><span class="line"></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(jedis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>maven</code>依赖是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--slf4j日志接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--logback日志实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动程序，发现是正常写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">16:16:01.424 [main] INFO  com.njupt.swg.AppTest - k-54795  value is v-54795</span><br><span class="line">16:16:02.426 [main] INFO  com.njupt.swg.AppTest - k-55630  value is v-55630</span><br><span class="line">16:16:03.429 [main] INFO  com.njupt.swg.AppTest - k-70642  value is v-70642</span><br><span class="line">16:16:04.430 [main] INFO  com.njupt.swg.AppTest - k-42978  value is v-42978</span><br><span class="line">16:16:05.431 [main] INFO  com.njupt.swg.AppTest - k-96297  value is v-96297</span><br><span class="line">16:16:06.433 [main] INFO  com.njupt.swg.AppTest - k-4220  value is v-4220</span><br><span class="line">16:16:07.435 [main] INFO  com.njupt.swg.AppTest - k-34103  value is v-34103</span><br><span class="line">16:16:08.436 [main] INFO  com.njupt.swg.AppTest - k-9177  value is v-9177</span><br><span class="line">16:16:09.437 [main] INFO  com.njupt.swg.AppTest - k-24389  value is v-24389</span><br><span class="line">16:16:10.439 [main] INFO  com.njupt.swg.AppTest - k-32325  value is v-32325</span><br><span class="line">16:16:11.440 [main] INFO  com.njupt.swg.AppTest - k-68538  value is v-68538</span><br><span class="line">16:16:12.441 [main] INFO  com.njupt.swg.AppTest - k-36233  value is v-36233</span><br><span class="line">16:16:13.443 [main] INFO  com.njupt.swg.AppTest - k-305  value is v-305</span><br><span class="line">16:16:14.444 [main] INFO  com.njupt.swg.AppTest - k-59279  value is v-59279</span><br></pre></td></tr></table></figure><p>我们将现在的端口为7000的<code>redis master</code> 给<code>kill</code>掉</p><blockquote><p>kill -9 master的pid</p></blockquote><p>我们会发现：客户端报异常，但是在大概十几秒之后，就继续正常塞值了。原因是服务端的哨兵机制的选举<code>matser</code>需要一定的时间。</p><h2>4. 三个定时任务</h2><h4>4.1 每10秒每个sentinel对master和slave执行Info</h4><ul><li>发现<code>slave</code>节点</li><li>确认主从关系</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h4>4.2 每2秒每个sentinel通过master节点的channel交换信息(pub/sub)</h4><ul><li>通过<code>__sentinel__</code>:hello进行频道交互</li><li>交互对节点的“看法”和自身信息</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h4>4.3 每1秒每个<code>sentinel</code>对其他<code>sentinel</code>和<code>redis</code>执行<code>ping</code></h4><ul><li>心跳监测，失败判定依据</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h2>5. 主观下线和客观下线</h2><p>对于之前的<code>Sentinel</code>配置文件中有两条配置：</p><p>监控<code>master redis</code>节点，这里是当超过两个<code>sentinel</code>认为<code>master</code>挂了，则认为<code>master</code>挂了。</p><blockquote><p><code>sentinel monitor &lt;masterName&gt; &lt;masterIp&gt; &lt;msterPort&gt; &lt;quorum&gt;</code></p><p><code>sentinel monitor mymaster 127.0.0.1 6379 2</code></p></blockquote><p>这里是每秒<code>sentinel</code>都会去<code>Ping</code>周围的<code>master redis</code>，超过30秒没有任何响应，说明其挂了。</p><blockquote><p><code>sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;</code></p><p><code>sentinel down-after-milliseconds mymaster 300000</code></p></blockquote><h4>5.1 主观下线</h4><p>主观下线：每个<code>sentinel</code>节点对<code>Redis</code>节点失败的“偏见”</p><p>这是一种主观下线。因为在复杂的网络环境下，这个<code>sentinel</code>与这个<code>master</code>不通，但是<code>master</code>与其他的<code>sentinel</code>都是通的呢？所以是一种“偏见”</p><p>这是依靠的第三种定时：每秒去ping一下周围的<code>sentinel</code>和<code>redis</code>。对于<code>slave redis</code>,可以使用这个主观下线，因为他不需要进行故障转移。</p><h4>5.2 客观下线</h4><p>客观下线：所有<code>sentinel</code>节点对<code>master Redis</code>节点失败“达成共识”（超过<code>quorum</code>个则统一）</p><p>这是依靠的第二种定时：每两秒，<code>sentinel</code>之间进行“商量”，传递的消息是:<code>sentinel is-master-down-by-addr</code></p><p>对于<code>master redis</code>的下线，必须要达成共识才可以，因为涉及故障转移，仅仅依靠一个<code>sentinel</code>判断是不够的。</p><h2>6. 领导者选举</h2><p>原因：只有一个<code>sentinel</code>节点完成故障转移</p><p>选举：通过<code>sentinel is-master-down-by-addr</code>命令都希望成为领导者</p><ul><li>每个做主观下线的<code>sentinel</code>节点向其他<code>sentinel</code>节点发送命令，要求将它设置为领导者</li><li>收到命令的<code>sentinel</code>节点如果还没有同意过其他<code>semtinel</code>节点发送的命令，那么将同意该请求，否则拒绝</li><li>如果该<code>sentinel</code>节点发现自己的票数已经超过<code>sentinel</code>集合半数并且超过<code>quorum</code>，那么它将成为领导者。</li><li>如果此过程中多个<code>sentinel</code>节点成为了领导者，那么将等待一段时间重新进行选举</li></ul><h2>7. 故障转移</h2><ul><li>从<code>slave</code>节点中选出一个“合适的”节点作为新的<code>master</code>节点</li><li>对上述的<code>slave</code>节点执行“<code>slaveof no one</code>”命令使其成为<code>master</code>节点</li><li>向剩余的<code>slave</code>节点发送命令，让它们成为新<code>master</code>节点的<code>slave</code>节点，复制规则和<code>parallel-syncs</code>参数一样</li><li>更新对原来的<code>master</code>节点配置为<code>slave</code>，并保持着对其“关注”，当恢复后命令他去复制新的<code>master</code>节点</li></ul><p>那么，如何选择“合适”的<code>slave</code>节点呢？</p><ul><li>选择<code>slave-priority</code>(<code>slave</code>节点优先级)最高的<code>slave</code>节点，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的<code>slave</code>节点(复制得最完整)，如果存在则返回，不存在则继续</li><li>选择<code>run_id</code>最小的<code>slave</code>节点(最早的节点)</li></ul><h2>8. 节点下线</h2><p>主节点下线：<code>sentinel failover &lt;masterName&gt;</code></p><p>从节点下线要注意读写分离问题。</p><h2>9. 总结与思考</h2><blockquote><p><code>redis sentinel</code>是<code>redis</code>高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。</p></blockquote><blockquote><p><code>redis sentinel</code>从<code>redis2.8</code>版本才正式生产可用，之前版本不可生产用。</p></blockquote><blockquote><p>尽可能在不同物理机上部署<code>redis sentinel</code>所有节点。</p></blockquote><blockquote><p><code>redis sentinel</code>中的<code>sentinel</code>节点个数应该大于等于3且最好是奇数。</p></blockquote><blockquote><p><code>redis sentinel</code>中的数据节点和普通数据节点没有区别。每个<code>sentinel</code>节点在本质上还是一个<code>redis</code>实例，只不过和<code>redis</code>数据节点不同的是，其主要作用是监控<code>redis</code>数据节点</p></blockquote><blockquote><p>客户端初始化时连接的是<code>sentinel</code>节点集合，不再是具体的<code>redis</code>节点，但<code>sentinel</code>只是配置中心不是代理。</p></blockquote><blockquote><p><code>redis sentinel</code>通过三个定时任务实现了<code>sentinel</code>节点对于主节点、从节点、其余<code>sentinel</code>节点的监控。</p></blockquote><blockquote><p><code>redis sentinel</code>在对节点做失败判定时分为主观下线和客观下线。</p></blockquote><blockquote><p>看懂<code>redis sentinel</code>故障转移日志对于<code>redis sentine</code>l以及问题排查非常有用。</p></blockquote><blockquote><p><code>redis sentinel</code>实现读写分离高可用可以依赖<code>sentinel</code>节点的消息通知，获取<code>redis</code>数据节点的状态变化。</p></blockquote><p><code>redis sentinel</code>可以实现高可用的读写分离，高可用体现在故障转移，那么实现高可用的基础就是要有从节点，主从节点还实现了读写分离，减少<code>master</code>的压力。但是如果是从节点下线了，<code>sentinel</code>是不会对其进行故障转移的，并且连接从节点的客户端也无法获取到新的可用从节点，而这些问题在<code>Cluster</code>中都得到了有效的解决。</p><p>对于性能提高、容量扩展的时候，这种方式是比较复杂的，比较推荐的是使用集群，就是下面讨论的<code>redis cluster</code>!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第七篇文章。Redis Sentinel 是一个分布式系统，你可以在一个架构中运行多个 Sentinel 进程，这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息，并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>数值计算精度丢失问题</title>
    <link href="http://yoursite.com/2019/01/31/miscellany/14%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/31/miscellany/14数值计算精度丢失问题/</id>
    <published>2019-01-31T13:48:54.352Z</published>
    <updated>2019-01-31T13:49:43.953Z</updated>
    
    <content type="html"><![CDATA[<p>无论在什么业务中，钱是非常重要的东西，对账的时候一定要对的上，不能这边少一分那边多一分。对于数值的计算，尤其是小数，<code>double</code>和<code>double</code>都是禁止使用的。</p><a id="more"></a><blockquote><p>阿里强制要求存放小数时使用 decimal，禁止使用 float 和 double。</p><p>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 <code>decimal</code> 的范围，建议将数据拆成整数和小数分开存储。</p></blockquote><p>处理方式可以为：<code>mysql</code> 可以用 <code>decimal</code> ，如果你是用 <code>java</code>， 在商业计算中我们要用 <code>java.math.BigDecimal</code>，注意：如果需要精确计算，非要用<code>String</code>来够造<code>BigDecimal</code>不可！</p><p>那么到底是什么情况？</p><h2>一个例子说明</h2><p>废话不多说，上图：</p><p><img src="http://bloghello.oursnail.cn/zaji8-1.png" alt="image"></p><h2>问题原因</h2><p>无论是我们本文提到的<code>double</code>，还是<code>float</code>，都是浮点数。</p><p>在计算机科学中，浮点（英语：<code>floating point</code>，缩写为FP）<strong>是一种对于实数的近似值数值表现法</strong>，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（<code>floating-point number</code>）。</p><p>其实我觉得很好理解，我们之前说过，计算机计算加减乘除啊，都是用的加法器，实质都是二进制的加法处理。那么这里就有一个二进制表示的问题。试想，4，2，8之流都是2的幂次方，可以完美用二进制表示，计算当然不会出现问题。对于0，1，3，5之类也都可以用二进制来表示出来，所以，正数肯定是没问题的。</p><p>但是对于小数呢？1、0.5、0.25那都是可以转换成二进制的小数，如十进制的0.1，就无法用二进制准确的表示出来。因此只能使用近似值的方式表达。</p><p><img src="http://bloghello.oursnail.cn/zaji8-2.png" alt="image"></p><p>如果我们尝试着把10进制的0.1转化成二进制，会怎么转呢？</p><p>在十进制中，0.1如何计算出来的呢？</p><blockquote><p>0.1 = 1 ÷ 10</p></blockquote><p>那么二进制中也是同理：</p><blockquote><p>1 ÷ 1010</p></blockquote><p>我们回到小学的课堂，来列竖式吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       0.000110011...</span><br><span class="line">      ------------------</span><br><span class="line">1010 ) 1 0000</span><br><span class="line">         1010</span><br><span class="line">       ------</span><br><span class="line">          1100</span><br><span class="line">          1010</span><br><span class="line">          ----</span><br><span class="line">            10000</span><br><span class="line">             1010</span><br><span class="line">            -----</span><br><span class="line">              1100</span><br><span class="line">              1010</span><br><span class="line">              ----</span><br><span class="line">                10</span><br></pre></td></tr></table></figure><p>很显然，除不尽，除出了一个无限循环小数：二进制的 0.0001100110011…</p><p>那么，如何在计算机中表示这个无限不循环的小数呢？只能考虑按照不同的精度保理不同的位数。</p><p>我们知道float是单精度的，double是双精度的。不同的精度，其实就是保留的有效数字位数不同，保留的位数越多，精度越高。</p><p>所以，浮点数在Java中是无法精确表示的，因为大部分浮点数转换成二进制是一个无限不循环的小数，只能通过保留精度的方式进行近似表示。</p><h2>问题的解决</h2><p><code>String</code> 构造方法是完全可预知的：写入 <code>newBigDecimal(&quot;0.1&quot;)</code> 将创建一个 <code>BigDecimal</code>，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用<code>String</code>构造方法。</p><p>使用<code>BigDecimal(String val)</code>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.add(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">sub</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.subtract(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">mul</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.multiply(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//四舍五入,保留2位小数,应对除不尽的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，上面的精度丢失问题就迎刃而解了。但是除不尽怎么办？比如10.0除以这里的3.0，保留小数点后三位有效数字：</p><p><img src="http://bloghello.oursnail.cn/zaji8-3.png" alt="image"></p><p>那么，每个用户得到的都是3.333元，三个用户加起来是得不到10块钱的。</p><p>对于除法，始终会产生除不尽的情况怎么办？有个词叫轧差</p><p>什么意思呢？举个简单例子。假如现在需要把10元分成3分，如果是10除以3这么除，会发现为3.33333无穷尽的3。这些数字完全无法在程序或数据库中进行精确的存储。</p><p>简单理解就是，当除不尽或需去除小数点的时候，前面的n-1笔（这里n=3）做四舍五入。最后一笔做兜底（总金额减去前面n-1笔之和）。这样保证总金额的不会丢失。</p><p>比如10块钱，三个用户分，前面两个用户只能各分到3。333块钱，最后一个用户分到3.334块钱。保证总额不变。</p><p>至于原理，有一点点数学化，以后再作探讨吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论在什么业务中，钱是非常重要的东西，对账的时候一定要对的上，不能这边少一分那边多一分。对于数值的计算，尤其是小数，&lt;code&gt;double&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;都是禁止使用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://yoursite.com/2019/01/31/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/01/31/redis/Redis主从复制/</id>
    <published>2019-01-31T12:45:32.691Z</published>
    <updated>2019-02-01T12:28:10.690Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第六篇文章。介绍redis主从复制功能实现原理。作为高可用的基础，了解一下其中的门道是有必要的。</p><a id="more"></a><h2>1.单机有什么问题</h2><ul><li>机器故障</li><li>容量瓶颈</li><li>QPS瓶颈</li></ul><h2>2. 主从复制的作用</h2><ul><li>数据副本</li><li>扩展读性能，<code>slave</code>专门用来读</li><li>一个<code>master</code>可以有多个<code>slave</code>，一个<code>salve</code>只能有一个<code>master</code></li></ul><h2>3. 两种实现方式</h2><ul><li>方式一：<code>slaveof</code>命令<ul><li><code>slaveof masterIp masterPort</code></li><li><code>slaveof no one</code>(不会清除原来同步的数据，而是新的数据不会再同步给他)</li></ul></li><li>方式二：配置<ul><li>修改某一行的配置：<code>slaveof ip port</code></li><li>从节点只做读操作：<code>slave-read-only yes</code></li></ul></li><li>对比<ul><li>命令的优点：不需要重启</li><li>命令的缺点：不便于管理</li><li>配置的优点：统一配置</li><li>配置的缺点：需要重启</li></ul></li></ul><p>一个场景，假如6380是6379的一个从节点，然后将6380执行<code>salveof no one</code>，然后插入一些新的数据；再重新变成6379的从节点，那么里面的新数据会被清除掉。</p><ul><li>查看run_id<ul><li><code>redis-cli -p 6379 info server | grep run</code></li></ul></li></ul><h2>4. 全量复制</h2><ul><li>全量复制开销<ul><li>bgsave时间</li><li>rdb网络传输时间</li><li>从节点清空数据的时间</li><li>从节点加载RDB的时间</li><li>可能的AOF重写时间</li></ul></li><li>存在的问题<ul><li>时间开销比较大</li><li>如果<code>master</code>和<code>slave</code>之间网络扰动甚至断开，那么<code>master</code>此间更新的数据对于<code>slave</code>是不知道的，最简单的方法就是再进行一次全量复制，但是显然，消耗太大了。</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png" alt="image"></p><h2>5. 部分复制</h2><p><img src="http://bloghello.oursnail.cn/%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6.png" alt="image"></p><h2>6. 开发与运维的问题</h2><ul><li>读写分离</li></ul><p><code>master</code>只做写操作，<code>slave</code>来做读操作，来分摊流量。但是会有一些问题：</p><blockquote><p>复制数据延迟</p><p>读到过期数据</p><p>从节点故障</p></blockquote><ul><li>主从配置不一致</li></ul><blockquote><p>例如<code>maxmemory</code>不一致：丢失数据</p><p>数据结构优化参数：内存不一致</p></blockquote><ul><li>规避全量复制</li></ul><blockquote><p>第一次全量复制：不可避免—小主节点(<code>maxmemroy</code>不要太大)或者在低峰时进行操作</p><p>节点<code>run_id</code>不匹配（主节点重启，那么<code>master</code>的<code>run_id</code>会发生变化，<code>slave</code>发现其<code>run_id</code>变化，会进行全量复制）；我们可以用故障转移，例如哨兵或集群来避免全量复制。</p><p>复制积压缓冲区不足(网络中断，部分复制无法满足)，可以增大复制缓冲区配置<code>size</code>，网络增强</p></blockquote><ul><li>规避复制风暴</li></ul><blockquote><p>概念：主节点宕机造成大量的全量复制</p><p>单主节点复制风暴：主节点重启，多从节点复制；解决：更换复制拓扑</p><p>单机器复制风暴：机器宕机后（该机器全是<code>Mater</code>），大量全量复制。解决：<code>master</code>分散多机器。</p></blockquote><p>说到底，还是需要有一种高可用的实现方式，在<code>master</code>出现故障之后，如何自动实现从<code>slave</code>晋升为<code>master</code>继续使用.而不是一直死守着原来老的<code>master</code>不放，因为老的<code>master</code>啥时候恢复不知道，恢复了可能会造成复制风暴，既然从节点本来是一直与<code>master</code>节点保持尽量的同步的，那么为什么不将数据最新的从节点升级为主节点呢？下一章继续来分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第六篇文章。介绍redis主从复制功能实现原理。作为高可用的基础，了解一下其中的门道是有必要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://yoursite.com/2019/01/31/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/31/redis/Redis持久化/</id>
    <published>2019-01-31T12:34:15.804Z</published>
    <updated>2019-02-01T12:27:54.497Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第五篇文章。redis处理数据都是在内存中进行，所以速度特别快，同样，它也可以支持持久化，这里注意，并不是说redis要来充当mysql那种角色，其实更多的是为了在崩溃的时候快速恢复以及主从复制这样的功能。redis的持久化主要有两种方式，一种是RDB，一种是AOF，对于他们的原理和区别都是比较重要的面试考察点，需要掌握。</p><a id="more"></a><h2>1. 什么是持久化</h2><p><code>redis</code>所有数据保持在内存中，对数据的更新将异步地保存到磁盘中。</p><h2>2. 持久化的方式</h2><p>快照—<code>mysql dump</code>或者<code>redis rdb</code></p><p>写日志—<code>mysql binlog</code>或者<code>hbase glog</code>或者<code>redis aof</code></p><h2>3. RDB</h2><h4>什么是RDB</h4><p><img src="http://bloghello.oursnail.cn/%E4%BB%80%E4%B9%88%E6%98%AFRDB.png" alt="image"></p><h4>触发机制三种主要方式</h4><ul><li>save(<strong>同步持久化，会造成redis主线程的阻塞，不推荐使用</strong>)</li></ul><p><code>save</code>是同步的，当保存的数据量很大时，可能造成<code>redis</code>的阻塞，即客户端访问<code>redis</code>被阻塞。</p><p><img src="http://bloghello.oursnail.cn/save%E5%91%BD%E4%BB%A4.png" alt="image"></p><p>他的文件策略是：如果存在老的<code>RDB</code>文件，则新的替换老的。复杂度为<code>O(n)</code>。</p><ul><li>bgsave(<strong>异步，fork一个子进程来进行持久化，不会造成主线程的阻塞</strong>)</li></ul><p>一般情况下，<code>fork</code>是比较快的，但是也可以会慢，这时会阻塞<code>redis</code>。只要<code>fork</code>不慢，客户端不会被阻塞。</p><p><img src="http://bloghello.oursnail.cn/newbgsave.png" alt="image"></p><p>他的文件策略和复杂度与save是一样的。</p><p><code>save</code>和<code>bgsave</code>两者对比：</p><p><img src="http://bloghello.oursnail.cn/save%E5%92%8Cbgsave%E5%AF%B9%E6%AF%94.png" alt="image"></p><ul><li>自动</li></ul><p><code>redis</code>的自动保存的默认配置是：</p><table><thead><tr><th>配置</th><th>seconds</th><th>changes</th></tr></thead><tbody><tr><td>save</td><td>900</td><td>1</td></tr><tr><td>save</td><td>300</td><td>10</td></tr><tr><td>save</td><td>60</td><td>10000</td></tr></tbody></table><p>就是说，在60秒内改变了10000条数据，就自动保存；在300秒内有10条改变才自动保存；900秒内有1一条改变就保存。</p><h4>RDB总结</h4><ol><li><code>RDB</code>是<code>Redis</code>内存到硬盘的快照，用于持久化。</li><li><code>save</code>通常会阻塞<code>redis</code>。</li><li><code>bgsave</code>不会阻塞<code>redis</code>，但是会<code>fork</code>新进程。</li><li><code>save</code>自动配置满足任一就会被执行。</li><li>有些触发机制不容忽视。</li></ol><h2>4. AOF</h2><h4>RDB问题</h4><ul><li>全量数据存入磁盘</li></ul><p><code>O(n)</code>数据的备份，很耗时间；对于<code>bgsave</code>来说，<code>fork()</code>是一个很消耗内存的操作；将数据全写到硬盘，必然对硬盘IO占用很大。</p><ul><li>宕机丢失数据多</li></ul><p>还有一点是：<strong>某个时间点宕机，那么在某个时间段的数据就丢失了</strong>。</p><h4>AOF原理</h4><p>将对<code>redis</code>的操作追加到<code>aof</code>文件中。当<code>redis</code>宕机之后，使用<code>aof</code>恢复所有的操作继而实现数据的恢复。</p><h4>AOF三种策略</h4><ul><li>always</li></ul><p><img src="http://bloghello.oursnail.cn/aof-always.png" alt="image"></p><ul><li>everysec</li></ul><p><img src="http://bloghello.oursnail.cn/aof-everysec.png" alt="image"></p><p><code>redis</code>出现故障，有可能丢失一秒的数据。<code>redis</code>默认方式。</p><ul><li>no</li></ul><p><img src="http://bloghello.oursnail.cn/aof-no.png" alt=""></p><h4>三种策略的比较</h4><p><img src="http://bloghello.oursnail.cn/aof%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="image"></p><h4>AOF重写</h4><p><img src="http://bloghello.oursnail.cn/AOF%E9%87%8D%E5%86%99.png" alt="image"></p><p>好处是：减少硬盘占用、减少数据丢失</p><p>下面是AOF的<code>bgrewirteaof</code>的过程：</p><p><img src="http://bloghello.oursnail.cn/bgrewriteaof.png" alt="image"></p><p>注意：这里的重写并不是上面演示的，将原来的<code>aof</code>文件进行重写，而是根据<code>redis</code>现在的内存数据进行一次回溯。</p><h4>aof重写流程</h4><p><img src="http://bloghello.oursnail.cn/aof%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>也就是说，子进程在执行 AOF 重写时，主进程需要执行以下三个工作：</p><ul><li>1.处理命令请求；</li><li>2.将写命令追加到现有的 AOF 文件中；</li><li>3.将写命令追加到 AOF 重写缓存中。</li></ul><p>如此可以保证：</p><ul><li>现有的AOF功能继续执行，即使 AOF 重写期间发生停机，也不会有任何数据丢失；</li><li>所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。</li></ul><p>当子进程完成对 AOF 文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：(阻塞)</p><ul><li>将 AOF 重写缓存中的内容全部写入到新的 AOF 文件中；(现有 AOF 文件、新的 AOF 文件和数据库三者的状态就完全一致了)</li><li>对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。(执行完毕后，程序就完成了新旧两个 AOF 文件的替换)</li></ul><p>当这个信号处理函数执行完毕之后，主进程就可以继续像往常一样接收命令请求了。在整个 AOF 后台重写过程中，<strong>只有最后的“主进程写入命令到AOF缓存”和“对新的 AOF 文件进行改名，覆盖原有的 AOF 文件”这两个步骤会造成主进程阻塞，在其他时候， AOF 后台重写都不会对主进程造成阻塞，这将 AOF 重写对性能造成的影响降到最低。</strong></p><p>小结：</p><ul><li>AOF 重写的目的是轻量地保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求；</li><li>AOF在redis宕机的时候最多丢失一秒的数据，比RDB要好一点，并且可读性高，基本上能看得懂</li><li>AOF 重写其实是一个有歧义的名字，实际上重写工作是针对数据库的当前值来进行的，重写过程中不会读写、也不适用原来的 AOF 文件；</li><li>AOF 可以由用户手动触发，也可以由服务器自动触发。</li></ul><h2>5. 持久化的取舍和选择</h2><h4>RDB和AOF对比</h4><p><img src="http://bloghello.oursnail.cn/RDB%E5%92%8CAOF%E5%AF%B9%E6%AF%94.png" alt="image"></p><p>可以看出，世界上没有完美的东西，只有合适的东西。AOF同样存在一些问题：AOF文件的体积通常要大于RDB文件的体积、且恢复速度慢。</p><h4>RDB最佳策略</h4><p>“关”：建议关闭，但是后面主从复制功能是需要他的，因为需要主节点执行<code>dbsave</code>，然后将<code>rdb</code>文件传给从节点。所以说，关不是永久关。</p><p><strong>“集中管理”：虽然<code>RDB</code>很重，但是对于数据备份是很重要的，按照小时或者天集中地进行备份比较好，因为他的文件很小，利于传输。</strong></p><p>“主从，从开”：有时候从节点打开这个功能是比较好的，但是备份太频繁，取决于实际的场景。</p><h4>AOF最佳策略</h4><ul><li>“开”：建议打开，如果仅仅是作为一个普通缓存，对于数据要求不是很高，这次数据丢了，下次可以从数据库取(数据库压力不是很大)，这种情况就建议关闭，因为<code>AOF</code>还是有性能开销的。</li><li>“everysec”</li></ul><h4>Redis4</h4><p><code>Redis 4.0</code> 新增了 <code>RDB-AOF</code> 混合持久化格式， 这是一个可选的功能，</p><p>在开启了这个功能之后， <code>AOF</code> 重写产生的文件将同时包含 <code>RDB</code> 格式的内容和 <code>AOF</code> 格式的内容， 其中 <code>RDB</code> 格式的内容用于记录已有的数据， 而 <code>AOF</code> 格式的内存则用于记录最近发生了变化的数据， 这样 <code>Redis</code> 就可以同时兼有 <code>RDB</code> 持久化和 <code>AOF</code> 持久化的优点 —— 既能够快速地生成重写文件， 也能够在出现问题时， 快速地载入数据。</p><p>RDB和AOF共存的情况下如何恢复数据：</p><p><img src="http://bloghello.oursnail.cn/redis5-1.png" alt="image"></p><ul><li>优点：<ul><li>混合持久化结合了<code>RDB</code>持久化 和 <code>AOF</code> 持久化的优点,</li><li>由于绝大部分都是<code>RDB</code>格式，加载速度快，同时结合<code>AOF</code>，增量的数据以<code>AOF</code>方式保存了，数据更少的丢失。</li></ul></li><li>缺点：<ul><li>兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该<code>aof</code>文件，同时由于前部分是<code>RDB</code>格式，阅读性较差</li></ul></li></ul><p>策略是：</p><h2>6. 总结</h2><ul><li><a href="http://www.ywnds.com/?p=4876" target="_blank" rel="noopener">http://www.ywnds.com/?p=4876</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第五篇文章。redis处理数据都是在内存中进行，所以速度特别快，同样，它也可以支持持久化，这里注意，并不是说redis要来充当mysql那种角色，其实更多的是为了在崩溃的时候快速恢复以及主从复制这样的功能。redis的持久化主要有两种方式，一种是RDB，一种是AOF，对于他们的原理和区别都是比较重要的面试考察点，需要掌握。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>深入Nginx原理</title>
    <link href="http://yoursite.com/2019/01/30/miscellany/13%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Nginx%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/30/miscellany/13深入探究Nginx原理/</id>
    <published>2019-01-30T09:12:26.197Z</published>
    <updated>2019-01-30T09:15:09.299Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡中间件。是非常常用的web server.我们需要理解它的原理，才能达到游刃有余的程度。</p><a id="more"></a><p>本篇文章需要对Nginx有基本的使用以及对IO复用模型有一定的了解。文章比较长。</p><h2>1.正向代理和反向代理</h2><p><img src="http://xiaozhao.oursnail.cn/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="image"></p><p><strong>正向代理的工作原理就像一个跳板</strong>，比如：我访问不了<code>google.com</code>，但是我能访问一个代理服务器A，A能访问<code>google.com</code>，于是我先连上代理服务器A，告诉他我需要<code>google.com</code>的内容，A就去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="image"></p><p>反向代理（<code>Reverse Proxy</code>）方式是指以代理服务器来接受<code>internet</code>上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给<code>internet</code>上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><p>简单来说：</p><ul><li>正向代理是不知道客户端是谁，代理是一个跳板，所有客户端通过这个跳板来访问到对应的内容。</li><li>反向代理是不知道服务端是谁，用户的请求被转发到内部的某台服务器去处理。</li></ul><h2>2.基本的工作流程</h2><p><img src="http://xiaozhao.oursnail.cn/nginx%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="image"></p><ol><li>用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址；</li><li>反向代理服务器接受用户的请求；</li><li>反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</li><li>如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中。</li></ol><h2>3.优点</h2><ul><li>保护了真实的web服务器，保证了web服务器的资源安全</li><li>节约了有限的IP地址资源</li><li>减少WEB服务器压力，提高响应速度(缓存功能)</li><li>请求的统一控制，包括设置权限、过滤规则等</li><li>实现负载均衡</li><li>区分动态和静态可缓存内容</li><li>…</li></ul><h2>4.使用场景</h2><ul><li>Nginx作为Http代理、反向代理</li><li>Nginx作为负载均衡器</li><li>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</li><li>Nginx作为Web缓存</li></ul><h2>5.Nginx的Master-Worker模式</h2><p><img src="http://xiaozhao.oursnail.cn/Nginx%E7%9A%84Master-Worker%E6%A8%A1%E5%BC%8F.png" alt="image"></p><p>启动<code>Nginx</code>后，其实就是在80端口启动了<code>Socket</code>服务进行监听，如图所示，<code>Nginx</code>涉及<code>Master</code>进程和<code>Worker</code>进程。</p><p><img src="http://xiaozhao.oursnail.cn/Master-Worker%E6%A8%A1%E5%BC%8F.png" alt="image"></p><h2>6.Master进程的作用是？</h2><p>读取并验证配置文件<code>nginx.conf</code>；管理<code>worker</code>进程；</p><ul><li>接收来自外界的信号</li><li>向各worker进程发送信号</li><li>监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程</li></ul><h2>7.Worker进程的作用是？</h2><p>每一个<code>Worker</code>进程都维护一个线程（避免线程切换），处理连接和请求；注意<code>Worker</code>进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个<code>Worker</code>进程。</p><h5>思考：Nginx如何做到热部署？</h5><blockquote><p>所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载/nginx -t检查配置/nginx -s stop）</p><p>通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p>方案一：</p><p>修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点volatile的味道）</p><p>方案二：</p><p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p></blockquote><p>Nginx采用的就是方案二来达到热部署的！</p><h5>思考：Nginx如何做到高并发下的高效处理？</h5><blockquote><p>上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p><p>作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞…</p><p>要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</p><p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</p></blockquote><h5>思考：Nginx挂了怎么办？</h5><blockquote><p>Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p><p>答案是：Keepalived+Nginx实现高可用。</p><p>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</p><p>Keepalived+Nginx实现高可用的思路：</p><p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p><p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,从而实现Nginx故障切换）</p></blockquote><p><img src="http://xiaozhao.oursnail.cn/Keepalived+Nginx.png" alt="image"></p><h2>6.nginx.conf</h2><p><img src="http://xiaozhao.oursnail.cn/nginx.conf.png" alt="image"></p><ul><li>第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</li><li>第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。</li><li>第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</li><li>第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。</li></ul><p>除了可以映射静态资源，上面已经说了，可以作为一个代理服务器来使用。</p><blockquote><p>所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理，上面已经说了，过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。</p></blockquote><p>负载均衡【upstream】</p><blockquote><p>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><p>第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</p><p>第二，将proxy_pass替换成upstream指定的值即可。</p><p>负载均衡可能带来的问题？</p><p>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</p></blockquote><h2>7.惊群现象</h2><p>定义：惊群效应就是当一个fd的事件被触发时，所有等待这个fd的线程或进程都被唤醒。</p><p><code>Nginx</code>的IO通常使用<code>epoll</code>，<code>epoll</code>函数使用了I/O复用模型。与I/O阻塞模型比较，I/O复用模型的优势在于可以同时等待多个（而不只是一个）套接字描述符就绪。<code>Nginx</code>的<code>epoll</code>工作流程如下：</p><ul><li>master进程先建好需要listen的socket后，然后再fork出多个woker进程，这样每个work进程都可以去accept这个socket</li><li>当一个client连接到来时，所有accept的work进程都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败，Nginx提供了一把<strong>共享锁accept_mutex</strong>来保证同一时刻只有一个work进程在accept连接，从而解决惊群问题</li><li>当一个worker进程accept这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了</li></ul><h2>8.Nginx架构及工作流程</h2><p><img src="http://xiaozhao.oursnail.cn/Nginx%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p><p><code>Nginx</code>真正处理请求业务的是<code>Worker</code>之下的线程。<code>worker</code>进程中有一个<code>ngx_worker_process_cycle()</code>函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个<code>Nginx</code>服务被停止。</p><p>当一个 <code>worker</code> 进程在 <code>accept()</code> 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个完整的请求。一个请求，完全由 <code>worker</code> 进程来处理，而且只能在一个 <code>worker</code> 进程中处理。</p><p>这样做带来的好处：</p><ol><li>节省锁带来的开销。每个 <code>worker</code> 进程都是独立的进程，不共享资源，不需要加锁。同时在编程以及问题查上时，也会方便很多。</li><li>独立进程，减少风险。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，<code>master</code> 进程则很快重新启动新的 <code>worker</code> 进程。当然，<code>worker</code> 进程的也能发生意外退出。</li></ol><h2>9.nginx为什么高性能</h2><p><strong>因为nginx是多进程单线程的代表，多进程模型每个进程/线程只能处理一路IO，那么 Nginx是如何处理多路IO呢？</strong></p><p>如果不使用 IO 多路复用，那么在一个进程中，同时只能处理一个请求，比如执行 <code>accept()</code>，如果没有连接过来，那么程序会阻塞在这里，直到有一个连接过来，才能继续向下执行。</p><p>而多路复用，允许我们只在事件发生时才将控制返回给程序，而其他时候内核都挂起进程，随时待命。</p><p><strong>核心：Nginx采用的 IO多路复用模型epoll</strong></p><p><code>epoll</code>通过在<code>Linux</code>内核中申请一个简易的文件系统（文件系统一般用什么数据结构实现？B+树），其工作流程分为三部分：</p><ol><li>调用 <code>int epoll_create(int size)</code>建立一个<code>epoll</code>对象，内核会创建一个<code>eventpoll</code>结构体，用于存放通过<code>epoll_ctl()</code>向<code>epoll</code>对象中添加进来的事件，这些事件都会挂载在红黑树中。</li><li>调用 <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code> 在 <code>epoll</code> 对象中为 fd 注册事件，所有添加到<code>epoll</code>中的事件都会与设备驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个<code>sockfd</code>的回调方法，将<code>sockfd</code>添加到<code>eventpoll</code> 中的双链表</li><li>调用 <code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code> 来等待事件的发生，<code>timeout</code> 为 -1 时，该调用会阻塞直到有事件发生</li></ol><p>这样，注册好事件之后，只要有 fd 上事件发生，<code>epoll_wait()</code> 就能检测到并返回给用户，用户就能”非阻塞“地进行 I/O 了。</p><p><code>epoll()</code> 中内核则维护一个链表，<code>epoll_wait</code> 直接检查链表是不是空就知道是否有文件描述符准备好了。（<code>epoll</code> 与 <code>select</code> 相比最大的优点是不会随着 <code>sockfd</code> 数目增长而降低效率，使用 <code>select()</code> 时，内核采用轮训的方法来查看是否有fd 准备好，其中的保存 <code>sockfd</code> 的是类似数组的数据结构 <code>fd_set</code>，key 为 fd，value 为 0 或者 1。）</p><p>能达到这种效果，是因为在内核实现中 <code>epoll</code> 是根据每个 <code>sockfd</code> 上面的与设备驱动程序建立起来的回调函数实现的。那么，某个 <code>sockfd</code> 上的事件发生时，与它对应的回调函数就会被调用，来把这个 <code>sockfd</code> 加入链表，其他处于“空闲的”状态的则不会。在这点上，<code>epoll</code> 实现了一个”伪”AIO。但是如果绝大部分的 I/O 都是“活跃的”，每个 <code>socket</code> 使用率很高的话，<code>epoll</code>效率不一定比 <code>select</code> 高（可能是要维护队列复杂）。</p><p>可以看出，因为一个进程里只有一个线程，所以一个进程同时只能做一件事，但是可以通过不断地切换来“同时”处理多个请求。</p><p>例子：<code>Nginx</code> 会注册一个事件：“如果来自一个新客户端的连接请求到来了，再通知我”，此后只有连接请求到来，服务器才会执行 <code>accept()</code> 来接收请求。又比如向上游服务器（比如 PHP-FPM）转发请求，并等待请求返回时，这个处理的 <code>worker</code> 不会在这阻塞，它会在发送完请求后，注册一个事件：“如果缓冲区接收到数据了，告诉我一声，我再将它读进来”，于是进程就空闲下来等待事件发生。</p><p>这样，基于 多进程+epoll， Nginx 便能实现高并发。</p><h2>10.几种负载均衡的算法介绍</h2><blockquote><p>轮询（默认）</p></blockquote><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><blockquote><p>weight</p></blockquote><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><blockquote><p>ip_hash</p></blockquote><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问同一个后端服务器，可以解决session的问题。但是不能解决宕机问题。<br>前三种是nginx自带的，直接在配置文件中配置即可使用。</p><blockquote><p>fair（第三方）</p></blockquote><p>按后端服务器的相应时间来分配请求，相应时间短的优先分配。</p><blockquote><p>url_hash（第三方）</p></blockquote><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><h2>11.基于不同层次的负载均衡</h2><p><img src="http://bloghello.oursnail.cn/http1-6.png" alt="image"></p><p>七层就是基于URL等应用层信息的负载均衡；<br>同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。</p><p>换句话说:</p><ul><li>二层负载均衡会通过一个虚拟MAC地址接受请求，然后再分配到真是的MAC地址；</li><li>三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；</li><li>四层通过虚拟的URL或主机名接收请求，然后再分配到真是的服务器。</li></ul><p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。</p><p>比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。</p><p>七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p><p>负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。</p><p>负载均衡设备也常被称为&quot;四到七层交换机&quot;，那么四层和七层两者到底区别在哪里？</p><blockquote><p>第一，技术原理上的区别。</p></blockquote><p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><blockquote><p>第二，应用场景的需求。</p></blockquote><p>七层应用负载的好处，是使得整个网络更&quot;智能化&quot;。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。</p><p>另外一个常常被提到功能就是安全性。</p><h2>12.总结</h2><ol><li>理解正向代理和反向代理的概念</li><li>nginx的优点和使用场景</li><li>master和work两种进程的作用</li><li>如何热部署</li><li>Nginx单点故障的预防</li><li>映射静态文件、反向代理跳转到后端服务器处理的写法</li><li>惊群现象</li><li>Nginx 采用的是多进程（单线程） &amp; 多路IO复用模型(底层依靠epoll实现)</li><li>几种负载均衡的算法</li><li>四层的负载均衡和七层的负载均衡</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx是一个高性能的HTTP和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡中间件。是非常常用的web server.我们需要理解它的原理，才能达到游刃有余的程度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis为什么快</title>
    <link href="http://yoursite.com/2019/01/30/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/"/>
    <id>http://yoursite.com/2019/01/30/redis/Redis为什么快/</id>
    <published>2019-01-30T08:08:05.626Z</published>
    <updated>2019-01-30T09:00:35.737Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第四篇文章，本文主要攻克面试题-Redis为什么这么快。这就涉及Redis的线程模型啦。</p><a id="more"></a><h2>完全基于内存</h2><p><code>Redis</code>是纯内存数据库，相对于读写磁盘，读写内存的速度就不是几倍几十倍了，一般，<code>hash</code>查找可以达到每秒百万次的数量级。</p><h2>多路复用IO</h2><p>“多路”指的是多个网络连接，“复用”指的是复用同一个线程。<strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗）。</p><h2>Redis为什么是单线程的？</h2><p>因为CPU不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><h2>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h2><p>首先，<code>Redis</code> 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p><blockquote><p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ol><li><p>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p></li><li><p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</p></li><li><p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。</p></li></ol><p>第三种就是IO复用模型，<code>Linux</code>下的<code>select</code>、<code>poll</code>和<code>epoll</code>就是干这个的。<strong>将用户<code>socket</code>对应的<code>fd</code>注册进<code>epoll</code>，然后<code>epoll</code>帮你监听哪些<code>socket</code>上有消息到达</strong>，这样就避免了大量的无用操作。此时的<code>socket</code>应该采用非阻塞模式。这样，整个过程只在调用<code>select</code>、<code>poll</code>、<code>epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的<code>reactor</code>模式。</p></blockquote><p>所以，I/O多路复用的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。</p><p>这里还涉及一个名词：<strong>fd文件描述符。</strong></p><p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p><h2>redis的线程模型？</h2><p><code>Redis</code> 服务采用 <code>Reactor</code> 的方式来实现文件事件处理器。</p><p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p><p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 <code>Redis</code> 服务实现的简单。</p><p><img src="http://bloghello.oursnail.cn/redis%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86111.png-1000width" alt="image"></p><p>上面简单理解就是：多个网络连接并发读写redis的时候，先将对应的fd注册到<code>epoll</code>上，I/O多路复用模块会监听这些网络请求的情况，一旦有一个网络连接产生了<code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件，I/O多路复用模块就会向文件事件分派器传送那些产生了事件的网络连接。</p><p><img src="http://bloghello.oursnail.cn/redis4-1.png" alt="image"></p><p>当然了，上面的文件事件可能会并发产生，这时的策略是，将所有产生事件的套接字（对应上面的网络连接）都入队到一个队列里面， 然后通过这个队列， 以有序（<code>sequentially</code>）、同步（<code>synchronously</code>）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。再看看下图，与上图使一样的：</p><p><img src="http://bloghello.oursnail.cn/redis4-2.png" alt="image"></p><p>文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。</p><p>服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。</p><p><strong>整个模块使 <code>Redis</code> 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性，单线程还减少线程切换和调度，实现更加简单</strong></p><p><strong>最后总结一下</strong>，为什么<code>redis</code>比较快大概思路通俗的说就是：<code>Redis</code>是纯内存数据库，读取快，瓶颈在于IO上，如果使用阻塞式IO，因为是单线程的缘故，就会停止等待。所以采用IO多路复用监听文件描述符的状态，将对<code>redis</code>的开关读写换成事件，加入队列进行相应的事件处理，吞吐量比较大。</p><h2>IO复用模型的选择</h2><p>因为 Redis 需要在多个平台上运行，同时为了最大化执行的效率与性能，所以会根据编译平台的不同选择不同的 I/O 多路复用函数作为子模块，提供给上层统一的接口；</p><p>因为 <code>select</code> 函数是作为 <code>POSIX</code> 标准中的系统调用，在不同版本的操作系统上都会实现，所以将其作为保底方案：</p><p><img src="http://bloghello.oursnail.cn/redis4-3.png" alt="image"></p><p><code>Redis</code> 会优先选择时间复杂度为 <code>O(1)</code> 的 I/O 多路复用函数作为底层实现，包括 <code>Solaries 10</code> 中的 <code>evport</code>、<code>Linux</code> 中的 <code>epoll</code> 和 <code>macOS/FreeBSD</code> 中的 <code>kqueue</code>，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。</p><p>但是如果当前编译环境没有上述函数，就会选择 <code>select</code> 作为备选方案，由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 <code>O(n)</code>，并且只能同时服务 1024 个文件描述符，所以一般并不会以 <code>select</code> 作为第一方案使用。</p><h2>reids在linux下的安装</h2><p><code>Redis</code>对于<code>Linux</code>是官方支持的，安装起来也非常地简单，直接编译源码然后进行安装即可。</p><p>这里以<code>centos</code>为例，大概说一下步骤：</p><blockquote><p>下载redis编译工具:<code>yum install gcc</code>和<code>yum install g++</code></p></blockquote><blockquote><p>解压<code>redis.tar.gz</code>文件，进去之后进行编译:<code>make</code></p></blockquote><blockquote><p>然后安装：<code>make install PREFIX=/usr/local/redis</code></p></blockquote><blockquote><p>安装成功之后进入<code>/usr/local/redis/bin</code>下启动<code>redis</code></p><p><code>./redis-server</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第四篇文章，本文主要攻克面试题-Redis为什么这么快。这就涉及Redis的线程模型啦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis其他的功能介绍</title>
    <link href="http://yoursite.com/2019/01/29/redis/Redis%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/01/29/redis/Redis其他的功能介绍/</id>
    <published>2019-01-29T13:49:41.030Z</published>
    <updated>2019-01-30T03:20:33.553Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第三篇文章，本文主要介绍redis一些其他的功能。遇到某些场景的时候可以想到redis是不是可以实现。</p><a id="more"></a><h2>一、慢查询日志</h2><h4>1.1 什么是慢查询日志</h4><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来。</p><h4>1.2 redis一条命令简单的生命周期</h4><p><img src="http://xiaozhao.oursnail.cn/redis%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image"></p><p>慢查询只会出现在【<strong>3.执行命令</strong>】这个阶段，即慢查询只记录命令执行时间，并不包括命令排队时间和网络传输时间。</p><h4>1.3 慢查询配置参数</h4><blockquote><p>慢查询的预设阀值  <code>slowlog-log-slower-than</code></p></blockquote><ul><li><code>slowlog-log-slower-than</code>参数就是预设阀值，单位是微秒,默认值是10000，如果一条命令的执行时间超过10000微妙(10毫秒)，那么它将被记录在慢查询日志中。</li><li>如果<code>slowlog-log-slower-than</code>的值是0，则会记录所有命令。</li><li>如果<code>slowlog-log-slower-than</code>的值小于0，则任何命令都不会记录日志。</li><li><code>redis</code>的操作一般是微妙级，<code>slowlog-log-slower-than</code>不要设置太大，一般设置为1毫秒。支持动态设置。</li></ul><blockquote><p>慢查询日志的长度<code>slowlog-max-len</code></p></blockquote><ul><li><code>slowlog-max-len</code>只是说明了慢查询日志最多存储多少条。</li><li><code>Redis</code>使用一个列表来存储慢查询日志，<code>showlog-max-len</code>就是列表的最大长度。</li><li>当慢查询日志已经到达列表的最大长度时，又有慢查询日志要进入列表，则最早插入列表的日志将会被移出列表，新日志被插入列表的末尾。</li><li>默认是128，但是<code>slowlog-max-len</code>不要设置太小，可以设置为1000以上.</li></ul><p><strong>慢查询日志是一个先进先出队列，慢查询较多的情况下，可能会丢失部分慢查询命令，可以定期执行<code>slow get</code>命令将慢查询日志持久化到其他存储中。然后制作可视化界面查询。</strong></p><h2>二、pipeline</h2><h4>2.1 为什么会出现Pipeline</h4><p>用普通的<code>get</code>和<code>set</code>，如果同时需要执行大量的命令，那就是等待上一条命令应答后再执行，这中间不仅仅多了<code>RTT（Round Time Trip）</code>，而且还频繁的调用系统IO，发送网络请求。</p><p><img src="http://bloghello.oursnail.cn/%E6%89%B9%E9%87%8F%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>对于多条命令不是有<code>mget</code>和<code>mset</code>吗？确实对于一批的<code>get</code>和<code>set</code>可以用<code>mget</code>和<code>mset</code>，但是它的问题在于如果我们需要同时传输<code>get</code>和<code>hget</code>呢？此时<code>pipeline</code>(流水线)就出现了。</p><p><img src="http://bloghello.oursnail.cn/%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="image"></p><p>所以流水线解决的问题是N条命令网络通信的减少。</p><p><img src="http://bloghello.oursnail.cn/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="image"></p><p>为什么说网络耗费时间大呢？这里给出一个极端的例子。</p><p><img src="http://bloghello.oursnail.cn/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%97%B6%E9%97%B4.png" alt="image"></p><p><code>pipeline</code>与原生M操作的对比。</p><ul><li>原生M操作是一个原子操作。</li></ul><p><img src="http://bloghello.oursnail.cn/%E5%8E%9F%E7%94%9FM%E6%93%8D%E4%BD%9C.png" alt="image"></p><ul><li><code>pipeline</code>非原子命令。</li></ul><p><img src="http://bloghello.oursnail.cn/pipeline%E9%9D%9E%E5%8E%9F%E5%AD%90%E5%91%BD%E4%BB%A4.png" alt="image"></p><p>当某个命令的执行需要依赖前一个命令的返回结果时，无法使用<code>pipeline</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset a “a1” b “b” c “c1” </span><br><span class="line">mget a b c</span><br></pre></td></tr></table></figure><p><code>mget</code>和<code>mset</code>命令也是为了减少网络连接和传输时间所设置的，其本质和<code>pipeline</code>的应用区别不大，但是在特定场景下只能用<code>pipeline</code>实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get a</span><br><span class="line">set b ‘1’</span><br></pre></td></tr></table></figure><p><code>pipeline</code>适合执行这种连续，且无相关性的命令。</p><h4>2.2 一个demo</h4><p>搭建一个<code>quickstart</code>的<code>maven</code>工程。过程略。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接再单元测试中进行测试：普通的直接<code>hset</code> 10000条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        jedis.hset(<span class="string">"hashkey"</span>+i,<span class="string">"filed"</span>+i,<span class="string">"value"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"一共耗时: "</span>+(after-before)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>一共耗时: 1526ms</p></blockquote><p>但是用pipeline后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//分为10次批量发送</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1000</span>*i;j&lt;(i+<span class="number">1</span>)*<span class="number">1000</span>;j++)&#123;</span><br><span class="line">            pipeline.hset(<span class="string">"hashkey:"</span>+j,<span class="string">"field:"</span>+j,<span class="string">"value:"</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        pipeline.syncAndReturnAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用pipeline一共耗时: "</span>+(after-before)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：使用<code>pipeline</code>一共耗时: 139ms</p></blockquote><p>可以预见，对于更多的传输次数，<code>pipeline</code>的优势将越来越明显。但是<code>pipeline</code>每次只能作用在一个<code>redis</code>节点上。</p><h2>三、发布订阅</h2><h4>3.1 角色</h4><p>发布者----频道----订阅者</p><h4>3.2 模型</h4><p><img src="http://bloghello.oursnail.cn/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>注意，新订阅的，是不能收到之前的消息的。</p><ul><li>订阅者1：subscribe mytopic</li><li>订阅者2：subscribe mytopic</li><li>订阅者3：subscribe mytopic</li><li>发布者：publish mytopic “hello”</li></ul><p>缺点是不能保证消息可达，所以还是用专业的消息队列传达比较保障。</p><p>与发布订阅模型很类似的是<strong>消息队列</strong>模型。</p><p><img src="http://bloghello.oursnail.cn/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>只有一个是可以收到消息的。</p><h2>四、bitMap</h2><h5>4.1 位图是什么</h5><p>就是通过一个<code>bit</code>位来表示某个元素对应的值或者状态,其中的<code>key</code>就是对应元素本身。我们知道8个<code>bit</code>可以组成一个<code>Byte</code>，所以<code>bitmap</code>本身会极大的节省储存空间。</p><p><code>Bitmap</code>不是一个确切的数据类型，而是基于<code>String</code>类型定义的一系列面向位操作的方法。因为<code>String</code>是二进制安全的并且它们的最大长度是512MB，<br>所以<code>String</code>类型很合适去作为一个2^32长度的位数组。</p><p>比如我们执行 <code>set hello big</code></p><p>那么这个<code>big</code>其实是这个形态：</p><p><img src="http://bloghello.oursnail.cn/%E5%AD%97%E7%AC%A6%E4%B8%B2big%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="image"></p><p>执行<code>getbit hello 0</code>  得到0； 执行<code>getbit hello 1</code> 得到1</p><p><code>setbit hello 7 1</code>，那么再<code>get hello</code> 将得到<code>cig</code></p><h5>4.2 位图有什么用呢？</h5><p>位图除了<code>getbit</code>和<code>setbit</code>之外，还有<code>bitcount key [start end]</code>，就是获取执行范围内的1的个数。</p><p><code>bitop</code>作用是做多个<code>Bitmap</code>的<code>and</code>,<code>or</code>,<code>not</code>,<code>xor</code>操作。</p><blockquote><p>以一个场景为例：日活跃用户</p></blockquote><p>每次用户登录时会执行一次<code>redis.setbit(daily_active_users, user_id, 1)</code></p><p>因为日活跃用户每天都变化，所以需要每天创建一个新的<code>bitmap</code>。我们简单地把日期（年月日）添加到key后面，以后就可以根据年月日这个key找到某天活跃用户。实现了这个功能。</p><blockquote><p>第二个场景：用户签到情况</p></blockquote><p>将那天所代表的网站的上线日作为<code>offset</code>参数， 比如,如果今天是网站上线的第100天,而用户$uid=10001在今天阅览过网站, 那么执行命令<code>SETBIT peter 100 1</code>. 如果明天<code>$uid=10001</code>也继续阅览网站,那么执行命令<code>SETBIT peter 101 1</code> ,以此类推.</p><p>仔细想想，用位图，一天签到一次只要占一个bit，8天才占一个字节。那么一年这个用户签到占的数据是365/8=45.625个字节.如果不用位图实现，保存一条记录将远远大于一个比特吧，那么当用户量很大的时候，差距将会特别大。</p><h2>五、hyperLogLog</h2><p>基于<code>HyperLogLog</code>算法：极小空间完成独立数量统计。本质还是字符串。</p><ul><li><code>pfadd key element [element...]</code>:向<code>hyperloglog</code>添加元素</li><li><code>pfcount key [key...]</code>:计算<code>hyperloglog</code>的独立总数</li><li><code>pfmerge destkey sourcekey [sourcekey...]</code>:合并多个<code>hyperloglog</code></li></ul><h4>api例子</h4><p><img src="http://bloghello.oursnail.cn/hyperloglogdemo.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/hyperloglogdemo2.png" alt="image"></p><h4>为什么要用hyperLogLog呢</h4><p>我们上面例子可以看到，他的功能类似于去重，统计出所有不一样元素的个数。</p><p>他的优点是：占用内存极小。</p><p><img src="http://bloghello.oursnail.cn/hyperloglog%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97.png" alt="image"></p><p>缺点也有：</p><ul><li>他可能会出错，错误率为0.81%，看你是否能够容忍错误了</li><li>不能拿到单条数据</li></ul><h2>六、geo</h2><p>存储经纬度、计算两地距离、范围计算等。</p><p>提到<code>LBS(Location Based Service)</code>，基于位置的服务。我立即想起<code>Mongodb</code>的<code>GEO</code>实现地理坐标查询等功能，具体介绍为<a href="http://fourcolor.oursnail.cn/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">地理位置附近查询的GEOHASH解决方案</a>。</p><p><code>mongodb</code>最大的特点是灵活，因为其数据是以<code>json</code>的格式存储，所以字段随时可以增加或减少；<code>Redis</code>的特点是快，适合单一的，简单的，大量数据的存储；<code>HBase</code>我没有做深入研究，它的特点是大，适合做离线缓存。在处理社交这种关系复杂的数据存储时，依然还是需要用<code>mysql</code>这种关系型数据库，<code>nosql</code>并不能完全替代。</p><h2>七、总结</h2><ul><li>首先是慢查询日志，可以定时地持久化，并且用一个可视化页面进行监测。</li><li>pipeline解决的是对没有相互依赖的操作的批量执行，减少网络传输和IO时间。但是呢，需要注意一般只能往一个节点放数据，面对集群的时候，就需要采取一些策略了。mset、mget，目前只支持具有相同slot值的key执行批量操作。后文再讲。</li><li>可以实现发布订阅模型以及消息队列，但是消息是无状态的，不能保证消息一定送达，所以需要用专业的MQ来实现。</li><li>位图，可以实现极小的空间完成对大量用户信息的统计。</li><li>地理坐标服务</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第三篇文章，本文主要介绍redis一些其他的功能。遇到某些场景的时候可以想到redis是不是可以实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基本数据结构和操作</title>
    <link href="http://yoursite.com/2019/01/29/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/01/29/redis/Redis基本数据结构和操作/</id>
    <published>2019-01-29T12:13:04.744Z</published>
    <updated>2019-01-29T12:18:18.520Z</updated>
    
    <content type="html"><![CDATA[<p>本文为redis学习笔记的第二篇文章，本文主要介绍redis如何启动，以及基本的键命令和五种基本数据类型的操作。部分图片可能看不清楚，可以拖到新窗口打开。</p><a id="more"></a><h2>一、启动方式</h2><p>我的环境是<code>windows</code>，那么直接进入<code>redis</code>的解压目录中，分别执行<code>redis-server.exe</code>和<code>redis-cli.exe</code>两个可执行的程序。也可以通过<code>cmd</code>启动：</p><p><img src="http://bloghello.oursnail.cn/redis2-1.png" alt="image"></p><p>不要直接用<code>crtl+C</code>关闭<code>server</code>，在<code>linux</code>下，直接停掉<code>server</code>的话，会导致数据的丢失。正确的做法是在客户端执行 <code>redis-cli.exe shutdown</code></p><p><img src="http://bloghello.oursnail.cn/redis2-2.png" alt="image"></p><p>还可以指定端口启动：<code>./redis-server.exe --port 6380</code></p><p><img src="http://bloghello.oursnail.cn/redis2-3.png" alt="image"></p><p>那么对应客户端连接也要指定相应 的端口才能连接。关闭服务端也要指定相应的端口才行：</p><p><img src="http://bloghello.oursnail.cn/redis2-4.png" alt="image"></p><p><code>-h</code>指定远程<code>redis</code>的<code>ip</code></p><p><img src="http://bloghello.oursnail.cn/redis2-5.png" alt="image"></p><p>通过配置文件启动,可以在下面这个文件中指定端口号：</p><p><img src="http://bloghello.oursnail.cn/redis2-6.png" alt="image"></p><p>结合配置文件启动:</p><p><img src="http://bloghello.oursnail.cn/redis2-7.png" alt="image"></p><p>还可以设置密码：</p><p><img src="http://bloghello.oursnail.cn/redis2-8.png" alt="image"></p><p>那么客户端连接就必须要密码验证了：</p><p><img src="http://bloghello.oursnail.cn/redis2-9.png" alt="image"></p><h2>二、命令</h2><h6>1、基础命令</h6><p><code>info</code>:查看系统信息</p><p><code>select (0-15)</code>，redis一共有16个工作区间，一般默认从0开始，到15.</p><p><img src="http://bloghello.oursnail.cn/redis2-10.png" alt="image"></p><ul><li><code>flushdb</code>：清空当前选择的空间</li><li><code>flushall</code>：清空所有</li><li><code>dbsize</code>：当前空间里面key-value键值对的数目</li><li><code>save</code>：人工实现redis的持久化</li><li><code>quit</code>：退出</li></ul><h6>2、键命令</h6><p><code>del key</code>成功返回1，失败返回0.</p><p><img src="http://bloghello.oursnail.cn/redis2-11.png" alt="image"></p><p><code>exits key</code></p><p><img src="http://bloghello.oursnail.cn/redis2-12.png" alt="image"></p><p><code>ttl</code>和<code>expire</code></p><p><img src="http://bloghello.oursnail.cn/redis2-13.png" alt="image"></p><p><code>type key</code> 查看key的类型</p><p><code>randomkey</code>:</p><p><img src="http://bloghello.oursnail.cn/redis2-14.png" alt="image"></p><p><code>rename oldkey newkey</code></p><p><img src="http://bloghello.oursnail.cn/redis2-15.png" alt="image"></p><p>如果是重命名为已经存在的key呢？</p><p><img src="http://bloghello.oursnail.cn/redis2-16.png" alt="image"></p><p><code>renamenx</code>:</p><p><img src="http://bloghello.oursnail.cn/redis2-17.png" alt="image"></p><h2>三、redis数据结构</h2><h6>1、String字符串</h6><p><code>setex</code>&amp;<code>psetex</code></p><p><img src="http://bloghello.oursnail.cn/redis2-18.png" alt="image"></p><p><code>getrange</code>&amp;<code>getset</code></p><p><img src="http://bloghello.oursnail.cn/redis2-19.png" alt="image"></p><p><code>mset</code>&amp;<code>mget</code>&amp;<code>strlen</code></p><p><img src="http://bloghello.oursnail.cn/redis2-20.png" alt="image"></p><p><code>setnx</code>&amp;<code>msetnx</code></p><p><img src="http://bloghello.oursnail.cn/redis2-21.png" alt="image"></p><p>数值操作</p><p><img src="http://bloghello.oursnail.cn/redis2-22.png" alt="image"></p><h5>2、hash</h5><p><img src="http://bloghello.oursnail.cn/redis2-23.png" alt="image"></p><h5>3、list</h5><p><img src="http://bloghello.oursnail.cn/redis2-24.png" alt="image"></p><h5>4、set</h5><p><img src="http://bloghello.oursnail.cn/redis2-25.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/redis2-26.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/redis2-27.png" alt="image"></p><h6>5、sorted set</h6><p><img src="http://bloghello.oursnail.cn/redis2-28.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为redis学习笔记的第二篇文章，本文主要介绍redis如何启动，以及基本的键命令和五种基本数据类型的操作。部分图片可能看不清楚，可以拖到新窗口打开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
</feed>
