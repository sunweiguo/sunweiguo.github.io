<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fossi</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-12T10:57:59.812Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fossi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git基本原理</title>
    <link href="http://yoursite.com/2019/03/12/miscellany/16git%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/12/miscellany/16git基本原理/</id>
    <published>2019-03-12T09:18:22.158Z</published>
    <updated>2019-03-12T10:57:59.812Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们对git并不陌生，全球最大的同性交友网站github是程序猿们的最爱，这里只有你想不到的，没有你找不到的，各种资源应有尽有，免去了从浏览器中找到若干垃圾的麻烦。因此熟悉git也成为程序猿标配，本文来简单说说git的基本操作和基本原理。</p><a id="more"></a><h2>一、Git工作流程</h2><p><img src="http://bloghello.oursnail.cn/zaji17-1.png" alt="image"></p><p>这四个区域的名字如下:</p><ul><li>Workspace：工作区</li></ul><p>程序员进行开发改动的地方，是你当前看到的，也是最新的。平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。</p><ul><li>Index / Stage：暂存区</li></ul><p><code>.git</code>目录下的<code>index</code>文件, 暂存区会记录<code>git add</code>添加文件的相关信息(文件名、大小、<code>timestamp</code>…)，不保存文件实体, 通过id指向每个文件实体。</p><p>可以使用<code>git status</code>查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。<br>当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过<code>git add</code>先提交到暂存区，被git管理。</p><ul><li>Repository：仓库区（或本地仓库）</li></ul><p><code>git commit</code>后同步<code>index</code>的目录树到本地仓库，方便从下一步通过<code>git push</code>同步本地仓库与远程仓库的同步。</p><ul><li>Remote：远程仓库</li></ul><p>远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p><p>总结一下：</p><ul><li>任何对象都是在工作区中诞生和被修改；</li><li>任何修改都是从进入<code>index</code>区才开始被版本控制；</li><li>只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；</li><li>与协作者分享本地的修改，可以把它们<code>push</code>到远程仓库来共享。</li></ul><p>下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。</p><p><img src="http://bloghello.oursnail.cn/zaji17-2.png" alt="image"></p><h2>二、常用git命令</h2><p><img src="http://bloghello.oursnail.cn/zaji17-3.png" alt="image"></p><p>我们从关键字入手git常用命令。</p><h2>2.1 HEAD</h2><p><code>HEAD</code>，它始终指向当前所处分支的最新的提交(commit)点。你所处的分支变化了，或者产生了新的提交点，<code>HEAD</code>就会跟着改变。</p><p><img src="http://bloghello.oursnail.cn/zaji17-4.png" alt="image"></p><h2>2.2 add和commit</h2><p><img src="http://bloghello.oursnail.cn/zaji17-5.png" alt="image"></p><p><code>add</code>相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。</p><p><img src="http://bloghello.oursnail.cn/zaji17-6.png" alt="image"></p><p><code>commit</code>相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的<code>HEAD</code>向后移动一个提交点。</p><p><img src="http://bloghello.oursnail.cn/zaji17-7.png" alt="image"></p><h2>2.3 branch</h2><p><img src="http://bloghello.oursnail.cn/zaji17-8.png" alt="image"></p><p>涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。</p><p><img src="http://bloghello.oursnail.cn/zaji17-9.png" alt="image"></p><h2>2.4 merge</h2><p><img src="http://bloghello.oursnail.cn/zaji17-10.png" alt="image"></p><p><code>merge</code>命令把不同的分支合并起来。如上图，在实际开放中，我们可能从<code>master</code>分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的<code>commit</code>记录，最后开发完成需要合入<code>master</code>中，这便用到了<code>merge</code>。</p><p><img src="http://bloghello.oursnail.cn/zaji17-11.png" alt="image"></p><p>一般在<code>merge</code>之后，会出现<code>conflict</code>，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。</p><p>就是说同一个代码两个人都进行了修改，那么必然需要通过人工的沟通协调最终选择一个统一的版本。</p><h2>2.5 reset</h2><p><img src="http://bloghello.oursnail.cn/zaji17-12.png" alt="image"></p><p>reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。</p><p><img src="http://bloghello.oursnail.cn/zaji17-13.png" alt="image"></p><p>还有一个叫做<code>git revert</code>,与<code>git reset</code>的区别是：</p><p><img src="http://bloghello.oursnail.cn/zaji17-14.png" alt="image"></p><p><code>git reset</code> 是把<code>HEAD</code>向后移动了一下，而<code>git revert</code>是<code>HEAD</code>继续前进，只是新的<code>commit</code>的内容和要<code>revert</code>的内容正好相反，能够抵消要被<code>revert</code>的内容。</p><h5>2.6 push</h5><p>上传本地仓库分支到远程仓库分支，实现同步。</p><p><img src="http://bloghello.oursnail.cn/zaji17-15.png" alt="image"></p><h2>2.7 其他命令</h2><p><img src="http://bloghello.oursnail.cn/zaji17-16.png" alt="image"></p><p>整理自：<a href="https://mp.weixin.qq.com/s?__biz=MzUwOTQ1NTAzNA==&amp;mid=2247483714&amp;idx=2&amp;sn=a7893d7306025dc35ca0fb2678003795&amp;chksm=f910be97ce673781f259bb353b3802818eb64e2cb9b06390290374c3d95d139f32d8acb710e8&amp;mpshare=1&amp;scene=1&amp;srcid=1220thpAb37YI9AJFiDH0rMA#rd" target="_blank" rel="noopener">一篇文章让你读懂Git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们对git并不陌生，全球最大的同性交友网站github是程序猿们的最爱，这里只有你想不到的，没有你找不到的，各种资源应有尽有，免去了从浏览器中找到若干垃圾的麻烦。因此熟悉git也成为程序猿标配，本文来简单说说git的基本操作和基本原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="miscellany" scheme="http://yoursite.com/tags/miscellany/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(下)</title>
    <link href="http://yoursite.com/2019/03/12/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(%E4%B8%8B)/"/>
    <id>http://yoursite.com/2019/03/12/design-pattern/单例模式(下)/</id>
    <published>2019-03-12T05:54:29.390Z</published>
    <updated>2019-03-12T05:59:06.727Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中简单介绍了几种单例模式的实现，并且简单处理了一下如何抗反序列化，但是路漫漫，反射攻击等还在等着我们，本文深入探讨反射攻击以及枚举单例是如何实现完美单例的。</p><a id="more"></a><h2>一、反射攻击</h2><p>还是以饿汉模式实现的单例模式类来实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法忽略，跟本章无关</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Class objectClass = HungrySingleton.class;</span><br><span class="line">        Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//普通获取的对象</span></span><br><span class="line">        HungrySingleton instance = HungrySingleton.getGetInstance();</span><br><span class="line">        <span class="comment">//根据构造器反射构建的对象</span></span><br><span class="line">        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance == newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，就是通过反射拿到这个类的私有构造器，然后利用这个构造器去创建这个类的对象。运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@1540e19d</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@677327b6</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>那么可以进行反射的一些防御，因为是饿汉，在类加载之后就已经创建好实例对象了，所以我们可以在构造器种进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射调用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: 单例构造器禁止反射调用</span><br></pre></td></tr></table></figure><p>对于声明静态属性或者用静态内部类的这两种方式，因为类加载的时候，实例就会生成好，所以可以用这种方式进行防御。但是对于不是在类加载时期就加载类对象的模式，就不一定行了，跟具体的时序有关（主要看在反射创建对象的时候是不是已经存在了实例对象）。</p><p>即使添加复杂逻辑，比如用标记位来判断等手段都是不行的，因为反射的威力不仅可以修改构造器，还可以修改一个类的属性，所以是没有意义的。</p><h2>二、Enum枚举单例</h2><p>为了解决反射攻击以及序列化反序列化问题，推荐适用枚举单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumInstance &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其进行序列化和反序列化测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        EnumInstance instance = EnumInstance.getInstance();</span><br><span class="line">        instance.setData(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singletonFile"</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"singletonFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        <span class="comment">//获取反序列化后的对象</span></span><br><span class="line">        EnumInstance newInstance = (EnumInstance) ois.readObject();</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println(instance.getData());</span><br><span class="line">        System.out.println(newInstance.getData());</span><br><span class="line">        System.out.println(instance.getData() == newInstance.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@378bf509</span><br><span class="line">java.lang.Object@378bf509</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>原理是：还是要看<code>ObjectInputStream</code>对枚举是如何处理的，我们循着这个路径：</p><p>点开<code>(EnumInstance) ois.readObject();</code>中的<code>readObject()</code>方法，显示：</p><p><img src="http://bloghello.oursnail.cn/pattern14-1.png" alt="image"></p><p>点进去，找到枚举这一个类型：</p><p><img src="http://bloghello.oursnail.cn/pattern14-2.png" alt="image"></p><p>点进<code>readEnum</code>这个方法：</p><p><img src="http://bloghello.oursnail.cn/pattern14-3.png" alt="image"></p><p>我们看到是根据枚举的名字来生成枚举对象的，枚举的名字是唯一的，所以反序列化后还是原来的那个对象实例。解决了序列化和反序列化的问题。下面来看看是如何防止反射攻击的：</p><p>我们还是跟以前一样去获取枚举的构造器试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance.class;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>获取构造器的时候直接抛出异常了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = objectClass.getDeclaredConstructor();</span><br></pre></td></tr></table></figure><p>为什么获取不到枚举的无参构造器呢？</p><p>我们进入Enum源码，发现里面只有一个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就拿这个有参构造器去尝试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = EnumInstance.class;</span><br><span class="line">Constructor constructor = objectClass.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">EnumInstance instance = (EnumInstance) constructor.newInstance(<span class="string">"swg"</span>,<span class="number">666</span>);</span><br></pre></td></tr></table></figure><p>但是我们会发现，根据构造器去创建实例对象的时候报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br></pre></td></tr></table></figure><p>报错信息说，不能反射创建枚举对象。原因是：</p><p><img src="http://bloghello.oursnail.cn/pattern14-4.png" alt="image"></p><p>判断如果是枚举类型，就抛出这个异常。ok，这里就解决了反射攻击。</p><p>经过jad反编译之后，我们可以看到这个枚举类是一个final类型，表明不能被继承；构造器私有，不能被new，最重要的是，针对我们创建的实例：</p><p><img src="http://bloghello.oursnail.cn/pattern14-5.png" alt="image"></p><p>说明是在类加载的时候就去创建了，类似于饿汉模式。</p><h2>三、容器单例</h2><p>容器启动的时候，可以将一些单例实例放进map中来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInstance</span><span class="params">(String key,Object instance)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断key不为空，instance也不为空</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            map.put(key,instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在问题，多线程情况下，两个线程t1和t2，t1线程先塞入一个&lt;“key”,1&gt;，此时t2进来，立即塞入同样的&lt;“key”,2&gt;，那么此时t2返回2,t1也会返回1，造成了数据的混乱。</p><h2>四、ThreadLocal</h2><p>本地线程，是线程隔离的，保证一个线程的实例唯一。</p><p>这属于带引号的单例模式，不赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中简单介绍了几种单例模式的实现，并且简单处理了一下如何抗反序列化，但是路漫漫，反射攻击等还在等着我们，本文深入探讨反射攻击以及枚举单例是如何实现完美单例的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(上)</title>
    <link href="http://yoursite.com/2019/03/12/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(%E4%B8%8A)/"/>
    <id>http://yoursite.com/2019/03/12/design-pattern/单例模式(上)/</id>
    <published>2019-03-12T05:51:21.975Z</published>
    <updated>2019-03-12T05:59:04.324Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式看似十分简单，不就是唯一性嘛！但是当单例模式遇上多线程，遇上序列化，遇上反射的时候，一切就变得有点麻烦了，因为单例不仅要在生成的时候全局唯一，也要支持序列化反序列化后的唯一，还需要抵抗住反射的攻击。分为两截文章进行探讨，本文是上篇。</p><a id="more"></a><h2>一、定义</h2><ul><li>保证一个类只有一个实例，并提供一个全局访问点</li><li>创建型</li><li>对于单例的适用场景是不必多说了</li><li>单例模式的优点也是很明显的了：只有一个实例，减少内存开销</li><li>缺点也很明显：不易扩展</li><li>单例的关键词：私有构造器、线程安全、延迟加载、序列化和反序列化安全、防止反射攻击</li></ul><h2>二、懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在线程安全的问题，解决方法是：<code>synchronized</code>，但是这种排队执行，是比较慢的。下面进行优化。</p><h2>三、双重锁检查–禁止指令重排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazyDoubleCheckSingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazyDoubleCheckSingleton();<span class="comment">//2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意要用<code>volatile</code>关键字，来防止指令重排序。因为<code>instance = new LazyDoubleCheckSingleton();</code>这一步可以分为三个步骤：</p><ul><li>第一步：分配内存给对象</li><li>第二步：初始化对象</li><li>第三步：设置instance指向刚刚分配的内存地址</li></ul><p>这个时候，第二步和第三步执行顺序可能会被颠倒。</p><p>比如第一个线程t1，进来了，执行new，即先指向内存，但是对象还没有初始化完成，这个时候instance已经不为null，但是还没有初始化成功。</p><p>此时假设恰好t1时间片执行结束，t2进来了，首先判断是否为Null，因为不为null，所以直接返回这个还没有初始化好的instance，这个时候，针对这个线程t2系统就要报异常了。</p><p>此时，t2线程不影响t1线程继续执行，再去初始化一下对象，返回初始化好的instance.</p><p>加上<code>volatile</code>关键字之后，每个线程就都可以看到这个共享内存中的最新状态了，保证了内存可见性。并且禁止指令重排序，不会出现上述指令排序出现的问题。</p><p>用<code>volatile</code>关键字修饰的共享变量，在进行写操作的时候，将当前缓存行的数据写回到系统内存（共享内存）中，这个写回系统内存的操作会使其他线程缓存的这个变量值失效，所以他们需要去系统内存去同步数据。</p><p>这样，既兼顾了性能，又兼顾了线程安全。</p><h2>四、允许重排序–禁止其他线程看到重排序</h2><p>采用静态内部类的方式。原理如下。</p><p>假设有一个类叫A：</p><ul><li>A类实例被创建</li><li>A类中声明的静态方法被调用</li><li>A类中声明的一个静态成员被赋值</li><li>A类中声明的一个静态成员被使用，并且这个成员不是常量成员</li><li>如果A类为顶级类，并且A类中有嵌套的断言语句（不常用）</li></ul><p>根据java语言规范，其中任何一种情况首次发生，这个类就会立即被初始化。</p><p>那么，我们执行<code>InnerClass.instance</code>这句话的时候，就是调用了这个内部类的静态成员，所以此时这个静态内部类立即被初始化。</p><p><img src="http://bloghello.oursnail.cn/patten13-1.png" alt="image"></p><p>JVM在类的初始化阶段（class加载后，线程使用前），这个阶段会执行类的初始化，<strong>JVM会先获取一个锁</strong>，这个锁可以同步多个线程对一个类的初始化，基于这个特性，可以实现基于静态内部类的延迟加载、线程安全的方案。</p><p>那么，由于存在一把初始化锁，只能有一个线程执行初始化，即使静态内部类中存在重排序，也不会有任何问题，因为其他线程压根看不到，进不来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassLazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassLazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassLazySingleton instance = <span class="keyword">new</span> StaticInnerClassLazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取这个单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassLazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>五、饿汉式</h2><p>类加载的时候就完成了初始化，没有延迟加载(final static修饰的变量会在JVM准备阶段就完全确定了)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将初始化对象放到静态块中，达到一样的效果。</p><h2>六、序列化和反序列化破坏单例模式及解决</h2><p>用上一个饿汉来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//获取单例对象</span></span><br><span class="line">    HungrySingleton instance = HungrySingleton.getGetInstance();</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singletonFile"</span>));</span><br><span class="line">    oos.writeObject(instance);</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"singletonFile"</span>);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">    <span class="comment">//获取反序列化后的对象</span></span><br><span class="line">    HungrySingleton newInstance = (HungrySingleton) ois.readObject();</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    System.out.println(instance);</span><br><span class="line">    System.out.println(newInstance);</span><br><span class="line">    System.out.println(instance == newInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@568db2f2</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>反序列化后就破坏了单例。<font color="red">原因是在<code>ObjectInputStream</code>中，有段逻辑判断这个类是不是<code>implements Serializable</code>，是的话就用反射构建的对象，是新的实例。</font></p><p>此时如果将<code>HungrySingleton</code>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getGetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新增一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">com.swg.creational.singleton.HungrySingleton@135fbaa4</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>为什么呢？在上面反序列化的反射过程中生成了一个新的对象obj之后，下面还有一个判断：</p><p><img src="http://bloghello.oursnail.cn/pattern13-2.png" alt="image"></p><p>这里<code>hasReadResolveMethod</code>这个方法，具体如下：</p><p><img src="http://bloghello.oursnail.cn/pattern13-3.png" alt="image"></p><p>就是说，加入这个类实现了序列化接口，并且有<code>readResolve()</code>这个方法，就返回true.</p><p>就会执行下面的<code>desc.invokeReadResolve(obj)</code>这句，这句其实就是利用反射去调用<code>HungrySingleton</code>类中的<code>readResolve()</code>方法，拿到了原来里面的对象实例。所以就解决了这个问题。</p><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式看似十分简单，不就是唯一性嘛！但是当单例模式遇上多线程，遇上序列化，遇上反射的时候，一切就变得有点麻烦了，因为单例不仅要在生成的时候全局唯一，也要支持序列化反序列化后的唯一，还需要抵抗住反射的攻击。分为两截文章进行探讨，本文是上篇。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【面试题45-扑克牌顺子】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9845-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题45-扑克牌顺子】/</id>
    <published>2019-03-12T04:17:37.594Z</published>
    <updated>2019-03-12T04:17:58.116Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十五题。</p><a id="more"></a><h2>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张<sup>_</sup>)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2>解题思路</h2><p>要组成顺子，我们想一想最简单的情况，就是四个王再搭一个任意牌，这五张牌必然是顺子。</p><p>那么到底如何判断是不是顺子呢？</p><p>一个关键点是0的个数，就是王的个数。另一个关键点是非0元素之间的差值和。</p><p>如果这个差值的和大于王的个数，那么王是无法填补里面的间隙的，那么就形不成顺子了。</p><p>下面举个简单的例子。比如有五张牌，分别是1，3，4，5，0，那么0可以作为2，可以作为顺子，此时0 的个数是1，而间隙是(3-1-1)+(4-3-1)+(5-4-1)=1（注意，数组要先排序，所以此时数组是0,1,3,4,5）,而0不要参与计算。此时0的个数为1，差值也为1，所以0可以来填补这个间隙，所以可以作为顺子。</p><p>再来看一个例子：0,0,1,5,6，0的个数为2，间隙为(5-1-1)+(6-5-1)=3,此时3&gt;2，所以无法用0来填补，所以无法构成顺子。</p><p>最后就是注意，如果存在对子，那么肯定就不是顺子了。</p><p>分析完毕。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//零的个数，即王的个数</span></span><br><span class="line">        <span class="keyword">int</span> zeroNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排序后元素之间的差值</span></span><br><span class="line">        <span class="keyword">int</span> gapNum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//数组排序</span></span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//统计王的个数，统计到一个就重新循环，因为不需要参与后面的差值计算</span></span><br><span class="line">            <span class="comment">//也不需要对比是不是顺子</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是王，并且还是对子，那肯定不是顺子了</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不是王，计算一下两两的差值，最后与王的个数做比较</span></span><br><span class="line">            gapNum += numbers[i+<span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//差值小于王的个数，说明可以用王来构成顺子</span></span><br><span class="line">        <span class="keyword">if</span>(gapNum &lt;= zeroNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十五题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题44-翻转单词顺序列】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9844-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题44-翻转单词顺序列】/</id>
    <published>2019-03-12T04:17:02.063Z</published>
    <updated>2019-03-12T04:17:22.703Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十四题。</p><a id="more"></a><h2>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h2>解题思路</h2><p>比较简单的思路是从尾到头遍历数组，依次拼接起来。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.trim().length() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] strArr = str.split(<span class="string">" "</span>);</span><br><span class="line">        </span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=strArr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                res += strArr[i] + <span class="string">" "</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += strArr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十四题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题43-左旋转字符串】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9843-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题43-左旋转字符串】/</id>
    <published>2019-03-12T04:16:33.394Z</published>
    <updated>2019-03-12T04:16:52.779Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十三题。</p><a id="more"></a><h2>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h2>解题思路</h2><p>我们可以用一个比较巧妙的方法实现这种循环左移，比如将&quot;abc&quot;拼接成&quot;abcabc&quot;，此时如果要循环左移一位，应该变成&quot;bca&quot;，那么我通过截取&quot;abcabc&quot;来获得，怎么截取呢？很简单，就是截取n-n+length这个长度即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制字符串，比如"abc"复制为`abcabc`</span></span><br><span class="line">        String s = str + str;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="comment">//算出偏移量</span></span><br><span class="line">        n = n%len;</span><br><span class="line">        <span class="comment">//开始从n截取，截取到len+n</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(n,len+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十三题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题42-和为S的两个数字】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9842-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题42-和为S的两个数字】/</id>
    <published>2019-03-12T04:15:59.338Z</published>
    <updated>2019-03-12T04:16:21.820Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十二题。</p><a id="more"></a><h2>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>输出描述:</p><blockquote><p>对应每个测试案例，输出两个数，小的先输出。</p></blockquote><h2>解题思路</h2><p>满足递增，设两个头尾两个指针i和j，</p><p>若ai + aj == sum，就是答案（相差越远乘积越小）</p><p>若ai + aj &gt; sum，aj肯定不是答案之一（前面已得出 i 前面的数已是不可能），j -= 1</p><p>若ai + aj &lt; sum，ai肯定不是答案之一（前面已得出 j 后面的数已是不可能），i += 1</p><p>第一组符合条件的也是乘积最小的，数学可以证明，所以我们找到第一个即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = array.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[low] + array[high] == sum)&#123;</span><br><span class="line">                res.add(array[low]);</span><br><span class="line">                res.add(array[high]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[low] + array[high] &gt; sum)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十二题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题41-和为S的连续正数序列】</title>
    <link href="http://yoursite.com/2019/03/12/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9841-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/12/剑指offer/【面试题41-和为S的连续正数序列】/</id>
    <published>2019-03-12T04:15:25.526Z</published>
    <updated>2019-03-12T04:15:48.037Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十一题。</p><a id="more"></a><h2>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p>输出描述:</p><blockquote><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p></blockquote><h2>解题思路</h2><p>可以采取类似于窗口滑动的思想，慢慢找。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小</span></span><br><span class="line">        <span class="keyword">int</span> plow = <span class="number">1</span>,phigh = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(phigh &gt; plow)&#123;</span><br><span class="line">            <span class="comment">//由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2</span></span><br><span class="line">            <span class="keyword">int</span> cur = (phigh + plow) * (phigh - plow + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//相等，那么就将窗口范围的所有数添加进结果集</span></span><br><span class="line">            <span class="keyword">if</span>(cur == sum)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=plow;i&lt;=phigh;i++)&#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                plow++;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和小于sum，那么右边窗口右移一下</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur &lt; sum)&#123;</span><br><span class="line">                phigh++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果当前窗口内的值之和大于sum，那么左边窗口右移一下</span></span><br><span class="line">                plow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十一题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CSS之定位</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之定位/</id>
    <published>2019-03-11T14:04:48.644Z</published>
    <updated>2019-03-11T14:08:18.177Z</updated>
    
    <content type="html"><![CDATA[<p>本文来研究一下第三个重点：定位。</p><a id="more"></a><h2>绝对定位和相对定位</h2><p>绝对定位的主要特性是不占空间。</p><p><img src="http://bloghello.oursnail.cn/html8-1.png" alt="image"></p><p>但是相对定位是占空间的。</p><p><img src="http://bloghello.oursnail.cn/html8-2.png" alt="image"></p><p>我们看到，占用的是原来的空间。说明相对定位的话，原有的空间会给它保留住，实际占用的空间仍然是原来的，而不是现在移动后的。</p><h2>嵌套子元素</h2><p><img src="http://bloghello.oursnail.cn/html8-3.png" alt="image"></p><p>我们可以发现，如果子元素用的是绝对定位，那么定位是跟父元素没有关系的，而是与浏览器边框有关。此时如何做到跟着父元素一起动呢?最简单的方法是将子元素改为相对定位。</p><p>改为相对定位确实可以解决这个问题，但是有的时候我们需要子元素不占用空间，那么怎么办呢？一般情况下，我们给父元素一个定位信息，一般是相对定位，然后子元素是绝对定位，这样子元素就不会占用空间，并且子元素的位置是相对父元素动的。</p><p>为什么父元素要是相对定位呢？因为父元素一般都是需要占用空间的。一举两得，所以口则是子绝父相。</p><p><img src="http://bloghello.oursnail.cn/html8-4.png" alt="image"></p><p>此时就做到子元素相对于父元素定位了。</p><p>固定定位就是<code>fixed</code>，那么网页内容再多一直往下滑，它依然不动。</p><p>简单总结一下，就是相对定位是占空间的，绝对定位是不占空间的。默认情况下，绝对定位是相对于浏览器边框的，但是如果是父子关系，并且父元素设置<code>relative</code>子元素设置<code>absolute</code>的话，子元素就是相对于父元素进行排版。固定定位就是钉死不动。默认情况下是<code>static</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来研究一下第三个重点：定位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS之浮动</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之浮动/</id>
    <published>2019-03-11T13:11:04.888Z</published>
    <updated>2019-03-11T13:11:40.613Z</updated>
    
    <content type="html"><![CDATA[<p>本文来研究一下第二个重点：浮动。</p><a id="more"></a><h2>浮动</h2><p><img src="http://bloghello.oursnail.cn/html7-1.png" alt="image"></p><p>那么我们如何让他变成一行呢？之前已经说过了，可以用<code>inline-block</code>来实现：</p><p><img src="http://bloghello.oursnail.cn/html7-2.png" alt="image"></p><p>但是我们发现，有该死的间隙存在。此时就需要用到我的浮动了。什么是浮动，顾名思义，就是浮在上面，下面来直观感受一下：</p><p><img src="http://bloghello.oursnail.cn/html7-3.png" alt="image"></p><p>我们会发现，一个加了浮动，一个没有加的话，那么这两个在排版的时候是互相不冲突的，也就是说，浮动的元素根本就不占用标准元素的空间，所以这两者重叠在了一起。浮动就像是飞机，而不是浮动的就是汽车，汽车与汽车之间是互斥的，但是汽车与飞机之间不互斥，下面我们再来解决上面存在间隙的问题，我们只需要将这两个元素全部置为向左浮动即可。</p><p><img src="http://bloghello.oursnail.cn/html7-4.png" alt="image"></p><p>那么既然已经是浮动的元素了，这个元素是属于谁的呢？也就是说，是属于整个body还是属于父元素的呢？如果是属于父元素的话，那么就非常好了，我可以调整好父元素的位置之后，里面的子元素采用浮动来置为一行。我们来测试一下。</p><p><img src="http://bloghello.oursnail.cn/html7-5.png" alt="image"></p><p>这说明确实是属于父元素的。</p><h2>一些问题</h2><p><img src="http://bloghello.oursnail.cn/html7-6.png" alt="image"></p><p>此时下面的<code>div</code>直接就将第一个<code>outer</code>给顶掉了，这不是我们想要的结果。结果方案有三种。</p><p><img src="http://bloghello.oursnail.cn/html7-7.png" alt="image"></p><p>可能有的时候需要用第三种，因为第一种方法有的时候父元素会隐藏掉多出来的子元素。有的时候我们不想隐藏，就需要用到这个方法。</p><p><img src="http://bloghello.oursnail.cn/html7-8.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来研究一下第二个重点：浮动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS之盒子模型</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之盒子模型/</id>
    <published>2019-03-11T12:15:10.754Z</published>
    <updated>2019-03-11T12:16:13.769Z</updated>
    
    <content type="html"><![CDATA[<p>盒子模型是比较基础但是比较重要的一点，本文来简单了解一下。</p><a id="more"></a><h2>盒子模型</h2><p><img src="http://bloghello.oursnail.cn/html6-1.png" alt="image"></p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。<br>下面的图片说明了盒子模型(Box Model)：</p><p><img src="http://bloghello.oursnail.cn/html6-2.png" alt="image"></p><p>由上面我知道了：最终元素的总宽度计算公式是这样的：</p><ul><li>总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距</li></ul><p>元素的总高度最终计算公式是这样的：</p><ul><li>总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距</li></ul><p>简单了解了盒子模型之后，我们看到这个margin是在盒子的最外面，那么两个这样的盒子相邻的话可能会出一些问题。</p><p>比如两个盒子一上一下放，两个都设置margin，那么这两者之间上下间隔会是多少呢？是两者的margin之和吗？</p><p>⭐经过验证，间隔是以大的那个为准，而不是两者之和。</p><p>那对于内部嵌套的情况呢？</p><p><img src="http://bloghello.oursnail.cn/html6-5.png" alt="image"></p><p>看起来好像没什么问题，都是符合我们一开始的期望的。但是去掉父盒子中的<code>padding</code>或者同时删除掉<code>padding</code>和<code>border</code>会是什么样子呢？</p><p><img src="http://bloghello.oursnail.cn/html6-6.png" alt="image"></p><p>好像子中<code>margin</code>的设置没什么作用了，此时我增大一下<code>margin</code>：</p><p><img src="http://bloghello.oursnail.cn/html6-4.png" alt="image"></p><p>（删除掉<code>border</code>效果也一样），效果就是两者同时下移了。这就很奇怪了，用比较专业的词汇来说，就是这两者的<code>margin</code>咋合并了呢？这里确实是合并了，<code>div</code>距离最上面的距离由其中较大的<code>margin</code>的值决定。</p><p>解决方法是什么呢？正如上面第一种显示的，要么加一个<code>border</code>要么加一个<code>padding</code>.</p><p><img src="http://bloghello.oursnail.cn/html6-7.png" alt="image"></p><p>还有一种方式是在父元素上增加<code>overflow</code>，顾名思义就是溢出的意思。</p><p><img src="http://bloghello.oursnail.cn/html6-8.png" alt="image"></p><p>这也可以解决边框合并问题。我们稍微来看一下这个溢出是啥意思。起始就是说，如果子元素不在这个父元素范围内了，就直接不显示了。我们也可以显示，调整为<code>auto</code>模式即可，就可以下拉看到子元素了。</p><p><img src="http://bloghello.oursnail.cn/html6-9.png" alt="image"></p><p>我们来稍微总结一下，盒子模型的计算方法跟<code>margin</code>决定的外边距，<code>border</code>决定的边框宽度，<code>padding</code>决定的内边距以及实际内容相关。</p><p>然后就是存在外边距合并的问题，一个是上下关系，一个是嵌套关系。重点是嵌套关系，要解除外边距合并问题，第一个比较可行的方案是给父元素添加一个白色的边框，一个是给父元素增加<code>overflow</code>。那个<code>padding</code>是不大好用的，毕竟增加了<code>padding</code>之后整个父元素的宽度或者高度都变化了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;盒子模型是比较基础但是比较重要的一点，本文来简单了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS之图片</title>
    <link href="http://yoursite.com/2019/03/11/front/CSS%E4%B9%8B%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2019/03/11/front/CSS之图片/</id>
    <published>2019-03-11T08:00:21.455Z</published>
    <updated>2019-03-11T08:02:15.252Z</updated>
    
    <content type="html"><![CDATA[<p>本文来说一说图片相关的一些处理以及精灵图。</p><a id="more"></a><h2>图片</h2><p><img src="http://bloghello.oursnail.cn/html5-1.png" alt="image"></p><p>这就是简单放一张图片，但是我们发现，当图片比我们设定的div要小的时候，它会自动复制取铺满整个div。如果我们仅仅显示原来的图片，不要它铺开呢？</p><p><img src="http://bloghello.oursnail.cn/html5-2.png" alt="image"></p><p>这样就不会重复显示了，那我们能不能移动移动这个图片呢？</p><p><img src="http://bloghello.oursnail.cn/html5-3.png" alt="image"></p><p>注意，正数是让它往左往右移动。这个有什么用呢？这就要说一说精灵图了。</p><p>还可以用<code>background-repeat: repeat-x;</code>表示横向自动填充。</p><h2>精灵图</h2><p>什么是精灵图呢？</p><p>我们去腾讯游戏的官网看一下：</p><p><img src="http://bloghello.oursnail.cn/html5-4.png" alt="image"></p><p>我们注意到有很多的小图标，这些小图片特点是数量多，并且很小。为了减轻与服务器交互带来的不必要的开销，可以将这些小图标全部放在一张大图上，要用哪个图标通过上面说过的<code>background-position</code>来指定即可。</p><p><img src="http://bloghello.oursnail.cn/html5-5.png" alt="image"></p><p>比如我想只显示那个奖杯。</p><p><img src="http://bloghello.oursnail.cn/html5-6.png" alt="image"></p><p>慢慢移动到这个位置就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文来说一说图片相关的一些处理以及精灵图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【面试题40-数组中只出现一次的数字】</title>
    <link href="http://yoursite.com/2019/03/11/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9840-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/11/剑指offer/【面试题40-数组中只出现一次的数字】/</id>
    <published>2019-03-11T05:31:34.199Z</published>
    <updated>2019-03-11T05:38:40.213Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第四十题。</p><a id="more"></a><h2>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><h2>解题思路</h2><p>一种简单的思路，可以想到用<code>HashSet</code>这种数据结构来存，重复的就立即剔除，剩下的就是不重复的两个数字，将其取出即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.isEmpty() &amp;&amp; set.contains(array[i]))&#123;</span><br><span class="line">                set.remove(array[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这边处理的不够好</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(set.size() == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Integer i:set)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        num1[<span class="number">0</span>] = list.get(<span class="number">0</span>);</span><br><span class="line">        num2[<span class="number">0</span>] = list.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于题目中说除了两个单个数字外，其他的都出现偶数次。我们需要从这句话入手，寻求更优的解决思路。</p><p>我们知道，位运算中异或的性质是：两个相同数字异或=0，不相同的话肯定不为0，一个数和0异或还是它本身。</p><p>这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。</p><p>有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。</p><p>我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。</p><p>我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。</p><p>现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【解决思路】：从简单的场景想起，假设一个数组中只有一个独特元素，其他出现次数都为2</span></span><br><span class="line">        <span class="comment">//如何快速找出这个独特元素呢？那就是从头到尾两两异或，由于相同的数异或为0，则认为是抵消</span></span><br><span class="line">        <span class="comment">//一直到最后，结果必然就是这个独特元素</span></span><br><span class="line">        <span class="comment">//那么找出两个来也是这个思路，核心就是要将这两个独特的数分离开，下面详细介绍</span></span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            num1[<span class="number">0</span>] = num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//整个数组从头两两异或，最终的结果必然是两个不同数字的异或结果</span></span><br><span class="line">        <span class="comment">//因为相同的数字两两异或之后为0</span></span><br><span class="line">        <span class="comment">//0和任意一个数异或还是这个数本身</span></span><br><span class="line">        <span class="keyword">int</span> len = array.length, index = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            sum ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//java中int类型占4个字节，即32个bit</span></span><br><span class="line">        <span class="comment">//从左开始找到这个异或结果第一个为1的索引</span></span><br><span class="line">        <span class="keyword">while</span>((sum&amp;<span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">32</span>)&#123;</span><br><span class="line">            sum = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以这个索引处是否为1作为判定标准，就将两个不同的数分离开了</span></span><br><span class="line">        <span class="comment">//下面就是分两批不停地疑惑，就会得到这两个不同的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//这样就可以分别找到index处为1的独特解以及为0的独特解</span></span><br><span class="line">            <span class="keyword">if</span>(isBit(array[i],index))&#123;</span><br><span class="line">                num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断num的index（从左往右看）是否为1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBit</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        num = num &gt;&gt; index;</span><br><span class="line">        <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第四十题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题39-平衡二叉树】</title>
    <link href="http://yoursite.com/2019/03/11/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9839-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/11/剑指offer/【面试题39-平衡二叉树】/</id>
    <published>2019-03-11T05:31:24.909Z</published>
    <updated>2019-03-11T05:33:04.296Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第三十九题。</p><a id="more"></a><h2>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><h2>解题思路</h2><p>首先明确平衡二叉树的概念，就是数的最大高度和最小高度差不超过1.根据上一题我们得到灵感，我们可以分别求出左右子树的最大深度，然后对他们两进行比较即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取左右子树的最大高度</span></span><br><span class="line">        <span class="keyword">int</span> left = judge(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = judge(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两边高度不超过1即可</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left-right) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judge</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = judge(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = judge(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第三十九题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题38-二叉树的深度】</title>
    <link href="http://yoursite.com/2019/03/11/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9838-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/11/剑指offer/【面试题38-二叉树的深度】/</id>
    <published>2019-03-11T05:31:14.667Z</published>
    <updated>2019-03-11T05:33:14.930Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第三十八题。</p><a id="more"></a><h2>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h2>解题思路</h2><p>看到二叉树，递归基本没跑了，我们只要想好递归关系即可。我们假设已经正确拿到了root结点左右子树的最大深度，那么最后加一即可。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归的出口，root为0则返回0，这里可以理解为root为0那肯定没有层数了</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到左子树的最大深度</span></span><br><span class="line">        <span class="keyword">int</span> leftDep = TreeDepth(root.left);</span><br><span class="line">        <span class="comment">//拿到右子树的最大深度</span></span><br><span class="line">        <span class="keyword">int</span> rightDep = TreeDepth(root.right);</span><br><span class="line">        <span class="comment">//找出最大值，并且加上root这一层即可</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDep,rightDep) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第三十八题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题37-数字在排序数组中出现的次数】</title>
    <link href="http://yoursite.com/2019/03/11/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9837-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/11/剑指offer/【面试题37-数字在排序数组中出现的次数】/</id>
    <published>2019-03-11T05:31:02.173Z</published>
    <updated>2019-03-11T05:33:26.586Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第三十七题。</p><a id="more"></a><h2>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p><h2>解题思路</h2><p>看到排序数组，第一个想到的是二分查找，我们来看看这里是如何应用二分查找法的。</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//统计次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//进入二分查找，注意边界</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="comment">//先找到中间点</span></span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; k)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &lt; k)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//走到这边，说明找到了第一个相等的数，先将count加一</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//开始从index-1往前找有没有相等的</span></span><br><span class="line">                <span class="keyword">int</span> index = mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; array[index--] == k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始从index+1往后找有没有相等的</span></span><br><span class="line">                index = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(index &lt; array.length &amp;&amp; array[index++] == k)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//提前跳出while循环，结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第三十七题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【面试题36-两个链表的第一个公共结点】</title>
    <link href="http://yoursite.com/2019/03/11/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9836-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/11/剑指offer/【面试题36-两个链表的第一个公共结点】/</id>
    <published>2019-03-11T02:30:04.520Z</published>
    <updated>2019-03-11T02:30:27.145Z</updated>
    
    <content type="html"><![CDATA[<p>剑指offer第三十六题。</p><a id="more"></a><h2>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p><h2>解题思路</h2><p>这个题目的两个链表应该是有共同的尾部，而不是简单的交叉。对于这种性质，可能有更好的思路，但是我这里还是用了比较简单的想法，遍历第一个链表放进set中，再遍历另一个链表，找到第一个一样的结点，就是公共结点。时间复杂度为O(m+n)</p><h2>我的答案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            set.add(pHead1);</span><br><span class="line">            pHead1 = pHead1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(pHead2))&#123;</span><br><span class="line">                <span class="keyword">return</span> pHead2;</span><br><span class="line">            &#125;</span><br><span class="line">            pHead2 = pHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;剑指offer第三十六题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer题解" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>小练习</title>
    <link href="http://yoursite.com/2019/03/10/front/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/03/10/front/小练习/</id>
    <published>2019-03-10T14:12:34.652Z</published>
    <updated>2019-03-10T14:12:56.817Z</updated>
    
    <content type="html"><![CDATA[<p>前端的小练习。</p><a id="more"></a><p>实现形如：</p><p><img src="http://bloghello.oursnail.cn/html4-1.png" alt="image"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="comment">/*去除整个页面中一些边距*/</span></span></span><br><span class="line"><span class="undefined">*&#123;</span></span><br><span class="line"><span class="undefined">margin: 0;</span></span><br><span class="line"><span class="undefined">padding: 0;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*设置大的div块，此时左右居中*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.nav</span>&#123;</span></span><br><span class="line"><span class="undefined">width: 1050px;</span></span><br><span class="line"><span class="undefined">height: 65px;</span></span><br><span class="line"><span class="undefined">margin: auto;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">li&#123;</span></span><br><span class="line"><span class="undefined">list-style: none;</span></span><br><span class="line"><span class="undefined">display: inline-block;</span></span><br><span class="line"><span class="css"><span class="comment">/*重点1，向左浮动解决&lt;li&gt;之间间隙问题*/</span></span></span><br><span class="line"><span class="undefined">float: left;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">a&#123;</span></span><br><span class="line"><span class="undefined">display: inline-block;</span></span><br><span class="line"><span class="undefined">height: 65px;</span></span><br><span class="line"><span class="undefined">width: 350px;</span></span><br><span class="line"><span class="css"><span class="comment">/*重点2，设置a标签中内容所占的高度与外面一样，这样内容就上下居中了*/</span></span></span><br><span class="line"><span class="undefined">line-height: 65px;</span></span><br><span class="line"><span class="css"><span class="comment">/*左右居中*/</span></span></span><br><span class="line"><span class="undefined">text-align: center;</span></span><br><span class="line"><span class="css"><span class="comment">/*去除下划线*/</span></span></span><br><span class="line"><span class="undefined">text-decoration: none;</span></span><br><span class="line"><span class="undefined">font-size: 18px;</span></span><br><span class="line"><span class="undefined">color: white;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.nav</span> <span class="selector-class">.inner-1</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#696391</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.nav</span> <span class="selector-class">.inner-2</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#9385f5</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.nav</span> <span class="selector-class">.inner-3</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#3c64c2</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"inner-1"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>JAVA WEB<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"inner-2"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>项目实战<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"inner-3"</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>微服务/分布式/中间件<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端的小练习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS显示模式</title>
    <link href="http://yoursite.com/2019/03/10/front/CSS%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/10/front/CSS显示模式/</id>
    <published>2019-03-10T11:16:06.149Z</published>
    <updated>2019-03-10T11:25:55.609Z</updated>
    
    <content type="html"><![CDATA[<p>CSS显示模式一般分为两种，一种是独占一行的<code>block</code>一种是行内元素<code>inline</code>类型。他们之间可以互相转换。是比较常见的，比较重要。</p><a id="more"></a><h2>显示模式</h2><p>我们知道<code>div</code>是独占一行或者说一块<code>block</code>，默认情况下同行是不能再放其他元素了。<code>span</code>是行内元素，即<code>inline</code>，一行可以有很多列这样的元素。</p><p>他们还有一个区别是，块级元素可以设置行高，但是行内元素是不能设置行高的，比如<code>span</code>给他一个高度也是没有用的，它是随着里面内容的变化而变化的，比如文字，里面的文字变大，那么这个<code>span</code>区域也就会随着变大。</p><p><code>block</code>和<code>inline</code>就是两种显示模式。</p><h2>block转inline</h2><p><img src="http://bloghello.oursnail.cn/html3-1.png" alt="image"></p><p>我们可以验证上面的说法，就是<code>div</code>是个块级，一行默认独占一格，所以两个<code>inner</code>就分为了两行，那么有没有办法调整为<code>inline</code>元素呢？</p><p><img src="http://bloghello.oursnail.cn/html3-2.png" alt="image"></p><p>这又验证了一下上面的说法，就是<code>inline</code>元素是否显示以及显示的大小与里面的内容有关。如果我这里不写一点字占坑的话，就直接没了。</p><p>此时我们发现虽然可以将这两个<code>div</code>放到同一行去，但是称为<code>inline</code>元素之后我们就不能随意设置它的宽高了，我又想把他们搞到一行，又想设置宽高，怎么实现呢？答案就是用<code>inline-block</code></p><p><img src="http://bloghello.oursnail.cn/html3-3.png" alt="image"></p><h2>inline转block</h2><p>比如比较常见的<code>a</code>标签，往往不是点文字才有用，而是点一大块区域都可以，但是我们知道<code>a</code>标签是一格<code>inline</code>标签，不能直接给他设置宽高，这个时候需要将它转为<code>block</code>就好了，怎么搞呢？</p><p><img src="http://bloghello.oursnail.cn/html3-4.png" alt="image"></p><p>通过<code>display: block;</code>之后就变成了<code>inline-block</code>，就可以设置宽高了，那一片区域都可以作为超链接点击。</p><p>下面再来一个例子，比如<code>ul</code>和<code>li</code>标签，默认情况下是每一个独占一行的，如果我想让它跟分页一样排成一行怎么弄呢？起始很简单就是将其置为<code>inline-block</code>即可。</p><p><img src="http://bloghello.oursnail.cn/html3-5.png" alt="image"></p><p>下一节用之前的知识做一个小例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS显示模式一般分为两种，一种是独占一行的&lt;code&gt;block&lt;/code&gt;一种是行内元素&lt;code&gt;inline&lt;/code&gt;类型。他们之间可以互相转换。是比较常见的，比较重要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CSS选择器相关</title>
    <link href="http://yoursite.com/2019/03/10/front/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2019/03/10/front/CSS选择器相关/</id>
    <published>2019-03-10T08:24:43.110Z</published>
    <updated>2019-03-10T11:24:44.452Z</updated>
    
    <content type="html"><![CDATA[<p>CSS要想根据我们的需要对指定的东西进行美化，需要用到选择器。下面我们来看看基本的选择器是如何使用的。</p><a id="more"></a><h2>一、内联样式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color: skyblue;border: 1px dashed red;"</span>&gt;</span>我是南邮吴镇宇！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般情况下不会这么写，所以会涉及选择器，就是css到底对谁起作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure><p>在外部放一个css文件。</p><h2>二、选择器</h2><h5>2.1 ID选择器</h5><p>就是给某个标签，比如<code>div</code>标签增加一个<code>id=&quot;div1&quot;</code>，那么我就可以通过</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> dashed red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#div1</span>&#123;</span></span><br><span class="line"><span class="undefined">    border: 1px dashed red;</span></span><br><span class="line"><span class="undefined">    color: skyblue;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>我是南邮吴镇宇！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是精准控制每个id是不现实的，要累死人的，下面介绍标签选择器。</p><h5>2.2 标签选择器</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> dashed red;</span><br><span class="line">    <span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>标签为<code>div</code>的都起作用了。这种方式也不好，因为范围太大了。</p><h5>2.3 类选择器</h5><p>形如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span>&#123;</span></span><br><span class="line"><span class="undefined">border: 1px dashed red;</span></span><br><span class="line"><span class="undefined">    color: skyblue;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span>我是南邮吴镇宇！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是南邮吴彦祖！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>class</code>可以写多个。这边可能会出现覆盖。但是注意类选择器的权重是小于ID选择器的，所以类选择器无法覆盖ID选择器的效果。</p><h5>2.4 后代选择器</h5><p>比如我这里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span>&#123;</span></span><br><span class="line"><span class="undefined">border: 1px dashed red;</span></span><br><span class="line"><span class="undefined">    color: skyblue;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">我是南邮吴镇宇！</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">我是南邮吴彦祖！</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么这两个<code>div</code>都会起作用，但是如果我只想让吴镇宇变化咋办呢？我们可以给他加个<code>span</code>标签。<code>span</code>是<code>.div</code>的儿子。也可以给这个<code>span</code>里面加一个<code>class</code>，写法一样的。这就是后代选择器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span> <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="undefined">border: 1px dashed red;</span></span><br><span class="line"><span class="undefined">    color: skyblue;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">我是南邮吴镇宇！</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">我是南邮吴彦祖！</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比较简单，这些都是比较常用的选择器，当然还有一些比较特殊的选择器，到时候再说。</p><h2>三、字体相关</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">font-size</span>: 16<span class="selector-tag">px</span>;<span class="comment">/*12px在谷歌中是最小的字体*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">font-family</span>: "宋体";<span class="comment">/*字体样式，一般用默认即可*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">font-style</span>: <span class="selector-tag">italic</span>;<span class="comment">/*默认是normal,italic是斜体*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">font-weight</span>: 900;<span class="comment">/*100-900的范围，默认是normal*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">text-align</span>: <span class="selector-tag">left</span>;<span class="comment">/*center置为中间*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">text-indent</span>: 2<span class="selector-tag">em</span>;<span class="comment">/*首行缩进*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">line-height</span>: 50<span class="selector-tag">px</span>;<span class="comment">/*调整一行的行高*/</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">a&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>;<span class="comment">/*去掉a标签的下划线*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">color</span>: <span class="selector-tag">green</span>;<span class="comment">/*设定默认链接是绿色*/</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*鼠标悬浮在a标签上之后就会变成红色并且出现下划线*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="undefined">color: red;</span></span><br><span class="line"><span class="undefined">text-decoration: underline;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">我是南邮吴镇宇！</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">我是南邮吴彦祖！</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2>四、交集和并集</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是1号<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"id"</span>&gt;</span>我是2号<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"para"</span>&gt;</span>我是3号<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"para"</span>&gt;</span>我是4号<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是5号<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想选标签是<code>p</code>并且<code>class=&quot;para&quot;</code>的行，这就是交集：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.para</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>如果我选择<code>class=&quot;para&quot;</code>或者<code>id=&quot;id&quot;</code>的行，这就是并集：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line"><span class="selector-id">#id</span>,<span class="selector-class">.para</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS要想根据我们的需要对指定的东西进行美化，需要用到选择器。下面我们来看看基本的选择器是如何使用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端基础" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
