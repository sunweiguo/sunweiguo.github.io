<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FourColor</title>
  
  <subtitle>学习技术一口吃不成胖子，慢慢走，每天只要进步一丢丢！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-12T07:38:01.513Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FourColor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池原理详解</title>
    <link href="http://yoursite.com/2019/02/12/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/12/thread/线程池原理详解/</id>
    <published>2019-02-12T07:36:14.209Z</published>
    <updated>2019-02-12T07:38:01.513Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA帮助开发者封装了一些现成的线程池调用，但是每种线程池都有自己的使用场景，如果不了解里面的原理，那么很容易掉进坑里，线程池原理也是面试的重灾区，因此本问将完整分析线程池的原理。</p><a id="more"></a><h2>一、new thread弊端</h2><p>从学习java多线程开始，我们就学习了用<code>new thread</code>来创建线程。但是他有一定的弊端：</p><ul><li>每次<code>new Thread</code>新建对象，性能差</li><li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM</li><li>缺少更多功能，如更多执行、定期执行、线程中断</li></ul><h2>二、线程池好处</h2><ul><li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li><li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li><li>提供定时执行、定期执行、单线程、并发数控制等功能</li></ul><h2>三、线程池相关参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>:核心线程数量</li></ul><blockquote><p>默认情况下，在创建了线程池后，线程池中的线程数为0，<br>（除非调用<code>prestartAllCoreThreads()</code>和<code>prestartCoreThread()</code>方法，从方法名字可以看出，是预创建线程的意思，即在没有任务到来之前，就创建<code>corePoolSize</code>个线程或1个线程）当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中；</p><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p></blockquote><ul><li><code>maximumPoolSize</code>:线程最大线程数</li></ul><blockquote><p>线程池中的最大线程数，表示线程池中最多能创建多少个线程。</p><p>超过就执行<code>reject</code>策略:如果队列满了,并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务</p></blockquote><ul><li><code>workQueue</code>:阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响，一般有以下几种选择：</li></ul><blockquote><p><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序；</p><p><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于<code>ArrayBlockingQueue</code>。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列；</p><p><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列；</p><p><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列；底层用<code>DelayedWorkQueue</code>实现。</p></blockquote><ul><li><code>keepAliveTime</code>：线程没有任务执行时最多保持多久时间终止</li></ul><blockquote><p>当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。（但是如果调用了<code>allowCoreThreadTimeOut(boolean value)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0；）</p></blockquote><ul><li><code>unit</code>:<code>keepAliveTime</code>的时间单位</li><li><code>threadFactory</code>：线程工厂，用来创建线程</li></ul><blockquote><p><code>threadFactory</code>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</p></blockquote><ul><li><code>handler</code>:饱和策略</li></ul><blockquote><p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。</p></blockquote><p>这些参数全部传给<code>ThreadPoolExecutor</code>之后，<code>ThreadPoolExecutor</code>就可以为我们提供一个线程池，我们可以对这个线程池提交以及终止线程任务。</p><h2>四、饱和策略</h2><p>当线程池中已经到了完全没有办法再接收新的线程进来的时候，就会启动饱和策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</span><br></pre></td></tr></table></figure><ol><li><code>AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常（默认）</li><li><code>CallerRunsPolicy</code>：只用调用所在的线程运行任务</li><li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li><code>DiscardPolicy</code>：不处理，丢弃掉,不抛出异常。</li></ol><h2>五、线程池的源码解读</h2><p>程序中要声明线程池，是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">exec.excute(Runnable command);</span><br></pre></td></tr></table></figure><p>先来看看<code>ExecutorService</code>其中的奥秘。</p><h5>5.1 ExecutorService和Executor的关系</h5><p><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为<code>void</code>，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>ExecutorService</code>具备管理执行器和任务生命周期的方法，提交任务机制更加完善。<code>Executor</code>只是运行新任务的简单接口，目的是将任务提交和任务执行解耦。</p><h5>5.2 ThreadPoolExecutor重要方法</h5><p>我们知道，在执行<code>Executors.newCachedThreadPool()</code>的时候，内部是调用<code>ThreadPoolExecutor</code>的构造函数来生成<code>Exceutors</code>对象，即生成了线程池，因为继承关系是：<code>ThreadPoolExecutor extends AbstractExecutorService implements ExecutorService extends Executor</code>。构建好之后，就可以构建工作线程去执行任务。其中，流程是这样的：</p><p><img src="http://bloghello.oursnail.cn/thread11-2.jpg" alt="image"></p><p>所以，用于<code>execute()</code>或者<code>submit()</code>的线程任务都是被封装成<code>worker</code>去执行的。下面来看看<code>execute()</code>和<code>submit()</code>等核心方法。</p><p>在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p><ul><li><code>execute()</code></li></ul><blockquote><p><code>execute()</code>方法实际上是<code>Executor</code>中声明的方法，在<code>ThreadPoolExecutor</code>进行了具体的实现，这个方法是<code>ThreadPoolExecutor</code>的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p></blockquote><ul><li><code>submit()</code></li></ul><blockquote><p><code>submit()</code>方法是在<code>ExecutorService</code>中声明的方法,这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code>方法不同，它能够返回任务执行的结果，去看<code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了<code>Future</code>来获取任务执行结果。</p></blockquote><ul><li><code>shutdown()</code><br>将线程池状态置为<code>SHUTDOWN</code>,并不会立即停止：</li></ul><blockquote><p>停止接收外部<code>submit</code>的任务内部正在跑的任务和队列里等待的任务，会执行完等到第二步完成后，才真正停止</p></blockquote><ul><li><code>shutdownNow()</code><br>将线程池状态置为<code>STOP</code>。企图立即停止，事实上不一定：</li></ul><blockquote><p>跟<code>shutdown()</code>一样，先停止接收外部提交的任务忽略队列里等待的任务尝试将正在跑的任务<code>interrupt</code>中断返回未执行的任务列表</p><p>它试图终止线程的方法是通过调用<code>Thread.interrupt()</code>方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有<code>sleep</code> 、<code>wait</code>、<code>Condition</code>、定时锁等应用, <code>interrupt()</code>方法是无法中断当前的线程的。所以，<code>ShutdownNow()</code>并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。但是大多数时候是能立即退出的</p></blockquote><ul><li><code>awaitTermination(long timeOut, TimeUnit unit)</code></li></ul><blockquote><p>当前线程阻塞，直到等所有已提交的任务（包括正在跑的和队列中等待的）执行完或者等超时时间到或者线程被中断，抛出<code>InterruptedException</code></p><p>然后返回true（<code>shutdown</code>请求后所有任务执行完毕）或false（已超时）</p><p><code>shuntdown()</code>和<code>awaitTermination()</code>效果差不多，方法执行之后，都要等到提交的任务全部执行完才停。</p><p><code>shutdown()</code>后，不能再提交新的任务进去；但是<code>awaitTermination()</code>后，可以继续提交。</p><p><code>awaitTermination()</code>是阻塞的，返回结果是线程池是否已停止（true/false）；<code>shutdown()</code>不阻塞。</p></blockquote><h5>5.3 Executors生成线程池</h5><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>Executors</code>类里面提供了一些静态工厂，生成一些常用的线程池。这个就涉及上面我们反复提及的核心类：<code>ThreadPoolExecutor</code>。</p><p>⭐其实都是通过调用<code>ThreadPoolExecutor</code>来完成的，最后可以返回<code>ExecutorService</code>对象，其实说白了都是<code>Excutor</code>对象。</p><p>下面来分别看看比较常用的线程池。</p><ul><li><code>newSingleThreadExecutor</code></li></ul><blockquote><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为1的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="comment">//线程由DefaultThreadFactory默认创建，有统一的命名规范，并且优先级是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                               threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:10,index:1</span><br><span class="line">task:10,index:2</span><br><span class="line">task:10,index:3</span><br><span class="line">task:10,index:4</span><br><span class="line">task:10,index:5</span><br><span class="line">task:10,index:6</span><br><span class="line">task:10,index:7</span><br><span class="line">task:10,index:8</span><br><span class="line">task:10,index:9</span><br></pre></td></tr></table></figure><p>运行结果分析：单线程+有序。</p><ul><li><code>newFixedThreadPool</code></li></ul><blockquote><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为nThreads的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:11,index:1</span><br><span class="line">task:11,index:3</span><br><span class="line">task:11,index:4</span><br><span class="line">task:11,index:5</span><br><span class="line">task:11,index:6</span><br><span class="line">task:11,index:7</span><br><span class="line">task:11,index:8</span><br><span class="line">task:11,index:9</span><br><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br></pre></td></tr></table></figure><p>结果分析：只创建了三个线程来执行。</p><ul><li><code>newCachedThreadPool</code></li></ul><blockquote><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个按需创建线程的线程池，初始线程个数为0，最多线程个数为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为同步队列</span></span><br><span class="line"><span class="comment">//keeyAliveTime=60说明只要当前线程60s内空闲则回收</span></span><br><span class="line"><span class="comment">//特殊在于加入到同步队列的任务会被马上被执行，同步队列里面最多只有一个任务，并且存在后马上会拿出执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br><span class="line">task:14,index:4</span><br><span class="line">task:16,index:6</span><br><span class="line">task:18,index:8</span><br><span class="line">task:11,index:1</span><br><span class="line">task:13,index:3</span><br><span class="line">task:15,index:5</span><br><span class="line">task:17,index:7</span><br><span class="line">task:19,index:9</span><br></pre></td></tr></table></figure><p>结果分析：按需创建线程，几乎一次循环就创建了一个新的线程来执行。</p><ul><li><code>newScheduledThreadPool</code></li></ul><blockquote><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多长时间之后执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时执行，这里是每隔3秒执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);<span class="comment">//一开始延迟1秒执行任务，之后每隔3秒执行一次任务，不适合调用exec.shutdown();，因为会被关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>newSingleThreadScheduledExecutor</code></li></ul><blockquote><p>创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize为1，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上。demo不再赘述。</p><h5>5.4  线程池实现原理–线程池状态</h5><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt="image"></p><ul><li><code>static final int RUNNING = 0;</code></li></ul><blockquote><p>当创建线程池后，初始时，线程池处于RUNNING状态；</p></blockquote><ul><li><code>static final int SHUTDOWN = 1;</code></li></ul><blockquote><p>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p></blockquote><ul><li><code>static final int STOP = 2;</code></li></ul><blockquote><p>如果调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p></blockquote><ul><li><code>static final int TERMINATED = 3;</code></li></ul><blockquote><p>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</p></blockquote><h5>6.5 线程池实现原理–任务的执行</h5><p><code>corePoolSize</code>与<code>maximumPoolSize</code>的关系举个简单的例子形象理解就是：</p><blockquote><p>假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p><p>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p><p>然后就将任务也分配给这4个临时工人做；</p><p>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p></blockquote><p>这个例子中的<code>corePoolSize</code>就是10，而<code>maximumPoolSize</code>就是14（10+4）。</p><p><code>maximumPoolSize</code>可以看作是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>在<code>ThreadPoolExecutor</code>类中，最核心的任务提交方法是<code>execute()</code>方法，虽然通过<code>submit</code>也可以提交任务，但是实际上<code>submit</code>方法里面最终调用的还是<code>execute()</code>方法，所以我们只需要研究<code>execute()</code>方法的实现原理即可：</p><p>注：<code>execute()</code>方法和<code>submit()</code>方法已经在前面讲过区别了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">     <span class="comment">// Proceed in 3 steps:</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 1. </span></span><br><span class="line">     <span class="comment">// 判断当前的线程数是否小于corePoolSize,如果是，使用入参任务通过addWord方法创建一个新的线程，</span></span><br><span class="line">     <span class="comment">// 如果能完成新线程创建exexute方法结束，成功提交任务</span></span><br><span class="line">     <span class="comment">// 2. </span></span><br><span class="line">     <span class="comment">// 在第一步没有完成任务提交；状态为运行并且能够成功加入任务到工作队列后，再进行一次check，如果状态</span></span><br><span class="line">     <span class="comment">// 在任务加入队列后变为了非运行（有可能是在执行到这里线程池shutdown了），非运行状态下当然是需要</span></span><br><span class="line">     <span class="comment">// reject；然后再判断当前线程数是否为0（有可能这个时候线程数变为了0），如是，新增一个线程；</span></span><br><span class="line">     <span class="comment">// 3. </span></span><br><span class="line">     <span class="comment">// 如果不能加入任务到工作队列，将尝试使用任务新增一个线程，如果失败，则是线程池已经shutdown或者线程池</span></span><br><span class="line">     <span class="comment">// 已经达到饱和状态，所以reject这个任务</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果工作线程数大于等于核心线程数</span></span><br><span class="line">    <span class="comment">// 线程的的状态为RUNNING并且队列notfull</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查线程的运行状态，如果不是RUNNING直接从队列中移除</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 移除成功，拒绝该非运行的任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">            <span class="comment">// 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列满了或者是非运行的任务都拒绝执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的程序流程图为：</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B111.png" alt="image"></p><p>为了理解更加得透彻，用下图配合文字总结一下：</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86111.png" alt="image"></p><ul><li>1.如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>2.如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>3.如果无法将任务加入<code>BlockingQueue</code>（队列已满），则在非<code>corePool</code>中创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li><li>4.如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ul><blockquote><p><code>ThreadPoolExecutor</code>采取上述步骤的总体设计思路，是为了在执行<code>execute()</code>方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JAVA帮助开发者封装了一些现成的线程池调用，但是每种线程池都有自己的使用场景，如果不了解里面的原理，那么很容易掉进坑里，线程池原理也是面试的重灾区，因此本问将完整分析线程池的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从CAS到Atomic包原理</title>
    <link href="http://yoursite.com/2019/02/12/thread/%E4%BB%8ECAS%E5%88%B0Atomic%E5%8C%85%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/12/thread/从CAS到Atomic包原理/</id>
    <published>2019-02-12T03:48:48.284Z</published>
    <updated>2019-02-12T03:54:21.871Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，volatile保证了可见性，但是不能保证原子性，在面对线程安全问题时，就显地力不从心，那么除了synchronized关键字外，还有什么方式可以实现线程安全更新呢？本文首先介绍CAS是什么，引出JUC下一个重要的包：Atomic包。</p><a id="more"></a><h2>一、CAS简介</h2><p><code>CAS</code>（<code>Compare and Swap</code>），即比较并替换，实现并发算法时常用到的一种技术，<code>Doug lea</code>大神在java同步器中大量使用了<code>CAS</code>技术，鬼斧神工的实现了多线程执行的安全性。</p><p><code>CAS</code>的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回<code>true</code>，否则什么都不做，并返回<code>false</code>。</p><h2>二、n++问题</h2><p><img src="http://bloghello.oursnail.cn/thread9-1.jpg" alt="image"></p><p>通过<code>javap -verbose Case</code>看看<code>add</code>方法的字节码指令：</p><p><img src="http://bloghello.oursnail.cn/thread9-2.jpg" alt="image"></p><p>我们可以看到，<code>n++</code>被拆分成了下面几个指令：</p><ul><li>执行<code>getfield</code>拿到原始<code>n</code>；</li><li>执行<code>iadd</code>进行加1操作；</li><li>执行<code>putfield</code>写把累加后的值写回<code>n</code>；</li></ul><p>通过<code>volatile</code>修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果，那么应该如何解决呢？</p><p>这里顺便提一下线程安全三个特性</p><ul><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程观察到。</li><li>有序性：一个线程观察其他线程中的指令的执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ul><p>可以看到原子性是线程安全的一大特性。</p><h2>三、解决方案一</h2><p>在<code>add</code>方法加上<code>synchronized</code>修饰解决。</p><p><img src="http://bloghello.oursnail.cn/thread9-3.jpg" alt="image"></p><p>这个方案当然可行，但是性能上差了点，还有其它方案么？</p><h2>四、解决方案二</h2><p>我们可不可以用一下乐观锁的思想呢？即不加锁，等真正要赋值的时候比较一下。</p><p><img src="http://bloghello.oursnail.cn/thread9-4.jpg" alt="image"></p><p>当然了，这段代码如果真的在并发下执行，肯定出问题，只有把这整个过程变成一个原子操作才行，即同一时刻只有一个线程才能修改变量<code>a</code>。</p><p>如何实现呢？</p><p>我们注意到JUC下有个好东西，以<code>Atomic</code>打头的一些类。就可以很好地帮助我们实现对一个数加一减一的原子性操作。比如我们要安全地对<code>n</code>加一，可以这样做：</p><p><img src="http://bloghello.oursnail.cn/thread9-5.jpg" alt="image"></p><p>下面就以<code>AtomicInteger</code>的实现为例，分析一下<code>CAS</code>是如何实现的。</p><p><img src="http://bloghello.oursnail.cn/thread9-6.jpg" alt="image"></p><ul><li><code>Unsafe</code>，是<code>CAS</code>的核心类，由于Java方法无法直接访问底层系统，需要通过本地（<code>native</code>）方法来访问，<code>Unsafe</code>相当于一个后门，基于该类可以直接操作特定内存的数据。</li><li>变量<code>valueOffset</code>，表示该变量值在内存中的偏移地址，因为<code>Unsafe</code>就是根据内存偏移地址获取数据的。</li><li>变量<code>value</code>用<code>volatile</code>修饰，保证了多线程之间的内存可见性。</li></ul><p>看看<code>AtomicInteger</code>如何实现并发下的累加操作：</p><p><img src="http://bloghello.oursnail.cn/thread9-7.jpg" alt="image"></p><p>假设线程<code>A</code>和线程<code>B</code>同时执行<code>getAndIncrement</code>操作（分别跑在不同CPU上）：</p><ul><li>假设<code>AtomicInteger</code>里面的<code>value</code>原始值为0，即主内存中<code>AtomicInteger</code>的<code>value</code>为0，根据Java内存模型，线程A和线程B各自持有一份<code>value</code>的副本，值为0。</li><li>线程A通过<code>getIntVolatile(var1, var2)</code>拿到<code>value</code>值0，这时线程A被挂起。</li><li>线程B也通过<code>getIntVolatile(var1, var2)</code>方法获取到<code>value</code>值0，运气好，线程B没有被挂起，并执行<code>compareAndSwapInt</code>方法比较内存值也为0，成功修改内存值为1。</li><li>这时线程A恢复，执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值(0)和内存的值(1)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li><li>重新获取<code>value</code>值，因为变量<code>value</code>被<code>volatile</code>修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功。</li></ul><p>整个过程中，利用<code>CAS</code>保证了对于<code>value</code>的修改的并发安全，继续深入看看<code>Unsafe</code>类中的<code>compareAndSwapInt</code>方法实现。</p><p><img src="http://bloghello.oursnail.cn/thread9-8.jpg" alt="image"></p><p>我们看到是一个本地方法，并且在每个操作系统的具体实现都是不大一样的，这里我们就不再深究了。只要知道它的比较和替换是一个原子操作即可。</p><h2>五、其他重要的Atomic类</h2><h5>5.1 LongAdder</h5><p>上面提到了<code>AtomicInteger</code>，那么必然也存在``AtomicLong`。用法和原理是一样的。</p><p>既然用<code>LongAddr</code>也可以，但是为什么不使用<code>AtomicLong</code>呢？换句话说，为什么<code>AtomicLong</code>可以实现，还要有<code>LongAddr</code>这个类呢？？？</p><p><code>LongAddr</code>优点：我们从<code>AtomicInteger</code>这个类的实现看到，他是在一个死循环内不停地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功的几率很高。否则修改失败的概率就会很高。在大量修改失败的时候，多次尝试，性能会受到一定的影响。</p><p>对于普通类型的<code>Long</code>和<code>Double</code>变量，JVM允许将64位的读操作和写操作拆成两个32位的操作。</p><blockquote><p>我们知道<code>JUC</code>下面提供的原子类都是基于<code>Unsafe</code>类实现的，并由<code>Unsafe</code>来提供<code>CAS</code>的能力。<code>CAS</code> (<code>compare-and-swap</code>)本质上是由现代<code>CPU</code>在硬件级实现的原子指令，允许进行无阻塞，多线程的数据操作同时兼顾了安全性以及效率。<code>getAndAddLong</code>方法会以<code>volatile</code>的语义去读需要自增的域的最新值，然后通过<code>CAS</code>去尝试更新，正常情况下会直接成功后返回，但是在高并发下可能会同时有很多线程同时尝试这个过程，也就是说线程A读到的最新值可能实际已经过期了，因此需要在<code>while</code>循环中不断的重试，造成很多不必要的开销。</p></blockquote><p>将<code>AtomicLong</code>核心数据<code>value</code>分离成一个数组，每个线程访问时，通过<code>hash</code>等算法，映射到其中一个数字进行计数。最终的计数结果则为这个数组的求和累加。其中热点数据<code>value</code>会被分离成多个单元的<code>cell</code>，每个<code>cell</code>独自维护内部的值，当前对象的实际值由<code>cell</code>累计合成。这样，热点就得到有效的分离并提高了并行度。 <code>LongAddr</code>在<code>AtomicLong</code>基础上将单点的更新压力分散到各个节点上。低并发时通过对<code>base</code>直接更新，得到与<code>AtomicLong</code>一样的性能。</p><div class="tip">缺陷：统计的时候，如果有并发更新，会有统计的误差，例如获取一个全局唯一的ID还是采用`AtomicLong`更好一点。</div><h5>5.2 AtomicReference</h5><p>这个其实很简单，用法如下：</p><p><img src="http://bloghello.oursnail.cn/thread9-9.jpg" alt="image"></p><p>其实这个方法实现的是对一个共享对象的原子性操作，保证对象更新的原子性。</p><h5>5.3 AtomicIntegerFieldUpdater</h5><p>假设现在有这样的一个场景： 一百个线程同时对一个int对象进行修改，要求只能有一个线程可以修改。</p><p>可能有的同学会这么写：</p><p><img src="http://bloghello.oursnail.cn/thread9-10.jpg" alt="image"></p><p>我们来分析一下，对于<code>volatile</code>变量，写的时候会将线程本地内存的数据刷新到主内存上，读的时候会将主内存的数据加载到本地内存里，所以可以保证可见行和单个读/写操作的原子性。</p><p>但是上例中先</p><ul><li>先判断:<code>!ischanged</code></li><li>再执行赋值操作：<code>ischanged=true</code></li></ul><p>该组合操作就不能保证原子性了，也就是说线程A A1-&gt;A2 , 线程B B1-&gt;B2 (第一个操作为<code>volatile</code>读或者第二个操作为<code>volatile</code>写的时候，编译器不会对两个语句重排序，所以最后的执行顺序满足顺序一致性模型的)，但是最后的执行结果可能是A1-&gt;B1-&gt;A2-&gt;B2。不满足需求.</p><p>这种情况下，<code>AtomicIntegerFieldUpdater</code>就可以派上用场了。</p><p><img src="http://bloghello.oursnail.cn/thread9-11.jpg" alt="image"></p><p>对于这个代码的理解可以用下面这个代码来：</p><p><img src="http://bloghello.oursnail.cn/thread9-12.jpg" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update success 1:200</span><br><span class="line">update fail</span><br></pre></td></tr></table></figure><p>用<code>AtomicIntegerFieldUpdater.newUpdater</code>指定类里面的属性。这里我们要更新<code>Test</code>类里面的<code>A</code>字段（必须是<code>volatile</code>且不是<code>static</code>对象）。<code>update.compareAndSet()</code>方法使用<code>cas</code>机制，每次提交的时候都比较下<code>test.a</code>是不是100，如果是，则更新。</p><p>注意，不能使用<code>final</code>变量，因为语义冲突。对于<code>AtomicIntegerFieldUpdater</code>和<code>AtomicLongFieldUpdater</code>只能修改<code>int</code>/<code>long</code>类型的字段，不能修改其包装类型（<code>Integer</code>/<code>Long</code>）。如果要修改包装类型就需要使用<code>AtomicReferenceFieldUpdater</code>。</p><h5>5.4 AtomicStampedReference</h5><p>对于上面说的<code>AtomicInteger</code>等存在一个问题就是ABA问题。</p><p>ABA问题：其他线程将A改为B，又重新改为了A，本线程用期望值A与之进行比较，发现是相等的，则进行下面的操作。因为这个值已经被改变过，这就是ABA问题。</p><p>解决：用个版本号来控制，来防止ABA问题。</p><h5>5.5 AtomicBoolean</h5><p>场景：若干个线程进来，但是这个方法只能执行一次。</p><p><img src="http://bloghello.oursnail.cn/thread9-13.jpg" alt="image"></p><p>好了，其实<code>Atomic</code>包最核心的思想就是用无阻塞的<code>CAS</code>来代替锁实现高性能操作，是实现线程安全的一种可行方法，理解了<code>CAS</code>原理和他们的基本用法和场景使用，基本就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，volatile保证了可见性，但是不能保证原子性，在面对线程安全问题时，就显地力不从心，那么除了synchronized关键字外，还有什么方式可以实现线程安全更新呢？本文首先介绍CAS是什么，引出JUC下一个重要的包：Atomic包。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile详解</title>
    <link href="http://yoursite.com/2019/02/11/thread/volatile%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/11/thread/volatile详解/</id>
    <published>2019-02-11T13:13:55.833Z</published>
    <updated>2019-02-11T13:16:10.932Z</updated>
    
    <content type="html"><![CDATA[<p>volatile是比较重要的关键字，它涉及JMM，我们需要对其进行深入了解。</p><a id="more"></a><h2>一、java内存模型JMM</h2><p>JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。</p><p>请务必区分HMM和JAVA内存区域，JMM描述的是一组规则，围绕原子性、有序性以及可见性展开。</p><p><img src="http://bloghello.oursnail.cn/thread8-1.png" alt="image"></p><p>大多数的变量是只能存储在主内存中的，线程也不能直接去主内存中读取数据，而是获取数据的副本，每个线程对这个副本进行修改后，会在某个时机刷新回主内存。每个线程之间的工作内存的值是互不透明的，因此不能互相访问，线程间的通信必须通过主内存来完成。</p><h2>二、JMM主内存和工作内存都放些什么</h2><ul><li>主内存<ul><li>存储JAVA实例对象</li><li>包括实例变量、类信息、常量、静态变量等</li><li>属于数据共享的区域，多线程并发操作时会引起线程安全问题</li></ul></li><li>工作内存<ul><li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见(方法里的基本数据类型会直接被存储在工作内存的栈帧结构中)</li><li>字节码行号指示器、Native方法信息</li><li>如果是引用类型，引用存储在工作内存中，实例存储在主内存中</li><li>属于线程私有数据区域，不存在线程安全问题</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/thread8-2.jpg" alt="image"></p><h2>三、指令重排序</h2><p>为了提高执行性能，JVM会进行一定的指令重排序，禁止方式就是加入内存屏障指令，下面会说。</p><p>当然了，指令重排序需要满足一定的条件：</p><ul><li>在单线程环境下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li></ul><p>无法通过<code>happend-before</code>原则推导出来的，才能进行指令的重排序。</p><h2>四、happend-before</h2><p>多线程有两个基本的问题，就是原子性和可见性，而<code>happens-before</code>规则就是用来解决可见性的。</p><p>即：在时间上，动作A发生在动作B之前，能不能<strong>保证</strong>B可以看见A？如果可以保证的话，那么就可以说<code>hb(A,B)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行<code>writer()</code>方法之后，线程B执行<code>reader()</code>方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p><ul><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据volatile规则，2 happens before 3。</li><li>根据happens before 的传递性规则，1 happens before 4。</li></ul><p>上述<code>happens before</code> 关系的图形化表现形式如下：</p><p><img src="http://bloghello.oursnail.cn/thread8-3.png" alt="image"></p><p>在上图中，每一个箭头链接的两个节点，代表了一个<code>happens before</code> 关系。黑色箭头表示程序顺序规则；橙色箭头表示<code>volatile</code>规则；蓝色箭头表示组合这些规则后提供的<code>happens before</code>保证。</p><p>这里A线程写一个<code>volatile</code>变量后，B线程读同一个<code>volatile</code>变量。A线程在写<code>volatile</code>变量之前所有可见的共享变量，在B线程读同一个<code>volatile</code>变量后，将立即变得对B线程可见。</p><p>说了那么多，java中是如何保证这种可见性的呢？<code>Volatile</code>闪亮登场。</p><h2>五、什么是volatile</h2><p><code>volatile</code>关键字的目的是保证被它修饰的共享变量对所有线程总是可见的。</p><h2>六、为什么要用volatile</h2><p><code>Volatile</code>变量修饰符如果使用恰当的话，它比<code>synchronized</code>的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</p><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被<code>volatile</code>修饰之后，那么就具备了两层语义：</p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ul><h2>七、volatile如何保证可见性</h2><p><code>voliatile</code>关键字保证了在进程中变量的变化的可见性。</p><p>在多线程的应用里，如果线程操作了一个没有被<code>volatile</code>关键字标记的变量，那么每个线程都会在使用到这个变量时从主存里拷贝这个变量到CPU的<code>cache</code>里面（为了性能！CPU缓存可比内存快多了）。如果你的电脑有多于一个CPU，那么每个线程都会在不同的CPU上面运行，这意味着每个线程都会把这个变量拷贝到不同的CPU <code>cache</code>里面，正如下图所示：</p><p><img src="http://bloghello.oursnail.cn/thread8-4.png" alt="image"></p><p>一个不带有<code>volatile</code>关键字的变量在JVM从主存里面读取数据到CPU cache或者从cache里面写入数据到主存时是没有保证的。</p><p>想象这样一个场景，当一到两个线程允许去共享一个包含了一个计数变量的对象，这个计数变量如下所定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">//无关键字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这线程一增加了<code>counter</code>变量的值，但是，但是同时线程一和线程二都有可能随时读取这个<code>counter</code>变量。</p><p>如果这个<code>counter</code>变量未曾使用<code>volatile</code>声明，那么我们就无法保证这个变量在两个线程中所位于的CPU的cache和主存中的值是否保持一致了。示意图如下：</p><p><img src="http://bloghello.oursnail.cn/thread8-5.png" alt="image"></p><p>那么部分的线程就不能看到这个变量最新的样子，因为这个变量还没有被线程写回到主存中，这就是可见性的问题，这个线程更新的变量对于其他线程是不可视的。</p><p>在声明了<code>counter</code>变量的<code>volatile</code>关键字后，所有写入到<code>counter</code>变量的值会被立即写回到主存中。同时，所有读取这个变量的线程会先把对应的工作内存置为无效，从主存里面读取这个变量，下面的代码就是声明带<code>volatile</code>关键字的变量的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此声明这个变量就保证了这个变量对于其他写这个变量的线程的可见性。</p><p>总结：</p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了<code>Volatile</code>变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><h2>八、来详细说说volatile写-读的内存语义</h2><p><strong>volatile写的内存语义如下</strong>：</p><blockquote><p>当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</p></blockquote><p>以上面示例程序<code>VolatileExample</code>为例，假设线程A首先执行<code>writer()</code>方法，随后线程B执行<code>reader()</code>方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行<code>volatile</code>写后，共享变量的状态示意图：</p><p><img src="http://bloghello.oursnail.cn/thread8-6.png" alt="image"></p><p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p><p><strong>volatile读的内存语义如下</strong>：</p><blockquote><p>当读一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></blockquote><p><img src="http://bloghello.oursnail.cn/thread8-7.png" alt="image"></p><p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把<code>volatile</code>写和<code>volatile</code>读这两个步骤综合起来看的话，在读线程B读一个<code>volatile</code>变量后，写线程A在写这个<code>volatile</code>变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p><p>下面对<code>volatile</code>写和<code>volatile</code>读的内存语义做个总结：</p><ul><li>线程A写一个<code>volatile</code>变量，实质上是线程A向接下来将要读这个<code>volatile</code>变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程B读一个<code>volatile</code>变量，实质上是线程B接收了之前某个线程发出的（在写这个<code>volatile</code>变量之前对共享变量所做修改的）消息。</li><li>线程A写一个<code>volatile</code>变量，随后线程B读这个<code>volatile</code>变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h2>九、volatile如何禁止指令重排序</h2><p>这就不得不提一个指令叫做：内存屏障了。</p><p>它可就厉害了，</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ul><p>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化。</p><p>这个指令对编译器和CPU的执行都是起作用的，可用强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><p>因此，从根本上来说，是内存屏障指令实现了<code>volatile</code>的可见性和禁止指令重排序的。</p><h2>十、volatile的应用场景</h2><blockquote><p><code>volatile</code>关键字只能对32位和64位的变量使用</p></blockquote><p><code>synchronized</code>关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而<code>volatile</code>关键字在某些情况下性能要优于<code>synchronized</code>，但是要注意<code>volatile</code>关键字是无法替代<code>synchronized</code>关键字的，因为<code>volatile</code>关键字无法保证操作的原子性。通常来说，使用<code>volatile</code>必须具备以下2个条件：</p><blockquote><p>1）对变量的写操作不依赖于当前值</p></blockquote><blockquote><p>2）该变量没有包含在具有其他变量的不变式中</p></blockquote><p>下面列举几个Java中使用<code>volatile</code>的几个场景。</p><p>①.状态标记量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②.单例模式中的<code>double check</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>instance = new Singleton();</code>//非原子操作</p></blockquote><p>执行这一句，JVM发生了如下事情：</p><ul><li>给 <code>instance</code> 分配内存</li><li>调用 <code>Singleton</code> 的构造函数来初始化成员变量</li><li>将<code>instance</code>对象指向分配的内存空间（执行完这步 <code>instance</code> 就为非 <code>null</code> 了）</li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 <code>instance</code> 已经是非 <code>null</code> 了（但却没有初始化），所以线程二会直接返回 <code>instance</code>，然后使用，然后顺理成章地出错了，不再是单例了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;volatile是比较重要的关键字，它涉及JMM，我们需要对其进行深入了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读写锁ReentrantReadWriteLock</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/"/>
    <id>http://yoursite.com/2019/02/11/thread/读写锁ReentrantReadWriteLock/</id>
    <published>2019-02-11T11:35:01.023Z</published>
    <updated>2019-02-11T11:38:36.811Z</updated>
    
    <content type="html"><![CDATA[<p>读写锁的出现是为了提高性能，思想是：读读不互斥，读写互斥，写写互斥。本文来了解一下读写锁的使用和锁降级的概念。</p><a id="more"></a><h2>1. 锁的分类</h2><ul><li>排他锁：在同一时刻只允许一个线程进行访问，其他线程等待；</li><li>读写锁：在同一时刻允许多个读线程访问，但是当写线程访问，所有的写线程和读线程均被阻塞。读写锁维护了一个读锁加一个写锁，通过读写锁分离的模式来保证线程安全，性能高于一般的排他锁。</li></ul><h2>2. 读写锁</h2><p>我们对数据的操作无非两种：“读”和“写”，试想一个这样的情景，当十个线程同时读取某个数据时，这个操作应不应该加同步。答案是没必要的。只有以下两种情况需要加同步：</p><ul><li>这十个线程对这个公共数据既有读又有写</li><li>这十个线程对公共数据进行写操作</li><li>以上两点归结起来就一点就是有对数据进行改变的操作就需要同步</li></ul><p>所以</p><p><strong>java5提供了读写锁这种锁支持多线程读操作不互斥，多线程读写互斥，多线程写互斥</strong>。读操作不互斥这样有助于性能的提高，这点在java5以前没有。</p><h2>3. java并发包提供的读写锁</h2><p>java并发包提供了读写锁的具体实现<code>ReentrantReadWriteLock</code>，它主要提供了一下特性：</p><ul><li>公平性选择：支持公平和非公平（默认）两种获取锁的方式，非公平锁的吞吐量优于公平锁；</li><li>可重入：支持可重入，读线程在获取读锁之后能够再次获取读锁，写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁；</li><li>锁降级：线程获取锁的顺序遵循获取写锁，获取读锁，释放写锁，写锁可以降级成为读锁。</li></ul><h2>4. 先看个小例子</h2><p><strong>读取数据和写入数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个map用来读取和存放数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化ReentrantReadWriteLock</span></span><br><span class="line"><span class="keyword">private</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据实例化对象分别获取读锁和写锁</span></span><br><span class="line"><span class="keyword">private</span> Lock r = rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上读锁</span></span><br><span class="line">r.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 读操作开始执行"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">System.out.println(map.get(key));</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解读锁</span></span><br><span class="line">r.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 读操作执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入数据，即写数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上写锁</span></span><br><span class="line">w.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 写操作开始执行"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">map.put(key, value);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//解写锁</span></span><br><span class="line">w.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 写操作执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main进行创建多线程测试：先来测试一下存在写的情况(只有写或者写读都有)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 写操作开始执行</span><br><span class="line">Thread-0 写操作执行完毕</span><br><span class="line">Thread-1 读操作开始执行</span><br><span class="line">value1</span><br><span class="line">Thread-1 读操作执行完毕</span><br><span class="line">Thread-2 写操作开始执行</span><br><span class="line">Thread-2 写操作执行完毕</span><br><span class="line">Thread-3 写操作开始执行</span><br><span class="line">Thread-3 写操作执行完毕</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>发现存在写的情况，那么就是一个同步等待的过程，即开始执行，然后等待3秒，执行完毕，符合第2个目录中提到的规则。</p><p><strong>对只有读操作的情形进行测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">demo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">demo.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">demo.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 读操作开始执行</span><br><span class="line">Thread-1 读操作开始执行</span><br><span class="line">Thread-2 读操作开始执行</span><br><span class="line">value1</span><br><span class="line">Thread-0 读操作执行完毕</span><br><span class="line">value2</span><br><span class="line">Thread-1 读操作执行完毕</span><br><span class="line">value3</span><br><span class="line">Thread-2 读操作执行完毕</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>在主线程中先<code>put</code>进去几个数用于读的测试，下面开辟三个读线程，我们可以从执行结果中发现，其中一个线程进去之后，另外的线程能够立即再次进入，即这三把锁不是互斥的。</p><h2>5. 锁降级</h2><p>锁降级是指写锁将为读锁。</p><p>锁降级：从写锁变成读锁；锁升级：从读锁变成写锁。读锁是可以被多线程共享的，写锁是单线程独占的。也就是说写锁的并发限制比读锁高，这可能就是升级/降级名称的来源。</p><p>如下代码会产生死锁，因为同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，<code>ReentrantReadWriteLock</code>是不支持的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line">rtLock.readLock().lock();  <span class="comment">//上读锁</span></span><br><span class="line">System.out.println(<span class="string">"get readLock."</span>);  </span><br><span class="line">rtLock.writeLock().lock();  <span class="comment">//读锁还没有释放，不允许上死锁</span></span><br><span class="line">System.out.println(<span class="string">"blocking"</span>);</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>支持锁降级，如下代码不会产生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line">rtLock.writeLock().lock();  <span class="comment">//上写锁</span></span><br><span class="line">System.out.println(<span class="string">"writeLock"</span>);  </span><br><span class="line">  </span><br><span class="line">rtLock.readLock().lock();  <span class="comment">//可以在写锁没有释放的时候立即上读锁</span></span><br><span class="line">System.out.println(<span class="string">"get read lock"</span>);</span><br></pre></td></tr></table></figure><p>利用这个机制：<strong>同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，<code>ReentrantReadWriteLock</code>是不支持的。</strong></p><p>在写锁没有释放的时候，先获取到读锁，然后再释放写锁，保证后面读到的数据的一致性。</p><p><img src="https://segmentfault.com/img/bVOGUM?w=1063&amp;h=246" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isUpdate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">r.lock();<span class="comment">//为了保证isUpdate能够拿到最新的值</span></span><br><span class="line"><span class="keyword">if</span>(isUpdate)&#123;</span><br><span class="line">r.unlock();</span><br><span class="line">w.lock();</span><br><span class="line">map.put(<span class="string">"xxx"</span>,<span class="string">"xxx"</span>);</span><br><span class="line">r.lock();<span class="comment">//写锁还没有释放，立即获取读锁，阻塞本线程，保证本线程下面读的一致性</span></span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">String value = map.get(<span class="string">"xxx"</span>); <span class="comment">//读到的数据是本线程自己更新的数据，不会被其他线程打扰</span></span><br><span class="line">System.out.println(value);</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读写锁的出现是为了提高性能，思想是：读读不互斥，读写互斥，写写互斥。本文来了解一下读写锁的使用和锁降级的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从ReentrantLock引出AQS的原理</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E4%BB%8EReentrantLock%E5%BC%95%E5%87%BAAQS%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/11/thread/从ReentrantLock引出AQS的原理/</id>
    <published>2019-02-11T10:45:59.507Z</published>
    <updated>2019-02-11T11:28:48.109Z</updated>
    
    <content type="html"><![CDATA[<p>如果对并发编程稍微熟悉的话，就不会对ReentrantLock陌生，也可能对一些组件比如CountDownLatch,FutureTask以及Semaphore等同步组件耳闻过，他们都是JUC包下的类或者工具，他们都有一个共同的基础：AQS，即AbstractQueuedSynchronizer，从今天开始，让我们记住它，并且尝试去理解它。</p><a id="more"></a><h2>一、ReentrantLock</h2><p>首先我们先来看看<code>ReentrantLock</code>这个可重入锁的性质和使用，因为它往往会在面试中被面试官拿来同<code>synchronized</code>相比较。如果这种基本的比较都不知道的话，那就没有后续深入的探讨了，面试可能也会结束了。</p><p>它的用法极其简单，如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-1.jpg" alt="image"></p><p>他们两兄弟的区别是：</p><ul><li><code>synchronized</code>是关键字，<code>ReentrantLock</code>是一个类</li><li><code>ReentrantLock</code>可以对获取锁的等待时间进行设置，避免死锁</li><li><code>ReentrantLock</code>可以获取各种锁的信息</li><li><code>ReentrantLock</code>可以灵活地实现多路通知</li><li>机制：<code>synchronized</code>操作<code>MarkWord</code>，<code>lock</code>调用<code>Unsafe</code>类的<code>park()</code>方法</li><li><code>ReentrantLock</code>可以设置锁的公平性</li><li><code>ReentrantLock</code>调用<code>lock()</code>之后必须调用<code>unlock()</code>释放锁</li><li>性能上<code>ReentrantLock</code>未必就比<code>synchronized</code>高，他们都是可重入的</li></ul><p>可以看出，<code>ReentrantLock</code>更加灵活，可以更加细腻度操作锁，而<code>synchronized</code>看起来则相对比较笨拙，但是笨拙的是简单的，不存在忘记释放锁的问题。可谓存在即合理嘛！</p><p>针对上文中提到的<code>Unsafe</code>类，其中最经典的一个方法是：<code>compareAndSwapXXX</code>这类<code>CAS</code>方法，它其实是JAVA留的一个后门，它可以直接操作内存，因此如果普通开发者拿来用的话，可能会出现各种问题，因此被成为不安全的类。</p><p>好了，关于区别已经说的差不多了，下面我们就要来真格的了，首先来翻翻源码。<strong>前方高能预警，请非战斗人员紧急撤离现场，老司机要开车了。</strong></p><p>首先呢，我们来看看<code>lock()</code>方法的实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里多了一个东西叫<code>Sync</code>，<code>Sync</code>为<code>ReentrantLock</code>里面的一个内部类，它继承<code>AQS</code>，它有两个子类：公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>。</p><p><code>ReentrantLock</code>里面大部分的功能都是委托给<code>Sync</code>来实现的，同时<code>Sync</code>内部定义了<code>lock()</code>抽象方法由其子类去实现，默认实现了<code>nonfairTryAcquire(int acquires)</code>方法，可以看出它是非公平锁的默认实现方式。</p><p><img src="http://bloghello.oursnail.cn/thread7-2.jpg" alt="image"></p><p>几乎每一个方法都是通过<code>sync.xxx</code>来实现的，而<code>Sync</code>这个内部类在<code>AQS</code>的基础上增加一些东西而已，所以本质上都是基于<code>AQS</code>来实现的。</p><p>不仅仅是这个，JUC包基本都是以<code>AQS</code>为基础构成，因此<code>AQS</code>可以理解为JUC的一个实现框架。既然<code>AQS</code>这么重要，下面有必要挖地三尺掘出它的原理。</p><h2>二、AQS简介</h2><p>java的内置锁一直都是备受争议的，在JDK 1.6之前，<code>synchronized</code>这个重量级锁性能一直都是较为低下，虽然在1.6后，进行大量的锁优化策略,但是与<code>Lock</code>相比<code>synchronized</code>还是存在一些缺陷的：虽然<code>synchronized</code>提供了便捷性的隐式获取锁释放锁机制（基于JVM机制），但是它却缺少了获取锁与释放锁的可操作性，可中断、超时获取锁，且它为独占式在高并发场景下性能大打折扣。</p><p>AQS：<code>AbstractQueuedSynchronizer</code>，即队列同步器。它是构建锁或者其他同步组件的基础框架（如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<br><code>Semaphore</code>等），JUC并发包的作者（<code>Doug Lea</code>）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。</p><p>AQS解决了在实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS使用一个<code>int</code>类型的成员变量<code>state</code>来表示同步状态，当<code>state&gt;0</code>时表示已经获取了锁，当<code>state = 0</code>时表示释放了锁。它提供了三个方法（<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect,int update)</code>）来对同步状态<code>state</code>进行操作，当然AQS可以确保对<code>state</code>的操作是安全的。</p><p>AQS通过内置的<code>FIFO</code>同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><h2>三、CLH同步队列</h2><p><code>CLH</code>同步队列是一个<code>FIFO</code>双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>在<code>CLH</code>同步队列中，一个节点表示一个线程，它保存着线程的引用（<code>thread</code>）、状态（<code>waitStatus</code>）、前驱节点（<code>prev</code>）、后继节点（<code>next</code>），<code>CLH</code>同步队列结构图如下（注意图中有个小错误，就是第一个<code>node</code>的<code>prev</code>要指向<code>head</code>，由于不会太影响理解，所以就不改图了）：</p><p><img src="http://bloghello.oursnail.cn/thread7-3.jpg" alt="image"></p><p>举例理解：假设目前有三个线程<code>Thread1</code>、<code>Thread2</code>、<code>Thread3</code>同时去竞争锁，如果结果是<code>Thread1</code>获取了锁，<code>Thread2</code>和<code>Thread3</code>进入了等待队列，那么他们的样子如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-6.jpg" alt="image"></p><p>AQS的等待队列基于一个双向链表实现的，<code>HEAD</code>节点不关联线程，后面两个节点分别关联<code>Thread2</code>和<code>Thread3</code>，他们将会按照先后顺序被串联在这个队列上。这个时候如果后面再有线程进来的话将会被当做队列的<code>TAIL</code>。</p><h2>四、入列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWaiter(Node node)</code>先通过快速尝试设置尾节点，如果失败，则调用<code>enq(Node node)</code>方法设置尾节点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多次尝试，直到成功为止 </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置为尾节点 </span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就很明了了，首先是尝试快速用<code>CAS</code>设置当前的节点为尾节点，但是可能存在并发问题设置不成功，下面用死循环的方式不断地尝试添加节点并且设置为尾节点，直到成功。</p><p>过程如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-4.jpg" alt="image"></p><h2>五、出列</h2><p>CLH同步队列遵循<code>FIFO</code>，首节点的线程释放同步状态后，将会唤醒它的后继节点（<code>next</code>），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的<code>next</code>和当前节点的<code>prev</code>即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。</p><p><img src="http://bloghello.oursnail.cn/thread7-7.jpg" alt="image"></p><p>其实这里按照源码的解释，是将第一个获取到同步状态的<code>node</code>作为新的<code>head</code>，然后将原来的<code>head</code>置空。</p><h2>六、同步状态的获取与释放</h2><p>在前面提到过，AQS是构建Java同步组件的基础，我们期待它能够成为实现大部分同步需求的基础。AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情况。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。</p><h2>七、独占式-独占式同步状态获取</h2><p>独占式，同一时刻仅有一个线程持有同步状态。</p><p>独占式同步状态获取<code>acquire(int arg)</code>方法为AQS提供的模板方法，该方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire</code>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现(<code>ReentrantLock</code>中实现公平锁和非公平锁就是分别重写了这个方法实现的，下面看<code>ReentrantLock</code>的原理的时候就明白了)，该方法必须要保证线程安全的获取同步状态。</li><li><code>addWaiter</code>：如果<code>tryAcquire</code>返回<code>FALSE</code>（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li><code>acquireQueued</code>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt</code>：产生一个中断。</li></ul><p>对这里的<code>acquireQueued</code>有疑惑，下面来看看它做了什么。<code>acquireQueued</code>方法为一个自旋的过程，也就是说当前线程（<code>Node</code>）进入同步队列后，就会先进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点node的前驱结点p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果p确实是head，那说明当前节点node是可用的第一个线程</span></span><br><span class="line">            <span class="comment">//即为当前队列的第一个线程，则最先处理它</span></span><br><span class="line">            <span class="comment">//当前线程则尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//从这里可以看出，更新当前节点为头节点</span></span><br><span class="line">                <span class="comment">//将原来头节点的next引用置空以供JVM回收</span></span><br><span class="line">                <span class="comment">//具体见出列小标题下的示意图</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前驱节点不是头节点就继续阻塞继续等待呗</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p><ul><li>保持FIFO同步队列原则。</li><li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li></ul><p>对这个的理解简单来说就是：</p><blockquote><p>在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的队尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果当前节点的前驱节点就是头节点，则表明当前节点是当前队列中的第一个可用线程，则让其不断尝试获取同步状态，如果获取到，则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p></blockquote><p>继续，我们看到，如果发现前驱节点并不是<code>head</code>，那么就说明是比较靠后的节点了，这个时候，很有可能需要一段时间之后才会用到它，所以根本不需要再参与自旋浪费CPU的性能了，即下面一个if:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>通过这段代码我们可以看到，在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法，该方法主要靠前驱节点判断当前线程是否应该被阻塞，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//状态为signal，表示当前线程处于等待状态，直接放回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//前驱节点状态 &gt; 0 ，则为Cancelled,表明该节点已经超时或者被中断了，需要从同步队列中取消</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前驱节点状态为Condition、propagate</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要检查当前线程是否需要被阻塞，具体规则如下：</p><ul><li>如果当前线程的前驱节点状态为<code>SINNAL</code>，则表明当前线程需要被阻塞，调用<code>unpark()</code>方法唤醒，直接返回true，当前线程阻塞</li><li>如果当前线程的前驱节点状态为<code>CANCELLED（ws &gt; 0）</code>，则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li><li>如果前驱节点非<code>SINNAL</code>，非<code>CANCELLED</code>，则通过CAS的方式将其前驱节点设置为<code>SINNAL</code>，返回false</li></ul><p>针对<code>pred.waitStatus</code>的几种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法返回<code>true</code>，则调用<code>parkAndCheckInterrupt()</code>方法阻塞当前线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parkAndCheckInterrupt()</code> 方法主要是把当前线程挂起，从而阻塞住线程的调用栈，同时返回当前线程的中断状态。其内部则是调用<code>LockSupport</code>工具类的<code>park()</code>方法来阻塞该方法。</p><p>那么，此时，当第一个线程已经执行完毕，释放锁了，就需要唤醒队列中后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>unparkSuccessor(Node node)</code>唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//当前状态 &lt; 0 则设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从tail节点来找可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会存在当前线程的后继节点为<code>null</code>，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，但是为何是从<code>tail</code>尾节点开始，而不是从<code>node.next</code>开始呢？原因在于<code>node.next</code>仍然可能会存在<code>null</code>或者取消了，所以采用<code>tail</code>回溯办法找第一个可用的线程。最后调用<code>LockSupport</code>的<code>unpark(Thread thread)</code>方法唤醒该线程。</p><p>从上面我可以看到，当需要阻塞或者唤醒一个线程的时候，AQS都是使用LockSupport这个工具类来完成的。</p><p><code>LockSupport</code>定义了一系列以<code>park</code>开头的方法来阻塞当前线程，<code>unpark(Thread thread)</code>方法来唤醒一个被阻塞的线程。这些方法的实现都是通过<code>Unsafe</code>类调用<code>native</code>方法来实现的。</p><p>好了，至此就完完全全地搞明白了独占式同步状态获取<code>acquire(int arg)</code>方法的原理，特别是其中节点如何进出、队列第一个节点如何尝试获取同步状态、如何阻塞后继线程以及如何唤醒。</p><h2>八、独占式获取响应中断</h2><p><code>AQS</code>提供了<code>acquire(int arg)</code>方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于<code>CLH</code>同步队列中等待着获取同步状态。为了响应中断，<code>AQS</code>提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常<code>InterruptedException</code>。</p><p>具体原理就不深究了，其实源码跟上面个相差不大，只是不再是使用<code>interrupted</code>标志，而是直接抛出<code>InterruptedException</code>异常。再深究这博客没法继续写啦。</p><h2>九、独占式超时获取</h2><p><code>AQS</code>除了提供上面两个方法外，还提供了一个增强版的方法：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为<code>acquireInterruptibly</code>方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回<code>false</code>，否则返回<code>true</code>。</p><p>针对超时控制，程序首先记录唤醒时间<code>deadline</code> :<code>deadline</code> = <code>System.nanoTime()</code> +<code>nanosTimeout</code>（时间间隔）。</p><p>如果获取同步状态失败，则需要计算出需要休眠的时间间隔<code>nanosTimeout</code> = <code>deadline</code> - <code>System.nanoTime()</code>，如果<code>nanosTimeout</code> &lt;= 0 表示已经超时了，返回<code>false</code>;</p><p>如果大于<code>spinForTimeoutThreshold(1000L)</code>则需要休眠<code>nanosTimeout</code> ;</p><p>如果<code>nanosTimeout</code> &lt;= <code>spinForTimeoutThreshold</code> ，就不需要休眠了，直接进入快速自旋的过程。原因在于 <code>spinForTimeoutThreshold</code> 已经非常小了，非常短的时间等待无法做到十分精确，如果这时再次进行超时等待，相反会让<code>nanosTimeout</code> 的超时从整体上面表现得不是那么精确，所以在超时非常短的场景中，AQS会进行无条件的快速自旋。</p><p>流程图如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-8.jpg" alt="image"></p><h2>十、共享式-共享式同步状态获取</h2><p>共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p><p><code>AQS</code>提供<code>acquireShared(int arg)</code>方法共享式获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面程序可以看出，方法首先是调用<code>tryAcquireShared(int arg)</code>方法尝试获取同步状态，如果获取失败则调用<code>doAcquireShared(int arg)</code>自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。自旋方式获取同步状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryAcquireShared(int arg)</code>方法尝试获取同步状态，返回值为int，当其 &gt;= 0 时，表示能够获取到同步状态，这个时候就可以从自旋过程中退出。</p><p><code>acquireShared(int arg)</code>方法不响应中断，与独占式相似，AQS也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，这里就不做解释了。</p><h2>十一、共享式同步状态释放</h2><p>获取同步状态后，需要调用<code>release(int arg)</code>方法释放同步状态，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</p><h2>十二、再回过头来看看ReentrantLock的原理</h2><p>在对AQS原理进行大概了梳理之后，再来理解<code>ReentrantLock</code>就比较容易了，因为大部分的事情都由AQS做完了，剩下的只要重写几个个性化的方法即可。</p><p>还是要看看最核心的方法：<code>lock()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看这个<code>lock()</code>，一点点进了抽象静态内部类<code>Sync</code>中去了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>上面说过，<code>ReentrantLock</code>里面大部分的功能都是委托给<code>Sync</code>来实现的，同时<code>Sync</code>内部定义了<code>lock()</code>抽象方法由其子类去实现的，所以这个<code>lock</code>方法的具体实现是在子类中完成的。<code>Sync</code>的子类有<code>NonfairSync</code>和<code>FairSync</code>这两个，一看就知道了，一个是非公平一个是公平。</p><h2>十三、非公平锁</h2><p>先来看看比较简单的非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，这个<code>lock()</code>方法里面首先用<code>CAS</code>尝试获取锁，获取不到则执行<code>acquire()</code>方法，这个方法就恰好是完全由<code>AQS</code>实现，那么就回到了上面介绍过的内容了。这里为了方便再贴一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是调用<code>tryAcquire()</code>这个方法，即尝试获取锁，这个方法上面也提过，是留给具体的类自己去实现的，所以我们还要回到<code>ReentrantLock</code>中来看看，果然，在上面贴的<code>NonfairSync</code>这个类中对这个方法进行了重写。即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的方法就是实现尝试获取锁的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//state == 0,表示该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取锁成功，设置为当前线程所有</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程重入</span></span><br><span class="line">    <span class="comment">//判断锁持有的线程是否为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就很简单了，值得注意的是，为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作。</p><p>另外需要注意的是，这是非公平锁，就是说，一个线程进来，可能是比先进来的线程先获取锁，就像在开车的时候，总是会由一些车插到你的前面一样。但是如果它没有获取锁，则入队。</p><p>那么尝试获取锁的逻辑我们知道了，那么释放锁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。</p><h2>十四、公平锁</h2><p>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足<code>FIFO</code>。<code>ReentrantLock</code>的构造方法无参时是构造非公平锁。</p><p>提供了有参构造函数，可传入一个<code>boolean</code>值，<code>true</code>时为公平锁，<code>false</code>时为非公平锁，源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面非公平锁获取时（<code>nonfairTryAcquire</code>方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑与<code>nonfairTryAcquire</code>基本上一致，唯一的不同在于增加了<code>hasQueuedPredecessors</code>的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。</p><h2>十五、公平锁 VS 非公平锁</h2><ul><li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。</li><li>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，<code>ReentrantLock</code>默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果对并发编程稍微熟悉的话，就不会对ReentrantLock陌生，也可能对一些组件比如CountDownLatch,FutureTask以及Semaphore等同步组件耳闻过，他们都是JUC包下的类或者工具，他们都有一个共同的基础：AQS，即AbstractQueuedSynchronizer，从今天开始，让我们记住它，并且尝试去理解它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从底层理解synchronized</title>
    <link href="http://yoursite.com/2019/02/11/thread/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3synchronized/"/>
    <id>http://yoursite.com/2019/02/11/thread/从底层理解synchronized/</id>
    <published>2019-02-11T06:21:16.472Z</published>
    <updated>2019-02-11T06:21:44.186Z</updated>
    
    <content type="html"><![CDATA[<p>上一章了解了synchronized的基本使用方式之后，接下来我们来深入了解了解其底层原理，并且说明对它的优化。</p><a id="more"></a><h2>一、synchronized底层实现原理</h2><p>首先给出一个不是结论的结论，<code>synchronized</code>的实现基础是：<code>JAVA</code>对象头和<code>Monitor</code>，理解了这两者的作用就理解了<code>synchronized</code>的实现原理。下面进行详细讲解。</p><p>⭐然后在正式开始之前，先介绍一下锁的内存语义：</p><ul><li>当线程释放锁时，JAVA内存模型会把该线程对应额本地内存中的共享变量刷新到主内存中</li><li>当线程获取锁时，JAVA内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</li></ul><p>在<a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/" target="_blank" rel="noopener">JAVA内存模型-线程共享</a>这篇文章中介绍了对象头里面的基本构成。</p><p><img src="http://bloghello.oursnail.cn/thread6-1.jpg" alt="image"></p><p>我们着重看一下对象头，下面两个这里不需要关心。我们可以看到一个关键字：锁状态标志。因此<code>Mark Word</code>是实现锁的关键了。</p><p>我们也知道，<code>Mark Word</code>是一个可变的结构，可变的部分主要有如下：</p><p><img src="http://bloghello.oursnail.cn/thread6-2.jpg" alt="image"></p><p>其中，偏向所和轻量级锁是JDK1.6之后对<code>synchronized</code>优化所新加的，后文会探讨对<code>synchronized</code>的优化。</p><p>OK，到这里我们知道了每个对象区域的对象头这一块存储了关于锁的信息，即锁状态。仔细看表格，比如重量级锁，就是我们熟知的<code>synchronized</code>对象锁，它的说明是：指向重量级锁的指针。那这个锁是什么呢？指向的是什么位置呢？这个就不得不提及第二个关键字啦：<code>Monitor</code></p><p><code>Monitor</code>:每个对象打娘胎生下来就自带了一把看不见的锁，成为内部锁或者<code>Monitor</code>锁，也称为管程或者监视器锁。我们可以理解为一种同步工具，也可以理解为同步对象。</p><p>那么回到上面的问题上来，这个指针指向的就是<code>Monitor</code>对象的起始地址，因此，每个对象都会存在一个<code>Monitor</code>与之关联，当这个<code>Monitor</code>被一个线程持有时，它就会处于锁定状态。</p><p>在<code>Hotspot</code>虚拟机中，这个<code>Monitor</code>是由<code>ObjectMonitor</code>实现的，位于虚拟机源码中，用<code>C++</code>实现。我们一起来看看吧！</p><p>这个源码地址为：<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/76a9c9cf14f1/src/share/vm/runtime/objectMonitor.hpp" target="_blank" rel="noopener">objectMonitor.hpp</a></p><p><img src="http://bloghello.oursnail.cn/thread6-3.jpg" alt="image"></p><p>我们看到了几个比较重要的关键字，首先，每个等待获取锁的线程都会被封装为<code>ObjectWaiter</code>对象。<code>_WaitSet</code>就是之前说的所有<code>wait</code>状态的线程都会被放在这里等待唤醒再去竞争锁；<code>_EntryList</code>就是所有等待获取锁的线程对象存放的地方。<code>_owner</code>指向的是当前获取到锁的线程对象。<code>_count</code>为计数，这个就跟可重入相关了，线程进来一次就加一次，为0的时候就说明释放锁了，那么此时处于<code>_EntryList</code>池中的线程都可以去竞争这把锁了。</p><p>将上面文字转换为图来理解就是：</p><p><img src="http://bloghello.oursnail.cn/thread6-4.jpg" alt="image"></p><p>以上就是<code>Synchronized</code>实现锁的原理。</p><h2>二、synchronized在字节码层面的语义</h2><p>我们拿下面这段程序作为示例：</p><p><img src="http://bloghello.oursnail.cn/thread6-5.jpg" alt="image"></p><p>我们对这两个方法进行<code>javap</code>的分析，针对第一个同步代码块：</p><p><img src="http://bloghello.oursnail.cn/thread6-6.jpg" alt="image"></p><p>我们可以看出来，<code>synchronized</code>同步代码块实现同步的关键指令是<code>monitorenter</code>和<code>monitorexit</code>。这恰好与上面说的<code>monitor</code>锁对应上，即多个线程在<code>_EntryList</code>中竞争，看谁能拿到<code>monitor</code>锁的指向全，拿到了就可以进来，拿不到就阻塞在<code>monitorenter</code>处继续等待。知道这个锁被释放了为止。</p><p>那么对于<code>synchronized</code>修饰的方法呢？</p><p><img src="http://bloghello.oursnail.cn/thread6-7.jpg" alt="image"></p><p>如果是同步方法，在字节码层面的表示是略有不同的。我们注意到，是在某个标识位上给其打上<code>ACC_SYNCHRONIZED</code>标志，表示这是一个<code>synchronized</code>修饰的同步方法，那么下面对于锁竞争啥的都与上面一样，所以只是字节码层面的表示不同而已，原理都一样。</p><h2>三、对synchronized的优化</h2><p>对于<code>synchronized</code>的性能，在以前一直是嗤之以鼻的，这种观念从老一代的程序猿们口口相传到如今，可谓是根深蒂固，在以前的版本中，确实是很慢，原因如下：</p><ul><li>早期版本中，<code>synchronized</code>属于重量级锁，依赖于<code>Mutex Lock</code>实现</li><li>线程之间的切换需要从用户态转换到核心态，开销较大</li></ul><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h5>3.1 自旋锁</h5><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p>何谓自旋锁？</p><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p><p>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用<code>-XX:+UseSpinning</code>开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数<code>-XX:PreBlockSpin</code>来调整；</p><p>如果通过参数<code>-XX:preBlockSpin</code>来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h5>3.2 适应自旋锁</h5><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p><p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h5>3.3 锁消除</h5><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。</p><p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如<code>StringBuffer</code>、<code>Vector</code>、<code>HashTable</code>等，这个时候会存在隐形的加锁操作。比如<code>StringBuffer</code>的<code>append()</code>方法，<code>Vector</code>的<code>add()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM可以明显检测到变量<code>vector</code>没有逃逸出方法<code>vectorTest()</code>之外，所以JVM可以大胆地将<code>vector</code>内部的加锁操作消除。</p><h5>3.4 锁粗化</h5><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p><p>在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。</p><p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：<code>vector</code>每次add的时候都需要加锁操作，JVM检测到对同一个对象（<code>vector</code>）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到<code>for</code>循环之外。</p><h5>3.5 偏向锁</h5><p>在大多数情况下，锁不存在多线程竞争，总是由同一个线程多次获得。</p><blockquote><p>⭐⭐⭐核心的思想是：如果一个线程获得了锁，那么锁就会进入偏向模式，此时<code>Mark Word</code>的结构也变为偏向锁结构，当该结构再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查<code>Mark Word</code>的锁标记位位偏向锁以及当前线程ID等于<code>Mark Word</code>的<code>ThreadId</code>即可，这样省去了大量有关锁申请的操作。</p></blockquote><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换<code>ThreadID</code>的时候依赖一次<code>CAS</code>原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的<code>CAS</code>原子指令的性能消耗）。<strong>上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><p>它的思想可以理解为<code>CAS</code>，因此这种锁不适合于锁竞争比较激烈的多线程场合。</p><p>偏向锁的获取和释放：</p><blockquote><ul><li>访问 Mark Word 中偏向锁的标识位是否为1，如果是1，则确定为偏向锁。<ul><li>如果偏向锁的标识位为0，说明此时是处于无锁状态，则当前线程通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；并且将偏向标识位设为1。</li><li>如果偏向锁的标识位不为1，也不为0(此时偏向锁的标识位没有值)，说明发生了竞争，偏向锁已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁。</li></ul></li><li>如果是偏向锁，则判断 Mark Word 中的偏向线程ID是否指向当前线程，如果偏向线程ID指向当前线程，则表明当前线程已经获取到了锁；</li><li>如果偏向线程ID并未指向当前线程，则通过CAS操作尝试获取偏向锁，如果获取锁成功，则将 Mark Word 中的偏向线程ID设置为当前线程ID；</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时(在这个时间点上没有正在执行的字节码)，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>偏向锁的释放：<ul><li>当其它的线程尝试获取偏向锁时，持有偏向锁的线程才会释放偏向锁。</li><li>释放偏向锁需要等待全局安全点(在这个时间点上没有正在执行的字节码)。<ul><li>- 首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，</li><li>- 如果线程还活着，说明此时发生了竞争，则偏向锁升级为轻量级锁，然后刚刚被暂停的线程会继续往下执行同步代码。</li></ul></li></ul></li></ul></blockquote><h5>3.6 轻量级锁</h5><p>引入轻量级锁的主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p><p><strong>⭐轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><p>轻量级锁的加锁过程：</p><blockquote><p>1.当使用轻量级锁(锁标识位为00)时，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(注:锁记录中的标识字段称为Displaced Mark Word)。</p><p>2.将对象头中的MarkWord复制到栈桢中的锁记录中之后，虚拟机将尝试使用CAS将对象头中Mark Word替换为指向该线程虚拟机栈中锁记录的指针，此时如果没有线程占有锁或者没有线程竞争锁，则当前线程成功获取到锁，然后执行同步块中的代码。</p><p>3.如果在获取到锁的线程执行同步代码的过程中，另一个线程也完成了栈桢中锁记录的创建，并且已经将对象头中的MarkWord复制到了自己的锁记录中，然后尝试使用CAS将对象头中的MarkWord修改为指向自己的锁记录的指针，但是由于之前获取到锁的线程已经将对象头中的MarkWord修改过了(并且现在还在执行同步体中的代码,即仍然持有着锁)，所以此时对象头中的MarkWord与当前线程锁记录中MarkWord的值不同，导致CAS操作失败，然后该线程就会不停地循环使用CAS操作试图将对象头中的MarkWord替换为自己锁记录中MarkWord的值，(当循环次数或循环时间达到上限时停止循环)如果在循环结束之前CAS操作成功，那么该线程就可以成功获取到锁，如果循环结束之后依然获取不到锁，则锁获取失败，对象头中的MarkWord会被修改为指向重量级锁的指针，然后这个获取锁失败的线程就会被挂起，阻塞了。</p><p>4.当持有锁的那个线程执行完同步体之后，使用CAS操作将对象头中的MarkWord还原为最初的状态时(将对象头中指向锁记录的指针替换为Displaced Mark Word )，发现MarkWord已被修改为指向重量级锁的指针，因此CAS操作失败，该线程会释放锁并唤起阻塞等待的线程，开始新一轮夺锁之争，而此时，轻量级锁已经膨胀为重量级锁，所有竞争失败的线程都会阻塞，而不是自旋。</p></blockquote><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>试用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章了解了synchronized的基本使用方式之后，接下来我们来深入了解了解其底层原理，并且说明对它的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从卖票程序初步看synchronized的特性</title>
    <link href="http://yoursite.com/2019/02/10/thread/%E4%BB%8E%E5%8D%96%E7%A5%A8%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5%E7%9C%8Bsynchronized%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/02/10/thread/从卖票程序初步看synchronized的特性/</id>
    <published>2019-02-10T12:33:14.847Z</published>
    <updated>2019-02-10T12:33:34.622Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第五篇，在多线程学习和编程中，synchronized都是我们第一个要碰见的关键字，它很重要，因为它被认为还有优化的空间，并且它代表的是互斥锁的基本思想，JDK或者其他地方的源码随处可见，本文用一个卖票程序来切入synchronized的学习，从语法和使用上进行全面了解，并且对其引申出来的一些概念进行说明。</p><a id="more"></a><h2>1. 线程安全问题产生原因</h2><ul><li>存在共享数据</li><li>存在多条线程共同操作这些共享数据</li></ul><h2>2. 线程安全问题解决方法</h2><p>上面的问题归根结底是由于两个线程访问相同的资源造成的。对于并发编程，需要采取措施防止两个线程来访问相同的资源。</p><p>一种措施是当资源被一个线程访问时，为其加锁。第一个访问资源的线程必须锁定该资源，是其他任务在资源被解锁前不能访问该资源。</p><p>基本上所有的并发模式在解决线程安全问题时，都采用“序列化访问临界资源”的方案。即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。</p><p>这里来好好谈谈<code>Synchronized</code>实现加锁的方式。</p><h2>3. synchronized修饰符</h2><p><code>synchronized</code>：可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”.</p><p><code>synchronized</code>满足了以下重要特性：</p><ul><li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块进行访问，互斥性也称为操作的原子性。</li><li>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致</li></ul><p>⭐<code>synchronized</code>锁的不是代码，是对象！</p><h5>3.1 不使用synchronized会出现线程不安全问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sellTicket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SellTicket sellTicket = <span class="keyword">new</span> SellTicket();</span><br><span class="line"><span class="comment">//同时开启五个线程去卖票</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某一次运行的结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread2,还剩2</span><br><span class="line">thread1,还剩2</span><br><span class="line">thread3,还剩2</span><br><span class="line">thread4,还剩0</span><br><span class="line">thread5,还剩0</span><br></pre></td></tr></table></figure><p>很显然，多个线程之间打架了，数据混乱了。这是因为，多个线程同时操作<code>run（）</code>方法，对<code>count</code>进行修改，进而造成错误。</p><h5>3.2 使用synchronized来加锁</h5><p>对卖票的核心方法上加上<code>synchronized</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者写成同步代码块的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果只有一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1 count:4</span><br><span class="line">thread4 count:3</span><br><span class="line">thread5 count:2</span><br><span class="line">thread3 count:1</span><br><span class="line">thread2 count:0</span><br></pre></td></tr></table></figure><p>结果是正确的，可以看出代码A和代码B的区别就是在<code>sellTicket()</code>方法上加上了<code>synchronized</code>修饰。</p><p><strong>说明</strong>：当多个线程访问<code>MyThread</code> 的<code>run</code>方法的时候，如果使用了<code>synchronized</code>修饰，那个多线程就会以排队的方式进行处理（这里排队是按照CPU分配的先后顺序而定的），一个线程想要执行<code>synchronized</code>修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行<code>synchronized</code>代码体的内容，如果拿不到锁的话，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且多个线程同时去竞争这把锁，也就是会出现锁竞争的问题。</p><h5>3.3 一个对象有一把锁！不同对象不同锁！</h5><p>每次开启一个线程就new一个对象的话，即对每个不同的对象加锁，则互不干扰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程任务<code>SellTicket()</code>无论给不给<code>sellTicket()</code>加锁，结果都是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1,还剩4</span><br><span class="line">thread2,还剩4</span><br><span class="line">thread3,还剩4</span><br><span class="line">thread5,还剩4</span><br><span class="line">thread4,还剩4</span><br></pre></td></tr></table></figure><p>这是因为我这里是五个不同的对象，每个对象各自获取自己的锁，互不影响，所以都是4.</p><p>关键字<code>synchronized</code>取得的锁都是对象锁，而不是把一段代码或方法当做锁，所以上述实例代码C中哪个线程先执行<code>synchronized</code> 关键字的方法，那个线程就持有该方法所属对象的锁，五个对象，线程获得的就是两个不同对象的不同的锁，他们互不影响的。</p><p>那么，我们在正常的场景的时候，肯定是有一种情况的就是，一个类<code>new</code>出来的所有对象会对一个变量<code>count</code>进行操作，那么如何实现哪？很简单就是加<code>static</code>，我们知道，用<code>static</code>修改的方法或者变量，在该类的所有对象是具有相同的引用的，这样的话，无论实例化多少对象，调用的都是一个方法。</p><p><code>Main</code>函数不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SellTicket</code>则在卖票方法上增加<code>static</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sellTicket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者显示地锁住<code>Class</code>对象，即锁住类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1,还剩4</span><br><span class="line">thread2,还剩3</span><br><span class="line">thread4,还剩2</span><br><span class="line">thread3,还剩1</span><br><span class="line">thread5,还剩0</span><br></pre></td></tr></table></figure><p>仔细看，我们给<code>sellTicket</code>设定为<code>static</code>静态方法，那么这个方法就从之前的对象方法上升到类级别方法，这个类所有的对象都调用的同一个方法。实现资源的共享和加锁。</p><p>上面讲的时对象锁和类锁，前者锁定的是某个实例对象，后者锁定的是Class对象。下面总结一下：</p><ul><li>有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块</li><li>若锁住的时同一个对象，一个线程在访问对象的同步代码块(同步方法)时，另一个访问对象的同步代码块(同步方法)的线程会被阻塞</li><li>同一个类的不同对象的对象锁互不干扰</li><li>类锁由于也是一种特殊的对象锁，因此表现与上述一致，只是由于一个类只有一把类锁，所以同一个类的不同对象使用类锁是同步的</li><li>类锁和对象锁互不干扰</li></ul><h2>4. Synchronized锁重入</h2><h5>4.1 什么是可重入锁</h5><p>锁的概念就不用多解释了,当某个线程A已经持有了一个锁,当线程B尝试进入被这个锁保护的代码段的时候.就会被阻塞.</p><p><strong>⭐而锁的操作粒度是&quot;线程”,而不是调用.同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁,这就是可重入锁。</strong></p><h5>4.2 可重入锁的小例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDubbo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method1..."</span>);</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method2..."</span>);</span><br><span class="line">method3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method3..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SyncDubbo syncDubbo = <span class="keyword">new</span> SyncDubbo();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">syncDubbo.method1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码向我们演示了，如何在一个已经被<code>synchronized</code>关键字修饰过的方法再去调用对象中其他被<code>synchronized</code>修饰的方法。</p><h5>4.3 为什么要可重入</h5><p>我们上一篇文章中介绍了“一个对象一把锁，多个对象多把锁”，可重入锁的概念就是：<strong>自己可以获取自己的内部锁</strong>。</p><p><strong>假如有1个线程T获得了对象A的锁，那么该线程T如果在未释放前再次请求该对象的锁时</strong>，如果没有可重入锁的机制，是不会获取到锁的，这样的话就会出现死锁的情况。</p><p>就如代码A体现的那样，线程T在执行到<code>method1（）</code>内部的时候，由于该线程已经获取了该对象<code>syncDubbo</code> 的对象锁，当执行到调用<code>method2（）</code> 的时候，会再次请求该对象的对象锁，如果没有可重入锁机制的话，由于该线程T还未释放在刚进入<code>method1（）</code> 时获取的对象锁，当执行到调用<code>method2（）</code> 的时候，就会出现死锁。</p><h5>4.4 可重入锁到底有什么用哪？</h5><p>正如上述代码A和（4.3）中解释那样，最大的作用是避免死锁。假如有一个场景：用户名和密码保存在本地txt文件中，则登录验证方法和更新密码方法都应该被加<code>synchronized</code>，那么当更新密码的时候需要验证密码的合法性，所以需要调用验证方法，此时是可以调用的。</p><h5>4.5  什么是死锁？</h5><p>线程A当前持有互斥所锁<code>lock1</code>，线程B当前持有互斥锁<code>lock2</code>。接下来，当线程A仍然持有<code>lock1</code>时，它试图获取<code>lock2</code>，因为线程B正持有<code>lock2</code>，因此线程A会阻塞等待线程B对<code>lock2</code>的释放。如果此时线程B在持有<code>lock2</code>的时候，也在试图获取<code>lock1</code>，因为线程A正持有<code>lock1</code>，因此线程B会阻塞等待A对<code>lock1</code>的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p><p>一个例子来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">System.out.println(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">System.out.println(<span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">DeadLock d = <span class="keyword">new</span> DeadLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">d.a();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">d.b();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>产生死锁的原因主要是：</strong></p><ul><li>（1） 因为系统资源不足。</li><li>（2） 进程运行推进的顺序不合适。</li><li>（3） 资源分配不当等。</li></ul><p><strong>如何解决死锁：</strong></p><p>一般地，解决死锁的方法分为死锁的预防，避免，检测与恢复三种（注意：死锁的检测与恢复是一个方法）</p><p><strong>死锁的预防</strong>是保证系统不进入死锁状态的一种策略。它的基本思想是要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。</p><p><strong>死锁的避免</strong>，它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。就是说，在资源分配过程中若预测有发生死锁的可能性，则加以避免。这种方法的关键是确定资源分配的安全性。</p><p><strong>死锁的检测与恢复</strong>，一般来说，由于操作系统有并发，共享以及随机性等特点，通过预防和避免的手段达到排除死锁的目的是很困难的。这需要较大的系统开销，而且不能充分利用资源。为此，一种简便的方法是系统为进程分配资源时，不采取任何限制性措施，但是提供了检测和解脱死锁的手段：能发现死锁并从死锁状态中恢复出来。因此，在实际的操作系统中往往采用死锁的检测与恢复方法来排除死锁。死锁检测与恢复是指系统设有专门的机构，当死锁发生时，该机构能够检测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来。</p><blockquote><p>（1）最简单，最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程。</p><p>（2）撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素。</p></blockquote><h5>4.6 可重入锁支持在父子类继承的环境中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">super</span>.doSomething();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行子类的方法的时候,先获取了一次<code>Widget</code>的锁,然后在执行<code>super</code>的时候,就要获取一次,如果不可重入,那么就跪了.</p><p>在这里，可能会产生疑问：</p><blockquote><p>重入”代表一个线程可以再次获得同一个对象的锁。可是你给出的代码示例中，我理解的是一个线程调用<code>Child</code>的<code>doSomething</code>方法前或得了<code>Child</code>对象的锁，<code>super.doSomething</code>方法调用时，次线程获得了<code>Child</code>对象父对象的锁。两个锁属于不同的对象，这还算是重入吗？</p></blockquote><p>解释：当<code>Child</code>实例对象调用<code>doSomething</code>方法时，此时持有的是<code>Child</code>实例对象的锁，之后调用<code>super.doSomething();</code>，这时仍然对于<code>Child</code>实例对象加锁，因为此时仍然使用的是<code>Child</code>实例对象内存空间的数据。</p><p>至于这句话的理解，就牵涉到继承的机制：</p><blockquote><p>在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。</p></blockquote><p>之所以网上有很多说只继承<code>protected</code>或者<code>private</code>的，是因为从语言的角度出发的：</p><p><img src="https://uploadfiles.nowcoder.net/images/20171019/1829253_1508380548300_1372D420D0F13C1126C6FCB3DC35A515" alt="image"></p><p>从内存的角度来看，的确是继承了的，可以写一个简单的继承类，debug看子类的属性是否存在父类的private属性，事实证明是有的。</p><p>针对这里有人说：不是创建一个父类对象，而只是创建一个父类空间并进行相应的初始化。对此，我一开始也是这么想的，不过当我看到这个答案的时候，又觉得很有道理：</p><blockquote><p>会创建父类对象。《Java编程思想》（第四版）129页，当创建一个导出类对象时，该对象包含了一个基类的子对象，这子对象与你用基类直接创建的对象是一样的，二者区别在于后者来源于外部，而基类的子对象被包装在导出类对象内部。</p></blockquote><h2>5. 发生异常时会自动释放锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" , i= "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                Integer.parseInt(<span class="string">"a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SyncException se = <span class="keyword">new</span> SyncException();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                se.operation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t1 , i= 2</span><br><span class="line">t1 , i= 3</span><br><span class="line">t1 , i= 4</span><br><span class="line">t1 , i= 5</span><br><span class="line">t1 , i= 6</span><br><span class="line">t1 , i= 7</span><br><span class="line">t1 , i= 8</span><br><span class="line">t1 , i= 9</span><br><span class="line">t1 , i= 10</span><br><span class="line">java.lang.NumberFormatException: For input string: &quot;a&quot;</span><br><span class="line">    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">    //其他输出信息</span><br></pre></td></tr></table></figure><p>关于<code>synchronized</code>的优化放到后文去讲。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第五篇，在多线程学习和编程中，synchronized都是我们第一个要碰见的关键字，它很重要，因为它被认为还有优化的空间，并且它代表的是互斥锁的基本思想，JDK或者其他地方的源码随处可见，本文用一个卖票程序来切入synchronized的学习，从语法和使用上进行全面了解，并且对其引申出来的一些概念进行说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程重要的相关方法</title>
    <link href="http://yoursite.com/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/10/thread/线程重要的相关方法/</id>
    <published>2019-02-10T09:41:16.298Z</published>
    <updated>2019-02-10T09:41:44.654Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第四篇，本篇文章主要来看看线程相关的几个重要方法。</p><a id="more"></a><h2>wait和sleep</h2><p>他们最基本的差异是：</p><ul><li><code>wait</code>是<code>Object</code>的一个方法，<code>sleep</code>是<code>Thread</code>类的方法</li><li><code>sleep</code>可以在任何地方使用，但是<code>wait</code>方法只能在<code>synchronied</code>方法或<code>synchronied</code>块中使用</li></ul><p>本质的区别是：</p><ul><li><code>Thread.sleep</code>只会让出CPu，不会导致锁行为的改变</li><li><code>Object.wait</code>不仅让出CPU，还会释放已经占用的同步资源锁</li></ul><p>这个区别也就解释了为什么<code>wait</code>方法只能在<code>synchronied</code>方法或<code>synchronied</code>块中使用，因为没有获取过锁哪里来的释放锁呢？所以释放锁的前提是要获取锁。</p><p>下面来验证一下，眼见为实！</p><p><img src="http://bloghello.oursnail.cn/thread4-1.jpg" alt="image"></p><p>对于<code>sleep</code>来说是没有锁的要求的，既不用获取锁也不用释放锁，关于这一点就不再验证了。</p><h2>notify和notifyAll</h2><p>先来了解一下锁池和等待池的概念。</p><ul><li>锁池EntryLisy</li></ul><blockquote><p>假设线程A已经拥有了某个对象(不是类)的锁，而其他线程B、C想要调用这个对象的某个synchronized方法或块，由于B、C线程在进入对象的synchronized方法或块之前必须先获得该对象锁得拥有权，而恰巧该对象的锁正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待所得释放，这个地方就是该对象得锁池。</p></blockquote><ul><li>等待池WaitSet</li></ul><blockquote><p>假设线程A调用了某个对象的wait方法后，线程A就会释放该对象得锁，同时线程A句进入到该对象得等待池中，进入到等待池中得线程不会去竞争该对象的锁。</p></blockquote><p><code>notify</code>的作用就是<strong>随机</strong>唤醒<strong>一个</strong>线程进入等待池的线程，而<code>notifyAll</code>是唤醒所有处于等待池中线程，唤醒之后就可以再去竞争获得锁的机会了。</p><p>刚才的例子稍微改造一下，来了解一下<code>notify</code>的作用。还拿刚才那个例子：</p><p><img src="http://bloghello.oursnail.cn/thread4-2.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/thread4-3.jpg" alt="image"></p><h2>yield</h2><p><img src="http://bloghello.oursnail.cn/thread4-4.jpg" alt="image"></p><p>当调用<code>Thread.yield()</code>函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。并且它也不会释放当前线程占用的锁。</p><p><code>yield()</code>与无参的<code>wait()</code>的区别：</p><ul><li>执行<code>yield()</code>后，当前线程由运行状态变为就绪状态。执行<code>wait</code>后，当前线程会失去对象的锁，状态变为<code>WAITING</code>状态。</li><li>执行<code>yield()</code>后，当前线程不会释放锁。执行<code>wait</code>后，当前线程会释放锁。</li></ul><p>比较简单，就不举例了。</p><h2>interrupt</h2><p>它只是通知线程应该中断了。</p><ul><li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个<code>interruptedException</code>异常</li><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><p>也就是说，中断一个线程是由被调用的线程状态和自己程序判断决定的。</p><ul><li>阻塞状态下，线程会立即退出，并抛出异常</li><li>正常状态下，需要被调用的线程检查中断标志位，然后再根据中断标志位自行地停止线程</li></ul><p>下面写一个demo来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable interruptTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程</span></span><br><span class="line">                    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                        i++;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" ("</span> + Thread.currentThread().getState() + <span class="string">") loop "</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ("</span> + Thread.currentThread().getState() + <span class="string">") catch InterruptedException."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(interruptTask, <span class="string">"t1"</span>);</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is new."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.启动“线程t1”</span></span><br><span class="line">        t1.start();                      </span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.主线程休眠300ms，然后主线程给t1发“中断”指令。</span></span><br><span class="line">        Thread.sleep(<span class="number">400</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.主线程休眠300ms，然后查看t1的状态。</span></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted now."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 (NEW) is new.</span><br><span class="line">t1 (RUNNABLE) is started.</span><br><span class="line">t1 (RUNNABLE) loop 1</span><br><span class="line">t1 (RUNNABLE) loop 2</span><br><span class="line">t1 (RUNNABLE) loop 3</span><br><span class="line">t1 (TIMED_WAITING) is interrupted.</span><br><span class="line">t1 (RUNNABLE) catch InterruptedException.</span><br><span class="line">t1 (TERMINATED) is interrupted now.</span><br></pre></td></tr></table></figure><p>首先，是就绪状态，为<code>new</code>；接下来启动这个线程，状态变为<code>started</code>，由于此时一切安好，没有“打扰”这个线程的执行，所以每隔100毫秒打印一句<code>(RUNNABLE) loop i</code>出来；在400毫秒的安好之后，给他一个<code>t1.interrupt();</code>，此时线程可能恰好在执行<code>sleep</code>睡觉呢，这个<code>interrupt</code>一看你在阻塞(睡觉)，那还得了，立马停止这个线程并且抛出异常。</p><p>但是话说回头，本程序还用了if判断，只要标志位为<code>false</code>就不停循环，一旦标志位变为<code>true</code>则立马退出循环。所以即使你不睡觉，但是我还是能通过这个If来终止你的循环。</p><h2>join</h2><p><code>join</code>是加入的意思，非常形象生动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die.</span></span><br><span class="line"><span class="comment"> * 调用方线程（调用join方法的线程）执行等待操作，</span></span><br><span class="line"><span class="comment"> * 直到被调用的线程（join方法所属的线程）结束，再被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现如下：</p><p><img src="http://bloghello.oursnail.cn/thread4-5.jpg" alt="image"></p><p>我们知道<code>wait</code>是需要释放当前线程所占的对象锁的，而<code>join</code>基于<code>wait</code>实现，显然是可以的。</p><p>这里判断如果线程还在运行中的话，则继续等待，如果指定时间到了，或者线程运行完成了，则代码继续向下执行，调用线程就可以执行后面的逻辑了。</p><p>但是在这里没有看到哪里调用<code>notify</code>或者<code>notifyAll</code>方法，如果没有调用的话，那调用方线程会一直等待下去，那是哪里调用了唤醒它的方法呢？通过查证得知，原来在线程结束时，java虚拟机会执行该线程的本地<code>exit</code>方法，这个<code>exit</code>方法里面会调用<code>notifyAll</code>方法，唤醒所有等待的线程。</p><p>下面来两个例子来彻底理解它的用法。</p><p>例子一：有耐心的男孩：</p><p><img src="http://bloghello.oursnail.cn/thread4-6.jpg" alt="image"></p><blockquote><p>男孩和女孩准备出去逛街</p><p>女孩开始化妆,男孩在等待。。。</p><p>女孩化妆完成！，耗时5000</p><p>男孩和女孩开始去逛街了</p></blockquote><p>就是男孩和女孩准备去逛街，女孩要化妆先，等女孩化妆完成了，再一起去逛街。</p><p>例子二：没有耐心的男孩：</p><p><img src="http://bloghello.oursnail.cn/thread4-7.jpg" alt="image"></p><blockquote><p>男孩和女孩准备出去逛街</p><p>女孩开始化妆,男孩在等待。。。</p><p>男孩等了2000, 不想再等了，去逛街了</p><p>女孩化妆完成！，耗时5000</p></blockquote><p>男孩等了<code>join(time)</code>中的<code>time</code>时间，如果这个<code>time</code>时间到达之后，女孩所在的线程还没执行完，则不等待了，继续执行后面的逻辑，就是不等女孩了，自己去逛街。</p><h2>总结</h2><p>了解了这些核心方法之后，就可以对下面这幅图简单说一说啦：</p><p><img src="http://bloghello.oursnail.cn/thread2-9.jpg" alt="image"></p><p>首先是<code>new Thread()</code>只是新建状态，只有<code>start</code>之后才会进入<code>runnable</code>状态，注意这个状态里面可能有两种状态，一种是正在运行，即<code>running</code>，还有一种是就绪状态即<code>ready</code>，这两个状态归属于一类的原因是他们之间是在不断切换的，即CPU的时间片内临幸到这个进程，这个进程中有若干个线程的话，就会高速地切换各个线程逐个执行，达到宏观上是并行执行的效果。我们知道<code>yield</code>是给线程调度器一个暗示让出当前执行的线程的时间片，至于这个线程调度器听不听那就不知道了，所以存在一定的随机性。如果正常执行结束就进入最后的终止状态。往右边看，如果发生带时间的超时等待，如<code>sleep(100)</code>，本线程会阻塞，让出CPU执行权并且不改变锁状态，与之区别的是<code>wait(100)</code>这个方法不仅让出CPU执行权，还会释放锁，所以要调用<code>wait</code>方法必然要先获取锁，所以一般都是在<code>synchronized</code>中调用它。至于<code>join(100)</code>是指阻塞当前线程，让其他的线程先执行，底层是<code>wait</code>所以也会释放锁。超时等待只要等它时间过了就可以跳出阻塞状态了，或者用<code>notify</code>或者<code>interrupt</code>之类的来唤醒或者打断它。往左下角看，是锁获取的时候可能发生阻塞，这个时候只能等其他线程释放锁才行了。往左边看，是无限期等待的代表，唤醒手段与有限期等待是一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第四篇，本篇文章主要来看看线程相关的几个重要方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程的状态</title>
    <link href="http://yoursite.com/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/02/10/thread/线程的状态/</id>
    <published>2019-02-10T07:36:13.461Z</published>
    <updated>2019-02-10T07:36:38.852Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第三篇，主要介绍一下线程的几个状态的含义。</p><a id="more"></a><p><code>Thread</code>类源码中规定了几种线程的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实源码中已经详细说明了这几种状态的含义以及发生的时机。下面还是再看看：</p><ul><li>新建(<code>new</code>)：创建后尚未启动的线程的状态</li><li>运行(<code>Runnable</code>)：包含<code>Running</code>和<code>Ready</code>两种状态</li><li>无限期等待(<code>Waiting</code>)：不会被分配CPU执行时间，需要显式被唤醒<ul><li>无<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>无<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.park()</code>方法</li></ul></li><li>限期等待(<code>Timed Waiting</code>)：不会被分配CPU执行时间，在一定时间后会由系统自动唤醒<ul><li><code>Thread.sleep()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.parkNanos()</code>方法</li><li><code>LockSupport.parkUntil()</code>方法</li></ul></li><li>阻塞(<code>Blocked</code>)：等待获取排他锁</li><li>结束(<code>Terminated</code>)：已终止线程的状态，线程已经结束执行</li></ul><p>既然有这么多线程状态，那么必然会存在状态的转换，他们的状态是如何转换的呢？下面这张图就是比较全面的状态转换图：</p><p><img src="http://bloghello.oursnail.cn/thread2-9.jpg" alt="image"></p><p>初学者看到这张图一张是比较晕的，各种乱七八糟的东西堆在这里实在是难以下咽，不过一开始不能完全看懂是很正常的，需要进一步地学习一些细节，不断地来回顾，总有一天就会真正理解了。</p><p>下面就是要详细说说<code>Thread</code>类里面的一些方法啦，理解了这些方法，状态的切换图便一目了然。为了限制篇幅，本文先说到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第三篇，主要介绍一下线程的几个状态的含义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程之传参和返回值处理</title>
    <link href="http://yoursite.com/2019/02/10/thread/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/10/thread/java多线程之传参和返回值处理/</id>
    <published>2019-02-10T06:36:37.569Z</published>
    <updated>2019-02-10T06:44:10.066Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第二篇，对于传参和返回值的问题，是面试中关于多线程这一块问得比较多的问题了，这里进行详细的说明。</p><a id="more"></a><h2>一、如何给run()方法传参</h2><p>我们知道多线程是通过<code>star()</code>方法让线程处于准备就绪状态，而实际运行的业务逻辑是放在<code>run()</code>方法体中的，但是<code>run()</code>方法是没有参数的方法，实际的业务场景中，我们可能需要向方法体中传递参数，实现的方式主要有三种：</p><ul><li>构造函数传参，这个在上一篇文章中已经演示了。</li><li>成员变量传参，这个就是依靠<code>set</code>方法。</li><li>回调函数传参，这个稍微特殊一点。这里说明一下。</li></ul><p>上面的两种向线程中传递数据的方法是最常用的。但这两种方法都是<code>main</code>方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。</p><p>然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的<code>run</code>方法中产生了3个随机数，然后通过<code>Work</code>类的<code>process</code>方法求这三个随机数的和，并通过<code>Data</code>类的<code>value</code>将结果返回。从这个例子可以看出，在返回<code>value</code>之前，必须要得到三个随机数。也就是说，这个 <code>value</code>是无法事先就传入线程类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span>  value =  <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Work</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">process</span><span class="params">(Data data, Integer[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>  ( <span class="keyword">int</span>  n : numbers) &#123;</span><br><span class="line">            data.value += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">MyThread3</span>  <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Work work;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">MyThread3</span><span class="params">(Work work)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span> .work = work;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.随机生成3个数放进数组中</span></span><br><span class="line">        java.util.Random random =  <span class="keyword">new</span>  java.util.Random();</span><br><span class="line">        Data data =  <span class="keyword">new</span>  Data();</span><br><span class="line">        <span class="keyword">int</span>  n1 = random.nextInt( <span class="number">1000</span> );</span><br><span class="line">        <span class="keyword">int</span>  n2 = random.nextInt( <span class="number">2000</span> );</span><br><span class="line">        <span class="keyword">int</span>  n3 = random.nextInt( <span class="number">3000</span> );</span><br><span class="line">        Integer[] numbers = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">        numbers[<span class="number">0</span>] = n1;</span><br><span class="line">        numbers[<span class="number">1</span>] = n2;</span><br><span class="line">        numbers[<span class="number">2</span>] = n3;</span><br><span class="line">        <span class="comment">//调用函数去计算这三个数之和，计算的结果存在Data实例中的value属性中</span></span><br><span class="line">        <span class="comment">//这里process相当于回调函数，我调用这个函数，给我一个计算结果</span></span><br><span class="line">        work.process(data, numbers);    </span><br><span class="line">        System.out.println(String.valueOf(n1) +  <span class="string">"+"</span>  + String.valueOf(n2) +  <span class="string">"+"</span></span><br><span class="line">                + String.valueOf(n3) +  <span class="string">"="</span>  + data.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t =  <span class="keyword">new</span>  MyThread3( <span class="keyword">new</span>  Work());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一次的执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">707+678+173=1558</span><br></pre></td></tr></table></figure><p>在上面代码中的<code>process</code>方法被称为回调函数。从本质上说，回调函数就是事件函数。在<code>Windows API</code>中常使用回调函数和调用API的程序之间进行数据交互。因此，调用回调函数的过程就是最原始的引发事件的过程。在这个例子中调用了<code>process</code>方法来获得数据也就相当于在<code>run</code>方法中引发了一个事件。</p><h2>二、如何处理线程返回值</h2><p>由于线程相当于一个异步的处理函数，想要获取它的结果就不能像传统的获取它的<code>return</code>的值那么简单了，主要问题就在于它什么时候能处理好是不知道的，需要一定的机制去等待它处理好了再去获取它的处理结果。方式一般有三种。</p><h5>2.1 主线程等待法</h5><p>这个方法是最简单也是最容易想到的处理方式。下面搞个实例来看看大概是如何操作的。</p><p>首先写一个类，写这个的含义是，假如主线程不等待，将会一口气执行到最后一行，此时子线程可能还没执行完。就会出现打印空。</p><p><img src="http://bloghello.oursnail.cn/thread2-1.jpg" alt="image"></p><p>那么我们的主线程如何获取到子线程中赋予的值呢？一种方式就是死等，不停地轮询看你的值是否已经计算好了，一旦计算好就可以拿到这个值。类似于以下：</p><p><img src="http://bloghello.oursnail.cn/thread2-2.jpg" alt="image"></p><p>其实这就是自旋，即CPU停在这里等待，不能干其他事情，这必然会大大浪费CPU资源，所以虽然这种方式实现起来非常简单，但是不适合用。另外的缺点就是代码臃肿，比如我要等待的值不止一个，有多个，那是不是要写多个while循环来等待呢？此外，我们大多时候根本不知道这个子线程到底要执行多久，因为我们这里是每隔100毫秒轮询一次，那假如这个值在这100毫秒内值已经有了，那么是不能立即获取的。</p><p>针对以上不能精准控制的缺点，这里便有了第二种方法。</p><h2>Join方法</h2><p><code>Thread</code>类中的<code>join</code>方法可以阻塞当前线程以等待子线程处理完毕。</p><p><img src="http://bloghello.oursnail.cn/thread2-3.jpg" alt="image"></p><p>在这里，由于是在主线程中调用的<code>join</code>，所以阻塞主线程，让子线程执行完毕再继续执行。</p><p>这种方法更简单，但是存在多个子线程的情况下，做到灵活以及精准控制是做不到的。</p><h2>Callable接口实现</h2><p>JAVA提供了有返回值的任务，即实现了<code>Callable</code>接口的任务，执行这个任务之后可以获取一个叫做<code>Futrue</code>的对象，通过<code>get()</code>就可以获取<code>Callable</code>任务返回的内容。</p><p>具体是如何获取返回的内容呢？有两种方式，一个是通过<code>FutureTask</code>这个类来获取，一个是通过线程池获取。</p><p>对于第一种方式，我们通过例子来理解。</p><p>先新建一个实现了<code>Callable</code>接口的任务：</p><p><img src="http://bloghello.oursnail.cn/thread2-5.jpg" alt="image"></p><p>把<code>Callable</code>任务放进<code>FutureTask</code>中，这个<code>FutureTask</code>再放进<code>Thread</code>中去执行：</p><p><img src="http://bloghello.oursnail.cn/thread2-4.jpg" alt="image"></p><p>发现我们的程序并没有显示地等待，<code>FutureTask</code>的<code>get()</code>方法完成了等待和获取返回值。下面来看看<code>Future</code>的继承关系：</p><p><img src="http://bloghello.oursnail.cn/thread2-6.jpg" alt="image"></p><p>我们发现，<code>FutureTask</code>实质上都是<code>Runnable</code>接口的实例，只是它还是<code>Futrue</code>接口的实例，所以不仅可以作为一个线程任务被执行，还可以接受一个<code>Callable</code>接口去接受它的返回值。因此是一个升级版的<code>Runnable</code>实例。</p><p>说完了<code>FutureTask</code>的实现方式，下面再来看看另一种方式，即线程池来实现。关于线程池，后文还会详细介绍，这里只是简单先运用一下。</p><p><img src="http://bloghello.oursnail.cn/thread2-7.jpg" alt="image"></p><p>达到了一样的效果。我们来分析分析。</p><p><img src="http://bloghello.oursnail.cn/thread2-8.jpg" alt="image"></p><p>我们发现，其实两种方式的根本就是<code>Future</code>这个接口，第一种是直接用了<code>FutureTask</code>这个类来手动实现，即不仅需要它接收一个<code>Callable</code>任务，还需要将其作为一个线程任务去手动执行。而第二种方式就比较简单了，有了线程池，我直接把<code>Callable</code>任务扔线程池去<code>submit</code>，就可以得到一个可以获取返回值的<code>Future</code>类型对象，就可以根据这个对象获取到值了。</p><p>所以两种方式本质上是一样一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第二篇，对于传参和返回值的问题，是面试中关于多线程这一块问得比较多的问题了，这里进行详细的说明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程基本知识梳理</title>
    <link href="http://yoursite.com/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/10/thread/线程基本知识梳理/</id>
    <published>2019-02-10T04:15:17.009Z</published>
    <updated>2019-02-10T04:33:58.796Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第一篇，主要说明基本概念，这是面试中最基本的要会的东西，如果这些都回答不了，基本上就没有机会了，本文从源码稍微深入一点去探讨常见的基本概念。本文并不会从最最最最基本的知识开始说起，将不费笔墨直击要害，所以需要一点多线程的基本知识才行，这也符合本博客的宗旨，即知识点再次提炼和升级。</p><a id="more"></a><h2>一、进程和线程的区别</h2><p>这一块详见 <a href="http://fourcolor.oursnail.cn/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">面试-进程与线程</a> 里面的内容，相信已经够用了。</p><h2>二、start()和run()方法的区别</h2><p>以一个小例子入手，在主函数中尝试新建一个线程，并且以<code>t.run()</code>的形式去调用，从结果可以看出，java默认开启主线程来执行，当我们用<code>t.run()</code>去执行的时候，只是相当于简单的函数调用，因为从打印结果可以看出都是<code>main</code>进程，那么，实质上并没有新建一个子线程。</p><p><img src="http://bloghello.oursnail.cn/thread1-1.jpg" alt="image"></p><p>（注意，不是一调用就会去执行，而是说这个线程处于就绪状态，将有资格获得CPU的临幸，关于线程状态，后文会再次详细说明，关于start之后处于就绪状态这一点默认读者是清楚的，下面表述可能不会太顾及说明这一点）：</p><p><img src="http://bloghello.oursnail.cn/thread1-2.jpg" alt="image"></p><p>那么，从表象上我们已经知道，<code>run</code>只是简单的函数调用，<code>start</code>才会真正地开启一个新线程来执行，下面从源码层面来看看<code>start()</code>的基本实现方式。</p><p><img src="http://bloghello.oursnail.cn/thread1-3.jpg" alt="image"></p><p>说明一下，本源码是基于JDK1.8，我们看到它的核心实现是一个<code>native</code>方法，IDEA上已经看不了，只好去看看<code>openJDK</code>了。</p><p>直接打开网址： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/f0b93fbd8cf8/src/share/native/java/lang/Thread.c" target="_blank" rel="noopener">Thread.c</a>  我们可以看到：</p><p><img src="http://bloghello.oursnail.cn/thread1-4.jpg" alt="image"></p><p>我们看到很多关于线程的方法，但是这里是看不到具体的实现的，我们看到上面引入了<code>jvm.h</code>的库，所以实现应该是在<code>jvm</code>相关的代码中，直接点开： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/76a9c9cf14f1/src/share/vm/prims/jvm.cpp" target="_blank" rel="noopener">jvm.cpp</a>  可以看到如下：</p><p><img src="http://bloghello.oursnail.cn/thread1-5.jpg" alt="image"></p><p>emmm，虽然不大看得懂，但是我们确实看到了<code>start()</code>会调用虚拟机去创建一个新的线程，最终再去调用<code>run</code>方法去执行。所以流程如下：</p><p><img src="http://bloghello.oursnail.cn/thread1-6.jpg" alt="image"></p><p>最终总结：</p><ul><li>调用<code>start()</code>方法会创建一个新的子线程并启动</li><li><code>run()</code>方法只是<code>thread</code>的一个普通方法的调用</li></ul><h2>三、Thread和Runnable是什么关系</h2><p>还是老规矩，先来翻翻源码：</p><p>我们可以看到，<code>Thread</code>是一个<code>class</code>，而<code>Runnable</code>是一个<code>interface</code>，而<code>Runnable</code>中只有一个抽象方法就是<code>run()</code>.</p><p><img src="http://bloghello.oursnail.cn/thread1-7.jpg" alt="image"></p><p>那么，我们上面说到，新建一个线程是要靠<code>start()</code>来实现的，那么<code>Runnable</code>是如何来新建一个线程呢？它不是只有一个<code>run()</code>方法吗？</p><p>此时再来看<code>Thread</code>类，它里面有大量的方法，就包含了<code>run()</code>和<code>start()</code>方法，它还有一个重要的构造函数为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>就是说，传入<code>Runable</code>接口实例，再调用<code>Thread</code>的<code>start()</code>方法创建子线程，再来调用重写的<code>run()</code>方法就可以了。下面举个例子。</p><p>先说说用<code>Thread</code>的方式来创建一个子线程类：</p><p><img src="http://bloghello.oursnail.cn/thread1-8.jpg" alt="image"></p><p>这也从侧面证明了，线程是交替执行的，但是因为属于同一个进程，共享同一个地址和资源，所以不需要进行切换，极大提高了CPU执行效率。</p><p>下面再来看看<code>Runnable</code>接口是怎么实现多线程的：</p><p><img src="http://bloghello.oursnail.cn/thread1-9.jpg" alt="image"></p><p>总结一下他们俩：</p><ul><li><code>Thread</code>是一个类，<code>Runnable</code>是一个接口，前者实现后者</li><li><code>Thread</code>有<code>start</code>方法，结合<code>run()</code>可以实现多线程，但是<code>Runnable</code>没有<code>start()</code>方法，所以要通过<code>Thread()</code>来实现，所以，两种方式最终都是通过<code>Thread</code>的<code>start()</code>来实现<code>run()</code>的多线程特性</li><li>由于JAVA是单一继承的，所以推荐多使用<code>Runnable</code>接口</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于JAVA多线程和并发的第一篇，主要说明基本概念，这是面试中最基本的要会的东西，如果这些都回答不了，基本上就没有机会了，本文从源码稍微深入一点去探讨常见的基本概念。本文并不会从最最最最基本的知识开始说起，将不费笔墨直击要害，所以需要一点多线程的基本知识才行，这也符合本博客的宗旨，即知识点再次提炼和升级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="http://yoursite.com/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>实例说明类加载过程</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/09/JVM/实例说明类加载过程/</id>
    <published>2019-02-09T14:26:55.574Z</published>
    <updated>2019-02-09T14:36:42.417Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十三篇文章，本文从一个简单程序入手，将前面所学串联起来，详细来看看类加载的过程到底是什么样子的。</p><a id="more"></a><h2>零、Java虚拟机启动、加载类过程分析</h2><p>下面我将定义一个非常简单的java程序并运行它，来逐步分析java虚拟机启动的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.luanlouis.jvm.load;  </span><br><span class="line"><span class="keyword">import</span> sun.security.pkcs11.P11Util;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Hello,World!"</span>);  </span><br><span class="line">  </span><br><span class="line">        ClassLoader loader = P11Util.class.getClassLoader();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(loader);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>windows</code>命令行下输入： <code>java org.luanlouis.jvm.load.Main</code></p><p>当输入上述的命令时： <code>windows</code>开始运行<code>{JRE_HOME}/bin/java.exe</code>程序，<code>java.exe</code> 程序将完成以下步骤：</p><blockquote><p>1.根据JVM内存配置要求，为JVM申请特定大小的内存空间；</p><p>2.创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；</p><p>3.创建JVM 启动器实例 <code>Launcher</code>,并取得类加载器<code>ClassLoader</code>；</p><p>4.使用上述获取的<code>ClassLoader</code>实例加载我们定义的 <code>org.luanlouis.jvm.load.Main</code>类；</p><p>5.加载完成时候JVM会执行Main类的<code>main</code>方法入口，执行Main类的<code>main</code>方法；</p><p>6.结束，java程序运行结束，JVM销毁。</p></blockquote><p>下面逐一分析一下这几个步骤。</p><h3>一、根据JVM内存配置要求，为JVM申请特定大小的内存空间</h3><p>JVM内存按照功能上的划分，可以粗略地划分为方法区(<code>Method Area</code>) 和堆(<code>Heap</code>),而所有的类的定义信息都会被加载到方法区中。</p><p><img src="http://bloghello.oursnail.cn/jvm9-1.jpg" alt="image"></p><h3>二、创建一个引导类加载器实例，初步加载系统类到内存方法区区域中</h3><p>JVM申请好内存空间后，JVM会创建一个<strong>引导类加载器</strong>（<code>Bootstrap Classloader</code>）实例，引导类加载器是使用<code>C++</code>语言实现的，负责加载JVM虚拟机运行时所需的基本系统级别的类，如<code>java.lang.String</code>, <code>java.lang.Object</code>等等。<br>引导类加载器(<code>Bootstrap Classloader</code>)会读取 <code>{JRE_HOME}/lib</code> 下的jar包和配置，然后将这些系统类加载到方法区内。</p><p>本例中，引导类加载器是用 <code>{JRE_HOME}/lib</code>加载类的，不过，你也可以使用参数 <code>-Xbootclasspath</code> 或 系统变量<code>sun.boot.class.path</code>来指定的目录来加载类。</p><p>一般而言，<code>{JRE_HOME}/lib</code>下存放着JVM正常工作所需要的系统类，如下表所示：</p><table><thead><tr><th>文件名</th><th>描述</th></tr></thead><tbody><tr><td>rt.jar</td><td>运行环境包，rt即runtime，J2SE 的类定义都在这个包内</td></tr><tr><td>charsets.jar</td><td>字符集支持包</td></tr><tr><td>jce.jar</td><td>是一组包，它们提供用于加密、密钥生成和协商以及 Message Authentication Code（MAC）</td></tr><tr><td>jsse.jar</td><td>安全套接字拓展包Java™ Secure Socket Extension</td></tr><tr><td>classlist</td><td>该文件内表示是引导类加载器应该加载的类的清单</td></tr><tr><td>net.properties</td><td>JVM 网络配置信息</td></tr></tbody></table><p>引导类加载器(<code>Bootstrap ClassLoader</code>） 加载系统类后，JVM内存会呈现如下格局：</p><p><img src="http://bloghello.oursnail.cn/jvm9-2.jpg" alt="image"></p><ul><li>引导类加载器将类信息加载到方法区中，以特定方式组织，对于某一个特定的类而言，在方法区中它应该有 运行时常量池、类型信息、字段信息、方法信息、类加载器的引用，对应class实例的引用等信息。</li><li>类加载器的引用,由于这些类是由引导类加载器(<code>Bootstrap Classloader</code>)进行加载的，而 引导类加载器是由C++语言实现的，所以是无法访问的，故而该引用为NULL</li><li>对应class实例的引用， 类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</li></ul><h3>三、创建JVM 启动器实例 Launcher,并取得类加载器ClassLoader</h3><p>上述步骤完成，JVM基本运行环境就准备就绪了。接着，我们要让JVM工作起来了：运行我们定义的程序 <code>org.luanlouis,jvm.load.Main</code>。</p><p>此时，JVM虚拟机调用已经加载在方法区的类<code>sun.misc.Launcher</code> 的静态方法<code>getLauncher()</code>,  获取<code>sun.misc.Launcher</code> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Java启动器 </span></span><br><span class="line">sun.misc.Launcher launcher = sun.misc.Launcher.getLauncher(); </span><br><span class="line"><span class="comment">//获取类加载器ClassLoader用来加载class到内存来  </span></span><br><span class="line">ClassLoader classLoader = launcher.getClassLoader();</span><br></pre></td></tr></table></figure><p><code>sun.misc.Launcher</code> 使用了单例模式设计，保证一个JVM虚拟机内只有一个<code>sun.misc.Launcher</code>实例。</p><p>在<code>Launcher</code>的内部，其定义了两个类加载器(<code>ClassLoader</code>),分别是<code>sun.misc.Launcher.ExtClassLoader</code>和<code>sun.misc.Launcher.AppClassLoader</code>，这两个类加载器分别被称为拓展类加载器(<code>Extension ClassLoader</code>) 和 应用类加载器(<code>Application ClassLoader</code>).如下图所示：</p><p><img src="http://bloghello.oursnail.cn/jvm9-3.jpg" alt="image"></p><h3>四、使用类加载器ClassLoader加载Main类</h3><p>通过 <code>launcher.getClassLoader()</code>方法返回<code>AppClassLoader</code>实例，接着就是<code>AppClassLoader</code>加载 <code>org.luanlouis.jvm.load.Main</code>类的时候了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lassLoader classloader = launcher.getClassLoader();<span class="comment">//取得AppClassLoader类  </span></span><br><span class="line">classLoader.loadClass(<span class="string">"org.luanlouis.jvm.load.Main"</span>);<span class="comment">//加载自定义类</span></span><br></pre></td></tr></table></figure><p>上述定义的<code>org.luanlouis.jvm.load.Main</code>类被编译成<code>org.luanlouis.jvm.load.Main class</code>二进制文件，这个class文件中有一个叫常量池(<code>Constant Pool</code>)的结构体来存储该class的常量信息。常量池中有<code>CONSTANT_CLASS_INFO</code>类型的常量，表示该class中声明了要用到那些类：</p><p><img src="http://bloghello.oursnail.cn/jvm9-4.jpg" alt="image"></p><p>当<code>AppClassLoader</code>要加载 <code>org.luanlouis.jvm.load.Main</code>类时，会去查看该类的定义，发现它内部声明使用了其它的类： <code>sun.security.pkcs11.P11Util</code>、<code>java.lang.Object</code>、<code>java.lang.System</code>、<code>java.io.PrintStream</code>、<code>java.lang.Class</code>；<code>org.luanlouis.jvm.load.Main</code>类要想正常工作，首先要能够保证这些其内部声明的类加载成功。所以<code>AppClassLoader</code>要先将这些类加载到内存中。（注：为了理解方便，这里没有考虑懒加载的情况，事实上的JVM加载类过程比这复杂的多）</p><p><strong>加载顺序：</strong></p><ol><li>加载<code>java.lang.Object</code>、<code>java.lang.System</code>、<code>java.io.PrintStream</code>、<code>java,lang.Class</code></li></ol><blockquote><p><code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；</p><p>而<code>ExtClassLoader</code>发现不是其加载范围，其返回null；</p><p><code>AppClassLoader</code>发现父类加载器<code>ExtClassLoader</code>无法加载，<br>则会查询这些类是否已经被<code>BootstrapClassLoader</code>加载过，<br>结果表明这些类已经被<code>BootstrapClassLoader</code>加载过，<br>则无需重复加载，直接返回对应的<code>Class&lt;T&gt;</code>实例；</p></blockquote><ol start="2"><li>加载<code>sun.security.pkcs11.P11Util</code></li></ol><blockquote><p>此在<code>{JRE_HOME}/lib/ext/sunpkcs11.jar</code>包内，属于<code>ExtClassLoader</code>负责加载的范畴。</p><p><code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；</p><p>而<code>ExtClassLoader</code>发现其正好属于加载范围，故<code>ExtClassLoader</code>负责将其加载到内存中。</p><p><code>ExtClassLoader</code>在加载<code>sun.security.pkcs11.P11Util</code>时也分析这个类内都使用了哪些类，<br>并将这些类先加载内存后，才开始加载<code>sun.security.pkcs11.P11Util</code>，<br>加载成功后直接返回对应的<code>Class&lt;sun.security.pkcs11.P11Util&gt;</code>实例；</p></blockquote><ol start="3"><li>加载<code>org.luanlouis.jvm.load.Main</code></li></ol><blockquote><p><code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；<br><code>而ExtClassLoader</code>发现不是其加载范围，其返回null；</p><p><code>AppClassLoader</code>发现父类加载器<code>ExtClassLoader</code>无法加载，<br>则会查询这些类是否已经被<code>BootstrapClassLoader</code>加载过。<br>而结果表明<code>BootstrapClassLoader</code> 没有加载过它，<br>这时候<code>AppClassLoader</code>只能自己动手负责将其加载到内存中，<br>然后返回对应的<code>Class&lt;org.luanlouis.jvm.load.Main&gt;</code>实例引用；</p></blockquote><p>以上三步骤都成功，才表示<code>classLoader.loadClass(&quot;org.luanlouis.jvm.load.Main&quot;)</code>完成，上述操作完成后，JVM内存方法区的格局会如下所示：</p><p><img src="http://bloghello.oursnail.cn/jvm9-5.jpg" alt="image"></p><p>如上图所示：</p><ul><li>JVM方法区的类信息区是按照类加载器进行划分的，每个类加载器会维护自己加载类信息；</li><li>某个类加载器在加载相应的类时，会相应地在JVM内存堆（<code>Heap</code>）中创建一个对应的<code>Class&lt;T&gt;</code>，用来表示访问该类信息的入口</li></ul><h2>五、使用Main类的main方法作为程序入口运行程序</h2><p>就是去执行指令，过程与<a href="http://fourcolor.oursnail.cn/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">Java如何执行一个最简单的程序</a>类似。</p><h2>六、方法执行完毕，JVM销毁，释放内存</h2><p>对于本程序，主程序执行完毕，释放主函数所在的栈帧，释放堆中的内存。</p><h2>七、再来回顾回顾java类加载器相关的概念吧</h2><p>本处的内容为再次简单说明，具体见<a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">双亲委派模型</a>。类加载器(<code>Class Loader</code>)：顾名思义，指的是可以加载类的工具。JVM自身定义了三个类加载器：引导类加载器(<code>Bootstrap Class</code> Loader)、拓展类加载器(<code>Extension Class Loader</code> )、应用加载器(<code>Application Class Loader</code>)。当然，我们有时候也会自己定义一些类加载器来满足自身的需要。</p><p>引导类加载器(<code>Bootstrap Class Loader</code>): 该类加载器使JVM使用C++/C底层代码实现的加载器，用以加载JVM运行时所需要的系统类，这些系统类在<code>{JRE_HOME}/lib</code>目录下。<strong>由于类加载器是使用平台相关的底层<code>C++/C</code>语言实现的， 所以该加载器不能被Java代码访问到。但是，我们可以查询某个类是否被引导类加载器加载过</strong>。我们经常使用的系统类如：<code>java.lang.String</code>,<code>java.lang.Object</code>,<code>java.lang*</code>… 这些都被放在 <code>{JRE_HOME}/lib/rt.jar</code>包内， 当JVM系统启动的时候，引导类加载器会将其加载到 JVM内存的方法区中。</p><p>拓展类加载器(<code>Extension Class Loader</code>): 该加载器是用于加载 java 的拓展类 ，拓展类一般会放在<code>{JRE_HOME}/lib/ext/</code> 目录下，用来提供除了系统类之外的额外功能。拓展类加载器是是整个JVM加载器的Java代码可以访问到的类加载器的最顶端，即是超级父加载器，拓展类加载器是没有父类加载器的。（注意，其实引导类加载器不能算是扩展类加载器的父类，我们从源码中可以看出来的）</p><p>应用类加载器(<code>Applocatoin Class Loader</code>): 该类加载器是用于加载用户代码，是用户代码的入口。我经常执行指令 <code>java xxx.x.xxx.x.x.XClass</code> , 实际上，JVM就是使用的<code>AppClassLoader</code>加载 <code>xxx.x.xxx.x.x.XClass</code> 类的。</p><p>用户自定义类加载器（<code>Customized Class Loader</code>）：用户可以自己定义类加载器来加载类。所有的类加载器都要继承<code>java.lang.ClassLoader</code>类。</p><p>关于双亲委派模型，就不再赘述了。</p><p><img src="http://bloghello.oursnail.cn/jvm9-6.jpg" alt="image"></p><h2>八、线程上下文加载器</h2><p>Java 任何一段代码的执行，都有对应的线程上下文。如果我们在代码中，想看当前是哪一个线程在执行当前代码，我们经常是使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread  thread = Thread.currentThread();<span class="comment">//返回对当当前运行线程的引用</span></span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/jvm9-7.jpg" alt="image"></p><p>相应地，我们可以为当前的线程指定类加载器。在上述的例子中， 当执行   <code>java org.luanlouis.jvm.load.Main</code> 的时候，JVM会创建一个<code>Main</code>线程，而创建应用类加载器<code>AppClassLoader</code>的时候，会将<code>AppClassLoader</code>设置成Main线程的上下文类加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  Launcher.ExtClassLoader var1;  </span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">      var1 = Launcher.ExtClassLoader.getExtClassLoader();  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException var10) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">      <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException var9) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//将AppClassLoader设置成当前线程的上下文加载器  </span></span><br><span class="line">  Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);  </span><br><span class="line">  <span class="comment">//.......  </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程上下文类加载器是从线程的角度来看待类的加载，为每一个线程绑定一个类加载器，可以将类的加载从单纯的 双亲加载模型解放出来，进而实现特定的加载需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第十三篇文章，本文从一个简单程序入手，将前面所学串联起来，详细来看看类加载的过程到底是什么样子的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>静态分派和动态分派</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/"/>
    <id>http://yoursite.com/2019/02/09/JVM/静态分派和动态分派/</id>
    <published>2019-02-09T13:19:59.377Z</published>
    <updated>2019-02-09T13:20:05.810Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十二篇文章，本章说明静态分派和动态分派的原理。</p><a id="more"></a><p>这里所谓的分派指的是在Java中对方法的调用。Java中有三大特性：封装、继承和多态。分派是多态性的体现，Java虚拟机底层提供了我们开发中“重写”和“重载”的底层实现。其中重载属于静态分派，而重写则是动态分派的过程。除了使用分派的方式对方法进行调用之外，还可以使用解析调用，解析调用是在编译期间就已经确定了，在类装载的解析阶段就会把符号引用转化为直接引用，不会延迟到运行期间再去完成。而分派调用则既可以是静态的也可以是动态（就是这里的静态分派和动态分派）的。</p><h2>方法解析</h2><p>对于方法的调用，虚拟机提供了四条方法调用的字节码指令，分别是：</p><ul><li><p><code>invokestatic</code>: 调用静态方法</p></li><li><p><code>invokespecial</code>: 调用构造方法，私有方法，父类方法</p></li><li><p><code>invokevirtual</code>: 调用虚方法</p></li><li><p><code>invokeinterface</code>: 调用接口方法</p></li></ul><p>其中，1和2都可以在类加载阶段确定方法的唯一版本，因此，在类加载阶段就可以把符号引用解析为直接引用，在调用时刻直接找到方法代码块的内存地址进行执行（编译时已经找到了，并且存在方法调用的入口）；3和4则是在运行期间动态绑定方法的直接引用。</p><p><code>invokestatic</code>指令和<code>invokespecial</code>指令调用的方法称为非虚方法，注意，<code>final</code>修饰的方法也属于虚方法。</p><h2>静态分派</h2><p>静态分派只会涉及重载，而重载是在编译期间确定的，那么静态分派自然是一个静态的过程（因为还没有涉及到Java虚拟机）。静态分派的最直接的解释是在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的。比如创建一个类<code>O</code>，在<code>O</code>中创建了静态类内部类<code>A</code>，<code>O</code>中又有两个静态类内部类<code>B</code>、<code>C</code>继承了这个静态内部类<code>A</code>，那么实际上当编写如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">O</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(C c)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"C method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        O o = <span class="keyword">new</span> O();</span><br><span class="line">        A b = <span class="keyword">new</span> B();</span><br><span class="line">        A c = <span class="keyword">new</span> C();</span><br><span class="line">        o.a(b);</span><br><span class="line">        o.a(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是打印出连个<code>“A method”</code>。原因在于静态类型的变化仅仅在使用时发生，变量本身的类型不会发生变化。</p><p>比如我们这里中<code>A b = new B();</code>虽然在创建的时候是<code>B</code>的对象，但是当调用<code>o.a(b)</code>的时候才发现是<code>A</code>的对象，所以会输出<code>“A method”</code>。**也就是说在发生重载的时候，Java虚拟机是通过参数的静态类型而不是实际参数类型作为判断依据的。**因此，在编译阶段，Javac编译器选择了<code>a(A a)</code>这个重载方法。</p><p>虽然编译器能够在编译阶段确定方法的版本，但是很多情况下重载的版本不是唯一的，在这种模糊的情况下，编译器会选择一个更合适的版本。例如，重载的方法中，参数列表除了参数类型不一样，其他都一样，例接收的参数有char\int\long等，传入参数‘a’，则会调用需要char类型参数的方法，去掉需要char类型参数的方法，则会调用需要int类型参数的方法。这时发生了一次自动类型转换。同样，去掉需要int类型参数的方法，则会调用需要long类型参数的方法。这里再次发生类型转换，会按照char-&gt;int-&gt;long-&gt;float-&gt;double转换类型。</p><h2>动态分派</h2><p>动态分派与重写(Override)有着很密切的关联。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtayfjpk.jvm.chapter8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">        man.sayHello();  </span><br><span class="line">        woman.sayHello();  </span><br><span class="line">        man = <span class="keyword">new</span> Woman();  </span><br><span class="line">        man.sayHello();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里显然不可能是根据静态类型来决定的，因为静态类型都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时执行了不同的行为，并且变量<code>man</code>在两次调用中执行了不同的方法。</p><p>导致这个现象的原是是这两个变量的实际类型不同。那么Java虚拟机是如何根据实际类型来分派方法执行版本的呢，我们使用<code>javap</code>命令输出这段代码的字节码，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;  </span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC  </span><br><span class="line">  Code:  </span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span>  </span><br><span class="line">       0: new           #16                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Man  </span><br><span class="line">       <span class="number">3</span>: dup  </span><br><span class="line">       4: invokespecial #18                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Man."&lt;init&gt;":()V  </span><br><span class="line">       <span class="number">7</span>: astore_1  </span><br><span class="line">       8: new           #19                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman  </span><br><span class="line">      <span class="number">11</span>: dup  </span><br><span class="line">      12: invokespecial #21                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman."&lt;init&gt;":()V  </span><br><span class="line">      <span class="number">15</span>: astore_2  </span><br><span class="line">      <span class="number">16</span>: aload_1  </span><br><span class="line">      17: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      <span class="number">20</span>: aload_2  </span><br><span class="line">      21: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      24: new           #19                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman  </span><br><span class="line">      <span class="number">27</span>: dup  </span><br><span class="line">      28: invokespecial #21                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman."&lt;init&gt;":()V  </span><br><span class="line">      <span class="number">31</span>: astore_1  </span><br><span class="line">      <span class="number">32</span>: aload_1  </span><br><span class="line">      33: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      <span class="number">36</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>0-15行的字节码是准备动作，作用是建立<code>man</code>和<code>woman</code>的内存空间，调用<code>Man</code>和<code>Woman</code>类的实例构造器，将这两个实例的引用存放在第1和第2个局部变量表Slot之中，这个动作对应了代码中这两句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure><p>接下来的第16-21行是关键部分，第16和第20两行分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将执行的<code>sayHello()</code>方法的所有者，称为接收者(Receiver)。</p><p>第17和第21两行是方法调用指令，单从字节码的角度来看，这两条调用指令无论是指令(都是<code>invokevirtual</code>)还是参数(都是常量池中<code>Human.sayHello()</code>的符号引用)都完全一样，但是这两条指令最终执行的目标方法并不相同，其原因需要从<code>invokevirutal</code>指令的多态查找过程开始说起，<code>invokevirtual</code>指令的运行时解析过程大致分为以下步骤：</p><ul><li>找到操作数栈顶的第一个元素所指向的对象实际类型，记作<code>C</code>。</li><li>如果在类型<code>C</code>中找到与常量中描述符和简单名称都相同的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找结束；不通过则返回<code>java.lang.IllegalAccessError</code>错误。</li><li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行第2步的搜索与校验过程。</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>错误。</li></ul><p>由于<code>invokevirtual</code>指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h2>单分派与多分派</h2><p>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派与多分派两种。单分派是根据一个宗量来对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p><p>在编译期的静态分派过程选择目标方法的依据有两点：一是静态类型；二是方法参数，所以Java语言的静态分派属于多分派类型。在运行阶段虚拟机的动态分派过程只能接收者的实际类型一个宗量作为目标方法选择依据，所以Java语言的动态分派属于单分派类型。<strong>所以Java语言是一门静态多分派，动态单分派语言</strong>。</p><h2>JVM实现动态分派</h2><p>动态分派在Java中被大量使用，使用频率及其高，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此JVM在类的方法区中建立虚方法表（<code>virtual method table</code>）来提高性能。</p><p><strong>⭐⭐⭐每个类中都有一个虚方法表，表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表中该方法的地址入口和父类该方法的地址入口一样，即子类的方法入口指向父类的方法入口。如果子类重写父类的方法，那么子类的虚方法表中该方法的实际入口将会被替换为指向子类实现版本的入口地址</strong>。</p><p>那么虚方法表什么时候被创建？虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第十二篇文章，本章说明静态分派和动态分派的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>类的初始化过程</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/09/JVM/类的初始化过程/</id>
    <published>2019-02-09T12:13:48.264Z</published>
    <updated>2019-02-09T12:47:16.842Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十一篇文章，其实在前面的文章中已经说到了类加载机制，但是为了本文的完整性，前面一部分还是重复地放在这里，后面会着重说明初始化过程。</p><a id="more"></a><h2>1. 类加载过程</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（<code>Loading</code>）、验证（<code>Verification</code>）、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>Using</code>)和卸载(<code>Unloading</code>)7个阶段。其中准备、验证、解析3个部分统称为连接（<code>Linking</code>）。如图所示：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" alt="image"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都以<code>HotSpot</code>为基准。</p><h2>2. 加载</h2><p><strong>在加载阶段</strong>（可以参考<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法），虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li></ul><p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h2>3. 验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>验证阶段大致会完成4个阶段的检验动作</strong>：</p><blockquote><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></blockquote><blockquote><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p></blockquote><blockquote><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></blockquote><blockquote><p>符号引用验证：确保解析动作能正确执行。</p></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2>4. 准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量<code>value</code>在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把<code>value</code>赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器()方法之中，所以把<code>value</code>赋值为123的动作将在初始化阶段才会执行。</p><p><strong>至于“特殊情况”是指</strong>：<code>public static final int value=123</code>，即当类字段的字段属性是<code>ConstantValue</code>时，会在准备阶段初始化为指定的值，所以标注为<code>final</code>之后，<code>value</code>的值在准备阶段初始化为123而非0.</p><h2>5. 解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h2>6. 初始化</h2><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程.</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，<strong>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        System.out.println(i);<span class="comment">//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么去掉报错的那句，改成下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        i=0;</span><br><span class="line">//      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i=1;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是什么呢？当然是1啦~在准备阶段我们知道i=0，然后类初始化阶段按照顺序执行，首先执行<code>static</code>块中的i=0,接着执行<code>static</code>赋值操作i=1,最后在main方法中获取i的值为1。</p><p><code>&lt;clinit&gt;()</code>方法与实例构造器<code>&lt;init&gt;()</code>方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<code>&lt;cinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕.</p><p>⭐由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p><p><code>&lt;clinit&gt;()</code>方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<code>&lt;clinit&gt;()</code>方法。</p><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。</p><p>虚拟机规范严格规定了<strong>有且只有</strong>5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><blockquote><ol><li>遇到 <code>new</code> , <code>getstatic</code> , <code>putstatic</code> , <code>invokestatic</code> 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：<strong>①使用new关键字实例化对象的时候</strong>、<strong>②读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候</strong>，以及<strong>③调用一个类的静态方法的时候</strong>。</li></ol></blockquote><blockquote><ol start="2"><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li></ol></blockquote><blockquote><ol start="3"><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li></ol></blockquote><blockquote><ol start="4"><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li></ol></blockquote><p>下面说明三种被动引用(除了上面提到的五种情况外，所有引用类的方法都不会触发初始化，成为被动引用)。</p><p><strong>第一种：通过子类引用父类的静态字段，不会导致子类初始化。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superclass static init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superclass static init</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>说明：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p><strong>第二种：通过数组定义来引用类，不会触发此类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter12;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SuperClass复用上面个代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：（无）</p><p>说明：从结果来看，显然没有触发类<code>chapter12.SuperClass</code>的初始化阶段，但是这段代码触发了另一个名叫 <code>&quot;[Lchapter12.SuperClass&quot;</code>的类的初始化阶段。这显然不是一个合法的类名称，他是由虚拟机自动生成的、直接继承于<code>java.lang.Object</code>的子类，创建动作由字节码制定<code>newarray</code>触发。</p><p>这个类代表了一个元素类型为<code>chapter12.SuperClass</code>的一维数组，数组中应有的属性和方法(用于可直接使用的只有被修饰为<code>public</code>的<code>length</code>属性和<code>clone()</code>方法)都实现在这个类里。Java语言中对数组的访问比<code>C/C++</code>相对安全是因为这个类封装了数组元素的访问方法，而<code>C/C++</code>     直接翻译为对数组指针的移动。</p><p><strong>第三种：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：hello world</p><p>说明：上述代码虽然在java源码中引用了<code>ConstClass</code>类中的常量<code>hello world</code>，但是其实在编译阶段通过常量传播优化，已经将此常量值<code>hello world</code>存储到了<code>NotInitialization</code>的常量池中，以后<code>NotInitialization</code>对常量<code>ConstClass.HELLOWORLD</code>的引用实际上都被转化为<code>NotInitialization</code>对自身常量池的引用了。</p><h2>7. 接口的加载</h2><p>接口的加载过程与类加载过程有一些不同，针对接口需要做一些特殊说明：</p><p>接口也有初始化过程，而接口中不能使用<code>static{}</code>语句块，但编译器仍然会为接口生成<code>&quot;&lt;clinit()&gt;&quot;</code>类构造器，用于初始化接口中所定义的成员变量。</p><p>接口与类真正所区别的是前面讲述的5种“有且仅有”情况的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个借口在初始化时，并不要求其父接口全部都已经完成了初始化，只有在真正用到父接口时（如引用接口中定义的常量）才会初始化。</p><h2>8. 例子巩固</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SSClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> <span class="keyword">extends</span> <span class="title">SSClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init SuperClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init SubClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SSClass</span><br><span class="line">SuperClass init!</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>说明：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><h2>9.总结java执行顺序</h2><p>举例立刻明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Children构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Children普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Children静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Children children = <span class="keyword">new</span> Children();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parent静态代码块</span><br><span class="line">Children静态代码块</span><br><span class="line">Parent普通代码块</span><br><span class="line">Parent构造函数</span><br><span class="line">Children普通代码块</span><br><span class="line">Children构造函数</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类静态块</span><br><span class="line">自身静态块</span><br><span class="line">父类块</span><br><span class="line">父类构造器</span><br><span class="line">自身块</span><br><span class="line">自身构造器</span><br></pre></td></tr></table></figure><h2>10. 总结java赋值顺序</h2><p>举例立刻明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag = <span class="string">"父类成员变量赋值"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"父类构造器---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"父类构造器赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"父类构造器---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类代码块---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"父类代码块赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"父类代码块---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag = <span class="string">"成员变量赋值"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类构造器---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"子类构造器赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"子类构造器---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类代码快---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"子类代码块赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"子类代码块---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类方法---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Children children = <span class="keyword">new</span> Children();</span><br><span class="line">        children.setFlag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">父类代码块---&gt;父类成员变量赋值</span><br><span class="line">父类代码块---&gt;父类代码块赋值</span><br><span class="line"></span><br><span class="line">父类构造器---&gt;父类代码块赋值</span><br><span class="line">父类构造器---&gt;父类构造器赋值</span><br><span class="line"></span><br><span class="line">子类代码快---&gt;成员变量赋值</span><br><span class="line">子类代码块---&gt;子类代码块赋值</span><br><span class="line"></span><br><span class="line">子类构造器---&gt;子类代码块赋值</span><br><span class="line">子类构造器---&gt;子类构造器赋值</span><br><span class="line"></span><br><span class="line">子类方法---&gt;子类构造器赋值</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">父类的静态变量赋值</span><br><span class="line">自身的静态变量赋值</span><br><span class="line"></span><br><span class="line">父类成员变量赋值</span><br><span class="line">父类块赋值</span><br><span class="line">父类构造器赋值</span><br><span class="line"></span><br><span class="line">自身成员变量赋值</span><br><span class="line">自身块赋值</span><br><span class="line">自身构造器赋值</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第十一篇文章，其实在前面的文章中已经说到了类加载机制，但是为了本文的完整性，前面一部分还是重复地放在这里，后面会着重说明初始化过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读5-Class文件中的方法表集合--method方法在class文件中是怎样组织的</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB5-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88--method%E6%96%B9%E6%B3%95%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读5-Class文件中的方法表集合--method方法在class文件中是怎样组织的/</id>
    <published>2019-02-09T11:40:07.123Z</published>
    <updated>2019-02-09T11:40:14.998Z</updated>
    
    <content type="html"><![CDATA[<p>继续讲class文件中的方法表集合。</p><a id="more"></a><h2>1. 方法表集合概述</h2><p>方法表集合是指由若干个方法表（method_info）组成的集合。对于在类中定义的若干个经过JVM编译成class文件后，会将相应的method方法信息组织到一个叫做方法表集合的结构中，字段表集合是一个类数组结构，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9591" alt="image"></p><h2>2. method方法的描述-方法表集合在class文件中的位置</h2><p>method方法的描述-方法表集合紧跟在字段表集合的后面，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9592" alt="image"></p><h2>3. 一个类中的method方法应该包含哪些信息？----method_info结构体的定义</h2><p>对于一个方法的表示，我们根据我们可以概括的信息如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9593" alt="image"></p><p>实际上JVM还会对method方法的描述添加其他信息，我们将在后面详细讨论。如上图中的method_info结构体的定义，该结构体的定义跟描述field字段 的field_info结构体的结构几乎完全一致,如下图所示。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9594" alt="image"></p><p>方法表的结构体由：访问标志(access_flags)、名称索引(name_index)、描述索引(descriptor_index)、属性表(attribute_info)集合组成。</p><p><strong>访问标志(access_flags)：</strong></p><p>method_info结构体最前面的两个字节表示的访问标志（access_flags），记录这这个方法的作用域、静态or非静态、可变性、是否可同步、是否本地方法、是否抽象等信息，实际上不止这些信息，我们后面会详细介绍访问标志这两个字节的每一位具体表示什么意思。</p><p><strong>名称索引(name_index)：</strong></p><p>紧跟在访问标志（access_flags）后面的两个字节称为名称索引，这两个字节中的值指向了常量池中的某一个常量池项，这个方法的名称以UTF-8格式的字符串存储在这个常量池项中。如public void methodName(),很显然，“methodName”则表示着这个方法的名称，那么在常量池中会有一个CONSTANT_Utf8_info格式的常量池项，里面存储着“methodName”字符串，而mehodName()方法的方法表中的名称索引则指向了这个常量池项。</p><p><strong>描述索引(descriptor_index)：</strong></p><p>描述索引表示的是这个方法的特征或者说是签名，一个方法会有若干个参数和返回值，而若干个参数的数据类型和返回值的数据类型构成了这个方法的描述，其基本格式为：     (参数数据类型描述列表)返回值数据类型   。我们将在后面继续讨论。</p><p><strong>属性表(attribute_info)集合：</strong></p><p>这个属性表集合非常重要，方法的实现被JVM编译成JVM的机器码指令，机器码指令就存放在一个Code类型的属性表中；如果方法声明要抛出异常，那么异常信息会在一个Exceptions类型的属性表中予以展现。Code类型的属性表可以说是非常复杂的内容，也是本文最难的地方。</p><h2>4. 访问标志(access_flags)—记录着method方法的访问信息</h2><p>访问标志（access_flags）共占有2 个字节，分为 16 位，这 16位 表示的含义如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9595" alt="image"></p><p><strong>举例：某个类中定义了如下方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>greeting()方法的修饰符有：public、static、synchronized、final 这几个修饰符修饰，那么相对应地，greeting()方法的访问标志中的ACC_PUBLIC、ACC_STATIC、ACC_SYNCHRONIZED、ACC_FINAL标志位都应该是1，即：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9596" alt="image"></p><p>从上图中可以看出访问标志的值应该是二进制00000000 00111001,即十六进制0x0039。我们将在文章的最后一个例子中证实这点。</p><h2>5. 名称索引和描述符索引----一个方法的签名</h2><p>紧接着访问标志（access_flags）后面的两个字节，叫做<strong>名称索引(name_index)</strong>，这两个字节中的值是指向了常量池中某个常量池项的索引，该常量池项表示这这个方法名称的字符串。</p><p><strong>方法描述符索引</strong>(descrptor_index)是紧跟在名称索引后面的两个字节，这两个字节中的值跟名称索引中的值性质一样，都是指向了常量池中的某个常量池项。这两个字节中的指向的常量池项，是表示了方法描述符的字符串。</p><p><strong>所谓的方法描述符，实质上就是指用一个什么样的字符串来描述一个方法</strong>，方法描述符的组成如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9597" alt="image"></p><p>举例：对于如下定义的的greeting()方法，我们来看一下对应的method_info结构体中的名称索引和描述符索引信息是怎样组织的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示,method_info结构体的名称索引中存储了一个索引值x，指向了常量池中的第x项，第 x项表示的是字符串&quot;greeting&quot;,即表示该方法名称是&quot;greeting&quot;；描述符索引中的y 值指向了常量池的第y项，该项表示字符串&quot;()V&quot;，即表示该方法没有参数，返回值是void类型。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9598" alt="image"></p><h2>6. 属性表集合–记录方法的机器指令和抛出异常等信息</h2><p>属性表集合记录了某个方法的一些属性信息，这些信息包括：</p><blockquote><ol><li>这个方法的代码实现，即方法的可执行的机器指令</li><li>这个方法声明的要抛出的异常信息</li><li>这个方法是否被@deprecated注解表示</li><li>这个方法是否是编译器自动生成的</li></ol></blockquote><p>属性表（attribute_info）结构体的一般结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9599" alt="image"></p><p><ins>修正：属性长度为4个字节。</ins></p><h3>6.1 Code类型的属性表–method方法中的机器指令的信息</h3><p>Code类型的属性表(attribute_info)可以说是class文件中最为重要的部分，因为它包含的是JVM可以运行的机器码指令，JVM能够运行这个类，就是从这个属性中取出机器码的。除了要执行的机器码，它还包含了一些其他信息，如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95910" alt="image"></p><p><strong>Code属性表的组成部分</strong>：</p><blockquote><p>机器指令----code：</p></blockquote><p>目前的JVM使用一个字节表示机器操作码，即对JVM底层而言，它能表示的机器操作码不多于2的 8 次方，即 256个。class文件中的机器指令部分是class文件中最重要的部分，并且非常复杂，本文的重点不止介绍它</p><blockquote><p>异常处理跳转信息—exception_table：</p></blockquote><p>如果代码中出现了try{}catch{}块，那么try{}块内的机器指令的地址范围记录下来，并且记录对应的catch{}块中的起始机器指令地址，当运行时在try块中有异常抛出的话，JVM会将catch{}块对应懂得其实机器指令地址传递给PC寄存器，从而实现指令跳转；</p><blockquote><p>Java源码行号和机器指令的对应关系—LineNumberTable属性表：</p></blockquote><p>编译器在将java源码编译成class文件时，会将源码中的语句行号跟编译好的机器指令关联起来，这样的class文件加载到内存中并运行时，如果抛出异常，JVM可以根据这个对应关系，抛出异常信息，告诉我们我们的源码的多少行有问题，方便我们定位问题。这个信息不是运行时必不可少的信息，但是默认情况下，编译器会生成这一项信息，如果你项取消这一信息，你可以使用-g:none 或-g:lines来取消或者要求设置这一项信息。如果使用了-g:none来生成class文件，class文件中将不会有LineNumberTable属性表，造成的影响就是 将来如果代码报错，将无法定位错误信息报错的行，并且如果项调试代码，将不能在此类中打断点（因为没有指定行号。）</p><blockquote><p>局部变量表描述信息----LocalVariableTable属性表：</p></blockquote><p>局部变量表信息会记录栈帧局部变量表中的变量和java源码中定义的变量之间的关系，这个信息不是运行时必须的属性，默认情况下不会生成到class文件中。你可以根据javac指令的-g:none或者-g:vars选项来取消或者设置这一项信息。<br>它有什么作用呢？  当我们使用IDE进行开发时，最喜欢的莫过于它们的代码提示功能了。如果在项目中引用到了第三方的jar包，而第三方的包中的class文件中有无LocalVariableTable属性表的区别如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95911" alt="image"></p><p><strong>Code属性表结构体的解释：</strong></p><ol><li><p>attribute_name_index,属性名称索引，占有2个字节，其内的值指向了常量池中的某一项，该项表示字符串“Code”;</p></li><li><p>attribute_length,属性长度，占有 4个字节，其内的值表示后面有多少个字节是属于此Code属性表的；</p></li><li><p>max_stack,操作数栈深度的最大值，占有 2 个字节，在方法执行的任意时刻，操作数栈都不应该超过这个值，虚拟机的运行的时候，会根据这个值来设置该方法对应的栈帧(Stack Frame)中的操作数栈的深度；</p></li><li><p>max_locals,最大局部变量数目，占有 2个字节，其内的值表示局部变量表所需要的存储空间大小；</p></li><li><p>code_length,机器指令长度，占有 4 个字节，表示跟在其后的多少个字节表示的是机器指令；</p></li><li><p>code,机器指令区域，该区域占有的字节数目由 code_length中的值决定。JVM最底层的要执行的机器指令就存储在这里；</p></li><li><p>exception_table_length,显式异常表长度，占有2个字节，如果在方法代码中出现了try{} catch()形式的结构，该值不会为空，紧跟其后会跟着若干个exception_table结构体，以表示异常捕获情况；</p></li><li><p>exception_table，显式异常表，占有8 个字节，start_pc,end_pc,handler_pc中的值都表示的是PC计数器中的指令地址。exception_table表示的意思是：如果字节码从第start_pc行到第end_pc行之间出现了catch_type所描述的异常类型，那么将跳转到handler_pc行继续处理。</p></li><li><p>attribute_count,属性计数器，占有 2 个字节，表示Code属性表的其他属性的数目</p></li><li><p>attribute_info,表示Code属性表具有的属性表，它主要分为两个类型的属性表：“LineNumberTable”类型和“LocalVariableTable”类型。<br>“LineNumberTable”类型的属性表记录着Java源码和机器指令之间的对应关系<br>“LocalVariableTable”类型的属性表记录着局部变量描述</p></li></ol><p><strong>举例：</strong></p><p>如下定义Simple类，使用javac -g:none Simple.java 编译出Simple.class 文件，并使用javap -v Simple &gt; Simple.txt 查看反编译的信息，然后看Simple.class文件中的方法表集合是怎样组织的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>1. Simple.class文件组织信息如下所示：</h4><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95912" alt="image"></p><p>如上所示，方法表集合使用了蓝色线段圈了起来。<br>请注意：方法表集合的头两个字节，即方法表计数器（method_count）的值是0x0002，它表示该类中有2 个方法。细心的读者会注意到，我们的Simple.java中就定义了一个greeting()方法，为什么class文件中会显示有两个方法呢？？</p><blockquote><p>JVM为没有显式定义实例化构造方法的类，自动生成默认的实例化构造方法&quot;<init>()&quot;</init></p></blockquote><p>除了实例化构造方法，JVM还会在特殊的情况下生成一个叫类构造方法&quot;<cinit>()&quot;。如果我们在类中使用到了static修饰的代码块，那么，JVM会在class文件中生成一个“<cinit>()”构造方法。关于它们的具体细节，我将在后续的文章中详细讨论，在这里就不展开了。</cinit></cinit></p><blockquote><ol start="2"><li>Simple.class 中的<init>() 方法:</init></li></ol></blockquote><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95913" alt="image"></p><p>解释：</p><ol><li><p>方法访问标志(access_flags)： 占有 2个字节，值为0x0001,即标志位的第 16 位为 1，所以该<init>()方法的修饰符是：ACC_PUBLIC;</init></p></li><li><p>名称索引(name_index)： 占有 2 个字节，值为 0x0004，指向常量池的第 4项，该项表示字符串“<init>”，即该方法的名称是“<init>”;</init></init></p></li><li><p>描述符索引(descriptor_index): 占有 2 个字节，值为0x0005,指向常量池的第 5 项，该项表示字符串“()V”，即表示该方法不带参数，并且无返回值（构造函数确实也没有返回值）；</p></li><li><p>属性计数器（attribute_count): 占有 2 个字节，值为0x0001,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；</p></li><li><p>属性表的名称索引(attribute_name_index)：占有 2 个字节，值为0x0006,指向常量池中的第6 项，该项表示字符串“Code”，表示这个属性表是Code类型的属性表；</p></li><li><p>属性长度（attribute_length）：占有4个字节，值为0x0000 0011，即十进制的 17，表明后续的 17 个字节可以表示这个Code属性表的属性信息；</p></li><li><p>操作数栈的最大深度（max_stack）：占有2个字节，值为0x0001,表示栈帧中操作数栈的最大深度是1；</p></li><li><p>局部变量表的最大容量（max_variable）：占有2个字节，值为0x0001, JVM在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；</p></li><li><p>机器指令数目(code_length)：占有4个字节，值为0x0000 0005,表示后续的5 个字节 0x2A 、0xB7、 0x00、0x01、0xB1表示机器指令;</p></li><li><p>机器指令集(code[code_length])：这里共有  5个字节，值为0x2A 、0xB7、 0x00、0x01、0xB1；</p></li><li><p>显式异常表集合（exception_table_count）： 占有2 个字节，值为0x0000,表示方法中没有需要处理的异常信息；</p></li><li><p>Code属性表的属性表集合（attribute_count）： 占有2 个字节，值为0x0000，表示它没有其他的属性表集合，因为我们使用了-g:none 禁止编译器生成Code属性表的 LineNumberTable 和LocalVariableTable;</p></li></ol><blockquote><p>B. Simple.class 中的greeting() 方法:</p></blockquote><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95914" alt="image"></p><p>解释：</p><ol><li><p>方法访问标志(access_flags)： 占有 2个字节，值为 0x0039 ,即二进制的00000000 00111001,即标志位的第11、12、13、16位为1，根据上面讲的方法标志位的表示，可以得到该greeting()方法的修饰符有：ACC_SYNCHRONIZED、ACC_FINAL、ACC_STATIC、ACC_PUBLIC;</p></li><li><p>名称索引(name_index)： 占有 2 个字节，值为 0x0007，指向常量池的第 7 项，该项表示字符串“greeting”，即该方法的名称是“greeting”;</p></li><li><p>描述符索引(descriptor_index): 占有 2 个字节，值为0x0005,指向常量池的第 5 项，该项表示字符串“()V”，即表示该方法不带参数，并且无返回值；</p></li><li><p>属性计数器（attribute_count): 占有 2 个字节，值为0x0001,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；</p></li><li><p>属性表的名称索引(attribute_name_index)：占有 2 个字节，值为0x0006,指向常量池中的第6 项，该项表示字符串“Code”，表示这个属性表是Code类型的属性表；</p></li><li><p>属性长度（attribute_length）：占有4个字节，值为0x0000 0010，即十进制的16，表明后续的16个字节可以表示这个Code属性表的属性信息；</p></li><li><p>操作数栈的最大深度（max_stack）：占有2个字节，值为0x0001,表示栈帧中操作数栈的最大深度是1；</p></li><li><p>局部变量表的最大容量（max_variable）：占有2个字节，值为0x0001, JVM在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；</p></li><li><p>机器指令数目(code_length)：占有4 个字节，值为0x0000 0004,表示后续的4个字节0x10、 0x0A、 0x3B、0xB1的是表示机器指令;</p></li><li><p>机器指令集(code[code_length])：这里共有4 个字节，值为0x10、 0x0A、 0x3B、0xB1 ；</p></li><li><p>显式异常表集合（exception_table_count）： 占有2 个字节，值为0x0000,表示方法中没有需要处理的异常信息；</p></li><li><p>Code属性表的属性表集合（attribute_count）： 占有2 个字节，值为0x0000，表示它没有其他的属性表集合，因为我们使用了-g:none 禁止编译器生成Code属性表的 LineNumberTable 和LocalVariableTable;</p></li></ol><h3>6.2 Exceptions类型的属性表----method方法声明的要抛出的异常信息</h3><p>有些方法在定义的时候，会声明该方法会抛出什么类型的异常，如下定义一个Interface接口，它声明了sayHello()方法，抛出Exception异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们看一下Exceptions类型的属性表(attribute_info)结构体是怎样组织的：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95915" alt="image"></p><p>如上图所示，Exceptions类型的属性表(attribute_info)结构体由一下元素组成：</p><p>属性名称索引(attribute_name_index)：占有 2个字节，其中的值指向了常量池中的表示&quot;Exceptions&quot;字符串的常量池项；</p><p>属性长度(attribute_length)：它比较特殊，占有4个字节，它的值表示跟在其后面多少个字节表示异常信息；</p><p>异常数量(number_of_exceptions)：占有2 个字节，它的值表示方法声明抛出了多少个异常，即表示跟在其后有多少个异常名称索引；</p><p>异常名称索引(exceptions_index_table)：占有2个字节，它的值指向了常量池中的某一项，该项是一个CONSTANT_Class_info类型的项，表示这个异常的完全限定名称；</p><p><strong>Exceptions类型的属性表的长度计算</strong></p><p>如果某个方法定义中，没有声明抛出异常，那么，表示该方法的方法表(method_info)结构体中的属性表集合中不会有Exceptions类型的属性表；换句话说，如果方法声明了要抛出的异常，方法表(method_info)结构体中的属性表集合中必然会有Exceptions类型的属性表，并且该属性表中的异常数量不小于1。<br>我们假设异常数量中的值为 N，那么后面的异常名称索引的数量就为N，它们总共占有的字节数为N*2，而异常数量占有2个字节，那么将有下面的这个关系式：</p><blockquote><p>属性长度(attribute_length)中的值= 2  + 2*异常数量(number_of_exceptions)中的值</p></blockquote><blockquote><p>Exceptions类型的属性表（attribute_info）的长度=2+4+属性长度(attribute_length)中的值</p></blockquote><p><strong>举例：</strong><br>将上面定义的Interface接口类编译成class文件，然后我们查看Interface.class文件，找出方法表集合所在位置和相应的数据，并辅助javap -v  Inerface 查看</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95916" alt="image"></p><p>由于sayHello()方法是在的Interface接口类中声明的，它没有被实现，所以它对应的方法表(method_info)结构体中的属性表集合中没有Code类型的属性表。</p><ol><li><p>方法计数器（methods_count）中的值为0x0001，表明其后的方法表(method_info)就一个,即我们就定义了一个方法，其后会紧跟着一个方法表(method_info)结构体；</p></li><li><p>方法的访问标志（access_flags）的值是0x0401，二进制是00000100 00000001,第6位和第16位是1，对应上面的标志位信息，可以得出它的访问标志符有：ACC_ABSTRACT、ACC_PUBLIC。细心的读者可能会发现，在上面声明的sayHello()方法中并没有声明为abstract类型啊。确实如此，这是因为编译器对于接口内声明的方法自动加上ACC_ABSTRACT标志。</p></li><li><p>名称索引（name_index）中的值为0x0005，0x0005指向了常量池的第5项，第五项表示的字符串为“sayHello”，即表示的方法名称是sayHello</p></li><li><p>描述符索引(descriptor_index)中的值为0x0006,0x0006指向了常量池中的第6项，第6项表示的字符串为“()V” 表示这个方法的无入参，返回值为void类型</p></li><li><p>属性表计数器(attribute_count)中的值为0x0001,表示后面的属性表的个数就1个，后面紧跟着一个attribute_info结构体；</p></li><li><p>属性表（attribute_info）中的属性名称索引(attribute_name_index)中的值为0x0007，0x0007指向了常量池中的第7 项，第 7项指向字符串“Exceptions”，即表示该属性表表示的异常信息；</p></li><li><p>属性长度（attribute_length）中的值为：0x00000004,即后续的4个字节将会被解析成属性值；</p></li><li><p>异常数量（number_of_exceptions）中的值为0x0001,表示这个方法声明抛出的异常个数是1个；</p></li><li><p>异常名称索引(exception_index_table)中的值为0x0008,指向了常量池中的第8项，第8项表示的是CONSTANT_Class_info类型的常量池项，表示“java/lang/Exception”，即表示此方法抛出了java.lang.Exception异常。</p></li></ol><h2>7. IDE代码提示功能实现的基本原理</h2><p>每个IDE都提供了代码提示功能，它们实现的基本原理其实就是IDE针对它们项目下的包中所有的class文件进行建模，解析出它们的方法信息，当我们一定的条件时，IDE会自动地将合适条件的方法列表展示给开发者，供开发者使用。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95917" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续讲class文件中的方法表集合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读4-Class文件中的字段表集合--field字段在class文件中是怎样组织的</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB4-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88--field%E5%AD%97%E6%AE%B5%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读4-Class文件中的字段表集合--field字段在class文件中是怎样组织的/</id>
    <published>2019-02-09T11:38:35.969Z</published>
    <updated>2019-02-09T11:38:52.544Z</updated>
    
    <content type="html"><![CDATA[<p>继续讲class文件中的字段表集合。</p><a id="more"></a><h2>1. 字段表集合概述</h2><p>字段表集合是指由若干个字段表（field_info）组成的集合。对于在类中定义的若干个字段，经过JVM编译成class文件后，会将相应的字段信息组织到一个叫做字段表集合的结构中，字段表集合是一个类数组结构，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B581" alt="image"></p><p>注意：这里所讲的字段是指在类中定义的静态或者非静态的变量，而不是在类中的方法内定义的变量。请注意区别。<br>比如，如果某个类中定义了5个字段，那么，JVM在编译此类的时候，会生成5个字段表（field_info）信息,然后将字段表集合中的字段计数器的值设置成5，将5个字段表信息依次放置到字段计数器的后面。</p><h2>2. 字段表集合在class文件中的位置</h2><p>字段表集合紧跟在class文件的接口索引集合结构的后面，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B582" alt="image"></p><h2>3.  Java中的一个Field字段应该包含那些信息？------字段表field_info结构体的定义</h2><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B583" alt="image"></p><p>针对上述的字段表示，JVM虚拟机规范规定了field_info结构体来描述字段，其表示信息如下：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B584" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B585" alt="image"></p><p>下面我将一一讲解FIeld_info的组成元素：访问标志（access_flags）、名称索引（name_index）、描述索引（descriptor_index）、属性表集合</p><h2>4. field字段的访问标志</h2><p>如上图所示定义的field_info结构体，field字段的访问标志(access_flags)占有两个字节，它能够表述的信息如下所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B586" alt="image"></p><p>举例：如果我们在某个类中有定义field域：private static String str;，那么在访问标志上，第15位ACC_PRIVATE和第13位ACC_STATIC标志位都应该为1。field域str的访问标志信息应该是如下所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B587" alt="image"></p><h2>5. 字段的数据类型表示和字段名称表示</h2><p>class文件对数据类型的表示如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B588" alt="image"></p><p>field字段名称，我们定义了一个形如private static String str的field字段，其中&quot;str&quot;就是这个字段的名称。<br>class文件将字段名称和field字段的数据类型表示作为字符串存储在常量池中。在field_info结构体中，紧接着访问标志的，就是字段名称索引和字段描述符索引，它们分别占有两个字节，其内部存储的是指向了常量池中的某个常量池项的索引，对应的常量池项中存储的字符串，分别表示该字段的名称和字段描述符。</p><h2>6. 属性表集合-----静态field字段的初始化</h2><p>在定义field字段的过程中，我们有时候会很自然地对field字段直接赋值，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX=<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>对于虚拟机而言，上述的两个field字段赋值的时机是不同的：</p><blockquote><p>对于非静态（即无static修饰）的field字段的赋值将会出现在实例构造方法<init>()中</init></p></blockquote><blockquote><p>对于静态的field字段，有两个选择：1、在静态构造方法<cinit>()中进行；2 、使用ConstantValue属性进行赋值</cinit></p></blockquote><p>Sun javac编译器对于静态field字段的初始化赋值策略：</p><blockquote><p>如果使用final和static同时修饰一个field字段，并且这个字段是基本类型或者String类型的，那么编译器在编译这个字段的时候，会在对应的field_info结构体中增加一个ConstantValue类型的结构体，在赋值的时候使用这个ConstantValue进行赋值；</p></blockquote><blockquote><p>如果该field字段并没有被final修饰，或者不是基本类型或者String类型，那么将在类构造方法<cinit>()中赋值。</cinit></p></blockquote><p>对于上述的public static final init MAX=100：</p><blockquote><p>javac编译器在编译此field字段构建field_info结构体时，除了访问标志、名称索引、描述符索引外，会增加一个ConstantValue类型的属性表。</p></blockquote><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B589" alt="image"></p><h2>7. 实例解析</h2><p>定义如下一个简单的Simple类，然后通过查看Simple.class文件内容并结合javap -v Simple 生成的常量池内容，分析str field字段的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">transient</span> <span class="keyword">static</span> <span class="keyword">final</span> String str =<span class="string">"This is a test"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B5810" alt="image"></p><blockquote><ol><li>字段计数器中的值为0x0001,表示这个类就定义了一个field字段</li></ol></blockquote><blockquote><ol start="2"><li>字段的访问标志是0x009A,二进制是00000000 10011010，即第9、12、13、15位标志位为1，这个字段的标志符有：ACC_TRANSIENT、ACC_FINAL、ACC_STATIC、ACC_PRIVATE;</li></ol></blockquote><blockquote><ol start="3"><li>名称索引中的值为0x0005,指向了常量池中的第5项，为“str”,表明这个field字段的名称是str；</li></ol></blockquote><blockquote><ol start="4"><li>描述索引中的值为0x0006,指向了常量池中的第6项，为&quot;Ljava/lang/String;&quot;，表明这个field字段的数据类型是java.lang.String类型；</li></ol></blockquote><blockquote><p>5.属性表计数器中的值为0x0001,表明field_info还有一个属性表；</p></blockquote><blockquote><p>6.属性表名称索引中的值为0x0007,指向常量池中的第7项，为“ConstantValue”,表明这个属性表的名称是ConstantValue，即属性表的类型是ConstantValue类型的；</p></blockquote><blockquote><p>7.属性长度中的值为0x0002，因为此属性表是ConstantValue类型，它的值固定为2；</p></blockquote><blockquote><p>8.常量值索引 中的值为0x0008,指向了常量池中的第8项，为CONSTANT_String_info类型的项，表示“This is a test” 的常量。在对此field赋值时，会使用此常量对field赋值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续讲class文件中的字段表集合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读3-Class文件中的访问标志、类索引、父类索引、接口索引集合</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB3-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读3-Class文件中的访问标志、类索引、父类索引、接口索引集合/</id>
    <published>2019-02-09T11:37:12.949Z</published>
    <updated>2019-02-09T11:37:24.227Z</updated>
    
    <content type="html"><![CDATA[<p>讲完了class文件中的常量池，我们就相当于克服了class文件中最麻烦的模块了。现在，我们来看一下class文件中紧接着常量池后面的几个东西：访问标志、类索引、父类索引、接口索引集合。</p><a id="more"></a><h2>1. 访问标志、类索引、父类索引、接口索引集合 在class文件中的位置</h2><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%20%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE" alt="image"></p><h2>2. 访问标志(access_flags)能够表示什么？</h2><p>访问标志（access_flags）紧接着常量池后，占有两个字节，总共16位，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%28access_flags%29%E8%83%BD%E5%A4%9F%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F" alt="image"></p><p>当JVM在编译某个类或者接口的源代码时，JVM会解析出这个类或者接口的访问标志信息，然后，将这些标志设置到访问标志（access_flags）这16个位上。JVM会考虑如下设置如下访问表示信息：</p><h4>a. 类或接口</h4><p>我们知道，每个定义的类或者接口都会生成class文件（这里也包括内部类，在某个类中定义的静态内部类也会单独生成一个class文件）。</p><blockquote><p>对于定义的类，JVM在将其编译成class文件时，会将class文件的访问标志的第11位设置为1 。第11位叫做ACC_SUPER标志位；</p></blockquote><blockquote><p>对于定义的接口，JVM在将其编译成class文件时，会将class文件的访问标志的第8位 设置为 1 。第8位叫做ACC_INTERFACE标志位；</p></blockquote><h4>b. 访问权限：public类型和包package类型。</h4><p>如果类或者接口被声明为public类型的，那么，JVM将其编译成class文件时，会将class文件的访问标志的第16位设置为1 。第16位叫做ACC_PUBLIC标志符；</p><h4>c. 类是否为抽象类型的，即我们定义的类有没有被abstract关键字修饰，即我们定义的类是否为抽象类。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;......&#125;</span><br></pre></td></tr></table></figure><p>定义某个类时，JVM将它编译成class文件的时候，会将class文件的访问标志的第7位设置为1 。第7位叫做ACC_ABSTRACT标志位。</p><p>另外值得注意的是，对于定义的接口，JVM在编译接口的时候也会对class文件的访问标志上的ACC_ABSTRACT标志位设置为 1；</p><h4>d. 该类是否被声明了final类型,即表示该类不能被继承。</h4><p>此时JVM会在编译class文件的过程中，会将class文件的访问标志的第12位设置为 1 。第12位叫做ACC_FINAL标志位；</p><h4>e.是否是JVM通过java源代码文件编译而成的</h4><p>如果我们这个class文件不是JVM通过java源代码文件编译而成的，而是用户自己通过class文件的组织规则生成的，那么，一般会对class文件的访问标志第4位设置为 1 。通过JVM编译源代码产生的class文件此标志位为 0，第4位叫做ACC_SYNTHETIC标志位；</p><h4>f. 枚举类</h4><p>对于定义的枚举类如：public enum EnumTest{…}，JVM也会对此枚举类编译成class文件，这时，对于这样的class文件，JVM会对访问标志第2位设置为 1 ，以表示它是枚举类。第2位叫做ACC_ENUM标志位；</p><h4>g. 注解类</h4><p>对于定义的注解类如：public @interface{…},JVM会对此注解类编译成class文件，对于这样的class文件，JVM会将访问标志第3位设置为1，以表示这是个注解类，第3位叫做ACC_ANNOTATION标志位。</p><p>当JVM确定了上述标志位的值后，就可以确定访问标志（access_flags）的值了。实际上JVM上述标志会根据上述确定的标志位的值，对这些标志位的值取或，便得到了访问标志（access_flags）。如下图所示:</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97" alt="image"></p><h4>举例</h4><p>定义一个最简单的类Simple.java，使用编译器编译成class文件，然后观察class文件中的访问标志的值，以及使用javap -v Simple 查看访问标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用UltraEdit查看编译成的class文件，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%972" alt="image"></p><p>上述的图中黄色部分表示的是常量池部分,常量池后面紧跟着就是访问标志，它的十六进制值为0x0021,二进制的值为：00000000 00100001，由二进制的1的位数可以得出第11、16位为1，分别对应ACC_SUPER标志位和ACC_PUBLIC标志位。验证一下:</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%973" alt="image"></p><h2>3. 类索引(this_class)是什么？</h2><p>我们知道一般情况下一个Java类源文件经过JVM编译会生成一个class文件，也有可能一个Java类源文件中定义了其他类或者内部类，这样编译出来的class文件就不止一个，但每一个class文件表示某一个类，至于这个class表示哪一个类，便可以通过 类索引 这个数据项来确定。JVM通过类的完全限定名确定是某一个类。</p><p><strong>类索引的作用，就是为了指出class文件所描述的这个类叫什么名字。</strong></p><p>类索引紧接着访问标志的后面，占有两个字节，在这两个字节中存储的值是一个指向常量池的一个索引，该索引指向的是CONSTANT_Class_info常量池项.</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%951" alt="image"></p><p>以上面定义的Simple.class 为例，如下图所示，查看他的类索引在什么位置和取什么值。</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%952" alt="image"></p><p>由上可知，它的类索引值为0x0001,那么，它指向了常量池中的第一个常量池项，那我们再看一下常量池中的信息。使用javap -v Simple,常量池中有以下信息：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%953" alt="image"></p><p>可以看到常量池中的第一项是CONSTANT_Class_info项，它表示一个&quot;com/louis/jvm/Simple&quot;的类名。即类索引是告诉我们这个class文件所表示的是哪一个类。</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%954" alt="image"></p><h2>4. 父类索引(super_class)是什么？</h2><p>Java支持单继承模式，除了java.lang.Object 类除外，每一个类都会有且只有一个父类。class文件中紧接着类索引(this_class)之后的两个字节区域表示父类索引，跟类索引一样，父类索引这两个字节中的值指向了常量池中的某个常量池项CONSTANT_Class_info，表示该class表示的类是继承自哪一个类。</p><p><img src="http://javajvm.oursnail.cn/%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95" alt="image"></p><h2>5. 接口索引集合(interfaces)是什么？</h2><p>一个类可以不实现任何接口，也可以实现很多个接口，为了表示当前类实现的接口信息，class文件使用了如下结构体描述某个类的接口实现信息:</p><p><img src="http://javajvm.oursnail.cn/%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95" alt="image"></p><p>由于类实现的接口数目不确定，所以接口索引集合的描述的前部分叫做接口计数器（interfaces_count），接口计数器占用两个字节，其中的值表示着这个类实现了多少个接口，紧跟着接口计数器的部分就是接口索引部分了，每一个接口索引占有两个字节，接口计数器的值代表着后面跟着的接口索引的个数。接口索引和类索引和父类索引一样，其内的值存储的是指向了常量池中的常量池项的索引，表示着这个接口的完全限定名。</p><p><strong>举例：</strong></p><p>定义一个Worker接口，然后类Programmer实现这个Worker接口，然后我们观察Programmer的接口索引集合是怎样表示的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">implements</span> <span class="title">Worker</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I'm Programmer,Just coding...."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%954" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲完了class文件中的常量池，我们就相当于克服了class文件中最麻烦的模块了。现在，我们来看一下class文件中紧接着常量池后面的几个东西：访问标志、类索引、父类索引、接口索引集合。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读2-Class文件中的常量池</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB2-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读2-Class文件中的常量池/</id>
    <published>2019-02-09T11:35:04.972Z</published>
    <updated>2019-02-09T11:35:16.666Z</updated>
    
    <content type="html"><![CDATA[<p>上一节Class类文件结构大致地介绍了class文件的组织结构，接下来，我们将深入每一个结构，来详细了解它们。这一章节呢，我们就来扒一扒class文件中非常重要 的一个数据区域------常量池。它在JVM虚拟机中扮演了非常重要的地位。</p><a id="more"></a><p>本篇内容来自于<a href="http://blog.csdn.net/luanlouis/article/details/40148053" target="_blank" rel="noopener">java虚拟机原理图解</a>，自己一边理解一边进行复制整理得此文章，<strong>也是看了很多遍，逐渐地好像懂了常量池怎么玩的，所以一定要坚持，读不懂多读几遍一定可以读懂的。</strong></p><p>本篇文章内容过多，这里将目录列举在此。</p><blockquote><ol><li>常量池是什么</li><li>常量池在class文件的什么位置？</li><li>常量池里面是怎么组织的？</li><li>常量池项 (cp_info) 的结构是什么？</li><li>常量池能够表示哪些信息？</li><li>int和float数据类型的常量在常量池中是怎样表示和存储的？</li><li>long和 double数据类型的常量在常量池中是怎样表示和存储的？</li><li>String类型的字符串常量在常量池中是怎样表示和存储的？</li><li>类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？</li><li>类中引用到的field字段在常量池中是怎样描述的？</li><li>类中引用到的method方法在常量池中是怎样描述的？</li><li>类中引用到某个接口中定义的method方法在常量池中是怎样描述的？</li><li>更好地支持动态语言所增加的三项</li></ol></blockquote><hr><h2>1. 常量池是什么</h2><p>可以理解为class文件之中的资源仓库，它是class文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据项目之一，同时它还是class文件中第一个出现表类型的数据项目．</p><p>由于常量池的数量是不固定的，所以在常量池入口需要放置一项u2（即２个字节）类型的数据，代表常量池容量计数值（constant-pool-count）(从１开始，将０表示不引用任何常量).</p><p>常量池中主要存放两大类常量：<strong>字面量（Literal）和符号引用(Synbolic Reference)</strong>．</p><p>字面量：比较接近于Java语言层面的常量概念，如文本字符串，声明为final的常量值.</p><p>符号引用：包括如下三类常量：</p><blockquote><ol><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ol></blockquote><h2>2. 常量池在class文件的什么位置？</h2><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BD%8D%E7%BD%AE" alt="image"></p><h2>3. 常量池的里面是怎么组织的？</h2><p>常量池的组织很简单，前端的两个字节占有的位置叫做常量池计数器(constant_pool_count)，它记录着常量池的组成元素  常量池项(cp_info) 的个数。紧接着会排列着constant_pool_count-1个常量池项(cp_info)。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%84%E7%BB%87" alt="image"></p><h2>4. 常量池项 (cp_info) 的结构是什么？</h2><p>每个常量池项(cp_info) 都会对应记录着class文件中的某种类型的字面量。让我们先来了解一下常量池项(cp_info)的结构吧：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%93%E6%9E%84" alt="image"></p><p>JVM虚拟机规定了不同的tag值和不同类型的字面量对应关系如下：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%842" alt="image"></p><p>所以根据cp_info中的tag 不同的值，可以将cp_info 更细化为以下结构体：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%843" alt="image"></p><p>现在让我们看一下细化了的常量池的结构会是类似下图所示的样子：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%844" alt="image"></p><h2>5. 常量池能够表示那些信息？</h2><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%83%BD%E5%A4%9F%E8%A1%A8%E7%A4%BA%E9%82%A3%E4%BA%9B%E4%BF%A1%E6%81%AF" alt="image"></p><h2>6. int和float数据类型的常量在常量池中是怎样表示和存储的？(CONSTANT_Integer_info, CONSTANT_Float_info)</h2><p>Java语言规范规定了 int类型和Float 类型的数据类型占用 4 个字节的空间。那么存在于class字节码文件中的该类型的常量是如何存储的呢？相应地，在常量池中，将 int和Float类型的常量分别使用CONSTANT_Integer_info和 Constant_float_info表示，他们的结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" alt="image"></p><p>举例：建下面的类 IntAndFloatTest.java，在这个类中，我们声明了五个变量，但是取值就两种int类型的10 和Float类型的11f.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntAndFloatTest</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> c = <span class="number">11f</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> d = <span class="number">11f</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> e = <span class="number">11f</span>;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用编译器编译成IntAndFloatTest.class字节码文件，我们通过javap -v IntAndFloatTest 指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了两次10 和三次11f，但是常量池中，就只有一个常量10 和一个常量11f,如下图所示:</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2" alt="image"></p><p>从结果上可以看到常量池第#8 个常量池项(cp_info) 就是CONSTANT_Integer_info,值为10；第#23个常量池项(cp_info) 就是CONSTANT_Float_info,值为11f。</p><p>代码中所有用到 int 类型 10 的地方，会使用指向常量池的指针值#8 定位到第#8 个常量池项(cp_info)，即值为 10的结构体 CONSTANT_Integer_info，而用到float类型的11f时，也会指向常量池的指针值#23来定位到第#23个常量池项(cp_info) 即值为11f的结构体CONSTANT_Float_info。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B3" alt="image"></p><h2>7. long和 double数据类型的常量在常量池中是怎样表示和存储的？(CONSTANT_Long_info、CONSTANT_Double_info )</h2><p>Java语言规范规定了 long 类型和 double类型的数据类型占用8 个字节的空间。那么存在于class 字节码文件中的该类型的常量是如何存储的呢？相应地，在常量池中，将long和double类型的常量分别使用CONSTANT_Long_info和Constant_Double_info表示，他们的结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/long%E5%92%8C%20double%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" alt="image"></p><p>代码中所有用到 long 类型-6076574518398440533L 的地方，会使用指向常量池的指针值#18 定位到第 #18 个常量池项(cp_info)，即值为-6076574518398440533L 的结构体CONSTANT_Long_info，而用到double类型的10.1234567890D时，也会指向常量池的指针值#26 来定位到第 #26 个常量池项(cp_info) 即值为10.1234567890D的结构体CONSTANT_Double_info。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/long%E5%92%8C%20double%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2" alt="image"></p><h2>8. String类型的字符串常量在常量池中是怎样表示和存储的？（CONSTANT_String_info、CONSTANT_Utf8_info）</h2><p>对于字符串而言，JVM会将字符串类型的字面量以UTF-8 编码格式存储到在class字节码文件中。这么说可能有点摸不着北，我们先从直观的Java源码中中出现的用双引号&quot;&quot; 括起来的字符串来看，在编译器编译的时候，都会将这些字符串转换成CONSTANT_String_info结构体，然后放置于常量池中。其结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B" alt="image"></p><p>如上图所示的结构体，CONSTANT_String_info结构体中的string_index的值指向了CONSTANT_Utf8_info结构体，而字符串的utf-8编码数据就在这个结构体之中。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B" alt="image"></p><p>请看一例，定义一个简单的StringTest.java类，然后在这个类里加一个&quot;JVM原理&quot; 字符串，然后，我们来看看它在class文件中是怎样组织的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String s1 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s2 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s3 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s4 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B3" alt="image"></p><p>在上面的图中，我们可以看到CONSTANT_String_info结构体位于常量池的第#15个索引位置。而存放&quot;Java虚拟机原理&quot; 字符串的 UTF-8编码格式的字节数组被放到CONSTANT_Utf8_info结构体中，该结构体位于常量池的第#16个索引位置。上面的图只是看了个轮廓，让我们再深入地看一下它们的组织吧。请看下图：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B4" alt="image"></p><h2>9. 类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？(CONSTANT_Class_info)</h2><p>JVM会将某个Java 类中所有使用到了的类的完全限定名 以二进制形式的完全限定名 封装成CONSTANT_Class_info结构体中，然后将其放置到常量池里。CONSTANT_Class_info 的tag值为 7 。其结构如下：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B61" alt="image"></p><p><strong>类的完全限定名和二进制形式的完全限定名</strong></p><p>在某个Java源码中，我们会使用很多个类，比如我们定义了一个 ClassTest的类，并把它放到com.louis.jvm 包下，则 ClassTest类的完全限定名为com.louis.jvm.ClassTest，将JVM编译器将类编译成class文件后，此完全限定名在class文件中，是以二进制形式的完全限定名存储的，即它会把完全限定符的&quot;.“换成”/&quot; ，即在class文件中存储的 ClassTest类的完全限定名称是&quot;com/louis/jvm/ClassTest&quot;。因为这种形式的完全限定名是放在了class二进制形式的字节码文件中，所以就称之为 二进制形式的完全限定名。</p><p>举例，我们定义一个很简单的ClassTest类，来看一下常量池是怎么对类的完全限定名进行存储的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Date date =<span class="keyword">new</span> Date();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B62" alt="image"></p><p>如上图所示，在ClassTest.class文件的常量池中，共有 3 个CONSTANT_Class_info结构体，分别表示ClassTest 中用到的Class信息。 我们就看其中一个表示com/jvm.ClassTest的CONSTANT_Class_info 结构体。它在常量池中的位置是#1，它的name_index值为#2，它指向了常量池的第2 个常量池项，如下所示:</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B63" alt="image"></p><p>注意：</p><p>对于某个类而言，其class文件中至少要有两个CONSTANT_Class_info常量池项，用来表示自己的类信息和其父类信息。(除了java.lang.Object类除外，其他的任何类都会默认继承自java.lang.Object）如果类声明实现了某些接口，那么接口的信息也会生成对应的CONSTANT_Class_info常量池项。</p><p>除此之外，如果在类中使用到了其他的类，只有真正使用到了相应的类，JDK编译器才会将类的信息组成CONSTANT_Class_info常量池项放置到常量池中。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Date date;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Other</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        Date da;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的Other的类，在JDK将其编译成class文件时，常量池中并没有java.util.Date对应的CONSTANT_Class_info常量池项，为什么呢?</p><p>在Other类中虽然定义了Date类型的两个变量date、da，但是JDK编译的时候，认为你只是声明了“Ljava/util/Date”类型的变量，并没有实际使用到Ljava/util/Date类。将类信息放置到常量池中的目的，是为了在后续的代码中有可能会反复用到它。很显然，JDK在编译Other类的时候，会解析到Date类有没有用到，发现该类在代码中就没有用到过，所以就认为没有必要将它的信息放置到常量池中了。</p><p>将上述的Other类改写一下，仅使用new Date()，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Other</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Date();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ol><li>对于某个类或接口而言，其自身、父类和继承或实现的接口的信息会被直接组装成CONSTANT_Class_info常量池项放置到常量池中；</li><li>类中或接口中使用到了其他的类，只有在类中实际使用到了该类时，该类的信息才会在常量池中有对应的CONSTANT_Class_info常量池项；</li><li>类中或接口中仅仅定义某种类型的变量，JDK只会将变量的类型描述信息以UTF-8字符串组成CONSTANT_Utf8_info常量池项放置到常量池中，上面在类中的private Date date;JDK编译器只会将表示date的数据类型的“Ljava/util/Date”字符串放置到常量池中。</li></ol></blockquote><h2>10. 类中引用到的field字段在常量池中是怎样描述的？(CONSTANT_Fieldref_info, CONSTANT_Name_Type_info)</h2><p>一般而言，我们在定义类的过程中会定义一些 field 字段，然后会在这个类的其他地方（如方法中）使用到它。有可能我们在类的方法中只使用field字段一次，也有可能我们会在类定义的方法中使用它很多很多次。</p><p>举一个简单的例子，我们定一个叫Person的简单java bean，它有name和age两个field字段，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面定义的类中，我们在Person类中的一系列方法里，多次引用到namefield字段 和agefield字段，对于JVM编译器而言，name和age只是一个符号而已，并且它在由于它可能会在此类中重复出现多次，所以JVM把它当作常量来看待，将name和age以field字段常量的形式保存到常量池中。</p><p>将它name和age封装成 CONSTANT_Fieldref_info 常量池项，放到常量池中，在类中引用到它的地方，直接放置一个指向field字段所在常量池的索引。</p><p>上面的Person类，使用javap -v Person指令，查看class文件的信息，你会看到，在Person类中引用到age和namefield字段的地方，都是指向了常量池中age和namefield字段对应的常量池项中。表示field字段的常量池项叫做CONSTANT_Fieldref_info。</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B51" alt="image"></p><p>怎样描述某一个field字段的引用？</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B52" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B53" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B54" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B55" alt="image"></p><p>实例解析： 现在，让我们来看一下Person类中定义的namefield字段在常量池中的表示。通过使用javap -v Person会查看到如下的常量池信息：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B56" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B57" alt="image"></p><p>请读者看上图中namefield字段的数据类型，它在#6个常量池项，以UTF-8编码格式的字符串“Ljava/lang/String;” 表示，这表示着这个field 字段是java.lang.String 类型的。关于field字段的数据类型，class文件中存储的方式和我们在源码中声明的有些不一样。请看下图的对应关系：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B58" alt="image"></p><p><strong>注意：</strong></p><p>如果我们在类中定义了field 字段，但是没有在类中的其他地方用到这些字段，它是不会被编译器放到常量池中的。</p><p>只有在类中的其他地方引用到了，才会将他放到常量池中。</p><h2>11. 类中引用到的method方法在常量池中是怎样描述的？(CONSTANT_Methodref_info, CONSTANT_Name_Type_info)</h2><h3>1. 举例</h3><p>还是以Person类为例。在Person类中，我们定义了setName(String name)、getName()、setAge(int age)、getAge()这些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们定义了方法，但是这些方法没有在类总的其他地方被用到（即没有在类中其他的方法中引用到），所以它们的方法引用信息并不会放到常量中。</p><p>现在我们在类中加一个方法 getInfo()，调用了getName()和getAge() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> getName()+<span class="string">"\t"</span>+getAge();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候JVM编译器会将getName()和getAge()方法的引用信息包装成CONSTANT_Methodref_info结构体放入到常量池之中。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%951" alt="image"></p><p>这里的方法调用的方式牵涉到Java非常重要的一个术语和机制，叫动态绑定。这个动态绑定问题以后在单独谈谈。</p><h3>2. 表示一个方法引用</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%952" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%953" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%954" alt="image"></p><h3>3. 方法描述符的组成</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%955" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%956" alt="image"></p><h3>4. getName() 方法引用在常量池中的表示</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%957" alt="image"></p><h2>12. 类中引用到某个接口中定义的method方法在常量池中是怎样描述的？(CONSTANT_InterfaceMethodref_info, CONSTANT_Name_Type_info)</h2><p>当我们在某个类中使用到了某个接口中的方法，JVM会将用到的接口中的方法信息方知道这个类的常量池中。<br>比如我们定义了一个Worker接口，和一个Boss类，在Boss类中调用了Worker接口中的方法，这时候在Boss类的常量池中会有Worker接口的方法的引用表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">(Worker worker)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        worker.work();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84method%E6%96%B9%E6%B3%951" alt="image"></p><p>如上图所示，在Boss类的makeMoney()方法中调用了Worker接口的work()方法，机器指令是通过invokeinterface指令完成的，invokeinterface指令后面的操作数，是指向了Boss常量池中Worker接口的work()方法描述，表示的意思就是：“我要调用Worker接口的work()方法”。</p><p>Worker接口的work()方法引用信息，JVM会使用CONSTANT_InterfaceMethodref_info结构体来描述，CONSTANT_InterfaceMethodref_info定义如下：</p><p><img src="http://javajvm.oursnail.cn/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84method%E6%96%B9%E6%B3%952" alt="image"></p><p>CONSTANT_InterfaceMethodref_info结构体和上面介绍的CONSTANT_Methodref_info 结构体很基本上相同，它们的不同点只有：</p><blockquote><ol><li>CONSTANT_InterfaceMethodref_info 的tag 值为11，而CONSTANT_Methodref_info的tag值为10；</li></ol></blockquote><blockquote><ol start="2"><li>CONSTANT_InterfaceMethodref_info 描述的是接口中定义的方法，而CONSTANT_Methodref_info描述的是实例类中的方法；</li></ol></blockquote><p>其他的基本与上面一个一毛一样。参照上面个理解即可。</p><h2>13. CONSTANT_MethodType_info，CONSTANT_MethodHandle_info，CONSTANT_InvokeDynamic_info</h2><p>这三项主要是为了让Java语言支持动态语言特性而在Java 7 版本中新增的三个常量池项，只会在极其特别的情况能用到它，在class文件中几乎不会生成这三个常量池项。   其实我花了一些时间来研究这三项，并且想通过各种方式生成这三项，不过没有成功，最后搞的还是迷迷糊糊的。从我了解到的信息来看，Java 7对动态语言的支持很笨拙，并且当前没有什么应用价值，然后就对着三项的研究先放一放了。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一节Class类文件结构大致地介绍了class文件的组织结构，接下来，我们将深入每一个结构，来详细了解它们。这一章节呢，我们就来扒一扒class文件中非常重要 的一个数据区域------常量池。它在JVM虚拟机中扮演了非常重要的地位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>补充阅读1-Class类文件结构</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB-Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/02/09/JVM/补充阅读-Class类文件结构/</id>
    <published>2019-02-09T11:32:35.940Z</published>
    <updated>2019-02-09T11:33:03.051Z</updated>
    
    <content type="html"><![CDATA[<p>总体概览一下Class文件是什么以及有什么。</p><a id="more"></a><h2>整体感知</h2><p><code>class</code>文件是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得<code>class</code>文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间。 我们的Java源文件， 在被编译之后， 每个类（或者接口）都单独占据一个<code>class</code>文件， 并且类中的所有信息都会在<code>class</code>文件中有相应的描述， 由于<code>class</code>文件很灵活， 它甚至比Java源文件有着更强的描述能力。</p><h2>Class文件格式</h2><p><img src="http://javajvm.oursnail.cn/Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="image"></p><p><strong>换成表格的形式：</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count - 1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h3>NO1. 魔数(magic)</h3><p>所有的由Java编译器编译而成的class文件的前4个字节都是“0xCAFEBABE”</p><p>它的作用在于：</p><blockquote><p>当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。</p></blockquote><h3>NO2.版本号(minor_version,major_version)</h3><p>主版本号和次版本号在class文件中各占两个字节，<strong>副版本号占用第5、6两个字节，而主版本号则占用第7，8两个字节</strong>。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51,对应的7，8个字节的十六进制的值应该是 0x33。</p><p>JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版本号，如果JVM本身的版本号小于class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的<code>&quot;java.lang.UnsupportedClassVersionError: Bad version number in .class file &quot; Error</code>错误；反之，JVM会认为可以加载此class文件，继续加载此class文件。</p><h3>NO3.常量池计数器(constant_pool_count)</h3><p>常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。 常量池是由一组<code>constant_pool</code>结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器<code>constant_pool_count</code> 的值等于<code>constant_pool</code>表中的成员数+ 1。<code>constant_pool</code>表的索引值只有在大于 0 且小于<code>constant_pool_count</code>时(即1~(constant_pool_count-1))才会被认为是有效的。</p><p>这个容量计数是从1而不是从0开始的，如果常量池容量为十六进制数0x0016，即十进制22，这就代表着常量池中有21个常量，索引值范围为1-21。在Class文件格式规范制定时，设计者将第0项常量空出来是有特殊考虑的，用于在特定情况下表达“不引用任何一个常量池项目”。</p><h3>NO4.常量池数据区(constant_pool[contstant_pool_count-1])</h3><p>常量池，constant_pool是一种表结构,它包含 Class 文件结构及其子结构中引用的所有字符串常量、 类或接口名、字段名和其它常量。 常量池中的每一项都具备相同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，称为 “tag byte” 。常量池的索引范围是 1 至constant_pool_count−1。常量池的具体细节我们会稍后讨论。</p><h3>NO6.访问标志(access_flags)</h3><p>访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="image"></p><h3>NO7.类索引(this_class)</h3><p>类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类或接口。</p><h3>NO8.父类索引(super_class)</h3><p>父类索引，对于类来说，super_class 的值必须为 0 或者是对constant_pool 表中项目的一个有效索引值。如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的access_flag 中都不能带有ACC_FINAL 标记。对于接口来说，它的Class文件的super_class项的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是java.lang.Object类，只有它是唯一没有父类的类。</p><h3>NO9.接口计数器(interfaces_count)</h3><p>接口计数器，interfaces_count的值表示当前类或接口的直接父接口数量。</p><h3>NO10.接口信息数据区(interfaces[interfaces_count])</h3><p>接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员 interfaces[i]  必须为 CONSTANT_Class_info类型常量，其中 0 ≤ i &lt;interfaces_count。在interfaces[]数组中，成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><h3>NO11.字段计数器(fields_count)</h3><p>字段计数器，fields_count的值表示当前 Class 文件 fields[]数组的成员个数。 fields[]数组中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。</p><h3>NO12.字段信息数据区(fields[fields_count])</h3><p>字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接口继承的部分。</p><h3>NO13.方法计数器(methods_count)</h3><p>方法计数器， methods_count的值表示当前Class 文件 methods[]数组的成员个数。Methods[]数组中每一项都是一个 method_info 结构的数据项。</p><h3>NO14.方法信息数据区(methods[methods_count])</h3><p>方法表，methods[] 数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。如果某个method_info 结构的access_flags 项既没有设置 ACC_NATIVE 标志也没有设置ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需要引用其它类。 method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法方法和类或接口初始化方法方法 。methods[]数组只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。</p><h3>NO15.属性计数器(attributes_count)</h3><p>属性计数器，attributes_count的值表示当前 Class 文件attributes表的成员个数。attributes表中每一项都是一个attribute_info 结构的数据项。</p><h3>NO16.属性信息数据区(attributes[attributes_count])</h3><p>属性表，attributes 表的每个项的值必须是attribute_info结构。</p><p>在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性： InnerClasses  、 EnclosingMethod 、 Synthetic  、Signature、SourceFile，SourceDebugExtension 、Deprecated、RuntimeVisibleAnnotations 、RuntimeInvisibleAnnotations以及BootstrapMethods属性。</p><p>对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取attributes表中的Signature、RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。Java 7 规范 要求任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 （甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总体概览一下Class文件是什么以及有什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>内存分配和回收策略</title>
    <link href="http://yoursite.com/2019/02/09/JVM/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/02/09/JVM/内存分配和回收策略/</id>
    <published>2019-02-09T11:16:03.990Z</published>
    <updated>2019-02-09T11:26:05.405Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十篇文章，本章对内存分配和垃圾回收的细节再次详细说明一下，并且说明一下逃逸分析/栈上分配以及TLAB两种方式的概念和原理。</p><a id="more"></a><h2>1. 对象优先在Eden分配</h2><p><strong>前面文章曾介绍HotSpot虚拟机新生代内存布局及算法:</strong></p><blockquote><p>（1）、将新生代内存分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间；</p><p>（2）、每次使用<code>Eden</code>和其中一块<code>Survivor</code>；</p><p>（3）、当回收时，将<code>Eden</code>和使用中的<code>Survivor</code>中还存活的对象一次性复制到另外一块<code>Survivor</code>；</p><p>（4）、而后清理掉<code>Eden</code>和使用过的<code>Survivor</code>空间；</p><p>（5）、后面就使用<code>Eden</code>和复制到的那一块<code>Survivor</code>空间，重复步骤3；</p></blockquote><p>默认<code>Eden：Survivor=8:1</code>，即每次可以使用90%的空间，只有一块<code>Survivor</code>的空间被浪费；</p><p>大多数情况下，对象在新生代<code>Eden</code>区中分配；</p><p>当<code>Eden</code>区没有足够空间进行分配时，JVM将发起一次<code>Minor GC</code>（新生代GC）；</p><p><code>Minor GC</code>时，如果发现存活的对象无法全部放入<code>Survivor</code>空间，只好通过分配担保机制提前转移到老年代。</p><h2>2. 大对象直接进入老年代</h2><p>大对象指需要大量连续内存空间的Java对象，如，很长的字符串、数组；</p><p>经常出现大对象容易导致内存还有不少空间就提前触发GC,以获取足够的连续空间来存放它们，所以应该尽量避免使用创建大对象；</p><p><code>-XX:PretenureSizeThreshold</code>：</p><p><strong>可以设置这个阈值，大于这个参数值的对象直接在老年代分配；</strong></p><p>默认为0（无效），且只对<code>Serail</code>和<code>ParNew</code>两款收集器有效；</p><p>如果需要使用该参数，可考虑<code>ParNew+CMS</code>组合。</p><h2>3. 长期存活的对象将进入老年代</h2><p>JVM给每个对象定义一个对象年龄计数器，其计算流程如下：</p><blockquote><p>在<code>Eden</code>中分配的对象，经<code>Minor GC</code>后还存活，就复制移动到<code>Survivor</code>区，年龄为1；</p><p>而后每经一次<code>Minor GC</code>后还存活，在<code>Survivor</code>区复制移动一次，年龄就增加1岁；</p><p>如果年龄达到一定程度，就晋升到老年代中；</p></blockquote><p><code>-XX:MaxTenuringThreshold</code>：</p><p><strong>设置新生代对象晋升老年代的年龄阈值，默认为15；</strong></p><h2>4. 动态对象年龄判定</h2><p>JVM为更好适应不同程序，不是永远要求等到<code>MaxTenuringThreshold</code>中设置的年龄；</p><p>如果在<code>Survivor</code>空间中相同年龄的所有对象大小总和大于<code>Survivor</code>空间的一半，大于或等于该年龄的对象就可以直接进入老年代</p><h2>5. 空间分配担保</h2><p>在前面曾简单介绍过分配担保：</p><p>当<code>Survivor</code>空间不够用时，需要依赖其他内存（老年代）进行分配担保（<code>Handle Promotion</code>）；</p><p><strong>分配担保的流程如下：</strong></p><blockquote><p>在发生<code>Minor GC</code>前，JVM先检查老年代最大可用的连续空间是否大于新生所有对象空间；</p></blockquote><blockquote><p>如果大于，那可以确保<code>Minor GC</code>是安全的；</p></blockquote><blockquote><p>如果不大于，则<code>JVM</code>查看<code>HandlePromotionFailure</code>值是否允许担保失败；</p></blockquote><blockquote><p>如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小；</p></blockquote><blockquote><p>如果大于，将尝试进行一次<code>Minor GC</code>，但这是有风险的；</p></blockquote><blockquote><p>如果小于或<code>HandlePromotionFailure</code>值不允许冒险，那这些也要改为进行一次<code>Full GC</code>；</p></blockquote><p><strong>尝试<code>Minor GC</code>的风险–担保失败：</strong></p><blockquote><p>因为尝试<code>Minor GC</code>前面，无法知道存活的对象大小，所以使用历次晋升到老年代对象的平均大小作为经验值；</p><p>假如尝试的<code>Minor GC</code>最终存活的对象远远高于经验值的话，会导致担保失败（<code>Handle Promotion Failure</code>）；</p><p>失败后只有重新发起一次<code>Full GC</code>，这绕了一个大圈，代价较高；</p></blockquote><p><strong>但一般还是要开启<code>HandlePromotionFailure</code>，避免<code>Full GC</code>过于频繁，而且担保失败概率还是比较低的；</strong></p><p><strong>JDK6-u24后，JVM代码中已经不再使用<code>HandlePromotionFailure</code>参数了；</strong></p><p>规则变为：</p><p>⭐⭐⭐<strong>只要老年代最大可用的连续空间大于新生所有对象空间或历次晋升到老年代对象的平均大小，就会进行<code>Minor GC</code>；否则进行<code>Full GC</code>；</strong></p><p>⭐⭐⭐即老年代最大可用的连续空间小于新生所有对象空间时，不再检查<code>HandelPromotionFailure</code>，而直接检查历次晋升到老年代对象的平均大小；</p><h2>6. 逃逸分析</h2><p>般认为new出来的对象都是被分配在堆上，但是这个结论不是那么的绝对，通过对Java对象分配的过程分析，可以知道有两个地方会导致Java中new出来的对象并不一定分配在所认为的堆上。这两个点分别是Java中的逃逸分析和<code>TLAB</code>（<code>Thread Local Allocation Buffer</code>）。</p><h5>6.1 什么是栈上分配？</h5><p>栈上分配主要是指在Java程序的执行过程中，<strong>在方法体中声明的变量以及创建的对象，将直接从该线程所使用的栈中分配空间</strong>。</p><p>一般而言，创建对象都是从堆中来分配的，这里是指在栈上来分配空间给新创建的对象。</p><h5>6.2 什么是逃逸？</h5><p>逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；</p><p>这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。</p><p>正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；而此时由于无法回收，即成为逃逸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> V global_v;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> V v=b_method();  </span><br><span class="line"> c_method();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">b_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> V v=<span class="keyword">new</span> V();  </span><br><span class="line"> <span class="keyword">return</span> v;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> global_v=<span class="keyword">new</span> V();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>b_method</code>方法内部生成的V对象的引用被返回给<code>a_method</code>方法内的变量v，<code>c_method</code>方法内生成的V对象被赋给了全局变量<code>global_v</code>。这两种场景都发生了（引用）逃逸。</p><h5>6.3 逃逸分析</h5><p>在JDK 6之后支持对象的栈上分析和逃逸分析，在JDK7中完全支持栈上分配对象。其是否打开逃逸分析依赖于以下JVM的设置：</p><blockquote><p><code>-XX:+DoEscapeAnalysis</code></p></blockquote><h5>6.4 栈上分配与逃逸分析的关系</h5><p>进行逃逸分析之后，产生的后果是所有的对象都将由栈上分配，而非从JVM内存模型中的堆来分配。</p><h5>6.5 逃逸分析／栈上分配的优劣分析</h5><p>JVM在<code>Server</code>模式下的逃逸分析可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配，由于该对象一定是局部的，所以栈上分配不会有问题。</p><blockquote><p>消除同步。</p></blockquote><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。</p><blockquote><p>矢量替代。</p></blockquote><p>逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。</p><blockquote><p>劣势：</p></blockquote><p>栈上分配受限于栈的空间大小，一般自我迭代类的需求以及大的对象空间需求操作，将导致栈的内存溢出；故只适用于一定范围之内的内存范围请求。</p><h5>6.6 测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//会发生逃逸</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            x = (++counter);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">10</span>; ++i) &#123;  </span><br><span class="line">            Foo foo = <span class="keyword">new</span> Foo();  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();  </span><br><span class="line">        System.out.println(<span class="string">"Time cost is "</span> + (end - start));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未开启逃逸分析设置为：</p><blockquote><p>-server -verbose:gc</p></blockquote><p>在未开启逃逸分析的状况下运行情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC 5376K-&gt;427K(63872K), 0.0006051 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(63872K), 0.0003928 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(63872K), 0.0003639 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(69248K), 0.0003770 secs]  </span><br><span class="line">[GC 11179K-&gt;427K(69248K), 0.0003987 secs]  </span><br><span class="line">[GC 11179K-&gt;427K(79552K), 0.0003817 secs]  </span><br><span class="line">[GC 21931K-&gt;399K(79552K), 0.0004342 secs]  </span><br><span class="line">[GC 21903K-&gt;399K(101120K), 0.0002175 secs]  </span><br><span class="line">[GC 43343K-&gt;399K(101184K), 0.0001421 secs]  </span><br><span class="line">Time cost is 58514571</span><br></pre></td></tr></table></figure><p>开启逃逸分析设置为：</p><blockquote><p>-server -verbose:gc -XX:+DoEscapeAnalysis</p></blockquote><p>开启逃逸分析的状况下，运行情况如下：</p><blockquote><p>Time cost is 10031306</p></blockquote><p>未开启逃逸分析时，运行上述代码，JVM执行了GC操作，而在开启逃逸分析情况下，JVM并没有执行GC操作。同时，操作时间上，开启逃逸分析的程序运行时间是未开启逃逸分析时间的1/5。</p><h2>7. 再来聊聊TLAB</h2><p>JVM在内存新生代<code>Eden Space</code>中开辟了一小块线程私有的区域，称作<code>TLAB</code>（<code>Thread-local allocation buffer</code>）。默认设定为占用<code>Eden Space</code>的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且<code>TLAB</code>上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。<br>也就是说，Java中每个线程都会有自己的缓冲区称作<code>TLAB</code>（<code>Thread-local allocation buffer</code>），每个<code>TLAB</code>都只有一个线程可以操作，TLAB结合<code>bump-the-pointer</code>技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。</p><h2>8. 对象内存分配过程再升级</h2><blockquote><ol><li>编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.</li></ol></blockquote><blockquote><ol start="2"><li>如果<code>tlab_top + size &lt;= tlab_end</code>，则在在TLAB上直接分配对象并增加<code>tlab_top</code><br>的值，如果现有的TLAB不足以存放当前对象则3.</li></ol></blockquote><blockquote><ol start="3"><li>重新申请一个<code>TLAB</code>，并再次尝试存放当前对象。如果放不下，则4.</li></ol></blockquote><blockquote><ol start="4"><li>在<code>Eden</code>区加锁（这个区是多线程共享的），如果<code>eden_top + size &lt;= eden_end</code>则将对象存放在<code>Eden</code>区，增加<code>eden_top</code> 的值，如果<code>Eden</code>区不足以存放，则5.</li></ol></blockquote><blockquote><ol start="5"><li>执行一次<code>Young GC</code>（<code>minor collection</code>）。</li></ol></blockquote><blockquote><ol start="6"><li>经过<code>Young GC</code>之后，如果<code>Eden</code>区任然不足以存放当前对象，则直接分配到老年代。</li></ol></blockquote><blockquote><ol start="7"><li>老年代还是不足，则触发Full GC，再不足就OOM错误</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为学习JAVA虚拟机的第十篇文章，本章对内存分配和垃圾回收的细节再次详细说明一下，并且说明一下逃逸分析/栈上分配以及TLAB两种方式的概念和原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
</feed>
