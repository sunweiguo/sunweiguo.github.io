<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>垃圾收集器介绍</title>
      <link href="/2019/02/09/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/02/09/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第九篇文章，主要介绍七种比较经典的垃圾收集器的实现原理。</p><a id="more"></a><h2>垃圾收集器</h2><p><img src="http://xiaozhao.oursnail.cn/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>以上是 <code>HotSpot</code> 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><h3>1. Serial 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p><code>Serial</code> 翻译为串行，垃圾收集和用户程序不能同时执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 <code>CMS</code> 和 <code>G1</code> 之外，其它收集器都是以串行的方式执行。<code>CMS</code> 和 <code>G1</code> 可以使得垃圾收集和用户程序同时执行，被称为并发执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 <code>Client</code> 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。<code>Serial</code> 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h3>2. ParNew 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>它是 <code>Serial</code> 收集器的多线程版本。</p><p>是 <code>Server</code>模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 <code>Serial</code> 收集器，只有它能与 <code>CMS</code> 收集器配合工作。</p><p>默认开始的线程数量与 CPU 数量相同，可以使用 <code>-XX:ParallelGCThreads</code> 参数来设置线程数。</p><h3>3. Parallel Scavenge 收集器</h3><p>与 <code>ParNew</code> 一样是并行的多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 <code>-XX:MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 和 <code>Survivor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（<code>GC Ergonomics</code>）。</p><h3>4. Serial Old 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/SerialOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>是 <code>Serial</code> 收集器的老年代版本，也是给 <code>Client</code> 模式下的虚拟机使用。如果用在 <code>Server</code> 模式下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（<code>Parallel Old</code> 诞生以前）中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li><li>作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li></ul><h3>5. Parallel Old 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>是 <code>Parallel Scavenge</code> 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器。</p><h3>6. CMS 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p><code>CMS</code>（Concurrent Mark Sweep），<code>Mark Sweep</code> 指的是标记 - 清除算法。</p><p>特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 <code>GC Roots</code> 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行<code>GC Roots Tracing</code> 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 <code>-XX:CMSInitiatingOccupancyFraction</code> 来改变触发 <code>CMS</code> 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 <code>Serial Old</code> 来替代 <code>CMS</code>。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code>。</li></ul><h3>7. G1 收集器</h3><p><code>G1</code>（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。<code>HotSpot</code> 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>G1 把新生代和老年代划分成多个大小相等的独立区域（<code>Region</code>），新生代和永久代不再物理隔离。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A82.png" alt="image"></p><p>通过引入 <code>Region</code> 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用来记录该 <code>Region</code> 对象的引用对象所在的 <code>Region</code>。通过使用 <code>Remembered Set</code>，在做可达性分析的时候就可以避免全堆扫描。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A83.jpg" alt="image"></p><p>如果不计算维护 <code>Remembered Set</code> 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 <code>Region</code> 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 <code>Region</code> 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h3>8. 比较</h3><table><thead><tr><th style="text-align:center">收集器</th><th style="text-align:center">串行/并行/并发</th><th style="text-align:center">新生代/老年代</th><th style="text-align:center">收集算法</th><th style="text-align:center">目标</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Serial</strong></td><td style="text-align:center">串行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单 CPU 环境下的 Client 模式</td></tr><tr><td style="text-align:center"><strong>Serial Old</strong></td><td style="text-align:center">串行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单 CPU 环境下的 Client 模式、CMS 的后备预案</td></tr><tr><td style="text-align:center"><strong>ParNew</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr><tr><td style="text-align:center"><strong>Parallel Scavenge</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>Parallel Old</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>CMS</strong></td><td style="text-align:center">并行 + 并发</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-清除</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">集中在互联网站或 B/S 系统服务端上的 Java 应用</td></tr><tr><td style="text-align:center"><strong>G1</strong></td><td style="text-align:center">并行 + 并发</td><td style="text-align:center">新生代 + 老年代</td><td style="text-align:center">标记-整理 + 复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">面向服务端应用，将来替换 CMS</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GC相关</title>
      <link href="/2019/02/09/JVM/GC%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/02/09/JVM/GC%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第八篇文章，我们知道，JVM为我们管理垃圾对象实现自动回收，让我们不需要太关心内存释放问题，一定程度上减少了内存溢出的错误。这一切的背后是如何实现的呢？</p><a id="more"></a><h2>一、垃圾标记算法</h2><h5>1.1 引用计数法</h5><p><strong>算法思想</strong></p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器☞减一；任何时候计数器为0的对象是不可能再被使用的。</p><p><strong>主要缺陷</strong></p><p>无法解决对象间相互循环引用的问题。</p><p><strong>举个例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Test objA = <span class="keyword">new</span> Test();<span class="comment">//count=1</span></span><br><span class="line">    Test objB = <span class="keyword">new</span> Test();<span class="comment">//count=1</span></span><br><span class="line"></span><br><span class="line">        objA.instance = objB;<span class="comment">//count=2</span></span><br><span class="line">        objB.instance = objA;<span class="comment">//count=2</span></span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;<span class="comment">//count=1</span></span><br><span class="line">        objB = <span class="keyword">null</span>;<span class="comment">//count=1</span></span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">testGC();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入参数</strong></p><blockquote><p>-verbose:gc -XX:+PrintGCDetails</p></blockquote><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 6063K-&gt;600K(37888K)] 6063K-&gt;608K(123904K), 0.0037131 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 600K-&gt;0K(37888K)] [ParOldGen: 8K-&gt;529K(86016K)] 608K-&gt;529K(123904K), [Metaspace: 2595K-&gt;2595K(1056768K)], 0.0062705 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 37888K, used 328K [0x00000000d6100000, 0x00000000d8b00000, 0x0000000100000000)</span><br><span class="line">  eden space 32768K, 1% used [0x00000000d6100000,0x00000000d6152030,0x00000000d8100000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d8100000,0x00000000d8100000,0x00000000d8600000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8600000,0x00000000d8600000,0x00000000d8b00000)</span><br><span class="line"> ParOldGen       total 86016K, used 529K [0x0000000082200000, 0x0000000087600000, 0x00000000d6100000)</span><br><span class="line">  object space 86016K, 0% used [0x0000000082200000,0x0000000082284778,0x0000000087600000)</span><br><span class="line"> Metaspace       used 2601K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>日志中6063K-&gt;600K(37888K)，从原来的6M内存变成了600k，表明对象已被回收，从而表明JVM没有使用引用计数算法。Java中使用了可达性分析算法来来判定对象是否存活。</p><h5>1.2 可达性分析算法</h5><p>这个算法的基本思路就是通过一系列的称谓<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径为引用链，当一个对象到<code>GC Roots</code>没有任何引用链时，则证明此对象时不可用的，下面看一下例子：</p><p><img src="http://img.blog.csdn.net/20141102164158981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><p>上面的这张图，对象<code>object5</code>、<code>object6</code>、<code>object7</code>虽然互相没有关联，但是它们到<code>GC Roots</code>是不可达的，所以它们将会被判定为是可回收的对象</p><p>注：Java语言中，可作为<code>GC Roots</code>的对象包括下面几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li><li>活跃线程引用的对象</li></ul><h2>二、Java中的引用类型</h2><p>从JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用，这四种引用的强度一次逐渐减弱</p><ol><li><p>强引用就是指在程序代码之中普遍存在的，类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</p></li><li><p>软引用是用来描述一些还有用但并非需要的对象，对于软引用关联着的对象，在系统将要发生内存异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存异常</p></li><li><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存释放足够，都会回收掉只被弱引用关联的对象</p></li><li><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，对一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p></li></ol><h3>三、两次标记</h3><p>《深入理解java虚拟机》原文：</p><blockquote><p>在java根搜索算法中判断对象的可达性，对于不可达的对象，也并不一定是必须清理。这个时候有一个缓刑期，真正的判断一个对象死亡，至少要经过俩次标记过程：</p><p>如果对象在进行根搜索后发现没有与<code>GC roots</code>相关联的引用链，那他将会第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这俩种情况都视为“没有必要执行”。</p><p>即当一个对象重写了<code>finalize()</code>方法的时候，这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象被放置在<code>F-Queue</code>队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行。这里所谓的执行是指虚拟机会出发这个方法，但不承诺会等待它运行结束。这样做的原因：如果一个对象在<code>finalize()</code>方法中执行缓慢，或者发生了死循环（极端的情况下），将可能会导致<code>F-Queue</code>队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象要在<code>finalize()</code>中成功拯救自己----只要重新与引用链上的任何建立关联即可，那么在第二次标记时它将会被移出“即将回收”的集合；如果对象这时候没有逃脱，就会被回收。</p></blockquote><h5>3.1 finalize的工作原理</h5><p>一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用<code>finalize()</code>，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.所以如果使用<code>finalize()</code>，就可以在垃圾收集期间进行一些重要的清除或清扫工作.</p><h5>3.2 finalize()在什么时候被调用?</h5><ol><li>所有对象被<code>Garbage Collection</code>时自动调用,比如运行<code>System.gc()</code>的时候.</li><li>程序退出时为每个对象调用一次<code>finalize</code>方法。</li><li>显式的调用<code>finalize</code>方法</li></ol><p>这个方法的用途就是：在该对象被回收之前，该对象的<code>finalize()</code>方法会被调用。<strong>这里的回收之前指的就是被标记之后</strong>，问题就出在这里，有没有一种情况就是原本一个对象开始不再上一章所讲的“关系网”（引用链）中，但是当开发者重写了<code>finalize()</code>后，并且将该对象重新加入到了“关系网”中，也就是说该对象对我们还有用，不应该被回收，但是已经被标记啦，怎么办呢？</p><p>针对这个问题，虚拟机的做法是进行两次标记，即<strong>第一次标记不在“关系网”中的对象，并且要判断该对象有没有实现<code>finalize()</code>方法</strong>了，如果没有实现就直接判断该对象可回收。如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它。</p><p><strong>随后就会进行第二次的小规模标记</strong>，如果对象还没有逃脱，在这次被标记的对象就会真正的被回收了。</p><h2>四、垃圾收集算法</h2><h5>4.1 标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（<code>Mark-Sweep</code>）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<strong>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</strong>。</p><p>标记-清除算法的执行过程如图：</p><p><img src="http://bloghello.oursnail.cn/jvm8-1.jpg" alt="image"></p><h5>4.2 复制算法</h5><p>为了解决效率问题，一种称为“复制”（<code>Copying</code>）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<strong>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点</strong>。</p><p>复制算法的执行过程如图：</p><p><img src="http://bloghello.oursnail.cn/jvm8-2.jpg" alt="image"></p><h5>4.3 标记-整理算法</h5><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就<strong>需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法</strong>。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（<code>Mark-Compact</code>）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图</p><p><img src="http://bloghello.oursnail.cn/jvm8-3.jpg" alt="image"></p><h5>4.4 分代收集算法</h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（<code>Generational Collection</code>）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收</strong></p><p><img src="http://bloghello.oursnail.cn/jvm8-4.jpg" alt="image"></p><h2>五、新生代和老年代</h2><h5>5.1 新生代</h5><p>新生代分为三个区域，一个<code>Eden</code>区和两个<code>Survivor</code>区，它们之间的比例为（8：1：1），这个比例也是可以修改的。通常情况下，对象主要分配在新生代的<code>Eden</code>区上，少数情况下也可能会直接分配在老年代中。</p><p>Java虚拟机每次使用新生代中的<code>Eden</code>和其中一块<code>Survivor</code>（<code>From</code>），在经过一次<code>MinorGC</code>后，将<code>Eden</code>和<code>Survivor</code>中还存活的对象一次性地复制到另一块<code>Survivor</code>空间上（这里使用的复制算法进行GC），最后清理掉<code>Eden</code>和刚才用过的<code>Survivor</code>（<code>From</code>）空间。将此时在<code>Survivor</code>空间存活下来的对象的年龄设置为1，以后这些对象每在<code>Survivor</code>区熬过一次GC，它们的年龄就加1，当对象年龄达到某个年龄（默认值为15）时，就会把它们移到老年代中。</p><p>在新生代中进行GC时，有可能遇到另外一块<code>Survivor</code>空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><p>总结：</p><p>1、<code>Minor GC</code>是发生在新生代中的垃圾收集，采用的复制算法；</p><p>2、新生代中每次使用的空间不超过90%，主要用来存放新生的对象；</p><p>3、<code>Minor GC</code>每次收集后Eden区和一块<code>Survivor</code>区都被清空；</p><h5>5.1 老年代</h5><p>老年代里面存放都是生命周期长的对象，对于一些较大的对象（即需要分配一块较大的连续内存空间），是直接存入老年代的，还有很多从新生代的<code>Survivor</code>区域中熬过来的对象。</p><p>老年代中使用的是<code>Full GC</code>，<code>Full GC</code>所采用的是标记-清除或者标记-整理算法。老年代中的<code>Full GC</code>不像<code>Minor GC</code>操作那么频繁，并且进行一次<code>Full GC</code>所需要的时间要比<code>Minor GC</code>的时间长。</p><h5>5.2 触发Full GC的条件</h5><ul><li>老年代空间不足</li><li>JDK8以前的永久代空间不足，现在永久代已经被元数据区代替</li><li>CMS GC时出现<code>promotion failed</code>，<code>concurrent mode failure</code>(下面文章讲到CMS垃圾收集器的时候会说明)</li><li><code>minor GC</code>晋升到老年代的平均大小大于老年代的剩余空间</li><li>调用<code>System.gc()</code>提醒JVM回收一下，只是提醒</li></ul><h5>5.3 对象如何晋升到老年代</h5><p>一般有如下情况会晋升：</p><ul><li>经历一定minor次数依然存活的对象</li><li>survivor区中存放不下的对象</li><li>新生成的大对象</li></ul><h5>5.4 常用的调优参数</h5><p><img src="http://bloghello.oursnail.cn/jvm8-5.jpg" alt="image"></p><h5>5.5 内存申请过程</h5><p>A. JVM会试图为相关Java对象在<code>Eden</code>中初始化一块内存区域</p><p>B. 当<code>Eden</code>空间足够时，内存申请结束。否则到下一步</p><p>C. <code>JVM</code>试图释放在<code>Eden</code>中所有不活跃的对象（<code>Minor GC</code>）, 释放后若<code>Eden</code>空间仍然不足以放入新对象，则试图将部分<code>Eden</code>中活跃对象放入<code>Survivor</code>区</p><p>D. 当<code>Survivor</code>区空间不够时或者某些对象熬的时间比较长，则<code>Survivor</code>区这些对象会被移到<code>Old</code>区</p><p>E. 当<code>Old</code>区空间不够时，<code>JVM</code>会在<code>Old</code>区进行完全的垃圾收集（<code>Full GC</code>）</p><p>F. 完全垃圾收集后，若<code>Survivor</code>及<code>Old</code>区仍然无法存放从<code>Eden</code>复制过来的部分对象，导致<code>JVM</code>无法在<code>Eden</code>区为新对象创建内存区域，则出现<code>out of memory</code>错误.</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA内存模型常问面试题</title>
      <link href="/2019/02/08/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%B8%B8%E9%97%AE%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/02/08/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%B8%B8%E9%97%AE%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第七篇文章，介绍一些面试比较常问的问题。</p><a id="more"></a><h2>一、JVM三大性能调优参数-Xms -Xmx -Xss的含义</h2><p>一般我们可以传入以下参数去调整堆和内存所占的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms128m -Xmx128m -Xss256k -jar xxx.jar</span><br></pre></td></tr></table></figure><ul><li>-Xms ：堆的初始值</li><li>-Xmx ：堆能达到的最大值</li><li>-Xss ：规定了每个线程虚拟机栈的大小</li></ul><h2>二、JAVA内存模型中堆和栈的区别</h2><p>首先来了解一下几种不同的内存分配策略：</p><ul><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求，比如static声明的静态变量，这里的数据一般都放在方法区，java8中这个区域叫做元数据区，用的时物理内存，并且之前合在一起的字符串常量池也被移到了堆区，详情见上一篇文章。</li><li>栈式存储：数据去需求在编译时未知，运行时模块入口前确定，比如基本数据类型，都是在运行的时候，才知道数据(字面量)到底是什么，对于JVM，一个方法内的执行，局部变量表和操作数栈的大小时确定的，即引用变量和栈空间大小是编译器确定的，至于字面量等运行时才能确定。</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配，比如可变长度串、对象实例</li></ul><p>下面来看看栈和堆的联系：</p><p>引用对象或者数组时，栈里定义变量保存堆中目标的首地址。</p><p><img src="http://bloghello.oursnail.cn/jvm7-1.png" alt="image"></p><p>下面来看看栈和堆的区别：</p><ul><li>管理方式：栈自动释放，堆需要GC</li><li>空间大小：栈比堆小</li><li>碎片相关：栈产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ul><p>简单总结：栈比较小，随着方法执行完毕自动释放，栈数据结构简单，所以操作也简单高效。堆放各种对象实例和数组，必定要比较大的空间，那么需要GC来回收不需要的数据，效率低并且碎片也比较多，由于堆的操作比较复杂，所以数据结构也复杂，效率低。</p><h2>三、元空间、堆、线程独占部分间的联系</h2><p>先来看一个最简单的程序：</p><p><img src="http://bloghello.oursnail.cn/jvm7-2.png" alt="image"></p><p>我们分别从元空间、堆、以及线程独占的部分来看看分别存储了啥：</p><p><img src="http://bloghello.oursnail.cn/jvm7-3.png" alt="image"></p><p>学到这里，对于这些东西已经不需要解释了。针对JVM内存模型的知识在这里就串联起来了。了解到这里，对内存模型这一块基本的知识已经差不多了。</p><h2>四、再来说说字符串</h2><p>之前在<a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" target="_blank" rel="noopener">java字符串核心一网打尽</a>文章中，其实是对于JDK8这个版本的字符串特性进行详细的解读，其中也介绍了<code>intern</code>这个方法的含义和用法，由于JDK6和JDK6+关于<code>intern</code>是不一样的，这里对比一下。</p><p>对于JDK8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况</span></span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    str1.intern();</span><br><span class="line">    String str2 = <span class="string">"a"</span>;</span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种情况</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    str3.intern();</span><br><span class="line">    String str4 = <span class="string">"aa"</span>;</span><br><span class="line">    System.out.println(str3 == str4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>但是在JDK6中执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>这个问题困扰了我很久，由于之前基础不是太扎实，所以直接就跳过了这个问题，在面试的时候几乎也不会太深究，但是一直成为我心里的坎。今天要把他解决掉。在说明这个问题之前，需要说明一下JVM有三种常量池：</p><h5>4.1 三种常量池</h5><ol><li>Class文件中的常量池</li></ol><p>这里面主要存放两大类常量：字面量和符号引用，符号引用包含三类常量：</p><ul><li>类和接口的全限定名(<code>Full Qualified Name</code>)</li><li>字段的名称和描述符(<code>Descriptor</code>)</li><li>方法的名称和描述符</li></ul><p>这个用<code>javap</code>看一下就能明白，这里只涉及字符串就不谈其他的了。简单地说，用双引号引起来的字符串字面量都会进这里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>str2</code>就是符号引用，<code>a</code>就是字面量。</p><ol start="2"><li>运行时常量池</li></ol><p>方法区的一部分。<code>Class</code>文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池(<code>Constant Pool Table</code>)，存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。</p><ol start="3"><li>全局字符串</li></ol><p><code>HotSpot VM</code>里，记录<code>interned string</code>的一个全局表叫做<code>StringTable</code>，它本质上就是个<code>HashSet&lt;String&gt;</code>。这是个纯运行时的结构，而且是惰性（<code>lazy</code>）维护的。</p><p>注意，它里面存放的是引用。</p><p>所以，一般我们说一个字符串进入了全局的字符串常量池其实是说在这个<code>StringTable</code>中保存了对它的引用，反之，如果说没有在其中就是说<code>StringTable</code>中没有对它的引用。</p><h5>4.2 字面量进入字符串常量池的时机</h5><p>先给出一个结论：就<code>HotSpot VM</code>的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在<code>StringTable</code>中并没有相应的引用，在堆中也没有对应的对象产生）</p><p>那么加载类的过程发生的是什么呢？</p><p>R大的一篇文章：</p><blockquote><p>在类加载阶段， JVM会在堆中创建 对应这些 class文件常量池中的 字符串对象实例 并在字符串常量池中驻留其引用。具体在resolve阶段执行。这些常量全局共享。</p></blockquote><p>这里说的比较笼统，没错，是<code>resolve</code>阶段，但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 <strong>JVM规范里明确指定resolve阶段可以是lazy的。</strong></p><p>所以，类加载的时候，必定要做的东西是，将class文件中字面量和符号引用放入运行时常量池中，而<code>JVM</code>规范里<code>Class</code>文件的常量池项的类型，有两种东西：<code>CONSTANT_Utf8</code>和<code>CONSTANT_String</code>。后者是<code>String</code>常量的类型，但它并不直接持有<code>String</code>常量的内容，而是只持有一个<code>index</code>，这个<code>index</code>所指定的另一个常量池项必须是一个<code>CONSTANT_Utf8</code>类型的常量，这里才真正持有字符串的内容。</p><p><code>CONSTANT_Utf8</code>会在类加载的过程中就全部创建出来，而<code>CONSTANT_String</code>则是<code>lazy resolve</code>的，例如说在第一次引用该项的<code>ldc</code>指令被第一次执行到的时候才会<code>resolve</code>。</p><h5>4.3 ldc指令是什么东西？</h5><p>简单地说，它用于将int、float或String型常量值从常量池中推送至栈顶</p><p>以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abc</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        String a = <span class="string">"AA"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看其编译后的Class文件如下：</p><p><img src="http://bloghello.oursnail.cn/jvm7-4.png" alt="image"></p><p>根据上面说的，在类加载阶段，这个 <code>resolve</code> 阶段（ <code>constant pool resolution</code>）是<code>lazy</code>的。换句话说并没有真正的对象，字符串常量池里自然也没有。执行<code>ldc</code>指令就是触发这个<code>lazy resolution</code>动作的条件。</p><p>ldc字节码在这里的执行语义是：到当前类的运行时常量池去查找该<code>index</code>对应的项,即上面说的<code>CONSTANT_String</code>指向的<code>index</code>，如果该项尚未<code>resolve</code>则<code>resolve</code>之，并返回<code>resolve</code>后的内容。</p><p>在遇到<code>String</code>类型常量时，<code>resolve</code>的过程如果发现<code>StringTable</code>已经有了内容匹配的<code>java.lang.String</code>的引用，则直接返回这个引用，反之，如果<code>StringTable</code>里尚未有内容匹配的<code>String</code>实例的引用，则会在<code>Java</code>堆里创建一个对应内容的<code>String</code>对象，然后在<code>StringTable</code>记录下这个引用，并返回这个引用出去。</p><p>这里很重要，昭示了一个重要问题：<code>String a = &quot;AA&quot;;</code>这一句执行完，要看字符串常量池中是否已经存在，不存在的话是要在堆中先创建对象的，然后把堆地址给全局的字符串常量池。</p><p>理解到这，有些问题就可以解决了，这里先不回答最上面的问题，先来看看下面的例子。注意运行环境是JDK8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTest0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s1=<span class="string">"static"</span>;  <span class="comment">// 第一句</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"he"</span>)+<span class="keyword">new</span> String(<span class="string">"llo"</span>); <span class="comment">//第二句</span></span><br><span class="line">        s2.intern(); <span class="comment">// 第三句</span></span><br><span class="line">        String s3=<span class="string">"hello"</span>;  <span class="comment">//第四句</span></span><br><span class="line">        System.out.println(s2 == s3);<span class="comment">//第五句，输出是true。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;static&quot;</code> <code>&quot;he&quot;</code> <code>&quot;llo&quot;</code> <code>&quot;hello&quot;</code>都会进入<code>Class</code>的常量池， 按照上面说的，类加载阶段由于<code>resolve</code> 阶段是<code>lazy</code>的，所以是不会创建实例，更不会驻留字符串常量池了。</p><p>但是要注意这个<code>“static”</code>和其他三个不一样，它是静态的，在类加载阶段中的初始化阶段，会为静态变量指定初始值，也就是要把<code>“static”</code>赋值给<code>s1</code>，这个赋值操作要怎么搞啊，先<code>ldc</code>指令把它放到栈顶，然后用<code>putstatic</code>指令完成赋值。注意，<code>ldc</code>指令，根据上面说的，会创建<code>&quot;static&quot;</code>字符串对象，并且会保存一个指向它的引用到字符串常量池。</p><p>运行<code>main</code>方法后，首先是第二句，一样的，要先用<code>ldc</code>把<code>&quot;he&quot;</code>和<code>&quot;llo&quot;</code>送到栈顶，换句话说，会创建他俩的对象（注意，在堆中开辟本体所占的空间，还没到new的那一步），并且会保存引用到字符串常量池中（把本地在堆中空间地址传给字符串常量池）；然后有个<code>＋</code>号对吧，内部是创建了一个<code>StringBuilder</code>对象，一路<code>append</code>，最后调用<code>StringBuilder</code>对象的<code>toString</code>方法得到一个<code>String</code>对象（内容是<code>hello</code>，注意这个<code>toString</code>方法会<code>new</code>一个<code>String</code>对象），并把它赋值给<code>s2</code>（s2指向的是new出来的新对象，是新的一块内存空间）。</p><p>注意，此时还没有把<code>hello</code>的引用放入字符串常量池。然后是第三句，<code>intern</code>方法一看，字符串常量池里面没有，它会把上面的这个<code>hello</code>对象的引用保存到字符串常量池，然后返回这个引用，但是这个返回值我们并没有使用变量去接收，所以没用。</p><p>第四句，字符串常量池里面已经有了，直接用嘛。所以<code>s2</code>和<code>s3</code>都是<code>s2</code>的指向的地址。</p><p>再来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    String s1=<span class="keyword">new</span> String(<span class="string">"he"</span>)+<span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">    String s2=<span class="keyword">new</span> String(<span class="string">"h"</span>)+<span class="keyword">new</span> String(<span class="string">"ello"</span>);</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    String s3=s1.intern();</span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    String s4=s2.intern();</span><br><span class="line">    <span class="comment">// ④</span></span><br><span class="line">    System.out.println(s1==s3);</span><br><span class="line">    System.out.println(s1==s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是将一些符号引用和字面量从class文件的常量池中撞到运行时常量池。然后运行main方法，先看第一句，会创建<code>&quot;he&quot;</code>和<code>&quot;llo&quot;</code>对象，并放入字符串常量池，然后会创建一个<code>&quot;hello&quot;</code>对象，没有放入字符串常量池，<code>s1</code>指向这个<code>&quot;hello&quot;</code>对象。</p><p>第二句，创建<code>&quot;h&quot;</code>和<code>&quot;ello&quot;</code>对象，并放入字符串常量池，然后会创建一个<code>&quot;hello&quot;</code>对象，没有放入字符串常量池，<code>s2</code>指向这个<code>&quot;hello&quot;</code>对象。</p><p>第三句，字符串常量池里面还没有，于是会把<code>s1</code>指向的<code>String</code>对象的引用放入字符串常量池（换句话说，放入池中的引用和<code>s1</code>指向了同一个对象），然后会把这个引用返回给了<code>s3</code>，所以<code>s3==s1</code>是<code>true</code>。</p><p>第四句，字符串常量池里面已经有了，直接将它返回给了<code>s4</code>，所以<code>s4==s1</code>是<code>true</code>。</p><p>此时，回到一开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    str1.intern();</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    String str2 = <span class="string">"a"</span>;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种情况</span></span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    <span class="comment">//6</span></span><br><span class="line">    str3.intern();</span><br><span class="line">    <span class="comment">//7</span></span><br><span class="line">    String str4 = <span class="string">"aa"</span>;</span><br><span class="line">    <span class="comment">//8</span></span><br><span class="line">    System.out.println(str3 == str4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk1.6及以前，调用<code>intern()</code></p><blockquote><p>如果常量池中不存在值相等的字符串时，jvm会复制一个字符串到创量池中，并返回常量池中的字符串。</p></blockquote><p>而在jdk1.7及以后，调用<code>intern()</code></p><blockquote><p>如果常量池中不存在值相等的字符串时，jvm只是在常量池记录当前字符串的引用，并返回当前字符串的引用。</p></blockquote><p>所以在JDK6情况下，都是返回false，原因是：第一种情况下，执行第一句，看到有个字符串<code>&quot;a&quot;</code>，那么首先是创建<code>&quot;a&quot;</code>本体对象，并且把副本放入字符串常量池中。执行第二句，发现字符串常量池中已经存在，则不放了。执行第三句，<br>s2指向的是字符串常量池中的<code>&quot;a&quot;</code>，这个字符串常量池<code>&quot;a&quot;</code>所在的地址，肯定与堆中的新new出来的不一样。所以返回false。</p><p>第二种情况，第一句相当于：</p><p>其实相当于:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String str3 =  (<span class="keyword">new</span> StringBuilder()).apend(s1).apend(s2).toString();</span><br></pre></td></tr></table></figure><p>会先在堆中创建两个对象<code>&quot;a&quot;</code>，拷贝一个副本到字符串常量池中，此时<code>&quot;a&quot;</code>已经存在于字符串常量池中了。然后拼接生成一个新的对象<code>&quot;aa&quot;</code>在堆中，这种拼接出来的<code>&quot;aa&quot;</code>此时是不会把副本放进字符串常量池的，因为字符串常量池只保存已确定的字面量，这种拼接的属于运行完成才能确定，所以字符串常量池中没有，直到执行第6句，才会尝试把<code>&quot;aa&quot;</code>副本放入字符串常量池，但是还是跟上面一样，一个指向堆，一个指向字符串常量池，肯定不相等。</p><p>在JDK6+情况下，第一个返回false，第二个返回true。原因是：第一种情况下，执行第一句，首先是创建<code>&quot;a&quot;</code>本体对象，并且把引用放进字符串常量池中，然后new，开辟新的地址空间，此时<code>str1</code>指向的是new出来的空间的引用。执行第二句，尝试将<code>str1</code>的引用放入字符串常量池，但是池中已经存在了，所以不能放，所以一个指向堆，一个是本体对象的引用，不一样，所以为false。第二种情况，<code>&quot;a&quot;</code>跟上面一样，在堆中开辟，然后引用放入字符串常量池中，后面拼接成<code>&quot;aa&quot;</code>，此时只是在堆中开辟空间，下面执行<code>intern</code>尝试把它的引用传给字符串常量池，由于字符串常量池中没有，所以就放进去了。此时字符串常量池中的引用与<code>&quot;aa&quot;</code>对象实际的堆地址是一样的，所以为true.</p><p>这边有一个事实：在执行<code>String s1 = new String(&quot;a&quot;)</code>的<code>new</code>之前，JVM先看到有一个字符串<code>&quot;a&quot;</code>，则会先看看字符串常量池中是否有这个<code>&quot;a&quot;</code>，有则直接返回字符串常量池引用，没有则给它开辟空间，并且把这个空间的引用传给字符串常量池。</p><p><img src="http://bloghello.oursnail.cn/jvm7-7.png" alt="image"></p><p>整理自：<a href="https://www.zhihu.com/question/55994121/answer/147296098" target="_blank" rel="noopener">木女孩的回答</a></p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内连接和外连接</title>
      <link href="/2019/02/05/mysql/%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/02/05/mysql/%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>在电信实习的时候，天天有人来面试，问的问题我都听的蛮清楚的，比如内连接和外连接的区别，好像很简单，但还是说的不好，这里总结一下。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A表                         B表</span><br><span class="line">id      name                id      name </span><br><span class="line">1          a                1       b </span><br><span class="line">2          b                3       c</span><br><span class="line">4          c</span><br></pre></td></tr></table></figure><h3>内连接</h3><p>内连接就是左表和右表相同的数据:</p><p><img src="http://bloghello.oursnail.cn/mysql9-1.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id      name            id      name </span><br><span class="line">1         a              1       b</span><br></pre></td></tr></table></figure><h3>左外连接</h3><p>左外连接就是以左表为准，去匹配右表，左表有多少条数据，结果就是多少条数据</p><p><img src="http://bloghello.oursnail.cn/mysql9-2.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id      name        id     name </span><br><span class="line">1         a          1       b </span><br><span class="line">2         b         null    null</span><br><span class="line">4         c         null    null</span><br></pre></td></tr></table></figure><h3>右外连接</h3><p>右外连接就是与左外连接反之，以右表为准，去匹配左表，右表有多少条数据，结果就是多少条数据</p><p><img src="http://bloghello.oursnail.cn/mysql9-3.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id      name            id     name </span><br><span class="line">1         a             1       b </span><br><span class="line">null    null            3       c</span><br></pre></td></tr></table></figure><h3>交叉连接</h3><p>交叉连接不带 <code>WHERE</code> 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到<br>结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查<br>询条件的数据行数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">join</span> B</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id  name  id  name</span><br><span class="line">1 a  1   b</span><br><span class="line">1 a  3   c</span><br><span class="line">2 b    1    b</span><br><span class="line">2 b  3   c</span><br><span class="line">4 c  1   b</span><br><span class="line">4 c  3   c</span><br></pre></td></tr></table></figure><h3>内连接和外连接的区别</h3><p>内连接只列出两张表共同匹配的数据行，而外连接的结果集中不仅包含符合连接条件的数据行，还包括左表(左外连接或左连接)或右表(右外连接或右连接)中的所有数据行。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA内存模型-线程共享</title>
      <link href="/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/"/>
      <url>/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第六篇文章，介绍线程共享区域。</p><a id="more"></a><h2>一、内存模型–JAVA堆</h2><ul><li><p>java堆一般是java虚拟机所管理的内存中最大的一块。</p></li><li><p>java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p></li><li><p>堆上存放对象实例和数组。</p></li><li><p>java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p></li><li><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p></li></ul><h2>二、内存模型–方法区</h2><p><img src="http://bloghello.oursnail.cn/jvm5-4.png" alt="image"></p><blockquote><p>方法区和堆一样，是各个线程共享的内存区域。</p></blockquote><blockquote><p>它用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。</p></blockquote><blockquote><p>其中，类信息包含类的版本、字段、接口、方法</p></blockquote><h2>八、PermGen与Metaspace</h2><p>其实，方法区可以理解为一个规范，jdk6的具体实现是<code>PermGen</code>,而后来的版本具体实现是<code>Metaspace</code>。它们有一定的区别。</p><p>在 <code>HotSpot JVM</code> 中，永久代中用于存放类和方法的元数据以及常量池，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>永久代是有大小限制的，它用的是JVM内存，即与堆内存等价的<code>no heap</code>区域，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <code>java.lang.OutOfMemoryError: PermGen</code> ，为此我们不得不对虚拟机做调优。</p><ol><li>由于 <code>PermGen</code> 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 <code>JVM</code> 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li><li>移除 <code>PermGen</code> 可以促进 <code>HotSpot JVM</code> 与 <code>JRockit VM</code> 的融合，因为 <code>JRockit</code> 没有永久代。</li></ol><p>根据上面的各种原因，<code>PermGen</code> 最终被移除，方法区移至 <code>Metaspace</code>，字符串常量移至 <code>Java Heap</code>。<code>Metaspace</code>并不在虚拟机中，而是使用本地内存,十分方便管理，不会出现永久带内存溢出问题，垃圾回收的时候这个单独区域方便处理。</p><h2>三、运行时常量池</h2><blockquote><p>是方法区的一部分。</p></blockquote><blockquote><p>类文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法的运行时常量池中存放。</p></blockquote><blockquote><p>这里尤其值得注意的是字符串的创建，会被扔到字符串常量池中。如果是new，那么还是在堆重创建的。当然，运行时也可以产生新的常量放入池中，比如讲new出来的字符串用<code>intern()</code>方法便可以在运行时将其放到常量池中。</p></blockquote><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str3.intern()); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><blockquote><p>对于直接声明的内容相同的字符串，对于str2来说是不需要重新分配地址的，因为str1的hello这个常量已经存在于常量池中了。所以他们两个其实是一个东西。</p></blockquote><blockquote><p>对于new出来的str3，是不会直接扔到常量池中的，他是在堆中分配，地址不一样，所以显然是false。</p></blockquote><blockquote><p>String类的<code>intern()</code>方法，使得运行时将堆中产生的对象放入常量池中，所以是true。</p></blockquote><p>这里我在<a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" target="_blank" rel="noopener">java字符串核心一网打尽</a>中已经详细说明了，不再赘述。</p><h2>四、对象探秘</h2><h5>4.1 对象的创建过程</h5><ul><li><p>类加载检查：检查该对象的类是否已经被加载、解析、初始化过，如果没有则先进行类加载操作。</p></li><li><p>分配内存：如果内存规整使用“指针碰撞”分配，否则一般使用“空闲列表”分配，具体看垃圾回收器是否带有整理（<code>Compact</code>）空闲内存功能。</p></li><li><p>初始化：将内存区初始化置零，不包含对象头，这一步保证了对象的实例字段在java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p>对象头设置：这个对象是哪个类的实例、如何找到类的元数据信息、哈希码、GC分代年龄信息等即为对象头</p></li><li><p>对象的方法：即按照程序员的意愿进行初始化</p></li></ul><h5>4.2 对象的内存布局</h5><ul><li>对象头</li></ul><p><strong>一部分称为<code>Mark Word</code>，存储对象自身运行时的数据</strong>，包含哈希码、GC分代年龄、锁状态标志等等。</p><p>采用压缩存储，压缩到虚拟机位数（32位/64位）。由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计为一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p><strong>另一部分为类型指针，指向它的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例</strong>。并不是所有虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。</p><p>如果对象是一个java数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象的元数据信息确定java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p><ul><li><p>实例数据</p><ul><li>实例数据部分是对象真正存储的有效信息，也是在程序中定义的各种类型的字段内容。</li><li>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li><li>从分配策略中可以看出，相同宽度的字段总是分配在一起，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</li></ul></li><li><p>对齐填充</p><ul><li>非必需，只有前两者加起来非8的倍数时才会有。</li><li>因为<code>HotSpot VM</code> 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍。不对齐的时候，需要通过它来填充对齐。</li></ul></li></ul><h2>九、对象的访问定位</h2><ul><li>通过句柄访问</li></ul><p><img src="http://bloghello.oursnail.cn/jvm5-5.png" alt="image"></p><p>通过句柄访问对象：当java虚拟机GC移动堆对象时，并不需要修改<code>reference</code>，只需修改句柄对象的实例数据指针。</p><ul><li>通过直接指针访问</li></ul><p><img src="http://bloghello.oursnail.cn/jvm5-6.png" alt="image"></p><p>通过直接指针访问对象：加快了对象访问速度，比间接访问少一次对象实例数据的访问，<code>HotSpot</code>则采用的这种访问方式。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA内存模型-线程私有</title>
      <link href="/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
      <url>/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第五篇文章，JVM的内存模型一般是面试必问的点，因为对JVM内存模型有所了解，才会有可能知道调优手段。本篇文章首先介绍线程私有的一些区域。</p><a id="more"></a><h2>一、从整体看JVM运行时内存模型</h2><p><img src="http://bloghello.oursnail.cn/jvm5-1.png" alt="image"></p><p>下面详细说说各个部分的作用。</p><h2>二、内存模型–程序计数器</h2><ul><li><p><strong>占用内存小</strong>：是一块较小的内存空间，当前线程所执行的字节码的行号指示器。</p></li><li><p><strong>PC作用</strong>：字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></li><li><p><strong>线程独立</strong>：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们成这类内存区域为“线程私有”的内存。</p></li><li><p><strong>native方法</strong>：如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空(undefined).</p></li><li><p><strong>无内存溢出异常</strong>：此内存区域是唯一一个在java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p></li></ul><h2>三、内存模型–JAVA虚拟机栈</h2><p><img src="http://bloghello.oursnail.cn/jvm5-2.png" alt="image"></p><ul><li><p>线程私有，生命周期与线程相同。</p></li><li><p>虚拟机栈描述的是Java方法的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p></li></ul><h2>四、栈帧</h2><p><img src="http://bloghello.oursnail.cn/jvm5-3.png" alt="image"></p><ul><li><p>我们口中常常提到的栈与堆，其中栈就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p></li><li><p>局部变量表存放了编译期可知的各种基本数据类型(<code>boolean</code>,<code>byte</code>,<code>char</code>,<code>short</code>,<code>int</code>,<code>float</code>,<code>long</code>,<code>double</code>),对象引用(它不等同于对象本身，可能是一个指向对象地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)、<code>returnAddress</code>类型(指向了一条字节码指令的地址)</p></li><li><p>其中64位长度的<code>long</code>和<code>double</code>类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p></li><li><p>局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，比如递归层数过多，将抛出<code>StackOverflowError</code>异常；如果虚拟机可以动态扩展，即虚拟机栈申请过多，扩展时却无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>异常。</p></li></ul><h2>五、内存模型–本地方法栈</h2><ul><li><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈尾虚拟机执行java方法(也就是字节码)服务，而本地方法栈则为虚拟机用到的Native方法服务。</p></li><li><p><code>Sun HotSpot</code>虚拟机直接将本地方法栈和虚拟机栈合二为一。</p></li><li><p>与虚拟机栈一样会抛出<code>StackOverflowError</code>异常或者<code>OutOfMemoryError</code>异常。</p></li></ul><p><strong>什么是native方法？</strong></p><p>简单地讲，一个<code>Native Method</code>就是一个java调用非java代码的接口。一个<code>Native Method</code>是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在<code>C＋＋</code>中，你可以用<code>extern “C”</code>告知<code>C＋＋</code>编译器去调用一个C的函数。</p><p>下一篇来看看线程共享的区域。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>细谈loadClass</title>
      <link href="/2019/02/05/JVM/%E7%BB%86%E8%B0%88loadClass/"/>
      <url>/2019/02/05/JVM/%E7%BB%86%E8%B0%88loadClass/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第四篇文章，对于获取Class对象，其实我们不知不觉中已经接触过两种了，一种就是loadClass，一种就是<a href="http://fourcolor.oursnail.cn/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/" target="_blank" rel="noopener">反射</a>中的forName，它们到底有什么区别呢？其实涉及了类加载过程的区别。下面好好来探讨一下。</p><a id="more"></a><h2>一、问题的提出</h2><p>对于之前的 测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\swg\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"Robot"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家有没有疑惑，我们这里是用了<code>loadClass(name)</code>来加载对应的<code>Class</code>对象的，最后还需要进行<code>newInstance()</code>。那么为什么要调用<code>newInstance()</code>才行呢？</p><h5>1.1 new的方式构建对象实例</h5><p>下面要进行相应的测试。对于<code>Robot.java</code>:</p><p><img src="http://bloghello.oursnail.cn/jvm4-1.png" alt="image"></p><p>首先用<code>new</code>的方式：</p><p><img src="http://bloghello.oursnail.cn/jvm4-2.png" alt="image"></p><p>显示结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><h5>1.2 loadClass来获取Class对象</h5><p><img src="http://bloghello.oursnail.cn/jvm4-3.png" alt="image"></p><p>如果仅仅这样写，显示结果仅仅为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>也就是说，并不会触发<code>static</code>静态块的执行，也就是说这个类根本就没有初始化。</p><h5>1.3 forName来获取Class对象</h5><p><img src="http://bloghello.oursnail.cn/jvm4-4.png" alt="image"></p><p>显示结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><p>触发了静态块的执行。</p><h2>二、类加载过程</h2><p>要想说明上面区别产生的原因，这里必须要介绍一个从未使用过的类加载的过程。</p><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（<code>Loading</code>）、验证（<code>Verification</code>）、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>Using</code>)和卸载(<code>Unloading</code>)7个阶段。其中准备、验证、解析3个部分统称为连接（<code>Linking</code>）。如图所示：</p><p><img src="http://bloghello.oursnail.cn/jvm4-5.png" alt="image"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p><h5>2.1 加载</h5><p><strong>在加载阶段</strong>（可以参考<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法），虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个<code>Class</code>文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口；</li></ul><p>加载阶段和连接阶段（<code>Linking</code>）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h5>2.2 验证</h5><p>验证是连接阶段的第一步，这一阶段的目的是为了确保<code>Class</code>文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>验证阶段大致会完成4个阶段的检验动作</strong>：</p><blockquote><p>文件格式验证：验证字节流是否符合<code>Class</code>文件格式的规范；例如：是否以魔术<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></blockquote><blockquote><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比<code>javac</code>编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了<code>java.lang.Object</code>之外。</p></blockquote><blockquote><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></blockquote><blockquote><p>符号引用验证：确保解析动作能正确执行。</p></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h5>2.3 准备</h5><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量<code>value</code>在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把<code>value</code>赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器()方法之中，所以把<code>value</code>赋值为123的动作将在初始化阶段才会执行。</p><p><strong>至于“特殊情况”是指</strong>：<code>public static final int value=123</code>，即当类字段的字段属性是<code>ConstantValue</code>时，会在准备阶段初始化为指定的值，所以标注为<code>final</code>之后，<code>value</code>的值在准备阶段初始化为123而非0.</p><h5>2.4 解析</h5><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><p>对于这里说的：将符号引用替换为直接引用。很多人包括我第一次看到的时候感觉莫名其妙，教材上也是直接用这些专用名词，给我们的学习带来了极大的困扰。这里还是要解释一下。</p><p>比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>s</code>是符号引用，而<code>abc</code>是字面量。</p><p>此时，知道了什么是符号引用就好办了，因为符号引用一般都是放在栈中的，这个玩意肯定是依赖于实际的东西，相当于一个指针，多以我们程序需要将其解析成这个实际东西所在的真正的地址。所以，一旦解析了，那么内存中必然实际存在了这个对象，即拥有实际的物理地址了。</p><h5>2.5 初始化</h5><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程.</p><h2>三、new、loadClass、forName</h2><p>正常情况下，我们一般构建对象实例是通过<code>new</code>的方式，<code>new</code>是隐式构建对象实例，不需要<code>newInstance()</code>，并且可以用带参数的构造器来生成对象实例；</p><p>对于<code>new</code>，我们有点基础的，是知道，已经一直来到了最后初始化完成的这一步，生成了可以直接使用的对象实例。由于篇幅不宜太长，不想展开讲new的过程发生了什么，这里先贴个我觉得讲的不错的链接：<a href="https://www.jianshu.com/p/ebaa1a03c594" target="_blank" rel="noopener">https://www.jianshu.com/p/ebaa1a03c594</a></p><p>然而<code>loadClass(name)</code>这种显示调用的方式，我们可以看到，只有加载的功能，而没有后续连接以及初始化的过程。</p><p>所以<code>loadClass(name)</code>需要进行<code>newInstance()</code>才能生成对应的对象实例，并且这个<code>newInstance()</code>方法不支持参数调用，要想实现输入参数生成实例对象，需要通过反射获取构造器对象传入参数再生成对象实例。</p><p>这里也就解释了为什么要<code>newInstance()</code>，因为不这样，<code>loadClass(name)</code>只是加载，并没有后续过程，也就是说这个类根本就没有动它，仅仅是加载进来而已。从代码层面调用<code>loadClass()</code>的时候，我们可以看到一个之前故意忽视的东西：</p><p><img src="http://bloghello.oursnail.cn/jvm4-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/jvm4-7.png" alt="image"></p><p>这个<code>resolve</code>默认是传入<code>false</code>的，那么进来看看这个<code>resolveClass()</code>方法：</p><p><img src="http://bloghello.oursnail.cn/jvm4-8.png" alt="image"></p><p>再下去是<code>native</code>方法，不必关心，我们只看方法的注释即可，写的是链接指定的类，就是上面的连接过程。我们由上面知道，如果这个方法能执行，那么就会触发验证、准备、解析这三个过程，而准备阶段是会去执行静态方法或静态块，类变量会被进行初始化，即分配内存，但是仅仅赋初值即可。</p><p>所以，<code>loadClass(name)</code>有一种懒加载的思想在里面，要用了再去进行初始化，而不是一开始就初始化好。</p><p>既然已经知道了<code>new</code>和<code>loadClass</code>的区别了，下面再来看看<code>Class.forName()</code>,聪明的读者估计已经可以猜到了，没错，根据实验的结果来看，它至少要进行到连接完，实质它也完成了初始化，即已经到达第三步：</p><p><img src="http://bloghello.oursnail.cn/jvm4-9.png" alt="image"></p><p>总结一下：<code>loadClass</code>仅仅是第一步的加载，而<code>forName</code>和<code>new</code>都是已经初始化好了。</p><h2>存在的原因</h2><p>所谓存在即合理，<code>forName</code>的用法，最常见的莫过于用于加载数据库驱动这，我们这里实验一下，首先引入相关的依赖：</p><p><img src="http://bloghello.oursnail.cn/jvm4-10.png" alt="image"></p><p>经典写法来啦：</p><p><img src="http://bloghello.oursnail.cn/jvm4-11.png" alt="image"></p><p>点进去看看：</p><p><img src="http://bloghello.oursnail.cn/jvm4-12.png" alt="image"></p><p>我们这个时候发现，里面是一个<code>static</code>方法，也就是说，我们要立即创建驱动。所以这个时候必须用<code>forname</code>方法啦！</p><p>那么对于<code>loadClass</code>，其实上面已经提及了，就是懒加载，这个思想再<code>spring</code>中是到处可见的，<code>bean</code>只是加载，但是步进行初始化，等用的时候再去初始化，提高性能。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双亲委派模型</title>
      <link href="/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第三篇文章，谈到JVM类加载机制，双亲委派模型是绕不开的话题，名字看好像是个高大上、深不可测的玩意，其实逐步揭开面纱之后很简单。下面我们就来揭揭看。</p><a id="more"></a><h2>回顾类加载器</h2><p>上一节简单说明了类加载器的作用，只说到一个核心功能是加载class文件。但是，绝对没有这么简单，神书《深入理解Java虚拟机》第二版对类加载器的说明：</p><blockquote><p>代码编译的结果从本地机器码转变成字节码，是存储格式的一小步，却是编程语言发展的一大步。</p><p>Java虚拟机把描述类的数据从Class文件加载进内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这动作的代码模块成为“类加载器”。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。这句话可以表达的更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</p></blockquote><p>对于上面进行一些说明：</p><p>注意，加载之后要将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）</p><p>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。这个<code>Class</code>对象并没有规定是在<code>Java</code>堆内存中，它比较特殊，虽为对象，但存放在方法区中。</p><p>这样，就可以使用这个类了。</p><p>还有，关于相等，只有在满足如下三个类“相等”判定条件，才能判定两个类相等。</p><ul><li>两个类来自同一个Class文件</li><li>两个类是由同一个虚拟机加载</li><li>两个类是由同一个类加载器加载</li></ul><h2>什么是双亲委派模型</h2><p>我们上一节已经知道了有四种类加载器，它们的实际关系为：</p><p><img src="http://bloghello.oursnail.cn/jvm3-1.png" alt="image"></p><p>从这个图来看，是一个继承的关系，是这样吗？我们用代码来看看是不是真的是这样。</p><p>代码还是用上一篇文章自定义类加载器来测试：</p><p><img src="http://bloghello.oursnail.cn/jvm3-3.png" alt="image"></p><p>结果是：</p><p><img src="http://bloghello.oursnail.cn/jvm3-4.png" alt="image"></p><p>从这个结果就很容易看出，层级关系是与上图所述的一样。那么，这个层级关系其实就是我们下面要说的双亲委派模型的结构。</p><p>这里还想补充一点：就是为什么最后一个是null，即<code>bootstrap</code>为什么显示null，其实是因为它是用C++实现的，不是java语言实现的，所以与其他几个都有区别，这里根据就调用不到，所以显示null。如果非要看<code>bootstrap</code>里面大概如何实现的，需要去看看<code>opjdk</code>的代码。</p><p>结合代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//2.首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">//3.如果当前类加载器没有加载过，进来</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//4.看是否有父类加载器，有则进来</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//5.父类加载器看看是否已经加载过</span></span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//进到这个，是来看看bootstrap类加载器是否加载过，没有加载过则加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一开始是false</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，就是先一级一级往上查询是否已经加载过，加载过直接返回即可；一直查询到<code>bootstrap</code>类加载器，都没有加载过，那么就从<code>bootstrap</code>类加载器开始一级一级向下到他们的扫描范围内尝试加载这个class文件，知道自定义类加载(如果有的话)，没有则返回找不到。</p><p>说一下代码的实现思路。代码使用递归实现的，先一级一级找父亲，即一级一级向上入栈，某一个查到了就返回，每一层递归停留在<code>c = parent.loadClass(name, false);</code>；都查不到，再一级一级出栈去执行，那么就从<code>c = findBootstrapClassOrNull(name);</code>后面的代码继续执行，那么显然就是执行<code>if (c == null) {...}</code>尝试去加载。</p><h2>为什么要用双亲委派模型</h2><p>为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：</p><blockquote><p>黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只<br>是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，<br>黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲<br>委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，<br>导致“病毒代码”被执行。</p></blockquote><p>而有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。</p><p>或许你会想，我在自定义的类加载器里面强制加载自定义的<code>java.lang.String</code>类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回<code>false</code>。</p><p>举个简单例子：</p><blockquote><p>ClassLoader1、ClassLoader2都加载java.lang.String类，对应Class1、Class2对象。<br>那么Class1对象不属于ClassLoad2对象加载的java.lang.String类型。</p></blockquote><p>委托机制的意义：防止内存中出现多份同样的字节码</p><p>比如两个类A和类B都要加载<code>System</code>类：</p><p>如果不用委托而是自己加载自己的，那么类A就会加载一份<code>System</code>字节码，然后类B又会加载一份<code>System</code>字节码，这样内存中就出现了两份<code>System</code>字节码。</p><p>如果使用委托机制，会递归的向父类查找，也就是首选用<code>Bootstrap</code>尝试加载，如果找不到再向下。这里的<code>System</code>就能在<code>Bootstrap</code>中找到然后加载，如果此时类B也要加载<code>System</code>，也从<code>Bootstrap</code>开始，此时<code>Bootstrap</code>发现已经加载过了<code>System</code>那么直接返回内存中的<code>System</code>即可而不需要重新加载，这样内存中就只有一份<code>System</code>的字节码了。</p><h2>一个面试题</h2><p>能不能自己写个类叫<code>java.lang.System</code>？</p><p>显然是不可以的，可能方案是自己搞一个这个类放在特殊目录，用自定义类加载器去加载，然而系统自身的类加载器会先去加载使用，下次再用的时候，是先逐级向上查询是否已经加载过，根本没有机会让自定义类加载器去加载。</p><p>所以，如果非要用，那么必定是要破坏双亲委派模型了，那么又回到为什么要用双亲委派模型的问题上了，所以，为了自己写一个<code>java.lang.System</code>而破坏双亲委派模型，我只能说，脑子秀逗了。所以不要搞这些东西，包名或类名写的不一样即可。</p><h2>一个问题</h2><p>那么为什么不能用一个加载器去一个目录加载所有呢？还要分这么多的类加载器，不是麻烦么？</p><p>其实，这个问题也是比较可笑的，毕竟每个层级的功能是不一样的，比如<code>bootstrap</code>是加载最核心的文件，没有它，都玩不起来。而自定义的呢？是比较特殊的需求，需要的时候才用到。对于这种有个性化的要求，一套代码来实现，显然是不合理的。</p><p>比如这个回答是根据加载的方式来思考的：</p><blockquote><p>每一个类加载器都是为了去在不同的情景下去加载类。比如，你可以从联网服务器上加载一个class文件，也可以从远程web服务器下载二进制类。这么设计是因为我们需要类加载器提供一致的接口，这样客户端就可以加载类但是却不用管类加载器到底是怎么实现的。启动类加载器能够加载JVM_HOME/lib 下的类，但如果我们需要在其他的情况下加载类呢？简单来说，加载类的方法有无数种，我们需要一个灵活的加载器系统去在特定的情况下按照我们的想法来加载类。</p></blockquote><p>还有一个回答是说更方便地对特定类进行优化：</p><blockquote><p>虽然 对java 虚拟机没有研究过，java 为什么不能 一个加载器 加载全部的类<br>很明显， 实现起来也可以<br>但是需要 的 代码 更多，也更难 为各种类进行 优化，为了更简单的抽象<br>我在明确知道 该类是启动类的情况下，我就会 为该类 进行优化。<br>如果是自定义类，可能就 不会进行 此类优化。<br>在明确 目的的情况下， 专用代码 比 通用代码 更简单，也更有效。</p></blockquote><p>总之，就是为了清晰和方便，这也是我们在进行软件设计的时候最基本的要求，即不能写死代码，影响扩展性；层次结构也不能写的太乱，影响后续的优化。</p><p>至此，双亲委派模型就讲完了。我们也清晰地知道了其设计思想和好处。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈ClassLoader</title>
      <link href="/2019/02/05/JVM/%E6%B5%85%E8%B0%88ClassLoader/"/>
      <url>/2019/02/05/JVM/%E6%B5%85%E8%B0%88ClassLoader/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第二篇文章，上一篇文章初步提到了class文件，以及一个最简单程序执行的指令含义，我们提到，是由JAVA虚拟机先加载这些编译好的class文件，然后再去根据解析出来的指令去转换为具体平台上的机器指令执行，但是加载这个class文件时如何加载的呢？其实就涉及比较重要的东西：ClassLoader</p><a id="more"></a><p>有一个基本认识，从编译到实例化对象的过程可以概括为以下三个阶段：</p><ul><li>编译器将<code>xxx.java</code>源文件编译为<code>xxx.class</code>字节码文件</li><li><code>ClassLoader</code>将字节码转换为JVM种的<code>Class&lt;xxx&gt;</code>对象</li><li>JVM利用<code>Class&lt;xxx&gt;</code>对象实例化为<code>xxx</code>对象</li></ul><h2>一、JVM系统结构</h2><p><img src="http://bloghello.oursnail.cn/jvm2-1.png" alt="image"></p><ul><li><code>ClassLoader</code>：依据特定格式，加载class文件到内存</li><li><code>Execution Engine</code>：对命令进行解析</li><li><code>Native Interface</code>：融合不同开发语言的原生库为Java所用</li><li><code>Runtime Data Area</code>：JVM内存空间结构模型</li></ul><p>首先通过<code>ClassLoader</code>加载符合条件的字节码文件到内存中，然后通过<code>Execution Engine</code>解析字节码指令，交由操作系统去执行。</p><h2>二、什么是ClassLoader</h2><p><code>ClassLoader</code>在java中有着非常重要的作用，它主要工作在<code>Class</code>装载的加载阶段，其主要作用是从系统外部获得<code>Class</code>二进制数据流。他是JAVA的核心组件，所有的<code>Class</code>都是由<code>ClassLoader</code>进行加载的，<code>ClassLoader</code>负责通过将<code>Class</code>文件里的二进制数据流装载进系统，然后交给JAVA虚拟机进行连接、初始化等操作。</p><p>简而言之，就是加载字节码文件。</p><p>我们翻开<code>ClassLoader</code>源码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>它是一个抽象类，下面我们再来说具体的实现类。</p><p>里面比较重要的是<code>loadClass()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是根据<code>name</code>来加载字节码文件，返回<code>Class</code>实例，加载不到则抛出<code>ClassNotFoundException</code>异常。</p><h2>三、ClassLoader的种类</h2><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：由<code>C++</code>语言实现（针对<code>HotSpot</code>）,加载核心库<code>java.*</code>。</li></ul><ul><li>扩展类加载器（<code>Extension ClassLoader</code>）：Java编写，加载扩展库<code>javax.*</code></li></ul><p>它扫描的是哪个路径呢？</p><p><img src="http://bloghello.oursnail.cn/jvm2-2.png" alt="image"></p><p>我们看到，它负责将 <code>&lt;JAVA_HOME &gt;/lib/ext</code>或者由系统变量<code>-Djava.ext.dir</code>指定位置中的类库 加载到内存中。</p><ul><li>应用程序类加载器（<code>Application ClassLoader</code>）：Java编写，加载程序所在目录</li></ul><p><img src="http://bloghello.oursnail.cn/jvm2-3.png" alt="image"></p><p>它负责将 用户类路径(<code>java -classpath</code>或<code>-Djava.class.path</code>变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，看截图的最后一行，显示的是当前项目路径。</p><ul><li>自定义<code>ClassLoader</code>：自定义</li></ul><h2>四、如何自定义ClassLoader</h2><p>要自己实现一个<code>ClassLoader</code>，其核心涉及两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先想一下为什么是这两个类？</p><p>其实答案在<code>loadClass()</code>这个方法里面。如果已经熟悉双亲委派模型的同学，都会知道加载<code>Class</code>对象是先委派给父亲，看父亲是否已经加载，如果没有加载过，则从最顶层父亲开始逐层往下进行加载，这一块详细在下一篇文章中解释，我们先走马观花看看这个的核心方法长啥样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不去重写<code>findClass(name)</code>方法，默认是直接抛出找不到的异常，所以我们要对这个方法进行重写。</p><p>由于字节码文件是一堆二进制流，所以需要一个方法来根据这个二进制流来定义成一个类，即<code>defineClass()</code>这个方法来实现这个功能。</p><p>说的比较抽象，下面来真正实践一把！</p><h2>五、实践自定义ClassLoader</h2><p>首先写一个类：Robot.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello , i am a robot!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对<code>Robot.java</code>用<code>javac</code>编译之后形成<code>Robot.class</code>文件，就要删除本项目下的这个<code>Robot.java</code>文件，要不然就会被<code>AppClassLoader</code>类加载先加载了，而无法再被我们的自定义类加载器再去加载。这个<code>Robot.class</code>文件我就直接放到桌面去了。路径为<code>C:/Users/swg/Desktop/</code>.</p><p>然后定义一个自定义的<code>ClassLoader</code>，按照上面的理论，只要重写<code>findClass</code>就可以指定到某个地方获取class字节码文件，此时获取的是二进制流文件，转换为字节数组，最后借用<code>defineClass</code>获取真正的<code>Class</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行加载的class文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">//自定义类加载器的名字</span></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    MyClassLoader(String path,String classLoaderName)&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于寻找类文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于加载类文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        name = path + name + <span class="string">".class"</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in  = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试一下能不能用自定义类加载器去加载到<code>Robot</code>对应的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\swg\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"Robot"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader@677327b6</span><br><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><p>好了，学习了关于<code>ClassLoader</code>的分类以及如何自定义<code>ClassLoader</code>，我们知道了类加载器的基本实现，上面谈到了一个重要方法是<code>loadClass</code>，这就涉及了类加载器的双亲委派模型。下一节从代码层面好好来说说这个，其实很简单。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019年展望</title>
      <link href="/2019/02/05/suibi/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/"/>
      <url>/2019/02/05/suibi/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/</url>
      <content type="html"><![CDATA[<p>今天是大年初一，算是真正步入2019年了。保存几张老家门口拍的照片，以作纪念。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/suibi1-2.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/suibi1-3.jpg" alt="image"></p><p>老家越来越冷清，越来越萧条。</p><p>今年四月底顺利毕业的话，就真的工作了，在南京，本科+研究生读了七年书，加上小时候每年暑假都来南京玩，对南京的熟悉的程度远远大于家乡盐城。</p><p>所以希望可以努力，在南京能扎下根，然后一家人全搬过去。</p><p>在找工作方面，找的并不理想，可能还在不好的几个offer之中选择了更不好的一个，心里甚是难受。不过，凡事都没有绝对，往好处多想想就好了，关键还是靠自己努力。</p><p>在2018年，算是学习java的进阶之年，自己学习了很多新的技术，也好好地夯实了基础，把以前很多模糊的问题搞清楚了，确实，基础真的太重要的，光学时髦的框架，可以写写简单的CRUD应用，是远远不够的，我觉得程序员的目标是可以造出大家都认可并且乐于使用的开源作品，没有好的基础，便是天方夜谭，也只能永远做一个普通的码农。</p><p>所以，我给自己定一个三年的目标，三年以后，无论是搞java还是搞大数据还是其他，我希望能达到中高级水平，在这个行业方向上有较好的基础和较深的认识。为后续更高的发展打下坚实的基础。</p><p>我希望，github真正能成为我出发的地方，并且能够走很远。犹记得，14年在大神室友的推荐下，注册了github，但是真正使用还是从去年开始吧。所以甚是惭愧，如果早一点上路，虽然追赶不上大神的脚步（已经进了google），但是进个二线比如京东、美团等都是轻而易举吧，但是谈这些确实是废话，没有人有假如。</p><p>除了对未来三年的一些初步想法之外，我还是希望我与家人都有一个健健康康的身体，所以工作以后身体的锻炼是必不可少的，八块腹肌是不指望了，至少爬几层楼不用喘吧。</p><p>一切还是视实际情况而定，但是终身学习的信念要埋藏在心里，这个时代以及未来的时代，选择了这一行，掉头发是注定的了，但是如果仅仅以掉头发的代价，可以让家人舒舒服服，健健康康，开开心心的话，那给我剃个光头也无妨了。</p><p>废话不多说了，我要继续完成本笔记的JVM部分了，不忘初心，套用喜剧之王的台词：努力，奋斗！</p><p><img src="http://bloghello.oursnail.cn/suibi1-4.jpg" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>彻底理解java反射机制</title>
      <link href="/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<p>反射机制这一块也是面试经常会被问到的，我从反射的基本概念到反射的一些面试题出发，好好理一理反射的知识。</p><a id="more"></a><h2>1. 什么是反射</h2><p>标准定义：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用方法的功能成为反射机制。</p><p>注意几个关键字：运行状态中，动态获取。</p><h2>2. Class对象和实例对象</h2><p>想要理解反射首先需要知道<code>Class</code>这个类，它的全称是<code>java.lang.Class</code>类。java是面向对象的语言，讲究万物皆对象，即使强大到一个类，它依然是另一个类（<code>Class</code>类）的对象，换句话说，普通类是<code>Class</code>类的对象，即<code>Class</code>是所有类的类（<code>There is a class named Class</code>）。</p><p>我们知道java世界是运行在JVM之上的，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的<code>.class</code>文件，这个就是JVM可以加载执行的字节码。</p><p>运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(<code>class loader</code>)的<code>defineClass()</code>被JVM调用，便会为这个类产生一个<code>Class</code>对象（一个<code>Class</code>类的实例），用来表达这个类，该类的所有实例都共同拥有着这个<code>Class</code>对象，而且是唯一的。</p><p>也就是说，加载<code>.class</code>文件之后会生成一个对应的<code>Class</code>对象。下面说说如何获取这个<code>Class</code>对象。</p><h2>3. 取得Class对象的三种方式</h2><p>我们假设有这么一个类叫<code>MyClass</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li>第一种方式：通过“类名.class”的方式取得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class classInstance= MyClass.class;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Car.class;</span><br><span class="line">Class cls1 = int.class;</span><br><span class="line">Class cls2 = String.class;</span><br></pre></td></tr></table></figure><ul><li>第二种方式：通过类创建的实例对象的<code>getClass</code>方法取得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">Class classInstance = myClass.getClass();</span><br></pre></td></tr></table></figure><ul><li>第三种方式：通过<code>Class</code>类的静态方法<code>forName</code>方法取得（参数是带包名的完整的类名）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class classInstance = Class.forName(<span class="string">"mypackage.MyClass"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种方法取得的对象都是相同的，所以效果上等价。</p><p><code>classInstance</code>是类类型，通过类类型可以得到一个类的属性和方法等参数，这是反射的基础。</p><h2>4. 利用反射API全面分析类的信息——方法，成员变量，构造器</h2><p>反射的一大作用是用于分析类的结构，或者说用于分析和这个类有关的所有信息。而这些信息就是类的基本的组成： 方法，成员变量和构造器。</p><p>在java种万物皆对象，一个类中的方法，成员变量和构造器也分别对应着一个对象</p><ol><li>每个方法都对应有一个保存和该方法有关信息的<strong>Method对象</strong>， 这个对象所属的类是<code>java.lang.reflect.Method</code>;</li><li>每个成员变量都对应有一个保存和该变量有关信息的<strong>Field对象</strong>，这个对象所属的类是 <code>java.lang.reflect.Field</code></li><li>每个构造器都对应有一个保存和该构造器有关信息的<strong>Constructor对象</strong>，这个对象所属的类是<code>java.lang.reflect.Constructor</code></li></ol><p>假设c是一个类的Class对象：</p><ul><li>通过 <code>c.getDeclaredMethods()</code>可取得这个类中所有声明方法对应的<code>Method</code>对象组成的数组</li><li>通过 <code>c.getDeclaredFields()</code>可取得这个类中所有声明的成员变量对应的<code>Field</code>对象组成的数组</li><li>通过 <code>c.getConstructors()</code>; 可取得这个类中所有构造函数所对应的<code>Constructor</code>对象所组成的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method [] methods = c.getDeclaredMethods(); <span class="comment">// 获取方法对象列表</span></span><br><span class="line"> </span><br><span class="line">Field [] fields = c.getDeclaredFields();   <span class="comment">// 获取成员变量对象列表</span></span><br><span class="line"></span><br><span class="line">Constructor [] constructors = c.getConstructors();  <span class="comment">// 获取构造函数对象列表</span></span><br><span class="line"></span><br><span class="line">xxx.getName()就可以打印出对应的名字了。</span><br></pre></td></tr></table></figure><h2>5. 更多的反射api</h2><h5>getMethods和getDeclaredMethods方法</h5><ul><li><code>getMethods</code>取得的<code>method</code>对应的方法<strong>包括从父类中继承的那一部分</strong>，而</li><li><code>getDeclaredMethods</code>取得的<code>method</code>对应的方法<strong>不包括从父类中继承的那一部分</strong></li></ul><p>一个普通的类，他们的基类都是<code>Object</code>，那么如果用<code>getMethods</code>，遍历得到的结果，会发现<code>Object</code>中的基础方法名都会被打印出来。</p><p>诸如<code>wait()</code>,<code>equals()</code>,<code>toString()</code>,<code>getClass()</code>,<br><code>notify()</code>,<code>notifyAll()</code>,<code>hashCode()</code>等等。</p><h5>通过method.getReturnType()获取方法返回值对应的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class returnClass = method.getReturnType(); <span class="comment">// 获取方法返回值对应的Class对象</span></span><br><span class="line">String returnName = returnClass.getName();  <span class="comment">//获取返回值所属类的类名——也即返回值类型</span></span><br></pre></td></tr></table></figure><h5>通过method.getParameterTypes()获取方法各参数的Class对象组成的数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class [] paramsClasses = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class pc: paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName(); <span class="comment">// 获取当前参数类型</span></span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>获取成员变量类型对应的的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = c.getDeclaredField(<span class="string">"name"</span>);  <span class="comment">// 取得名称为name的field对象</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 这一步很重要！！！设置为true才能访问私有成员变量name的值！</span></span><br><span class="line">String nameValue = (String) field.get(obj); <span class="comment">// 获取obj中name成员变量的值</span></span><br></pre></td></tr></table></figure><h5>通过getType方法读取成员变量类型的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = class1.getDeclaredField(number<span class="string">");</span></span><br><span class="line"><span class="string">System.out.print(field.getType().getName());</span></span><br></pre></td></tr></table></figure><p>因为java权限的原因，直接读取私有成员变量的值是非法的（加了<code>field.setAccessible(true)</code>后就可以了），但仍可以直接读取私有成员变量的类型</p><h5>利用反射API分析类中构造器信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> a, String str)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printContructorsMessage</span> <span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">Class c = obj.getClass();  <span class="comment">// 取得obj所属类对应的Class对象</span></span><br><span class="line">Constructor [] constructors = c.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">  Class [] paramsClasses =  constructor.getParameterTypes();</span><br><span class="line">  String paramsStr = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (Class pc : paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName();</span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"构造函数的所有参数的类型列表："</span> + paramsStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数的所有参数的类型列表：<span class="keyword">int</span>  java.lang.String</span><br></pre></td></tr></table></figure><h2>6. 利用反射动态加载类，并用该类创建实例对象</h2><p>我们用普通的方式使用一个类的时候，类是静态加载的<br>，<strong>而使用Class.forName(“XXX”)这种方式，则属于动态加载一个类</strong></p><p>静态加载的类在编译的时候就能确定该类是否存在，但动态加载一个类的时候却无法在编译阶段确定是否存在该类，而是在运行时候才能够确定是否有这个类，所以要捕捉可能发生的异常.</p><p>Class对象有一个<code>newInstance</code>方法，我们可以用它来创建实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class classInstance = Class.forName(<span class="string">"mypackage.MyClass"</span>);</span><br><span class="line">MyClass myClass = (MyClass) classInstance.newInstance();</span><br></pre></td></tr></table></figure><h2>7. 总结</h2><ul><li>反射为我们提供了全面的分析类信息的能力，例如类的方法，成员变量和构造器等的相关信息，反射能够让我们很方便的获取这些信息， 而实现这个获取过程的关键是取得类的<code>Class</code>对象，然后根据<code>Class</code>对象取得相应的<code>Method</code>对象，<code>Field</code>对象和<code>Constructor</code>对象，再分别根据各自的API取得信息。</li><li>反射还为我们提供动态加载类的能力</li><li>API中<code>getDeclaredXXX</code>和<code>getXXX</code>的区别在于前者只获取本类声明的XXX（如成员变量或方法），而不获取超类中继承的XXX， 后者都可以获取</li><li>API中， <code>getXXXs</code>（注意后面的s）返回的是一个数组， 而对应的 <code>getXXX</code>（“键”）按键获取一个值（这个时候因为可能报已检查异常所以要用try*catch语句包裹）</li><li>私有成员变量是不能直接获取到值的！因为java本身的保护机制，允许你取得私有成员变量的类型，但是不允许直接获取值，所以要对对应的<code>field</code>对象调用<code>field.setAccessible(true)</code> 放开权限</li></ul><h2>8. 面试</h2><h4>什么是反射</h4><p>反射是一种能够在程序运行时动态访问、修改某个类中任意属性（状态）和方法（行为）的机制</p><h4>反射到底有什么具体的用处</h4><ul><li>操作因访问权限限制的属性和方法；</li><li>实现自定义注解；</li><li>动态加载第三方jar包，解决android开发中方法数不能超过65536个的问题；</li><li>按需加载类，节省编译和初始化APK的时间；</li></ul><h4>反射的原理是什么</h4><p>当我们编写完一个Java项目之后，每个java文件都会被编译成一个.class文件，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被ClassLoader加载到虚拟机中。当一个类被加载以后，Java虚拟机就会在内存中自动产生一个Class对象。我们通过new的形式创建对象实际上就是通过这些Class来创建，只是这个过程对于我们是透明的而已。</p><p>反射的工作原理就是借助<code>Class.java</code>、<code>Constructor.java</code>、<br><code>Method.java</code>、<code>Field.java</code>这四个类在程序运行时动态访问和修改任何类的行为和状态。</p><h4>如何获取Class对象</h4><ul><li><code>Class</code>的<code>forName()</code>方法的返回值就是<code>Class</code>类型，也就是动态导入类的<code>Class</code>对象的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure><ul><li>每个类都会有一个名称为<code>Class</code>的静态属性，通过它也是可以获取到<code>Class</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz = Student.class;</span><br></pre></td></tr></table></figure><ul><li><code>Object</code>类中有一个名为<code>getClass</code>的成员方法，它返回的是对象的运行时类的<code>Class</code>对象。因为<code>Object</code>类是所有类的父类，所以，所有的对象都可以使用该方法得到它运行时类的<code>Class</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">Class&lt;Student&gt; clazz = stu.getClass();</span><br></pre></td></tr></table></figure><h4>反射的特点</h4><blockquote><p>优点</p></blockquote><ul><li>灵活、自由度高：不受类的访问权限限制，想对类做啥就做啥</li></ul><blockquote><p>缺点</p></blockquote><ul><li>性能问题</li></ul><p>通过反射访问、修改类的属性和方法时会远慢于直接操作，但性能问题的严重程度取决于在程序中是如何使用反射的。如果使用得很少，不是很频繁，性能将不会是什么问题；</p><ul><li>安全性问题</li></ul><p>反射可以随意访问和修改类的所有状态和行为，破坏了类的封装性，如果不熟悉被反射类的实现原理，随意修改可能导致潜在的逻辑问题；</p><h4>如何提高反射性能</h4><p>java应用反射的时候，性能往往是java程序员担心的地方，那么在大量运用反射的时候，性能的微弱提升，对这个系统而言都是如旱地逢甘霖。</p><ul><li><code>setAccessible(true)</code>,可以防止安全性检查（做这个很费时）</li><li>做缓存，把要经常访问的元数据信息放入内存中，<code>class.forName</code> 太耗时</li><li><code>getMethods()</code> 等方法尽量少用，尽量调用<code>getMethod(name)</code>指定方法的名称，减少遍历次数</li></ul><h4>java面试中面试官让你讲讲反射，应该从何讲起？</h4><p>先讲反射机制，反射就是程序运行期间JVM会对任意一个类洞悉它的属性和方法，对任意一个对象都能够访问它的属性和方法。依靠此机制，可以动态的创建一个类的对象和调用对象的方法。</p><p>其次就是反射相关的API，只讲一些常用的，比如获取一个<code>Class</code>对象。<code>Class.forName(完整类名)</code>。通过<code>Class</code>对象获取类的构造方法，<code>class.getConstructor</code>。根据<code>Class</code>对象获取类的方法，<code>getMethod</code>和<code>getMethods</code>。使用<code>Class</code>对象创建一个对象，<code>class.newInstance</code>等。</p><p>最后可以说一下反射的优点和缺点，优点就是增加灵活性，可以在运行时动态获取对象实例。缺点是反射的效率很低，而且会破坏封装，通过反射可以访问类的私有方法，不安全。</p>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java如何执行一个最简单的程序</title>
      <link href="/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第一篇文章，需要之前对JVM有一定了解的基础。我们都知道，JAVA号称：一次编译多处运行。这就离不开字节码文件和虚拟机啦！那么，虚拟机到底是如何去执行一个简单的程序的呢？理解了这个，我们就可以理解java时如何做到平台无关的了。下面我们来分析分析。</p><a id="more"></a><p>首先，写一个最简单的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">5</span>;</span><br><span class="line">        i++;</span><br><span class="line">        ++j;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后的结果想必就一目了然，我们就通过这个程序来分析分析到底是怎么执行这个程序额的。</p><p>首先呢，java程序的执行经历编译，编译成系统能识别的文件，这里的系统对应java语言就是JVM，即JAVA虚拟机。JVM在识别之后，再去与我们真正的操作系统进行交互和处理。</p><p>所以，我们要执行一个.java程序，必须要先进行编译。初学者都会学习一个指令叫做<code>javac</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-1.png" alt="image"></p><p>我们会发现路径下面就会多一个.class文件，这就是编译之后的文件。直接点开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> var1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> var2 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> var3 = var1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> var4 = var2 + <span class="number">1</span>;</span><br><span class="line">        System.out.println(var3);</span><br><span class="line">        System.out.println(var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看第一行注释，说的是编译后的文件已经自动被<code>IDEA</code>反编译了，所以我们还能看得懂。真正的文件是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">漱壕   4 </span><br><span class="line">    </span><br><span class="line">     &lt;init&gt; ()V Code LineNumberTable main ([Ljava/lang/String;)V </span><br><span class="line">SourceFile Main.java         Main java/lang/Object java/lang/System out Ljava/io/PrintStream; java/io/PrintStream println (I)V !                    *? ?             </span><br><span class="line">      E     &lt;=??? ? ? ? ?</span><br></pre></td></tr></table></figure><p>我们可以看到，其实是一堆乱码，根本看不懂。而在执行的时候，class文件是一种8位字节的二进制流文件。放在<code>sublime</code>中可以看到二进制文件（以16进制显示，在JAVA虚拟机中将来了解这各文件的含义，我们可以看到第一个单词是cafe babe，表明这是一个class字节码文件）：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-2.png" alt="image"></p><p>那么我们想看看.class中的信息，还是需要反编译，这个时候可以用<code>javap</code>指令来做。如果我们对其不熟悉，可以先执行<code>javap -help</code>来了解了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>我们注意到，有一个<code>-c</code>是进行反汇编，那么就用它试试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;javap -c Main.class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Compiled from &quot;Main.java&quot;</span><br><span class="line">public class Main &#123;</span><br><span class="line">  public Main();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_5</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iinc          1, 1</span><br><span class="line">       7: iinc          2, 1</span><br><span class="line">      10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      13: iload_1</span><br><span class="line">      14: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      17: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: iload_2</span><br><span class="line">      21: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      24: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这反汇编出来的东西是什么呢？这是一连串的指令，其实这些是加载class文件时真正执行的java虚拟机指令。</p><p>我们来看看它的含义吧！</p><p><img src="http://bloghello.oursnail.cn/javabasic6-3.png" alt="image"></p><p>仔细看看，其实发现并不神秘，一个函数的执行是一个入栈出栈的过程。ok，大体了解了字节码文件是什么以及里面的指令含义之后，我们对java如何执行它已经大体清楚了。下面执行一下：</p><p>那么如何运行呢？</p><p><img src="http://bloghello.oursnail.cn/javabasic6-4.png" alt="image"></p><p>其实这是废话，初学java其实是<code>java Main</code>运行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;java Main</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>这个时候，class文件可以移植到任何平台上去，比如直接上传到<code>linux</code>上，只要JDK或者JRE环境类似即可，就可以直接运行了，不需要编译，也不需要关心是什么系统。这就做到了一次编译到处运行。</p><p>下面总结一下：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-5.png" alt="image"></p><p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，JAVA语言在不同平台上运行时不需要进行重新编译，JAVA虚拟机在执行字节码的时候，把字节码转换为具体平台上的机器指令，然后各种操作系统就可以正确识别了。这就是JAVA如何执行代码和平台无关性的原因。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Redis一些重要的面试点</title>
      <link href="/2019/02/02/redis/%E5%85%B3%E4%BA%8ERedis%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%82%B9/"/>
      <url>/2019/02/02/redis/%E5%85%B3%E4%BA%8ERedis%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>这里整理一些面试题目，很多已经在前面的文章中详细说明了，这里算是总结一下。也补充了一点新的知识。</p><a id="more"></a><h2>Redis有哪些数据结构？</h2><p>字符串 <code>String</code>、字典 <code>Hash</code> 、列表 <code>List</code> 、集合 <code>Set</code> 、有序集合 <code>SortedSet</code>。</p><p>如果你是Redis中高级用户，还需要加上下面几种数据结构<code>HyperLogLog</code>、<code>Geo</code>、<code>Pub/Sub</code>。</p><h2>String类型的底层数据结构</h2><p>Redis 是一个键值对数据库, 数据库的值可以是字符串、集合、列表等多种类型的对象， 而数据库的键则总是字符串对象。</p><p>对于那些包含字符串值的字符串对象来说， 每个字符串对象都包含一个 <code>sds</code> 值。</p><div class="tip">“包含字符串值的字符串对象”，这种说法初听上去可能会有点奇怪， 但是在 Redis 中， 一个字符串对象除了可以保存字符串值之外， 还可以保存 long 类型的值， 所以为了严谨起见， 这里需要强调一下： 当字符串对象保存的是字符串时， 它包含的才是 sds 值， 否则的话， 它就是一个 long 类型的值。</div><p>举个例子， 以下命令创建了一个新的数据库键值对， 这个键值对的键和值都是字符串对象， 它们都包含一个 <code>sds</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET book &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET book</span><br><span class="line">&quot;Mastering C++ in 21 days&quot;</span><br></pre></td></tr></table></figure><p>目前来说， 只要记住这个事实即可： 在 <code>Redis</code> 中， 客户端传入服务器的协议内容、 aof 缓存、 返回给客户端的回复， 等等， 这些重要的内容都是由 <code>sds</code> 类型来保存的。</p><p>在 C 语言中，字符串可以用一个 <code>\0</code> 结尾的 <code>char</code> 数组来表示。</p><p>比如说， <code>hello world</code> 在 C 语言中就可以表示为 <code>&quot;hello world\0&quot;</code> 。</p><p>这种简单的字符串表示，在大多数情况下都能满足要求，但是，它并不能高效地支持长度计算和追加（<code>append</code>）这两种操作：</p><ul><li>每次计算字符串长度（<code>strlen(s)</code>）的复杂度为 θ(N) 。</li><li>对字符串进行 N 次追加，必定需要对字符串进行 N 次内存重分配（<code>realloc</code>）。</li></ul><p>在 <code>Redis</code> 内部， 字符串的追加和长度计算很常见， 而 <code>APPEND</code> 和 <code>STRLEN</code> 更是这两种操作，在 <code>Redis</code> 命令中的直接映射， 这两个简单的操作不应该成为性能的瓶颈。</p><p>另外， <code>Redis</code> 除了处理字符串之外， 还需要处理单纯的字节数组， 以及服务器协议等内容， 所以为了方便起见， <code>Redis</code> 的字符串表示还应该是二进制安全的： 程序不应对字符串里面保存的数据做任何假设， 数据可以是以 \0 结尾的 C 字符串， 也可以是单纯的字节数组， 或者其他格式的数据。</p><p>考虑到这两个原因， <code>Redis</code> 使用 <code>sds</code> 类型替换了 C 语言的默认字符串表示： sds 既可高效地实现追加和长度计算， 同时是二进制安全的。</p><p>在前面的内容中， 我们一直将 <code>sds</code> 作为一种抽象数据结构来说明， 实际上， 它的实现由以下两部分组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 已占用长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 剩余可用长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，类型 <code>sds</code> 是 <code>char *</code> 的别名（alias），而结构 <code>sdshdr</code> 则保存了 <code>len</code> 、 <code>free</code> 和 <code>buf</code> 三个属性。</p><p>作为例子，以下是新创建的，同样保存 <code>hello world</code> 字符串的 <code>sdshdr</code> 结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    len = 11;</span><br><span class="line">    free = 0;</span><br><span class="line">    buf = &quot;hello world\0&quot;;  // buf 的实际长度为 len + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>len</code> 属性， <code>sdshdr</code> 可以实现复杂度为 θ(1) 的长度计算操作。</p><p>另一方面， 通过对 <code>buf</code> 分配一些额外的空间， 并使用 <code>free</code> 记录未使用空间的大小， <code>sdshdr</code> 可以让执行追加操作所需的内存重分配次数大大减少。</p><p>为了易于理解，我们用一个 <code>Redis</code> 执行实例作为例子，解释一下，当执行以下代码时， <code>Redis</code> 内部发生了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND msg <span class="string">" again!"</span></span><br><span class="line">(integer) <span class="number">18</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world again!"</span></span><br></pre></td></tr></table></figure><p>首先， <code>SET</code> 命令创建并保存 <code>hello world</code> 到一个 <code>sdshdr</code> 中，这个 <code>sdshdr</code> 的值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    buf = <span class="string">"hello world\0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <code>APPEND</code> 命令时，相应的 <code>sdshdr</code> 被更新，字符串 &quot; again!&quot; 会被追加到原来的 “hello world” 之后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">18</span>;</span><br><span class="line">    buf = <span class="string">"hello world again!\0                  "</span>;     <span class="comment">// 空白的地方为预分配空间，共 18 + 18 + 1 个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中， 保存 “hello world again!” 共需要 18 + 1 个字节， 但程序却为我们分配了 18 + 18 + 1 = 37 个字节 —— 这样一来， 如果将来再次对同一个 <code>sdshdr</code> 进行追加操作， 只要追加内容的长度不超过 <code>free</code> 属性的值， 那么就不需要对 <code>buf</code> 进行内存重分配。</p><div class="tip">这种分配策略会浪费内存吗？执行过 APPEND 命令的字符串会带有额外的预分配空间， 这些预分配空间不会被释放， 除非该字符串所对应的键被删除， 或者等到关闭 Redis 之后， 再次启动时重新载入的字符串对象将不会有预分配空间。<p>因为执行 APPEND 命令的字符串键数量通常并不多， 占用内存的体积通常也不大， 所以这一般并不算什么问题。</p><p>另一方面， 如果执行 APPEND 操作的键很多， 而字符串的体积又很大的话， 那可能就需要修改 Redis 服务器， 让它定时释放一些字符串键的预分配空间， 从而更有效地使用内存。</p></div><p>当然， <code>sds</code> 也对操作的正确实现提出了要求 —— 所有处理 <code>sdshdr</code> 的函数，都必须正确地更新 <code>len</code> 和 <code>free</code> 属性，否则就会造成 bug 。</p><p>更多参见：<a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html" target="_blank" rel="noopener">简单动态字符串</a></p><h2>从海量数据中查询某一固定前缀的key</h2><p>使用<code>keys</code>指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<code>scan</code>指令，scan指令可以<strong>无阻塞</strong>的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><p>基于游标的迭代器，需要使用上一次游标延续之前的迭代过程。游标为0的时候代表开始或结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#模式</span><br><span class="line">scan cursor match pattern count</span><br><span class="line">#示例</span><br><span class="line">scan 0 match k* count 10</span><br></pre></td></tr></table></figure><h2>Redis做异步队列</h2><p>一般使用<code>list</code>结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当<code>lpop</code>没有消息的时候，要适当<code>sleep</code>一会再重试。</p><p>如果对方追问可不可以不用<code>sleep</code>呢？<code>list</code>还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p><p>如果对方追问能不能生产一次消费多次呢？使用<code>pub/sub</code>主题订阅者模式，可以实现1:N的消息队列。</p><p>如果对方追问<code>pub/sub</code>有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>rabbitmq</code>等。</p><p>如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用<code>sortedset</code>，拿时间戳作为<code>score</code>，消息内容作为<code>key</code>调用<code>zadd</code>来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理。</p><h2>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2>Redis如何做持久化的？</h2><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><p>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><p>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h2>Redis的同步机制了解么？</h2><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h2>是否使用过Redis集群，集群的原理是什么？</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p><p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><p>整理自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32540678" target="_blank" rel="noopener">天下无难试之Redis面试题刁难大全</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种主流缓存框架介绍</title>
      <link href="/2019/02/02/redis/%E5%87%A0%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/02/02/redis/%E5%87%A0%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第十二篇文章。本文对Guava Cache,Memcache以及redis进行简单介绍和对比。</p><a id="more"></a><h2>缓存特征</h2><p>缓存都会涉及：命中率、最大元素、清空策略(<code>FIFO</code>,<code>LFU</code>,<code>LRU</code>,过期时间，随机)</p><h2>影响缓存命中率因素</h2><ul><li>业务场景和业务需求：适合读多写少的场景</li><li>缓存的设计(粒度和策略)：缓存粒度越小，命中率越高</li><li>缓存容量(经常用LRU)和基础设施(是否可扩展，避免缓存失效-一致性hash算法和几点冗余)</li></ul><h2>缓存分类</h2><ul><li>本地缓存：编程实现（成员变量、局部变量、静态变量）、Guava Cache</li><li>分布式缓存：Memcache，Redis</li></ul><p>本地缓存：各应用之间无法很好地共享，与应用本身耦合过紧；而分布式缓存，本身就是独立的应用，各独立应用之间共享缓存。</p><h2>Guava Cache</h2><p><img src="http://bloghello.oursnail.cn/GuavaCache.png" alt="image"></p><p>设计思想类似于jdk1.7中的<code>ConcurrentHashMap</code>，也是用多个<code>segments</code>的细粒度锁，在保证线程安全的同时，支持高并发场景的需求。</p><p>下面数据存储就是以键值对的形式存储，另外，需要处理缓存过期、动态加载等算法逻辑，所以需要一些额外的信息来实现这些操作。</p><p>主要实现的功能有：自动将节点加入到缓存结构中，当缓存的数据超过设置的最大值时，用LRU算法来移除。他具备根据节点上次被访问或者写入的时间来计算他的过期机制。</p><h2>memcache</h2><h5>memcache简单认识</h5><p><code>memcache</code>是一个高性能的分布式的内存对象缓存系统，它在内存里维护一个统一的巨大的<code>hash</code>表。能用来缓存各种格式的数据，包括图像、视频、文件以及数据库检索等结果.</p><p><code>memcache</code>是以守护程序方式运行于一个或多个服务器中，随时会接收客户的连接和操作。</p><p>存在<code>memcache</code>中的对象实际放置在内存中，这也是<code>memcache</code>如此高效的原因。</p><p>本身是不提供分布式的解决方案的。分布式是在客户端实现的，通过客户端的路由来处理达到分布式的目的。</p><p>应用服务器每次在存储某个<code>key</code>和<code>value</code>的时候，通过某种算法把<code>key</code>映射到某台服务器上。</p><h5>一致性hash算法</h5><p>客户端实现分布式：一致性<code>hash</code>算法，<a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">这个算法已经详细介绍过了</a>。</p><p><img src="http://bloghello.oursnail.cn/memcache%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="image"></p><h5>memcache一些特性</h5><blockquote><p><code>Memcached</code>单进程在32位系统中最大使用内存为2G，若在64位系统则没有限制,这是由于32位系统限制单进程最多可使用2G内存,要使用更多内存，可以分多个端口开启多个<code>Memcached</code>进程。</p></blockquote><p>32 位寻址空间只有 4GB 大小，于是 32 位应用程序进程最大只能用到 4GB 的内存。然而，除了应用程序本身要用内存，操作系统内核也需要使用。应用程序使用的内存空间分为用户空间和内核空间，每个 32 位程序的用户空间可独享前 2GB 空间（指针值为正数），而内核空间为所有进程共享 2GB 空间（指针值为负数）。所以，32 位应用程序实际能够访问的内存地址空间最多只有 2GB。</p><blockquote><p>最大30天的数据过期时间，设置为永久也会在这个时间过期。最长键长为250字节，大于该长度无法存储。最大同时连接数是200;</p></blockquote><blockquote><p><code>memcache</code>是一种无阻塞的<code>socket</code>通信方式服务，基于<code>libevent</code>库，犹豫无阻塞通信，对内存读写速度非常快。</p></blockquote><h5>不适用memcached的业务场景？</h5><blockquote><p>缓存对象的大小大于1MB</p></blockquote><blockquote><p>虚拟主机不让运行<code>memcached</code>服务</p></blockquote><blockquote><p>key的长度大于250字符</p></blockquote><blockquote><p>需要持久化</p></blockquote><h5>不能够遍历memcached中所有的item？</h5><p>这个操作的速度相对缓慢且阻塞其他的操作</p><h5>memcache如何分配内存？</h5><p>这张图片里面涉及了<code>slab_class</code>、<code>slab</code>、<code>page</code>、<code>chunk</code>四个概念，它们之间的关系是：</p><ul><li><code>MemCache</code>将内存空间分为一组<code>slab</code></li><li>每个<code>slab</code>下又有若干个<code>page</code>，每个<code>page</code>默认是1M，如果一个<code>slab</code>占用100M内存的话，那么这个slab下应该有100个page</li><li>每个page里面包含一组<code>chunk</code>，<code>chunk</code>是真正存放数据的地方，同一个<code>slab</code>里面的<code>chunk</code>的大小是固定的</li><li>有相同大小<code>chunk</code>的<code>slab</code>被组织在一起，称为<code>slab_class</code></li></ul><p><img src="http://bloghello.oursnail.cn/memcache%E5%8E%9F%E7%90%86.png" alt="image"></p><p><strong>那么是具体如何分配的呢？</strong></p><blockquote><p><code>MemCache</code>中的<code>value</code>过来存放的地方是由<code>value</code>的大小决定的，<code>value</code>总是会被存放到与<code>chunk</code>大小最接近的一个<code>slab</code>中，比如<code>slab[1]</code>的<code>chunk</code>大小为80字节、<code>slab[2]</code>的<code>chunk</code>大小为100字节、<code>slab[3]</code>的<code>chunk</code>大小为128字节（相邻<code>slab</code>内的<code>chunk</code>基本以1.25为比例进行增长，<code>MemCache</code>启动时可以用-f指定这个比例），那么过来一个88字节的<code>value</code>，这个<code>value</code>将被放到2号<code>slab</code>中。</p></blockquote><blockquote><p>放<code>slab</code>的时候，首先<code>slab</code>要申请内存，申请内存是以<code>page</code>为单位的，所以在放入第一个数据的时候，无论大小为多少，都会有1M大小的<code>page</code>被分配给该<code>slab</code>。申请到<code>page</code>后，<code>slab</code>会将这个<code>page</code>的内存按<code>chunk</code>的大小进行切分，这样就变成了一个<code>chunk</code>数组，最后从这个<code>chunk</code>数组中选择一个用于存储数据。</p></blockquote><blockquote><p>如果这个slab中没有<code>chunk</code>可以分配了怎么办，如果<code>MemCache</code>启动没有追加-M（禁止LRU，这种情况下内存不够会报<code>Out Of Memory</code>错误），那么<code>MemCache</code>会把这个<code>slab</code>中最近最少使用的<code>chunk</code>中的数据清理掉，然后放上最新的数据。</p></blockquote><blockquote><ol><li><code>MemCache</code>的内存分配<code>chunk</code>里面会有内存浪费，88字节的<code>value</code>分配在128字节（紧接着大的用）的<code>chunk</code>中，就损失了30字节，但是这也避免了管理内存碎片的问题</li></ol></blockquote><blockquote><ol start="2"><li><code>MemCache</code>的<code>LRU</code>算法不是针对全局的，是针对<code>slab</code>的</li></ol></blockquote><blockquote><ol start="3"><li>该可以理解为什么<code>MemCache</code>存放的<code>value</code>大小是限制的，因为一个新数据过来，<code>slab</code>会先以<code>page</code>为单位申请一块内存，申请的内存最多就只有1M，所以<code>value</code>大小自然不能大于1M了</li></ol></blockquote><h5>最后再总结一下memcache</h5><ul><li><code>MemCache</code>中可以保存的<code>item</code>数据量是没有限制的，只要内存足够</li><li><code>MemCache</code>单进程在32位机中最大使用内存为2G，64位机则没有限制</li><li><code>Key</code>最大为250个字节，超过该长度无法存储</li><li>单个<code>item</code>最大数据是1MB，超过1MB的数据不予存储</li><li><code>MemCache</code>服务端是不安全的，比如已知某个<code>MemCache</code>节点，可以直接<code>telnet</code>过去，并通过<code>flush_all</code>让已经存在的键值对立即失效</li><li>不能够遍历<code>MemCache</code>中所有的<code>item</code>，因为这个操作的速度相对缓慢且会阻塞其他的操作</li><li><code>MemCache</code>的高性能源自于两阶段哈希结构：第一阶段在客户端，通过<code>Hash</code>算法根据<code>Key</code>值算出一个节点；第二阶段在服务端，通过一个内部的<code>Hash</code>算法，查找真正的<code>item</code>并返回给客户端。从实现的角度看，<code>MemCache</code>是一个非阻塞的、基于事件的服务器程序</li><li><code>MemCache</code>设置添加某一个<code>Key</code>值的时候，传入<code>expire</code>为0表示这个<code>Key</code>值永久有效，这个<code>Key</code>值也会在30天之后失效</li></ul><h2>redis</h2><h5>redis特点</h5><ul><li>支持数据持久化，可以将内存中的数据保存到磁盘。</li><li>支持更多的数据结构</li><li>支持数据备份</li><li>性能极高，读可以达到11万次每秒；写达到8万1千次每秒</li><li>redis所有操作都是原子性，并且支持几个操作一起的原子性</li><li>支持发布-订阅功能</li></ul><h5>redis适用场景</h5><ul><li>取最新n个数据、排行榜</li><li>精准过期时间</li><li>计数器</li><li>唯一性检查</li><li>实时系统、垃圾系统、缓存等</li></ul><h2>redis VS memcache</h2><p>当提到<code>redis</code>就问<code>memcache</code>，当提到<code>memcache</code>就提到<code>redis</code>，说明这两者用的都十分广泛，<code>redis</code>号称“强化版<code>memcached</code>”，他们之间的区别到底是啥呢？</p><ul><li>基本命令</li></ul><blockquote><p><code>memcache</code>支持的命令很少，因为他只支持<code>String</code>的操作，通讯协议包括文本格式和二进制格式，用于满足简单网络客户端工具（如<code>telnet</code>）和对性能要求更高的客户端的不同需求；<code>redis</code>操作类似，只是数据结构更复杂以支持更多的特性，如发布订阅、消息队列等。<code>redis</code>的客户端-服务器通讯协议完全采用文本格式(Redis Cluster服务端节点之间通讯采用二进制格式)。</p></blockquote><ul><li>事务</li></ul><blockquote><p><code>redis</code>通过<code>multi</code> / <code>watch</code> / <code>exec</code>等命令可以支持事务的概念，原子性的执行一批命令;</p><p><code>memcache</code>:即使在多线程模式，所有的命令都是原子的；命令序列不是原子的。在并发的情况下，您也可能覆写了一个被其他进程set的item。<code>memcached 1.2.5</code>以及更高版本，提供了<code>gets</code>和<code>cas</code>命令，它们可以解决上面的问题。如果您使用<code>gets</code>命令查询某个<code>key</code>的<code>item</code>，<code>memcached</code>会给您返回该<code>item</code>当前值的唯一标识。如果您覆写了这个<code>item</code>并想把它写回到<code>memcached</code>中，您可以通过<code>cas</code>命令把那个唯一标识一起发送给 <code>memcached</code>。如果该<code>item</code>存放在<code>memcached</code>中的唯一标识与您提供的一致，您的写操作将会成功。如果另一个进程在这期间也修改了这个 <code>item</code>，那么该<code>item</code>存放在<code>memcached</code>中的唯一标识将会改变，您的写操作就会失败。</p></blockquote><ul><li>数据备份，有效性，持久化等</li></ul><blockquote><p><code>memcached</code>不保证存储的数据的有效性，<code>slab</code>内部基于<code>LRU</code>也会自动淘汰旧数据;<code>memcached</code>也不做数据的持久化工作;</p><p><code>redis</code>可以以<code>master-slave</code>的方式配置服务器，<code>slave</code>节点对数据进行<code>replica</code>备份，<code>slave</code>节点也可以充当<code>read only</code>的节点分担数据读取的工作;<code>redis</code>内建支持两种持久化方案，<code>snapshot</code>快照和<code>AOF</code>增量<code>Log</code>方式。</p></blockquote><ul><li>性能</li></ul><blockquote><p><code>memcached</code>自身并不主动定期检查和标记哪些数据需要被淘汰，只有当再次读取相关数据时才检查时间戳，或者当内存不够使用需要主动淘汰数据时进一步检查<code>LRU</code>数据。</p><p><code>redis</code>为了减少大量小数据CMD操作的网络通讯时间开销 <code>RTT (Round Trip Time)</code>，支持<code>pipeline</code>和<code>script</code>技术。</p></blockquote><ul><li>集群</li></ul><blockquote><p><code>memcached</code>的服务器端互相完全独立，客户端通常通过对键值应用<code>hash</code>算法决定数据的分区，为了减少服务器的增减对<code>hash</code>结果的影响，导致大面积的缓存失效，多数客户端实现了一致性<code>hash</code>算法。</p><p><code>redis3.0</code>已经支持服务端集群了。</p></blockquote><ul><li>性能对比</li></ul><blockquote><p>由于<code>redis</code>只使用单核，而<code>memcached</code>可以使用多核，所以平均每一个核上<code>redis</code>在存储小数据时比<code>memcached</code>性能更高。而在100k以上的数据中，<code>memcached</code>性能要高于<code>redis</code>，虽然<code>redis</code>最近也在存储大数据的性能上进行优化，但是比起<code>memcached</code>，还是稍有逊色</p></blockquote><ul><li>内存使用效率</li></ul><blockquote><p>使用简单的<code>key-value</code>存储的话，<code>memcached</code>的内存利用率更高，而如果<code>redis</code>采用<code>hash</code>结构来做<code>key-value</code>存储，由于其组合式的压缩，其内存利用率会高于<code>memcached</code>。另外，<code>memcached</code>使用预分配的内存池的方式，带来一定程度的空间浪费 并且在内存仍然有很大空间时，新的数据也可能会被剔除，而<code>redis</code>使用现场申请内存的方式来存储数据，不会剔除任何非临时数据 redis更适合作为存储而不是<code>cache</code>。</p></blockquote><ul><li><code>redis</code>支持服务器端的数据操作</li></ul><blockquote><p><code>redis</code>相比<code>memcached</code>来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在<code>memcached</code>里，你需要将数据拿到客户端来进行类似的修改再<code>set</code>回去。这大大增加了网络IO的次数和数据体积。在<code>redis</code>中，这些复杂的操作通常和一般的<code>GET/SET</code>一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么<code>redis</code>会是不错的选择</p></blockquote><hr><p>何时应该使用<code>memcache</code>:</p><blockquote><p>首先就是对小型静态数据进行缓存处理，最具代表性的例子就是HTML代码片段。这是因为<code>memcached</code>在处理元数据时所消耗的内存资源相对更少.</p><p>在以前，<code>redis3.0</code>版本之前，<code>memcached</code>在横向扩展方面也比<code>redis</code>更具优势。由于其在设计上的思路倾向以及相对更为简单的功能设置，<code>memcached</code>在实现扩展时的难度比redis低得多。</p></blockquote><p>何时应该使用<code>redis</code>：</p><blockquote><p>其他场景都可以用<code>redis</code>来替换。</p><p>相比于武断的<code>LRU</code>(即最低近期使用量)算法，<code>redis</code>允许用户更为精准地进行细化控制，利用六种不同回收策略确切提高缓存资源的实际利用率。<code>redis</code>还采用更为复杂的内存管理与回收对象备选方案。</p><p><code>memcached</code>将键名限制在250字节，值也被限制在不超过1MB，且只适用于普通字符串。<code>redis</code>则将键名与值的最大上限各自设定为512MB，且支持二进制格式。</p><p>它所保存的数据具备透明化特性，也就是说服务器能够直接对这些数据进行操作.</p><p><code>redis</code>还提供可选而且能够具体调整的数据持久性方案</p><p><code>redis</code>能够提供复制功能。复制功能旨在帮助缓存体系实现高可用性配置方案，从而在遭遇故障的情况下继续为应用程序提供不间断的缓存服务。</p></blockquote><p>使用<code>redis</code>的正确姿势：</p><blockquote><p>要进行<code>master-slave</code>配置，出现服务故障时可以支持切换。</p><p>在<code>master</code>侧禁用数据持久化，只需在<code>slave</code>上配置数据持久化。</p><p>物理内存+虚拟内存不足，这个时候<code>dump</code>一直死着，时间久了机器挂掉。这个情况就是灾难。</p><p>当<code>redis</code>物理内存使用超过内存总容量的3/5时就会开始比较危险了，就开始做<code>swap</code>,内存碎片大。</p><p>当达到最大内存时，会清空带有过期时间的<code>key</code>，即使<code>key</code>未到过期时间。</p><p><code>redis</code>与<code>DB</code>同步写的问题，先写<code>DB</code>，后写<code>redis</code>，因为写内存基本上没有问题。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis事务</title>
      <link href="/2019/02/02/redis/Redis%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/02/02/redis/Redis%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第十一篇文章。详细探讨redis事务的用法和原理。</p><a id="more"></a><p>redis 事务是一组命令的集合，至少是两个或两个以上的命令，redis 事务保证这些命令被执行时中间不会被任何其他操作打断。</p><h3>事务基本认识</h3><p>当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行。</p><p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队。</p><p><img src="http://xiaozhao.oursnail.cn/redis%E4%BA%8B%E5%8A%A1.svg" alt="image"></p><h3>事务执行</h3><p>前面说到， 当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。</p><p>但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 <code>EXEC</code> 、 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code> 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：</p><p><img src="http://xiaozhao.oursnail.cn/redis%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1.svg" alt="image"></p><p>如果客户端正处于事务状态， 那么当 <code>EXEC</code> 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（<code>FIFO</code>）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p><h3>事务基本命令介绍</h3><p>除了 <code>EXEC</code> 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code> 。</p><p><code>DISCARD</code> 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。</p><p><code>Redis</code> 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 <code>MULTI</code> 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 <code>MULTI</code> 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p><p><code>WATCH</code> 只能在客户端进入事务状态之前执行， 在事务状态下发送 <code>WATCH</code> 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 <code>MULTI</code> 的情况一样）。</p><h3>正常情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//命令入队</span><br><span class="line">exec//提交事务（执行命令）</span><br></pre></td></tr></table></figure><h3>异常情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">set key//错误命令，直接报错</span><br><span class="line">exec//事务被丢弃，提交失败</span><br></pre></td></tr></table></figure><h3>例外情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">incr key//虽然字符串不能增一，但是不报错，入队</span><br><span class="line">exec//自增会失败，但是key被设置成功了，整个事务没有回滚</span><br></pre></td></tr></table></figure><h3>放弃事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">discard</span><br></pre></td></tr></table></figure><h3>乐观锁</h3><p>乐观锁：每次拿数据的时候都认为别人不会修改该数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这条数据，一般使用版本号进行判断，乐观锁使用于读多写少的应用类型，这样可以提高吞吐量。</p><p>乐观锁大多情况是根据数据版本号(<code>version</code>)的机制实现的，何为数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库添加一个<code>version</code>字段来实现读取出数据时，将此版本号一起读出，之后更新时，对此版本号加1，此时将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库表的当前版本，则予以更新，否则认为是过期数据，不予更新。</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>读出版本号为1，操作</td><td>A操作时，读出版本号也为1，进行某个操作(修改)</td></tr><tr><td>执行修改，version+1=2，因为2&gt;1，所以更新</td><td>…</td></tr><tr><td>…</td><td>执行修改，version+1=2，发现数据库记录的版本也为2，2=2,更新失败</td></tr></tbody></table><h3>watch机制</h3><p><code>WATCH</code> 命令用于在事务开始之前监视任意数量的键： 当调用 <code>EXEC</code> 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set k1 1     //设置k1值为1</span><br><span class="line">watch k1     //监视k1(其他客户端不能修改k1值)</span><br><span class="line">set k1 2     //设置k1值为2</span><br><span class="line">multi        //开始事务</span><br><span class="line">set k1 3     //修改k1值为3</span><br><span class="line">exex         //提交事务，k1值仍为2，因为事务开始之前k1值被修改了</span><br></pre></td></tr></table></figure><h3>watch机制举例</h3><p>大家可能知道<code>redis</code>提供了基于<code>incr</code>命令来操作一个整数型数值的原子递增，那么我们假设如果<code>redis</code>没有这个<code>incr</code>命令，我们该怎么实现这个<code>incr</code>的操作呢？</p><p>正常情况下我们想要对一个整形数值做修改是这么做的(伪代码实现)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure><p>但是上述的代码会出现一个问题,因为上面吧正常的一个<code>incr</code>(原子递增操作)分为了两部分,那么在多线程(分布式)环境中，这个操作就有可能不再具有原子性了。</p><p>研究过<code>java</code>的<code>juc</code>包的人应该都知道<code>cas</code>，那么<code>redis</code>也提供了这样的一个机制，就是利用<code>watch</code>命令来实现的。</p><p>具体做法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>和此前代码不同的是，新代码在获取<code>mykey</code>的值之前先通过<code>WATCH</code>命令监控了该键，此后又将<code>set</code>命令包围在事务中，这样就可以有效的保证每个连接在执行<code>EXEC</code>之前，如果当前连接获取的<code>mykey</code>的值被其它连接的客户端修改，那么当前连接的<code>EXEC</code>命令将执行失败。这样调用者在判断返回值后就可以获悉<code>val</code>是否被重新设置成功。</p><p>由于<code>WATCH</code>命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以在一般的情况下我们需要在<code>EXEC</code>执行失败后重新执行整个函数。</p><p>执行<code>EXEC</code>命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用<code>UNWATCH</code>命令来取消监控。</p><h3>watch机制原理</h3><h4>WATCH 命令的实现</h4><p>在每个代表数据库的 <code>redis.h/redisDb</code> 结构类型中， 都保存了一个 <code>watched_keys</code> 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。</p><p>比如说，以下字典就展示了一个 <code>watched_keys</code> 字典的例子：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%861.svg" alt="image"></p><p>其中， 键 <code>key1</code> 正在被 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p><p><code>WATCH</code> 命令的作用， 就是将当前客户端和要监视的键在 <code>watched_keys</code> 中进行关联。</p><p>举个例子， 如果当前客户端为 <code>client10086</code> ， 那么当客户端执行 <code>WATCH key1 key2</code> 时， 前面展示的 <code>watched_keys</code> 将被修改成这个样子：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%862.svg" alt="image"></p><p>通过 <code>watched_keys</code> 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p><h4>WATCH 的触发</h4><p>在任何对数据库键空间（<code>key space</code>）进行修改的命令成功执行之后 （比如 <code>FLUSHDB</code> 、 <code>SET</code> 、 <code>DEL</code> 、 <code>LPUSH</code> 、 <code>SADD</code> 、 <code>ZREM</code> ，诸如此类）， <code>multi.c/touchWatchedKey</code> 函数都会被调用 —— 它检查数据库的 <code>watched_keys</code> 字典， 看是否有客户端在监视已经被命令修改的键， 如果有的话， 程序将所有监视这个/这些被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%863.svg" alt="image"></p><p>当客户端发送 <code>EXEC</code> 命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p><ul><li>如果客户端的 <code>REDIS_DIRTY_CAS</code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li><li>如果 <code>REDIS_DIRTY_CAS</code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li></ul><p>举个例子，假设数据库的 <code>watched_keys</code> 字典如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%864.svg" alt="image"></p><p>如果某个客户端对 <code>key1</code> 进行了修改（比如执行 <code>DEL key1</code> ）， 那么所有监视 <code>key1</code> 的客户端， 包括 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 的 <code>REDIS_DIRTY_CAS</code> 选项都会被打开， 当客户端 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 执行 <code>EXEC</code> 的时候， 它们的事务都会以失败告终。</p><p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code>watched_keys</code> 字典中和这个客户端相关的资料都会被清除。</p><h3>事务的 ACID 性质</h3><p><code>Redis</code> 事务保证了其中的一致性（偶尔也有可能不一致）和隔离性，但并不保证原子性和持久性。</p><h4>原子性（Atomicity）</h4><p>单个 <code>Redis</code> 命令的执行是原子性的，但 <code>Redis</code> 没有在事务上增加任何维持原子性的机制，所以 <code>Redis</code> 事务的执行并不是原子性的。</p><p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p><p>另一方面，如果 <code>Redis</code> 服务器进程在执行事务的过程中被停止 —— 比如接到 <code>KILL</code> 信号、宿主机器停机，等等，那么事务执行失败。</p><p>当事务失败时，<code>Redis</code> 也不会进行任何的重试或者回滚动作。</p><h4>一致性（Consistency）</h4><p><code>Redis</code> 的一致性问题可以分为三部分来讨论：入队错误、执行错误、<code>Redis</code> 进程被终结。</p><p>前面两者上面已经讨论过了，这里再重复一下.</p><ul><li>入队错误</li></ul><p>入队错误一般是错误的命令(不考虑能不能执行，命令本身就是错误的)，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性；</p><ul><li>执行错误</li></ul><p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 <code>key</code> 执行了错误的操作， 那么 <code>Redis</code> 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。</p><ul><li><code>Redis</code> 进程被终结</li></ul><p>如果 <code>Redis</code> 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 <code>Redis</code> 所使用的持久化模式，可能有以下情况出现：</p><blockquote><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p></blockquote><blockquote><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。所以显然会造成不一致</p></blockquote><blockquote><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行,如果事务语句未写入到 AOF 文件，那么显然是一致的，因为事务里的操作全部失败；如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p></blockquote><h4>隔离性（Isolation）</h4><p><code>Redis</code> 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<code>Redis</code> 的事务是总是带有隔离性的。</p><h4>持久性（Durability）</h4><ul><li>在单纯的内存模式下，事务肯定是不持久的。</li><li>在 <code>RDB</code> 模式下，服务器可能在事务执行之后、<code>RDB</code> 文件更新之前的这段时间宕机，所以 <code>RDB</code> 模式下的 <code>Redis</code> 事务也是不持久的。</li><li>在 <code>AOF</code> 的“总是 <code>SYNC</code> ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code>fsync</code> 或 <code>fdatasync</code> 将事务数据写入到 <code>AOF</code> 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，服务器也有可能出现问题，所以这种模式下的事务也是不持久的。</li><li>都是不持久的。</li></ul><h3>总结</h3><ul><li><code>MULTI</code> 命令的执行标记着事务的开始</li><li>当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队</li><li><code>Redis</code> 的事务保证了 <code>ACID</code> 中的一致性（C）（偶尔也有可能不一致）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li><li>不加入到事务队列而直接执行的四个命令为：<code>EXEC</code> 、 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code></li><li><code>DISCARD</code> 命令用于取消一个事务</li><li><code>Redis</code> 的事务是不可嵌套的</li><li><code>WATCH</code> 只能在客户端进入事务状态之前执行</li><li><code>WATCH</code>机制的原理</li></ul><p>参考：</p><ul><li><a href="http://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">事务</a></li><li><a href="https://www.jianshu.com/p/361cb9cd13d5" target="_blank" rel="noopener">redis的事务和watch</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis缓存更新</title>
      <link href="/2019/02/02/redis/Redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2019/02/02/redis/Redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第十篇文章。redis缓存更新策略学习。</p><a id="more"></a><p>更新缓存的的<code>Design Pattern</code>有四种：<code>Cache aside</code>, <code>Read through</code>, <code>Write through</code>, <code>Write behind caching</code>，我们下面一一来看一下这四种<code>Pattern</code>。这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，<strong>我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）</strong>。</p><p>先来看看缓存可能存在的一些问题，目的是突出缓存使用策略选择的重要性。</p><h2>1.缓存穿透</h2><p>缓存穿透是说访问一个缓存中没有的数据，但是这个数据数据库中也不存在。</p><p>解决方案是：</p><ul><li>缓存空对象。如果缓存未命中，而数据库中也没有这个对象，则可以缓存一个空对象到缓存。如果使用<code>Redis</code>，这种<code>key</code>需设置一个较短的时间，以防内存浪费。</li><li>缓存预测。预测<code>key</code>是否存在。如果缓存的量不大可以使用<code>hash</code>来判断，如果量大可以使用布隆过滤器来做判断。采用布隆，将所有可能存在的数据哈希到一个足够大的<code>BitSet</code>中，不存在的数据将会被拦截掉，从而避免了对存储系统的查询压力。</li></ul><h2>2.缓存并发</h2><p>多个客户端同时访问一个没有在<code>cache</code>中的数据，这时每个客户端都会执行从<code>DB</code>加载数据<code>set</code>到缓存，就会造成缓存并发。</p><ul><li>缓存预热。提前把所有预期的热数据加到缓存。定位热数据还是比较复杂的事情，需要根据自己的服务访问情况去评估。这个方案只能减轻缓存并发的发生次数不能全部抵制。</li><li>缓存加锁。 如果多个客户端访问不存在的缓存时，在执行加载数据并<code>set</code>缓存这个逻辑之前先加锁，只能让一个客户端执行这段逻辑。</li></ul><h2>3.缓存雪崩</h2><p>缓存雪崩是缓存服务暂时不能提供服务，导致所有的请求都直接访问DB。</p><p>解决方案：</p><ul><li>构建高可用的缓存系统。目前常用的缓存系统<code>Redis</code>和<code>Memcache</code>都支持高可用的部署方式，所以部署的时候不防先考虑是否要以高可用的集群方式部署。</li><li>限流。<code>Netflix</code>的<code>Hystrix</code>是非常不错的工具，在用缓存时不妨搭配它来使用。</li></ul><h2>4.Cache Aside Pattern</h2><p><strong>一种错误的做法是</strong>：先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，直到这个缓存失效为止。</p><p><code>Cache Aside Pattern</code>是最常用最常用的<code>pattern</code>了。其具体逻辑如下：</p><ul><li>失效：应用程序先从<code>cache</code>取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从<code>cache</code>中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p><strong>注意，我们的更新是先更新数据库，成功后，让缓存失效</strong>。那么，这种方式是否可以没有文章前面提到过的那个问题呢？</p><p>一个是查询操作，一个是更新操作的并发，首先，没有了删除<code>cache</code>数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。<strong>而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据</strong>。</p><p><strong>但还是存在问题的</strong>。比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。不过，实际上出现的概率可能非常低.</p><p>所以，这也就是<code>Quora</code>上的那个答案里说的，要么通过<code>2PC</code>或是<code>Paxos</code>协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而<code>Facebook</code>使用了这个降低概率的玩法，因为<code>2PC</code>太慢，而<code>Paxos</code>太复杂。当然，最好还是为缓存设置上过期时间。</p><h2>5.Read/Write Through Pattern</h2><ul><li><code>Read Through</code>：读取数据的时候如果当前缓存中没有数据，惯常的操作都是应用程序去<code>DB</code>加载数据，然后加入到缓存中。<code>Read Through</code>与之不同的是我们不需要在应用程序自己加载数据了，缓存层会帮忙做件事。</li><li><code>Write Through</code>：更新数据的时候，如果命中缓存，则先更新缓存然后缓存在负责把数据更新到数据库；如果没有命中缓存则直接更新数据库。</li></ul><p>这种方式缓存层直接屏蔽了DB，应用程序只需要更缓存打交道。优点是应用逻辑简单了，而且更高效了；缺点是缓存层的实现相对复杂一些。</p><h2>6.Write Back Pattern</h2><p><code>Write Back</code>套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的<code>I/O</code>操作飞快无比（因为直接操作内存嘛 ），因为异步，<code>write backg</code>还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p><p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道<code>Unix/Linux</code>非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。</p><p>另外，<code>Write Back</code>实现逻辑比较复杂，因为他需要<code>track</code>有哪数据是被更新了的，需要刷到持久层上。操作系统的<code>write back</code>会在仅当这个<code>cache</code>需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫<code>lazy write</code>。</p><h2>7.实际使用的一些策略</h2><h4>业务方（调用者）更新</h4><p>传统上，更新缓存都是由业务方来做，也就是由调用者负责更新DB和缓存。</p><h4>DB中间件监听DB变化，更新缓存</h4><p>现在有种新的办法就是利用<code>DB</code>中间件监听<code>DB</code>变化（比如阿里的<code>Canal</code>中间件，点评的<code>Puma</code>），从而对缓存进行更新。<br>这种办法的一个好处就是：把缓存的更新逻辑，和业务逻辑解藕。业务只更新DB，缓存的更新被放在另外一个专门的系统里面。</p><h2>8.总结</h2><p>一句话，无论谁先谁后，只要更新缓存和更新DB不是原子的，就可能导致不一致。</p><p>总之，只是从实际业务来讲，一般缓存也都是保持“最终一致性“，而不是和<code>DB</code>的强一致性。</p><p><strong>并且一般建议先更新DB，再更新缓存，优先保证DB数据正确。</strong></p><h2>9.一致性问题</h2><p>上面，我们没有考虑缓存（<code>Cache</code>）和持久层（<code>Repository</code>）的整体事务的问题。比如，更新<code>Cache</code>成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——<code>prepare</code>, <code>commit/rollback</code>.后续再探讨。</p><ul><li>参考1：<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a></li><li>参考2：<a href="https://www.jianshu.com/p/3c111e4719b8" target="_blank" rel="noopener">https://www.jianshu.com/p/3c111e4719b8</a></li><li>参考3：<a href="https://blog.csdn.net/chunlongyu/article/details/53384933" target="_blank" rel="noopener">缓存更新策略/缓存穿透/缓存雪崩</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis缓存设计与优化</title>
      <link href="/2019/02/01/redis/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2019/02/01/redis/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第九篇文章。介绍redis缓存中 一些重要的问题。</p><a id="more"></a><h2>1. 缓存收益和成本</h2><h4>1.1 收益</h4><ul><li>加速读写</li><li>降低后端负载(降低mysql负载)</li></ul><h4>1.2 成本</h4><ul><li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</li><li>代码维护成本：多了一层缓存逻辑</li><li>运维成本：例如<code>redis cluster</code></li></ul><h4>1.3 使用场景</h4><ul><li>降低后端负载：对于高消耗的SQL：join结果集、分组统计结果；对这些结果进行缓存。</li><li>加速请求响应</li><li>大量写合并为批量写：如计数器先redis累加再批量写入DB</li></ul><h2>2. 缓存的更新策略</h2><ul><li><code>LRU/LFU/FIFO</code>算法剔除：例如<code>maxmemory-policy</code></li></ul><blockquote><p><code>FIFO(first in first out)</code></p><p>先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。</p><p><code>LFU(less frequently used)</code></p><p>最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。</p><p><code>LRU(least recently used)</code></p><p>最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</p></blockquote><ul><li>超时剔除：例如<code>expire</code></li><li>主动更新：开发控制生命周期（最终一致性，时间间隔比较短）</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/51026002.jpg" alt="image"></p><ul><li>低一致性：最大内存和淘汰策略</li><li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底。</li></ul><h2>3. 缓存粒度控制</h2><p><img src="http://bloghello.oursnail.cn/18-5-12/56376367.jpg" alt="image"></p><h4>3.1 缓存粒度控制三个角度</h4><ul><li>通用性：全量属性更好(添加删除属性不需要改东西)</li><li>占用空间：部分属性更好</li><li>代码维护：表面上全量属性更好(添加删除属性不需要改东西)</li></ul><h2>4. 缓存穿透优化</h2><h4>4.1 定义</h4><p>大量请求不命中,缓存已经没有存在的意义了：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/69826621.jpg" alt="image"></p><h4>4.2 产生原因</h4><ul><li>业务代码自身问题</li><li>恶意攻击、爬虫等</li></ul><h4>4.3 如何发现</h4><ul><li>业务响应时间</li><li>业务本身问题</li><li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ul><h4>4.4 解决方案</h4><ul><li>方案一：缓存空对象</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/30770379.jpg" alt="image"></p><blockquote><p>存在的问题</p><p>需要更多的键:恶意攻击、爬虫会有很多乱七八糟的键，当量很大时，会有风险，所以会对这种空对象设置缓存时间控制风险</p><p>缓存层和存储层数据“短期”不一致：缓存了空对象，但是当业务恢复了，真实数据又存在于DB中了，那么在这个空对象过期时间内，取到的仍然是空对象，造成短期内数据不一致的问题。解决：可以订阅消息，当恢复正常后接受到消息，然后刷新缓存。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/91489515.jpg" alt="image"></p><ul><li>方案二：布隆过滤器拦截</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/74465100.jpg" alt="image"></p><p>什么是<code>Bloom Filter</code>？</p><blockquote><p>布隆过滤器（<code>Bloom Filter</code>）是1970年由布隆提出的, “<code>a space-efficient probabilistic data structure</code>”。它实际上是一个很长的二进制矢量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，<code>Hash table</code>）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为<code>O(n),O(log n),O(n/k)</code>。</p><p><strong>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1</strong>。</p><p>优点：相比于其它的数据结构，<ins>布隆过滤器在空间和时间方面都有巨大的优势</ins>。布隆过滤器存储空间和插入/查询时间都是常数（O（k））。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。布隆过滤器可以表示全集，其它任何数据结构都不能；k和m相同，使用同一组散列函数的两个布隆过滤器的交并差运算可以使用位操作进行。</p><p>缺点：但是布隆过滤器的缺点和优点一样明显。<ins>误算率是其中之一</ins>。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。另外，<ins>一般情况下不能从布隆过滤器中删除元素</ins>。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1,这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/60082067.jpg" alt="image"></p><p>检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：<ins>如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在</ins>。这就是布隆过滤器的基本思想。</p><p><code>Bloom Filter</code>应用场景？</p><p><img src="http://bloghello.oursnail.cn/18-5-12/1394689.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-5-12/76148797.jpg" alt="image"></p><p>用<code>Redis</code>的<code>Bitmap</code>作为位数组构建起来的可扩展的布隆过滤器。</p><p><a href="https://blog.csdn.net/NEWCIH/article/details/78934420" target="_blank" rel="noopener">Redis实现的布隆过滤器如何快速有效删除数据？</a>：EXPIRE “bitmap的key值” 0</p><h4>4.5 解决方案对比</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/38205091.jpg" alt="image"></p><h2>5. 无底洞问题优化</h2><h4>5.1 问题描述</h4><ul><li>2010年，facebook有了3000个<code>Memcache</code>节点</li><li>发现问题：&quot;加&quot;机器性能没能提升，反而下降</li></ul><h4>5.2 问题原因</h4><p>当存在的节点异常多的时候，IO的代价已经超过数据传输，上文提到的facebook的节点已经超过3000个，在这种情况下再增加节点已经没法再提高效率了。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/45516608.jpg" alt="image"></p><h4>5.3 问题解决—优化IO</h4><ul><li>命令本身的效率：例如sql优化，命令优化</li><li>网络次数：减少通信次数</li><li>降低接入成本:长连/连接池,NIO等。</li><li>IO访问合并:O(n)到O(1)过程:批量接口(mget)，就是上一篇文章中介绍的对于mget的四个方案。</li></ul><h2>6. 缓存雪崩优化</h2><h4>6.1 什么是缓存雪崩？</h4><p>从下图可以很清晰出什么是缓存雪崩：由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 缓存雪崩的英文原意是 stampeding herd（奔逃的野牛），指的是缓存层宕掉后，流量会像奔逃的野牛一样，打向后端存储。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/92547625.jpg" alt="image"></p><h4>6.2 如何防止缓存雪崩？</h4><ul><li>保证缓存层服务高可用性。</li></ul><p>和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 <code>Redis Sentinel</code> 和 <code>Redis Cluster</code> 都实现了高可用。</p><ul><li>依赖隔离组件为后端限流并降级</li></ul><p>无论是缓存层还是存储层都会有出错的概率，可以将它们视同为资源。作为并发量较大的系统，假如有一个资源不可用，可能会造成线程全部 hang 在这个资源上，造成整个系统不可用。降级在高并发系统中是非常正常的：比如推荐服务中，如果个性化推荐服务不可用，可以降级补充热点数据，不至于造成前端页面是开天窗。</p><p><strong>在实际项目中，我们需要对重要的资源 ( 例如 <code>Redis</code>、 <code>MySQL</code>、 <code>Hbase</code>、外部接口 ) 都进行隔离</strong>，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响。但是线程池如何管理，比如如何关闭资源池，开启资源池，资源池阀值管理，这些做起来还是相当复杂的，这里推荐一个 Java 依赖隔离工具 <code>Hystrix</code>。超出范围了。不再赘述。</p><h2>7. 热点key重建优化</h2><h4>7.1 问题</h4><p>热点<code>key</code>( 例如一个热门的娱乐新闻）+较长的重建时间（可能是一个复杂计算，例如复杂的 SQL、多次 IO、多个依赖等）</p><p>就是说在高并发的情况下，某个key在缓存中重建时间太长，以至于高并发下缓存查不到，都去DB进行查询。对于DB压力很大，并且响应时间长。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/85568274.jpg" alt="image"></p><p>三个目标：<strong>要减少缓存重建次数、数据尽可能一致、减少潜在危险</strong>。</p><p>两个解决：互斥锁、永远不过期</p><h4>7.2 互斥锁—setex,setnx</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/40535698.jpg" alt="image"></p><p>存在问题：有等待时间。</p><p>伪代码：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/13945208.jpg" alt="image"></p><blockquote><p>(1) 从 <code>Redis</code> 获取数据，如果值不为空，则直接返回值，否则执行 (2.1) 和 (2.2)。</p><p>(2) 如果 <code>set(nx 和 ex)</code> 结果为 true，说明此时没有其他线程重建缓存，那么当前线程执行缓存构建逻辑。</p><p>(2.2) 如果 <code>setnx(nx 和 ex)</code> 结果为 false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程将休息指定时间 ( 例如这里是 50 毫秒，取决于构建缓存的速度 ) 后，重新执行函数，直到获取到数据。</p></blockquote><h4>7.3 永远不过期</h4><blockquote><p>这里我想了很久到底是什么意思，，，我感觉这是一个场景：保证数据的定期更新。对于热点<code>key</code>,无非是并发特别大并且重建缓存时间比较长，如果直接设置过期时间，那么时间到的时候，巨大的访问量会压迫到数据库上，所以我们实际上，是不给他设置过期时间，但是不设置过期时间，怎么做到定时更新呢？这里的方案是给热点key的val增加一个逻辑过期时间字段，并发访问的时候，判断这个逻辑字段的时间值是否大于当前时间，大于了说明要对缓存进行更新了，那么这个时候，依然让所有线程访问老的缓存，因为缓存并没有设置过期，但是另开一个线程对缓存进行重构。等重构成功，即执行了<code>redis set</code>操作之后，所有的线程就可以访问到重构后的缓存中的新的内容了。不知道我的理解是不是正确。</p></blockquote><p>“永远不过期”包含两层意思：</p><blockquote><p>从缓存层面来看，确实没有设置过期时间，所以不会出现热点 <code>key</code> 过期后产生的问题，也就是“物理”不过期。</p><p>从功能层面来看，为每个 <code>value</code> 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</p></blockquote><p>2018/6/19 号补充：物理上缓存确实是不过期的，保证所有线程都能访问到，但是有可能是老的数据；逻辑上给 value 增加过期时间，如果当过期时间超过当前时间(每一个线程拿缓存数据的时候都会判断一下，<strong>也就是说这里仍然使用互斥锁</strong>，其中一个线程发现过期时间超过当前时间了，那么锁住，另开一个线程去完成数据重建)，新开一个线程去构建缓存，构建成功之后，设置新内容到缓存中并且删除老缓存，就完成了热点 key 的重建。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/84104163.jpg" alt="image"></p><p>伪代码实现：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/97521024.jpg" alt="image"></p><h4>两种方案对比</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/92977181.jpg" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis-Cluster理论详解</title>
      <link href="/2019/02/01/redis/Redis-Cluster%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/01/redis/Redis-Cluster%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第八篇文章。<a href="http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" target="_blank" rel="noopener">上一篇</a>我们学习了redis sentinel，知道了它是redis高可用的一种实现方案。但是面对要求很高的场景，一台master是一定不能解决问题的，redis 3.0给我们带来了服务端集群方案，解决了这个问题。</p><a id="more"></a><h2>1. 数据分区</h2><p>集群，那么就会涉及到数据是如何分片的。有两种方式：顺序分区和哈希分区</p><p><img src="http://bloghello.oursnail.cn/18-5-11/75952046.jpg" alt="image"></p><p>两者对比：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/86878706.jpg" alt="image"></p><p>直接<code>hash</code>取模进行数据分片时，当节点增加，会有很多数据命中不了，需要重新映射。如果大多数数据在增加或者减少节点之后进行迁移的话，对于性能影响是很大的，因为数据迁移，那么缓存中现在是无法命中的，必须去数据库取，是灾难性的行为。</p><p>早期的做法就是这样，在客户端<code>hash</code>取余节点个数来进行数据分片。如果非要这样，采取翻倍扩容会稍微好一点，迁移数据量会小一点。不过无论如何，这种方式在大数据量情况下是不可行的。</p><h2>2. 一致性hash算法</h2><p>对于上面提到的直接hash取余的方式，会导致大量数据的迁移。那么有没有一种方式，在增加或减少节点时，只有少部分数据迁移呢？</p><p>针对一致性<code>hash</code>算法，已经在<a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">简明理解一致性hash算法</a>中详细说明了，不再赘述。</p><p>对于redis 3.0之前，客户端可以用这种方式来实现数据分片。在redis 3.0之后，就不需要客户端来实现分片算法了，而是直接给我们提供了服务端集群方案<code>redis cluster</code>.</p><h2>3. 虚拟槽</h2><p><code>redis cluster</code>引入槽的概念，一定要与一致性<code>hash</code>的槽区分！这里每一个槽映射一个数据集。</p><blockquote><p>CRC16(key) &amp; 16383</p></blockquote><p>这里计算结果发送给<code>redis cluster</code>任意一个<code>redis</code>节点，这个<code>redis</code>节点发现他是属于自己管辖范围的，那就将它放进去；不属于他的槽范围的话，由于<code>redis</code>之间是相互通信的，这个节点是知道其他<code>redis</code>节点的槽的信息，那么会告诉他去那个<code>redis</code>节点去看看。</p><p>那么就实现了服务端对于槽、节点、数据的管理。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/92222837.jpg" alt="image"></p><p>当<code>master</code>节点增加时，即扩容时，对于以上两种方案，都会出现数据迁移，那么只能作为缓存场景使用。但是<code>redis cluster</code>，由于每个节点维护的槽的范围是固定的，当有新加入的节点时，是不会干扰到其他节点的槽的，必须是以前的节点将使用槽的权利分配给你，并且将数据分配给你，这样，新的节点才会真正拥有这些槽和数据。这种实现还处于半自动状态，需要人工介入。-----主要的思想是：槽到集群节点的映射关系要改变，不变的是键到槽的映射关系.</p><p><code>Redis</code>集群，要保证16384个槽对应的<code>node</code>都正常工作，<strong>如果某个<code>node</code>发生故障，那它负责的<code>slots</code>也就失效，整个集群将不能工作</strong>。为了增加集群的可访问性，官方推荐的方案是将<code>node</code>配置成主从结构，即一个<code>master</code>主节点，挂n个<code>slave</code>从节点。这时，如果主节点失效，<code>Redis Cluster</code>会根据选举算法从<code>slave</code>节点中选择一个上升为主节点，整个集群继续对外提供服务。</p><h2>4. 某个Master又怎么知道某个槽自己是不是拥有呢？</h2><p><code>Master</code>节点维护着一个16384/8字节的位序列，<code>Master</code>节点用bit来标识对于某个槽自己是否拥有。比如对于编号为1的槽，<code>Master</code>只要判断序列的第二位（索引从0开始）是不是为1即可。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/45417990.jpg" alt="image"></p><p>如上面的序列，表示当前<code>Master</code>拥有编号为1，134的槽。集群同时还维护着槽到集群节点的映射，是由长度为16384类型为节点的数组实现的，槽编号为数组的下标，数组内容为集群节点，这样就可以很快地通过槽编号找到负责这个槽的节点。位序列这个结构很精巧，即不浪费存储空间，操作起来又很便捷。</p><p>具体参照：<a href="http://blog.jobbole.com/103258/" target="_blank" rel="noopener">http://blog.jobbole.com/103258/</a> ,还提到了<code>slot</code>迁移的一些细节。</p><h2>5. redis节点之间如何通信的？</h2><p><img src="http://bloghello.oursnail.cn/18-5-11/14610782.jpg" alt="image"></p><ul><li><code>gossip</code>协议：节点之间彼此不断通信交换信息，一段时间后所有节点都会知道集群完整的信息。</li><li>节点与节点之间通过<strong>二进制协议</strong>进行通信。</li><li>客户端和集群节点之间通信和通常一样，通过文本协议进行。</li><li>集群节点不会代理查询。</li></ul><h2>6. 集群伸缩</h2><p>这里6385为新加入的节点，一开始是没有槽的，所以进行<code>slot</code>的迁移。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/10996863.jpg" alt="image"></p><p>集群伸缩：槽和数据在节点之间的移动。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/8930549.jpg" alt="image"></p><p>迁移数据的流程图：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/7140273.jpg" alt="image"></p><p><strong>迁移key可以用<code>pipeline</code>进行批量的迁移。</strong></p><p>对于扩容，原理已经很清晰了，至于具体操作，网上很多。至于缩容，也是先手动完成数据迁移，再关闭<code>redis</code>。</p><h2>7. 客户端路由</h2><h4>7.1 moved重定向</h4><p><img src="http://bloghello.oursnail.cn/18-5-11/69037262.jpg" alt="image"></p><p>其中，槽直接命中的话，就直接返回槽编号：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/48809003.jpg" alt="image"></p><p>槽不命中，返回带提示信息的异常，客户端需要重新发送一条命令：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/38968206.jpg" alt="image"></p><p>对于命令行的实验，用<code>redis-cli</code>去连接集群：</p><p><code>redis -c -p 7000</code>:加上<code>-c</code>，表示使用集群模式，帮助我们在第一次不命中的情况下自动跳转到对应的节点上：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/53223278.jpg" alt="image"></p><p>如果不加-c的话，会返回moved异常，不会自动跳转：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/7791978.jpg" alt="image"></p><h4>7.2 ask重定向</h4><p>在扩容缩容的时候，由于需要遍历这个节点上的所有的<code>key</code>然后进行迁移，是比较慢的，对客户端是一个挑战。因为假设一个场景，客户端访问某个key，节点告诉客户端这个<code>key</code>在源节点，当我们再去源节点访问的时候，却发现<code>key</code>已经迁移到目标节点。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/35563321.jpg" alt="image"></p><h4>7.3 moved重定向和ask重定向对比</h4><ul><li>两者都是客户端的重定向</li><li>moved：槽已经确定转移</li><li>ask:槽还在迁移中</li></ul><p>问题：如果节点众多，那么让客户端随机访问节点，那么直接命中的概率只有百分之一，还有就是发生<code>ask</code>异常时（即节点正在迁移时）客户端如何还能高效运转？</p><p>总结一句话就是<code>redis cluster</code>的客户端的实现会更复杂。</p><h2>8. smart客户端</h2><h4>8.1 追求目标</h4><p>追求性能，不会使用代理模式，而是直连对应节点。需要对<code>moved</code>异常和<code>ask</code>异常做兼容。也就是说，需要有一个这个语言对应的客户端来高效实现查找等操作。</p><h4>8.2 smart原理</h4><ul><li>从集群中选一个可运行节点，使用<code>cluster slots</code>初始化槽和节点映射</li><li>将<code>slot</code>与<code>node</code>节点的结果映射到本地，为每个节点创建<code>JedisPool</code></li><li>准备执行命令</li></ul><p>第一步中将<code>slot</code>与<code>node</code>节点的对应关系放在了<code>map</code>中，形成一个映射关系；<code>key</code>是通过<code>CRC16</code>算法再取余得到<code>slot</code>，所以<code>key</code>与<code>slot</code>的映射关系也是确定的。我们就可以直接发送命令。只要后面集群没有发生数据迁移，那么就会连接成功。但是如果在连接的时候出现了连接出错，说明这个<code>key</code>已经迁移到其他的<code>node</code>上了。如果发现<code>key</code>不停地迁移，超过5次就报错。</p><p>在发生<code>moved</code>异常的时候，则需要刷新缓存，即一开始维护的<code>map</code>。<br><img src="http://bloghello.oursnail.cn/18-5-12/49065180.jpg" alt="image"></p><p>有一个情况比较全的图：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/16371398.jpg" alt="image"></p><p><code>java redis cluster</code>客户端：<code>jedisCluster</code>基本使用–伪代码</p><p><img src="http://bloghello.oursnail.cn/18-5-12/31666045.jpg" alt="image"></p><p><code>jedisCluster</code>内部已经封装好池的借还操作等。</p><p>先写一个<code>JedisClusterFactory</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hostPortList;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里可以设置相关参数</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从配置文件中读取ip:port的参数放进Set中</span></span><br><span class="line">        Set&lt;HostAndPort&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String hostPort : hostPortList)&#123;</span><br><span class="line">            String[] arr = hostPort.split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr.length != <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(<span class="keyword">new</span> HostAndPort(arr[<span class="number">0</span>],Integer.parseInt(arr[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedisCluster = <span class="keyword">new</span> JedisCluster(nodeSet,timeout,jedisPoolConfig);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedisCluster != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jedisCluster.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisCluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring注入hostPortList和timeout</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHostPortList</span><span class="params">(List&lt;String&gt; hostPortList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hostPortList = hostPortList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hostPortList</code> 放入<code>spring bean</code>中，<code>spring</code>自动完成注入。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/83900230.jpg" alt="image"></p><h4>8.3 多节点命令实现</h4><p>有的时候我们想操作所有节点的数据。如何实现呢？</p><p><img src="http://bloghello.oursnail.cn/18-5-12/68192871.jpg" alt="image"></p><h4>8.4 批量操作</h4><p><strong><code>mget</code>,<code>mset</code>必须在一个槽</strong>。这个条件比较苛刻，一般是不能保证的，那么如何实现批量的操作呢？</p><blockquote><p><code>Redis Cluster</code>的行为和<code>Redis</code> 的单节点不同，甚至和一个<code>Sentinel</code> 监控的主从模式也不一样。主要原因是集群自动分片，将一个<code>key</code> 映射到16384个槽中的一个，这些槽分布在多个节点上。因此操作多个<code>key</code> 的命令必须保证所有的<code>key</code> 都映射到同一个槽上，避免跨槽执行错误。更进一步说，今后一个单独的集群节点，只服务于一组专用的<code>keys</code>，请求一个命令到一个<code>Server</code>，只能得到该<code>Server</code> 上拥有<code>keys</code> 的对应结果。一个非常简单的例子是执行<code>KEYS</code>命令，当发布该命令到集群环境中的某个节时，只能得到该节点上拥有的<code>keys</code>，而不是集群中所有的<code>keys</code>。所以要得到集群中所有的<code>keys</code>，必须从集群的所有主节点上获取所有的<code>keys</code>。</p></blockquote><p>对于分散在<code>redis</code>集群中不同节点的数据，我们如何比较高效地批量获取数据呢？？？？</p><ol><li>串行mget–原始方案，整一个for循环</li></ol><p><img src="http://bloghello.oursnail.cn/18-5-12/58584180.jpg" alt="image"></p><ol start="2"><li>串行IO</li></ol><p>对key进行RCR16和取余操作得到<code>slot</code>，将<code>slots</code>按照节点进行分批传送：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/35132332.jpg" alt="image"></p><ol start="3"><li>并行IO</li></ol><p><img src="http://bloghello.oursnail.cn/18-5-12/42467098.jpg" alt="image"></p><ol start="4"><li>hash_tag</li></ol><p>不做任何改变的话，<code>hash</code>之后就比较均匀地散在每个节点上：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/67459261.jpg" alt="image"></p><p>那么我们能不能像使用单机<code>redis</code>一样，一次IO将所有的<code>key</code>取出来呢？<code>hash-tag</code>提供了这样的功能，如果将上述的<code>key</code>改为如下，<strong>也就是用大括号括起来相同的内容，那么这些key就会到指定的一个节点上</strong>。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/77254754.jpg" alt="image"></p><p>在<code>mget</code>的时候只需要在一台机器上去即可。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/77494164.jpg" alt="image"></p><ol start="5"><li>对比</li></ol><p>方案三比较复杂，一般不用；方案四可能会出现数据倾斜，也不用。方案一在key小的时候可以用；方案二相对来说有一点优势；</p><p><img src="http://bloghello.oursnail.cn/18-5-12/2180496.jpg" alt="image"></p><p>为什么说是一点优势呢？<code>pipeline</code>批量处理不应该比串行处理好很多吗？</p><ul><li><a href="http://xiezefan.me/2015/12/13/redis_cluster_research_2/" target="_blank" rel="noopener">http://xiezefan.me/2015/12/13/redis_cluster_research_2/</a></li><li><a href="http://trumandu.github.io/2016/05/09/RedisCluster%E6%9E%84%E5%BB%BA%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%8E%A2%E8%AE%A8/" target="_blank" rel="noopener">http://trumandu.github.io/2016/05/09/RedisCluster构建批量操作探讨/</a></li></ul><h2>9. 故障转移</h2><h4>9.1 故障发现</h4><ul><li>通过<code>ping/pong</code>消息实现故障发现：不需要<code>sentinel</code></li><li>分为主观下线和客观下线</li></ul><p>主观下线：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/34676048.jpg" alt="image"></p><p>客观下线：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/16678200.jpg" alt="image"></p><p>pfail消息就是主观下线的信息，维护在一个链表中，链表中包含了所有其他节点对其他节点所有的主观信息，是有时间周期的，为了防止很早以前的主观下线信息还残留在这里。对这个链表进行分析，符合条件就尝试客观下线。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/42802351.jpg" alt="image"></p><h4>9.2 故障恢复</h4><p>从节点接收到他的主节点客观下线的通知，则进行故障恢复的操作。</p><ul><li>资格检查</li></ul><p>选取出符合条件的从节点：当从节点和故障主节点的断线时间太长，会被取消资格。</p><ul><li>准备选举时间</li></ul><p>就是为了保证偏移量大的从节点优先被选举投票</p><p><img src="http://bloghello.oursnail.cn/18-5-12/46928842.jpg" alt="image"></p><ul><li>选举投票</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/64039470.jpg" alt="image"></p><ul><li>替换主节点</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/70736400.jpg" alt="image"></p><p>这些所有步骤加起来，差不多十几秒左右。最后如果故障节点又恢复功能了，就称为新的<code>Master</code>的<code>slave</code>节点。</p><h2>10. 常见问题</h2><h4>10.1 集群完整性</h4><p><code>cluster-require-full-coverage</code>默认为yes</p><pre><code>- 要求所有节点都在服务，集群中16384个槽全部可用：保证集群完整性- 节点故障或者正在故障转移：`(error)CLUSTERDOWN the cluster is down`</code></pre><p><strong>但是大多数业务都无法容忍。需要将<code>cluster-require-full-coverage</code>设置为<code>no</code></strong></p><h4>10.2 带宽消耗</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/18544066.jpg" alt="image"></p><ul><li>消息发送频率：节点发现与其他节点最后通信时间超过<code>cluster-node-timeout/2</code>时会直接发送<code>Ping</code>消息</li><li>消息数据量：<code>slots</code>槽数组(2k空间)和整个集群1、10的状态数据(10个节点状态数据约10k)</li><li>节点部署的机器规模：进去分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽越高。</li><li>优化：避免“大”集群，：避免多业务使用一个集群，大业务可用多集群；<code>cluster-node-timeout</code>时间设置要注意是带宽和故障转移速度的均衡；尽量均匀分配到多机器上：保证高可用和带宽。</li></ul><h4>10.3 PubSub广播</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/49491067.jpg" alt="image"></p><ul><li>问题：<code>publish</code>在集群中每个节点广播：加重带宽。</li><li>解决：单独“走”一套<code>redis sentinel</code>。就是针对目标的几个节点构建<code>redis sentinel</code>，在这个里面实现广播。</li></ul><h4>10.4 数据倾斜</h4><ul><li>节点和槽分配不均匀<ul><li><code>./redis-trib.rb info ip:port</code>查看节点、槽、键值分布</li><li>慎用<code>rebalance</code>命令</li></ul></li><li>不同槽位对应键数量差异较大<ul><li>CRC16正常情况下比较均匀</li><li>可能存在<code>hash_tag</code></li><li><code>cluster countKeysinslot {slot}</code>获取槽对应键值个数</li></ul></li><li>包含<code>bigkey</code><ul><li>例如大字符串、几百万的元素的<code>hash</code>、<code>set</code>等</li><li>在从节点上执行:<code>redis-cli --bigkeys</code>来查看<code>bigkey</code>情况</li><li>优化：优化数据结构</li></ul></li><li>内存相关配置不一致<ul><li>因为某种情况下，某个节点对<code>hash</code>或者<code>Set</code>这种数据结构进行了单独的优化，而其他节点都没有配置，会出现配置不一致的情况。</li></ul></li></ul><h4>10.5 请求倾斜</h4><ul><li>热点key：重要的<code>key</code>或者<code>bigkey</code></li><li>优化：避免<code>bigkey;</code>热键不使用<code>hash_tag</code>；当一致性不高时，可以用本地缓存+MQ</li></ul><h4>10.6 读写分离</h4><ul><li>只读连接：集群模式的从节点不接受任何读写请求</li></ul><blockquote><p>重定向到负责槽的主节点(对从节点进行读，都是重定向到主节点再返回信息)</p><p>readonly命令可以读：连接级别命令(每次重新连接都要写一次)</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/57749242.jpg" alt="image"></p><p>上图可以看出，<strong><code>redis cluster</code> 默认<code>slave</code> 也是不能读的，如果要读取，需要执行 <code>readonly</code></strong>，就可以了。</p><ul><li>读写分离：更加复杂（成本很高，尽量不要使用）</li></ul><blockquote><p>同样的问题：复制延迟、读取过期数据、从节点故障</p><p>修改客户端</p></blockquote><h4>10.7 数据迁移</h4><p>分为离线迁移和在线迁移(唯品会<code>redis-migrate-tool</code>和豌豆荚<code>redis-port</code>)。</p><p>官方的方式：只能从单机迁移到集群、不支持在线迁移、不支持断点续传、单线程迁移影响速度</p><blockquote><p><code>./redis-trib.rb import --from 源ip:port --copy 目标ip:port</code></p></blockquote><p>加入在迁移时再往源<code>redis</code>插入几条数据，这几条数据会丢失(丢失一部分)</p><h4>10.8 集群vs单机</h4><p>集群也有一定的限制：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/73133214.jpg" alt="image"></p><p>分布式<code>redis</code>不一定是好的：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/6295367.jpg" alt="image"></p><h2>11. 简单总结</h2><p><img src="http://bloghello.oursnail.cn/18-5-12/415428.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-5-12/24688449.jpg" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简明理解一致性hash算法</title>
      <link href="/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
      <url>/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的。</p><a id="more"></a><h2>环形Hash空间</h2><p>按照常用的hash算法来将对应的key哈希到一个具有2^32 次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图</p><p><img src="http://bloghello.oursnail.cn/zaji15-1.png" alt="image"></p><p>把数据通过一定的hash算法处理后映射到环上<br>现在我们将<code>object1</code>、<code>object2</code>、<code>object3</code>、<code>object4</code>四个对象通过特定的<code>Hash</code>函数计算出对应的<code>key</code>值，然后散列到<code>Hash</code>环上。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hash(object1) = key1；</span><br><span class="line">Hash(object2) = key2；</span><br><span class="line">Hash(object3) = key3；</span><br><span class="line">Hash(object4) = key4；</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/zaji15-2.png" alt="image"></p><p>将机器通过hash算法映射到环上<br>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有<code>NODE1</code>，<code>NODE2</code>，<code>NODE3</code>三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hash(NODE1) = KEY1;</span><br><span class="line">Hash(NODE2) = KEY2;</span><br><span class="line">Hash(NODE3) = KEY3;</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/zaji15-3.png" alt="image"></p><p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动<code>object1</code>存储到了<code>NODE1</code>中，<code>object3</code>存储到了<code>NODE2</code>中，<code>object2</code>、<code>object4</code>存储到了<code>NODE3</code>中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p><h2>机器的删除与添加</h2><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p><h3>节点（机器）的删除</h3><p>以上面的分布为例，如果<code>NODE2</code>出现故障被删除了，那么按照顺时针迁移的方法，<code>object3</code>将会被迁移到<code>NODE3</code>中，这样仅仅是<code>object3</code>的映射位置发生了变化，其它的对象没有任何的改动。如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-4.png" alt="image"></p><h3>节点（机器）的添加</h3><p>如果往集群中添加一个新的节点<code>NODE4</code>，通过对应的哈希算法得到<code>KEY4</code>，并映射到环中，如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-5.png" alt="image"></p><p>通过按顺时针迁移的规则，那么<code>object2</code>被迁移到了<code>NODE4</code>中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p><h2>平衡性</h2><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。</p><p>hash算法是不保证平衡的，如上面只部署了<code>NODE1</code>和<code>NODE3</code>的情况（<code>NODE2</code>被删除的图），<code>object1</code>存储到了<code>NODE1</code>中，而<code>object2</code>、<code>object3</code>、<code>object4</code>都存储到了<code>NODE3</code>中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。</p><blockquote><p>“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</p></blockquote><p>以上面只部署了<code>NODE1</code>和<code>NODE3</code>的情况（<code>NODE2</code>被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p><p><img src="http://bloghello.oursnail.cn/zaji15-6.png" alt="image"></p><p>根据上图可知对象的映射关系：<code>object1</code>-&gt;<code>NODE1-1</code>，<code>object2</code>-&gt;<code>NODE1-2</code>，<code>object3</code>-&gt;<code>NODE3-2</code>，<code>object4</code>-&gt;<code>NODE3-1</code>。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，真正的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-7.png" alt="image"></p><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设<code>NODE1</code>的IP地址为<code>192.168.1.100</code>。引入“虚拟节点”前，计算 <code>cache A</code> 的 <code>hash</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100”);</span><br></pre></td></tr></table></figure><p>引入“虚拟节点”后，计算“虚拟节”点<code>NODE1-1</code>和<code>NODE1-2</code>的<code>hash</code>值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100#1”); // NODE1-1</span><br><span class="line">Hash(“192.168.1.100#2”); // NODE1-2</span><br></pre></td></tr></table></figure><p>整理自：</p><ul><li><a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">五分钟理解一致性哈希算法</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis-Sentinel实现高可用读写分离</title>
      <link href="/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第七篇文章。Redis Sentinel 是一个分布式系统，你可以在一个架构中运行多个 Sentinel 进程，这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息，并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。</p><a id="more"></a><p>虽然 <code>Redis Sentinel</code> 是一个单独的可执行文件 <code>redis-sentinel</code> ，但实际上它只是一个运行在特殊模式下的 <code>Redis</code> 服务器，你可以在启动一个普通 <code>Redis</code> 服务器时通过给定 <code>–sentinel</code> 选项来启动 <code>Redis Sentinel</code> 。</p><ul><li>启动方式一：使用<code>sentinel</code>可执行文件 <code>redis-sentinel</code> 程序来启动 <code>Sentinel</code> 系统，命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure><ul><li><code>sentinel</code>只是运行在特殊模式下的<code>redis</code>服务器，你可以用启动<code>redis</code>服务的命令来启动一个运行在 <code>Sentinel</code> 模式下的 <code>Redis</code> 服务器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure><h2>1. redis sentinel</h2><p>首先来看看什么是 <code>redis sentinel</code>，中文翻译是redis哨兵。顾名思义，哨兵是站岗监督突发情况的，那么这里具体的功能上很类似：</p><ul><li>监控：<code>Sentinel</code> 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒：当被监控的某个 <code>Redis</code> 服务器出现问题时，<code>Sentinel</code> 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移：当一个主服务器不能正常工作时，<code>Sentinel</code> 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li></ul><p><img src="http://bloghello.oursnail.cn/redis_sentinel%E7%BB%93%E6%9E%84.png" alt="image"></p><p>其中总结一下故障转移的基本原理：</p><ul><li>多个<code>sentinel</code>发现并确认<code>master</code>有问题</li><li>选举出一个<code>sentinel</code>作为领导</li><li>选出一个可以成为新的<code>master</code>的<code>slave</code></li><li>通知其他的<code>slave</code>称为新的<code>master</code>的<code>slave</code></li><li>通知客户端主从变化</li><li>等待老的<code>master</code>复活称为新的<code>master</code>的<code>slave</code></li></ul><p>也支持多个<code>master-slave</code>结构：</p><p><img src="http://bloghello.oursnail.cn/%E5%A4%9A%E4%B8%AAmaster_slave.png" alt="image"></p><h2>2. 安装与配置</h2><ol><li>配置开启主从节点</li><li>配置开启<code>sentinel</code>监控主节点（<code>sentinel</code>是特殊的<code>redis</code>）</li><li>实际应该多台机器，但是演示方便，只用一台机器来搭建</li><li>详细配置节点</li></ol><p>本地安装的结构图：</p><p><img src="http://bloghello.oursnail.cn/%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="image"></p><p>对于<code>master:redis-7000.conf</code>配置：</p><p><img src="http://bloghello.oursnail.cn/redis-7000.conf.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /usr/local/redis/data/redis-7000.pid</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br></pre></td></tr></table></figure><p>对于<code>slave:redis-7001</code>和<code>redis-7002</code>配置：</p><p><img src="http://bloghello.oursnail.cn/redis-slave.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /usr/local/redis/data/redis-7001.pid</span><br><span class="line">logfile &quot;7001.log&quot;</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br><span class="line">slaveof 127.0.0.1 7000</span><br></pre></td></tr></table></figure><p>启动<code>redis</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server ../config/redis-7000.conf</span><br></pre></td></tr></table></figure><p>访问7000端口的<code>master redis</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 info replication</span><br></pre></td></tr></table></figure><p>显示他有两个从节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=7002,state=online,offset=99550,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=7001,state=online,offset=99816,lag=0</span><br><span class="line">master_repl_offset:99816</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:99815</span><br></pre></td></tr></table></figure><p>对于<code>sentinel</code>主要配置：</p><p><img src="http://bloghello.oursnail.cn/sentinel%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE.png" alt="image"></p><p><code>master sentinel config</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>启动<code>redis sentinel</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel ../config/redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure><p>访问26379 <code>redis sentinel master</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 info sentinel</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:7000,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看这六个进程是否都起来了：ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>注意，如果上面是配置在虚拟机的话，需要将127.0.0.1改为虚拟机的ip，要不然找不着。</p><h2>3. 故障转移演练</h2><h4>3.1 java客户端程序</h4><p><code>JedisSentinelPool</code>只是一个配置中心，不需要具体连接某个<code>redis</code>，注意它不是代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(AppTest.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//哨兵配置，我们访问redis，就通过sentinel来访问</span></span><br><span class="line">    String masername = <span class="string">"mymaster"</span>;</span><br><span class="line">    Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26379"</span>);</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26380"</span>);</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26381"</span>);</span><br><span class="line"></span><br><span class="line">    JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masername,sentinels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个while死循环，每隔一秒往master塞入一个值，并且日志打印</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = sentinelPool.getResource();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">100000</span>);</span><br><span class="line">            String key = <span class="string">"k-"</span> + index;</span><br><span class="line">            String value = <span class="string">"v-"</span> + index;</span><br><span class="line">            jedis.set(key,value);</span><br><span class="line">            logger.info(<span class="string">"&#123;&#125;  value is &#123;&#125;"</span>,key,jedis.get(key));</span><br><span class="line"></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(jedis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>maven</code>依赖是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--slf4j日志接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--logback日志实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动程序，发现是正常写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">16:16:01.424 [main] INFO  com.njupt.swg.AppTest - k-54795  value is v-54795</span><br><span class="line">16:16:02.426 [main] INFO  com.njupt.swg.AppTest - k-55630  value is v-55630</span><br><span class="line">16:16:03.429 [main] INFO  com.njupt.swg.AppTest - k-70642  value is v-70642</span><br><span class="line">16:16:04.430 [main] INFO  com.njupt.swg.AppTest - k-42978  value is v-42978</span><br><span class="line">16:16:05.431 [main] INFO  com.njupt.swg.AppTest - k-96297  value is v-96297</span><br><span class="line">16:16:06.433 [main] INFO  com.njupt.swg.AppTest - k-4220  value is v-4220</span><br><span class="line">16:16:07.435 [main] INFO  com.njupt.swg.AppTest - k-34103  value is v-34103</span><br><span class="line">16:16:08.436 [main] INFO  com.njupt.swg.AppTest - k-9177  value is v-9177</span><br><span class="line">16:16:09.437 [main] INFO  com.njupt.swg.AppTest - k-24389  value is v-24389</span><br><span class="line">16:16:10.439 [main] INFO  com.njupt.swg.AppTest - k-32325  value is v-32325</span><br><span class="line">16:16:11.440 [main] INFO  com.njupt.swg.AppTest - k-68538  value is v-68538</span><br><span class="line">16:16:12.441 [main] INFO  com.njupt.swg.AppTest - k-36233  value is v-36233</span><br><span class="line">16:16:13.443 [main] INFO  com.njupt.swg.AppTest - k-305  value is v-305</span><br><span class="line">16:16:14.444 [main] INFO  com.njupt.swg.AppTest - k-59279  value is v-59279</span><br></pre></td></tr></table></figure><p>我们将现在的端口为7000的<code>redis master</code> 给<code>kill</code>掉</p><blockquote><p>kill -9 master的pid</p></blockquote><p>我们会发现：客户端报异常，但是在大概十几秒之后，就继续正常塞值了。原因是服务端的哨兵机制的选举<code>matser</code>需要一定的时间。</p><h2>4. 三个定时任务</h2><h4>4.1 每10秒每个sentinel对master和slave执行Info</h4><ul><li>发现<code>slave</code>节点</li><li>确认主从关系</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h4>4.2 每2秒每个sentinel通过master节点的channel交换信息(pub/sub)</h4><ul><li>通过<code>__sentinel__</code>:hello进行频道交互</li><li>交互对节点的“看法”和自身信息</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h4>4.3 每1秒每个<code>sentinel</code>对其他<code>sentinel</code>和<code>redis</code>执行<code>ping</code></h4><ul><li>心跳监测，失败判定依据</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h2>5. 主观下线和客观下线</h2><p>对于之前的<code>Sentinel</code>配置文件中有两条配置：</p><p>监控<code>master redis</code>节点，这里是当超过两个<code>sentinel</code>认为<code>master</code>挂了，则认为<code>master</code>挂了。</p><blockquote><p><code>sentinel monitor &lt;masterName&gt; &lt;masterIp&gt; &lt;msterPort&gt; &lt;quorum&gt;</code></p><p><code>sentinel monitor mymaster 127.0.0.1 6379 2</code></p></blockquote><p>这里是每秒<code>sentinel</code>都会去<code>Ping</code>周围的<code>master redis</code>，超过30秒没有任何响应，说明其挂了。</p><blockquote><p><code>sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;</code></p><p><code>sentinel down-after-milliseconds mymaster 300000</code></p></blockquote><h4>5.1 主观下线</h4><p>主观下线：每个<code>sentinel</code>节点对<code>Redis</code>节点失败的“偏见”</p><p>这是一种主观下线。因为在复杂的网络环境下，这个<code>sentinel</code>与这个<code>master</code>不通，但是<code>master</code>与其他的<code>sentinel</code>都是通的呢？所以是一种“偏见”</p><p>这是依靠的第三种定时：每秒去ping一下周围的<code>sentinel</code>和<code>redis</code>。对于<code>slave redis</code>,可以使用这个主观下线，因为他不需要进行故障转移。</p><h4>5.2 客观下线</h4><p>客观下线：所有<code>sentinel</code>节点对<code>master Redis</code>节点失败“达成共识”（超过<code>quorum</code>个则统一）</p><p>这是依靠的第二种定时：每两秒，<code>sentinel</code>之间进行“商量”，传递的消息是:<code>sentinel is-master-down-by-addr</code></p><p>对于<code>master redis</code>的下线，必须要达成共识才可以，因为涉及故障转移，仅仅依靠一个<code>sentinel</code>判断是不够的。</p><h2>6. 领导者选举</h2><p>原因：只有一个<code>sentinel</code>节点完成故障转移</p><p>选举：通过<code>sentinel is-master-down-by-addr</code>命令都希望成为领导者</p><ul><li>每个做主观下线的<code>sentinel</code>节点向其他<code>sentinel</code>节点发送命令，要求将它设置为领导者</li><li>收到命令的<code>sentinel</code>节点如果还没有同意过其他<code>semtinel</code>节点发送的命令，那么将同意该请求，否则拒绝</li><li>如果该<code>sentinel</code>节点发现自己的票数已经超过<code>sentinel</code>集合半数并且超过<code>quorum</code>，那么它将成为领导者。</li><li>如果此过程中多个<code>sentinel</code>节点成为了领导者，那么将等待一段时间重新进行选举</li></ul><h2>7. 故障转移</h2><ul><li>从<code>slave</code>节点中选出一个“合适的”节点作为新的<code>master</code>节点</li><li>对上述的<code>slave</code>节点执行“<code>slaveof no one</code>”命令使其成为<code>master</code>节点</li><li>向剩余的<code>slave</code>节点发送命令，让它们成为新<code>master</code>节点的<code>slave</code>节点，复制规则和<code>parallel-syncs</code>参数一样</li><li>更新对原来的<code>master</code>节点配置为<code>slave</code>，并保持着对其“关注”，当恢复后命令他去复制新的<code>master</code>节点</li></ul><p>那么，如何选择“合适”的<code>slave</code>节点呢？</p><ul><li>选择<code>slave-priority</code>(<code>slave</code>节点优先级)最高的<code>slave</code>节点，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的<code>slave</code>节点(复制得最完整)，如果存在则返回，不存在则继续</li><li>选择<code>run_id</code>最小的<code>slave</code>节点(最早的节点)</li></ul><h2>8. 节点下线</h2><p>主节点下线：<code>sentinel failover &lt;masterName&gt;</code></p><p>从节点下线要注意读写分离问题。</p><h2>9. 总结与思考</h2><blockquote><p><code>redis sentinel</code>是<code>redis</code>高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。</p></blockquote><blockquote><p><code>redis sentinel</code>从<code>redis2.8</code>版本才正式生产可用，之前版本不可生产用。</p></blockquote><blockquote><p>尽可能在不同物理机上部署<code>redis sentinel</code>所有节点。</p></blockquote><blockquote><p><code>redis sentinel</code>中的<code>sentinel</code>节点个数应该大于等于3且最好是奇数。</p></blockquote><blockquote><p><code>redis sentinel</code>中的数据节点和普通数据节点没有区别。每个<code>sentinel</code>节点在本质上还是一个<code>redis</code>实例，只不过和<code>redis</code>数据节点不同的是，其主要作用是监控<code>redis</code>数据节点</p></blockquote><blockquote><p>客户端初始化时连接的是<code>sentinel</code>节点集合，不再是具体的<code>redis</code>节点，但<code>sentinel</code>只是配置中心不是代理。</p></blockquote><blockquote><p><code>redis sentinel</code>通过三个定时任务实现了<code>sentinel</code>节点对于主节点、从节点、其余<code>sentinel</code>节点的监控。</p></blockquote><blockquote><p><code>redis sentinel</code>在对节点做失败判定时分为主观下线和客观下线。</p></blockquote><blockquote><p>看懂<code>redis sentinel</code>故障转移日志对于<code>redis sentine</code>l以及问题排查非常有用。</p></blockquote><blockquote><p><code>redis sentinel</code>实现读写分离高可用可以依赖<code>sentinel</code>节点的消息通知，获取<code>redis</code>数据节点的状态变化。</p></blockquote><p><code>redis sentinel</code>可以实现高可用的读写分离，高可用体现在故障转移，那么实现高可用的基础就是要有从节点，主从节点还实现了读写分离，减少<code>master</code>的压力。但是如果是从节点下线了，<code>sentinel</code>是不会对其进行故障转移的，并且连接从节点的客户端也无法获取到新的可用从节点，而这些问题在<code>Cluster</code>中都得到了有效的解决。</p><p>对于性能提高、容量扩展的时候，这种方式是比较复杂的，比较推荐的是使用集群，就是下面讨论的<code>redis cluster</code>!</p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数值计算精度丢失问题</title>
      <link href="/2019/01/31/miscellany/14%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/31/miscellany/14%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>无论在什么业务中，钱是非常重要的东西，对账的时候一定要对的上，不能这边少一分那边多一分。对于数值的计算，尤其是小数，<code>double</code>和<code>double</code>都是禁止使用的。</p><a id="more"></a><blockquote><p>阿里强制要求存放小数时使用 decimal，禁止使用 float 和 double。</p><p>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 <code>decimal</code> 的范围，建议将数据拆成整数和小数分开存储。</p></blockquote><p>处理方式可以为：<code>mysql</code> 可以用 <code>decimal</code> ，如果你是用 <code>java</code>， 在商业计算中我们要用 <code>java.math.BigDecimal</code>，注意：如果需要精确计算，非要用<code>String</code>来够造<code>BigDecimal</code>不可！</p><p>那么到底是什么情况？</p><h2>一个例子说明</h2><p>废话不多说，上图：</p><p><img src="http://bloghello.oursnail.cn/zaji8-1.png" alt="image"></p><h2>问题原因</h2><p>无论是我们本文提到的<code>double</code>，还是<code>float</code>，都是浮点数。</p><p>在计算机科学中，浮点（英语：<code>floating point</code>，缩写为FP）<strong>是一种对于实数的近似值数值表现法</strong>，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（<code>floating-point number</code>）。</p><p>其实我觉得很好理解，我们之前说过，计算机计算加减乘除啊，都是用的加法器，实质都是二进制的加法处理。那么这里就有一个二进制表示的问题。试想，4，2，8之流都是2的幂次方，可以完美用二进制表示，计算当然不会出现问题。对于0，1，3，5之类也都可以用二进制来表示出来，所以，正数肯定是没问题的。</p><p>但是对于小数呢？1、0.5、0.25那都是可以转换成二进制的小数，如十进制的0.1，就无法用二进制准确的表示出来。因此只能使用近似值的方式表达。</p><p><img src="http://bloghello.oursnail.cn/zaji8-2.png" alt="image"></p><p>如果我们尝试着把10进制的0.1转化成二进制，会怎么转呢？</p><p>在十进制中，0.1如何计算出来的呢？</p><blockquote><p>0.1 = 1 ÷ 10</p></blockquote><p>那么二进制中也是同理：</p><blockquote><p>1 ÷ 1010</p></blockquote><p>我们回到小学的课堂，来列竖式吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       0.000110011...</span><br><span class="line">      ------------------</span><br><span class="line">1010 ) 1 0000</span><br><span class="line">         1010</span><br><span class="line">       ------</span><br><span class="line">          1100</span><br><span class="line">          1010</span><br><span class="line">          ----</span><br><span class="line">            10000</span><br><span class="line">             1010</span><br><span class="line">            -----</span><br><span class="line">              1100</span><br><span class="line">              1010</span><br><span class="line">              ----</span><br><span class="line">                10</span><br></pre></td></tr></table></figure><p>很显然，除不尽，除出了一个无限循环小数：二进制的 0.0001100110011…</p><p>那么，如何在计算机中表示这个无限不循环的小数呢？只能考虑按照不同的精度保理不同的位数。</p><p>我们知道float是单精度的，double是双精度的。不同的精度，其实就是保留的有效数字位数不同，保留的位数越多，精度越高。</p><p>所以，浮点数在Java中是无法精确表示的，因为大部分浮点数转换成二进制是一个无限不循环的小数，只能通过保留精度的方式进行近似表示。</p><h2>问题的解决</h2><p><code>String</code> 构造方法是完全可预知的：写入 <code>newBigDecimal(&quot;0.1&quot;)</code> 将创建一个 <code>BigDecimal</code>，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用<code>String</code>构造方法。</p><p>使用<code>BigDecimal(String val)</code>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.add(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">sub</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.subtract(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">mul</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.multiply(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//四舍五入,保留2位小数,应对除不尽的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，上面的精度丢失问题就迎刃而解了。但是除不尽怎么办？比如10.0除以这里的3.0，保留小数点后三位有效数字：</p><p><img src="http://bloghello.oursnail.cn/zaji8-3.png" alt="image"></p><p>那么，每个用户得到的都是3.333元，三个用户加起来是得不到10块钱的。</p><p>对于除法，始终会产生除不尽的情况怎么办？有个词叫轧差</p><p>什么意思呢？举个简单例子。假如现在需要把10元分成3分，如果是10除以3这么除，会发现为3.33333无穷尽的3。这些数字完全无法在程序或数据库中进行精确的存储。</p><p>简单理解就是，当除不尽或需去除小数点的时候，前面的n-1笔（这里n=3）做四舍五入。最后一笔做兜底（总金额减去前面n-1笔之和）。这样保证总金额的不会丢失。</p><p>比如10块钱，三个用户分，前面两个用户只能各分到3。333块钱，最后一个用户分到3.334块钱。保证总额不变。</p><p>至于原理，有一点点数学化，以后再作探讨吧。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis主从复制</title>
      <link href="/2019/01/31/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/01/31/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第六篇文章。介绍redis主从复制功能实现原理。作为高可用的基础，了解一下其中的门道是有必要的。</p><a id="more"></a><h2>1.单机有什么问题</h2><ul><li>机器故障</li><li>容量瓶颈</li><li>QPS瓶颈</li></ul><h2>2. 主从复制的作用</h2><ul><li>数据副本</li><li>扩展读性能，<code>slave</code>专门用来读</li><li>一个<code>master</code>可以有多个<code>slave</code>，一个<code>salve</code>只能有一个<code>master</code></li></ul><h2>3. 两种实现方式</h2><ul><li>方式一：<code>slaveof</code>命令<ul><li><code>slaveof masterIp masterPort</code></li><li><code>slaveof no one</code>(不会清除原来同步的数据，而是新的数据不会再同步给他)</li></ul></li><li>方式二：配置<ul><li>修改某一行的配置：<code>slaveof ip port</code></li><li>从节点只做读操作：<code>slave-read-only yes</code></li></ul></li><li>对比<ul><li>命令的优点：不需要重启</li><li>命令的缺点：不便于管理</li><li>配置的优点：统一配置</li><li>配置的缺点：需要重启</li></ul></li></ul><p>一个场景，假如6380是6379的一个从节点，然后将6380执行<code>salveof no one</code>，然后插入一些新的数据；再重新变成6379的从节点，那么里面的新数据会被清除掉。</p><ul><li>查看run_id<ul><li><code>redis-cli -p 6379 info server | grep run</code></li></ul></li></ul><h2>4. 全量复制</h2><ul><li>全量复制开销<ul><li>bgsave时间</li><li>rdb网络传输时间</li><li>从节点清空数据的时间</li><li>从节点加载RDB的时间</li><li>可能的AOF重写时间</li></ul></li><li>存在的问题<ul><li>时间开销比较大</li><li>如果<code>master</code>和<code>slave</code>之间网络扰动甚至断开，那么<code>master</code>此间更新的数据对于<code>slave</code>是不知道的，最简单的方法就是再进行一次全量复制，但是显然，消耗太大了。</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png" alt="image"></p><h2>5. 部分复制</h2><p><img src="http://bloghello.oursnail.cn/%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6.png" alt="image"></p><h2>6. 开发与运维的问题</h2><ul><li>读写分离</li></ul><p><code>master</code>只做写操作，<code>slave</code>来做读操作，来分摊流量。但是会有一些问题：</p><blockquote><p>复制数据延迟</p><p>读到过期数据</p><p>从节点故障</p></blockquote><ul><li>主从配置不一致</li></ul><blockquote><p>例如<code>maxmemory</code>不一致：丢失数据</p><p>数据结构优化参数：内存不一致</p></blockquote><ul><li>规避全量复制</li></ul><blockquote><p>第一次全量复制：不可避免—小主节点(<code>maxmemroy</code>不要太大)或者在低峰时进行操作</p><p>节点<code>run_id</code>不匹配（主节点重启，那么<code>master</code>的<code>run_id</code>会发生变化，<code>slave</code>发现其<code>run_id</code>变化，会进行全量复制）；我们可以用故障转移，例如哨兵或集群来避免全量复制。</p><p>复制积压缓冲区不足(网络中断，部分复制无法满足)，可以增大复制缓冲区配置<code>size</code>，网络增强</p></blockquote><ul><li>规避复制风暴</li></ul><blockquote><p>概念：主节点宕机造成大量的全量复制</p><p>单主节点复制风暴：主节点重启，多从节点复制；解决：更换复制拓扑</p><p>单机器复制风暴：机器宕机后（该机器全是<code>Mater</code>），大量全量复制。解决：<code>master</code>分散多机器。</p></blockquote><p>说到底，还是需要有一种高可用的实现方式，在<code>master</code>出现故障之后，如何自动实现从<code>slave</code>晋升为<code>master</code>继续使用.而不是一直死守着原来老的<code>master</code>不放，因为老的<code>master</code>啥时候恢复不知道，恢复了可能会造成复制风暴，既然从节点本来是一直与<code>master</code>节点保持尽量的同步的，那么为什么不将数据最新的从节点升级为主节点呢？下一章继续来分析。</p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2019/01/31/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2019/01/31/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第五篇文章。redis处理数据都是在内存中进行，所以速度特别快，同样，它也可以支持持久化，这里注意，并不是说redis要来充当mysql那种角色，其实更多的是为了在崩溃的时候快速恢复以及主从复制这样的功能。redis的持久化主要有两种方式，一种是RDB，一种是AOF，对于他们的原理和区别都是比较重要的面试考察点，需要掌握。</p><a id="more"></a><h2>1. 什么是持久化</h2><p><code>redis</code>所有数据保持在内存中，对数据的更新将异步地保存到磁盘中。</p><h2>2. 持久化的方式</h2><p>快照—<code>mysql dump</code>或者<code>redis rdb</code></p><p>写日志—<code>mysql binlog</code>或者<code>hbase glog</code>或者<code>redis aof</code></p><h2>3. RDB</h2><h4>什么是RDB</h4><p><img src="http://bloghello.oursnail.cn/%E4%BB%80%E4%B9%88%E6%98%AFRDB.png" alt="image"></p><h4>触发机制三种主要方式</h4><ul><li>save(<strong>同步持久化，会造成redis主线程的阻塞，不推荐使用</strong>)</li></ul><p><code>save</code>是同步的，当保存的数据量很大时，可能造成<code>redis</code>的阻塞，即客户端访问<code>redis</code>被阻塞。</p><p><img src="http://bloghello.oursnail.cn/save%E5%91%BD%E4%BB%A4.png" alt="image"></p><p>他的文件策略是：如果存在老的<code>RDB</code>文件，则新的替换老的。复杂度为<code>O(n)</code>。</p><ul><li>bgsave(<strong>异步，fork一个子进程来进行持久化，不会造成主线程的阻塞</strong>)</li></ul><p>一般情况下，<code>fork</code>是比较快的，但是也可以会慢，这时会阻塞<code>redis</code>。只要<code>fork</code>不慢，客户端不会被阻塞。</p><p><img src="http://bloghello.oursnail.cn/newbgsave.png" alt="image"></p><p>他的文件策略和复杂度与save是一样的。</p><p><code>save</code>和<code>bgsave</code>两者对比：</p><p><img src="http://bloghello.oursnail.cn/save%E5%92%8Cbgsave%E5%AF%B9%E6%AF%94.png" alt="image"></p><ul><li>自动</li></ul><p><code>redis</code>的自动保存的默认配置是：</p><table><thead><tr><th>配置</th><th>seconds</th><th>changes</th></tr></thead><tbody><tr><td>save</td><td>900</td><td>1</td></tr><tr><td>save</td><td>300</td><td>10</td></tr><tr><td>save</td><td>60</td><td>10000</td></tr></tbody></table><p>就是说，在60秒内改变了10000条数据，就自动保存；在300秒内有10条改变才自动保存；900秒内有1一条改变就保存。</p><h4>RDB总结</h4><ol><li><code>RDB</code>是<code>Redis</code>内存到硬盘的快照，用于持久化。</li><li><code>save</code>通常会阻塞<code>redis</code>。</li><li><code>bgsave</code>不会阻塞<code>redis</code>，但是会<code>fork</code>新进程。</li><li><code>save</code>自动配置满足任一就会被执行。</li><li>有些触发机制不容忽视。</li></ol><h2>4. AOF</h2><h4>RDB问题</h4><ul><li>全量数据存入磁盘</li></ul><p><code>O(n)</code>数据的备份，很耗时间；对于<code>bgsave</code>来说，<code>fork()</code>是一个很消耗内存的操作；将数据全写到硬盘，必然对硬盘IO占用很大。</p><ul><li>宕机丢失数据多</li></ul><p>还有一点是：<strong>某个时间点宕机，那么在某个时间段的数据就丢失了</strong>。</p><h4>AOF原理</h4><p>将对<code>redis</code>的操作追加到<code>aof</code>文件中。当<code>redis</code>宕机之后，使用<code>aof</code>恢复所有的操作继而实现数据的恢复。</p><h4>AOF三种策略</h4><ul><li>always</li></ul><p><img src="http://bloghello.oursnail.cn/aof-always.png" alt="image"></p><ul><li>everysec</li></ul><p><img src="http://bloghello.oursnail.cn/aof-everysec.png" alt="image"></p><p><code>redis</code>出现故障，有可能丢失一秒的数据。<code>redis</code>默认方式。</p><ul><li>no</li></ul><p><img src="http://bloghello.oursnail.cn/aof-no.png" alt=""></p><h4>三种策略的比较</h4><p><img src="http://bloghello.oursnail.cn/aof%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="image"></p><h4>AOF重写</h4><p><img src="http://bloghello.oursnail.cn/AOF%E9%87%8D%E5%86%99.png" alt="image"></p><p>好处是：减少硬盘占用、减少数据丢失</p><p>下面是AOF的<code>bgrewirteaof</code>的过程：</p><p><img src="http://bloghello.oursnail.cn/bgrewriteaof.png" alt="image"></p><p>注意：这里的重写并不是上面演示的，将原来的<code>aof</code>文件进行重写，而是根据<code>redis</code>现在的内存数据进行一次回溯。</p><h4>aof重写流程</h4><p><img src="http://bloghello.oursnail.cn/aof%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>也就是说，子进程在执行 AOF 重写时，主进程需要执行以下三个工作：</p><ul><li>1.处理命令请求；</li><li>2.将写命令追加到现有的 AOF 文件中；</li><li>3.将写命令追加到 AOF 重写缓存中。</li></ul><p>如此可以保证：</p><ul><li>现有的AOF功能继续执行，即使 AOF 重写期间发生停机，也不会有任何数据丢失；</li><li>所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。</li></ul><p>当子进程完成对 AOF 文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：(阻塞)</p><ul><li>将 AOF 重写缓存中的内容全部写入到新的 AOF 文件中；(现有 AOF 文件、新的 AOF 文件和数据库三者的状态就完全一致了)</li><li>对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。(执行完毕后，程序就完成了新旧两个 AOF 文件的替换)</li></ul><p>当这个信号处理函数执行完毕之后，主进程就可以继续像往常一样接收命令请求了。在整个 AOF 后台重写过程中，<strong>只有最后的“主进程写入命令到AOF缓存”和“对新的 AOF 文件进行改名，覆盖原有的 AOF 文件”这两个步骤会造成主进程阻塞，在其他时候， AOF 后台重写都不会对主进程造成阻塞，这将 AOF 重写对性能造成的影响降到最低。</strong></p><p>小结：</p><ul><li>AOF 重写的目的是轻量地保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求；</li><li>AOF在redis宕机的时候最多丢失一秒的数据，比RDB要好一点，并且可读性高，基本上能看得懂</li><li>AOF 重写其实是一个有歧义的名字，实际上重写工作是针对数据库的当前值来进行的，重写过程中不会读写、也不适用原来的 AOF 文件；</li><li>AOF 可以由用户手动触发，也可以由服务器自动触发。</li></ul><h2>5. 持久化的取舍和选择</h2><h4>RDB和AOF对比</h4><p><img src="http://bloghello.oursnail.cn/RDB%E5%92%8CAOF%E5%AF%B9%E6%AF%94.png" alt="image"></p><p>可以看出，世界上没有完美的东西，只有合适的东西。AOF同样存在一些问题：AOF文件的体积通常要大于RDB文件的体积、且恢复速度慢。</p><h4>RDB最佳策略</h4><p>“关”：建议关闭，但是后面主从复制功能是需要他的，因为需要主节点执行<code>dbsave</code>，然后将<code>rdb</code>文件传给从节点。所以说，关不是永久关。</p><p><strong>“集中管理”：虽然<code>RDB</code>很重，但是对于数据备份是很重要的，按照小时或者天集中地进行备份比较好，因为他的文件很小，利于传输。</strong></p><p>“主从，从开”：有时候从节点打开这个功能是比较好的，但是备份太频繁，取决于实际的场景。</p><h4>AOF最佳策略</h4><ul><li>“开”：建议打开，如果仅仅是作为一个普通缓存，对于数据要求不是很高，这次数据丢了，下次可以从数据库取(数据库压力不是很大)，这种情况就建议关闭，因为<code>AOF</code>还是有性能开销的。</li><li>“everysec”</li></ul><h4>Redis4</h4><p><code>Redis 4.0</code> 新增了 <code>RDB-AOF</code> 混合持久化格式， 这是一个可选的功能，</p><p>在开启了这个功能之后， <code>AOF</code> 重写产生的文件将同时包含 <code>RDB</code> 格式的内容和 <code>AOF</code> 格式的内容， 其中 <code>RDB</code> 格式的内容用于记录已有的数据， 而 <code>AOF</code> 格式的内存则用于记录最近发生了变化的数据， 这样 <code>Redis</code> 就可以同时兼有 <code>RDB</code> 持久化和 <code>AOF</code> 持久化的优点 —— 既能够快速地生成重写文件， 也能够在出现问题时， 快速地载入数据。</p><p>RDB和AOF共存的情况下如何恢复数据：</p><p><img src="http://bloghello.oursnail.cn/redis5-1.png" alt="image"></p><ul><li>优点：<ul><li>混合持久化结合了<code>RDB</code>持久化 和 <code>AOF</code> 持久化的优点,</li><li>由于绝大部分都是<code>RDB</code>格式，加载速度快，同时结合<code>AOF</code>，增量的数据以<code>AOF</code>方式保存了，数据更少的丢失。</li></ul></li><li>缺点：<ul><li>兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该<code>aof</code>文件，同时由于前部分是<code>RDB</code>格式，阅读性较差</li></ul></li></ul><p>策略是：</p><h2>6. 总结</h2><ul><li><a href="http://www.ywnds.com/?p=4876" target="_blank" rel="noopener">http://www.ywnds.com/?p=4876</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入Nginx原理</title>
      <link href="/2019/01/30/miscellany/13%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Nginx%E5%8E%9F%E7%90%86/"/>
      <url>/2019/01/30/miscellany/13%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Nginx%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡中间件。是非常常用的web server.我们需要理解它的原理，才能达到游刃有余的程度。</p><a id="more"></a><p>本篇文章需要对Nginx有基本的使用以及对IO复用模型有一定的了解。文章比较长。</p><h2>1.正向代理和反向代理</h2><p><img src="http://xiaozhao.oursnail.cn/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="image"></p><p><strong>正向代理的工作原理就像一个跳板</strong>，比如：我访问不了<code>google.com</code>，但是我能访问一个代理服务器A，A能访问<code>google.com</code>，于是我先连上代理服务器A，告诉他我需要<code>google.com</code>的内容，A就去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="image"></p><p>反向代理（<code>Reverse Proxy</code>）方式是指以代理服务器来接受<code>internet</code>上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给<code>internet</code>上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><p>简单来说：</p><ul><li>正向代理是不知道客户端是谁，代理是一个跳板，所有客户端通过这个跳板来访问到对应的内容。</li><li>反向代理是不知道服务端是谁，用户的请求被转发到内部的某台服务器去处理。</li></ul><h2>2.基本的工作流程</h2><p><img src="http://xiaozhao.oursnail.cn/nginx%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="image"></p><ol><li>用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址；</li><li>反向代理服务器接受用户的请求；</li><li>反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</li><li>如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中。</li></ol><h2>3.优点</h2><ul><li>保护了真实的web服务器，保证了web服务器的资源安全</li><li>节约了有限的IP地址资源</li><li>减少WEB服务器压力，提高响应速度(缓存功能)</li><li>请求的统一控制，包括设置权限、过滤规则等</li><li>实现负载均衡</li><li>区分动态和静态可缓存内容</li><li>…</li></ul><h2>4.使用场景</h2><ul><li>Nginx作为Http代理、反向代理</li><li>Nginx作为负载均衡器</li><li>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</li><li>Nginx作为Web缓存</li></ul><h2>5.Nginx的Master-Worker模式</h2><p><img src="http://xiaozhao.oursnail.cn/Nginx%E7%9A%84Master-Worker%E6%A8%A1%E5%BC%8F.png" alt="image"></p><p>启动<code>Nginx</code>后，其实就是在80端口启动了<code>Socket</code>服务进行监听，如图所示，<code>Nginx</code>涉及<code>Master</code>进程和<code>Worker</code>进程。</p><p><img src="http://xiaozhao.oursnail.cn/Master-Worker%E6%A8%A1%E5%BC%8F.png" alt="image"></p><h2>6.Master进程的作用是？</h2><p>读取并验证配置文件<code>nginx.conf</code>；管理<code>worker</code>进程；</p><ul><li>接收来自外界的信号</li><li>向各worker进程发送信号</li><li>监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程</li></ul><h2>7.Worker进程的作用是？</h2><p>每一个<code>Worker</code>进程都维护一个线程（避免线程切换），处理连接和请求；注意<code>Worker</code>进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个<code>Worker</code>进程。</p><h5>思考：Nginx如何做到热部署？</h5><blockquote><p>所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载/nginx -t检查配置/nginx -s stop）</p><p>通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p>方案一：</p><p>修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点volatile的味道）</p><p>方案二：</p><p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p></blockquote><p>Nginx采用的就是方案二来达到热部署的！</p><h5>思考：Nginx如何做到高并发下的高效处理？</h5><blockquote><p>上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p><p>作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞…</p><p>要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</p><p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</p></blockquote><h5>思考：Nginx挂了怎么办？</h5><blockquote><p>Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p><p>答案是：Keepalived+Nginx实现高可用。</p><p>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</p><p>Keepalived+Nginx实现高可用的思路：</p><p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p><p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,从而实现Nginx故障切换）</p></blockquote><p><img src="http://xiaozhao.oursnail.cn/Keepalived+Nginx.png" alt="image"></p><h2>6.nginx.conf</h2><p><img src="http://xiaozhao.oursnail.cn/nginx.conf.png" alt="image"></p><ul><li>第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</li><li>第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。</li><li>第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</li><li>第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。</li></ul><p>除了可以映射静态资源，上面已经说了，可以作为一个代理服务器来使用。</p><blockquote><p>所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理，上面已经说了，过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。</p></blockquote><p>负载均衡【upstream】</p><blockquote><p>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><p>第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</p><p>第二，将proxy_pass替换成upstream指定的值即可。</p><p>负载均衡可能带来的问题？</p><p>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</p></blockquote><h2>7.惊群现象</h2><p>定义：惊群效应就是当一个fd的事件被触发时，所有等待这个fd的线程或进程都被唤醒。</p><p><code>Nginx</code>的IO通常使用<code>epoll</code>，<code>epoll</code>函数使用了I/O复用模型。与I/O阻塞模型比较，I/O复用模型的优势在于可以同时等待多个（而不只是一个）套接字描述符就绪。<code>Nginx</code>的<code>epoll</code>工作流程如下：</p><ul><li>master进程先建好需要listen的socket后，然后再fork出多个woker进程，这样每个work进程都可以去accept这个socket</li><li>当一个client连接到来时，所有accept的work进程都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败，Nginx提供了一把<strong>共享锁accept_mutex</strong>来保证同一时刻只有一个work进程在accept连接，从而解决惊群问题</li><li>当一个worker进程accept这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了</li></ul><h2>8.Nginx架构及工作流程</h2><p><img src="http://xiaozhao.oursnail.cn/Nginx%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p><p><code>Nginx</code>真正处理请求业务的是<code>Worker</code>之下的线程。<code>worker</code>进程中有一个<code>ngx_worker_process_cycle()</code>函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个<code>Nginx</code>服务被停止。</p><p>当一个 <code>worker</code> 进程在 <code>accept()</code> 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个完整的请求。一个请求，完全由 <code>worker</code> 进程来处理，而且只能在一个 <code>worker</code> 进程中处理。</p><p>这样做带来的好处：</p><ol><li>节省锁带来的开销。每个 <code>worker</code> 进程都是独立的进程，不共享资源，不需要加锁。同时在编程以及问题查上时，也会方便很多。</li><li>独立进程，减少风险。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，<code>master</code> 进程则很快重新启动新的 <code>worker</code> 进程。当然，<code>worker</code> 进程的也能发生意外退出。</li></ol><h2>9.nginx为什么高性能</h2><p><strong>因为nginx是多进程单线程的代表，多进程模型每个进程/线程只能处理一路IO，那么 Nginx是如何处理多路IO呢？</strong></p><p>如果不使用 IO 多路复用，那么在一个进程中，同时只能处理一个请求，比如执行 <code>accept()</code>，如果没有连接过来，那么程序会阻塞在这里，直到有一个连接过来，才能继续向下执行。</p><p>而多路复用，允许我们只在事件发生时才将控制返回给程序，而其他时候内核都挂起进程，随时待命。</p><p><strong>核心：Nginx采用的 IO多路复用模型epoll</strong></p><p><code>epoll</code>通过在<code>Linux</code>内核中申请一个简易的文件系统（文件系统一般用什么数据结构实现？B+树），其工作流程分为三部分：</p><ol><li>调用 <code>int epoll_create(int size)</code>建立一个<code>epoll</code>对象，内核会创建一个<code>eventpoll</code>结构体，用于存放通过<code>epoll_ctl()</code>向<code>epoll</code>对象中添加进来的事件，这些事件都会挂载在红黑树中。</li><li>调用 <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code> 在 <code>epoll</code> 对象中为 fd 注册事件，所有添加到<code>epoll</code>中的事件都会与设备驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个<code>sockfd</code>的回调方法，将<code>sockfd</code>添加到<code>eventpoll</code> 中的双链表</li><li>调用 <code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code> 来等待事件的发生，<code>timeout</code> 为 -1 时，该调用会阻塞直到有事件发生</li></ol><p>这样，注册好事件之后，只要有 fd 上事件发生，<code>epoll_wait()</code> 就能检测到并返回给用户，用户就能”非阻塞“地进行 I/O 了。</p><p><code>epoll()</code> 中内核则维护一个链表，<code>epoll_wait</code> 直接检查链表是不是空就知道是否有文件描述符准备好了。（<code>epoll</code> 与 <code>select</code> 相比最大的优点是不会随着 <code>sockfd</code> 数目增长而降低效率，使用 <code>select()</code> 时，内核采用轮训的方法来查看是否有fd 准备好，其中的保存 <code>sockfd</code> 的是类似数组的数据结构 <code>fd_set</code>，key 为 fd，value 为 0 或者 1。）</p><p>能达到这种效果，是因为在内核实现中 <code>epoll</code> 是根据每个 <code>sockfd</code> 上面的与设备驱动程序建立起来的回调函数实现的。那么，某个 <code>sockfd</code> 上的事件发生时，与它对应的回调函数就会被调用，来把这个 <code>sockfd</code> 加入链表，其他处于“空闲的”状态的则不会。在这点上，<code>epoll</code> 实现了一个”伪”AIO。但是如果绝大部分的 I/O 都是“活跃的”，每个 <code>socket</code> 使用率很高的话，<code>epoll</code>效率不一定比 <code>select</code> 高（可能是要维护队列复杂）。</p><p>可以看出，因为一个进程里只有一个线程，所以一个进程同时只能做一件事，但是可以通过不断地切换来“同时”处理多个请求。</p><p>例子：<code>Nginx</code> 会注册一个事件：“如果来自一个新客户端的连接请求到来了，再通知我”，此后只有连接请求到来，服务器才会执行 <code>accept()</code> 来接收请求。又比如向上游服务器（比如 PHP-FPM）转发请求，并等待请求返回时，这个处理的 <code>worker</code> 不会在这阻塞，它会在发送完请求后，注册一个事件：“如果缓冲区接收到数据了，告诉我一声，我再将它读进来”，于是进程就空闲下来等待事件发生。</p><p>这样，基于 多进程+epoll， Nginx 便能实现高并发。</p><h2>10.几种负载均衡的算法介绍</h2><blockquote><p>轮询（默认）</p></blockquote><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><blockquote><p>weight</p></blockquote><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><blockquote><p>ip_hash</p></blockquote><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问同一个后端服务器，可以解决session的问题。但是不能解决宕机问题。<br>前三种是nginx自带的，直接在配置文件中配置即可使用。</p><blockquote><p>fair（第三方）</p></blockquote><p>按后端服务器的相应时间来分配请求，相应时间短的优先分配。</p><blockquote><p>url_hash（第三方）</p></blockquote><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><h2>11.基于不同层次的负载均衡</h2><p><img src="http://bloghello.oursnail.cn/http1-6.png" alt="image"></p><p>七层就是基于URL等应用层信息的负载均衡；<br>同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。</p><p>换句话说:</p><ul><li>二层负载均衡会通过一个虚拟MAC地址接受请求，然后再分配到真是的MAC地址；</li><li>三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；</li><li>四层通过虚拟的URL或主机名接收请求，然后再分配到真是的服务器。</li></ul><p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。</p><p>比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。</p><p>七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p><p>负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。</p><p>负载均衡设备也常被称为&quot;四到七层交换机&quot;，那么四层和七层两者到底区别在哪里？</p><blockquote><p>第一，技术原理上的区别。</p></blockquote><p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><blockquote><p>第二，应用场景的需求。</p></blockquote><p>七层应用负载的好处，是使得整个网络更&quot;智能化&quot;。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。</p><p>另外一个常常被提到功能就是安全性。</p><h2>12.总结</h2><ol><li>理解正向代理和反向代理的概念</li><li>nginx的优点和使用场景</li><li>master和work两种进程的作用</li><li>如何热部署</li><li>Nginx单点故障的预防</li><li>映射静态文件、反向代理跳转到后端服务器处理的写法</li><li>惊群现象</li><li>Nginx 采用的是多进程（单线程） &amp; 多路IO复用模型(底层依靠epoll实现)</li><li>几种负载均衡的算法</li><li>四层的负载均衡和七层的负载均衡</li></ol>]]></content>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis为什么快</title>
      <link href="/2019/01/30/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/"/>
      <url>/2019/01/30/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第四篇文章，本文主要攻克面试题-Redis为什么这么快。这就涉及Redis的线程模型啦。</p><a id="more"></a><h2>完全基于内存</h2><p><code>Redis</code>是纯内存数据库，相对于读写磁盘，读写内存的速度就不是几倍几十倍了，一般，<code>hash</code>查找可以达到每秒百万次的数量级。</p><h2>多路复用IO</h2><p>“多路”指的是多个网络连接，“复用”指的是复用同一个线程。<strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗）。</p><h2>Redis为什么是单线程的？</h2><p>因为CPU不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><h2>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h2><p>首先，<code>Redis</code> 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p><blockquote><p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ol><li><p>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p></li><li><p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</p></li><li><p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。</p></li></ol><p>第三种就是IO复用模型，<code>Linux</code>下的<code>select</code>、<code>poll</code>和<code>epoll</code>就是干这个的。<strong>将用户<code>socket</code>对应的<code>fd</code>注册进<code>epoll</code>，然后<code>epoll</code>帮你监听哪些<code>socket</code>上有消息到达</strong>，这样就避免了大量的无用操作。此时的<code>socket</code>应该采用非阻塞模式。这样，整个过程只在调用<code>select</code>、<code>poll</code>、<code>epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的<code>reactor</code>模式。</p></blockquote><p>所以，I/O多路复用的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。</p><p>这里还涉及一个名词：<strong>fd文件描述符。</strong></p><p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p><h2>redis的线程模型？</h2><p><code>Redis</code> 服务采用 <code>Reactor</code> 的方式来实现文件事件处理器。</p><p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p><p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 <code>Redis</code> 服务实现的简单。</p><p><img src="http://bloghello.oursnail.cn/redis%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86111.png-1000width" alt="image"></p><p>上面简单理解就是：多个网络连接并发读写redis的时候，先将对应的fd注册到<code>epoll</code>上，I/O多路复用模块会监听这些网络请求的情况，一旦有一个网络连接产生了<code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件，I/O多路复用模块就会向文件事件分派器传送那些产生了事件的网络连接。</p><p><img src="http://bloghello.oursnail.cn/redis4-1.png" alt="image"></p><p>当然了，上面的文件事件可能会并发产生，这时的策略是，将所有产生事件的套接字（对应上面的网络连接）都入队到一个队列里面， 然后通过这个队列， 以有序（<code>sequentially</code>）、同步（<code>synchronously</code>）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。再看看下图，与上图使一样的：</p><p><img src="http://bloghello.oursnail.cn/redis4-2.png" alt="image"></p><p>文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。</p><p>服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。</p><p><strong>整个模块使 <code>Redis</code> 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性，单线程还减少线程切换和调度，实现更加简单</strong></p><p><strong>最后总结一下</strong>，为什么<code>redis</code>比较快大概思路通俗的说就是：<code>Redis</code>是纯内存数据库，读取快，瓶颈在于IO上，如果使用阻塞式IO，因为是单线程的缘故，就会停止等待。所以采用IO多路复用监听文件描述符的状态，将对<code>redis</code>的开关读写换成事件，加入队列进行相应的事件处理，吞吐量比较大。</p><h2>IO复用模型的选择</h2><p>因为 Redis 需要在多个平台上运行，同时为了最大化执行的效率与性能，所以会根据编译平台的不同选择不同的 I/O 多路复用函数作为子模块，提供给上层统一的接口；</p><p>因为 <code>select</code> 函数是作为 <code>POSIX</code> 标准中的系统调用，在不同版本的操作系统上都会实现，所以将其作为保底方案：</p><p><img src="http://bloghello.oursnail.cn/redis4-3.png" alt="image"></p><p><code>Redis</code> 会优先选择时间复杂度为 <code>O(1)</code> 的 I/O 多路复用函数作为底层实现，包括 <code>Solaries 10</code> 中的 <code>evport</code>、<code>Linux</code> 中的 <code>epoll</code> 和 <code>macOS/FreeBSD</code> 中的 <code>kqueue</code>，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。</p><p>但是如果当前编译环境没有上述函数，就会选择 <code>select</code> 作为备选方案，由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 <code>O(n)</code>，并且只能同时服务 1024 个文件描述符，所以一般并不会以 <code>select</code> 作为第一方案使用。</p><h2>reids在linux下的安装</h2><p><code>Redis</code>对于<code>Linux</code>是官方支持的，安装起来也非常地简单，直接编译源码然后进行安装即可。</p><p>这里以<code>centos</code>为例，大概说一下步骤：</p><blockquote><p>下载redis编译工具:<code>yum install gcc</code>和<code>yum install g++</code></p></blockquote><blockquote><p>解压<code>redis.tar.gz</code>文件，进去之后进行编译:<code>make</code></p></blockquote><blockquote><p>然后安装：<code>make install PREFIX=/usr/local/redis</code></p></blockquote><blockquote><p>安装成功之后进入<code>/usr/local/redis/bin</code>下启动<code>redis</code></p><p><code>./redis-server</code></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis其他的功能介绍</title>
      <link href="/2019/01/29/redis/Redis%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/01/29/redis/Redis%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第三篇文章，本文主要介绍redis一些其他的功能。遇到某些场景的时候可以想到redis是不是可以实现。</p><a id="more"></a><h2>一、慢查询日志</h2><h4>1.1 什么是慢查询日志</h4><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来。</p><h4>1.2 redis一条命令简单的生命周期</h4><p><img src="http://xiaozhao.oursnail.cn/redis%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image"></p><p>慢查询只会出现在【<strong>3.执行命令</strong>】这个阶段，即慢查询只记录命令执行时间，并不包括命令排队时间和网络传输时间。</p><h4>1.3 慢查询配置参数</h4><blockquote><p>慢查询的预设阀值  <code>slowlog-log-slower-than</code></p></blockquote><ul><li><code>slowlog-log-slower-than</code>参数就是预设阀值，单位是微秒,默认值是10000，如果一条命令的执行时间超过10000微妙(10毫秒)，那么它将被记录在慢查询日志中。</li><li>如果<code>slowlog-log-slower-than</code>的值是0，则会记录所有命令。</li><li>如果<code>slowlog-log-slower-than</code>的值小于0，则任何命令都不会记录日志。</li><li><code>redis</code>的操作一般是微妙级，<code>slowlog-log-slower-than</code>不要设置太大，一般设置为1毫秒。支持动态设置。</li></ul><blockquote><p>慢查询日志的长度<code>slowlog-max-len</code></p></blockquote><ul><li><code>slowlog-max-len</code>只是说明了慢查询日志最多存储多少条。</li><li><code>Redis</code>使用一个列表来存储慢查询日志，<code>showlog-max-len</code>就是列表的最大长度。</li><li>当慢查询日志已经到达列表的最大长度时，又有慢查询日志要进入列表，则最早插入列表的日志将会被移出列表，新日志被插入列表的末尾。</li><li>默认是128，但是<code>slowlog-max-len</code>不要设置太小，可以设置为1000以上.</li></ul><p><strong>慢查询日志是一个先进先出队列，慢查询较多的情况下，可能会丢失部分慢查询命令，可以定期执行<code>slow get</code>命令将慢查询日志持久化到其他存储中。然后制作可视化界面查询。</strong></p><h2>二、pipeline</h2><h4>2.1 为什么会出现Pipeline</h4><p>用普通的<code>get</code>和<code>set</code>，如果同时需要执行大量的命令，那就是等待上一条命令应答后再执行，这中间不仅仅多了<code>RTT（Round Time Trip）</code>，而且还频繁的调用系统IO，发送网络请求。</p><p><img src="http://bloghello.oursnail.cn/%E6%89%B9%E9%87%8F%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>对于多条命令不是有<code>mget</code>和<code>mset</code>吗？确实对于一批的<code>get</code>和<code>set</code>可以用<code>mget</code>和<code>mset</code>，但是它的问题在于如果我们需要同时传输<code>get</code>和<code>hget</code>呢？此时<code>pipeline</code>(流水线)就出现了。</p><p><img src="http://bloghello.oursnail.cn/%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="image"></p><p>所以流水线解决的问题是N条命令网络通信的减少。</p><p><img src="http://bloghello.oursnail.cn/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="image"></p><p>为什么说网络耗费时间大呢？这里给出一个极端的例子。</p><p><img src="http://bloghello.oursnail.cn/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%97%B6%E9%97%B4.png" alt="image"></p><p><code>pipeline</code>与原生M操作的对比。</p><ul><li>原生M操作是一个原子操作。</li></ul><p><img src="http://bloghello.oursnail.cn/%E5%8E%9F%E7%94%9FM%E6%93%8D%E4%BD%9C.png" alt="image"></p><ul><li><code>pipeline</code>非原子命令。</li></ul><p><img src="http://bloghello.oursnail.cn/pipeline%E9%9D%9E%E5%8E%9F%E5%AD%90%E5%91%BD%E4%BB%A4.png" alt="image"></p><p>当某个命令的执行需要依赖前一个命令的返回结果时，无法使用<code>pipeline</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset a “a1” b “b” c “c1” </span><br><span class="line">mget a b c</span><br></pre></td></tr></table></figure><p><code>mget</code>和<code>mset</code>命令也是为了减少网络连接和传输时间所设置的，其本质和<code>pipeline</code>的应用区别不大，但是在特定场景下只能用<code>pipeline</code>实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get a</span><br><span class="line">set b ‘1’</span><br></pre></td></tr></table></figure><p><code>pipeline</code>适合执行这种连续，且无相关性的命令。</p><h4>2.2 一个demo</h4><p>搭建一个<code>quickstart</code>的<code>maven</code>工程。过程略。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接再单元测试中进行测试：普通的直接<code>hset</code> 10000条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        jedis.hset(<span class="string">"hashkey"</span>+i,<span class="string">"filed"</span>+i,<span class="string">"value"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"一共耗时: "</span>+(after-before)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>一共耗时: 1526ms</p></blockquote><p>但是用pipeline后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//分为10次批量发送</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1000</span>*i;j&lt;(i+<span class="number">1</span>)*<span class="number">1000</span>;j++)&#123;</span><br><span class="line">            pipeline.hset(<span class="string">"hashkey:"</span>+j,<span class="string">"field:"</span>+j,<span class="string">"value:"</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        pipeline.syncAndReturnAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用pipeline一共耗时: "</span>+(after-before)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：使用<code>pipeline</code>一共耗时: 139ms</p></blockquote><p>可以预见，对于更多的传输次数，<code>pipeline</code>的优势将越来越明显。但是<code>pipeline</code>每次只能作用在一个<code>redis</code>节点上。</p><h2>三、发布订阅</h2><h4>3.1 角色</h4><p>发布者----频道----订阅者</p><h4>3.2 模型</h4><p><img src="http://bloghello.oursnail.cn/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>注意，新订阅的，是不能收到之前的消息的。</p><ul><li>订阅者1：subscribe mytopic</li><li>订阅者2：subscribe mytopic</li><li>订阅者3：subscribe mytopic</li><li>发布者：publish mytopic “hello”</li></ul><p>缺点是不能保证消息可达，所以还是用专业的消息队列传达比较保障。</p><p>与发布订阅模型很类似的是<strong>消息队列</strong>模型。</p><p><img src="http://bloghello.oursnail.cn/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>只有一个是可以收到消息的。</p><h2>四、bitMap</h2><h5>4.1 位图是什么</h5><p>就是通过一个<code>bit</code>位来表示某个元素对应的值或者状态,其中的<code>key</code>就是对应元素本身。我们知道8个<code>bit</code>可以组成一个<code>Byte</code>，所以<code>bitmap</code>本身会极大的节省储存空间。</p><p><code>Bitmap</code>不是一个确切的数据类型，而是基于<code>String</code>类型定义的一系列面向位操作的方法。因为<code>String</code>是二进制安全的并且它们的最大长度是512MB，<br>所以<code>String</code>类型很合适去作为一个2^32长度的位数组。</p><p>比如我们执行 <code>set hello big</code></p><p>那么这个<code>big</code>其实是这个形态：</p><p><img src="http://bloghello.oursnail.cn/%E5%AD%97%E7%AC%A6%E4%B8%B2big%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="image"></p><p>执行<code>getbit hello 0</code>  得到0； 执行<code>getbit hello 1</code> 得到1</p><p><code>setbit hello 7 1</code>，那么再<code>get hello</code> 将得到<code>cig</code></p><h5>4.2 位图有什么用呢？</h5><p>位图除了<code>getbit</code>和<code>setbit</code>之外，还有<code>bitcount key [start end]</code>，就是获取执行范围内的1的个数。</p><p><code>bitop</code>作用是做多个<code>Bitmap</code>的<code>and</code>,<code>or</code>,<code>not</code>,<code>xor</code>操作。</p><blockquote><p>以一个场景为例：日活跃用户</p></blockquote><p>每次用户登录时会执行一次<code>redis.setbit(daily_active_users, user_id, 1)</code></p><p>因为日活跃用户每天都变化，所以需要每天创建一个新的<code>bitmap</code>。我们简单地把日期（年月日）添加到key后面，以后就可以根据年月日这个key找到某天活跃用户。实现了这个功能。</p><blockquote><p>第二个场景：用户签到情况</p></blockquote><p>将那天所代表的网站的上线日作为<code>offset</code>参数， 比如,如果今天是网站上线的第100天,而用户$uid=10001在今天阅览过网站, 那么执行命令<code>SETBIT peter 100 1</code>. 如果明天<code>$uid=10001</code>也继续阅览网站,那么执行命令<code>SETBIT peter 101 1</code> ,以此类推.</p><p>仔细想想，用位图，一天签到一次只要占一个bit，8天才占一个字节。那么一年这个用户签到占的数据是365/8=45.625个字节.如果不用位图实现，保存一条记录将远远大于一个比特吧，那么当用户量很大的时候，差距将会特别大。</p><h2>五、hyperLogLog</h2><p>基于<code>HyperLogLog</code>算法：极小空间完成独立数量统计。本质还是字符串。</p><ul><li><code>pfadd key element [element...]</code>:向<code>hyperloglog</code>添加元素</li><li><code>pfcount key [key...]</code>:计算<code>hyperloglog</code>的独立总数</li><li><code>pfmerge destkey sourcekey [sourcekey...]</code>:合并多个<code>hyperloglog</code></li></ul><h4>api例子</h4><p><img src="http://bloghello.oursnail.cn/hyperloglogdemo.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/hyperloglogdemo2.png" alt="image"></p><h4>为什么要用hyperLogLog呢</h4><p>我们上面例子可以看到，他的功能类似于去重，统计出所有不一样元素的个数。</p><p>他的优点是：占用内存极小。</p><p><img src="http://bloghello.oursnail.cn/hyperloglog%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97.png" alt="image"></p><p>缺点也有：</p><ul><li>他可能会出错，错误率为0.81%，看你是否能够容忍错误了</li><li>不能拿到单条数据</li></ul><h2>六、geo</h2><p>存储经纬度、计算两地距离、范围计算等。</p><p>提到<code>LBS(Location Based Service)</code>，基于位置的服务。我立即想起<code>Mongodb</code>的<code>GEO</code>实现地理坐标查询等功能，具体介绍为<a href="http://fourcolor.oursnail.cn/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">地理位置附近查询的GEOHASH解决方案</a>。</p><p><code>mongodb</code>最大的特点是灵活，因为其数据是以<code>json</code>的格式存储，所以字段随时可以增加或减少；<code>Redis</code>的特点是快，适合单一的，简单的，大量数据的存储；<code>HBase</code>我没有做深入研究，它的特点是大，适合做离线缓存。在处理社交这种关系复杂的数据存储时，依然还是需要用<code>mysql</code>这种关系型数据库，<code>nosql</code>并不能完全替代。</p><h2>七、总结</h2><ul><li>首先是慢查询日志，可以定时地持久化，并且用一个可视化页面进行监测。</li><li>pipeline解决的是对没有相互依赖的操作的批量执行，减少网络传输和IO时间。但是呢，需要注意一般只能往一个节点放数据，面对集群的时候，就需要采取一些策略了。mset、mget，目前只支持具有相同slot值的key执行批量操作。后文再讲。</li><li>可以实现发布订阅模型以及消息队列，但是消息是无状态的，不能保证消息一定送达，所以需要用专业的MQ来实现。</li><li>位图，可以实现极小的空间完成对大量用户信息的统计。</li><li>地理坐标服务</li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis基本数据结构和操作</title>
      <link href="/2019/01/29/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/01/29/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第二篇文章，本文主要介绍redis如何启动，以及基本的键命令和五种基本数据类型的操作。部分图片可能看不清楚，可以拖到新窗口打开。</p><a id="more"></a><h2>一、启动方式</h2><p>我的环境是<code>windows</code>，那么直接进入<code>redis</code>的解压目录中，分别执行<code>redis-server.exe</code>和<code>redis-cli.exe</code>两个可执行的程序。也可以通过<code>cmd</code>启动：</p><p><img src="http://bloghello.oursnail.cn/redis2-1.png" alt="image"></p><p>不要直接用<code>crtl+C</code>关闭<code>server</code>，在<code>linux</code>下，直接停掉<code>server</code>的话，会导致数据的丢失。正确的做法是在客户端执行 <code>redis-cli.exe shutdown</code></p><p><img src="http://bloghello.oursnail.cn/redis2-2.png" alt="image"></p><p>还可以指定端口启动：<code>./redis-server.exe --port 6380</code></p><p><img src="http://bloghello.oursnail.cn/redis2-3.png" alt="image"></p><p>那么对应客户端连接也要指定相应 的端口才能连接。关闭服务端也要指定相应的端口才行：</p><p><img src="http://bloghello.oursnail.cn/redis2-4.png" alt="image"></p><p><code>-h</code>指定远程<code>redis</code>的<code>ip</code></p><p><img src="http://bloghello.oursnail.cn/redis2-5.png" alt="image"></p><p>通过配置文件启动,可以在下面这个文件中指定端口号：</p><p><img src="http://bloghello.oursnail.cn/redis2-6.png" alt="image"></p><p>结合配置文件启动:</p><p><img src="http://bloghello.oursnail.cn/redis2-7.png" alt="image"></p><p>还可以设置密码：</p><p><img src="http://bloghello.oursnail.cn/redis2-8.png" alt="image"></p><p>那么客户端连接就必须要密码验证了：</p><p><img src="http://bloghello.oursnail.cn/redis2-9.png" alt="image"></p><h2>二、命令</h2><h6>1、基础命令</h6><p><code>info</code>:查看系统信息</p><p><code>select (0-15)</code>，redis一共有16个工作区间，一般默认从0开始，到15.</p><p><img src="http://bloghello.oursnail.cn/redis2-10.png" alt="image"></p><ul><li><code>flushdb</code>：清空当前选择的空间</li><li><code>flushall</code>：清空所有</li><li><code>dbsize</code>：当前空间里面key-value键值对的数目</li><li><code>save</code>：人工实现redis的持久化</li><li><code>quit</code>：退出</li></ul><h6>2、键命令</h6><p><code>del key</code>成功返回1，失败返回0.</p><p><img src="http://bloghello.oursnail.cn/redis2-11.png" alt="image"></p><p><code>exits key</code></p><p><img src="http://bloghello.oursnail.cn/redis2-12.png" alt="image"></p><p><code>ttl</code>和<code>expire</code></p><p><img src="http://bloghello.oursnail.cn/redis2-13.png" alt="image"></p><p><code>type key</code> 查看key的类型</p><p><code>randomkey</code>:</p><p><img src="http://bloghello.oursnail.cn/redis2-14.png" alt="image"></p><p><code>rename oldkey newkey</code></p><p><img src="http://bloghello.oursnail.cn/redis2-15.png" alt="image"></p><p>如果是重命名为已经存在的key呢？</p><p><img src="http://bloghello.oursnail.cn/redis2-16.png" alt="image"></p><p><code>renamenx</code>:</p><p><img src="http://bloghello.oursnail.cn/redis2-17.png" alt="image"></p><h2>三、redis数据结构</h2><h6>1、String字符串</h6><p><code>setex</code>&amp;<code>psetex</code></p><p><img src="http://bloghello.oursnail.cn/redis2-18.png" alt="image"></p><p><code>getrange</code>&amp;<code>getset</code></p><p><img src="http://bloghello.oursnail.cn/redis2-19.png" alt="image"></p><p><code>mset</code>&amp;<code>mget</code>&amp;<code>strlen</code></p><p><img src="http://bloghello.oursnail.cn/redis2-20.png" alt="image"></p><p><code>setnx</code>&amp;<code>msetnx</code></p><p><img src="http://bloghello.oursnail.cn/redis2-21.png" alt="image"></p><p>数值操作</p><p><img src="http://bloghello.oursnail.cn/redis2-22.png" alt="image"></p><h5>2、hash</h5><p><img src="http://bloghello.oursnail.cn/redis2-23.png" alt="image"></p><h5>3、list</h5><p><img src="http://bloghello.oursnail.cn/redis2-24.png" alt="image"></p><h5>4、set</h5><p><img src="http://bloghello.oursnail.cn/redis2-25.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/redis2-26.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/redis2-27.png" alt="image"></p><h6>5、sorted set</h6><p><img src="http://bloghello.oursnail.cn/redis2-28.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初步认识Redis</title>
      <link href="/2019/01/29/redis/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86Redis/"/>
      <url>/2019/01/29/redis/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86Redis/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第一篇文章，主要从感性层面来认识一下这个开发中的宠儿，无论是什么应用，只要有点用户量的，不上redis是不可能的。作为当今最优秀的缓存中间件，没有理由不去深入了解它！</p><a id="more"></a><h2>一、redis是什么</h2><p>redis很快，官方宣称QPS(每秒查询率)达10万。</p><p><code>Redis</code>是一个开源的使用<code>ANSI C</code>语言编写、支持网络、<strong>单进程单线程</strong>、<strong>可基于内存亦可持久化</strong>、一个高性能的<code>key-value</code>数据库。</p><p>简而言之，就是一个缓存数据库，基于内存，也可以持久化，速度贼快，几乎所有互联网公司都在使用。</p><p>有的初学者可能看到数据库这个字眼，就把他归类于mysql之类，其实不是，mysql是一种关系型数据库，是存在磁盘中的。核心的数据是一定要落地到mysql之类的数据库中的。redis其实使用最多的功能是缓存，既然能存东西，那么必然也有数据库的功能，但是有可能会造成数据的缺失。所以，数据一定是要落入数据库才保险，redis可以作为缓存，缓存热点数据或者只读数据，提高性能并保护数据库。</p><h2>二、为什么要用redis</h2><p>好了，我们已经知道它是一个高性能的缓存中间件。那么必然一大功能是作为缓存使用。那为什么要用缓存呢？直接从数据库查不就行了码？</p><p>在实际的业务场景中，用户量一上来，数据库是吃不消的。数据库是性能的一大瓶颈，如果不采取措施，用户的操作将卡在数据库处理这一块，最终可能导致不可用。</p><p>那么，此时，加入缓存，比如商城首页有很多很多内容，这些内容不可能经常变化，至少也要两三天吧？所以，可以将这些数据放到redis中，用户进商城之后，数据直接从redis中获取即可。速度极快，提高了用户的体验。</p><p>既然是缓存，那么必定会存在数据不一致的情况，所以缓存最适合于读多写少的情况，当然啦，要修改缓存肯定是可以的，但是要注意热点key的问题，比如微博最火的一片新闻，此时有几百万人再看，你却要修改一下，肯定是要注意点什么东西才行的，后续的文章会讲到如何处理热点key修改的问题。</p><h2>三、Redis与其他key-value存储有什么不同</h2><p>这里先简单说说，后面会有文章详细比价一下。</p><ul><li>多样的数据结构和原子性操作</li></ul><p><code>Redis</code>有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。<code>redis</code>中的单个命令都是原子性的，什么是原子性，就是该命令不可分割。</p><ul><li>运行于内存+持久化于磁盘</li></ul><p><code>Redis</code>运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。另一个优点是， <strong>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样<code>Redis</code>可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</strong>。</p><p>注：我们要知道，对于磁盘的顺序访问速度是远大于随机访问的。这种在硬盘上顺序追加效率很高。</p><h2>四、redis特点</h2><ul><li><strong>速度快</strong>： 基于内存,这是快的最主要原因。</li><li><strong>持久化</strong>： 可以同步或异步保存到磁盘中</li><li><strong>多种数据结构</strong>： 除了五种基本数据类型，还支持位图、<code>HyperLogLog</code>，<code>GEO</code>等</li><li><strong>支持多种编程语言客户端</strong>： <code>java</code>，<code>python</code>，<code>ruby</code>，<code>Lua</code>…</li><li><strong>功能丰富</strong>： 可以实现发布-订阅，支持事务、<code>Lua</code>脚本</li><li><strong>简单</strong>： 不依赖与外部库、单线程模型</li><li><strong>主从复制</strong>： 主服务器同步数据到从服务器，是高可用的基础</li><li><strong>高可用、分布式</strong>： 高可用：<code>redis-Sentinel</code>(v2.8版本)；分布式：<code>redis-cluster</code>(v3.0版本)</li></ul><h2>五、redis典型应用场景</h2><ul><li><strong>缓存系统</strong>：这个就不多说了，<code>redis</code>作为高速缓存是其主要存在价值。</li><li><strong>计数器</strong>：因为是原子操作<code>incr</code>+单线程，作为计数器永远不会出错</li><li><strong>消息队列系统</strong>：数据结构<code>list</code>可以实现这种生产者-消费者模式的消息队列。</li><li><strong>排行榜</strong>：有序集合<code>sorted set</code>就可以实现</li><li><strong>社交网络</strong>：<code>redis</code>与社交网络就是一家，非常方便用<code>set</code>就能实现诸如共同好友这些功能。</li></ul><h2>六、redis优势</h2><ul><li><strong>缓存管理</strong>：可以在必要时将无效的旧数据从内存中删除，为新数据腾出新的空间</li><li><strong>提供更大的灵活性</strong>：<code>redis</code>支持多种类型，并且采用<code>key-value</code> 的形式存储，<code>key</code>和<code>value</code>的大小限制都是512Mb,与编码无关，所以数据安全。但是<code>memcached</code>限制<code>key</code>最大为250字节，<code>value</code>为1MB，况且只支持<code>String</code>类型。</li><li><strong><code>redis</code>提供主从复制</strong>：实现高可用的<code>cache</code>系统，支持集群中多个服务器之间的数据同步。</li><li><strong>数据持久化</strong>：<code>redis</code>可以通过两种方式将数据进行持久化，一定程度上规避缓存中的数据不稳定的问题，也可以在重启服务器时最快的恢复缓存中所需的数据，提高了效率的同时减轻了主数据库系统的开销。</li></ul><p>与传统的<code>Memcached</code>相比，优势还是很大的，两者的具体对比我会在后续的文章中详细说明。这里注意存在即合理，<code>Memcached</code>也有不可替代的适用场景：</p><ul><li>存储一些粒度比较小的静态数据，比如一些html片段，<code>Memcached</code>便是我们更好的选择。相对于<code>redis</code>而言，<code>Memcached</code>的元数据<code>metadata</code>更小些，所以相对来讲对于数据存储管理的性能更高，额外开销更小。</li><li><code>Memcached</code>的特点：<code>Memcached</code>唯一支持的数据类型是<code>String</code>,所以更适合存储只读数据，因为字符串并不会因为额外的处理造成额外的开销。毕竟<code>Memcached</code>每次更新一个对象时，都需要重复执行下面的操作：获取整个字符串-&gt;反序列化为对象-&gt;修改其中的值-&gt;再次序列化该对象-&gt;在缓存中将整个字符串替换为新字符串。这样一来，更新存储数据就会有更高的消耗，可能就不是我们的最佳选择了。</li></ul><h2>七、总结</h2><p>只要记住redis三个关键字：快、持久化、高可用和分布式</p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>地理位置附近查询的GEOHASH解决方案</title>
      <link href="/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>地理位置附近查询的GEOHASH解决方案</p><a id="more"></a><h2>1.需求场景</h2><p>现今互联网确实从方方面面影响我们的生活。现在我们可以足不出户就能买到我们心仪的衣服，找到附近的美食。当我们点开一个外卖的app就能看到自己附近的餐厅，那我们有没有想过这是怎么实现的呢？</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.png" alt="image"></p><h2>2.尝试解决</h2><ul><li>首先我们能想到的就是把所有餐厅的经纬度存下来</li><li>然后当用户选择附近餐厅时</li><li>我们先获取用户的经纬度，然后到数据库中查出所有的经纬度，依次计算它们和用户间的距离。</li><li>最后根据用户输入的距离范围过滤出合适的餐厅，并根据距离做一个升序排列。</li></ul><p>这样貌似能查出附近的餐厅，但是餐厅的数量这么多，直接全查出来内存也要爆掉，即使分批处理计算量也十分大。这样用户等待的时间就会特别长。那有什么办法能减少我们的计算量呢？</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%883.png" alt="image"></p><p>其实很简单，我们应该只计算用户关心的那一片数据，而不是计算所有的。例如用户在北京，那完全没必要计算海南，黑龙江，新疆，浙江等其它地区的数据。如果我们能快速定位到北京甚至某个区，那么我们的计算量将大大减少。我们发现这其实就是索引的功能，但是<code>MySQL</code>对这种二维的地理位置的索引支持并不友好（<code>mongodb</code>有直接的地理位置索引），它对一维的像字符串这样的支持很好。那如果我们的数据在MySQL中，有没有什么方法能将我们的二维坐标转换为一种可比较的字符串呢？这就是我们今天要介绍的<code>geohash</code>算法。</p><h2>3.基本思想</h2><p><strong><code>geohash</code>简单来说就是将一个地理坐标转换为一个可比较的字符串的算法。不过生成的字符串表示的是一个矩形的范围，并不是一个点。</strong></p><p>比如西二旗地铁附近这一片矩形区域就可以用<code>wx4eyu82</code>这个字符串表示，并且越靠前的编码表示额范围越大，比如中国绝大部分地区可以用w这个字母表示的矩形区域内。像<code>wx4eyu82</code>表示的区域一定在<code>wx4e</code>表示的区域范围内。利用这些特性我们就可以实现附近餐厅的功能了，比如我们希望查看西二旗地铁附近的餐厅就可以这样查询：<code>select * from table where geohash like 'wx4eyu82%';</code> 这样就可以利用索引，快速查询出相关餐厅的信息了。并且我们还可以用<code>wx4eyu82</code>为<code>key</code>，餐厅信息为<code>value</code>做缓存。</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882.png" alt="image"></p><p><strong>通过上面的介绍我们知道了<code>GeoHash</code>就是一种将经纬度转换成字符串的方法，并且使得在大部分情况下，字符串前缀匹配越多的距离越近.</strong></p><h2>4.GeoHash算法的步骤</h2><ul><li>首先我们将经度和纬度都单独转换为一个二进制编码</li><li>得到经度和纬度的二进制编码后，我们按照奇数位放纬度，偶数为放经度的规则（我们这里奇数偶数下标是从0开始）将它们合成一个二进制编码</li><li>最后我们需要将这个二进制编码转换为base32编码</li></ul><p><strong>举例</strong></p><ul><li>地球纬度区间是[-90,90]， 北海公园的纬度是39.928167，可以通过下面算法对纬度39.928167进行逼近编码:<ul><li>区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1；</li><li>接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0；</li><li>递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167；</li><li>如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，这样随着算法的进行会产生一个序列1011100，序列的长度跟给定的区间划分次数有关。</li></ul></li><li>通过上述计算，纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。</li><li>最后使用用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，首先将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。</li></ul><h2>5.缺陷-geohash的边界问题</h2><p>比如红色的点是我们的位置，绿色的两个点分别是附近的两个餐馆，但是在查询的时候会发现距离较远餐馆的<code>GeoHash</code>编码与我们一样（因为在同一个GeoHash区域块上），而较近餐馆的<code>GeoHash</code>编码与我们不一致。</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%884.png" alt="image"></p><p>目前比较通行的做法就是我们不仅获取当前我们所在的矩形区域，还获取周围8个矩形块中的点。那么怎样定位周围8个点呢？关键就是需要获取周围8个点的经纬度，那我们已经知道自己的经纬度，只需要用自己的经纬度减去最小划分单位的经纬度就行。因为我们知道经纬度的范围,又知道需要划分的次数，所以很容易就能计算出最小划分单位的经纬度。</p><h2>6.几种实现geohash方案的对比</h2><h4>6.1支持二维索引的存储数据库：mongodb</h4><p><code>mongoDB</code>支持二维空间索引,使用空间索引,<code>mongoDB</code>支持一种特殊查询,如某地图网站上可以查找离你最近的咖啡厅,银行等信息。这个使用<code>mongoDB</code>的空间索引结合特殊的查询方法很容易实现。</p><ul><li>API直接支持，很方便</li><li>支持按照距离排序，并支持分页。支持多条件筛选。</li><li>可满足实时性需求。</li><li>资源占用大，数据量达到百万级请流量在10w左右查询速度明显下降。</li></ul><h4>6.2升级Mysql至5.7，支持Geohash</h4><p><code>MySQL 5.7.5</code> 增加了对<code>GeoHash</code>的支持，提供了一系列<code>geohash</code>的函数，但是其实<code>Mysql</code>并没有提供类似<code>mogodb</code>类型<code>near</code>这样的函数，仅仅提供了一些经纬度转<code>hash</code>、<code>hash</code>取经纬度的一些函数。</p><ul><li>优点:函数直接调用，生成目标<code>hash</code>、根据<code>hash</code>获取经纬度。</li><li>缺点：不支持范围查询函数，需要自行处理周边8点的问题，需要补充<code>geo</code>的算法</li></ul><h4>6.3Redis Commands: Geography Edition</h4><p>GEO 特性在 Redis 3.2 版发布， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作，GEO通过如下命令来完成GEO需求.</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd</td><td>添加一个或多个经纬度地理位置</td></tr><tr><td>georadius</td><td>获取指定范围内的对象，也可以增加参数withdistance直接算出距离，也可以增加参数descending/ascending 进行距离排序</td></tr><tr><td>georadiusbymember</td><td>通过指定的对象，获取其周边对象</td></tr><tr><td>geoencode</td><td>转换为geohash，52-bit，同时返回该区域最小角的geohash,最大角的geohash，及中心点</td></tr><tr><td>geodecode</td><td>同上逆操作</td></tr></tbody></table><ul><li>优点:效率高，API丰富</li><li>缺点：3.2版本是否稳定？</li></ul><p>面试的时候，问到geohash算法以及技术选型大概也能说一说了…</p><p>本文章借鉴很多优秀文章，七拼八凑而出。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补码的前世今生</title>
      <link href="/2019/01/29/java-basic/%E8%A1%A5%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/01/29/java-basic/%E8%A1%A5%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      <content type="html"><![CDATA[<p>计算机如何来保存负数呢？其实只要达到这样的目的：正数负数都有一个唯一标识即可，但是，正如人类用+1和-1来表示可以提高效率一样，也得有一个比较适当的适合我们的计算机识别的一个方式。下面来详细讲解。</p><a id="more"></a><h2>问题的由来</h2><p>下面为了表示方便，先假设存储一个整型数字用4个bit。</p><p>举例来说，+2在计算机中表示为二进制的0010，那么-2怎么表示呢？</p><p>很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+2就是<code>0010</code>，而-8则是<code>1010</code>。</p><p>更多的例子如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic5-1.png" alt="image"></p><p>这就是直接用原码的方式来存储，虽然说这种方式理论上是可行的，毕竟每个数我都唯一标识了。</p><p>但是这种方式存在问题，我们希望+1和-1相加为0，但是通过这个方式算出来的是：0001+1001=1010 (-2)。也就是说，按照正常一步头的方式得不到我们想要的结果。</p><p>为了解决了“正负相加等于0”的问题，人们发明了反码。</p><h2>反码</h2><p>“反码”表示方式是用来处理负数的，符号位置不变，其余位置相反。</p><p><img src="http://bloghello.oursnail.cn/javabasic5-2.png" alt="image"></p><p>此时，我们再来算一下+1和-1相加，变成了0001+1110=1111，刚好反码表示方式中，1111象征-0。</p><p>此时，好像是解决了这个问题，但是我们发现，0这个时候有了两种表达：0000和1111。</p><p>即在用反码表示的情况下，0竟然可以用两个值来表示，这显然不好吧。毕竟+0和-0就是同一个玩意啊。</p><p>这个时候补码闪亮登场。</p><h2>补码</h2><p>很简单，在刚才反码的基础上加1。</p><p><img src="http://bloghello.oursnail.cn/javabasic5-3.png" alt="image"></p><p>此时，我们这里假定整形只有4位。那么-0表示为1111+1=10000，显然溢出了，就需要丢弃最高位，变成0000.</p><p>此时，神奇地发现，达到了统一，+0和-0都是用0000来表示了。</p><p>此时，也满足正负数相加为0的条件。比如+2为0010，-2为1110.此时两者相加为：0010+1110=(0)0000，丢掉最高位就是0000</p><p>那么对于普通情况，比如7+(-4)呢?即0111+1100=0011，就是3。OK，大功告成。</p><h2>补码怎么求</h2><p>上面已经说的很详细啦，比如-4，就是在4(0100)的基础上取反(1011)再加一(1100).</p><p>上面也解释了为什么要用补码。即保证了对称的正负数相加为0并且0只有一种表示方式。</p><p>还有一个重要的点就是，我们注意到，7-4其实我们都是转换成7+(-4)，也就是说，在计算机中，减法都是用加法的逻辑实现的。</p><p>即：一套加法的电路实现加减法。此外，乘法和除法其实都是加法这套电路实现的。</p><h2>补码的本质</h2><p>这里假设存储一个整型用8个bit。</p><p>要将正数转成对应的负数，其实只要用0减去这个数就可以了。比如，-8其实就是0-8。</p><p>则8的二进制是00001000，-8就可以用下面的式子求出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　００００００００</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br></pre></td></tr></table></figure><p>因为00000000（被减数）小于0000100（减数），所以不够减。请回忆一下小学算术，如果被减数的某一位小于减数，我们怎么办？很简单，问上一位借1就可以了。</p><p>所以，0000000也问上一位借了1，也就是说，被减数其实是100000000，算式也就改写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">１００００００００</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１１０００</span><br></pre></td></tr></table></figure><p>进一步观察，可以发现100000000 = 11111111 + 1，所以上面的式子可以拆成两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　１１１１１１１１</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１０１１１</span><br><span class="line">＋０００００００１</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１１０００</span><br></pre></td></tr></table></figure><p>通过这一步，我们就从数学上知道了为什么补码是取反加一了。</p><p>你看，求任何一个负数，都是0-正数，那么就用借位的思想来，则变成100000000。</p><p>100000000则可以分解为11111111+00000001。</p><p>此时求负数的过程就就变成11111111-X+1</p><ul><li>而先用11111111来减这个正数，这个结果就是对正数取反。</li><li>此时再加上另外一个1.</li></ul><p>这与我们求补码的过程是一样的，这也解释了为什么要这样求补码。</p><h2>证明(可不看)</h2><p>将上面的特例抽象一下，用统一表达式来证明一下。</p><p>我们要证明的是，X-Y或X+(-Y)可以用X加上Y的补码完成。</p><p>Y的补码等于(11111111-Y)+1。所以，X加上Y补码，就等于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + (11111111-Y) + 1</span><br></pre></td></tr></table></figure><p>我们假定这个算式的结果等于Z，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = X + (11111111-Y) + 1</span><br></pre></td></tr></table></figure><p>接下来，分成两种情况讨论。</p><ul><li>第一种情况，如果X小于Y，那么Z是一个负数。</li></ul><p>由Y的补码等于(11111111-Y)+1，标记为F=(11111111-Y)+1,那么如何根据F逆向求Y呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y=1111111-(F-1)</span><br></pre></td></tr></table></figure><p>OK,因为此时Z是一个负数，那么Z进行补码的逆运算就可以求出它的绝对值，即正数。再加一个符号，两者相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = -[11111111-(Z-1)] = -[11111111-(X + (11111111-Y) + 1-1)] = X - Y</span><br></pre></td></tr></table></figure><ul><li>第二种情况，如果X大于Y</li></ul><p>这意味着Z肯定大于11111111，但是我们规定了这是8位机，最高的第9位是溢出位，必须被舍去，这相当于减去100000000。所以，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = Z - 100000000 = X + (11111111-Y) + 1 - 100000000 = X - Y</span><br></pre></td></tr></table></figure><p>这就证明了，在正常的加法规则下，可以利用2的补码得到正数与负数相加的正确结果。换言之，计算机只要部署加法电路和补码电路，就可以完成所有整数的加法。</p><p>本文整理自：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="noopener">关于2的补码</a></li><li><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="noopener">知乎第一条评论</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot使用logback实现日志按天滚动</title>
      <link href="/2019/01/28/miscellany/11SpringBoot%E4%BD%BF%E7%94%A8logback%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%8C%89%E5%A4%A9%E6%BB%9A%E5%8A%A8/"/>
      <url>/2019/01/28/miscellany/11SpringBoot%E4%BD%BF%E7%94%A8logback%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%8C%89%E5%A4%A9%E6%BB%9A%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>日志是任何一个系统都必备的东西，日志的重要程度丝毫不亚于代码。而springboot中经常使用的是logback，那么今天我们就来学习一下在springboot下如何配置logback日志。理解了这里的配置，对于任何的日志都是一样的。</p><a id="more"></a><h2>需求</h2><ul><li>日志按天滚动分割</li><li><code>info</code>和<code>error</code>日志输出到不同文件</li></ul><h2>为什么使用Logback</h2><ul><li><code>Logback</code>是<code>Log4j</code>的升级版，作者为同一个人，作者不想再去改<code>Log4j</code>，所以写了<code>Logback</code></li><li>使用日志框架的最佳实践是选择一款日志门面+一款日志实现，这里选择<code>Slf4j</code>+<code>Logback</code>,<code>Slf4j</code>作者也是<code>Logback</code>的作者</li><li><code>SpringBoot</code>从1.4版本开始，内置的日志框架就是<code>Logback</code></li></ul><h2>Logback在SpringBoot中配置方式一</h2><p>可以直接在<code>applicatin.properties</code>或者<code>application.yml</code>中配置</p><p>以在<code>application.yml</code>中配置为例</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  pattern:</span></span><br><span class="line"><span class="attr">    console:</span> <span class="string">"%d - %msg%n"</span></span><br><span class="line"><span class="attr">  file:</span> <span class="string">/var/log/tomcat/sell.log</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">com.imooc.LoggerTest:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>可以发现，这种配置方式简单，但能实现的功能也很局限，只能</p><ul><li>定制输出格式</li><li>输出文件的路径</li><li>指定某个包下的日志级别</li></ul><p>如果需要完成我们的需求，这就得用第二种配置了</p><h2>Logback在SpringBoot中配置方式二</h2><p>在<code>resource</code>目录下新建<code>logback-spring.xml</code>, 内容如下</p><?xml version="1.0" encoding="UTF-8" ?><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打印到控制台的格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"consoleLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--除了error级别的日志文件保存格式以及滚动策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileInfoLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--过滤器，将error级别过滤掉--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/var/log/tomcat/sell/info.%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--error级别日志文件保存格式以及滚动策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileErrorLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只让error级别的日志进来--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/var/log/tomcat/sell/error.%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileInfoLog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileErrorLog"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个<code>appender</code>你可以理解为一个日志处理策略。</p><p>第一个<code>appender</code>的<code>name=&quot;consoleLog&quot;</code>,</p><p>名字是自己随意取的，取这个名字，表示这个策略用于控制台的日志。</p><p>我们重点看第二个和第三个<code>appender</code>,因为要把<code>info</code>和<code>error</code>日志输入到不同文件，所以我们分别建了两个<code>appender</code>。</p><p><code>rollingPolicy</code>是滚动策略，这里我们设置按时间滚动</p><p><code>filter</code>是日志的过滤方式，我们在<code>fileInfoLog</code>里做了如下过滤</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码翻译之后：拦截<code>ERROR</code>级别的日志。如果匹配到了，则禁用处理。如果不匹配，则接受，开始处理日志。</p><p>那有的同学要问了，不能这样写吗</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样不是只拦截<code>INFO</code>日志了吗？</p><p>不对！</p><p>这就得说一下日志级别了</p><p><code>DEBUG</code> -&gt;<code>INFO</code> -&gt; <code>WARN</code> -&gt;<code>ERROR</code></p><p>如果你设置的日志级别是<code>INFO</code>，那么是会拦截<code>ERROR</code>日志的哦。也就是说，如果直接写<code>info</code>，那么大于等于<code>info</code>级别的日志都会写进去，违背了我们的需求。</p><p>整理自：</p><ul><li><a href="http://www.imooc.com/article/19005" target="_blank" rel="noopener">http://www.imooc.com/article/19005</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql面试高频理论知识</title>
      <link href="/2019/01/27/mysql/mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/01/27/mysql/mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>整理一些面试题，简单看看。</p><a id="more"></a><p>目录</p><ol><li>数据库三范式</li><li>事务</li><li>mysql数据库默认最大连接数</li><li>分页</li><li>触发器</li><li>存储过程</li><li>用jdbc怎么调用存储过程？</li><li>对jdbc的理解</li><li>写一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序</li><li>JDBC中的PreparedStatement相比Statement的好处</li><li>数据库连接池作用</li><li>选择合适的存储引擎</li><li>数据库优化-索引</li><li>数据库优化-分表</li><li>数据库优化-读写分离</li><li>数据库优化-缓存</li><li>数据库优化-sql语句优化的技巧</li><li>jdbc批量插入几百万数据怎么实现</li><li>聚簇索引和非聚簇索引</li><li>sql注入问题</li><li>mysql悲观锁和乐观锁</li></ol><h2>1. 数据库三范式</h2><h3>1.1 范式是什么</h3><p>范式就是规范，要满足第二范式必须先满足第一范式，要满足第三范式，必须要先满足第二范式。</p><ul><li>1NF(第一范式)：列数据不可分割，即一列不能有多个值</li><li>2NF(第二范式)：主键(每一行都有唯一标识)</li><li>3NF(第三范式)：外键(表中不包含已在其他表中包含的非主关键信息)</li></ul><h3>1.2 反三范式</h3><p>反三范式：有时为了效率，可以设置重复或者推导出的字段，例如：订单总价格订单项的单价，这个订单总价虽然可以由订单项计算出来，但是当订单数目庞大时，效率比较低，所以订单的总价这个字段是必要的。</p><h2>2. 事务</h2><h3>2.1 含义</h3><p>事务时并发控制的单位，是用户定义的一个操作序列，要么都做，要么都不做，是不可分割的工作单位。</p><h3>2.2 事务的四个特征(ACID特性)</h3><ul><li>原子性：表示事务内操作不可分割</li><li>一致性：要么成功，要么失败，若后面失败，前面则回滚</li><li>隔离性：一个事务开始了，不被其他事务干扰</li><li>持久性：事务开始了，就不能突然终止</li></ul><h2>3. mysql数据库默认最大连接数</h2><h3>3.1 为什么需要最大连接数</h3><p>特定服务器上的数据库只能支持一定数目同时连接，这时需要我们设置最大连接数（最多同时服务多少连接）。在数据库安装时会有一个默认的最大连接数。</p><blockquote><p><code>my.ini</code>中<code>max_connections=100</code></p></blockquote><h2>4. 分页</h2><h3>4.1 为什么需要分页？</h3><p>在很多数据时，不可能完全显示数据。进行分段显示.</p><h3>4.2 mysql如何分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = </span><br><span class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="string">" + pageSize*(pageNumber-1) + "</span>,<span class="string">" + pageSize;</span></span><br></pre></td></tr></table></figure><h3>4.3 oracle分页</h3><p>是使用了三层嵌套查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = </span><br><span class="line"> &quot;select * from &quot; +  </span><br><span class="line"> (select *,rownum rid from (select * from students order by postime desc) where rid&lt;=&quot; + pagesize*pagenumber + &quot;) as t&quot; + </span><br><span class="line"> &quot;where t&gt;&quot; + pageSize*(pageNumber-1);</span><br></pre></td></tr></table></figure><h2>5. 触发器</h2><p>略。</p><h2>6. 存储过程</h2><h3>6.1 数据库存储过程具有如下优点：</h3><ul><li><p>1、存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。</p></li><li><p>2、通常，复杂的业务逻辑需要多条 SQL 语句。这些语句要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会大大减少，降低了网络负载。</p></li><li><p>3、存储过程创建一次便可以重复使用，从而可以减少数据库开发人员的工作量。</p></li><li><p>4、安全性高，存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，无需拥有访问底层数据库对象的显式权限。</p></li></ul><h3>6.2 定义存储过程:</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_Student (_name <span class="built_in">varchar</span>(<span class="number">50</span>),_age <span class="built_in">int</span> ,<span class="keyword">out</span> _id <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span>(<span class="literal">null</span>,_name,_age);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(stuId) <span class="keyword">into</span> _id <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> insert_Student(<span class="string">'wfz'</span>,<span class="number">23</span>,@<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><h2>7. 用jdbc怎么调用存储过程？</h2><blockquote><p>贾琏欲执事</p></blockquote><ul><li>加载驱动</li><li>获取连接</li><li>设置参数</li><li>执行</li><li>释放连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Connection cn = <span class="keyword">null</span>;</span><br><span class="line">CallableStatement cstmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里最好不要这么干，因为驱动名写死在程序中了</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//实际项目中，这里应用DataSource数据，如果用框架，</span></span><br><span class="line"><span class="comment">//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()</span></span><br><span class="line"><span class="comment">//cn = ds.getConnection();</span></span><br><span class="line">cn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///test"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">cstmt = cn.prepareCall(<span class="string">"&#123;call insert_Student(?,?,?)&#125;"</span>);</span><br><span class="line">cstmt.registerOutParameter(<span class="number">3</span>,Types.INTEGER);</span><br><span class="line">cstmt.setString(<span class="number">1</span>, <span class="string">"wangwu"</span>);</span><br><span class="line">cstmt.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">cstmt.execute();</span><br><span class="line"><span class="comment">//get第几个，不同的数据库不一样，建议不写</span></span><br><span class="line">System.out.println(cstmt.getString(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*try&#123;cstmt.close();&#125;catch(Exception e)&#123;&#125;</span></span><br><span class="line"><span class="comment">try&#123;cn.close();&#125;catch(Exception e)&#123;&#125;*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(cstmt != <span class="keyword">null</span>)</span><br><span class="line">cstmt.close();</span><br><span class="line"><span class="keyword">if</span>(cn != <span class="keyword">null</span>)</span><br><span class="line">cn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>8. 对jdbc的理解</h2><p><code>Java database connection</code> java数据库连接.数据库管理系统(<code>mysql</code> <code>oracle</code>等)是很多，每个数据库管理系统支持的命令是不一样的。</p><p>Java只定义接口，让数据库厂商自己实现接口，对于我们者而言。只需要导入对应厂商开发的实现即可。然后以接口方式进行调用.(<code>mysql</code> + <code>mysql</code>驱动（实现）+<code>jdbc</code>)</p><h2>9. 写一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序</h2><blockquote><p>贾琏欲执事</p></blockquote><ol><li>加载驱动(<code>com.mysql.jdbc.Driver,oracle.jdbc.driver.OracleDriver</code>)</li><li>取连接(<code>DriverManager.getConnection(url,usernam,passord)</code>)</li><li>设置参数  <code>Statement PreparedStatement</code><br><code>cstmt.setXXX(index, value);</code></li><li>执行   <code>executeQuery executeUpdate</code></li><li>释放连接(是否连接要从小到大，必须放到<code>finnaly</code>)</li></ol><h2>10. JDBC中的PreparedStatement相比Statement的好处</h2><p><strong>大多数我们都使用<code>PreparedStatement</code>代替<code>Statement</code></strong></p><ul><li>1：<code>PreparedStatement</code>是预编译的，比<code>Statement</code>速度快</li><li>2：代码的可读性和可维护性</li></ul><p>虽然用<code>PreparedStatement</code>来代替<code>Statement</code>会使代码多出几行,但这样的代码无论从可读性还是可维护性上来说.都比直接用<code>Statement</code>的代码高很多档次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeUpdate(<span class="string">"insert into tb_name (col1,col2,col2,col4) values</span></span><br><span class="line"><span class="string">('"</span>+var1+<span class="string">"','"</span>+var2+<span class="string">"',"</span>+var3+<span class="string">",'"</span>+var4+<span class="string">"')"</span>); </span><br><span class="line"></span><br><span class="line">perstmt = con.prepareStatement(<span class="string">"insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)"</span>);</span><br><span class="line">perstmt.setString(<span class="number">1</span>,var1);</span><br><span class="line">perstmt.setString(<span class="number">2</span>,var2);</span><br><span class="line">perstmt.setString(<span class="number">3</span>,var3);</span><br><span class="line">perstmt.setString(<span class="number">4</span>,var4);</span><br><span class="line">perstmt.executeUpdate();</span><br></pre></td></tr></table></figure><ul><li>3：安全性</li></ul><p><code>PreparedStatement</code>可以防止<code>SQL</code>注入攻击，而<code>Statement</code>却不能。</p><p>比如说：</p><blockquote><p>String sql = “select * from tb_name where name= '”+varname+&quot;’ and passwd=’&quot;+varpasswd+&quot;’&quot;;</p></blockquote><p>如果我们把<code>[' or '1' = '1]</code>作为varpasswd传入进来.用户名随意,看看会成为什么?</p><blockquote><p>select * from tb_name = ‘随意’ and passwd = ‘’ or ‘1’ = ‘1’;</p></blockquote><p>因为<code>'1'='1'</code>肯定成立，所以可以任何通过验证。</p><p>更有甚者：把<code>[';drop table tb_name;]</code>作为<code>varpasswd</code>传入进来,则：</p><blockquote><p>select * from tb_name = ‘随意’ and passwd = ‘’;drop table tb_name;</p></blockquote><p>有些数据库是不会让你成功的，但也有很多数据库就可以使这些语句得到执行。</p><p>而如果你使用预编译语句你传入的任何内容就不会和原来的语句发生任何匹配的关系，只要全使用预编译语句你就用不着对传入的数据做任何过虑。而如果使用普通的<code>statement</code>,有可能要对<code>drop</code>等做费尽心机的判断和过虑。</p><h2>11. 数据库连接池作用</h2><ul><li>1、限定数据库的个数，不会导致由于数据库连接过多导致系统运行缓慢或崩溃</li><li>2、数据库连接不需要每次都去创建或销毁，节约了资源</li><li>3、数据库连接不需要每次都去创建，响应时间更快。</li></ul><h2>12. 选择合适的存储引擎</h2><p>在开发中，我们经常使用的存储引擎 <code>myisam</code> / <code>innodb</code>/ <code>memory</code></p><blockquote><p>MyISAM存储引擎</p></blockquote><p>如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. 比如 bbs 中的 发帖表，回复表.</p><blockquote><p>INNODB存储引擎:</p></blockquote><p>对事务要求高，保存的数据都是重要数据，我们建议使用<code>INNODB</code>,比如订单表，账号表.</p><blockquote><p>Memory 存储</p></blockquote><p>我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用<code>memory</code>, 速度极快.</p><p><code>MyISAM</code> 和 <code>INNODB</code>的区别(主要)</p><ol><li>事务安全 <code>myisam</code>不支持事务而<code>innodb</code>支持</li><li>查询和添加速度 <code>myisam</code>不用支持事务就不用考虑同步锁，查找和添加和添加的速度快</li><li>支持全文索引 <code>myisam</code>支持<code>innodb</code>不支持</li><li>锁机制 <code>myisam</code>支持表锁而<code>innodb</code>支持行锁(事务)</li><li>外键 <code>MyISAM</code> 不支持外键， <code>INNODB</code>支持外键. (通常不设置外键，通常是在程序中保证数据的一致)</li></ol><hr><h1>下面是数据库的优化手段，但是只是表面，需要以后再好好探究</h1><p>在项目自验项目转测试之前，在启动<code>mysql</code>数据库时开启慢查询，并且把执行慢的语句写到日志中，在运行一定时间后。通过查看日志找到慢查询语句。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">show variables like '%slow%';   #查看MySQL慢查询是否开启</span><br><span class="line"></span><br><span class="line">set global slow_query_log=ON;   #开启MySQL慢查询功能</span><br><span class="line"></span><br><span class="line">show variables like "long_query_time";  #查看MySQL慢查询时间设置，默认10秒</span><br><span class="line"></span><br><span class="line">set global long_query_time=5;  #修改为记录5秒内的查询</span><br><span class="line"></span><br><span class="line">select sleep(6);  #测试MySQL慢查询</span><br><span class="line"></span><br><span class="line">show variables like "%slow%";  #查看MySQL慢查询日志路径</span><br><span class="line"></span><br><span class="line">show global status like '%slow%';  #查看MySQL慢查询状态</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">vi  /etc/my.cnf  #编辑，在[mysqld]段添加以下代码</span><br><span class="line"></span><br><span class="line">slow-query-log = on  #开启MySQL慢查询功能</span><br><span class="line"></span><br><span class="line">slow_query_log_file =  /var/run/mysqld/mysqld-slow.log #设置MySQL慢查询日志路径</span><br><span class="line"></span><br><span class="line">long_query_time = 5  #修改为记录5秒内的查询，默认不设置此参数为记录10秒内的查询</span><br><span class="line"></span><br><span class="line">log-queries-not-using-indexes = on  #记录未使用索引的查询</span><br><span class="line"></span><br><span class="line">:wq! #保存退出</span><br><span class="line"></span><br><span class="line">service mysqld restart #重启MySQL服务</span><br></pre></td></tr></table></figure><h2>13. 数据库优化-索引</h2><h3>13.1 索引的概念</h3><p>索引（<code>Index</code>）是帮助<code>DBMS</code>高效获取数据的数据结构。</p><h3>13.2 索引有哪些</h3><blockquote><p>分类：普通索引/唯一索引/主键索引/全文索引</p></blockquote><ul><li><p>普通索引:允许重复的值出现</p></li><li><p>唯一索引:除了不能有重复的记录外，其它和普通索引一样(用户名、用户身份证、email,tel)</p></li><li><p>主键索引：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会給改列创建索引。这就是主键索引.唯一且没有null值</p></li><li><p>全文索引:用来对表中的文本域(<code>char</code>，<code>varchar</code>，<code>text</code>)进行索引， 全文索引针对<code>MyIsam</code><br><code>explain select * from articles where match(title,body) against(‘database’);</code>【会使用全文索引】</p></li></ul><h3>13.3 使用索引的注意事项</h3><blockquote><p>索引弊端</p></blockquote><ol><li>占用磁盘空间。</li><li>对<code>dml</code>(插入、修改、删除)操作有影响，变慢。</li></ol><blockquote><p>使用场景：</p></blockquote><ol><li>肯定在<code>where</code>条件经常使用,如果不做查询就没有意义</li><li>该字段的内容不是唯一的几个值(sex)</li><li>字段内容不是频繁变化.</li></ol><blockquote><p>注意事项</p></blockquote><ol><li>对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept <span class="keyword">add</span> <span class="keyword">index</span> my_ind (dname,loc); // dname 左边的列,loc就是右边的列</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=<span class="string">'aaa'</span>\G 会使用到索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> loc=<span class="string">'aaa'</span>\G 就不会使用到索引</span><br></pre></td></tr></table></figure><ol start="2"><li>对于使用<code>like</code>的查询，查询如果是<code>%aaa</code>不会使用到索引而<code>aaa%</code>会使用到索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="keyword">like</span> <span class="string">'%aaa'</span>\G不能使用索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="keyword">like</span> <span class="string">'aaa%'</span>\G使用索引.</span><br></pre></td></tr></table></figure><p>所以在<code>like</code>查询时，‘关键字’的最前面不能使用<code>%</code> 或者 <code>_</code>这样的字符，如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p><ol start="3"><li>索引列排序</li></ol><p><code>MySQL</code>查询只使用一个索引，因此如果<code>where</code>子句中已经使用了索引的话，那么<code>order by</code>中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><ol start="4"><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=’<span class="number">111</span>’;</span><br><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=<span class="number">111</span>;（数值自动转字符串）</span><br><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=qqq;报错</span><br></pre></td></tr></table></figure><p>也就是，如果列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来.</p><ol start="5"><li><p>如果<code>mysql</code>估计使用全表扫描要比使用索引快，则不使用索引。<br>表里面只有一条记录</p></li><li><p>索引不会包含有<code>NULL</code>值的列</p></li></ol><p>只要列中包含有<code>NULL</code>值都将不会被包含在<code>MySQL</code>索引中，复合索引中只要有一列含有<code>NULL</code>值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为<code>NULL</code>。</p><ol start="7"><li>使用短索引</li></ol><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个<code>CHAR(255)</code>的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p><ol start="8"><li>不要在列上进行运算，不使用<code>NOT IN</code>和<code>&lt;&gt;</code>操作，不支持正则表达式。</li></ol><h2>14. 数据库优化-分表</h2><p>分表分为水平(按行)分表和垂直(按列)分表</p><p><strong>水平分表情形：</strong></p><p>根据经验，<code>Mysql</code>表数据一般达到百万级别，查询效率会很低，容易造成表锁，甚至堆积很多连接，直接挂掉；水平分表能够很大程度较少这些压力。</p><p><strong>垂直分表情形：</strong></p><p>如果一张表中某个字段值非常多(长文本、二进制等)，而且只有在很少的情况下会查询。这时候就可以把字段多个单独放到一个表，通过外键关联起来。考试详情，一般我们只关注分数，不关注详情。</p><p><strong>水平分表策略：</strong></p><blockquote><p>1.按时间分表</p></blockquote><p>这种分表方式有一定的局限性，当数据有较强的实效性，如微博发送记录、微信消息记录等，这种数据很少有用户会查询几个月前的数据，如需要就可以按月分表。</p><blockquote><p>2.按区间范围分表</p></blockquote><p>一般在有严格的自增id需求上，如按照<code>user_id</code>水平分表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table_1  user_id从1~100w  </span><br><span class="line">table_2  user_id从101~200w </span><br><span class="line">table_3  user_id从201~300w</span><br></pre></td></tr></table></figure><blockquote><p>3.hash分表</p></blockquote><p>通过一个原始目标的ID或者名称通过一定的<code>hash</code>算法计算出数据存储表的表名，然后访问相应的表。</p><h2>15. 数据库优化-读写分离</h2><p>一台数据库支持的最大并发连接数是有限的，如果用户并发访问太多。一台服务器满足不要要求是就可以集群处理。Mysql的集群处理技术最常用的就是读写分离。</p><p><strong>主从同步</strong></p><p>数据库最终会把数据持久化到磁盘，如果集群必须确保每个数据库服务器的数据是一直的。<strong>能改变数据库数据的操作都往主数据库去写，而其他的数据库从主数据库上同步数据。</strong></p><p><strong>读写分离</strong></p><p>使用负载均衡来实现写的操作都往主数据去，而读的操作往从服务器去。</p><h2>16. 数据库优化-缓存</h2><p><strong>什么是缓存</strong></p><p>在持久层(<code>dao</code>)和数据库(<code>db</code>)之间添加一个缓存层，如果用户访问的数据已经缓存起来时，在用户访问时直接从缓存中获取，不用访问数据库。而缓存是在操作内存级，访问速度快。</p><p><strong>作用</strong></p><p>减少数据库服务器压力，减少访问时间。</p><p><strong>Java中常用的缓存有</strong></p><ol><li><code>hibernate</code>的二级缓存。该缓存不能完成分布式缓存。</li><li>可以使用<code>redis</code>(<code>memcahe</code>等)来作为中央缓存。对缓存的数据进行集中处理</li></ol><h2>17. 数据库优化-sql语句优化的技巧</h2><h3>DDL优化</h3><ol><li>通过禁用索引来提供导入数据性能，这个操作主要针对现有数据库的表追加数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//去除键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test3 <span class="keyword">DISABLE</span> <span class="keyword">keys</span>;</span><br><span class="line">//批量插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test3 ***</span><br><span class="line">//恢复键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test3 <span class="keyword">ENABLE</span> <span class="keyword">keys</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>关闭唯一校验</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> unique_checks=<span class="number">0</span>  关闭</span><br><span class="line"><span class="keyword">set</span> unique_checks=<span class="number">1</span>  开启</span><br></pre></td></tr></table></figure><ol start="3"><li>修改事务提交方式(导入)（变多次提交为一次）</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>   关闭</span><br><span class="line">//批量插入</span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">1</span>   开启</span><br></pre></td></tr></table></figure><h3>DML优化（变多次提交为一次）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">//合并多条为一条</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3>DQL优化</h3><blockquote><p>Order by优化</p></blockquote><ol><li>多用索引排序</li><li>普通结果排序（非索引排序）Filesort</li></ol><blockquote><p>group by优化</p></blockquote><p>使用order by null,取消默认排序</p><p>等等等等…</p><h2>18. jdbc批量插入几百万数据怎么实现</h2><p>1、变多次提交为一次<br>2、使用批量操作<br>3、像这样的批量插入操作能不使用代码操作就不使用，可以使用存储过程来实现</p><p><img src="http://p376695fl.bkt.clouddn.com/jdbc%E6%8F%92%E5%85%A5%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96.png" alt="image"></p><h2>mysql优化手段介绍到这里。</h2><h2>19. 聚簇索引和非聚簇索引</h2><p>索引分为聚簇索引和非聚簇索引。</p><p><strong>“聚簇索引”</strong></p><p>以一本英文课本为例，要找第8课，直接翻书，若先翻到第5课，则往后翻，再翻到第10课，则又往前翻。这本书本身就是一个索引，即“聚簇索引”。</p><p><strong>“非聚簇索引”</strong></p><p>如果要找&quot;fire”这个单词，会翻到书后面的附录，这个附录是按字母排序的，找到F字母那一块，再找到&quot;fire”，对应的会是它在第几课。这个附录，为“非聚簇索引”。</p><p>由此可见，聚簇索引，索引的顺序就是数据存放的顺序，所以，很容易理解，一张数据表只能有一个聚簇索引。</p><p>聚簇索引要比非聚簇索引查询效率高很多，特别是范围查询的时候。所以，至于聚簇索引到底应该为主键，还是其他字段，这个可以再讨论。</p><h3>1、MYSQL的索引</h3><p>mysql中，不同的存储引擎对索引的实现方式不同，大致说下<code>MyISAM</code>和<code>InnoDB</code>两种存储引擎。</p><p><strong>MyISAM存储引擎的索引实现</strong></p><p><code>MyISAM</code>的<code>B+Tree</code>的叶子节点上的<code>data</code>，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。<br>MyISAM还采用压缩机制存储索引，比如，第一个索引为“her”，第二个索引为“here”，那么第二个索引会被存储为“3,e”，这样的缺点是同一个节点中的索引只能采用顺序查找。</p><p><strong>InnoDB存储引擎的索引实现</strong></p><p><code>InnoDB</code> 的数据文件本身就是索引文件，<code>B+Tree</code>的叶子节点上的<code>data</code>就是数据本身，<code>key</code>为主键，这是聚簇索引。非聚簇索引，叶子节点上的data是主键 (所以聚簇索引的<code>key</code>，不能过长)。为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证。<br>至于为什么主键通常建议使用自增id呢？</p><h3>2.聚簇索引</h3><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p><p>聚簇索引不但在检索上可以大大滴提高效率，在数据读取上也一样。比如：需要查询f~t的所有单词。</p><p>一个使用<code>MyISAM</code>的主索引，一个使用<code>InnoDB</code>的聚簇索引。两种索引的<code>B+Tree</code>检索时间一样，但读取时却有了差异。</p><p><strong>因为<code>MyISAM</code>的主索引并非聚簇索引</strong>，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。</p><p><strong>不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是<code>MyISAM</code>占优势些，因为索引所占空间小，这些操作是需要在内存中完成的</strong>。</p><p>鉴于聚簇索引的范围查询效率，很多人认为使用主键作为聚簇索引太多浪费，毕竟几乎不会使用主键进行范围查询。但若再考虑到聚簇索引的存储，就不好定论了。</p><h2>20. sql注入问题</h2><h3>20.1 什么是sql注入</h3><p>sql注入大家都不陌生，是一种常见的攻击方式，攻击者在界面的表单信息或url上输入一些奇怪的sql片段，例如“or ‘1’=’1’”这样的语句，有可能入侵参数校验不足的应用程序。所以在我们的应用中需要做一些工作，来防备这样的攻击方式。在一些安全性很高的应用中，比如银行软件，经常使用将sql语句全部替换为存储过程这样的方式，来防止sql注入，这当然是一种很安全的方式，但我们平时开发中，可能不需要这种死板的方式。</p><h3>20.2 PrepareStatement解决SQL注入的问题</h3><p>在使用<code>JDBC</code>的过程中，可以使用<code>PrepareStatement</code>进行预处理，预处理的优势就是预防绝大多数的SQL注入；而且针对多次操作数据库的情况，可以极大的提高访问数据库的效率。</p><p>那为什么它这样处理就能预防SQL注入提高安全性呢？其实是因为SQL语句在程序运行前已经进行了预编译。在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库以参数化的形式进行查询。当运行时动态地把参数传给<code>PreprareStatement</code>时，即使参数里有敏感字符如 or ‘1=1’，数据库也会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令。如此，就起到了SQL注入的作用了！</p><h3>20.3 MyBatis如何防止sql注入</h3><p><code>mybatis</code>框架作为一款半自动化的持久层框架，其sql语句都要我们自己来手动编写，这个时候当然需要防止sql注入。其实<code>Mybatis</code>的sql是一个具有“输入+输出”功能，类似于函数的结构，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=“getBlogById“ resultType=“Blog“ parameterType=”int”&gt;</span><br><span class="line">       <span class="keyword">select</span> <span class="keyword">id</span>,title,author,<span class="keyword">content</span> </span><br><span class="line">　　　　<span class="keyword">from</span> blog </span><br><span class="line">　　　　<span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125; </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>这里，<code>parameterType</code>标示了输入的参数类型，<code>resultType</code>标示了输出的参数类型。回应上文，如果我们想防止sql注入，理所当然地要在输入参数上下功夫。上面代码中“#{id}”即输入参数在sql中拼接的部分，传入参数后，打印出执行的sql语句，会看到sql是这样的：</p><blockquote><p>select id,title,author,content from blog where id = ?</p></blockquote><p>不管输入什么参数，打印出的sql都是这样的。这是因为<code>mybatis</code>启用了预编译功能，在sql执行前，会先将上面的sql发送给数据库进行编译，执行时，直接使用编译好的sql，替换占位符“？”就可以了。因为sql注入只能对编译过程起作用，所以这样的方式就很好地避免了sql注入的问题。</p><p><code>mybatis</code>是如何做到sql预编译的呢？其实在框架底层，是<code>jdbc</code>中的<code>PreparedStatement</code>类在起作用，<code>PreparedStatement</code>是我们很熟悉的<code>Statement</code>的子类，它的对象包含了编译好的sql语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行一个sql时，能够提高效率，原因是sql已编译好，再次执行时无需再编译。</p><p>补充</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=“orderBlog“ resultType=“Blog“ parameterType=”map”&gt;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">select</span> <span class="keyword">id</span>,title,author,<span class="keyword">content</span> <span class="keyword">from</span> blog <span class="keyword">order</span> <span class="keyword">by</span> $&#123;orderParam&#125;</span><br><span class="line"> </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>仔细观察，内联参数的格式由“#{xxx}”变为了${xxx}。如果我们给参数“orderParam”赋值为”id”,将sql打印出来，是这样的：</p><blockquote><p>select id,title,author,content from blog order by id</p></blockquote><p>显然，这样是无法阻止sql注入的。在mybatis中，”${xxx}”这样格式的参数会直接参与sql编译，从而不能避免注入攻击。<strong>但涉及到动态表名和列名时，只能使用“${xxx}”这样的参数格式</strong>，所以，这样的参数需要我们在代码中手工进行处理来防止注入。</p><h2>21. mysql悲观锁和乐观锁</h2><h2>21.1 悲观锁</h2><p>悲观锁（<code>Pessimistic Lock</code>），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p><p><code>Java synchronized</code> 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p><h2>21.2 乐观锁</h2><p>乐观锁（<code>Optimistic Lock</code>），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p><p>乐观锁一般来说有以下2种方式：</p><ul><li>使用数据版本（<code>Version</code>）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 <code>version</code> 字段来实现。当读取数据时，将<code>version</code>字段的值一同读出，数据每更新一次，对此<code>version</code>值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的<code>version</code>值进行比对，如果数据库表当前版本号与第一次取出来的<code>version</code>值相等，则予以更新，否则认为是过期数据。</li><li>使用时间戳（<code>timestamp</code>）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（<code>timestamp</code>）, 和上面的<code>version</code>类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。<br><code>Java JUC</code>中的<code>atomic</code>包就是乐观锁的一种实现，<code>AtomicInteger</code> 通过<code>CAS</code>（<code>Compare And Set</code>）操作实现线程安全的自增。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复杂查询基础</title>
      <link href="/2019/01/27/mysql/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/01/27/mysql/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>这一节从group by和having两个关键语法入手，学习一下写sql的基本思路。</p><a id="more"></a><p>数据库准备：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`student`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`student_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">8</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- student表数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'lilei'</span>, <span class="string">'19'</span>, <span class="string">'female'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'huangmeimei'</span>, <span class="string">'18'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'pollu'</span>, <span class="string">'17'</span>, <span class="string">'female'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'tom'</span>, <span class="string">'18'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'david'</span>, <span class="string">'17'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'lucy'</span>, <span class="string">'19'</span>, <span class="string">'female'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'7'</span>, <span class="string">'jacky'</span>, <span class="string">'20'</span>, <span class="string">'male'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 课程表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`course`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`course_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- course表数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'chinese'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'math'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'english'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'physics'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 分数表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`score`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`score`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- score表数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'78'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'2'</span>, <span class="string">'81'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'92'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="string">'47'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'3'</span>, <span class="string">'88'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'88'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="string">'90'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'78'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'2'</span>, <span class="string">'68'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'2'</span>, <span class="string">'72'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'72'</span>);</span><br></pre></td></tr></table></figure><h2>第一个问题</h2><blockquote><p>查询所有同学的学号、选课数、总成绩</p></blockquote><p>针对sql问题，不需要一口气全部写出来，我们先分解逐个击破，最后再合体。</p><p>分析题目，他要查询的是每个学生的学号，选课数，总成绩</p><p>那么先把关键字列出来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#首先是要查询，肯定有select关键字</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">#要查询的几个关键字段</span><br><span class="line">student_id,<span class="keyword">count</span>(course_id),<span class="keyword">sum</span>(score)</span><br></pre></td></tr></table></figure><p>我们看到，有一些函数在里面，比如<code>count</code>和<code>sum</code>，那么我们会想到一般情况下是与<code>group by</code>结合使用的。</p><p>因为是查询每个学生，那么必然是根据每个学生的id进行分组了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group by student_id</span><br></pre></td></tr></table></figure><p>此时，因为涉及的<code>student_id</code>,<code>course_id</code>以及<code>score</code>只需要一张<code>score</code>表就可以解决,那么拼接起来就是：</p><p><img src="http://bloghello.oursnail.cn/mysql10-0.png" alt="image"></p><p>我们进行<code>explain</code>分析一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">SELECT</span> student_id,<span class="keyword">count</span>(course_id),<span class="keyword">sum</span>(score)</span><br><span class="line"><span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br></pre></td></tr></table></figure><p>显示：</p><p><img src="http://bloghello.oursnail.cn/mysql10-4.png" alt="image"></p><p>基本的原理就是：首先根据<code>group by</code>进行分组，分组出来的数据缓存到一张临时表中，然后再做<code>count</code>之类的计算显示。</p><p>并且，本题是针对一张表，所以有一个规则是：如果用<code>group by</code>，那么你的<code>select</code>语句中选出的列要么是<code>group by</code>里用到的列，要么就是<code>sum</code> <code>min</code>等列函数的列。所以这里<code>group by</code>和后面是<code>student_id</code>，所以<code>select</code>后面可以查询<code>student_id</code>，但是不能查询<code>course_id</code>等字段。</p><h2>第二个问题</h2><blockquote><p>查询所有同学的学号、姓名、选课数、总成绩</p></blockquote><p>注意观察，其实就是比上一个问题多一个字段<code>name</code>，但是区别比较大，因为一张<code>score</code>表已经不够用了。这个时候还需要<code>student</code>表了，即两张表联合查询。那么只要搞一个连接条件即可：</p><p><img src="http://bloghello.oursnail.cn/mysql10-1.png" alt="image"></p><h2>第三个问题</h2><blockquote><p>查询平均成绩大于60分的同学的学号和平均成绩</p></blockquote><p>我们再来分解看看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询肯定用到select</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">#要查询的两个字段</span><br><span class="line">student_id,<span class="keyword">avg</span>(score) </span><br><span class="line"></span><br><span class="line">#由于存在<span class="keyword">avg</span>，那么必然要分组</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br></pre></td></tr></table></figure><p>最后，有一个条件是：平均成绩大于60分，此时就需要对查询出来的分组进行过滤筛选了，此时<code>having</code>闪亮登场。</p><p><img src="http://bloghello.oursnail.cn/mysql10-2.png" alt="image"></p><p>测试了一下，下面两条sql都是一样的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">where</span> course_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">having</span> course_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2>第四个问题</h2><blockquote><p>查询没有学全所有课的同学的学号、姓名</p></blockquote><p>这个稍微复杂一点点，我们还是分解来看看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查询肯定用到select</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">#要查询的两个字段</span><br><span class="line">student_id,<span class="keyword">name</span></span><br><span class="line"></span><br><span class="line">#由于存在<span class="keyword">avg</span>，那么必然要分组</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br><span class="line"></span><br><span class="line">#两张表连接，要起个别名</span><br><span class="line"><span class="keyword">where</span> sc.student_id = stu.student_id</span><br></pre></td></tr></table></figure><p>因为需要查询课程没有学满的学生，所以需要先查询所有课程的数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> course</span><br></pre></td></tr></table></figure><p>此时，我们需要利用这个查询语句作为结果再进行查询，即子查询。对于上面的分组要进行筛选</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">having count(sc.course_id) &lt; (select count(1) from course)</span><br></pre></td></tr></table></figure><p>所以最终的语句是：</p><p><img src="http://bloghello.oursnail.cn/mysql10-3.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL必知必会知识点提炼</title>
      <link href="/2019/01/27/mysql/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2019/01/27/mysql/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      <content type="html"><![CDATA[<p>这是对《mysql必知必会》的知识提炼。</p><a id="more"></a><h1>一、基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p><p><code>SQL</code>（<code>Structured Query Language</code>)，标准 <code>SQL</code> 由 <code>ANSI</code> 标准委员会管理，从而称为 <code>ANSI SQL</code>。各个 <code>DBMS</code> 都有自己的实现，如 <code>PL/SQL</code>、<code>Transact-SQL</code> 等。</p><p><code>SQL</code> 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 <code>DBMS</code> 以及配置。</p><p><code>SQL</code> 支持以下三种注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure><h1>二、创建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h1>三、修改表</h1><p>添加列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><h1>四、插入</h1><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure><p>插入检索出来的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure><p>将一个表的内容插入到一个新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1>五、更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">col</span> = val</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1>六、删除</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>TRUNCATE TABLE</strong>  可以清空表，也就是删除所有行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><p>使用更新和删除操作时一定要用 <code>WHERE</code> 子句，不然会把整张表的数据都破坏。可以先用 <code>SELECT</code> 语句进行测试，防止错误删除。</p><h1>七、查询</h1><h2>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回第 3 ~ 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h1>八、排序</h1><ul><li><strong>ASC</strong> ：升序（默认）</li><li><strong>DESC</strong> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h1>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;&gt; !=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&lt;= !&gt;</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;= !&lt;</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">BETWEEN</td><td style="text-align:center">在两个值之间</td></tr><tr><td style="text-align:center">IS NULL</td><td style="text-align:center">为 NULL 值</td></tr></tbody></table><p>应该注意到，<code>NULL</code> 与 0、空字符串都不同。</p><p><strong>AND 和 OR</strong>  用于连接多个过滤条件。优先处理 <code>AND</code>，当一个过滤表达式涉及到多个 <code>AND</code> 和 <code>OR</code> 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong>  操作符用于匹配一组值，其后也可以接一个 <code>SELECT</code> 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong>  操作符用于否定一个条件。</p><h1>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><p><code>%</code>  匹配 &gt;=0 个任意字符；</p></li><li><p><code>\_</code>  匹配 ==1 个任意字符；</p></li><li><p><code>[ ]</code>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p></li></ul><p>使用 <code>Like</code> 来进行通配符匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">LIKE</span> <span class="string">'[^AB]%'</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h1>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用  <strong>AS</strong>  来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 * col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><p><strong>CONCAT()</strong>  用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">'('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1>十二、函数</h1><h2>汇总</h2><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center">AVG()</td><td style="text-align:center">返回某列的平均值</td></tr><tr><td style="text-align:center">COUNT()</td><td style="text-align:center">返回某列的行数</td></tr><tr><td style="text-align:center">MAX()</td><td style="text-align:center">返回某列的最大值</td></tr><tr><td style="text-align:center">MIN()</td><td style="text-align:center">返回某列的最小值</td></tr><tr><td style="text-align:center">SUM()</td><td style="text-align:center">返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 <code>NULL</code> 行。</p><p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2>文本处理</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">LEFT()</td><td style="text-align:center">左边的字符</td></tr><tr><td style="text-align:center">RIGHT()</td><td style="text-align:center">右边的字符</td></tr><tr><td style="text-align:center">LOWER()</td><td style="text-align:center">转换为小写字符</td></tr><tr><td style="text-align:center">UPPER()</td><td style="text-align:center">转换为大写字符</td></tr><tr><td style="text-align:center">LTRIM()</td><td style="text-align:center">去除左边的空格</td></tr><tr><td style="text-align:center">RTRIM()</td><td style="text-align:center">去除右边的空格</td></tr><tr><td style="text-align:center">LENGTH()</td><td style="text-align:center">长度</td></tr><tr><td style="text-align:center">SOUNDEX()</td><td style="text-align:center">转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong>  可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)</span><br></pre></td></tr></table></figure><h2>日期和时间处理</h2><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center">AddDate()</td><td style="text-align:center">增加一个日期（天、周等）</td></tr><tr><td style="text-align:center">AddTime()</td><td style="text-align:center">增加一个时间（时、分等）</td></tr><tr><td style="text-align:center">CurDate()</td><td style="text-align:center">返回当前日期</td></tr><tr><td style="text-align:center">CurTime()</td><td style="text-align:center">返回当前时间</td></tr><tr><td style="text-align:center">Date()</td><td style="text-align:center">返回日期时间的日期部分</td></tr><tr><td style="text-align:center">DateDiff()</td><td style="text-align:center">计算两个日期之差</td></tr><tr><td style="text-align:center">Date_Add()</td><td style="text-align:center">高度灵活的日期运算函数</td></tr><tr><td style="text-align:center">Date_Format()</td><td style="text-align:center">返回一个格式化的日期或时间串</td></tr><tr><td style="text-align:center">Day()</td><td style="text-align:center">返回一个日期的天数部分</td></tr><tr><td style="text-align:center">DayOfWeek()</td><td style="text-align:center">对于一个日期，返回对应的星期几</td></tr><tr><td style="text-align:center">Hour()</td><td style="text-align:center">返回一个时间的小时部分</td></tr><tr><td style="text-align:center">Minute()</td><td style="text-align:center">返回一个时间的分钟部分</td></tr><tr><td style="text-align:center">Month()</td><td style="text-align:center">返回一个日期的月份部分</td></tr><tr><td style="text-align:center">Now()</td><td style="text-align:center">返回当前日期和时间</td></tr><tr><td style="text-align:center">Second()</td><td style="text-align:center">返回一个时间的秒部分</td></tr><tr><td style="text-align:center">Time()</td><td style="text-align:center">返回一个日期时间的时间部分</td></tr><tr><td style="text-align:center">Year()</td><td style="text-align:center">返回一个日期的年份部分</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-4-14 20:25:11</span><br></pre></td></tr></table></figure><h2>数值处理</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SIN()</td><td style="text-align:center">正弦</td></tr><tr><td style="text-align:center">COS()</td><td style="text-align:center">余弦</td></tr><tr><td style="text-align:center">TAN()</td><td style="text-align:center">正切</td></tr><tr><td style="text-align:center">ABS()</td><td style="text-align:center">绝对值</td></tr><tr><td style="text-align:center">SQRT()</td><td style="text-align:center">平方根</td></tr><tr><td style="text-align:center">MOD()</td><td style="text-align:center">余数</td></tr><tr><td style="text-align:center">EXP()</td><td style="text-align:center">指数</td></tr><tr><td style="text-align:center">PI()</td><td style="text-align:center">圆周率</td></tr><tr><td style="text-align:center">RAND()</td><td style="text-align:center">随机数</td></tr></tbody></table><h1>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p><code>GROUP BY</code> 自动按分组字段进行排序，<code>ORDER BY</code> 也可以按汇总字段来进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p><code>WHERE</code> 过滤行，<code>HAVING</code> 过滤分组，行过滤应当先于分组过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分组规定：</p><ul><li><code>GROUP BY</code> 子句出现在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前；</li><li>除了汇总字段外，<code>SELECT</code> 语句中的每一字段都必须在 <code>GROUP BY</code> 子句中给出；</li><li><code>NULL</code> 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 <code>GROUP BY</code> 列具有可变长度的数据类型。</li></ul><h1>十四、子查询</h1><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h1>十五、连接</h1><p>连接用于连接多个表，使用 <code>JOIN</code> 关键字，并且条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 <code>AS</code> 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2>内连接</h2><p>内连接又称等值连接，使用 <code>INNER JOIN</code> 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>可以不明确使用 <code>INNER JOIN</code>，而使用普通查询并在 <code>WHERE</code> 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>在没有条件语句的情况下返回笛卡尔积。</p><h2>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department = (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure><p>自连接版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure><h2>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure><h2>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure><p>customers 表：</p><table><thead><tr><th style="text-align:center">cust_id</th><th style="text-align:center">cust_name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td></tr></tbody></table><p>orders 表：</p><table><thead><tr><th style="text-align:center">order_id</th><th style="text-align:center">cust_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">3</td></tr></tbody></table><p>结果：</p><table><thead><tr><th style="text-align:center">cust_id</th><th style="text-align:center">cust_name</th><th style="text-align:center">order_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">a</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">a</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">b</td><td style="text-align:center">Null</td></tr></tbody></table><h1>十六、组合查询</h1><p>使用  <strong>UNION</strong>  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 <code>UNION ALL</code>。</p><p>只能包含一个 <code>ORDER BY</code> 子句，并且必须位于语句的最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h1>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理；</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</p><p>给变量赋值都需要用 <code>select into</code> 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="built_in">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="built_in">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y*y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(@ret);</span><br><span class="line"><span class="keyword">select</span> @ret;</span><br></pre></td></tr></table></figure><h1>十九、游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="built_in">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span><br><span class="line">        <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">'02000'</span> <span class="keyword">set</span> done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        open mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            fetch mycursor into ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line"></span><br><span class="line">        close mycursor;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure><h1>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：<code>DELETE</code>、<code>INSERT</code>、<code>UPDATE</code>。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 <code>BEFORE</code> 关键字，之后执行使用 <code>AFTER</code> 关键字。<code>BEFORE</code> 用于数据验证和净化，<code>AFTER</code> 用于审计跟踪，将修改记录到另外一张表中。</p><p><code>INSERT</code> 触发器包含一个名为 <code>NEW</code> 的虚拟表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> @<span class="keyword">result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure><p><code>DELETE</code> 触发器包含一个名为 <code>OLD</code> 的虚拟表，并且是只读的。</p><p><code>UPDATE</code> 触发器包含一个名为 <code>NEW</code> 和一个名为 <code>OLD</code> 的虚拟表，其中 <code>NEW</code> 是可以被修改地，而 <code>OLD</code> 是只读的。</p><p><code>MySQL</code> 不允许在触发器中使用 <code>CALL</code> 语句，也就是不能调用存储过程。</p><h1>二十一、事务处理</h1><p>基本术语：</p><ul><li>事务（<code>transaction</code>）指一组 SQL 语句；</li><li>回退（<code>rollback</code>）指撤销指定 SQL 语句的过程；</li><li>提交（<code>commit</code>）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（<code>savepoint</code>）指事务处理中设置的临时占位符（<code>placeholder</code>），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p><p><code>MySQL</code> 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 <code>autocommit</code> 为 0 可以取消自动提交，直到 <code>autocommit</code> 被设置为 1 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，<code>ROLLBACK</code> 会回退到 <code>START TRANSACTION</code> 语句处；如果设置了保留点，并且在 <code>ROLLBACK</code> 中指定该保留点，则会回退到该保留点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure><h1>二十二、字符集</h1><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(<span class="keyword">col</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><p>可以在排序、分组时指定校对：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">col</span> <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure><h1>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>创建账户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypassword'</span>;</span><br></pre></td></tr></table></figure><p>新创建的账户没有任何权限。</p><p><strong>修改账户名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure><p><strong>删除账户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>查看权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>授予权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure><p>账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。</p><p><strong>删除权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li><li>整个数据库，使用 <code>ON database.\*</code>；</li><li>特定的表，使用 <code>ON database.table</code>；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p><strong>更改密码</strong></p><p>必须使用 <code>Password()</code> 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser = <span class="keyword">Password</span>(<span class="string">'new_password'</span>);</span><br></pre></td></tr></table></figure><p>转自：</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/SQL.md" target="_blank" rel="noopener">SQL</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库事务核心问题</title>
      <link href="/2019/01/27/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/27/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本文从事务引出了Mysql InnoDB RR隔离级别下是如何防止幻读的。</p><a id="more"></a><h2>1. 数据库事务的四大特性</h2><p>最重要的是ACID特性。</p><ul><li>原子性(Atomicity)：事务要么都成功要么都失败</li><li>一致性(Consistency)：关系型数据库有很多约束，事务前后都要满足这些约束(不仅仅是数据库物理约束，还包括内部逻辑上的一些假设)</li><li>隔离性(Isolation)：两个事务互相独立，不能互相干扰</li><li>持久性(Durability)：事务执行成功之后结果可以持久化，永久存储下来(redo日志)</li></ul><p>对于一致性，可能解释比较抽象，他的实际含义是：数据库的数据应满足完整性约束。拿转账业务来说，假设用户A和用户B一共有2000块钱，那么他们之间无论如何转账，总共的钱应该都是2000.</p><h2>2. 事务并发访问引起的问题</h2><ul><li>更新丢失-mysql所有事务隔离级别在数据库层面均可避免</li></ul><table><thead><tr><th>取款事务</th><th>存款事务</th></tr></thead><tbody><tr><td>开始事务</td><td>开始事务</td></tr><tr><td>查询余额为100元</td><td>无</td></tr><tr><td>无</td><td>查询余额为100元</td></tr><tr><td>无</td><td>存入20，余额变为120元</td></tr><tr><td>无</td><td>提交事务</td></tr><tr><td>取出10元，余额改为90元</td><td>无</td></tr><tr><td>回滚事务，余额恢复为100元</td><td>更新丢失</td></tr></tbody></table><ul><li>脏读问题-一个事务读到另一个事务未提交的数据</li><li>不可重复读-事务A多次读取数据，未提交数据，此时事务B提交新的数据，导致A多次读取数据期间数据不一致，不满足隔离性</li><li>幻读-事务A受到另一个事务插入新的一行或者删除一行的影响，导致幻觉</li></ul><p><strong>不可重复读的重点是修改:</strong><br>同样的条件的select, 你读取过的数据, 再次读取出来发现值不一样了</p><p><strong>幻读的重点在于新增或者删除:</strong><br>同样的条件的select, 第1次和第2次读出来的记录数不一样</p><p>具体可以自己设置不同的隔离级别进行演示。</p><h2>3. 事务的隔离级别</h2><ul><li>Read uncommitted：读到其他事务未commit的值</li><li>Read committed：解决了脏读问题，但是会读到其他事务commit的值，读两次可能会读到两个值，所以又叫不可重复读</li><li>Repeatable Read：解决了不可重复读问题，可重复读，别人commit对我没有影响，但是对于别的事务插入操作，可能会产生幻读</li><li>Serializable：串行化，当发生两个事务同时提交，结果只可能有一个，相当于串行执行后的某个结果</li></ul><p>级别越来越高，安全性也越来越高，但是但是性能越来越低。说明一下，出现幻读只是针对这种<code>Repeatable Read</code>隔离级别，但是<code>InnoDB</code>已经不存在幻读问题了，如何解决的呢？主要是用<code>next-key锁</code>来解决，下文会讲到。</p><h2>4. 当前读和快照读</h2><h5>4.1 当前读</h5><p>读取的都是当前数据的最新版本，并且在读的时候对其加锁，不允许其他事务进行修改操作。</p><p><code>select ... lock in share mode</code>（共享锁）以及<br><code>select ... for update</code>、<code>update</code>、<code>delete</code>、<code>insert</code>（排他锁）这些操作都是当前读。</p><p>为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：</p><p><img src="http://bloghello.oursnail.cn/mysql4-7.jpg" alt="image"></p><p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，发出current read 读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。</p><p>待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。</p><p>一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。</p><h5>4.2 快照读</h5><p>不加锁的非阻塞读，简单的select（前提是事务级别不是<code>serializable</code>，因为在<code>serializable</code>级别下都是串行读，普通的<code>select</code>也会退化为当前读即<code>select ... lock in share mode</code>）</p><p>快照读的实现是基于多版本并发控制（MVCC）实现，旨在提高性能。有可能读到的不是数据的最新版本。（创建快照的时机决定了读到的数据的版本，如果事务A先快照读，事务B修改，那么事务A再快照读就还是更新前的版本，事务A的当前读会读到最新的数据；而当事务B先更新，事务A再快照读，就会读到数据最新版本了）</p><h6>4.3 MVCC</h6><p>MVCC在MySQL的InnoDB中的实现 在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号</li><li>DELETE时，保存当前事务版本号为行的删除版本号</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li></ul><p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p><p>说白了，就是乐观锁的一种实现。免去了加锁解锁的过程，对于读多写少的场景特别适用。</p><h2>5. RC，RR级别下的InnoDB非阻塞读（快照读）如何实现</h2><ul><li>通过数据行里的<code>DB_TRX_ID</code>、<code>DB_ROLL_PTR</code>、<code>DB_ROW_ID</code>这三个字段</li></ul><p><code>DB_TRX_ID</code>，最后一次修改本行事务的ID</p><p><code>DB_ROLL_PTR</code>，即回滚指针,与undo日志配合</p><p><code>DB_ROW_ID</code>，随着新行插入而单调递增的行号（innoDB中如果既没有主键索引也没有唯一索引的时候，就会自动生成一个隐藏主键，就是这个玩意）</p><p>这三个字段结合<code>undo</code>日志，这个日志里面记录的都是老版本的数据，这样，快照读就可以读出适合的一个版本的数据出来。在数据库中，日志是非常重要的东西，可以说其重要性是大于数据本身的，因为数据丢失可以通过日志找回来，但是日志丢失了，那么以后数据库出现崩溃等就麻烦了。</p><h2>6. 日志</h2><p>数据库数据存放的文件称为<code>data file</code>；日志文件称为<code>log file</code>；数据库数据是有缓存的，如果没有缓存，每次都写或者读物理disk，那性能就太低下了。数据库数据的缓存称为<code>data buffer</code>，日志（redo）缓存称为<code>log buffer</code>；既然数据库数据有缓存，就很难保证缓存数据（脏数据）与磁盘数据的一致性。比如某次数据库操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> driver_info <span class="keyword">set</span> driver_status = <span class="number">2</span> <span class="keyword">where</span> driver_id = <span class="number">10001</span>;</span><br></pre></td></tr></table></figure><p>更新<code>driver_status</code>字段的数据会存放在缓存中，等待存储引擎将<code>driver_status</code>刷新<code>data_file</code>，并返回给业务方更新成功。如果此时数据库宕机，缓存中的数据就丢失了，业务方却以为更新成功了，数据不一致，也没有持久化存储。</p><p>上面的问题就可以通过事务的ACID特性来保证。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> trans；</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> driver_info <span class="keyword">set</span> driver_status = <span class="number">2</span> <span class="keyword">where</span> driver_id = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这样执行后，更新要么成功，要么失败。业务方的返回和数据库<code>data file</code>中的数据保持一致。要保证这样的特性这就不得不说存储引擎<code>innodb</code>的<code>redo</code>和<code>undo</code>日志。</p><h5>6.1 undo是啥</h5><p>undo日志用于存放数据修改被修改前的值，假设修改 tba 表中 id=2的行数据，把Name=‘B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name='B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p><p>对数据的变更操作，主要来自 INSERT UPDATE DELETE，而UNDO LOG中分为两种类型，一种是 <code>INSERT_UNDO</code>（INSERT操作，事务提交后可以立即丢弃），记录插入的唯一键值；一种是 <code>UPDATE_UNDO</code>（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。</p><h5>6.2 redo是啥</h5><p>存储引擎也会为<code>redo</code> <code>undo</code>日志开辟内存缓存空间，<code>log buffer</code>。磁盘上的日志文件称为<code>log file</code>，是顺序追加的，性能非常高，注：磁盘的顺序写性能比内存的写性能差不了多少。</p><p>redo日志记录事务执行后的状态，用来恢复未写入<code>data file</code>的已成功事务更新的数据。例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为&lt;T1, X, 5&gt;，Redo日志为&lt;T1, X, 15&gt;。</p><p>梳理下事务执行的各个阶段：</p><ul><li>写undo日志到log buffer；</li><li>执行事务，并写redo日志到log buffer；</li><li>如果innodb_flush_log_at_trx_commit=1，则将redo日志写到log file，并刷新落盘。</li><li>提交事务。</li></ul><p>那redo日志是写进去了，但是数据呢？</p><p><strong>在数据库的世界里，数据从来都不重要，日志才是最重要的，有了日志就有了一切。</strong></p><p>因为<code>data buffer</code>中的数据会在合适的时间 由存储引擎写入到<code>data file</code>，如果在写入之前，数据库宕机了，根据落盘的redo日志，完全可以将事务更改的数据恢复。好了，看出日志的重要性了吧。先持久化日志的策略叫做<code>Write Ahead Log</code>，即预写日志。</p><h5>6.3 Undo + Redo事务的简化过程</h5><p>假设有A、B两个数据，值分别为1,2，开始一个事务，事务的操作内容为：把1修改为3，2修改为4，那么实际的记录如下（简化）：</p><ol><li>事务开始.</li><li>记录A=1到undo log buffer.</li><li>修改A=3.</li><li>记录A=3到redo log buffer.</li><li>记录B=2到undo log buffer.</li><li>修改B=4.</li><li>记录B=4到redo log buffer.</li><li>将redo log写入磁盘。</li><li>事务提交</li></ol><p>我们可以看到，2，4，5，7，8都是新增操作，但是2，4，5，7都是缓冲到buffer区，只有8是磁盘IO操作。为了保证Redo Log有较好的IO性能，设计一般有以下特点：</p><ul><li>尽量保持<code>Redo Log</code>存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配。 以顺序追加的方式记录<code>Redo Log</code>,通过顺序IO来改善性能。</li><li>批量写入日志。日志并不是直接写入文件，而是先写入<code>redo log buffer</code>.当需要将日志刷新到磁盘时 (如事务提交),将许多日志一起写入磁盘.</li><li>并发的事务共享<code>Redo Log</code>的存储空间，它们的<code>Redo Log</code>按语句的执行顺序，依次交替的记录在一起，</li></ul><blockquote><pre><code> 以减少日志占用的空间。例如,Redo Log中的记录内容可能是这样的： 记录1: &lt;trx1, insert …&gt; 记录2: &lt;trx2, update …&gt; 记录3: &lt;trx1, delete …&gt; 记录4: &lt;trx3, update …&gt; 记录5: &lt;trx2, insert …&gt;</code></pre></blockquote><ul><li>因为上一条的原因,当一个事务将<code>Redo Log</code>写入磁盘时，也会将其他未提交的事务的日志写入磁盘</li><li><code>Redo Log</code>上只进行顺序追加的操作，当一个事务需要回滚时，它的<code>Redo Log</code>记录也不会从<code>Redo Log</code>中删除掉。</li></ul><h5>6.4 回滚</h5><p>前面说到未提交的事务和回滚了的事务也会记录<code>Redo Log</code>，因此在进行恢复时,这些事务要进行特殊的的处理。有2种不同的恢复策略：</p><ul><li>进行恢复时，只重做已经提交了的事务。</li><li>进行恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过<code>Undo Log</code>回滚那些未提交的事务。</li></ul><p>MySQL数据库InnoDB存储引擎使用了第二个策略。</p><h2>InnoDB可重复读隔离级别下如何避免幻读</h2><blockquote><p>表象原因:快照读（非阻塞读）–伪MVCC</p></blockquote><blockquote><p>内在原因：next-key锁（行锁+gap锁）</p></blockquote><h6>6.5 next-key锁</h6><p>在 RR 级别下，如果查询条件能使用上唯一索引，或者是一个唯一的查询条件，那么仅加行锁，如果是一个范围查询，那么就会给这个范围加上 <code>gap</code> 锁或者 <code>next-key</code>锁 (行锁+gap锁)。</p><p>那么gap锁啥时候出现呢？</p><p>使用主键索引或者唯一索引时：</p><ul><li>如果where条件全部命中，则不会用Gap锁，只会加记录锁</li><li>如果where条件部分命中或者全不命中，则会加Gap锁</li></ul><p>在走非唯一索引或者不走索引的当前读中，也会出现Gap锁。对于不走索引的情况，那么就会锁住整张表。</p><p>总结一下：只有对唯一索引+全部命中才不会加gap锁。</p><p>具体来个例子说明间隙锁如何工作。</p><h2>7. 例子-走唯一索引</h2><h5>7.1 准备工作</h5><p>有这样一个表test，其中name为主键，id为唯一键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> ( </span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) primary <span class="keyword">key</span>, </span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>, <span class="keyword">unique</span> <span class="keyword">KEY</span> <span class="string">`id`</span> (<span class="string">`id`</span>) ) </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span> (<span class="string">"f"</span>,<span class="number">1</span>), (<span class="string">"h"</span>,<span class="number">2</span>), (<span class="string">"b"</span>,<span class="number">3</span>), (<span class="string">"a"</span>,<span class="number">5</span>), (<span class="string">"c"</span>,<span class="number">6</span>),(<span class="string">"d"</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>id</th></tr></thead><tbody><tr><td>f</td><td>1</td></tr><tr><td>h</td><td>2</td></tr><tr><td>b</td><td>3</td></tr><tr><td>a</td><td>5</td></tr><tr><td>c</td><td>6</td></tr><tr><td>d</td><td>9</td></tr></tbody></table><p>首先验证一下使用主键索引或者唯一索引时会怎么样。</p><h5>7.2 第一种情况：唯一索引+命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>此时由于id是唯一索引，并且是命中的，所以只是对这一行加排他锁，而没有加gap锁，所以session2是可以正常执行的，不能被阻塞。</p><h5>7.3 第一种情况：唯一索引+不命中数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>此时session2会阻塞住，证明id=7周围加了gap锁。gap锁的范围遵从左开右闭的原则，这里就是(6,7）以及(7,9)都会被锁住。加上record锁组成next-key锁，所以next-key锁的范围是(6,7]以及(7,9]这个范围。</p><h5>7.4 第三种情况：唯一索引+不命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>) <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>这里是一个范围，5和9都是存在的，但是7不存在，即部分数据不存在。</p><p>session2执行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",4);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",7);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",8);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",10);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>那么对于(5,9]的范围内就阻塞住了，那么部分命中就是部分加gap锁。</p><h5>7.5 第四种情况：唯一索引+命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>) <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>这里全部命中，那么</p><p>session2执行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",7);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",8);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>这个时候就不会加gap锁了。</p><h2>8. 例子-不走唯一索引或者不走索引</h2><p>下面来看看不走非唯一索引的当前读是什么情况。</p><p>此时表的数据为：</p><table><thead><tr><th>name</th><th>id</th></tr></thead><tbody><tr><td>h</td><td>2</td></tr><tr><td>c</td><td>6</td></tr><tr><td>b</td><td>9</td></tr><tr><td>d</td><td>9</td></tr><tr><td>f</td><td>11</td></tr><tr><td>a</td><td>15</td></tr></tbody></table><p>把id上的唯一索引换成了普通索引。</p><h5>8.1 第五种情况：非唯一索引</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>此时session2是会被block住的。gap的范围是(6,9]以及(9,11].</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",5);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",7);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",12);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>上面的原理都是一样的，即只要是6和11之间的数，不包含临界值的时候，无论插入什么数据，都是会阻塞的。</p><p>但是关于临界值6和11，这里就比较特殊了，因为需要加上主键的值才能进行精准的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values(&quot;bb&quot;,6);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values(&quot;dd&quot;,6);&lt;!--不可以--&gt;</span><br></pre></td></tr></table></figure><p>这是什么原因呢？</p><p>我们将数据画成图：</p><p><img src="http://bloghello.oursnail.cn/mysql4-8.jpg" alt="image"></p><p>这里的gap区间可能是(负无穷，2],(2,6],(6,9],(9,11],(11,15],(15,正无穷)</p><p>我们可以看到，id为6的行，对应的name为c(不要忘记name是主键，主键按照顺序排序)，那么主键中就是按照字母表的顺序进行排列的（ASCII码），如果插入的name小于c，那么就不在gap的范围内(c,)，就可以插入，但是dd在gap的范围内,所以就会阻塞住。</p><h5>8.2 第五种情况：不走索引</h5><p>这个时候，所有的间隙都会加上间隙锁，那么就是锁表了。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>锁模块</title>
      <link href="/2019/01/26/mysql/%E9%94%81%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/01/26/mysql/%E9%94%81%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>本章对行锁表所、共享锁排他锁进行详细说明。这是数据库锁的核心知识。</p><a id="more"></a><h2>MySQL中几种重要的锁概念</h2><h6>共享锁（S）和 排他锁（X）</h6><p>InnoDB 实现了标准的行级锁，包括两种：共享锁（简称 s 锁）、排它锁（简称 x 锁）</p><ul><li>共享锁允许持锁事务读取一行</li><li>排它锁允许持锁事务更新或者删除一行</li></ul><p>如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：</p><ul><li>T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁</li><li>T2 请求 x 锁不能被立即允许</li></ul><p>如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才行。</p><h6>意向锁</h6><p>innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。</p><p>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。</p><p>说白了意向锁的主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”</p><ul><li>意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 x 锁</li><li>意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 s 锁</li></ul><p>例如， <code>SELECT ... LOCK IN SHARE MODE</code> 设置一个 IS 锁, <code>SELECT ... FOR UPDATE</code> 设置一个 IX 锁。</p><p>意向锁的原则如下：</p><ul><li>一个事务必须先持有该表上的 IS 或者更强的锁才能持有该表中某行的 S 锁</li><li>一个事务必须先持有该表上的 IX 锁才能持有该表中某行的 X 锁</li></ul><h6>next-key锁</h6><p>InnoDB有三种行锁的算法：</p><ul><li>Record Lock：单个行记录上的锁。分为S Lock和X Lock</li><li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</li><li>Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</li></ul><p>在默认情况下，mysql的事务隔离级别是可重复读，并且<code>innodb_locks_unsafe_for_binlog</code>参数为0，这时默认采用<code>next-key locks</code>。所谓<code>Next-Key Locks</code>，就是<code>Record lock</code>和<code>gap lock</code>的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。</p><p>例子：假设一个索引包含值 10,11,13和20，索引上可能的NK 锁包括如下几个区间（注意开闭区间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><p>Innodb使用NK 锁来进行索引搜索和扫描，阻止了幻读。</p><p>间隙锁在Innodb中是被“十足的抑制”的，也就是说，他们只阻止其他事务插入到间隙中，他们不阻止其他事物在同一个间隙上获得间隙锁。</p><p>下篇文章会详细介绍一下。</p><h2>MyISAM和InnoDB关于锁方面的区别</h2><p>结论：</p><ul><li>MyISAM默认使用的是表级锁，不支持行级锁</li><li>InnoDB默认使用的是行级锁，也支持表级锁</li></ul><p>所谓表级锁，就是锁住整张表。开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p><strong>MyISAM在执行select的时候会产生一个表共享读锁，当进行更新等操作的时候会产生表独占写锁（排他锁）</strong>。所以：</p><ul><li>myISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但会阻塞对同一个表的写请求。</li><li>myISAM表的写操作，会阻塞其他用户对同一个表的读和写操作。</li><li>myISAM表的读、写操作之间、以及写操作之间是串行的。</li></ul><blockquote><p>这里的读是共享锁，也可以将其变为排他锁，语法是select … for update</p></blockquote><p>上面说完了<code>MyISAM</code>的表锁，下面要说说<code>InnoDB</code>啦。<code>InnoDB</code>支持行级锁。</p><p>所谓行级锁，就是锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发性也最高。</p><h2>SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE</h2><p>如果你在查询数据，然后在同一个事务里插入或者修改相关的数据，常规的 <code>select</code> 语句不会提供足够的保护。其他的事务可以修改或者删除你正在查询的行。<code>InnoDB</code> 支持两种可以提供安全机制的读取锁：</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code></li><li><code>SELECT ... FOR UPDATE</code></li></ul><p><code>SELECT … LOCK IN SHARE MODE</code> 在读取的行上设置一个共享锁，其他的<code>session</code>可以读这些行，但在你的事务提交之前不可以修改它们。如果这些行里有被其他的还没有提交的事务修改，你的查询会等到那个事务结束之后使用最新的值。</p><p>索引搜索遇到的记录，<code>SELECT … FOR UPDATE</code> 会锁住行及任何关联的索引条目，和你对那些行执行 <code>update</code> 语句相同。其他的事务会被阻塞在比如执行 <code>update</code> 操作，获取共享锁，或从某些事务隔离级别读取数据等操作。</p><p>使用 <code>SELECT FOR UPDATE</code> 为 <code>update</code> 操作锁定行，只适用于 <code>autocommit</code> 被禁用（当使用 <code>START TRANSACTION</code> 开始事务或者设置 <code>autocommit</code> 为0时）。如果 <code>autocommit</code> 已启用，符合规范的行不会被锁定。</p><p>以上是对官方文档的翻译解读。</p><hr><p><code>SELECT … LOCK IN SHARE MODE</code> ：<strong>共享锁</strong>(S锁, <code>share locks</code>)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。</p><p>如果事务对某行数据加上共享锁之后，可进行读写操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。</p><p><code>SELECT … FOR UPDATE</code>：<strong>排他锁</strong>(X锁, <code>exclusive locks</code>)。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。</p><p>注：普通 <code>select</code> 语句默认不加锁，而<code>CUD</code>操作默认加排他锁。</p><ul><li>当前事务获取共享锁后，可以读写，其他事务是否可以进行读写操作和获取共享锁：可以读，可以获取共享锁，不可以写</li><li>两个事务同时获取共享锁后，是否可以进行update操作：不可以</li><li>当前事务获取排他锁后，其他事务是否可以进行读写操作和获取共享锁：其他事务可以读，不可以获取共享锁，不可以写</li><li>是否可对一条数据加多个排他锁：不可以</li><li>行锁和索引的关系：查询字段未加索引（主键索引、普通索引等）时，使用表锁</li></ul><blockquote><p>注：InnoDB行级锁基于索引实现。</p></blockquote><blockquote><ul><li><p>未加索引时，两种行锁情况为（使用表锁）：</p><ul><li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的共享锁，不可以获取不同行数据的排他锁</li><li>事务1获取某行数据排他锁，其他事务不可以获取不同行数据的共享锁、排他锁</li></ul></li><li><p>加索引后，两种行锁为（使用行锁）：</p><ul><li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的排他锁</li><li>事务1获取某行数据排他锁，其他事务可以获取不同行数据的共享锁、排他锁</li></ul></li></ul></blockquote><ul><li>索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</li></ul><h2>总结（很重要）</h2><ul><li>MyISAM默认使用的是表级锁，不支持行级锁<ul><li>执行select的时候会产生一个表共享读锁</li><li>当进行更新等操作的时候会产生表独占写锁（排他锁）</li><li>读不会阻塞其他session的读以及获取表共享读锁</li><li>写会阻塞其他session读和写操作</li><li>写与读之间是串行的</li></ul></li><li>InnoDB默认使用的是行级锁，也支持表级锁<ul><li>InnoDB 支持两种可以提供安全机制的读取锁：SELECT … LOCK IN SHARE MODE以及SELECT … FOR UPDATE</li><li>SELECT … LOCK IN SHARE MODE 在读取的行上设置一个共享锁</li><li>SELECT … FOR UPDATE：排他锁</li><li>一个session对某一行上共享锁，其他的session可以读这行，也可以获取共享锁，但是不允许写，更不允许获取写锁。对于其他行，可以读写其他行数据也可以上读写锁。</li><li>一个session对某一行上排他锁，其他的session则不能加任何锁，包括共享锁。允许读这一行，但是不能写。允许对其他行数据进行读写以及上读写锁。</li><li>InnoDB中行级锁基于索引实现，所以在不加索引的时候，这两者上的其实都是表锁；加上索引之后，使用行锁。</li></ul></li></ul><div class="tip"><p>以上的内容都是从博客：<a href="https://blog.csdn.net/u012099869/article/details/52778728" target="_blank" rel="noopener">https://blog.csdn.net/u012099869/article/details/52778728</a> 中整理而来，具体的实验也在他的博客中进行了详细的展示。</p></div><h2>MyISAM适合场景</h2><ul><li>频繁执行全表count语句(MyISAM已经用一个表保存了行数)</li><li>对数据进行增删改的频率不高，查询非常频繁</li><li>没有事务</li></ul><h2>InnoDB适合场景</h2><ul><li>数据增删改查都相当频繁</li><li>可靠性要求比较高，要求支持事务</li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于索引失效和联合索引</title>
      <link href="/2019/01/26/mysql/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/01/26/mysql/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>理解最左前缀原则，可以帮助我们避免索引失效。</p><a id="more"></a><h2>索引失效</h2><blockquote><p>查询条件包含or</p></blockquote><p>当<code>or</code>左右查询字段只有一个是索引，该索引失效，<code>explain</code>执行计划<code>key=null</code>；只有当or左右查询字段均为索引时，才会生效；</p><blockquote><p>组合索引，不是使用第一列索引，索引失效</p></blockquote><ul><li>如果<code>select * from key1=1 and key2= 2;</code>建立组合索引<code>（key1，key2）</code>;</li><li><code>select * from key1 = 1;</code>组合索引有效；</li><li><code>select * from key1 = 1 and key2= 2;</code>组合索引有效；</li><li><code>select * from key2 = 2;</code>组合索引失效；不符合最左前缀原则</li></ul><blockquote><p>like 以%开头</p></blockquote><p>使用<code>like</code>模糊查询，当%在前缀时，索引失效；</p><blockquote><p>如何列类型是字符串，where时一定用引号括起来，否则索引失效</p></blockquote><blockquote><p>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效</p></blockquote><h2>最左前缀原则</h2><p>建立以下sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`test_index`</span>(</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`data`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`union_index`</span> (<span class="string">`a`</span>,<span class="string">`b`</span>,<span class="string">`c`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> ROW_FORMAT=DYNAMIC  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=<span class="built_in">binary</span>;</span><br></pre></td></tr></table></figure><p>测试的<code>mysql</code>版本是 5.7.</p><ol><li>首先以列a作为条件查询数据，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 4</code> 表示索引长度为4，也就是利用上了索引来进行查找:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>然后以列b作为条件查询数据，可以看到<code>type: ALL</code>表示全表查找, <code>key_len: NULL</code> 表示没有索引，也就说明如果只使用b作为查询条件，不能利用索引来加快查找速度.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="3"><li>接着以列c作为条件查询数据，可以看到<code>type: ALL</code>表示全表查找, <code>key_len: NULL</code> 表示没有索引，情况与用b作为条件一样，只使用c作为查询条件也不能利用索引来加快查找速度</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="4"><li>现在来测一下使用a、b作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 8</code> 表示索引长度为8，也就是说我们利用上了a、b联合索引来进行查找</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> b = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">8</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="5"><li>紧接着来测一下使用a、c作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 4</code> 表示索引长度为4，这就奇怪了，按照最左原则来说，a、c上是不会建立索引的，为什么会有索引长度呢？其实与a、b上的索引一比较我们就能发现，a、c上的索引长度只有4，而且单独的c上是没有索引的，所以4字节长度的索引只能是a上的，也就是说这种情况我们只使用了a列上的索引来进行查找</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">index</span> condition</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="6"><li>为了进一步验证上面的想法，这一次测一下使用b、c作为条件的情况，我们看到 <code>type: ALL</code> 表示全表查找, <code>key_len: NULL</code> 表示没有索引可以使用，按照最左原则来说，b列上没有索引，c列上也没有索引，同时b、c的上也不存在联合索引，所以使用b、c作为查询条件时无法利用联合索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">1.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="7"><li>测试完两个条件的情况，接下来测试一下使用a、b、c作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 12</code> 表示索引长度为12，这完全符合联合索引的最左原则，同时使用3个条件查询可以利用联合索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">12</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="8"><li>下面这种情况也能利用a、b上的联合索引，索引长度为8</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span> <span class="keyword">and</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">8</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="9"><li>再来试试这种情况，按照最左原则，c上没有建立索引，a上有索引，c、a没有建立联合索引，所以只能使用a上的索引进行查找，结果索引长度只有4，验证了我们的想法，联合查询条件使用索引时满足“交换律”</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> c = <span class="number">1</span> <span class="keyword">and</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">index</span> condition</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2>联合索引总结</h2><ol><li>联合索引的最左原则就是建立索引<code>KEY union_index (a,b,c)</code>时，等于建立了(a)、(a,b)、(a,b,c)三个索引，从形式上看就是索引向左侧聚集，所以叫做最左原则，因此最常用的条件应该放到联合索引的组左侧。</li><li>**对于&quot;=&quot;和&quot;in&quot;可以乱序。**利用联合索引加速查询时，联合查询条件符合“交换律”，也就是<code>where a = 1 and b = 1</code> 等价于 <code>where b = 1 and a = 1</code>。这归功于mysql查询优化器，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</li><li><strong>mysql会一直向右匹配直到遇到范围查询(&lt;,&gt;,between,like)就停止匹配</strong>。比如a=3 and b=4 and c&gt;5 and d=6，如果建立(a,b,c,d)顺序的索引，d是用不到索引的。如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li></ol><h2>对于最左匹配原则的理解</h2><p><a href="https://www.zhihu.com/question/36996520" target="_blank" rel="noopener">mysql索引最左匹配原则的理解?–沈杰的回答</a></p><p>其实我觉得只要理解一点就是，只要有最左边的索引元素，那么这个索引结构一定是按照最左索引元素排序的，后序的索引元素也是依赖于最左元素之后才有可能变得有意义。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL调优</title>
      <link href="/2019/01/26/mysql/MySQL%E8%B0%83%E4%BC%98/"/>
      <url>/2019/01/26/mysql/MySQL%E8%B0%83%E4%BC%98/</url>
      <content type="html"><![CDATA[<p>本文介绍最基本的sql调优手段。</p><a id="more"></a><h2>根据慢日志定位慢查询sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这里是用模糊查询查出关于查询的一些配置项--&gt;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%query%'</span></span><br></pre></td></tr></table></figure><p>我们关注<code>slow_query_log</code>：<code>OFF</code>，表示慢查询处于关闭状态。关注<code>long_query_time</code>：超出这个时间就是慢查询，记录到<code>slow_query_log_file</code>文件中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%slow_queries%'</span></span><br></pre></td></tr></table></figure><p>这一句作用是统计慢查询的数量。</p><p>如何打开慢查询呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--打开慢查询--&gt;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log = <span class="keyword">on</span>;</span><br><span class="line">&lt;!--慢查询的标准是1秒--&gt;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>注意要重启一下客户端。或者在配置文件中设置，重启服务端就永久保留了。</p><h2>explain分析慢日志</h2><p>上一步时打开慢查询日志。下面要进行分析。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ...</span><br></pre></td></tr></table></figure><p>对这个命令进行分析。有两个关键字段：</p><p><code>type</code>：表示mysql找到数据行的方式，下面的顺序是由快到慢：</p><p><code>system</code>&gt;<code>const</code>&gt; <code>eq_ref</code>&gt;<code>ref</code>&gt;<code>fulltext</code>&gt;<code>ref_or_null</code>&gt;<code>index_merge</code>&gt;<code>unique_subquery</code>&gt;<code>index_subquery</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>all</code></p><p><strong>其中<code>index</code>和<code>all</code>为全表扫描。说明需要优化。</strong></p><p><code>extra</code>：</p><ul><li><code>using_filesort</code>：表示MySQL会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容。可能在内存或者磁盘上进行排序。MqSQL中无法利用索引完成的排序操作称为“文件排序”</li><li><code>using temporary</code>：表示MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by。</li></ul><p><strong>当<code>extra</code>中出现以上两项意味着MYSQL根本不能使用索引，效率会受到重大影响，应尽可能对此进行优化。</strong></p><h2>修改sql或者尽量让sql走索引</h2><p>上一步分析完之后，就要采取一定的措施来修正。</p><p>如果是没有加索引，可以对其加上索引。<code>extra</code>就会变成<code>using index</code>，表示走了索引。</p><h2>索引是越多越好吗</h2><ul><li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li><li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li><li>更多的索引意味着也需要更多的空间</li></ul><p>可以理解为，一个几页的宣传手册</p><ul><li>对于几页的宣传手册我们还需要建立一个目录吗？</li><li>变更这个小的宣传手册里面的章节还要修改目录不是更烦吗？</li><li>一个宣传手册内容就两页，结果你的目录就占了一页，这合理吗？</li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL索引全面解读</title>
      <link href="/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>彻底理解MySQL的存储引擎数据结构以及聚集索引。</p><a id="more"></a><h2>1.为什么需要索引</h2><p>如果不用索引，那么最简单的方案是：将数据全部或者分批次地加载到内存，因为数据是以页的形式存储的，所以我们可以轮询这些页，找出有没有我们需要的数据。</p><p>在大数据量的情况下，显然是会非常慢的。因为它要进行全表的扫描。</p><p>而索引的灵感来源于字典，我们知道，新华字典前面有按照拼音或者按偏旁部首排序的一个列表页，我们可以快速地根据这个索引目录迅速定位到某几页，然后我们到这个某几页找一下就可以找到了。不需要全表扫描。</p><h2>2.索引的数据结构</h2><h5>2.1 二叉查找树上阵</h5><p>二叉查找树的特点：</p><ul><li>二分搜索树本质上是一棵二叉树。不需要是一棵完全二叉树。</li><li>每个节点的键值大于左孩子</li><li>每个节点的键值小于右孩子</li><li>以左右孩子为根的子树仍为二分搜索树</li></ul><p>二叉查找树有点很明显，我们查询一个数据只需要O(logn)的时间。但是它存在一个致命问题：</p><p>我们有时会删除增加数据，搞的不好，会把他恶化成一个链表。</p><p><img src="http://bloghello.oursnail.cn/mysql4-1.jpg" alt="image"></p><p>但是有的同学说，我们可以利用红黑树之类的数据结构来维持住平衡二叉树的特性，这样不就好了吗？</p><p>这里还存在另一个问题，就是IO。我们知道从磁盘查询数据，影响性能的关键点是iO的次数，然后这种一个节点只有两个孩子，在海量数据里，IO的次数还是太多，影响性能。</p><p>我们这个时候就知道了方向，我们想找一个数据结构，它既包含了二叉树的优点，还要是平衡的树，还能使树的高度变矮，并且每个节点存储更多的数据。</p><h5>2.2 BTree上阵</h5><p>B数又叫平衡多路查找树。M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉</p><p><img src="http://bloghello.oursnail.cn/mysql4-2.jpg" alt="image"></p><p>有几个特点：</p><ul><li>根节点至少包含两个孩子</li><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li><strong>子节点数</strong>：树中每个节点最多包含m个孩子(m&gt;=2)；除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子</li><li><strong>关键字数</strong>：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于m-1个（<strong>分别比孩子数少一个</strong>）</li><li>所有叶子节点都位于同一层，即所有叶子节点高度都一样</li></ul><p>我们结合这个图来理解。</p><p>可以看到，我们这是一个3路B树，根节点有3个孩子，有2个关键字。根据规则，子节点数最多为m个即3个，最少为ceil(1.5)个即2个；关键字数最多为m-1个即2个，最少为于ceil(1.5)-1个即1个.</p><p>那么我们进行插入的时候，关键字这里最多为2个，所以大于2就要进行拆分。</p><p>如何拆分呢？拿个例子来：</p><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;</p><p>那么关键字最多为4个，超过4个就拆分。</p><p>先插入 3、8、31、11</p><p><img src="http://bloghello.oursnail.cn/mysql4-23jpg.jpg" alt="image"></p><p>再插入23、29</p><p><img src="http://bloghello.oursnail.cn/mysql4-3.jpg" alt="image"></p><p>再插入50、28</p><p><img src="http://bloghello.oursnail.cn/mysql4-4.jpg" alt="image"></p><p>大概就是这样的流程。总之要维护一个从左到右逐渐增大的一个特性，并且必须是平衡的。(大概忽略里面可能存在的一些小错误，理解其中意思即可)</p><p>对于删除也是如此，要满足以上的特性才行，这里就不再赘述了。</p><p>对B树总结一下：</p><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p><h5>2.3 B+树</h5><p>是B树的变体，其定义基本上与B树是差不多的。除了：</p><ul><li><strong>非叶子节点的子树指针与关键字个数相同</strong></li><li><strong>非叶子节点仅用来索引，数据都保存在叶子节点中</strong></li><li><strong>所有叶子节点均有一个链指针指向下一个叶子节点</strong></li></ul><p>这就是B+树相对于B树的改进的几个点。</p><p>由于数据存在叶子节点，优点是非叶子节点保存的关键字更多了，树的高度就会更矮。</p><p><img src="http://bloghello.oursnail.cn/mysql4-5.jpg" alt="image"></p><h5>2.4 总结</h5><p>B+树更适合用来做存储索引：</p><ul><li>B+树的磁盘读写代价更低（因为内部不存放数据，一次性读取的关键字更多，IO次数降低）</li><li>B+树的查询效率更加稳定（任何关键字的查找都要到叶子节点，导致每个查询都差不多）</li><li>B+树有利于对数据库扫描（遍历叶子节点就可以直接扫描整个表，这个适合做范围查询）</li></ul><h5>2.5 Hash索引也可以考虑一下</h5><p>Hash结构可以一次性地定位到响应位置。如果遇到碰撞的情况，只需要遍历链表即可。那么性能这么高，为什么我们不用Hash索引呢？</p><p>它也有缺点：</p><ul><li>只能做等值操作，不能使用范围查询</li><li>hash索引不是按照索引值顺序存储，无法使用于排序。</li><li>不能利用部分索引键查询（比如组合索引，hash索引是对这几个索引一起hash计算的，而我们用组合索引中的部分索引时就无法用了）</li><li>不能避免表扫描（会出现hashs冲突，必然要扫描里面具体的数据才行）</li><li>遇到大量hash值相等的时候性能不一定比B树高(同上)</li></ul><h2>3. 聚集索引</h2><h5>3.1 什么是聚集索引</h5><p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><h5>3.2 MyISAM和InnoDB索引实现</h5><p><strong>第一个不同是：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</strong></p><p><code>MyISAM</code>引擎使用<code>B+Tree</code>作为索引结构，叶节点的<code>data</code>域存放的是数据记录的地址，是没有任何顺序而言的，所以<strong>MyISAM的索引方式也叫做“非聚集”的</strong>，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><p><code>MyISAM</code>中索引检索的算法为首先按照<code>B+Tree</code>搜索算法搜索索引，如果指定的Key存在，则取出其<code>data</code>域的值，然后以<code>data</code>域的值为地址，读取相应数据记录。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9523.png" alt="image"></p><p>在<code>MyISAM</code>中，主索引和辅助索引（<code>Secondary key</code>）在结构上没有任何区别，只是主索引要求<code>key</code>是唯一的，而辅助索引的<code>key</code>可以重复。</p><p><code>InnoDB</code>也使用<code>B+Tree</code>作为索引结构。<code>InnoDB</code>的数据文件本身就是索引文件，即  <code>InnoDB</code> 表是基于聚簇索引建立的。</p><p><code>MyISAM</code>索引文件和数据文件是分离的，索引文件仅保存数据记录的地址（这一点可以通过在<code>data</code>目录下查看数据库文件验证。<code>Innodb</code>每一个数据库只有一个数据文件，而<code>Myisam</code>则有三个（数据文件、索引文件、表结构文件））。</p><p>而在<code>InnoDB</code>中，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的<code>key</code>是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9524.png" alt="image"></p><p>上图是<code>InnoDB</code>主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。聚集索引的确定规则为：</p><ul><li>若一个主键被定义，该主键则作为聚集索引</li><li>若没有主键被定义，该表的第一个唯一非空索引作为聚集索引</li><li>若上述都找不到，innodb内部会生成一个隐藏主键(聚集索引)</li><li>非主键索引存储相关键位和其对应的主键值，包含两次查找</li></ul><p><strong>第二个与<code>MyISAM</code>索引的不同是<code>InnoDB</code>的辅助索引<code>data</code>域存储相应记录主键的值而不是地址。</strong></p><p>换句话说，<code>InnoDB</code>的所有辅助索引都引用主键作为<code>data</code>域。</p><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p><img src="http://bloghello.oursnail.cn/mysql4-6.jpg" alt="image"></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了<code>InnoDB</code>的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在<code>InnoDB</code>中不是个好主意，因为<code>InnoDB</code>数据文件本身是一颗<code>B+Tree</code>，非单调的主键会造成在插入新记录时数据文件为了维持<code>B+Tree</code>的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择</p><h2>4. 总结</h2><p>本文首先介绍的是为什么要索引。这个问题很简单。</p><p>然后介绍了几种数据结构：二叉搜索树、二叉平衡树、B树以及B+树。一步一步引出为什么最终是B+树。面试的时候就看解决：为什么不能用二叉搜索树、为什么不用红黑树、B树和B+树各自的数据结构特点、B+树的优点</p><p>最后介绍了聚集索引，因为这是MyISAM与InnoDB索引结构最大的不同。</p><p>之前还是不能太准确理解聚集索引，这两种存储引擎都是以B+树数据结构建立索引结构的，但是InnoDB本身这个B+树就作为了索引文件，即索引与数据是放在一起的，所以逻辑上这样排的数据，它物理上也是这么排。</p><p>而MyISAM的索引结构(B+树)与数据是分离的，虽然B+树可能是按照主键有序地组织，但是表的数据在另一个地方是随机放的，找数据是根据地址来找即可，所以这种结构就不是聚集的。</p><p>理解了这个，下面就非常好理解了，InnoDB这个B+树，我们知道，叶子节点的核心数据就是主键。所以是按照主键递增的方式进行排列。这样子，无论是按照主键排序还是范围搜索，都会非常地快。</p><p>那么如果是非主键索引的辅助索引呢？InnoDB只能通过两次查询来实现了，首先第一步是根据这个辅助索引找到存放在叶子节点中的主键值，然后根据主键再去主键索引中去查找对应的数据。</p><p>而MyISAM索引，主键索引和辅助索引就区别不大了。都是单独一个索引结构，然后根据最后叶子节点中的该条数据的地址去找。</p><p>上面说的按照主键排列，就是这里所谓的聚集索引啦。当然了，如果没有指定主键，会按照上面所说的规则去构建聚集索引。</p><p>那么，面试的时候，就可以应对InnoDB与MyISAM索引结构的各自的实现和不同点啦。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库索引入门</title>
      <link href="/2019/01/26/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/"/>
      <url>/2019/01/26/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>索引是数据库中提高性能的一大利器。本篇入门索引的基本知识。</p><a id="more"></a><h2>1. 什么是索引</h2><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><h2>2. 为什么要用索引</h2><p>索引主要就是为了提高查询速度用的。</p><h2>3. 索引的一些缺点</h2><ul><li>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h2>4. 哪些字段适合用索引</h2><ul><li><strong>在经常需要搜索的列上</strong>，可以加快搜索的速度；</li><li><strong>在作为主键的列上</strong>，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li><strong>在经常需要根据范围进行搜索的列上创建索引</strong>，因为索引已经排序，其指定的范围是连续的；</li><li><strong>在经常需要排序的列上创建索引</strong>，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li><strong>在经常使用在WHERE子句中的列上面创建索引</strong>，加快条件的判断速度。（这同一）</li></ul><h2>5. 不应该创建索引的的这些列具有下列特点</h2><ul><li>第一，<strong>对于那些在查询中很少使用或者参考的列不应该创建索引</strong>。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>第二，<strong>对于那些只有很少数据值的列也不应该增加索引</strong>。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>第三，<strong>对于那些定义为<code>text</code>, <code>image</code>和<code>bit</code>数据类型的列不应该增加索引</strong>。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>第四，<strong>当修改性能远远大于检索性能时，不应该创建索引</strong>。这是因为，<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><h2>6. 索引的分类</h2><p><code>B-Tree</code> 索引， <code>Hash</code> 索引， <code>Fulltext</code> 索引和<code>R-Tree</code> 索引</p><p>最主要关心的是<code>B-Tree</code> 索引。下面再提一下聚集索引，因为这是innodb最主要的组织方式。</p><p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><p><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">下一节</a>会详细讲到<code>InnoDB</code>和<code>MyISAM</code>的索引实现方式，他们最大的区别就是<code>InnoDB</code>是聚集索引，而<code>MyISAM</code>不是。</p><h2>7. 局部性原理与磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此<strong>为了提高效率，要尽量减少磁盘I/O</strong>。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会<strong>预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。<strong>这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（<code>page</code>）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h2>8.B树/B+树</h2><p>想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是<code>B tree</code>或者 <code>B+ tree</code>，重要的事情说三遍：“<strong>平衡树，平衡树，平衡树</strong>”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。</p><p>我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。</p><p>事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。</p><p><strong>如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引</strong>。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。</p><p><strong>这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置</strong>。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9521.png" alt="image"></p><p>上图就是带有主键的表（聚集索引）的结构图。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句：</p><blockquote><p>select * from table where id = 1256;</p></blockquote><p>首先根据索引定位到1256这个值所在的叶结点，然后再通过叶结点取到id等于1256的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%9522.jpg" alt="image"></p><p>这一节先对索引入个门，关于B+树以及聚集索引下篇文章来具体分析。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何设计一个关系型数据库</title>
      <link href="/2019/01/26/mysql/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/01/26/mysql/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>这是一个比较空的面试题，这里说一下如何回答。</p><a id="more"></a><h2>如何设计一个关系型数据库</h2><p>我们考虑开发一个数据库最重要的模块是什么。首先数据存储是其核心功能。因此会有一个存储模块来存储数据。介质主要是硬盘。</p><p>可是，光有存储是不行的。我们需要有以下程序模块对数据进行组织。</p><ul><li>存储管理</li></ul><p>我们需要对数据的格式和文件的分隔进行统一的管理，通过逻辑的形式来组合和表示出来。</p><p>我们知道程序处理，需要将数据先加载到内存中去，不可能直接在硬盘上进行处理。</p><p>我们通过io读取磁盘数据，磁盘的io是非常耗时的，所以硬盘以页的形式存储数据，根据局部性原理，往往用户要查询的数据周围的数据也会被查询到，所以取数据都是以页为单位查取多个数据，提高效率。</p><ul><li>缓存机制</li></ul><p>也就是上面提到的，一次IO不会只取用户所需要的一点数据，所以会涉及到缓存，缓存可能会不够放，那就涉及一些缓存淘汰的算法，比如比较常用的是LRU算法。</p><ul><li>SQL解析</li></ul><p>将SQL进行编译执行。如何提高SQL解析效率呢？可能也用缓存，缓存好SQL解析后的结果，下次再执行一样的SQL就可以免去解析的过程。</p><ul><li>日志管理</li></ul><p>要记录SQL操作，方便主从同步、灾难恢复等。这里要了解一下binlog.</p><ul><li>权限划分</li></ul><p>就是权限。</p><ul><li>容灾机制</li></ul><p>要对异常情况做好准备，比如数据库挂了怎么办。</p><ul><li>索引管理</li></ul><p>优化数据库执行效率。</p><ul><li>锁模块</li></ul><p>使得数据库支持并发操作。</p><h2>总结</h2><p>了解了上面的内容，我们就可以对这个问题做一个简单的总结性回答了，如何设计关系型数据库呢？首先数据库有一个存储的功能，使得它能存储在比如机械硬盘或者固态硬盘上面。其次，我们需要一个存储管理模块来映射程序逻辑与物理地址，实现存储管理。还需要缓存机制，对一些数据进行缓存提高效率，并且缓存不能太大，必须配备缓存淘汰机制；然后需要一个SQL解析模块，来解析SQL；然后需要日志管理来提供主从赋值、主从同步等功能；还需要一个权限划分模块，来提供给多用户使用场景；还需要容灾机制面对异常情况；最后，为了提高数据查询效率需要有索引管理模块；为了支持并发操作需要有锁模块。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>delete和truncate以及drop区别</title>
      <link href="/2019/01/25/mysql/delete%E5%92%8Ctruncate%E4%BB%A5%E5%8F%8Adrop%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/01/25/mysql/delete%E5%92%8Ctruncate%E4%BB%A5%E5%8F%8Adrop%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>这个题目我自己也被问过，这里简单整理一下。</p><a id="more"></a><p>先来个总结：</p><ul><li><code>drop</code>直接删掉表；</li><li><code>truncate</code>删除的是表中的数据，再插入数据时自增长的数据id又重新从1开始；</li><li><code>delete</code>删除表中数据，可以在后面添加<code>where</code>字句。</li></ul><h2>日志是否记录</h2><p><code>DELETE</code>语句执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p><p><code>TRUNCATE TABLE</code> 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><h2>是否可以回滚</h2><p><code>delete</code> 这个操作会被放到 <code>rollback segment</code> 中,事务提交后才生效。<code>truncate</code>、<code>drop</code>是DLL（data define language),操作立即生效，原数据不放到 <code>rollback segment</code> 中，不能回滚.</p><p>所以在没有备份情况下，谨慎使用 <code>drop</code> 与 <code>truncate</code>。</p><h2>表和索引占的空间</h2><p>当表被 <code>TRUNCATE</code> 后，这个表和索引所占用的空间会恢复到初始大小。</p><p>而 <code>DELETE</code> 操作不会减少表或索引所占用的空间。</p><p><code>drop</code>语句将表所占用的空间全释放掉。</p><p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据，而 <code>DROP</code> 则删除整个表（结构和数据）</p><p>所以从干净程度，<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></p><p>ok，差不多了。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql最基础知识小结</title>
      <link href="/2019/01/25/mysql/mysql%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/01/25/mysql/mysql%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>本文介绍关于数据库的最最最最基本的一些语法知识，如果这些都不熟悉，建议多多练习，因为后续的文章会比较深入原理。</p><a id="more"></a><p>一、DDL语句</p><p>1、创建数据库：<code>create database dbname;</code></p><p>2、删除数据库：<code>drop database dbname;</code></p><p>3、创建表：<code>create table tname;</code></p><p>4、删除表：<code>drop table tname;</code></p><p>5、修改表：略，懒得看</p><hr><p>二、DML语句</p><ul><li>插入：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span>(字段<span class="number">1</span>，字段<span class="number">2</span>，...) <span class="keyword">values</span> (value1,value2,...) , (value3,value4,..)</span><br></pre></td></tr></table></figure><ul><li>更新：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> 字段=<span class="keyword">value</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><ul><li>删除：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><p>这里要注意下<code>delete</code>和<code>truncate</code>以及<code>drop</code>三者的区别，下篇文章详解。</p><ul><li>单表查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure><ul><li>连表查询方式1：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 别名<span class="number">1.</span>字段,别名<span class="number">2.</span>字段 <span class="keyword">from</span> table1 别名<span class="number">1</span>,table2 别名<span class="number">2</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><ul><li>连表查询方式2：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 别名<span class="number">1.</span>字段,别名<span class="number">2.</span>字段 <span class="keyword">from</span> table1 别名<span class="number">1</span> <span class="keyword">join</span> table2 别名<span class="number">2</span> <span class="keyword">on</span> ...</span><br></pre></td></tr></table></figure><p>这是全连接，这里就要了解一下笛卡儿积，简单来说，最后行数是左边表的函数乘以右边表的行数。详细的可以自行google.</p><ul><li>查询不重复的记录：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span> ...</span><br></pre></td></tr></table></figure><ul><li>排序：默认是升序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ... <span class="keyword">asc</span>/<span class="keyword">desc</span></span><br></pre></td></tr></table></figure><ul><li>limit：主要用于分页</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ... <span class="keyword">asc</span>/<span class="keyword">desc</span> <span class="keyword">limit</span> 起始偏移位置，显示条数</span><br></pre></td></tr></table></figure><ul><li>聚合：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*)/<span class="keyword">avg</span>(..)/<span class="keyword">sum</span>(...)/<span class="keyword">max</span>(...)/<span class="keyword">min</span>(...) <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">group</span> <span class="keyword">by</span> ... <span class="keyword">having</span> ....</span><br></pre></td></tr></table></figure><p>注意这里的<code>having</code>和<code>where</code>的区别：<code>where</code>是对表结果进行筛选，<code>having</code> 是对查询结果进行筛选，与<code>group by</code> 合用</p><ul><li>左连接和右连接</li></ul><p>左连接意思就是左表中的记录都在，右表没有匹配项就以null显示。记录数等于左表的行数。</p><p>右连接与之同理，尽量转为左连接做。</p><ul><li>子查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">in</span> (<span class="keyword">select</span> ....)</span><br></pre></td></tr></table></figure><p>所谓子查询就是根据另一个<code>select</code>的结果再进行筛选，常用的是in,not in,=,!=,exits,not exits</p><ul><li>union<br>主要用于两张表中的数据的合并：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> table1 <span class="keyword">union</span> all <span class="keyword">select</span> 字段 <span class="keyword">from</span> table2</span><br></pre></td></tr></table></figure><p>要想不重复用<code>union</code></p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些常见的面试题</title>
      <link href="/2019/01/25/network/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/01/25/network/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>对这一块整理一些常见的面试题。</p><a id="more"></a><h2>1.TCP三次握手、四次挥手</h2><p>这部分略。前面已经说的很详细，包括握手为什么不是两次、为什么不是四次，为什么挥手要等2MSL的时间。</p><h2>2.常见的HTTP状态码及其含义</h2><ul><li>200 OK：正常返回信息</li><li>400 Bad Reqest：客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized：请求未经授权，这个状态码必须与WWW-Authenticate报头域一起使用</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在</li><li>500 Internal Server Error：服务器发生不可预期的错误</li><li>503 Server Unavilable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul><h2>3.Get请求和Post请求的区别</h2><ul><li>Http报文层面：GET将请求信息放在URL，POST则放在报文体中</li><li>数据库层面：GET符合幂等性和安全性(查询不会改变数据库)，POST不符合</li><li>其他层面：GET可以被缓存、被存储为书签，而POST不行</li></ul><h2>4.Cookie和Session的区别</h2><p>对于session，字面上理解是会话，可以理解为用户与服务端一对一的交互。是一个比较抽象的概念。</p><p>但是我们常说的session其实是这里抽象概念的一种实现方式罢了，我觉得没有必要咬文嚼字，下面直接从面试角度来分析一下。</p><p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。</p><p>这个Session是保存在服务端的，有一个唯一标识，这个唯一标识对应一个用户。在服务端保存Session的方法很多，内存、数据库、文件都有。</p><p>服务端解决了用户标识问题，但是服务端怎么知道此时操作浏览器的用户是谁呢？</p><p>这个时候<code>Cookie</code>就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。</p><p>实际上大多数的应用都是用 <code>Cookie</code> 来实现<code>Session</code>跟踪的，第一次创建<code>Session</code>的时候，服务端会在HTTP协议中告诉客户端(放在响应头中返回)，需要在 <code>Cookie</code> 里面记录一个<code>Session ID</code>，以后每次请求(请求头)把这个会话ID发送到服务器，我就知道你是谁了。</p><p>有人问，如果客户端的浏览器禁用了 <code>Cookie</code> 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p><p><code>Cookie</code>其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到<code>Cookie</code>里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是<code>Cookie</code>名称的由来，给用户的一点甜头。</p><p><strong>总结：</strong></p><p><code>Session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</p><p><code>Cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现<code>Session</code>的一种方式。</p><p>下面说一下很常见的一种写法。比如在单体应用中，我此时登陆你的网站了，你可以将我的信息保存在<code>session</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User currentUserInfo = userService.getUserByUsernameAndPasswd(username,password);</span><br><span class="line">session.setAttribute(<span class="string">"currentUser"</span>,currentUserInfo);</span><br></pre></td></tr></table></figure><p>下次，我就可以在我们之间的会话中随时获取我的个人信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User currentUser = session.getAttribute(<span class="string">"currentUser"</span>);</span><br></pre></td></tr></table></figure><p>其实这些就是利用存放在<code>Cookie</code>中的<code>JSESSIONID</code>来实现的。</p><h2>5.HTTP和HRTTPS的关系</h2><p>来说一下SSL(Security Sockets Layer，安全套接层)</p><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统对外的API，SSL3.0之后更名为TLS</li><li>采用身份验证和数据加密保证网络通信的安全和数据的完整性</li></ul><p>HTTPS数据传输流程：</p><ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器</li><li>浏览器验证证书合法性，并结合证书公钥加密信息发给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器</li><li>浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据</li></ul><p>这个也就不赘述了，下面直接说说区别。</p><ul><li>HTTPS需要到CA申请证书，HTTP不需要</li><li>HTTPS密文传输，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</li><li>HTTPS=HTTP+加密+认证+完整性保护，更安全</li></ul><p>但是仍然存在一定的风险：</p><ul><li>浏览器默认填充http://，请求需要进行跳转，有被劫持的风险</li><li>可以使用HSTS(HTTP Strict Transport Security)优化（这个还不未主流，面试问的少）</li></ul><h2>Socket简介</h2><p>我们知道，进程与进程直接的通信最基本的要求是：可以唯一确定进程。</p><p>在本地进程通信中，可以用PID来唯一标识一个进程。</p><p>但是PID只在本地唯一，网络中PID冲突的几率还是存在的。</p><p>我们知道，到IP层就可以唯一定位到一台主机了，TCP层(tcp协议+端口号)可以唯一定位一台主机中的一个进程。</p><p>这样，我们可以通过ip地址+协议+端口号可以唯一标识一台主机的一个进程。这样就可以通过socket进行网络通信了。</p><p>socket是对TCP/IP协议的抽象，是操作系统对外开放的接口。</p><p>socket起源于unix，而unix是遵从一切皆文件的哲学。Socket是一种基于从打开、读/写、关闭的模式实现的。客户端和服务器各自维护一个文件，在连接建立后，可以供对方读取或者读取对方内容。</p><h2>socket相关题目</h2><p>编写一个网络程序，有客户端和服务端，客户端向服务端发送一个字符串，服务器收到字符串之后打印到命令行上，然后向客户端返回该字符串的长度，最后，客户端输出服务端返回的该字符串的长度，分别用TCP和UDP两种方式去实现。</p><p>代码地址：<a href="https://github.com/sunweiguo/TcpAndUdp/" target="_blank" rel="noopener">https://github.com/sunweiguo/TcpAndUdp/</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA基础核心-理解类、对象、面向对象编程、面向接口编程</title>
      <link href="/2019/01/24/java-basic/JAVA%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/01/24/java-basic/JAVA%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>什么是类，什么是对象，什么是面向对象编程，什么是面向接口编程。学习面向对象思想的语言，比如java，第一关可能就是要理解这些概念。下面就来好好琢磨一下。</p><a id="more"></a><h2>类和对象的概念</h2><p>首先总结一下：<strong>类是一个模板，对象就是用这个模板创造出来的东西</strong>。</p><p>比如，男孩，他就是一个模板，男的就行，那么对象是什么呢？就是具体某个男孩，比如男孩<code>BOB</code>，男孩<code>fourColor</code>.</p><p>请看下面一张图：</p><p><img src="http://bloghello.oursnail.cn/javabasic4-1.png" alt="image"></p><p>男孩女孩是比较抽象的概念，是模板，左边一排就是其具体的一些对象。你看长的都不一样，有的黑，有的白，有的高，有的矮，国家地区也不一样。但是他们都属于男孩或者女孩。</p><p>那么同理，人就是一个类，男孩女孩就是人的<strong>子类</strong>，因为人可能不仅包括男孩女孩，还包括第三性别这个类。</p><p>这里还引出了JAVA特性中的继承。继承简单理解就是父类有的东西(访问级别不能是private)的，那都是你的。比如你老爸的房子，就是属于你的，你出入自由。</p><p>人还可以分为胖人和瘦人这个子类。所以只要是抽象的模板，就是一个类。</p><ul><li>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li>类：类是一个模板，它描述一类对象的行为和状态。</li></ul><p>下面就拿狗这个类来说事。狗是动物这个类的子类。</p><h2>Java中创建类</h2><h5>构造器方法说明</h5><p>需要创造一个类对象出来的时候，要用到这个类的构造器方法，那么啥是构造器方法呢？<strong>构造器方法就是创造类时的初始化方法</strong>，和类同名的方法，你可以在里面写自己的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    访问权限 构造方法名称()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">   <span class="comment">//构造方法一</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"nothing to do..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造方法二</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">//这里就可以给每条new出来的对象(狗)初始化一个名字</span></span><br><span class="line">      System.out.println(<span class="string">"hi,my name is "</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>一个相对比较完整的类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    <span class="comment">//构造器方法</span></span><br><span class="line">    <span class="comment">//声明成员变量---这个变量属于这个类</span></span><br><span class="line">    <span class="comment">//声明成员方法</span></span><br><span class="line">        <span class="comment">//在方法里面定义的变量是局部变量，区别于成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"nothing to do..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">       <span class="comment">//这里就可以给每条new出来的对象(狗)初始化一个名字</span></span><br><span class="line">       System.out.println(<span class="string">"hi,my name is "</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//狗的颜色--成员属性</span></span><br><span class="line">    <span class="keyword">public</span> String color;<span class="comment">//一般是private，赋值用set方法，取值用get方法，这里只是演示</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//狗的行为，它会叫---成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"我会叫：汪汪汪~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>创建对象</h2><p>语法：</p><blockquote><p>类名 对象名 = new 类名() ;</p></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog fourcolor ;    // 先声明一个 Dog 类的对象 fourcolor</span><br><span class="line">fourcolor = new Dog(&quot;fourcolor&quot;) ;  // 用 new 关键字实例化 Dog 的对象 fourcolor,此时调用构造方法二</span><br></pre></td></tr></table></figure><p>通过<code>Dog</code>这个类可以创造出<code>fourcolor</code>对象.下面我才能操作这个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//让它的颜色为黑色</span><br><span class="line">fourcolor.color = &quot;black&quot;;</span><br><span class="line">//让它叫</span><br><span class="line">fourcolor.say();</span><br></pre></td></tr></table></figure><h2>面向对象</h2><p>在理解了什么是类，什么是对象，就可以来说说面向对象到底是什么了。</p><p>先来说说面向过程，大家都学习过C语言。C语言就是典型的面向过程的语言。</p><p>举个例子：要把大象装进冰箱里，这件事，面向过程的程序员是这样思考的：</p><ul><li>把冰箱门儿打开。</li><li>把大象装进去。</li><li>把冰箱门儿关上。</li></ul><p>上面的每一件事都用一个函数来实现。抽象为下面三个函数：</p><ul><li>openTheDoor()；</li><li>pushElephant()；</li><li>closeTheDoor()；</li></ul><p>这样不挺好的吗？为什么不用面向过程的这种思维来编程呢，还要搞出什么面向对象来。</p><p>需求又来啦：</p><ul><li>「我要把大象装微波炉里」</li><li>「我要把狮子也装冰箱里」</li><li>「我要把大象装冰箱，但是门别关，敞着就行」</li></ul><p>这个时候，面向过程的程序员就悲剧了，来一个需求我就写一个函数，我还能下班吗？</p><p>面向对象从另一个角度来解决这个问题。它抛弃了函数，把「对象」作为程序的基本单元。</p><p>面向对象的世界里，到处都是对象。即：万物皆对象。</p><p>比如人这个类，每个具体的人(对象)都要有这样的属性：身高、体重、年龄。每个人都有这样的行为：吃饭、睡觉、上厕所。</p><p>那么，这些通用的属性+方法可以构建一个模板：人这个类。因为每个具体的人（对象）都需要这些基本的东西。当然了，每个人具体什么身高、什么体重、吃什么都是不一样的，所以每个对象一般都是不一样的。但是模板是一样的。</p><p>那么，回到刚才的需求，面向对象是如何思考这件事的呢？</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>就是说，我不用亲自管开门的细节，我只要叫他开门即可。</p><div class="tip">我们创建的对象，应该是刚刚好能做完它能做的事情，不多做，不少做。多做了容易耦合，各种功能杂糅在一个对象里。比如我有一个对象叫「汽车」，可以「行驶」，可以「载人」，现在的需求是要实现「载人飞行」，就不能重用这个对象，必须新定义一个对象「飞机」来做。如果你给「汽车」插上了翅膀，赋予了它「飞行」的能力，那么新来的同学面对你的代码就会莫名其妙，无从下手。</div><p>但是不禁要问：怎么实现这种下达命令就可以自动去执行的效果呢？或者说，我怎么知道它有这个功能啊！</p><h2>面向接口编程</h2><p>现在我们把「数据」和「行为」都封装到了对象里，相当于对象成了一个黑匣子，那我们怎么知道对象具有什么样的能力呢？这个问题的关键就是接口。</p><p>因为无论是把大象装进洗衣机还是冰箱，都要求洗衣机或者冰箱有开门和关门的功能。这个时候，我们就可以抽象出来一个接口：【自动门】。这个接口里面定义两个能力：【开门】和【关门】。</p><p>让洗衣机、冰箱、微波炉这些带门的东西全部实现【自动门】接口。</p><p>这个时候，每个具体的实现可能略有不同，比如冰箱开门是往外拽，但是洗衣机开门可能是往上翻盖子。</p><p>此时，我有一个需求，把大象放进冰箱。我一看，冰箱实现了【自动门】这个接口，里面有【开门】和【关门】两个方法，ok，我知道冰箱是可以开门和关门了，那就好办了。我直接下达命令即可。还是跟上面一样的步骤.</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>此时，需要将狮子也装冰箱里。那还是一样：</p><ul><li>向冰箱下达「开门」的命令。</li><li>向狮子下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>此时，我要把大象装冰箱，但是门别关，敞着就行，那就：</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li></ul><p>是不是很方便？冰箱也可以换，我可以换成任何东西，只要实现了这个接口，这些东西就都有这些能力，那我才不管里面到底怎么实现的呢，直接下达【开门】【关门】命令即可。</p><p>这也引入了JAVA特性中另一个特性：封装。外界不知道里面实现细节，只需要知道它的功能和入参即可。</p><p>这就是面向过程和面向对象编程的区别，也顺带地理解了什么是面向接口编程。这是学习JAVA最基础也是最核心的点。</p><p>整理自：</p><ul><li><a href="https://tryenough.com/java05" target="_blank" rel="noopener">https://tryenough.com/java05</a></li><li><a href="http://www.woshipm.com/pmd/294180.html" target="_blank" rel="noopener">http://www.woshipm.com/pmd/294180.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java字符串核心一网打尽</title>
      <link href="/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/"/>
      <url>/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/</url>
      <content type="html"><![CDATA[<p>对字符串中最核心的点：对象创建和动态加入常量池这些点进行深入分析。</p><a id="more"></a><p>比如有两个面试题：</p><p>Q1：<code>String s = new String(&quot;abc&quot;);</code> 定义了几个对象。</p><p>Q2：如何理解<code>String</code>的<code>intern</code>方法？</p><p>A1：对于通过 <code>new</code> 产生的对象，会先去常量池检查有没有 “abc”，如果没有，先在常量池创建一个 “abc” 对象，然后在堆中创建一个常量池中此 “abc” 对象的拷贝对象。所以答案是：一个或两个。如果常量池中原来没有 ”abc”, 就是两个。如果原来的常量池中存在“abc”时，就是一个。</p><p>A2：当一个<code>String</code>实例调用<code>intern()</code>方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><h2>字面量和运行时常量池</h2><p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。</p><p>在JVM运行时区域的方法区中，有一块区域是运行时常量池，主要用来存储编译期生成的各种字面量和符号引用。</p><p>了解过JVM就会知道，在java代码被javac编译之后，文件结构中是包含一部分<code>Constant pool</code>的。比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译后，常量池内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #2 = String             #21            // abc</span><br><span class="line">  #3 = Class              #22            // StringDemo</span><br><span class="line">  #4 = Class              #23            // java/lang/Object</span><br><span class="line">  ...</span><br><span class="line">  #16 = Utf8               s</span><br><span class="line">  ..</span><br><span class="line">  #21 = Utf8               abc</span><br><span class="line">  #22 = Utf8               StringDemo</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p>上面的Class文件中的常量池中，比较重要的几个内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#16 = Utf8               s</span><br><span class="line">#21 = Utf8               abc</span><br><span class="line">#22 = Utf8               StringDemo</span><br></pre></td></tr></table></figure><p>上面几个常量中，<code>s</code>就是前面提到的符号引用，而<code>abc</code>就是前面提到的字面量。而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。</p><h2>new String创建了几个对象</h2><p>下面，我们可以来分析下<code>String s = new String(&quot;abc&quot;);</code>创建对象情况了。</p><p>这段代码中，我们可以知道的是，在编译期，符号引用<code>s</code>和字面量<code>abc</code>会被加入到Class文件的常量池中。由于是<code>new</code>的方式，在类加载期间，先去常量池检查有没有 “abc”，如果没有，先在常量池创建一个 “abc” 对象。</p><p>在运行期间，在堆中创建一个常量池中此 “abc” 对象的拷贝对象。</p><h2>运行时常量池的动态扩展</h2><p>编译期生成的各种字面量和符号引用是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期像运行时常量池中增加常量。那就是String的<code>intern</code>方法。</p><p>当一个String实例调用<code>intern()</code>方法时，JVM会查找常量池中是否有相同<code>Unicode</code>的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个<code>Unicode</code>等于str的字符串并返回它的引用；</p><p><code>intern()</code>有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。</p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s==s1:"</span>+(s==s1));</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s==s2:"</span>+(s==s2));</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1==s2:false</span><br><span class="line">s2==s3:true</span><br></pre></td></tr></table></figure><p>你可以简单的理解为<code>String s1 = &quot;hello world&quot;;</code>和<code>String s3 = new String(&quot;hello world&quot;).intern();</code>做的事情是一样的（但实际有些区别，这里暂不展开）。都是定义一个字符串对象，然后将其字符串字面量保存在常量池中，并把这个字面量的引用返回给定义好的对象引用。</p><p>对于<code>String s3 = new String(&quot;hello world&quot;).intern();</code>，在不调<code>intern</code>情况，<code>s3</code>指向的是JVM在堆中创建的那个对象的引用的（如<code>s2</code>）。但是当执行了<code>intern</code>方法时，<code>s3</code>将指向字符串常量池中的那个字符串常量。</p><p>由于<code>s1</code>和<code>s3</code>都是字符串常量池中的字面量的引用，所以<code>s1</code>==<code>s3</code>。但是，<code>s2</code>的引用是堆中的对象，所以<code>s2!=s1</code>。</p><h2>intern的正确用法</h2><p>不知道，你有没有发现，在<code>String s3 = new String(&quot;abc&quot;).intern();</code>中，其实<code>intern</code>是多余的？</p><p>因为就算不用<code>intern</code>，“abc&quot;作为一个字面量也会被加载到Class文件的常量池”&quot;，进而加入到运行时常量池中，为啥还要多此一举呢？到底什么场景下才会用到<code>intern</code>呢?<br>在解释这个之前，我们先来看下以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = s1 + s2;</span><br><span class="line">String s4 = <span class="string">"hello"</span> + <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><p>在经过反编译后，得到代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = (<span class="keyword">new</span> StringBuilder()).append(s1).append(s2).toString();</span><br><span class="line">String s4 = <span class="string">"helloworld"</span>;</span><br></pre></td></tr></table></figure><p>这就是阿里巴巴文档里为什么规定循环拼接字符串不准使用&quot;+&quot;而必须使用<code>StringBuilder</code>，因为反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个 <code>StringBuilder</code> 对象，然后进行<code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。</p><p>不恰当的方式形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"start"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    str = str + <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，言归正传，可以发现，同样是字符串拼接，<code>s3</code>和<code>s4</code>在经过编译器编译后的实现方式并不一样。<code>s3</code>被转化成<code>StringBuilder</code>及<code>append</code>，而<code>s4</code>被直接拼接成新的字符串。</p><p>如果你感兴趣，你还能发现，<code>String s4 = s1 + s2;</code> 经过编译之后，常量池中是有两个字符串常量的分别是 <code>hello</code>、<code>world</code>（其实<code>hello</code>和<code>world</code>是<code>String s1 = &quot;hello&quot;;</code>和<code>String s2 = &quot;world&quot;;</code>定义出来的），拼接结果<code>helloworld</code>并不在常量池中。</p><p>如果代码只有<code>String s4 = &quot;hello&quot; + &quot;world&quot;;</code>，那么常量池中将只有<code>helloworld</code>而没有<code>hello</code>和 <code>world</code>。</p><p><strong>究其原因，是因为常量池要保存的是已确定的字面量值</strong>。也就是说，对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串。</p><p>如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成<code>StringBuilder.append</code>，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。</p><p>那么，有了这个特性了，<code>intern</code>就有用武之地了。<strong>那就是很多时候，我们在程序中用到的字符串是只有在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中</strong>。</p><p>这时候，对于那种可能经常使用的字符串，使用<code>intern</code>进行定义，每次JVM运行到这段代码的时候，就会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了。</p><h2>总结</h2><h6>第一种情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(str1 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><ul><li>栈中开辟一块空间存放引用str1；</li><li>String池中开辟一块空间，存放String常量&quot;abc&quot;；</li><li>引用str1指向池中String常量&quot;abc&quot;；</li><li>str1所指代的地址即常量&quot;abc&quot;所在地址，输出为true</li></ul><h6>第二种情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); </span><br><span class="line">System.out.println(str2 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><ul><li>栈中开辟一块空间存放引用str2；</li><li>堆中开辟一块空间存放一个新建的String对象&quot;abc&quot;；</li><li>引用str2指向堆中的新建的String对象&quot;abc&quot;；</li><li>str2所指代的对象地址为堆中地址，而常量&quot;abc&quot;地址在池中，输出为false；</li></ul><h6>第三、四种情况</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（3）</span></span><br><span class="line">String str1 = <span class="string">"a"</span>；</span><br><span class="line">String str2 = <span class="string">"b"</span>；</span><br><span class="line">String str3 = str1 + <span class="string">"b"</span>；</span><br><span class="line"><span class="comment">//str1 和 str2 是字符串常量，所以在编译期就确定了。</span></span><br><span class="line"><span class="comment">//str3 中有个 str1 是引用，所以不会在编译期确定。</span></span><br><span class="line"><span class="comment">//又因为String是 final 类型的，所以在 str1 + "b" 的时候实际上是创建了一个新的对象，在把新对象的引用传给str3。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）</span></span><br><span class="line"><span class="keyword">final</span> String str1 = <span class="string">"a"</span>；</span><br><span class="line">String str2 = <span class="string">"b"</span>；</span><br><span class="line">String str3 = str1 + <span class="string">"b"</span>；</span><br><span class="line"><span class="comment">//这里和(3)的不同就是给 str1 加上了一个final，这样str1就变成了一个常量。</span></span><br><span class="line"><span class="comment">//这样 str3 就可以在编译期中就确定了</span></span><br></pre></td></tr></table></figure><p>这里的细节在上面已经详细说明了。</p><h6>第五种情况</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"ab"</span>；</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str1== str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2.intern() == str1);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>整理自：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4OTA3NDQ0Nw==&amp;mid=2455545837&amp;idx=1&amp;sn=5dde0e68c22e1827cc7422d1af39a2de&amp;chksm=fb9cbb8dcceb329b88dc91fe4c6a9d6535752cdd1191092d93da665b051f16c06bc9e0e2e508&amp;mpshare=1&amp;scene=24&amp;srcid=0121duABpN7IHaUl1JxPtp66&amp;ascene=14&amp;devicetype=android-26&amp;version=2700003b&amp;nettype=WIFI&amp;abtest_cookie=BgABAAgACgALABIAEwAUAAcAnoYeACaXHgBXmR4Am5keAJ2ZHgC3mR4A0pkeAAAA&amp;lang=zh_CN&amp;pass_ticket=UZ59UG%2Bqu2i5egH9vmxuu5prus%2FoCSM%2B4QOgzET8cSVcTyIG%2BDpQQbT5Prwgm96v&amp;wx_header=1" target="_blank" rel="noopener">我终于搞清楚了和String有关的那点事儿</a></li><li><a href="https://www.jianshu.com/p/2624036c9daa" target="_blank" rel="noopener">https://www.jianshu.com/p/2624036c9daa</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java字符串</title>
      <link href="/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>关于java字符串不可变特性的深入理解。</p><a id="more"></a><h2>什么是不可变对象？</h2><p>众所周知， 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ 可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><h2>区分对象和对象的引用</h2><p>对于Java初学者， 对于String是不可变对象总是存有疑惑。看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);  </span><br><span class="line">  </span><br><span class="line">s = <span class="string">"123456"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = 123456</span><br></pre></td></tr></table></figure><p>首先创建一个 String 对象 <code>s</code> ，然后让 <code>s</code> 的值为 <code>ABCabc</code> ， 然后又让 <code>s</code> 的值为 <code>123456</code> 。 从打印结果可以看出，<code>s</code> 的值确实改变了。那么怎么还说 String 对象是不可变的呢？</p><p>其实这里存在一个误区：<strong>s只是一个String对象的引用，并不是对象本身</strong>。</p><p>对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。</p><p>引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。</p><p>也就是说，<code>s</code> 只是一个引用，它指向了一个具体的对象，当 s=“123456”; 这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个新的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。内存结构如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="image"></p><h2>为什么String对象是不可变的？</h2><p>要理解 String 的不可变性，首先看一下 String 类中都有哪些成员变量。 在JDK1.6中，String 的成员变量有以下几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>在JDK1.7和1.8中，String 类做了一些改动，主要是改变了<code>substring</code>方法执行时的行为，这和本文的主题不相关。JDK1.7中 String 类的主要成员变量就剩下了两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>由以上的代码可以看出， <strong>在Java中 String 类其实就是对字符数组的封装</strong>。</p><p>JDK6中， <code>value</code>是String封装的数组，<code>offset</code>是String在这个value数组中的起始位置，<code>count</code>是String所占的字符的个数。</p><p>在JDK7中，只有一个<code>value</code>变量，也就是<code>value</code>中的所有字符都是属于<code>String</code>这个对象的。这个改变不影响本文的讨论。</p><p>除此之外还有一个<code>hash</code>成员变量，是该 String 对象的哈希值的缓存，这个成员变量也和本文的讨论无关。在Java中，数组也是对象。</p><p>所以<code>value</code>也只是一个引用，它指向一个真正的数组对象。其实执行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = “ABCabc<span class="string">";</span></span><br></pre></td></tr></table></figure><p>这句代码之后，真正的内存布局应该是这样的：</p><p><img src="http://xiaozhao.oursnail.cn/String%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="image"></p><p><code>value</code>，<code>offset</code>和<code>count</code>这三个变量都是<code>private</code>的，并且没有提供<code>setValue</code>， <code>setOffset</code>和<code>setCount</code>等公共方法来修改这些值，所以在<code>String</code>类的外部无法修改<code>String</code>。也就是说一旦初始化就不能修改， 并且在<code>String</code>类的外部不能访问这三个成员。</p><p>此外，<code>value</code>，<code>offset</code>和<code>count</code>这三个变量都是<code>final</code>的， 也就是说在 String 类内部，一旦这三个值初始化了， 也不能被改变。所以可以认为 String 对象是不可变的了。</p><p>那么在 String 中，明明存在一些方法，调用他们可以得到改变后的值。这些方法包括<code>substring</code>， <code>replace</code>， <code>replaceAll</code>， <code>toLowerCase</code>等。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//ABCabc</span></span><br><span class="line">a = a.replace(<span class="string">'A'</span>, <span class="string">'a'</span>);  </span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//aBCabc</span></span><br></pre></td></tr></table></figure><p>那么<code>a</code>的值看似改变了，其实也是同样的误区。再次说明， <code>a</code>只是一个引用， 不是真正的字符串对象，在调用<code>a.replace('A', 'a')</code>时， 方法内部创建了一个新的String对象，并把这个心的对象重新赋给了引用a。String中<code>replace</code>方法的源码可以说明问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);<span class="comment">//new出了新的String对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>String对象真的不可变吗？</h2><p>从上文可知String的成员变量是<code>private final</code> 的，也就是初始化之后不可改变。那么在这几个成员中， <code>value</code>比较特殊，因为他是一个引用变量，而不是真正的对象。</p><p><code>value</code>是<code>final</code>修饰的，也就是说<code>final</code>不能再指向其他数组对象，那么我能改变<code>value</code>指向的数组吗？</p><p>比如将数组中的某个位置上的字符变为下划线“_”。 至少在我们自己写的普通代码中不能够做到，因为我们根本不能够访问到这个<code>value</code>引用，更不能通过这个引用去修改数组。<br>那么用什么方式可以访问私有成员呢？</p><p>没错，用反射， 可以反射出String对象中的<code>value</code>属性， 进而改变通过获得的<code>value</code>引用改变数组的结构。下面是实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s  </span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;   </span><br><span class="line">      </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取String类中的value字段  </span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//改变value属性的访问权限  </span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值  </span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符  </span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;  </span><br><span class="line">      </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中，<code>s</code>始终引用的同一个 String 对象，但是再反射前后，这个 String 对象发生了变化， 也就是说，通过反射是可以修改所谓的“不可变”对象的。但是一般我们不这么做。</p><p>这个反射的实例还可以说明一个问题：<strong>如果一个对象，他组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final 的，但是这个Wheel对象内部的状态可以改变， 那么就不能很好的保证Car对象不可变。</strong></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521" target="_blank" rel="noopener">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Integer拆箱和装箱</title>
      <link href="/2019/01/23/java-basic/Integer%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1/"/>
      <url>/2019/01/23/java-basic/Integer%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1/</url>
      <content type="html"><![CDATA[<p>由于笔试经常遇到，所以这里整理一下。将Integer这一块一网打尽。</p><a id="more"></a><h2>拆箱和装箱</h2><p>这里以面试笔试经常出现的<code>Integer</code>类型为例，请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*第一组*/</span></span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    Integer i2 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i == i2);</span><br><span class="line"></span><br><span class="line">    Integer i3 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    Integer i4 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第二组*/</span></span><br><span class="line">    Integer i5 = <span class="number">128</span>;</span><br><span class="line">    Integer i6 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i5 == i6);</span><br><span class="line"></span><br><span class="line">    Integer i7 = <span class="number">127</span>;</span><br><span class="line">    Integer i8 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i7 == i8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第三组*/</span></span><br><span class="line">    Integer i9 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">int</span> i10 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i9 == i10);</span><br><span class="line"></span><br><span class="line">    Integer i11 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    <span class="keyword">int</span> i12 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i11== i12);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第四组*/</span></span><br><span class="line">    Integer i13 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    Integer i14 = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">    System.out.println(i13 == i14);</span><br><span class="line"></span><br><span class="line">    Integer i15 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    Integer i16 = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">    System.out.println(i13 == i14);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第五组*/</span></span><br><span class="line">    Integer i17 = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">    Integer i18 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i17 == i18);</span><br><span class="line"></span><br><span class="line">    Integer i19 = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">    Integer i20 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i19 == i20);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>翻开源码(jdk8)，我们可以看到一个私有的静态类，叫做整形缓存。顾名思义，就是缓存某些整型值，我们可以看到，它默认将-127-128之间数字封装成对象，放进一个常量池中，以后定义类似于<code>Integer a = 1</code>里面的<code>a</code>就可以直接从这个常量池中取对象即可，不需要重新<code>new</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Integer.valueOf()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，也是先看看是不是在-127到128之间的范围，是的话就从 <code>cache</code> 中取出相应的 <code>Integer</code> 对象即可。</p><ul><li>第一组中<ul><li>第一种情况，<code>i</code> 是创建的一个<code>Integer</code>的对象，取值是128。<code>i2</code> 是进行自动装箱的实例，因为这里超出了-128到127的范围，所以是创建了新的<code>Integer</code>对象。由于<code>==</code>比较的是地址，所以两者必然不一样。</li><li>第二种情况就不一样了，<code>i4</code>是不需要自己<code>new</code>，而是可以直接从缓存中取，但是<code>i3</code>是<code>new</code>出来的，地址还是不一样。</li></ul></li><li>第二组中<ul><li>第一种情况是都超出范围了，所以都要自己分别去<code>new</code>，所以不一样</li><li>第二种情况是在范围内，都去缓存中取，实际上都指向同一个对象，所以一样</li></ul></li><li>第三组中<ul><li><code>i10</code>和<code>i12</code>都是<code>int</code>型，<code>i9</code>和<code>i11</code>与它们比较的时候都要自动拆箱，所以比较的是数值，所以都一样</li></ul></li><li>第四组中<ul><li>与第一组原理一样</li></ul></li><li>四五组中<ul><li>与第二组原理一样</li></ul></li></ul><p>所以啊，<code>new Integer()</code>是每次都直接<code>new</code>对象出来，而<code>Integer.valueOf()</code>可能会用到缓存，所以后者效率高一点。</p><h2>总结</h2><ul><li><code>int</code> 和 <code>Integer</code> 在进行比较的时候， <code>Integer</code> 会进行拆箱，转为 <code>int 值与</code>int` 进行比较。</li><li><code>Integer</code> 与 <code>Integer</code> 比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是 <code>-128&lt;= x&lt;=127</code> 的整数，将会直接缓存在 <code>IntegerCache</code> 中，那么当赋值在这个区间的时候，不会创建新的 <code>Integer</code> 对象，而是从缓存中获取已经创建好的 <code>Integer</code> 对象。二：当大于这个范围的时候，直接 <code>new Integer</code> 来创建 <code>Integer</code> 对象。</li><li><code>new Integer(1)</code> 和 <code>Integer a = 1</code> 不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从 <code>IntegerCache</code> 中获取的。那么 <code>Integer a = 128</code>, 大于该范围的话才会直接通过 <code>new Integer(128)</code>创建对象，进行装箱。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式事务解决方案思考</title>
      <link href="/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
      <url>/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>在分布式系统中，最头疼的就是分布式事务问题，处理起来一定要小心翼翼。由于没有此方面实战，本文就从理论上看看比较好的分布式事务处理方案。</p><a id="more"></a><h2>什么是分布式事务</h2><p>众所周知，数据库能实现本地事务，也就是在同一个数据库中，你可以允许一组操作要么全都正确执行，要么全都不执行。这里特别强调了<strong>本地事务</strong>，也就是目前的数据库只能支持同一个数据库中的事务。但现在的系统往往采用微服务架构，业务系统拥有独立的数据库，因此就出现了<strong>跨多个数据库的事务需求</strong>，这种事务即为“分布式事务”。那么在目前数据库不支持跨库事务的情况下，我们应该如何实现分布式事务呢？</p><p>比如用户下单过程。当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：</p><ul><li>用户通过商品系统浏览商品，他看中了某一项商品，便点击下单</li><li>此时订单系统会生成一条订单</li><li>订单创建成功后，支付系统提供支付功能</li><li>当支付完成后，由积分系统为该用户增加积分</li></ul><p>上述步骤2、3、4需要在一个事务中完成。对于传统单体应用而言，实现事务非常简单，只需将这三个步骤放在一个方法A中，再用Spring的<code>@Transactional</code>注解标识该方法即可。Spring通过数据库的事务支持，保证这些步骤要么全都执行完成，要么全都不执行。但在这个微服务架构中，这三个步骤涉及三个系统，涉及三个数据库，此时我们必须在数据库和应用系统之间，通过某项黑科技，实现分布式事务的支持。</p><h2>方案1：基于可靠消息服务的分布式事务</h2><p><img src="http://bloghello.oursnail.cn/mama11-1.png" alt="image"></p><ul><li>在系统A处理任务A前，首先向消息中间件发送一条消息</li><li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li><li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li><li>系统A收到确认应答后，则可以开始处理任务A；</li><li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。<br>但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li><li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li><li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li></ul><p>上述过程中，如果任务A处理失败，那么需要进入回滚流程:</p><ul><li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li><li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li></ul><p>上面所介绍的<code>Commit</code>和<code>Rollback</code>都属于理想情况，但在实际系统中，<code>Commit</code>和<code>Rollback</code>指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是超时询问机制。</p><p>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的<code>Commit</code>或<code>Rollback</code>指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p><ul><li>提交  若获得的状态是“提交”，则将该消息投递给系统B。</li><li>回滚  若获得的状态是“回滚”，则直接将条消息丢弃。</li><li>处理中  若获得的状态是“处理中”，则继续等待。</li></ul><p>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p><p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。</p><p>注意，这个方案需要消息队列具有事务消息的能力，阿里的<code>RocketMQ</code>可以实现这个目标。其他的MQ还不行。</p><h2>方案2：最大努力通知（定期校对）</h2><p><img src="http://bloghello.oursnail.cn/mama11-2.png" alt="image"></p><ul><li>上游系统在完成任务后，向消息中间件同步地发送一条消息，确保消息中间件成功持久化这条消息，然后上游系统可以去做别的事情了；</li><li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；</li><li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</li></ul><p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p><ul><li>消息中间件向下游系统投递消息失败</li><li>上游系统向消息中间件发送消息失败</li></ul><p>对于第一种情况，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，<strong>如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“定期校对”</strong>。</p><p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p><p>对于第二种情况，需要在上游系统中建立消息重发机制。<strong>可以在上游系统建立一张本地消息表，并将 任务处理过程 和 向本地消息表中插入消息 这两个步骤放在一个本地事务中完成</strong>。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。</p><p>如果这两步都执行成功，那么该本地事务就完成了。<strong>接下来会有一个专门的消息发送者不断地发送本地消息表中的消息</strong>，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p><p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过重试机制+定期校对实现分布式事务，但相比于第一种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p><p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。还有其他的一些解决思路，这里就暂时只描述这些。后续再学习。</p><p>参考自：<a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">https://juejin.im/post/5aa3c7736fb9a028bb189bca</a></p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>库存扣减问题</title>
      <link href="/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>库存扣减问题一直是秒杀中最关键的一个点。如果把控不好，扣成负数，那可就麻烦了，如么如何保证不会出现超卖还能保证性能呢？</p><a id="more"></a><h2>一、扣减库存问题分析</h2><p>在提交订单的时候，要扣减库存，对于sql，是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>首先这条sql存在超卖问题，很有可能会减成负数。可能会改成如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span> <span class="keyword">and</span> stock &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样好像解决了超卖问题。但是引入了新的问题。由于库存牵涉进货、补货等系统，所以是个独立的服务。</p><p>并且，比如我是通过MQ去通知库存进行扣减库存，但是由于网络抖动，请求扣减库存没有结果，这个时候可能需要进行重试。重试之后，可能成功了，这个时候，有可能这两次都成功了。那么，一个用户买一样东西，但是库存扣了两遍。这就是幂等。如果不做幂等处理，重试会出现上述这种致命问题。</p><p>那么如何做到幂等呢？</p><p>实际上就是追求数据一致性。那么就可以考虑锁来保证，比如我这里用乐观锁来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> stock,<span class="keyword">version</span> <span class="keyword">from</span> t_stock;</span><br><span class="line">if(stock &gt; 用户购买数量)</span><br><span class="line">    <span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span> = last_version</span><br></pre></td></tr></table></figure><p>但是，一旦出现并发，那么可能这个用户是执行update失败的，所以还需要去重试(guava retry或者spring retry都可以优雅地实现重试)，直到成功或者库存已经不足。</p><p>那么，在少量并发的情况下，可以考虑乐观锁，要不然会大量失败，此时需要用悲观锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_stock <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">下面执行<span class="keyword">update</span>操作。。。</span><br></pre></td></tr></table></figure><p>在一个事务内，第一句为<code>select for update</code>，那么这一行数据就会被本线程锁住，整个事务执行完才能允许其他线程进来。</p><p>存在的问题：一个线程锁住这行数据，那么其他线程都要等待，效率很低。</p><p>那么，如何保证数据一致性，还可以提高效率呢？</p><p>对于扣减库存，往往是先在redis中进行扣减库存。redis是单线程，是高速串行执行，不存在并发问题。</p><p>如果是单机redis，可以在同一个事务中保证一次性执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch stock</span><br><span class="line">multi</span><br><span class="line">if stock &gt; count</span><br><span class="line">    stock = stock - count;</span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/mama8-1.png" alt="image"></p><p>但是不能在集群中用（分布在不同节点上时），所以用watch不通用。</p><p>redis都是原子操作，比如自增:incrby，用这个就可以判断库存是否够。就是所谓的redis预减库存。</p><p>但是在实际中，库存表里有两个字段：库存和锁定库存。</p><p>锁定库存是表示多少用户真正下单了，但是还没有支付。锁定库存+库存=总库存，等用户真正支付之后，就可以将锁定库存减掉。那么，此时，redis中需要存库存和锁定库存这两个值，上面单一的原子操作就不行了。</p><p>解决方案：redis+lua</p><p>为什么要用lua呢？可以用lua将一系列操作封装起来执行，输入自己的参数即可。lua脚本在redis中执行是串行的、原子性的。</p><p>OK，下面就实战一波：根据skuId查询缓存中的库存值。</p><h2>二、查询库存（设置库存）</h2><p>首先，我们要明确一点，redis中的库存初始值是由后台的系统人工提前配置好的，在进行商品销售时（用户下单时），直接从redis中先进行库存的扣减。</p><p>这里呢，我们没有进行初始化，而是在程序中进行判断：如果redis已经有了这个库存值，就将他查询出来返回；否则，就去数据库查询，然后对redis进行初始化。</p><p>这里的一个问题是：如果存在并发问题，但是我们初始化两个值（库存值和库存锁定值），这里采用lua脚本，在lua脚本中完成初始化，并且对于两个用户同时进行初始化库存的问题，可以在lua中进行判断,因为redis是单线程，lua也是单线程，不用担心会同时初始化两次。</p><p>下面首先写一个接口，根据skuid查询库存(库存和锁定库存)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/query/&#123;skuId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult&lt;Stock&gt; <span class="title">queryStock</span><span class="params">(@PathVariable <span class="keyword">long</span> skuId)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;Stock&gt;  result = <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"库存查询成功"</span>);</span><br><span class="line">    Stock stock = <span class="keyword">new</span> Stock();</span><br><span class="line">    stock.setSkuId(skuId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stockCount = stockService.queryStock(skuId);</span><br><span class="line"></span><br><span class="line">    stock.setStock(stockCount);</span><br><span class="line">    result.setData(stock);</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queryStock</span><span class="params">(<span class="keyword">long</span> skuId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先查redis</span></span><br><span class="line">    Stock stock ;</span><br><span class="line">    String stockKey = Constants.CACHE_PRODUCT_STOCK+<span class="string">":"</span>+skuId;</span><br><span class="line">    String stockLockKey = Constants.CACHE_PRODUCT_STOCK_LOCK+<span class="string">":"</span>+skuId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只需要查询一个即可，比如我这里只查询库存就行</span></span><br><span class="line">    Object stockObj = redisTemplate.opsForValue().get(stockKey);</span><br><span class="line">    Integer stockInRedis = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">if</span>(stockObj!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stockInRedis = Integer.valueOf(stockObj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有，那么我就需要将数据库中的数据初始化到redis中</span></span><br><span class="line">    <span class="keyword">if</span>(stockInRedis==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//去数据库查询 然后对redis进行初始化</span></span><br><span class="line">        stock = stockMapper.selectBySkuId(skuId);</span><br><span class="line">        <span class="comment">//两个key和两个库存值通过lua脚本塞到redis中</span></span><br><span class="line">        <span class="comment">//这里如果发生两个用户并发初始化redis，脚本中会进行判断，如果已经初始化了，脚本就会停止执行</span></span><br><span class="line">        <span class="comment">// 设置库存不应该在这配置，应该是后台管理系统进行设置，所以正常情况下，这里redis中应该是必然存在的</span></span><br><span class="line">        <span class="comment">//如果是在后台配置，就没有必要这么复杂了</span></span><br><span class="line">        redisUtils.skuStockInit(stockKey,stockLockKey,stock.getStock().toString(),stock.getLockStock().toString());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockInRedis;<span class="comment">//缓存中有就直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存结果可能会返回设置不成功，所以还是返回数据库查询结果</span></span><br><span class="line">    <span class="keyword">return</span> stock.getStock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个工具类为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看redis是否已经初始化好库存初始值，没有就初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_CACHE_LUA =</span><br><span class="line">        <span class="string">"local stock = KEYS[1] "</span> +</span><br><span class="line">                <span class="string">"local stock_lock = KEYS[2] "</span> +</span><br><span class="line">                <span class="string">"local stock_val = tonumber(ARGV[1]) "</span> +</span><br><span class="line">                <span class="string">"local stock_lock_val = tonumber(ARGV[2]) "</span> +</span><br><span class="line">                <span class="string">"local is_exists = redis.call(\"EXISTS\", stock) "</span> +</span><br><span class="line">                <span class="string">"if is_exists == 1  then "</span> +</span><br><span class="line">                <span class="string">"   return 0 "</span> +</span><br><span class="line">                <span class="string">"else  "</span> +</span><br><span class="line">                <span class="string">"   redis.call(\"SET\", stock, stock_val) "</span> +</span><br><span class="line">                <span class="string">"   redis.call(\"SET\", stock_lock, stock_lock_val) "</span> +</span><br><span class="line">                <span class="string">"   return 1 "</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 缓存sku库存 以及锁定库存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">skuStockInit</span><span class="params">(String stockKey,String stockLockKey,String stock,String stockLock)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用jedis去执行lua脚本 输入的参数要注意顺序 都是写死的 第一组是key，第二组是stock</span></span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(STOCK_CACHE_LUA, Collections.unmodifiableList(Arrays.asList(stockKey,stockLockKey))</span><br><span class="line">                ,Collections.unmodifiableList(Arrays.asList(stock, stockLock)));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (EXCUTE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于lua脚本进行稍微的解释一下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//第一组数据是key数组；第二组数据是args数组，是与key数组对应的值，就是库存</span><br><span class="line">//我们这里第一组为[stockKey,stockLockKey],就是存在redis中的名字，这里是在service层中定义好了</span><br><span class="line">//第二组为[<span class="number">50</span>,<span class="number">0</span>]，这个值就是可以从数据库表t_stock中查询出来的</span><br><span class="line">//因为执行这段lua脚本的话，说明redis中没有缓存的数据，所以需要先查询数据库，然后将缓存设置好</span><br><span class="line">//lua中定义变量用<span class="keyword">local</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> stock = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> stock_lock = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> stock_val = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> stock_lock_val = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">//再查询一遍缓存是否存在，防止两个线程同时进来设置缓存</span><br><span class="line">//存在就不用设置缓存了，否则就设置缓存</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> is_exists = redis.call(<span class="string">"EXISTS"</span>, stock)</span><br><span class="line"><span class="keyword">if</span> is_exists == <span class="number">1</span>  <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">"SET"</span>, stock, stock_val)</span><br><span class="line">    redis.call(<span class="string">"SET"</span>, stock_lock, stock_lock_val)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那么，启动工程<code>mama-buy-stock</code>：假如我去查询skuId=1的商品：</p><p><img src="http://bloghello.oursnail.cn/mama8-2.png" alt="image"></p><p>第一次库存不存在，那么就会去查询数据库：</p><p><img src="http://bloghello.oursnail.cn/mama8-3.png" alt="image"></p><p>我们再来看看redis中的数据：</p><p><img src="http://bloghello.oursnail.cn/mama8-4.png" alt="image"></p><h2>三、扣减库存</h2><p>下面来看看扣减库存是如何实现的。因为提交订单后，往往是不止一件商品的，往往购物车内有很多件商品，同时过来，假设有五件商品，但是其中只有一件暂时没有库存了，那么我还是希望其他的四件商品能够卖出去，只是没有库存的商品就不算钱了。所以扣减库存用一个map来装，即<code>Map&lt;skuId,count&gt;</code></p><p>controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/reduce"</span>)</span><br><span class="line"><span class="keyword">public</span> ApiResult&lt;Map&lt;Long,Integer&gt;&gt; reduceStock(<span class="meta">@RequestBody</span> List&lt;StockReduce&gt; stockReduceList)&#123;</span><br><span class="line">    ApiResult result = <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"库存扣减成功"</span>);</span><br><span class="line">    Map&lt;Long,Integer&gt; resultMap =  stockService.reduceStock(stockReduceList);</span><br><span class="line">    result.setData(resultMap);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Long, Integer&gt; <span class="title">reduceStock</span><span class="params">(List&lt;StockReduce&gt; stockReduceList)</span> </span>&#123;</span><br><span class="line">    Map&lt;Long, Integer&gt; resultMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历去减redis中库存，增加锁定库存</span></span><br><span class="line">    stockReduceList.stream().forEach(param -&gt; &#123;</span><br><span class="line">        String stockKey = Constants.CACHE_PRODUCT_STOCK+<span class="string">":"</span>+param.getSkuId();</span><br><span class="line">        String stockLockKey = Constants.CACHE_PRODUCT_STOCK_LOCK+<span class="string">":"</span>+param.getSkuId();</span><br><span class="line">        Object result = redisUtils.reduceStock(stockKey,</span><br><span class="line">                                               stockLockKey,</span><br><span class="line">                                               param.getReduceCount().toString(),<span class="comment">//incrby一个负数，就是减</span></span><br><span class="line">                                               String.valueOf(Math.abs(param.getReduceCount())));<span class="comment">//incrby一个正数，就是加</span></span><br><span class="line">        <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Long)&#123;</span><br><span class="line">            <span class="comment">//库存不存在或者不足 扣减失败 sku下单失败 记录下来</span></span><br><span class="line">            resultMap.put(param.getSkuId(),-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> List)&#123;</span><br><span class="line">            <span class="comment">//扣减成功 记录扣减流水</span></span><br><span class="line">            List resultList =  ((List) result);</span><br><span class="line">            <span class="keyword">int</span> stockAftChange =  ((Long)resultList.get(<span class="number">0</span>)).intValue();</span><br><span class="line">            <span class="keyword">int</span> stockLockAftChange = ((Long) resultList.get(<span class="number">1</span>)).intValue();</span><br><span class="line">            StockFlow stockFlow = <span class="keyword">new</span> StockFlow();</span><br><span class="line">            stockFlow.setOrderNo(param.getOrderNo());</span><br><span class="line">            stockFlow.setSkuId(param.getSkuId());</span><br><span class="line">            stockFlow.setLockStockAfter(stockLockAftChange);</span><br><span class="line">            stockFlow.setLockStockBefore(stockLockAftChange+param.getReduceCount());</span><br><span class="line">            stockFlow.setLockStockChange(Math.abs(param.getReduceCount()));</span><br><span class="line">            stockFlow.setStockAfter(stockAftChange);</span><br><span class="line">            stockFlow.setStockBefore(stockAftChange+Math.abs(param.getReduceCount()));</span><br><span class="line">            stockFlow.setStockChange(param.getReduceCount());</span><br><span class="line">            stockFlowMapper.insertSelective(stockFlow);</span><br><span class="line">            resultMap.put(param.getSkuId(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于redis的操作，基本与上一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>   扣减库存lua脚本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> 0  key不存在 错误   -1 库存不足  返回list  扣减成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_REDUCE_LUA=</span><br><span class="line">        <span class="string">"local stock = KEYS[1]\n"</span> +</span><br><span class="line">                <span class="string">"local stock_lock = KEYS[2]\n"</span> +</span><br><span class="line">                <span class="string">"local stock_change = tonumber(ARGV[1])\n"</span> +</span><br><span class="line">                <span class="string">"local stock_lock_change = tonumber(ARGV[2])\n"</span> +</span><br><span class="line">                <span class="string">"local is_exists = redis.call(\"EXISTS\", stock)\n"</span> +</span><br><span class="line">                <span class="string">"if is_exists == 1 then\n"</span> +</span><br><span class="line">                <span class="string">"    local stockAftChange = redis.call(\"INCRBY\", stock,stock_change)\n"</span> +</span><br><span class="line">                <span class="string">"    if(stockAftChange&lt;0) then\n"</span> +</span><br><span class="line">                <span class="string">"        redis.call(\"DECRBY\", stock,stock_change)\n"</span> +</span><br><span class="line">                <span class="string">"        return -1\n"</span> +</span><br><span class="line">                <span class="string">"    else \n"</span> +</span><br><span class="line">                <span class="string">"        local stockLockAftChange = redis.call(\"INCRBY\", stock_lock,stock_lock_change)\n"</span> +</span><br><span class="line">                <span class="string">"        return &#123;stockAftChange,stockLockAftChange&#125;\n"</span> +</span><br><span class="line">                <span class="string">"    end "</span> +</span><br><span class="line">                <span class="string">"else \n"</span> +</span><br><span class="line">                <span class="string">"    return 0\n"</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reduceStock</span><span class="params">(String stockKey,String stockLockKey,String stockChange,String stockLockChange)</span></span>&#123;</span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(STOCK_REDUCE_LUA, Collections.unmodifiableList(Arrays.asList(stockKey,stockLockKey))</span><br><span class="line">                ,Collections.unmodifiableList(Arrays.asList(stockChange, stockLockChange)));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，一旦数据库发生异常，那么就会回滚，但是redis中是无法回滚的。这个问题不用担心，因为数据库发生异常是及其严重的问题，是很少会发生的，一旦发生，只需要去这个流水的表中去查看情况，然后去执行脚本去初始化这个redis即可。所以是可以补救的。</p><p>但是接口的幂等性还没有做。重复尝试调用这个接口（通常是发生在MQ的失败重传机制，客户端的连续点击一般是可以避免的），可能会重复减redis库存并且重复地去插入流水记录。这个问题该如何解决呢？</p><h2>四、redis分布式锁来实现幂等性</h2><p>主流的方案，比如有用一张表来控制，比如以这个orderID为唯一主键，一旦插入成功，就可以根据这个唯一主键的存在与否判断是否为重复请求（也就是说，这里的扣减库存和插入去重表放在一个事务里，去重表中有一个字段为orderId，全局唯一不重复，用唯一索引进行约束，那么插入的时候判断这个去重表是否可以插入成功，如果不成功，那么数据库操作全部回滚）。</p><p>可以用redis分布式锁给这个订单上锁。以订单id为锁，不会影响其他线程来扣减库存，所以不影响性能。</p><p>针对这个订单，第一次肯定是可以去扣减库存的，但是第二次再接收到这个请求，那么就要返回已经成功了，不要再重复扣减。</p><p>对于<code>reduceStock()</code>这个方法最前面增加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止扣减库存时MQ正常重试时的不幂等</span></span><br><span class="line"><span class="comment">//以订单ID 加个缓存锁 防止程序短时间重试 重复扣减库存 不用解锁 自己超时</span></span><br><span class="line">Long orderNo = stockReduceList.get(<span class="number">0</span>).getOrderNo();</span><br><span class="line"><span class="keyword">boolean</span> lockResult = redisUtils.distributeLock(Constants.ORDER_RETRY_LOCK+orderNo.toString(),orderNo.toString(),<span class="number">300000</span>);</span><br><span class="line"><span class="keyword">if</span>(!lockResult)&#123;</span><br><span class="line">    <span class="comment">//锁定失败 重复提交 返回一个空map</span></span><br><span class="line">    <span class="keyword">return</span>  Collections.EMPTY_MAP;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long EXCUTE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**lua脚本  在redis中 lua脚本执行是串行的 原子的 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNLOCK_LUA=</span><br><span class="line">        <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> +</span><br><span class="line">                <span class="string">"   return redis.call('del', KEYS[1]) "</span> +</span><br><span class="line">                <span class="string">"else "</span> +</span><br><span class="line">                <span class="string">"   return 0 "</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 获取分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">distributeLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span></span>&#123;</span><br><span class="line">    String result = redisTemplate.execute((RedisCallback&lt;String&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        JedisCommands commands = (JedisCommands)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> commands.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);<span class="comment">//一条命令实现setnx和setexpire这些操作，原子性</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 释放分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseDistributelock</span><span class="params">(String lockKey, String requestId)</span></span>&#123;</span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(UNLOCK_LUA, Collections.singletonList(lockKey), Collections.singletonList(requestId));<span class="comment">//lua脚本中原子性实现：get查询和delete删除这两个操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (EXCUTE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里不需要我们主动去释放分布式锁，只要设置一个大于重试时间的过期时间即可。让它自己删除。</p><p>注意redis在集群下做分布式锁，最好要用Redission。这里如果用于集群，如何lua脚本在一个事务里同时操作多个key的时候，如果要保证这个事务生效，就需要保证这几个key都要在同一个节点上。但是，比如我们这里的两个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK = <span class="string">"product:stock"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK_LOCK = <span class="string">"product:stock:lock"</span>;</span><br></pre></td></tr></table></figure><p>因为我们这里要同时对库存和锁定库存这两个key进行操作，需要放在一个事务内执行，不处理的话，一旦他们不在一个节点，那么事务就不会生效，解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK = <span class="string">"&#123;product:stock&#125;"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK_LOCK = <span class="string">"&#123;product:stock&#125;:lock"</span>;</span><br></pre></td></tr></table></figure><p>如果加上花括号，那么在进行计算hash值的时候，他们两就会是一样的，会被投放到同一个slot中，自然就保证了在同一个节点上。</p><h2>五、测试一下</h2><p><img src="http://bloghello.oursnail.cn/mama8-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mama8-5.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mama8-7.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ELK平台搭建</title>
      <link href="/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>因为要完成产品的全文搜索这个功能，所以需要准备一下ES的环境。本节安装ELK。</p><p>ELK由Elasticsearch、Logstash和Kibana三部分组件组成。</p><a id="more"></a><h2>前言</h2><p><img src="http://bloghello.oursnail.cn/mama6-2.png" alt="image"></p><p><code>Elasticsearch</code>是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，<code>restful</code>风格接口，多数据源，自动搜索负载等。<br>简单来说，他是个全文搜索引擎，可以快速地储存、搜索和分析海量数据。</p><p><code>Logstash</code>是一个完全开源的工具，它可以把分散的、多样化的日志日志，或者是其他数据源的数据信息进行收集、分析、处理，并将其存储供以后使用。</p><p><code>Kibana</code>是一个开源的分析和可视化平台，设计用于和<code>Elasticsearch</code>一起工作。</p><p>你用<code>Kibana</code>来搜索，查看，并和存储在<code>Elasticsearch</code>索引中的数据进行交互。</p><p>你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。</p><p><code>Kibana</code>使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示<code>Elasticsearch</code>查询的变化。</p><h2>一、安装ES</h2><h3>1.1 首先是安装JDK：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line"></span><br><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;</span><br><span class="line"></span><br><span class="line">tar xzf jdk-8u141-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h3>1.2 添加环境变量：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">JAVA_HOME=/opt/jdk1.8.0_141</span><br><span class="line">JAVA_JRE=$JAVA_HOME/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h3>1.3 下载6.2.4版本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.tar.gz</span><br><span class="line">tar -xzvf elasticsearch-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf elasticsearch-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line">mv elasticsearch-6.2.4 elasticsearch</span><br></pre></td></tr></table></figure><h3>1.4 配置sysctl.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#修改sysctl配置</span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"> </span><br><span class="line">#添加如下配置</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"> </span><br><span class="line">#让配置生效</span><br><span class="line">sysctl -p</span><br><span class="line"> </span><br><span class="line">#查看配置的数目</span><br><span class="line">sysctl -a|grep vm.max_map_count</span><br></pre></td></tr></table></figure><h3>1.5 elasticsearch从5.0版本之后不允许root账户启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#添加用户</span><br><span class="line">adduser dev</span><br><span class="line"> </span><br><span class="line">#设定密码</span><br><span class="line">passwd dev</span><br><span class="line"> </span><br><span class="line">#添加权限</span><br><span class="line">chown -R dev /opt/elasticsearch</span><br><span class="line"> </span><br><span class="line">#切换用户</span><br><span class="line">su dev</span><br><span class="line"> </span><br><span class="line">#查看当前用户</span><br><span class="line">who am i</span><br><span class="line"> </span><br><span class="line">#启动</span><br><span class="line">./elasticsearch/bin/elasticsearch</span><br><span class="line"> </span><br><span class="line">#后台启动</span><br><span class="line">./elasticsearch/bin/elasticsearch -d</span><br></pre></td></tr></table></figure><h3>1.6 配置limits.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line"> </span><br><span class="line">把</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"> </span><br><span class="line">改为</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line"> </span><br><span class="line">#切换用户</span><br><span class="line">su dev</span><br><span class="line"> </span><br><span class="line">#查看配置是否生效</span><br><span class="line">ulimit -Hn</span><br></pre></td></tr></table></figure><h3>1.7 配置所有用户访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><h3>1.8 添加一下内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><h3>1.9 重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep elastic</span><br><span class="line">kill -9 xxxx</span><br></pre></td></tr></table></figure><h3>1.10 测试：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200/</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;MmiaBfA&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;zjX-q5PDRLyrWMy5TiBDkw&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.2.4&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;ccec39f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2018-04-12T20:37:28.497551Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;7.2.1&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就说明成功了。</p><h2>二、安装Kibana 6.2.4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">mv kibana-6.2.4-linux-x86_64 kibana</span><br><span class="line"></span><br><span class="line">vim /opt/kibana/config/kibana.yml</span><br></pre></td></tr></table></figure><h3>2.1 添加以下内容：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.url: &quot;http://127.0.0.1:9200&quot;</span><br></pre></td></tr></table></figure><h3>2.2 切换到bin目录下，启动即可。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#不能关闭终端</span><br><span class="line">./kibana  </span><br><span class="line"></span><br><span class="line">#可关闭终端</span><br><span class="line">nohup ./kibana &amp;</span><br></pre></td></tr></table></figure><h3>2.3 开放防火墙和安全组对应的这个端口</h3><p>浏览器访问：<a href="http://106.14.163.235:5601" target="_blank" rel="noopener">http://106.14.163.235:5601</a> 看到一个控制台页面就成功啦。</p><p><img src="http://bloghello.oursnail.cn/mama6-1.png" alt="image"></p><h3>2.4 关闭这个进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ps -ef|grep kibana</span><br><span class="line"> </span><br><span class="line">ps -ef|grep 5601</span><br><span class="line"> </span><br><span class="line">都找不到 </span><br><span class="line"> </span><br><span class="line">尝试 使用 fuser -n tcp 5601</span><br><span class="line"> </span><br><span class="line">kill -9  端口</span><br><span class="line"> </span><br><span class="line">启动即可 ./kibana</span><br><span class="line"></span><br><span class="line">或者去这个目录下的.out日志中可以看到看到它占用的pid</span><br></pre></td></tr></table></figure><h2>三、logstash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf logstash-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line"># 重命名</span><br><span class="line">mv logstash-6.2.4.tar.gz logstash</span><br><span class="line"></span><br><span class="line"># 进入</span><br><span class="line">cd logstash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个配置文件 我这里是mysqltones.conf</span><br><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">      jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/mama-buy-trade&quot;</span><br><span class="line">      jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">      jdbc_password =&gt; &quot;root&quot;</span><br><span class="line"></span><br><span class="line">      jdbc_driver_library =&gt; &quot;/opt/logstash/mysql-connector-java-5.1.46-bin.jar&quot;</span><br><span class="line">      # the name of the driver class for mysql</span><br><span class="line">      jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">      jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">      jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line"></span><br><span class="line">      # mysql文件, 也可以直接写SQL语句在此处，如下：</span><br><span class="line">      statement =&gt; &quot;SELECT * from t_product&quot;</span><br><span class="line">      # statement_filepath =&gt; &quot;/opt/logstash/conf/jdbc.sql&quot;</span><br><span class="line"></span><br><span class="line">      # 这里类似crontab,可以定制定时操作，比如每10分钟执行一次同步(分 时 天 月 年)</span><br><span class="line">      schedule =&gt; &quot;*/10 * * * *&quot;</span><br><span class="line">      type =&gt; &quot;jdbc&quot;</span><br><span class="line"></span><br><span class="line">      # 是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中</span><br><span class="line">      record_last_run =&gt; &quot;true&quot;</span><br><span class="line"></span><br><span class="line">      # 是否需要记录某个column 的值,如果record_last_run为真,可以自定义我们需要 track 的 column 名称，此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.</span><br><span class="line">      use_column_value =&gt; &quot;true&quot;</span><br><span class="line"></span><br><span class="line">      # 如果 use_column_value 为真,需配置此参数. track 的数据库 column 名,该 column 必须是递增的. 一般是mysql主键</span><br><span class="line">      tracking_column =&gt; &quot;id&quot;</span><br><span class="line"></span><br><span class="line">      last_run_metadata_path =&gt; &quot;/opt/logstash/conf/last_id&quot;</span><br><span class="line"></span><br><span class="line">      # 是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录</span><br><span class="line">      clean_run =&gt; &quot;false&quot;</span><br><span class="line"></span><br><span class="line">      # 是否将 字段(column) 名称转小写</span><br><span class="line">      lowercase_column_names =&gt; &quot;false&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 此处我不做过滤处理</span><br><span class="line">filter &#123;&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    # 输出到elasticsearch的配置</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        index =&gt; &quot;jdbc&quot;</span><br><span class="line"></span><br><span class="line">        # 将&quot;_id&quot;的值设为mysql的autoid字段</span><br><span class="line">        document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">        template_overwrite =&gt; true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 这里输出调试，正式运行时可以注释掉</span><br><span class="line">    stdout &#123;</span><br><span class="line">        codec =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">./bin/logstash -f ./mysqltones.conf</span><br></pre></td></tr></table></figure><p>看到这个就说明成功了：</p><p><img src="http://bloghello.oursnail.cn/mama6-3.png" alt="image"></p><h2>安装mysql数据库</h2><p>这一步要在执行logstash之前搞定，我的是阿里云centos7.3版本，mysql版本是5.7，安装过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 下载MySQL源安装包: </span><br><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"></span><br><span class="line"># 安装MySQL源：</span><br><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm </span><br><span class="line"></span><br><span class="line"># 检查MySQL源安装情况： </span><br><span class="line">yum repolist enabled | grep &quot;mysql.*-community.*&quot;</span><br><span class="line"></span><br><span class="line"># 安装MySQL: </span><br><span class="line">yum install mysql-community-server</span><br><span class="line"></span><br><span class="line"># 启动MySQL: </span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"># 查看MySQL状态: </span><br><span class="line">systemctl status mysqld</span><br><span class="line"></span><br><span class="line"># 设置开机启动MySQL：</span><br><span class="line">systemctl enable mysqld </span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 查找并修改MySQL默认密码（注意密码要符合规范，否则会失败）：</span><br><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log </span><br><span class="line"></span><br><span class="line">mysql -uroot -p </span><br><span class="line"></span><br><span class="line">alter user root@localhost identified by &apos;你的新密码&apos;;</span><br><span class="line"></span><br><span class="line"># 远程连接测试添加远程账户：</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;用户&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"># 立即生效：</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># 退出MySQL：</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 最后远程将数据给导入数据库</span><br></pre></td></tr></table></figure><h2>安装分词器</h2><p><code>ik_max_word</code>是分词比较细腻的一款，我们就用它来做分词，首先需要安装一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接安装</span><br><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.4/elasticsearch-analysis-ik-6.2.4.zip</span><br><span class="line"> </span><br><span class="line"># 重新启动ES</span><br><span class="line">ps -ef | grep elastic</span><br><span class="line">kill -9 xxxx</span><br><span class="line">su dev</span><br><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><p>对这个分词器在<code>kibana</code>中进行测试：</p><p><img src="http://bloghello.oursnail.cn/mama6-5.png" alt="image"></p><p>下面结合数据库模拟一下：</p><p><img src="http://bloghello.oursnail.cn/mama6-4.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Curator</title>
      <link href="/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<p>从技术角度出发，注册一个网站，再高并发的时候，有可能出现用户名重复这样的问题（虽然一般情况下不会出现这种问题），如何解决呢？</p><a id="more"></a><p>从数据库角度，对于单表，我可以用<code>select .. for update</code>悲观锁实现，或者用version这种乐观锁的思想。</p><p>更好的方法是将这个字段添加唯一索引，用数据库来保证不会重复。一旦插入重复，那么就会抛出异常，程序就可以捕获到。</p><p>但是，假如我们这里分表了，以上都是针对单表，第一种方案是锁表，不行，设置唯一索引是没有用。怎么办呢？</p><p>解决方案：用ZK做一个分布式锁。</p><p>首先准备一个ZK客户端，用的是<code>Curator</code>来连接我们的ZK：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">getZkClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        CuratorFrameworkFactory.Builder builder= CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(parameters.getZkHost())</span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">        CuratorFramework framework = builder.build();</span><br><span class="line">        framework.start();</span><br><span class="line">        <span class="keyword">return</span> framework;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册用一个分布式锁来控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    InterProcessLock lock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock = <span class="keyword">new</span> InterProcessMutex(zkClient, Constants.USER_REGISTER_DISTRIBUTE_LOCK_PATH);</span><br><span class="line">        <span class="keyword">boolean</span> retry = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">3000</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                <span class="comment">//查询重复用户</span></span><br><span class="line">                User repeatedUser = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">                <span class="keyword">if</span>(repeatedUser!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> MamaBuyException(<span class="string">"用户邮箱重复"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line">                user.setNickname(<span class="string">"码码购用户"</span>+user.getEmail());</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">                <span class="comment">//跳出循环</span></span><br><span class="line">                retry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可以适当休息一会...也可以设置重复次数，不要无限循环</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (retry);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">"用户注册异常"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span>  e;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lock != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">                log.info(user.getEmail()+Thread.currentThread().getName()+<span class="string">"释放锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路非常简单，就是先尝试上锁，即<code>acquire</code>，但是有可能失败，所以这里用一个超时时间，即<code>3000ms</code>之内上不了锁就失败，进入下一次循环。最后释放锁即可。</p><p>ok，这里要来说说ZK实现分布式锁了。这里用了开源客户端<code>Curator</code>，他对于实现分布式锁进行了封装，但是，我还是想了解一下它的实现原理：</p><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>也就是说，最小的那个节点就是Leader，进来判断是不是为那个节点，是的话就可以获取到锁，反之不行。</p><blockquote><p>为什么不能通过大家一起创建节点，如果谁成功了就算获取到了锁。 多个client创建一个同名的节点，如果节点谁创建成功那么表示获取到了锁，创建失败表示没有获取到锁。</p></blockquote><p>答：使用临时顺序节点可以保证获得锁的公平性，及谁先来谁就先得到锁，这种方式是随机获取锁，会造成无序和饥饿。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Session</title>
      <link href="/2019/01/23/miscellany/06Spring%20Session/"/>
      <url>/2019/01/23/miscellany/06Spring%20Session/</url>
      <content type="html"><![CDATA[<p>在单体应用中，我们经常用http session去管理用户信息，但是到了分布式环境下，显然是不行的，因为session对于不同的机器是隔离的，而http本身是无状态的，那么就无法判断出用户在哪一个服务器上登陆的。这个时候就需要有一个独立的地方存储用户session。spring session可以做到无代码侵入的方式实现分布式session存储。</p><a id="more"></a><p>在<code>spring boot</code>开发中，我们先注册相应<code>bean</code>并且打开相应的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span> <span class="comment">//(maxInactiveIntervalInSeconds = 604800)//session超时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpSessionStrategy <span class="title">httpSessionStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> HeaderHttpSessionStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisConnectionFactory connectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line"></span><br><span class="line">        String redisHost = parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> redisPort = Integer.valueOf(parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        connectionFactory.setTimeout(<span class="number">2000</span>);</span><br><span class="line">        connectionFactory.setHostName(redisHost);</span><br><span class="line">        connectionFactory.setPort(redisPort);</span><br><span class="line"><span class="comment">//        connectionFactory.setPassword(parameters.getRedisAuth());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，这样子其实就配置好了，一开始我也云里雾里的，这是啥玩意？</p><p>其实官网的文档中讲的是最准确的。所以还是官网看看吧！</p><p>ok，来spring session的官网(<a href="https://spring.io/projects/spring-session" target="_blank" rel="noopener">https://spring.io/projects/spring-session</a>)来看看把，我们来看看1.3.4GA版本的文档(<a href="https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest</a>).</p><p>spring session可以存在很多介质中，比如我们的数据源，比如redis，甚至是mongodb等。但是我们常用的是存在redis中，结合redis的过期机制来做。</p><p>所以其实我们只要关心如何跟redis整合，以及restful接口。</p><p>我们可以看到一开始文档就告诉我们要配置一下<code>HttpSessionStrategy</code>和存储介质。从<code>HttpSessionStrategy</code>语义就能大致看出配置的是它的策略，是基于<code>header</code>的策略。这个是什么意思，下面会提到。</p><p><img src="http://bloghello.oursnail.cn/mama4-1.png" alt="image"></p><p>那么我们就来看看文档吧！</p><p><img src="http://bloghello.oursnail.cn/mama4-2.png" alt="image"></p><p>好了，我们知道了它的基本原理，下面来看看是如何在restful接口中实现用户session的管理的：</p><p><img src="http://bloghello.oursnail.cn/mama4-3.png" alt="image"></p><p>也就是说要想在restful接口应用中用这种方式，直接告诉spring session:<code>return new HeaderHttpSessionStrategy();</code>即可。进入源码我们就会知道，它默认给这个header里面放置的一条类似于token的名字是<code>private String headerName = &quot;x-auth-token&quot;;</code>。</p><p>那么在用户登陆成功之后，到底存到是什么呢，先来看看响应数据的header里面是什么：</p><p><img src="http://bloghello.oursnail.cn/mama4-4.png" alt="image"></p><p>这一串数字正好可以跟redis中对应上，我们可以先来redis中看看到底在里面存储了啥玩意：</p><p><img src="http://bloghello.oursnail.cn/mama4-5.png" alt="image"></p><p>我们已经看到了想要看到的一串字符串，这里解释一下<code>redis</code>中存储的东西：</p><ul><li><code>spring:session</code>是默认的<code>Redis HttpSession</code>前缀（<code>redis</code>中，我们常用’:’作为分割符）</li><li>每一个<code>session</code>都会有三个相关的<code>key</code>，第一个<code>key</code>(<code>spring:session:sessions:37...</code>)最为重要，它是一个<code>HASH</code>数据结构，将内存中的<code>session</code>信息序列化到了<code>redis</code>中。如本项目中用户信息,还有一些<code>meta</code>信息，如创建时间，最后访问时间等。</li><li>另外两个key，一个是<code>spring:session:expiration</code>，还有一个是<code>spring:session:sessions:expires</code>，前者是一个SET类型，后者是一个STRING类型，可能会有读者发出这样的疑问，redis自身就有过期时间的设置方式TTL，为什么要额外添加两个key来维持session过期的特性呢？redis清除过期key的行为是一个异步行为且是一个低优先级的行为，用文档中的原话来说便是，可能会导致session不被清除。于是引入了专门的expiresKey，来专门负责session的清除，包括我们自己在使用redis时也需要关注这一点。</li></ul><p>这样子，就可以用独立的<code>redis</code>来存储用户的信息，通过前端传来的<code>header</code>里面的<code>token</code>，就可以到<code>redis</code>拿出当前登陆用户的信息了。</p><p>OK，在解决了<code>spring session</code>的问题之后，下面就可以来实现登陆啦：</p><p>controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult <span class="title">login</span><span class="params">(@RequestBody @Valid User user, HttpSession session)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;UserElement&gt; result = <span class="keyword">new</span> ApiResult&lt;&gt;(Constants.RESP_STATUS_OK,<span class="string">"登录成功"</span>);</span><br><span class="line"></span><br><span class="line">    UserElement ue= userService.login(user);</span><br><span class="line">    <span class="keyword">if</span>(ue != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(Constants.REQUEST_USER_SESSION) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            session.setAttribute(Constants.REQUEST_USER_SESSION,ue);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setData(ue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就跟以前一样，将session直接存进去就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserElement <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    UserElement ue = <span class="keyword">null</span>;</span><br><span class="line">    User userExist = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">    <span class="keyword">if</span>(userExist != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//对密码与数据库密码进行校验</span></span><br><span class="line">        <span class="keyword">boolean</span> result = passwordEncoder.matches(user.getPassword(),userExist.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"密码错误"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//校验全部通过，登陆通过</span></span><br><span class="line">            ue = <span class="keyword">new</span> UserElement();</span><br><span class="line">            ue.setUserId(userExist.getId());</span><br><span class="line">            ue.setEmail(userExist.getEmail());</span><br><span class="line">            ue.setNickname(userExist.getNickname());</span><br><span class="line">            ue.setUuid(userExist.getUuid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式ID生成策略</title>
      <link href="/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
      <url>/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>分布式环境下如何保证ID的不重复呢？一般我们可能会想到用UUID来实现嘛。但是UUID一般可以获取当前时间的毫秒数再加点随机数，但是在高并发下仍然可能重复。最重要的是，如果我要用这种UUID来生成分表的唯一ID的话，重复不谈，这种随机的字符串对于我们的innodb存储引擎的插入效率是很低的。所以我们生成的ID如果作为主键，最好有两种特性：分布式唯一和有序。</p><a id="more"></a><p>唯一性就不用说了，有序保证了对索引字段的插入的高效性。我们来具体看看<code>ShardingJDBC</code>的分布式ID生成策略是如何保证。</p><h3>snowflake算法</h3><p><img src="http://bloghello.oursnail.cn/mama5-10.png" alt="image"></p><p><code>sharding-jdbc</code>的分布式ID采用<code>twitter</code>开源的<code>snowflake</code>算法，不需要依赖任何第三方组件，这样其扩展性和维护性得到最大的简化；但是<code>snowflake</code>算法的缺陷（<strong>强依赖时间，如果时钟回拨，就会生成重复的ID</strong>）。</p><p>雪花算法是由<code>Twitter</code>公布的分布式主键生成算法，<strong>它能够保证不同进程主键的不重复性，以及相同进程主键的有序性</strong>。</p><p><strong>在同一个进程中</strong>，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。例如MySQL的Innodb存储引擎的主键。</p><p>使用雪花算法生成的主键，二进制表示形式包含4部分，从高位到低位分表为：1bit符号位、41bit时间戳位、10bit工作进程位以及12bit序列号位。</p><p>雪花算法主键的详细结构见下图。</p><p><img src="http://bloghello.oursnail.cn/mama5-1.png" alt="image"></p><ul><li>符号位(1bit)</li></ul><p>预留的符号位，恒为零。</p><ul><li>时间戳位(41bit)</li></ul><p>41位的时间戳可以容纳的毫秒数是2的41次幂，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。通过计算可知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);</span><br></pre></td></tr></table></figure><p>结果约等于69.73年。<code>ShardingSphere</code>的雪花算法的时间纪元从2016年11月1日零点开始，可以使用到2086年，相信能满足绝大部分系统的要求。</p><ul><li>工作进程位(10bit)</li></ul><p>该标志在Java进程内是唯一的，如果是分布式应用部署应保证每个工作进程的id是不同的。该值默认为0，可通过调用静态方法<code>DefaultKeyGenerator.setWorkerId()</code>设置。</p><ul><li>序列号位(12bit)</li></ul><p>该序列是用来在同一个毫秒内生成不同的ID。如果在这个毫秒内生成的数量超过4096(2的12次幂)，那么生成器会等待到下个毫秒继续生成。</p><h2>时钟回拨</h2><p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为0，可通过调用静态方法<code>DefaultKeyGenerator.setMaxTolerateTimeDifferenceMilliseconds()</code>设置。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springMVC全局异常+spring包扫描包隔离+spring事务传播</title>
      <link href="/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
      <url>/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/</url>
      <content type="html"><![CDATA[<p>在开发中，springMVC全局异常+spring包扫描包隔离+spring事务传播这三个不可能不会遇到。下面来好好说说他们吧。</p><a id="more"></a><h2>1、全局异常引入原因</h2><p>假设在我们的<code>login.do</code>的<code>controller</code>方法中第一行增加一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>重新启动服务器进行用户登录操作，那么就会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    com.swg.controller.portal.UserController.login(UserController.java:<span class="number">37</span>)</span><br><span class="line">    ...其他的堆栈信息</span><br></pre></td></tr></table></figure><p>这些信息会直接显示在网页上，如果是关于数据库的错误，同样，会详细地将数据库中的字段都显示在页面上，这对于我们的项目来说是存在很大的安全隐患的。这个时候，需要用全局异常来处理，如果发生异常，我们就对其进行拦截，并且在页面上显示我们给出的提示信息。</p><p>对于<code>SpringBoot</code>，一般全局异常是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        log.error(e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createByErrorCodeMessage(Constants.RESP_STATUS_INTERNAL_ERROR,<span class="string">"系统异常，请稍后再试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(SnailmallException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">handleException</span><span class="params">(SnailmallException e)</span></span>&#123;</span><br><span class="line">        log.error(e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createByErrorCodeMessage(e.getExceptionStatus(),e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>2、引入全局异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"exception:&#123;&#125;"</span>,httpServletRequest.getRequestURI(),e);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> MappingJacksonJsonView());</span><br><span class="line">        mv.addObject(<span class="string">"status"</span>,ResponseEnum.ERROR.getCode());</span><br><span class="line">        mv.addObject(<span class="string">"msg"</span>,<span class="string">"接口异常，详情请查看日志中的异常信息"</span>);</span><br><span class="line">        mv.addObject(<span class="string">"data"</span>,e.toString());</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，再执行登陆操作之后，就不会在页面上直接显示异常信息了。有效地屏蔽了关键信息。</p><h2>3、spring和springmvc配置文件的优化</h2><h5>3.1 包隔离优化</h5><p>在编写全局异常之前，先进行了包隔离和优化，一期中的扫描包的写法是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--springmvc:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>即<code>spring</code>和<code>springmvc</code>扫描包下面的所有的<code>bean</code>和<code>controller</code>.优化后的代码配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#spring</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将controller的扫描排除掉--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#springmvc</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg.controller"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加白名单，只扫描controller，总之要将service给排除掉即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做的原因是：<code>Spring</code>和<code>SpringMVC</code>是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题。</p><p><img src="http://bloghello.oursnail.cn/zaji4-1.png" alt="image"></p><p>针对包扫描只要记住以下几点即可：</p><ul><li><code>spring</code>是父容器，<code>springmvc</code>是子容器，子容器可以访问父容器的<code>bean</code>,父容器不能访问子容器的<code>bean</code>。</li><li>只有顶级容器（<code>spring</code>）才有加强的事务能力，而<code>springmvc</code>容器的<code>service</code>是没有的。</li><li>如果<code>springmvc</code>不配置包扫描的话，页面404.</li></ul><h5>3.2 事务的传播机制</h5><p>针对事务，不得不展开说明spring事务的几种传播机制了。在 <code>spring</code> 的 <code>TransactionDefinition</code> 接口中一共定义了七种事务传播属性：</p><ol><li><code>PROPAGATION_REQUIRED</code> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择（默认）。</li><li><code>PROPAGATION_SUPPORTS</code> – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li><code>PROPAGATION_MANDATORY</code> – 支持当前事务，如果当前没有事务，就抛出异常。</li><li><code>PROPAGATION_REQUIRES_NEW</code> – 新建事务，如果当前存在事务，把当前事务挂起。</li><li><code>PROPAGATION_NOT_SUPPORTED</code> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><code>PROPAGATION_NEVER</code> – 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><code>PROPAGATION_NESTED</code> – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与<code>PROPAGATION_REQUIRED</code>类似的操作。</li></ol><h2>4、补充</h2><p><code>Spring</code>默认情况下，会对运行期例外(<code>RunTimeException</code>)，即<code>uncheck</code>异常，进行事务回滚。如果遇到<code>checked</code>异常就不回滚。如何改变默认规则：</p><ul><li>让<code>checked</code>例外也回滚：在整个方法前加上 <code>@Transactional(rollbackFor=Exception.class)</code></li><li>让<code>unchecked</code>例外不回滚： <code>@Transactional(notRollbackFor=RunTimeException.class)</code></li><li>不需要事务管理的(只查询的)方法：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li></ul><h2>5、那么什么是嵌套事务呢？</h2><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫做<code>save point</code>，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点在于那个<code>save point</code>，看以下几个问题：</p><p><strong>问题1：如果子事务回滚，会发生什么？</strong></p><p>父事务会回到进入子事务前建立的<code>save point</code>，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>问题2：如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚，为什么呢？因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理/</p><p><strong>问题3：父事务先提交，然后子事务再提交；还是子事务先提交，然后父事务再提交呢？</strong></p><p>答案是第二种情况，子事务是父事务的一部分，由父事务同意提交。</p><h2>6、spring配置文件的一些理解：</h2><blockquote><p>容器</p></blockquote><p>在<code>Spring</code>整体框架的核心概念中，容器是核心思想，就是用来管理<code>Bean</code>的整个生命周期的，而在一个项目中，容器不一定只有一个，<code>Spring</code>中可以包括多个容器，而且容器有上下层关系，目前最常见的一种场景就是在一个项目中引入<code>Spring</code>和<code>SpringMVC</code>这两个框架，那么它其实就是两个容器，<code>Spring</code>是父容器，<code>SpringMVC</code>是其子容器，并且在<code>Spring</code>父容器中注册的<code>Bean</code>对于<code>SpringMV</code>C容器中是可见的，而在<code>SpringMVC</code>容器中注册的<code>Bean</code>对于<code>Spring</code>父容器中是不可见的，也就是子容器可以看见父容器中的注册的<code>Bean</code>，反之就不行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.springmvc.test"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用统一的如下注解配置来对<code>Bean</code>进行批量注册，而不需要再给每个<code>Bean</code>单独使用<code>xml</code>的方式进行配置。</p><p>从<code>Spring</code>提供的参考手册中我们得知该配置的功能是扫描配置的<code>base-package</code>包下的所有使用了<code>@Component</code>注解的类，并且将它们自动注册到容器中，同时也扫描<code>@Controller</code>，<code>@Service</code>，<code>@Respository</code>这三个注解，因为他们是继承自<code>@Component</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。以下配置会默认声明了<code>@Required</code>、<code>@Autowired</code>、 <code>@PostConstruct</code>、<code>@PersistenceContext</code>、<code>@Resource</code>、<code>@PreDestroy</code>等注解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个是<code>SpringMVC</code>必须要配置的，因为它声明了<code>@RequestMapping</code>、<code>@RequestBody</code>、<code>@ResponseBody</code>等。并且，该配置默认加载很多的参数绑定方法，比如<code>json</code>转换解析器等。</p><h2>7、总结</h2><p>在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的<code>Bean</code>：<code>Spring</code>父容器负责所有其他非<code>@Controller</code>注解的<code>Bean</code>的注册，而<code>SpringMVC</code>只负责<code>@Controller</code>注解的<code>Bean</code>的注册，使得他们各负其责、明确边界。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis实现分布式锁</title>
      <link href="/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<p>为了讲解redis分布式锁，我将引入一个场景：定时关单。因为往往订单服务是一个集群，那么定时器会同时触发这些集群去取消订单，显然是浪费机器资源的，所以目的是：只让其中一台机器去执行取消订单即可。这里可以用分布式锁来实现。</p><a id="more"></a><p>项目是从练手项目中截取出来的，框架是基于<code>SSM</code>的<code>XML</code>形式构成，所以下面还涉及一点<code>XMl</code>对于定时器<code>spring schedule</code>的配置内容。</p><h2>1、引入目标</h2><p>定时自动对超过两个小时还未支付的订单对其进行取消，并且重置库存。</p><h2>2、配置</h2><p>首先是<code>spring</code>配置文件引入<code>spring-schedule</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task"</span><br><span class="line">...</span><br><span class="line">http://www.springframework.org/schema/task</span><br><span class="line">http://www.springframework.org/schema/task/spring-task.xsd</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>补充：针对<code>applicationContext-datasource.xml</code>中的<code>dataSource</code>读取配置文件的信息无法展现的问题，在<code>spring</code>的配置文件中增加一条配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:datasource.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2>3、定时调度代码</h2><p>此代码的主要功能是：定时调用取消订单服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseOrderTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍的时候执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">        <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">        orderService.closeOrder(hour);</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@Component</code>一定要加，否则<code>spring</code>扫描不到。</p></blockquote><blockquote><p><code>close.order.task.time.hour</code> 也是配置在<code>snailmall.properties</code>中的，这里配置的是默认的2，即两个小时，下订单超过两个小时仍然不支付，就取消该订单。</p></blockquote><p>对于<code>orderService</code>里面的具体方法：</p><p>这里是关单的具体逻辑，细节是行锁。这段代码只要知道他是具体关单的逻辑即可，不需要仔细了解代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">    Date closeDateTime = DateUtils.addHours(<span class="keyword">new</span> Date(),-hour);</span><br><span class="line">    <span class="comment">//找到状态为未支付并且下单时间是早于当前检测时间的两个小时的时间,就将其置为取消</span></span><br><span class="line">    <span class="comment">//SELECT &lt;include refid="Base_Column_List"/&gt; from mmall_order WHERE  status = #&#123;status&#125; &lt;![CDATA[ and create_time &lt;= #&#123;date&#125; ]]&gt; order by create_time desc</span></span><br><span class="line">    List&lt;Order&gt; orderList = orderMapper.selectOrderStatusByCreateTime(Const.OrderStatusEnum.NO_PAY.getCode(),DateTimeUtil.dateToStr(closeDateTime));</span><br><span class="line">    <span class="keyword">for</span>(Order order:orderList)&#123;</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo());</span><br><span class="line">        <span class="keyword">for</span>(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">            <span class="comment">//一定要用主键where条件，防止锁表。同时必须是支持MySQL的InnoDB.</span></span><br><span class="line">            Integer stock = productMapper.selectStockByProductId(orderItem.getProductId());</span><br><span class="line">            <span class="keyword">if</span>(stock == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新产品库存</span></span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.setId(orderItem.getProductId());</span><br><span class="line">            product.setStock(stock+orderItem.getQuantity());</span><br><span class="line">            productMapper.updateByPrimaryKeySelective(product);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭order</span></span><br><span class="line">        <span class="comment">//UPDATE mmall_order set status = 0 where id = #&#123;id&#125;</span></span><br><span class="line">        orderMapper.closeOrderByOrderId(order.getId());</span><br><span class="line">        log.info(<span class="string">"关闭订单OrderNo:&#123;&#125;"</span>,order.getOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>debug</code>启动项目，一分钟后就会自动执行<code>closeOrderTaskV1</code>方法了。找一个未支付的订单，进行相应测试。</p><h2>4、存在的问题</h2><p>经过实验发现，同时部署两台<code>tomcat</code>服务器，执行定时任务的时候是两台都同时执行的，显然不符合我们集群的目标，我们只需要在同一时间只有一台服务器执行这个定时任务即可。那么解决方案就是引入<code>redis</code>分布式锁。</p><p><code>redis</code>实现分布式锁，核心命令式<code>setnx</code>命令。所以阅读下面，您需要对<code>redis</code>分布式锁的基本实现原理必须要先有一定的认识才行。</p><h2>5、第一种方案</h2><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V1.png" alt="image"></p><ul><li><p>第一步：<code>setnx</code>进去，如果成功，说明塞入<code>redis</code>成功，抢占到锁</p></li><li><p>第二步：抢到锁之后，先设置一下过期时间，即后面如果执行不到<code>delete</code>，也会将这个锁自动释放掉，防止死锁</p></li><li><p>第三步：关闭订单，删除<code>redis</code>锁</p></li><li><p>存在的问题：如果因为<code>tomcat</code>关闭或<code>tomcat</code>进程在执行<code>closeOrder()</code>方法的时候，即还没来得及设置锁的过期时间的时候，这个时候会造成死锁。需要改进。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个版本，在突然关闭tomcat的时候有可能出现死锁</span></span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="comment">//设置锁，value是用当前时间+timeout进行设置的</span></span><br><span class="line">    <span class="keyword">long</span> timeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>));</span><br><span class="line">    Long setnxResult = RedisShardPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">    <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() ==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//说明被当前的tomcat进程抢到锁，下面就可以关闭订单</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给锁一个过期时间，如果因为某个原因导致下面的锁没有被删除，造成死锁</span></span><br><span class="line">    RedisShardPoolUtil.expire(lockName,<span class="number">50</span>);</span><br><span class="line">    log.info(<span class="string">"获取&#123;&#125;，ThreadName:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">    orderService.closeOrder(hour);</span><br><span class="line">    <span class="comment">//关闭订单之后就立即删除这个锁</span></span><br><span class="line">    RedisShardPoolUtil.del(lockName);</span><br><span class="line">    log.info(<span class="string">"释放&#123;&#125;，ThreadName:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName());</span><br><span class="line">    System.out.println(<span class="string">"============================================="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>6、改进</h2><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V2.png" alt="image"></p><p>图看不清，可以重新打开一个窗口看。具体的逻辑代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="comment">//设置锁，value是用当前时间+timeout进行设置的</span></span><br><span class="line">    <span class="keyword">long</span> timeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>));</span><br><span class="line">    Long setnxResult = RedisShardPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">    <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() ==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//说明被当前的tomcat进程抢到锁，下面就可以关闭订单</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//在没有拿到锁的情况下，也要进行相应的判断，确保不死锁</span></span><br><span class="line">        String lockValueStr = RedisShardPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        <span class="comment">//如果判断锁是存在的并且现在已经超时了，那么我们这个进程就有机会去占有这把锁</span></span><br><span class="line">        <span class="keyword">if</span>(lockValueStr != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr))&#123;</span><br><span class="line">            <span class="comment">//当前进程进行get set操作，拿到老的key，再塞进新的超时时间</span></span><br><span class="line">            String getSetResult = RedisShardPoolUtil.getset(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">            <span class="comment">//如果拿到的是空的，说明老的锁已经释放，那么当前进程有权占有这把锁进行操作；</span></span><br><span class="line">            <span class="comment">//如果拿到的不是空的，说明老的锁仍然占有，并且这次getset拿到的key与上面查询get得到的key一样的话，说明没有被其他进程刷新，那么本进程还是有权占有这把锁进行操作</span></span><br><span class="line">            <span class="keyword">if</span>(getSetResult == <span class="keyword">null</span> || (getSetResult != <span class="keyword">null</span> &amp;&amp; StringUtils.equals(lockValueStr,getSetResult)))&#123;</span><br><span class="line">                closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125;            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样两次的防死锁措施，不仅可以防止死锁，还可以提高效率。</p><h2>7、扩展</h2><h6>mysql四种事务隔离机制</h6><ol><li><code>read uncommitted</code>:读取未提交内容</li></ol><p>两个线程，其中一个线程执行了更新操作，但是没有提交，另一个线程在事务内就会读到该线程未提交的数据。</p><ol start="2"><li><code>read committed</code>:读取提交内容（不可重复读）</li></ol><p>针对第一种情况，一个线程在一个事务内不会读取另一个线程未提交的数据了。但是，读到了另一个线程更新后提交的数据，也就是说重复读表的时候，数据会不一致。显然这种情况也是不合理的，所以叫不可重复读。</p><ol start="3"><li><code>repeatable read</code>:可重复读（默认）</li></ol><p>可重复读，显然解决2中的问题，即一个线程在一个事务内不会再读取到另一个线程提交的数据，保证了该线程在这个事务内的数据的一致性。</p><p>对于某些情况，这种方案会出现幻影读，他对于更新操作是没有任何问题的了，但是对于插入操作，有可能在一个事务内读到新插入的数据（但是MySQL中用多版本并发控制机制解决了这个问题），所以默认使用的就是这个机制，没有任何问题。</p><ol start="4"><li><code>serializable</code>:序列化</li></ol><p>略。</p><h6>存储引擎</h6><p><code>MySQL</code>默认使用的是<code>InnoDB</code>，支持事务。还有例如<code>MyISAM</code>,这种存储引擎不支持事务，只支持只读操作，在用到数据的修改的地方，一般都是用默认的<code>InnoDB</code>存储引擎。</p><h6>索引的一个注意点</h6><p>一般类型为<code>normal</code>和<code>unique</code>，用<code>btree</code>实现，对于联合索引(字段1和字段2)，在执行查询的时候，例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> 字段<span class="number">1</span>=<span class="string">"xxx"</span> ...</span><br></pre></td></tr></table></figure><p>是可以利用到索引的高性能查询的，但是如果是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> 字段<span class="number">2</span>=<span class="string">"xxx"</span> ...</span><br></pre></td></tr></table></figure><p>效率跟普通的查询时一样的，因为用索引进行查询，最左边的那个字段必须要有，否则无效。</p><p>扩展的内容知识顺便提一下，在数据库这一块，会详细介绍一下。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redisson实现Redis分布式锁原理</title>
      <link href="/2019/01/22/miscellany/02Redisson%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/01/22/miscellany/02Redisson%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<p>我们可以自己来实现一个<a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">redis分布式锁</a>，但是如何用Redisson优雅地实现呢？本文探讨一下它的原理。</p><a id="more"></a><p>用<code>Redisson</code>来实现分布式锁异常地简单，形如：</p><p><img src="http://bloghello.oursnail.cn/ziji2-1.png" alt="image"></p><p>还支持<code>redis</code>单实例、<code>redis</code>哨兵、<code>redis cluster</code>、<code>redis master-slave</code>等各种部署架构，都可以给你完美实现。</p><h2>加锁</h2><p>原理图：</p><p><img src="http://bloghello.oursnail.cn/zaji2-2.png" alt="image"></p><p>现在某个客户端要加锁。如果该客户端面对的是一个<code>redis cluster</code>集群，他首先会根据hash节点选择一台机器。紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</p><p><img src="http://bloghello.oursnail.cn/zaji2-3.png" alt="image"></p><p>为啥要用lua脚本呢？因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的<strong>原子性</strong>。</p><p>解释一下这段脚本的意思。</p><p>这里的<code>KEYS[1]</code>代表的是你加锁的那个key的名字。这个key就是我们常看到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"myLock"</span>);</span><br></pre></td></tr></table></figure><p>中的<code>myLock</code>，我就是对这个key进行加锁。</p><p>这里的<code>ARGV[1]</code>代表的就是锁key的默认生存时间，默认30秒。<code>ARGV[2]</code>代表的是加锁的客户端的ID:比如<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code></p><p>第一段if判断语句，就是相当于用<code>exists myLock</code>命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：<code>hset myLock</code>。</p><p>执行完<code>hest</code>之后，设置了一个hash数据结构：<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</code>，这行命令执行后，会出现一个类似下面的数据结构：</p><p><img src="http://bloghello.oursnail.cn/zaji2-4.png" alt="image"></p><p>紧接着会执行<code>pexpire myLock 30000</code>命令，设置myLock这个锁key的生存时间是30秒。好了，到此为止，ok，加锁完成了。</p><h2>锁互斥</h2><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？很简单，第一个if判断会执行<code>exists myLock</code>，发现myLock这个锁key已经存在了。接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p><p>所以这个客户端2两个if都不能进入，只能执行最后的<code>pttl myLock</code>，返回值代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p><h2>watch dog自动延期机制</h2><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个<code>watch dog</code>看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><h2>可重入加锁机制</h2><p>看一下代码，相同的客户进来，会进入第二个if，会执行<code>hincrby</code>，即增1，那么这个hash结构就会变成：</p><p><img src="http://bloghello.oursnail.cn/zaji2-5.png" alt="image"></p><h2>释放锁</h2><p>如果执行<code>lock.unlock()</code>，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：<code>del myLock</code>命令，从redis里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。</p><p>这就是所谓的分布式锁的开源Redisson框架的实现机制。</p><h2>存在的问题</h2><p>其实上面那种方案最大的问题，就是如果你对某个<code>redis master</code>实例，写入了myLock这种锁key的value，此时会异步复制给对应的<code>master slave</code>实例。</p><p>但是复制的这个过程中一旦发生<code>redis master</code>宕机，主备切换，<code>redis slave</code>变为了<code>redis master</code>。</p><p>假设客户端1在<code>redis master</code>上获得锁，然后主机宕机，<code>redis slave</code>成为新的<code>redis master</code>，但是还未同步到<code>redis slave</code>上，但是客户端1已经觉得自己获取到了锁。</p><p>此时，客户端2来尝试加锁的时候，在新的<code>redis master</code>上完成了加锁，此时就会发生多个客户端完成对一个key的加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</p><p>所以这个就是<code>redis cluster</code>，或者是<code>redis master-slave</code>架构的主从异步复制导致的redis分布式锁的最大缺陷：在<code>redis master</code>实例宕机的时候，可能导致多个客户端同时完成加锁。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring事务的传播行为</title>
      <link href="/2019/01/22/miscellany/01%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/"/>
      <url>/2019/01/22/miscellany/01%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</url>
      <content type="html"><![CDATA[<p>经常听到别人说事务传播行为，那到底什么是事务的传播行为呢？</p><a id="more"></a><h2>1.什么是事务？</h2><p>在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。</p><p>这里注意，其实事务就是数据库才能保证的，所以抛开数据库层面来谈事务本身就是不存在的，所以事务的概念就是数据库一系列操作的一个完整单元。</p><h2>2.什么是ACID？</h2><p>ACID是指数据库管理系统在写入或更新资料的过程中，为保证事务是正确可靠的，所必须具备的四个特性：原子性、一致性、隔离性、持久性。</p><ul><li><p><code>Atomicity</code>：一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><code>Consistency</code>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p></li><li><p><code>Isolation</code>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔<br>离分为不同级别，包括读未提交(<code>Read uncommitted</code>)、读提交(<code>read committed</code>)、可重复读(<code>repeatable read</code>)和串行化(<code>Serializable</code>)。</p></li><li><p><code>Durability</code>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h2>3.spring事务传播行为</h2><p>在我们用SSM开发项目的时候，我们一般都是将事务设置在<code>Service</code>层 那么当我们调用<code>Service</code>层的一个方法的时候它能够保证我们的这个方法中执行的所有的对数据库的更新操作保持在一个事务中，在事务层里面调用的这些方法要么全部成功，要么全部失败。那么事务的传播特性也是从这里说起的。</p><div class="tip"><重点1> 如果你在你的`Service`层的这个方法中，除了调用了`Dao`层的方法之外，还调用了本类的其他的`Service`方法，那么在调用其他的`Service`方法的时候，这个事务是怎么规定的呢，我必须保证我在我方法里调用的这个方法与我本身的方法处在同一个事务中，否则如果保证事物的一致性。事务的传播特性就是解决这个问题的.</重点1></div><p>在Spring中有针对传播特性的多种配置我们大多数情况下只用其中的一种:<code>PROPGATION_REQUIRED</code>：这个配置项的意思是说当我调用<code>service</code>层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个<code>service</code>层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务。这个工作使由Spring来帮助我们完成的。</p><div class="tip"><重点2> 默认情况下当发生`RuntimeException`的情况下，事务才会回滚，所以要注意一下：如果你在程序发生错误的情况下，有自己的异常处理机制定义自己的`Exception`，必须从`RuntimeException`类继承，这样事务才会回滚！</重点2></div><h2>4.事务隔离级别</h2><ul><li>1、<code>Serializable</code>：最严格的级别，事务串行执行，资源消耗最大；</li><li>2、<code>REPEATABLE READ</code>：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。</li><li>3、<code>READ COMMITTED</code>:大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。</li><li>4、<code>Read Uncommitted</code>：保证了读取过程中不会读取到非法数据。</li></ul><h2>5.总结</h2><p>本文的重点是在于理解事务的传播行为这个概念，从事务的概念，到事务的ACID介绍，引出事务传播传播行为和隔离级别这两个概念加以理解。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2019/01/22/java-collection/12.ConcurrentHashMap/"/>
      <url>/2019/01/22/java-collection/12.ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<p>对于并发场景下，推荐使用线程安全的 concurrentHashMap ，而不是 HashMap 或者是 HashTable .concurrentHashMap在JDK7和JDK8中的实现原理是不一样的。本文分别对其核心思想和方法进行阐述。</p><a id="more"></a><h2>一、JDK7实现</h2><p><code>ConcurrentHashMap</code> 的内部细分了若干个小的 <code>HashMap</code> ，称之为段（ <code>SEGMENT</code> ）。 <code>ConcurrentHashMap</code> 是一个 <code>Segment</code> 数组，<code>Segment</code> 通过继承 <code>ReentrantLock</code> 来进行加锁，所以每次需要加锁的操作锁住的是一个 <code>segment</code> ，这样只要保证每个 <code>Segment</code> 是线程安全的，也就实现了全局的线程安全。</p><p><img src="http://bloghello.oursnail.cn/ConcurrentHashMap7.png" alt="image"></p><p>如图所示，是由 <code>Segment</code> 数组、<code>HashEntry</code> 数组组成，和 <code>HashMap</code> 一样，仍然是数组加链表组成。</p><p><code>ConcurrentHashMap</code> 采用了分段锁技术，其中 <code>Segment</code> 继承于 <code>ReentrantLock</code>。不会像 <code>HashTable</code> 那样不管是 <code>put</code> 还是 <code>get</code> 操作都需要做同步处理，理论上 <code>ConcurrentHashMap</code> 支持 <code>CurrencyLevel</code> ( <code>Segment</code> 数组数量)的线程并发。每当一个线程占用锁访问一个 <code>Segment</code> 时，不会影响到其他的 <code>Segment</code>。</p><h5>1.1 get方法</h5><p><code>ConcurrentHashMap</code> 的 <code>get</code> 方法是非常高效的，因为<strong>整个过程都不需要加锁</strong>。</p><p>只需要将 <code>Key</code> 通过 <code>Hash</code> 之后定位到具体的 <code>Segment</code> ，再通过一次 <code>Hash</code> 定位到具体的元素上。由于 <code>HashEntry</code> 中的 <code>value</code> 属性是用 <code>volatile</code> 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值.</p><p>内部 <code>HashEntry</code> 类 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>1.2 put方法</h5><p>虽然 <code>HashEntry</code> 中的 <code>value</code> 是用 <code>volatile</code> 关键词修饰的，但是并不能保证并发的原子性，所以 <code>put</code> 操作时仍然<strong>需要加锁处理</strong>。</p><p>首先也是通过 <code>Key</code> 的 <code>Hash</code> 定位到具体的 <code>Segment</code>，在 <code>put</code> 之前会进行一次扩容校验。这里比 <code>HashMap</code> 要好的一点是：<code>HashMap</code> 是插入元素之后再看是否需要扩容，有可能扩容之后后续就没有插入就浪费了本次扩容(扩容非常消耗性能)。</p><p><strong>而 <code>ConcurrentHashMap</code> 不一样，它是在将数据插入之前检查是否需要扩容，之后再做插入操作。</strong></p><h5>1.3 size方法</h5><p>每个 <code>Segment</code> 都有一个 <code>volatile</code> 修饰的全局变量 <code>count</code> ,求整个 <code>ConcurrentHashMap</code> 的 size 时很明显就是将所有的 <code>count</code> 累加即可。但是 <code>volatile</code> 修饰的变量却不能保证多线程的原子性，所有直接累加很容易出现并发问题。</p><p>但如果每次调用 <code>size</code> 方法将其余的修改操作加锁效率也很低。所以做法是先尝试两次将 <code>count</code> 累加，如果容器的 <code>count</code> 发生了变化再加锁来统计 <code>size</code>。</p><p>在 <code>JDK7</code> 中，<strong>第一种方案</strong>他会使用不加锁的模式去尝试多次计算 <code>ConcurrentHashMap</code> 的 <code>size</code>，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。</p><p><strong>第二种方案</strong>是如果第一种方案不符合，他就会给每个 <code>Segment</code> 加上锁，然后计算 <code>ConcurrentHashMap</code> 的 <code>size</code> 返回。其源码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line"> <span class="keyword">int</span> size;</span><br><span class="line"> <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line"> <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line"> <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line"> <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0L</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    overflow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += seg.modCount;</span><br><span class="line">            <span class="keyword">int</span> c = seg.count;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">            overflow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == last)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        last = sum; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2>二、JDK8实现</h2><p><img src="http://bloghello.oursnail.cn/ConcurrentHashMap8.png" alt="image"></p><p><code>jdk8</code> 中的 <code>ConcurrentHashMap</code> 数据结构和实现与 <code>jdk7</code> 还是有着明显的差异。</p><p>其中抛弃了原有的 <code>Segment</code> 分段锁，而采用了 <code>CAS</code> + <code>synchronized</code> 来保证并发安全性。</p><p>也将 <code>jdk7</code> 中存放数据的 <code>HashEntry</code> 改为 <code>Node</code>，但作用都是相同的。</p><p><img src="http://bloghello.oursnail.cn/collection12-2.jpg" alt="image"></p><p>其中的 <code>val</code> <code>next</code> 都用了 <code>volatile</code> 修饰，保证了可见性。</p><h2>2.1 put方法</h2><p>重点来看看 <code>put</code> 函数：</p><p><img src="http://bloghello.oursnail.cn/collection12-3.jpg" alt="image"></p><ul><li>根据 <code>key</code> 计算出 <code>hashcode</code> 。</li><li>判断是否需要进行初始化。</li><li><code>f</code> 即为当前 <code>key</code> 定位出的 <code>Node</code>，<strong>如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入</strong>，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足(不需要初始化、Node不为空、不需要扩容)，则<strong>利用 <code>synchronized</code> 锁写入数据</strong>。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h2>2.2 get方法</h2><ul><li>根据计算出来的 <code>hashcode</code> 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>都不满足那就按照链表的方式遍历获取值。</li></ul><h2>2.3 size方法</h2><p><code>JDK8</code> 实现相比 <code>JDK7</code> 简单很多，只有一种方案，我们直接看 <code>size()</code> 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">                (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (<span class="keyword">int</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CounterCell[] as = counterCells; </span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//获取baseCount值</span></span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="comment">//遍历CounterCell数组全部加到baseCount上，它们的和就是size</span></span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可能你会有所疑问，<code>ConcurrentHashMap</code> 中的 <code>baseCount</code> 属性不就是记录的所有键值对的总数吗？直接返回它不就行了吗？</p><p>之所以没有这么做，是因为我们的 <code>addCount</code> 方法用于 <code>CAS</code> 更新 <code>baseCount</code>，但很有可能在高并发的情况下，更新失败，那么这些节点虽然已经被添加到哈希表中了，但是数量却没有被统计。</p><p><strong>还好，<code>addCount</code> 方法在更新 <code>baseCount</code> 失败的时候，会调用 <code>fullAddCount</code> 将这些失败的结点包装成一个 <code>CounterCell</code> 对象，保存在 <code>CounterCell</code> 数组中。那么整张表实际的 <code>size</code> 其实是 <code>baseCount</code> 加上 <code>CounterCell</code>数组中元素的个数。</strong></p><h2>三、总结</h2><ul><li>并发情况下请使用<code>concurrentHashMap</code></li><li>在<code>jdk7</code>中，用的是分段锁，默认是12段，那么并发量最多也就12.<ul><li><code>get</code>不加锁，第一次<code>hash</code>定位到<code>segment</code>，第二次<code>hash</code>定位到元素，元素值是用<code>volatile</code>保证内存可见性</li><li><code>put</code>需要加锁，<code>hash</code>定位到<code>segment</code>后，先检查是否需要扩容再插入。</li><li><code>size</code>先使用不加锁的模式去尝试多次计算<code>size</code>，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入；如果不一致，给每个 <code>Segment</code> 加上锁再依次去计算个数</li></ul></li><li>在<code>jdk8</code>中，采用了 <code>CAS</code> + <code>synchronized</code> 来保证并发安全性<ul><li><code>put</code>的过程比较复杂，简单来说是：先计算<code>hash</code>定位到<code>node</code>—》判断是否初始化—》如果<code>node</code>为空则表示可以插入，用<code>cas</code>插入—》判断是否需要扩容—》如果不需要初始化、<code>Node</code>不为空、不需要扩容，则利用 <code>synchronized</code> 锁写入数据—》判断是否需要转换为红黑树</li><li><code>get</code>就比较简单，直接根据<code>hash</code>定位到<code>node</code>，然后以链表或者红黑树的方式拿到</li><li><code>size</code>方法就一种方案：<code>baseCount</code>+<code>CounterCell[]中所有元素</code></li></ul></li></ul><p>整理自：</p><ul><li><a href="https://crossoverjie.top/JCSprout/#/thread/ConcurrentHashMap?id=size-%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">https://crossoverjie.top/JCSprout/#/thread/ConcurrentHashMap?id=size-方法</a></li><li><a href="https://www.jianshu.com/p/e99e3fcface4" target="_blank" rel="noopener">https://www.jianshu.com/p/e99e3fcface4</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap死循环问题</title>
      <link href="/2019/01/21/java-collection/11.HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/21/java-collection/11.HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>JDK1.7或者更老的版本中在多线程情况下是会存在死循环问题，究其原因是put过程中的resize方法在调用transfer方法的时候导致的死锁。这次我们来看看到底是哪里出了问题！</p><a id="more"></a><h2>核心源码</h2><p>在JDK8中，内部已经调整，解决了死循环问题，是如何解决的呢？将JDK7中头插入法改为末端插入。就是这么简单。关于这个，可以查看jdk8源码中的<code>resize</code>方法。</p><p>上面提到是由于<code>put</code>时出现问题，那么先来到<code>put()</code>中看看：</p><p><img src="http://bloghello.oursnail.cn/collection11-1.png" alt="image"></p><p>我们看到，put一个不存在的新元素，必然增加一个节点，我们进入这个增加节点的方法：</p><p><img src="http://bloghello.oursnail.cn/collection11-2.png" alt="image"></p><p>检查是否需要扩容，需要的话就<code>resize</code>:</p><p><img src="http://bloghello.oursnail.cn/collection11-3.png" alt="image"></p><p>下面就是对链表数据进行迁移：</p><p><img src="http://bloghello.oursnail.cn/collection11-4.png" alt="image"></p><p>核心的代码就是这么多，首先要强调一下：<strong>两个线程进来，是分别建立了两个独立的扩容后的数组</strong>，比如这里是两个长度为4的数组。老的数组为2个数就是唯一的。所以在第一步，线程2运行结束时，老的数组元素已经空了。</p><p>下面先演示一下正常的<code>rehash</code>过程。</p><h2>正常情况</h2><p><img src="http://bloghello.oursnail.cn/collection11-5.png" alt="image"></p><ul><li>假设了我们的<code>hash</code>算法就是简单的用 key mod 一下数组(hash表)的大小</li><li>最上面的是<code>old hash</code> 表，其中的<code>Hash</code>表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在<code>table[1]</code>这里了。</li><li>接下来的三个步骤是<code>Hash</code>表 <code>resize</code> 成4，然后所有的 <code>&lt;key,value&gt;</code> 重新 <code>rehash</code> 的过程</li></ul><p>注意到，在JDK7中，是按照头插入法依次插入的。所以7插到了3前面。</p><h2>并发情况</h2><h5>1.初始情况</h5><p>假设我们有两个线程。我用红色和浅蓝色标注了一下。</p><p>对于第一个线程先执行完这一行，然后挂起，此时 <code>e</code> 和 <code>next</code> 都附好值了：</p><p><img src="http://bloghello.oursnail.cn/collection11-6.png" alt="image"></p><p>而让线程二执行完成。于是我们有下面的这个样子：</p><p><img src="http://bloghello.oursnail.cn/collection11-7.png" alt="image"></p><p>因为<code>Thread1</code>的 <code>e</code> 指向了 <code>key(3)</code> ，而 <code>next</code> 指向了 <code>key(7)</code> ，其在 <code>Thread2</code>  <code>rehash</code>后，指向了 <code>Thread2</code> 重组后的链表。</p><h5>2.Thread1被调度回来执行</h5><ul><li>先是执行 <code>newTalbe[i] = e</code> ：此时线程1的第三个位置就是指向元素3;</li><li>然后是 <code>e = next</code>，导致了 <code>e</code> 指向了 <code>key(7)</code> ;</li><li>而下一次循环的 <code>next = e.next</code> 导致了 <code>next</code> 指向了 <code>key(3)</code> ;</li></ul><p><img src="http://bloghello.oursnail.cn/collection11-8.png" alt="image"></p><h2>3.一切安好</h2><p>线程一接着工作。把 <code>key(7)</code> 摘下来，放到 <code>newTable[i]</code> 的第一个，然后把 <code>e</code> 和 <code>next</code> 往下移。</p><p><img src="http://bloghello.oursnail.cn/collection11-9.png" alt="image"></p><h5>4.环形链接出现</h5><p><code>e.next = newTable[i]</code> 导致  <code>key(3).next</code> 指向了 <code>key(7)</code></p><p>注意：此时的 <code>key(7).next</code> 已经指向了 <code>key(3)</code>， 环形链表就这样出现了。</p><p><img src="http://bloghello.oursnail.cn/collection11-10.png" alt="image"></p><h2>自己的简单整理</h2><p>这里还是比较绕的，理解的最好方式左边放源码，右边放图，中间用草稿纸画一画。</p><p>那么，这里我在对其过程尽可能地讲明白一点。我们先确定7和3会全部落到扩容后的下标为3的位置(3%4=3,7%4=3)。</p><p>规定线程1开辟的数组为 <code>arr1</code> ，线程2开辟的数组为 <code>arr2</code>;</p><h5>1. 初始状态</h5><ul><li>线程一： e -&gt; key3 , next -&gt; key7</li><li>线程二： 数组3号位置 arr2[3] -&gt; key7 -&gt; key3</li></ul><p>注意此时 <code>key7</code> 指向 <code>key3</code> .</p><p>我们要明确一下，发生死循环，是指在<code>put</code>操作完毕之后，最终生成的数组中有死循环引用才行，千万不要一开始看线程一种key3指向key7，然后线程二种key7指向key3就是死循环了。。。</p><h5>2. 线程一继续执行</h5><p><img src="http://bloghello.oursnail.cn/collection11-6.png" alt="image"></p><ul><li>i = 3</li><li>e.next = key7,此时 e=key3 ,所以是 key3.next = key7（这是线程1的初始状态决定的）</li><li>arr1[3] 指向 key3</li><li>e 为 key7</li></ul><h5>3.由于e不为空，所以还会循环：</h5><ul><li>上一步 e 为 key7，所以 next = key7.next ，到线程2中一看是 key3 ，所以 next = key3（线程2中key7.next就是key3）</li><li>i = 3</li><li>e.next = key3------<strong>注意，这里就是Key7指向了key3,key7的next引用下面没有变过，所以这里做一下记录，即key7指向key3</strong></li><li>newTable[3] = key7</li><li>e = key3</li></ul><h5>4.由于e不为空，所以还会循环：</h5><ul><li>上一步 e=key3 , next=null</li><li>i=3</li><li>key3.next = key7，注意,由于key7已经指向了key3，<strong>此时key3又指向key7</strong>,发生死循环</li><li>newTable[3] = key3</li><li>e = null</li></ul><h5>5.e为null，跳出循环。</h5><p>此时发现key3又指向了key7。发生死循环。</p><p>整理自:<a href="https://coolshell.cn/articles/9606.html/comment-page-2#comments" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html/comment-page-2#comments</a></p>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux重要的一些命令</title>
      <link href="/2019/01/21/linux%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/01/21/linux%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>很多命令之所以重要，是因为用它们会大幅提高工作效率。所以，熟悉它们是我们必须要做的一件事情。下面着重提取了find、grep、管道、wc、awk以及sed等几个命令来看看如何使用。</p><a id="more"></a><h2>一、Linux体系结构</h2><div align="center">    <img src="http://bloghello.oursnail.cn/linux1-1.png" style="width:300px;"></div><p>对这幅图进行详细说明一下。</p><ul><li>体系结构主要分为<strong>用户态</strong>(用户上层活动)和<strong>内核态</strong></li><li><strong>内核：本质是一段管理计算机硬件设备的程序</strong>，这个程序直接管理硬件：包括CPU、内存空间、硬盘接口、网络接口等。所有的计算机操作都要通过内核来操作。</li><li>系统调用：内核的访问接口，<strong>是一种不能再简化的操作</strong>(可以认为系统调用已经是最小的原子操作，上层完成一个功能要依托于若干系统调用才能完成)</li><li>由于系统调用比较基础，要完成一个功能需要很多系统调用组合才能实现，对于程序员来说比较复杂。这个时候怎么办呢？<strong>我们可以调用公共函数库：系统调用的组合拳。简化程序员操作</strong>。</li><li><code>Shell</code>也是一种特殊的应用程序，是一个命令解释器，可以编程。</li><li><code>Shell</code>下通系统调用，上通各种应用，是上层和下层之间粘合的胶水，让不同程序可以偕同工作。</li><li>在没有图形界面之前，用户通过<code>shell</code>命令行或者可编程的<code>shell</code>脚本可以完成很多事情。</li></ul><h2>二、如何根据文件名检索文件</h2><ul><li>find</li><li>在指定目录下查找文件</li></ul><blockquote><p>语法 find path [options] params</p></blockquote><h3>2.1 精确查找文件</h3><p>比如我在当前目录(可能在子目录下)下找一个文件叫做<code>test.java</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name "test.java"</span><br></pre></td></tr></table></figure><p>这个指令就可以在本目录以及子目录下递归查找这个文件了。</p><p>实例：精确查询名字叫<code>snailmall-api-gateway-8080.jar</code>这个文件：</p><p><img src="http://bloghello.oursnail.cn/linux1-4.png" alt="image"></p><h3>2.2 全局搜索</h3><p>如果是全局查找，也很简单，无非是从根目录开始递归查找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name "test.java"</span><br></pre></td></tr></table></figure><p>实例：我对这台服务器全局查找文件名以<code>snailmall</code>开头的所有文件：</p><p><img src="http://bloghello.oursnail.cn/linux1-3.png" alt="image"></p><h3>2.3 模糊查询</h3><p>如果找以test打头的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name "test*"</span><br></pre></td></tr></table></figure><p>即用 <code>*</code> 通配符就可以模糊查询到以 <code>test</code> 打头的文件。</p><p>实例，我的这台服务器上部署了几个关于商城的服务，这个目录下我放了jar包和相应的启动信息文件。我对其进行模糊查询：</p><p><img src="http://bloghello.oursnail.cn/linux1-2.png" alt="image"></p><h3>2.4 忽略大小写</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -iname "test*"</span><br></pre></td></tr></table></figure><h2>三、如何根据文件内的内容进行检索</h2><h3>3.1 grep命令</h3><ul><li>grep</li><li>查找文件里符合条件的字符串</li></ul><blockquote><p>语法：grep [options] pattern file</p></blockquote><p>比如 <code>test.java</code> 中有一句话是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"i love java"</span>);</span><br></pre></td></tr></table></figure><p>那么如何查找 <code>test.java</code> 中的 <code>java</code> 呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "java" test*</span><br></pre></td></tr></table></figure><p>这句话意思就是查找以 <code>test</code> 打头的文件中的包含 <code>java</code> 字符串所在的行。</p><p>直接输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "hello"</span><br></pre></td></tr></table></figure><p>会等待用户输入文本。然后再对输入的内容进行检索。</p><h3>3.2 管道操作符 |</h3><blockquote><p>可将指令连接起来，前一个指令的输出作为后一个指令的输入。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / | grep "test"</span><br></pre></td></tr></table></figure><p>作用同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name "test"</span><br></pre></td></tr></table></figure><div class="tip"><p>注意：</p><p>只有前一个指令正确才会再处理。</p><p>管道右边命令必须能接收标准输入流，否则传递过程中数据会被抛弃</p></div><h3>3.3 grep结合管道</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'xxx' hello.info</span><br></pre></td></tr></table></figure><p>可以将 <code>xxx</code> 所在的行全部筛选出来，但是还是特别多，我比如关心这每一行中某个字段的信息，比如是 <code>param[xx12]</code>这种信息。如何实现筛选呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'xxx' hello.info | grep -o 'param\[[0-9a-z]*\]'</span><br></pre></td></tr></table></figure><p>这样就只把类似于 <code>param[xx12]</code> 这样的信息清晰地展现出来。</p><p>如何过滤掉不要的信息呢？可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v</span><br></pre></td></tr></table></figure><p>比如我们查询 <code>tomcat</code> 进程信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br></pre></td></tr></table></figure><p>我们会发现，不仅 <code>tomcat</code> 的信息展现出来了，执行 <code>grep</code> 命令本身的进程信息也展示出来了。我们要将这个 <code>grep</code> 命令过滤掉，只展现 <code>tomcat</code> 进程信息，可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat | grep -v "grep"</span><br></pre></td></tr></table></figure><p>这样就把 <code>grep</code> 进程信息过滤掉了。</p><h2>四、如何对文件内容做统计</h2><ul><li>awk</li><li>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分</li><li>将切片直接保存再内建的变量中，$1$2…($0表示行的全部)</li><li>支持对单个切片的判断，支持循环判断，<strong>默认分隔符为空格</strong></li></ul><blockquote><p>语法：awk [options] ‘cmd’ file</p></blockquote><p>有这样一个文件text1.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proto   Recv-Q   Send-Q    Local Address     Foreign Address      state</span><br><span class="line">tcp     0        48        111.34.134.2:ssh  124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     0        48        localhost:mysql   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     0        48        111.34.13.2:s0    124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     0        48        localhost:mysql   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     1        48        localhots:webcac  124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     1        48        111.34.134.2:s1   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     1        48        111.34.134.2:s2   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     0        48        111.34.134.2:s3   124.213.2.12:12565   ESTABLISHED</span><br></pre></td></tr></table></figure><p>列出切分出来的第一列和第二列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1,$2&#125;' test1.txt</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://bloghello.oursnail.cn/linux1-7.png" alt="image"></p><p>筛选出第一列为<code>tcp</code>和第二列为<code>1</code>的所在行，将这些行数据全部打印出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '$1="tcp" &amp;&amp; $2==1&#123;print $0&#125;' test1.txt</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://bloghello.oursnail.cn/linux1-8.png" alt="image"></p><p>打印带有表头的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '($1="tcp" &amp;&amp; $2==1) || NR==1 &#123;print $0&#125;' test1.txt</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-9.png" alt="image"></p><p>默认是以空格分隔，那么以逗号或者其他符号可以吗？答案当然是可以。对于这样的文件text2.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adas,123</span><br><span class="line">wqe,544</span><br><span class="line">12321,dddf</span><br><span class="line">sdaasd,1235</span><br><span class="line">465547,fjigj</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F "," '&#123;print $2&#125;' text2.txt</span><br></pre></td></tr></table></figure><h2>五、WC统计</h2><p>有一个文件test2.txt，里面的内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swg123eh shwf</span><br><span class="line">shsfswg7 121 32n dswg17328 123swg1 2h1jhw</span><br><span class="line">jqbsjwqbsh ddddh wg ehdedhd  dhsjh</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-10.png" alt="image"></p><h2>六、sed命令</h2><p>sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作</p><blockquote><p>sed [-n/e/f/r/i] ‘command’ 输入文本</p></blockquote><p>常用选项：</p><ul><li>-n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</li><li>-e∶直接在指令列模式上进行 sed 的动作编辑；</li><li>-f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；</li><li>-r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)</li><li>-i∶<strong>直接修改读取的档案内容，而不是由萤幕输出</strong>。</li></ul><p>常用命令：</p><ul><li>a   ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c   ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d   ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i   ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p  ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～</li><li>s  ∶<strong>取代</strong>，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><p>这里我就主要看一下批量替换这个功能。</p><p>如果只是给一个文件中的若干字符串批量替换，只需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i "s/oldstring/newstring/g" filename</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-12.png" alt="image"></p><p>如果是对某一路径下很多的文件批量替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/oldstring/newstring/g&quot; `grep oldstring -rl path`</span><br></pre></td></tr></table></figure><p>其中，<code>oldstring</code>是待被替换的字符串，<code>newstring</code>是待替换<code>oldstring</code>的新字符串，<code>grep</code>操作主要是按照所给的路径查找<code>oldstring</code>，<code>path</code>是所替换文件的路径；</p><ul><li><strong>-i选项是直接在文件中替换，不在终端输出</strong>；</li><li><strong>-r选项是所给的path中的目录递归查找</strong>；</li><li><strong>-l选项是输出所有匹配到oldstring的文件</strong>；</li></ul><p>这里只是模拟一下，将目录下的所有文件进行批量修改：</p><p><img src="http://bloghello.oursnail.cn/linux1-13.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>站点文章汇总</title>
      <link href="/2019/01/21/%E7%AB%99%E7%82%B9%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"/>
      <url>/2019/01/21/%E7%AB%99%E7%82%B9%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>☝️☝️☝️🔝🔝🔝本文为置顶文章，为了方便管理和查阅，在这里详细展示目录索引，看完索引，你就知道本站的大体内容啦！我相信一定会给小伙伴们一些收获！</p><a id="more"></a><h2>计算机网络🐭🐭🐭</h2><p>这一部分主要是关于<code>HTTP</code>和<code>TCP</code>的必备知识。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">《计算机网络相关系列》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/1.%E4%BB%8E%E4%B8%8B%E5%88%B0%E4%B8%8A%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">《从下到上看五层模型》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/2.%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">《从上到下看五层模型》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/3.http%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" target="_blank" rel="noopener">《HTTP的前世今生》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/4.TCP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">《TCP协议入门》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/5.TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" target="_blank" rel="noopener">《TCP三次握手和四次挥手》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/6.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8F%90%E7%82%BC/" target="_blank" rel="noopener">《HTTP基础知识提炼》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/7.%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3HTTPS/" target="_blank" rel="noopener">《一步一步理解HTTPS》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/25/network/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener">《一些常见的面试题》</a></li></ul></li></ul><h2>JAVA容器🐱🐱🐱</h2><p>这一部分是<code>JAVA</code>容器一系列文章，主要讲了常用<code>JAVA</code>容器的源码和一些特性，面试必问点。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/java%E5%AE%B9%E5%99%A8/" target="_blank" rel="noopener">《JAVA容器》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/1.ArrayList%E5%92%8CVector/" target="_blank" rel="noopener">《ArrayList/Vector》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/2.LinkedList/" target="_blank" rel="noopener">《LinkedList》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/3.CopyOnWriteArrayList/" target="_blank" rel="noopener">《CopyOnWriteArrayList》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/4.hashcode%E5%92%8Cequals/" target="_blank" rel="noopener">《HashCode/Equals》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/5.HashMap/" target="_blank" rel="noopener">《HashMap》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/6.HashSet/" target="_blank" rel="noopener">《HashSet》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/7.LinkedHashMap/" target="_blank" rel="noopener">《LinkedHashMap》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">《HashMap和LinkedHashMap遍历机制》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/9.HashTable/" target="_blank" rel="noopener">《HashTable》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/10.LinkedHashSet/" target="_blank" rel="noopener">《LinkedHashSet》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/21/java-collection/11.HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《JDK7中HashMap死循环原因剖析》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/java-collection/12.ConcurrentHashMap/" target="_blank" rel="noopener">《ConcurrentHashMap》</a></li></ul></li></ul><h2>Linux&amp;操作系统🐶🐶🐶</h2><p>一些必备的<code>Liunx</code>相关的知识点整理。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/Linux/" target="_blank" rel="noopener">《Linux》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/21/linux%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4/" target="_blank" rel="noopener">《Linux面试重要命令》</a></li></ul></li><li><a href="http://fourcolor.oursnail.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">《操作系统相关》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">《面试-进程与线程》</a></li></ul></li></ul><h2>JAVA虚拟机相关🐹🐹🐹</h2><p>主要是介绍JVM相关知识。轻松以应付面试。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/JVM/" target="_blank" rel="noopener">《JVM》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">《Java如何执行一个最简单的程序》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/%E6%B5%85%E8%B0%88ClassLoader/" target="_blank" rel="noopener">《浅谈ClassLoader》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">《双亲委派模型》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/%E7%BB%86%E8%B0%88loadClass/" target="_blank" rel="noopener">《细谈loadClass》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/" target="_blank" rel="noopener">《JAVA内存模型-线程私有》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/" target="_blank" rel="noopener">《JAVA内存模型-线程共享》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/08/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%B8%B8%E9%97%AE%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener">《JAVA内存模型常问面试题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/GC%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">《GC相关》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《垃圾收集器介绍》</a></li></ul></li></ul><h2>JAVA核心基础知识🐺🐺🐺</h2><p>主要是介绍比较核心的JAVA基础知识，属于JAVA基础进阶。</p><ul><li><a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/Integer%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1/" target="_blank" rel="noopener">《Integer拆箱和装箱》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2/" target="_blank" rel="noopener">《String为什么不可变》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" target="_blank" rel="noopener">《java字符串核心一网打尽》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/24/java-basic/JAVA%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener">《JAVA基础核心-理解类、对象、面向对象编程、面向接口编程》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/29/java-basic/%E8%A1%A5%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" target="_blank" rel="noopener">《补码的前世今生》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/31/miscellany/14%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《数值计算精度丢失问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/" target="_blank" rel="noopener">《彻底理解java反射机制》</a></li></ul><h2>JAVA多线程🐸🐸🐸</h2><p>多线程这一块比较棘手，且学且保重。</p><h2>Redis🐯🐯🐯</h2><p>系统学习redis的笔记整理。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/redis/" target="_blank" rel="noopener">《Redis》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/29/redis/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86Redis/" target="_blank" rel="noopener">《初步认识Redis》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/29/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener">《Redis基本数据结构和操作》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/29/redis/Redis%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《Redis其他的功能介绍》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/30/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/" target="_blank" rel="noopener">《Redis为什么快》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/31/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/" target="_blank" rel="noopener">《Redis持久化》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/31/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" target="_blank" rel="noopener">《Redis主从复制》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" target="_blank" rel="noopener">《Redis-Sentinel实现高可用读写分离》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Cluster%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">《Redis-Cluster理论详解》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/01/redis/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">《Redis缓存设计与优化》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/02/redis/Redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《Redis缓存更新问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/02/redis/Redis%E4%BA%8B%E5%8A%A1/" target="_blank" rel="noopener">《Redis事务》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/02/redis/%E5%87%A0%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《几种主流缓存框架介绍》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/02/redis/%E5%85%B3%E4%BA%8ERedis%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%82%B9/" target="_blank" rel="noopener">《关于Redis一些重要的面试点》</a></li></ul></li></ul><h2>MySQL数据库🐨🐨🐨</h2><p>作为必备技能，用法和原理都要会。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/mysql/" target="_blank" rel="noopener">《MySQL》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/25/mysql/mysql%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">《mysql最基础知识小结》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/27/mysql/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" target="_blank" rel="noopener">《SQL必知必会知识点提炼》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/27/mysql/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">《复杂查询基础》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/mysql/%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5/" target="_blank" rel="noopener">《内连接和外连接》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/25/mysql/delete%E5%92%8Ctruncate%E4%BB%A5%E5%8F%8Adrop%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">《delete和truncate以及drop区别》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" target="_blank" rel="noopener">《如何设计一个关系型数据库》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">《数据库索引入门》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">《MySQL索引全面解读》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/MySQL%E8%B0%83%E4%BC%98/" target="_blank" rel="noopener">《MySQL调优》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/" target="_blank" rel="noopener">《关于索引失效和联合索引》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/%E9%94%81%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">《锁模块》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/27/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《数据库事务核心问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/27/mysql/mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" target="_blank" rel="noopener">《mysql面试高频理论知识》</a></li></ul></li></ul><h2>算法🐻🐻🐻</h2><p>算法这一块也是面试痛点和难点，头发越来越少了呢！</p><h2>Spring🐷🐷🐷</h2><p>大厂必问啊啊啊啊，源码终究还是要读的~</p><h2>Spring Cloud相关🐮🐮🐮</h2><p>这一块就比较偏实践了。分布式。。。路漫漫。。。</p><h2>Zookeeper🐗🐗🐗</h2><p>作为当今分布式协调中心，核心的Paxos算法你不想了解一下吗？</p><h2>杂记🐵🐵🐵</h2><p>在这个板块，不划分类别，文章尽可能地简短，也可谓之记忆碎片。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/miscellany/" target="_blank" rel="noopener">《技术短文杂记》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/01%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/" target="_blank" rel="noopener">《spring事务的传播行为》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/02Redisson%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《Redisson实现Redis分布式锁原理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《redis实现分布式锁》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/" target="_blank" rel="noopener">《springMVC全局异常+spring包扫描包隔离+spring事务传播》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">《分布式ID生成策略》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/06Spring%20Session/" target="_blank" rel="noopener">《Spring Session》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《Curator》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">《ELK平台搭建》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《库存扣减问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/" target="_blank" rel="noopener">《分布式事务解决方案思考》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/28/miscellany/11SpringBoot%E4%BD%BF%E7%94%A8logback%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%8C%89%E5%A4%A9%E6%BB%9A%E5%8A%A8/" target="_blank" rel="noopener">《SpringBoot使用logback实现日志按天滚动》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">《地理位置附近查询的GEOHASH解决方案》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/30/miscellany/13%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Nginx%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">《深入探究Nginx原理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">《简明理解一致性hash算法》</a></li></ul></li></ul><h2>随笔🐖🐖🐖</h2><ul><li><a href="http://fourcolor.oursnail.cn/tags/%E9%9A%8F%E7%AC%94/" target="_blank" rel="noopener">《随笔》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/02/05/suibi/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/" target="_blank" rel="noopener">《2019年展望》</a></li></ul></li></ul><h2>实战作品🐰🐰🐰</h2><p>记录一些实战作品，代码主要存放在<code>github</code>上。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">《我的实战》</a>：<ul><li><a href="https://github.com/sunweiguo/MMall" target="_blank" rel="noopener">《快乐蜗牛商城代码》</a></li><li><a href="https://github.com/sunweiguo/mama-buy" target="_blank" rel="noopener">《码码购分布式电商实战代码》</a></li></ul></li></ul><hr><img src="http://bloghello.oursnail.cn/mypay.png" width="500">]]></content>
      
      
        <tags>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedHashSet</title>
      <link href="/2019/01/20/java-collection/10.LinkedHashSet/"/>
      <url>/2019/01/20/java-collection/10.LinkedHashSet/</url>
      <content type="html"><![CDATA[<p>HashSet 和 LinkedHashSet 的关系类似于 HashMap 和 LinkedHashMap 的关系，即后者维护双向链表，实现迭代顺序可为插入顺序或是访问顺序。所以也就轻松加愉快快速了解一下即可。</p><a id="more"></a><p>从源码中可以看到其空的构造函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>super</code>即父类是<code>HashSet</code>，从它的继承关系就可以显然看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>那么<code>HashSet</code>内部的数据结构就是一个 <code>HashMap</code>，其方法的内部几乎就是在调用 <code>HashMap</code> 的方法。</p><p><code>LinkedHashSet</code> 首先我们需要知道的是它是一个 <code>Set</code> 的实现，所以它其中存的肯定不是键值对，而是值。此实现与 <code>HashSet</code> 的不同之处在于，<code>LinkedHashSet</code> 维护着一个运行于所有条目的双向循环链表。</p><p>这一切都与<code>LinkedHashMap</code>类似。</p><p><code>LinkedHashSet</code> 内部有个属性 <code>accessOrder</code> 控制着遍历次序。默认情况下该值为 <code>false</code> ,即按插入排序访问。如果将该值设置为 <code>true</code> 的话，则按访问次序排序(即最近最少使用算法，最近最少使用的放在链表头部，最近访问的则在链表尾部)。</p><h2>一、 示例</h2><h4>HashSet的遍历：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">linkedHashSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"eee"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = linkedHashSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>输出结果是：</h4><blockquote><p>aaa<br>ccc<br>bbb<br>eee</p></blockquote><h4>LinkedHashSet的遍历：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">linkedHashSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"eee"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">linkedHashSet.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = linkedHashSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>输出结果是：</h4><blockquote><p>aaa<br>eee<br>ccc<br>bbb<br>null</p></blockquote><p>可以看到与输入顺序是一致的。</p>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hashtable</title>
      <link href="/2019/01/20/java-collection/9.HashTable/"/>
      <url>/2019/01/20/java-collection/9.HashTable/</url>
      <content type="html"><![CDATA[<p>Hashtable 是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。但这并不是我们不去了解它的理由。最起码 Hashtable 和 HashMap 的面试题在面试中经常被问到。</p><a id="more"></a><h2>一、前言</h2><p><code>Hashtable</code>和<code>HashMap</code>，从存储结构和实现来讲基本上都是相同的。</p><p>它和<code>HashMap</code>的最大的不同是它是线程安全的，另外它不允许<code>key</code>和<code>value</code>为<code>null</code>。</p><p>为了能在哈希表中成功地保存和取出对象，用作<code>key</code>的对象必须实现<code>hashCode</code>方法和<code>equals</code>方法。</p><h2>二、fail-fast机制</h2><p><code>iterator</code>方法返回的迭代器是<code>fail-fast</code>的。如果在迭代器被创建后<code>hashtable</code>被结构型地修改了，除了迭代器自己的<code>remove</code>方法，迭代器会抛出一个<code>ConcurrentModificationException</code>异常。</p><p><strong>因此，面对在并发的修改，迭代器干脆利落的失败，而不是冒险的继续。</strong></p><p>关于这个的理解，其实在上一章讲<code>LinkedHashMap</code>中的第八点提到：</p><div class="tip"><p><strong>值得注意的是，<code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</strong></p><p>简单说，就是两个线程同时分别进行修改和遍历时，会抛出这个异常。</p></div><p><strong>面试题：集合在遍历过程中是否可以删除元素，为什么迭代器就可以安全删除元素？</strong></p><p>集合在使用 <code>for</code> 循环迭代的过程中不允许使用，集合本身的 <code>remove</code> 方法删除元素，如果进行错误操作将会导致 <code>ConcurrentModificationException</code> 异常的发生</p><p><code>Iterator</code> 可以删除访问的当前元素(<code>current</code>)，一旦删除的元素是<code>Iterator</code> 对象中 <code>next</code> 所正在引用的，在 <code>Iterator</code> 删除元素通过 修改 <code>modCount</code> 与 <code>expectedModCount</code> 的值，可以使下次在调用 <code>remove</code> 的方法时候两者仍然相同因此不会有异常产生。</p><p>迭代器的<code>fail-fast</code>机制并不能得到保证，它不能够保证一定出现该错误。一般来说，<code>fail-fast</code>会尽最大努力抛出<code>ConcurrentModificationException</code>异常。因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：<code>ConcurrentModificationException</code> 应该仅用于检测 bug。</p><p><code>Hashtable</code>是线程安全的。如果不需要线程安全的实现是不需要的，推荐使用<code>HashMap</code>代替<code>Hashtable</code>。如果需要线程安全的实现，推荐使用<code>java.util.concurrent.ConcurrentHashMap</code>代替<code>Hashtable</code>。</p><h2>二、继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>extends Dictionary&lt;K,V&gt;</code>：<code>Dictionary</code>类是一个抽象类，用来存储键/值对，作用和Map类相似。</li><li><code>implements Map&lt;K,V&gt;</code>：实现了<code>Map</code>，实现了<code>Map</code>中声明的操作和<code>default</code>方法。</li></ul><p><code>hashMap</code>以及<code>TreeMap</code>的源码，都没有继承于这个类。不过当我看到注释中的解释也就明白了，其 <code>Dictionary</code> 源码注释是这样的：<code>NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class.</code> 该话指出 <code>Dictionary</code> 这个类过时了，新的实现类应该实现<code>Map</code>接口。</p><h2>三、属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashtable被结构型修改的次数。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>HashTable</code>并没有像<code>HashMap</code>那样定义了很多的常量，而是直接写死在了方法里。</p><p><code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。</p><h2>四、构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认初始化容量（11）和默认负载因子（0.75）来构造一个空的hashtable.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里可以看到，Hashtable默认初始化容量为16，而HashMap的默认初始化容量为11。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以获取到这些信息：<code>HashTable</code>默认的初始化容量为11（与<code>HashMap</code>不同），负载因子默认为0.75（与<code>HashMap</code>相同）。而正因为默认初始化容量的不同，同时也没有对容量做调整的策略，所以可以先推断出，<code>HashTable</code>使用的哈希函数跟<code>HashMap</code>是不一样的（事实也确实如此）。</p><h2>五、重要方法</h2><h4>5.1 get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//通过哈希函数，计算出key对应的桶的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">//遍历该桶的所有元素，寻找该key</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，<code>Hashtable</code>和<code>HashMap</code>确认<code>key</code>在数组中的索引的方法不同。</p><ul><li><code>Hashtable</code>通过<code>index = (hash &amp; 0x7FFFFFFF) % tab.length;</code>来确认</li><li><code>HashMap</code>通过<code>i = (n - 1) &amp; hash;</code>来确认</li></ul><p>跟<code>HashMap</code>相比，<code>HashTable</code>的<code>get</code>方法非常简单。我们首先可以看见<code>get</code>方法使用了<code>synchronized</code>来修饰，所以它能保证线程安全。并且它是通过链表的方式来处理冲突的。另外，我们还可以看见<code>HashTable</code>并没有像<code>HashMap</code>那样封装一个哈希函数，而是直接把哈希函数写在了方法中。而哈希函数也是比较简单的，<strong>它仅对哈希表的长度进行了取模</strong>。</p><h4>5.2 put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确认value不为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//找到key在table中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">//获取key所在索引的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//遍历entry，判断key是否已经存在</span></span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">//如果key已经存在</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="comment">//保存旧的value</span></span><br><span class="line">            V old = entry.value;</span><br><span class="line">            <span class="comment">//替换value</span></span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">//返回旧的value</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key在hashtable不是已经存在，就直接将键值对添加到table中，返回null</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//哈希表的键值对个数达到了阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="comment">//把新节点插入桶中（头插法）</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以总结出<code>Hashtable</code>的<code>put</code>方法的总体思路：</p><ul><li>确认<code>value</code>不为<code>null</code>。如果为<code>null</code>，则抛出异常</li><li>找到<code>key</code>在<code>table</code>中的索引，获取<code>key</code>所在位置的<code>entry</code></li><li>遍历<code>entry</code>，判断<code>key</code>是否已经存在</li><li>如果<code>key</code>已经存在，替换<code>value</code>，返回旧的<code>value</code></li><li>如果<code>key</code>在<code>hashtable</code>不是已经存在，就直接添加，否则直接将键值对添加到<code>table</code>中，返回<code>null</code></li></ul><p>在方法中可以看到，在遍历桶中元素时，是按照链表的方式遍历的。可以印证，<code>HashMap</code>的桶中可能为链表或者树。但<code>Hashtable</code>的桶中只可能是链表。</p><h4>5.3 remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//计算key在hashtable中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//遍历entry，如果entry中存在key为参数key的键值对，就删除键值对，并返回键值对的value</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不存在key为参数key的键值对，返回value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以总结出<code>Hashtable</code>的<code>remove</code>方法的总体思路：</p><ul><li>找到<code>key</code>在<code>table</code>中的索引，获取<code>key</code>所在位置的<code>entry</code></li><li>遍历<code>entry</code>，判断<code>key</code>是否已经存在</li><li>如果<code>key</code>存在，删除<code>key</code>映射的键值对，返回旧的<code>value</code></li><li>如果<code>key</code>在<code>hashtable</code>不存在，返回<code>null</code></li></ul><h4>5.4 rehash方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加hashtable的容量，为了更有效地存放和找到它的entry。</span></span><br><span class="line"><span class="comment"> * 当键值对的数量超过了临界值（capacity*load factor）这个方法自动调用</span></span><br><span class="line"><span class="comment"> * 长度变为原来的2倍+1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    <span class="comment">//记录旧桶的数组</span></span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//新的容量为旧的容量的2倍+1</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果新的容量大于容量的最大值MAX_ARRAY_SIZE </span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧容量为MAX_ARRAY_SIZE，容量不变，中断方法的执行</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果旧容量不为MAX_ARRAY_SIZE，新容量变为MAX_ARRAY_SIZE</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新的数组，容量为新容量</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">    <span class="comment">//结构性修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//计算扩容的临界值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line">    <span class="comment">//将旧的数组中的键值对转移到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完代码，我们可以总结出<code>rehash</code>的总体思路为：</p><ul><li>新建变量新的容量，值为旧的容量的2倍+1</li><li>如果新的容量大于容量的最大值<code>MAX_ARRAY_SIZE</code><ul><li>如果旧容量为<code>MAX_ARRAY_SIZE</code>，容量不变，中断方法的执行</li><li>如果旧容量不为<code>MAX_ARRAY_SIZE</code>，新容量变为<code>MAX_ARRAY_SIZE</code></li></ul></li><li>创建新的数组，容量为新容量</li><li>将旧的数组中的键值对转移到新数组中</li></ul><p>这里可以看到，一般情况下，<code>HashMap</code>扩容后容量变为原来的两倍，而<code>Hashtable</code>扩容后容量变为原来的两倍加一。</p><p><strong><code>HashTable</code>的<code>rehash</code>方法相当于<code>HashMap</code>的<code>resize</code>方法。跟<code>HashMap</code>那种巧妙的<code>rehash</code>方式相比，<code>HashTable</code>的<code>rehash</code>过程需要对每个键值对都重新计算哈希值，而比起异或和与操作，取模是一个非常耗时的操作，所以这也是导致效率较低的原因之一。</strong></p><h2>六、遍历</h2><p>可以使用与<code>HashMap</code>一样的遍历方式，但是由于历史原因，多了<code>Enumeration</code>的方式。</p><h5>针对Enumeration，这里与iterator进行对比一下。</h5><h6>相同点</h6><ul><li><code>Iterator</code>和<code>Enumeration</code>都可以对某些容器进行遍历。</li><li><code>Iterator</code>和<code>Enumeration</code>都是接口。</li></ul><h6>不同点</h6><ul><li><code>Iterator</code>有对容器进行修改的方法。而<code>Enumeration</code>只能遍历。</li><li><code>Iterator</code>支持<code>fail-fast</code>，而<code>Enumeration</code>不支持。</li><li><code>Iterator</code>比<code>Enumeration</code>覆盖范围广，基本所有容器中都有<code>Iterator</code>迭代器，而只有<code>Vector</code>、<code>Hashtable</code>有<code>Enumeration</code>。</li><li><code>Enumeration</code>在JDK 1.0就已经存在了，而<code>Iterator</code>是JDK2.0新加的接口。</li></ul><h2>七、Hashtable与HashMap对比</h2><p><code>HashTable</code>的应用非常广泛，<code>HashMap</code>是新框架中用来代替<code>HashTable</code>的类，也就是说建议使用<code>HashMap</code>。</p><h4>下面着重比较一下二者的区别：</h4><h5>1.继承不同</h5><p><code>Hashtable</code>是基于陈旧的<code>Dictionary</code>类的，<code>HashMap</code>是java1.2引进的Map接口的一个实现。</p><h5>2.同步</h5><p><code>Hashtable</code> 中的方法是同步的，保证了<code>Hashtable</code>中的对象是线程安全的。</p><p><code>HashMap</code>中的方法在缺省情况下是非同步的,<code>HashMap</code>中的对象并不是线程安全的。在多线程并发的环境下，可以直接使用<code>Hashtable</code>，但是要使用<code>HashMap</code>的话就要自己增加同步处理了。</p><h5>3.效率</h5><p>单线程中, <code>HashMap</code>的效率大于<code>Hashtable</code>。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合，<code>HashMap</code>是<code>Hashtable</code>的轻量级实现，这样可以避免由于同步带来的不必要的性能开销，从而提高效率。</p><h5>4.null值</h5><p><code>Hashtable</code>中，<code>key</code>和<code>value</code>都不允许出现<code>null</code>值，否则出现<code>NullPointerException</code>。</p><p>在<code>HashMap</code>中，<code>null</code>可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为<code>nul</code>l。当<code>get()</code>方法返回<code>null</code>值时，即可以表示 <code>HashMap</code>中没有该键，也可以表示该键所对应的值为<code>null</code>。因此，<strong>在<code>HashMap</code>中不能由<code>get()</code>方法来判断<code>HashMap</code>中是否存在某个键，而应该用<code>containsKey()</code>方法来判断</strong>。</p><h5>5.遍历方式</h5><p><code>Hashtable</code>、<code>HashMap</code>都使用了 <code>Iterator</code>。而由于历史原因，<code>Hashtable</code>可以使用<code>Enumeration</code>的方式。</p><h5>6.容量</h5><p><code>Hashtable</code>和<code>HashMap</code>它们两个内部实现方式的数组的初始大小和扩容的方式。</p><p><code>HashTable</code>中<code>hash</code>数组默认大小是11，增加的方式是 <code>old*2+1</code>。</p><p><code>HashMap</code>中<code>hash</code>数组的默认大小是16，而且一定是2的指数。</p><h2>八、总结</h2><p>无论什么时候有多个线程访问相同实例的可能时，就应该使用<code>Hashtable</code>，反之使用<code>HashMap</code>。非线程安全的数据结构能带来更好的性能。</p><p>如果在将来有一种可能—你需要按顺序获得键值对的方案时，<code>HashMap</code>是一个很好的选择，因为有<code>HashMap</code>的一个子类 <code>LinkedHashMap</code>。</p><p>所以如果你想可预测的按顺序迭代（默认按插入的顺序），你可以很方便用<code>LinkedHashMap</code>替换<code>HashMap</code>。反观要是使用的<code>Hashtable</code>就没那么简单了。</p><p>如果有多个线程访问<code>HashMap</code>，<code>Collections.synchronizedMap（）</code>可以代替，总的来说<code>HashMap</code>更灵活，或者直接用并发容器<code>ConcurrentHashMap</code>。</p><p>整理自：</p><ul><li><a href="http://blog.csdn.net/panweiwei1994/article/details/77428710" target="_blank" rel="noopener">http://blog.csdn.net/panweiwei1994/article/details/77428710</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52655042" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52655042</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap和LinkedHashMap遍历机制</title>
      <link href="/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>本篇单独讲一下HashMap和LinkedHashMap遍历方式。</p><a id="more"></a><h2>一、对HashMap和LinkedHashMap遍历的几种方法</h2><p>这里以<code>HashMap</code>为例，<code>LinkedHashMap</code>一样的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>强烈建议使用第一种 <code>EntrySet</code> 进行遍历。</strong></p><p>第一种可以把 <code>key value</code> 同时取出，第二种还得需要通过 <code>key</code> 取一次 <code>value</code>，效率较低, 第三种需要 <code>JDK1.8</code> 以上，通过外层遍历 <code>table</code>，内层遍历链表或红黑树。</p><p>我们知道，<code>HashMap</code>的输出顺序与元素的输入顺序无关，<code>LinkedHashMap</code>可以按照输入顺序输出，也可以根据读取元素的顺序输出。这一现象，已经在上一篇中展示出来了。</p><h2>二、HashMap的遍历机制</h2><p><code>HashMap</code> 提供了两个遍历访问其内部元素<code>Entry&lt;k,v&gt;</code>的接口：</p><ol><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>-------&gt;返回此映射所包含的映射关系的 Set 视图。</li><li><code>Set&lt;K&gt; keySet()</code>--------&gt;返回此映射中所包含的键的 Set 视图。</li></ol><blockquote><p>实际上，第二个接口表示的<code>Key</code>的顺序，和第一个接口返回的<code>Entry</code>顺序是对应的，也就是说：这两种接口对<code>HashMap</code>的元素遍历的顺序相相同的。  那么，<code>HashMap</code>遍历内部<code>Entry&lt;K,V&gt;</code> 的顺序是什么呢？ 搞清楚这个问题，先要知道其内部结构是怎样的。</p></blockquote><p><code>HashMap</code>在存储<code>Entry</code>对象的时候，是根据<code>Key</code>的<code>hash</code>值判定存储到<code>Entry[] table</code>数组的哪一个索引值表示的链表上。</p><p>对<code>HashMap</code>遍历<code>Entry</code>对象的顺序和<code>Entry</code>对象的存储顺序之间没有任何关系。</p><p><strong><code>HashMap</code>散列图、<code>Hashtable</code>散列表是按“有利于随机查找的散列(hash)的顺序”。并非按输入顺序。遍历时只能全部输出，而没有顺序</strong>。甚至可以<code>rehash()</code>重新散列，来获得更利于随机存取的内部顺序。</p><p>所以对<code>HashMap</code>的遍历，由内部的机制决定的，这个机制是只考虑利于快速存取，不考虑输入等顺序。</p><h2>三、LinkedHashMap 的遍历机制</h2><p><code>LinkedHashMap</code> 是<code>HashMap</code>的子类，它可以实现对容器内Entry的存储顺序和对Entry的遍历顺序保持一致。</p><p>为了实现这个功能，<strong><code>LinkedHashMap</code>内部使用了一个<code>Entry</code>类型的双向链表，用这个双向链表记录<code>Entry</code>的存储顺序</strong>。当需要对该<code>Map</code>进行遍历的时候，实际上是遍历的是这个双向链表。</p><p><code>LinkedHashMap</code>内部使用的<code>LinkedHashMap.Entry</code>类继承自<code>Map.Entry</code>类，在其基础上增加了<code>LinkedHashMap.Entry</code>类型的两个字段，用来引用该<code>Entry</code>在双向链表中的前面的<code>Entry</code>对象和后面的<code>Entry</code>对象。</p><p>它的内部会在<code>Map.Entry</code>类的基础上，增加两个<code>Entry</code>类型的引用：<code>before</code>，<code>after</code>。<code>LinkedHashMap</code>使用一个双向连表，将其内部所有的<code>Entry</code>串起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap linkedHashMap = <span class="keyword">new</span> LinkedHashMap();  </span><br><span class="line">linkedHashMap.put(<span class="string">"name"</span>,<span class="string">"louis"</span>);  </span><br><span class="line">linkedHashMap.put(<span class="string">"age"</span>,<span class="string">"24"</span>);  </span><br><span class="line">linkedHashMap.put(<span class="string">"sex"</span>,<span class="string">"male"</span>);</span><br></pre></td></tr></table></figure><p>对<code>LinkedHashMap</code>进行遍历的策略：</p><p><strong>从 <code>header.after</code> 指向的<code>Entry</code>对象开始，然后一直沿着此链表遍历下去，直到某个<code>entry.after == header</code> 为止，完成遍历。</strong></p><p>根据<code>Entry&lt;K,V&gt;</code>插入<code>LinkedHashMap</code>的顺序进行遍历的方式叫做：按插入顺序遍历。</p><p>另外，<code>LinkedHashMap</code>还支持一种遍历顺序，叫做：Get读取顺序。</p><p>如果<code>LinkedHashMap</code>的这个<code>Get</code>读取遍历顺序开启，那么，当我们在<code>LinkedHashMap</code>上调用<code>get(key)</code> 方法时，会导致内部<code>key</code>对应的<code>Entry</code>在双向链表中的位置移动到双向链表的最后。</p><h2>四、遍历机制的总结</h2><ol><li><p><code>HashMap</code>对元素的遍历顺序跟<code>Entry</code>插入的顺序无关，而<code>LinkedHashMap</code>对元素的遍历顺序可以跟<code>Entry&lt;K,V&gt;</code>插入的顺序保持一致：从双向。</p></li><li><p>当<code>LinkedHashMap</code>处于<code>Get</code>获取顺序遍历模式下，当执行<code>get()</code> 操作时，会将对应的<code>Entry&lt;k,v&gt;</code>移到遍历的最后位置。</p></li><li><p><code>LinkedHashMap</code>处于按插入顺序遍历的模式下，如果新插入的<code>&lt;key,value&gt;</code> 对应的<code>key</code>已经存在，对应的<code>Entry</code>在遍历顺序中的位置并不会改变。</p></li><li><p>除了遍历顺序外，其他特性<code>HashMap</code>和<code>LinkedHashMap</code>基本相同。</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedHashMap</title>
      <link href="/2019/01/20/java-collection/7.LinkedHashMap/"/>
      <url>/2019/01/20/java-collection/7.LinkedHashMap/</url>
      <content type="html"><![CDATA[<p>大多数情况下，只要不涉及线程安全问题， Map 基本都可以使用 HashMap ，不过 HashMap 有一个问题，就是迭代 HashMap 的顺序并不是 HashMap 放置的顺序，也就是无序。 HashMap 的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的 Map。</p><a id="more"></a><div class="tip">篇幅有点长，但是在理解了HashMap之后就比较简单了。</div><p>这个时候，<code>LinkedHashMap</code>就闪亮登场了，它虽然增加了时间和空间上的开销，但是可以解决有排序需求的场景。</p><p>它的底层是继承于 <code>HashMap</code> 实现的，由一个<strong>双向循环链表</strong>所构成。</p><p><code>LinkedHashMap</code> 的排序方式有两种：</p><ul><li>根据写入顺序排序。</li><li>根据访问顺序排序。</li></ul><p>其中根据访问顺序排序时，每次 <code>get</code> 都会将访问的值移动到链表末尾，这样重复操作就能得到一个按照访问顺序排序的链表。</p><h2>一、LinkedHashMap数据结构</h2><p><img src="http://bloghello.oursnail.cn/collection7-1.jpg" alt="image"></p><p><code>LinkedHashMap</code>是通过哈希表和双向循环链表实现的，它通过维护一个双向循环链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。</p><p>我们可以看出，遍历所有元素只需要从header开始遍历即可，一直遍历到下一个元素是header结束。</p><p>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说，假设你插入的键的顺序为1、2、3、4，后来再次插入2，迭代时的顺序还是1、2、3、4，而不会因为后来插入的2变成1、3、4、2。（但其实我们可以改变它的规则，使它变成1、3、4、2）</p><p><code>LinkedHashMap</code>的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希表部分继承了<code>HashMap</code>，拥有了<code>HashMap</code>那一套高效的操作，所以我们要看的就是<code>LinkedHashMap</code>中链表的部分，了解它是如何来维护有序性的。</p><h2>二、demo示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap插入数据，遍历输出无序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------HashMap插入数据--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iter = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap插入数据，遍历，默认以插入顺序为序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------LinkedHashMap插入数据,按照插入顺序进行排序--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    linkedHashMap.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = linkedHashMap.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap插入数据，设置accessOrder=true实现使得其遍历顺序按照访问的顺序输出，这里先用get方法来演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------LinkedHashMap插入数据,accessOrder=true:按照访问顺序进行排序--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; linkedHashMap2 = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"apple"</span>, <span class="string">"aa"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"banana"</span>, <span class="string">"cc"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"peach"</span>, <span class="string">"dd"</span>);</span><br><span class="line"></span><br><span class="line">    linkedHashMap2.get(<span class="string">"banana"</span>);<span class="comment">//banana移动到了内部的链表末尾</span></span><br><span class="line">    linkedHashMap2.get(<span class="string">"apple"</span>);<span class="comment">//apple移动到了内部的链表末尾</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    Iterator iter2 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter2.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap的put方法在accessOrder=true的情况下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);<span class="comment">//watermelon移动到了内部的链表末尾</span></span><br><span class="line">    linkedHashMap2.put(<span class="string">"stawbarrey"</span>, <span class="string">"ee"</span>);<span class="comment">//末尾插入新元素stawbarrey</span></span><br><span class="line">    linkedHashMap2.put(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//插入新的节点 null</span></span><br><span class="line">    Iterator iter3 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter3.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----------HashMap插入数据--------</span><br><span class="line">banana=c</span><br><span class="line">apple=a</span><br><span class="line">peach=d</span><br><span class="line">watermelon=b</span><br><span class="line">----------LinkedHashMap插入数据,按照插入顺序进行排序--------</span><br><span class="line">apple=a</span><br><span class="line">watermelon=b</span><br><span class="line">banana=c</span><br><span class="line">peach=d</span><br><span class="line">----------LinkedHashMap插入数据,按照访问顺序进行排序--------</span><br><span class="line">watermelon=bb</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc<span class="comment">//banana到了末尾</span></span><br><span class="line">apple=aa<span class="comment">//apple到了末尾</span></span><br><span class="line">-----------</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc</span><br><span class="line">apple=aa</span><br><span class="line">watermelon=bb<span class="comment">//watermelon到了链表末尾</span></span><br><span class="line">stawbarrey=ee<span class="comment">//新插入的放在末尾</span></span><br><span class="line"><span class="keyword">null</span>=<span class="keyword">null</span><span class="comment">//新插入的放在末尾</span></span><br></pre></td></tr></table></figure><h2>三、属性</h2><p><code>LinkedHashMap</code>可以认为是<code>HashMap+LinkedList</code>，即它既使用<code>HashMap</code>操作数据结构，又使用<code>LinkedList</code>维护插入元素的先后顺序</p><h5>3.1 继承关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，自然<code>LinkedHashMap</code>也就继承了<code>HashMap</code>中所有非private的方法。所以它已经从 <code>HashMap</code> 那里继承了与哈希表相关的操作了，那么在<code>LinkedHashMap</code>中，它可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p><h5>3.2 属性介绍</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap的链表节点继承了HashMap的节点，而且每个节点都包含了前指针和后指针，所以这里可以看出它是一个双向链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认为false。当为true时，表示链表中键值对的顺序与每个键的插入顺序一致，也就是说重复插入键，也会更新顺序</span></span><br><span class="line"><span class="comment">//简单来说，为false时，就是上面所指的1、2、3、4的情况；为true时，就是1、3、4、2的情况</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h2>五、构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是调用的 <code>HashMap</code> 的构造方法:</p><p><code>HashMap</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//HashMap 只是定义了改方法，具体实现交给了 LinkedHashMap</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面有一个空的 <code>init()</code>，具体是由 <code>LinkedHashMap</code> 来实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也就是对 <code>header</code> 进行了初始化。</p><h2>六、添加元素</h2><p><img src="http://bloghello.oursnail.cn/collection7-2.jpg" alt="image"></p><p><code>LinkedHashMap</code>并没有重写任何<code>put</code>方法。但是其重写了构建新节点的<code>newNode()</code>方法.</p><p><code>newNode()</code> 会在<code>HashMap</code>的<code>putVal()</code> 方法里被调用，<code>putVal()</code> 方法会在批量插入数据<code>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</code> 或者插入单个数据<code>public V put(K key, V value)</code>时被调用。</p><p><code>LinkedHashMap</code>重写<code>了newNode()</code>,在每次构建新节点时，通过<code>linkNodeLast(p);</code>将新节点链接在内部双向链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`.</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将新增的节点，连接在链表的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">//集合之前是空的</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//将新节点连接在链表的尾部</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及<code>HashMap</code>专门预留给<code>LinkedHashMap</code>的<code>afterNodeAccess()</code> 、<code>afterNodeInsertion()</code> 、<code>afterNodeRemoval()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>如果你没有注意到注释的解释的话，你可能会很奇怪为什么会有三个空方法，而且有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点之后，进行一些处理，它们在<code>LinkedHashMap</code>有各自的实现。<code>LinkedHashMap</code>正是通过重写这三个方法来保证链表的插入、删除的有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数，新节点插入之后回调,判断是否需要删除最老插入的节点。</span></span><br><span class="line"><span class="comment">//如果实现LruCache会用到这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">//LinkedHashMap 默认返回false 则不删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap 默认返回false 则不删除节点。 </span></span><br><span class="line"><span class="comment">//返回true 代表要删除最早的节点。</span></span><br><span class="line"><span class="comment">//通常构建一个LruCache会在达到Cache的上限是返回true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void afterNodeInsertion(boolean evict)</code>以及<code>boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code> 是构建LruCache需要的回调，在这可以忽略它们。</p><h2>七、删除元素</h2><p><code>LinkedHashMap</code>也没有重写<code>remove()</code> 方法，因为它的删除逻辑和<code>HashMap</code>并无区别。<br>但它重写了<code>afterNodeRemoval()</code> 这个回调方法。该方法会在<code>Node&lt;K,V&gt; removeNode(int hash, Object key</code>, <code>Object value</code>,<br><code>boolean matchValue, boolean movable)</code> 方法中回调，<code>removeNode()</code> 会在所有涉及到删除节点的方法中被调用，上文分析过，是删除节点操作的真正执行者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在删除节点e时，同步将e从双向链表上删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">//待删除节点 p 的前置后置节点都置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果前置节点是null，则现在的头结点应该是后置节点a</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则将前置节点b的后置节点指向a</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">//同理如果后置节点时null ，则尾节点应是b</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则更新后置节点a的前置节点为b</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>八、查询元素</h2><p><code>LinkedHashMap</code>重写了<code>get()</code>和<code>getOrDefault()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>HashMap</code>中的实现,<code>LinkedHashMap</code>只是增加了在成员变量(构造函数时赋值)<code>accessOrder</code>为true的情况下，要去回调<code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>afterNodeAccess()</code> 函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;<span class="comment">//原尾节点</span></span><br><span class="line">    <span class="comment">//如果accessOrder 是true ，且原尾节点不等于e</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">//节点e强转成双向链表节点p</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">//p现在是尾节点， 后置节点一定是null</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果p的前置节点是null，则p以前是头结点，所以更新现在的头结点是p的后置节点a</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则更新p的前直接点b的后置节点为 a</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">//如果p的后置节点不是null，则更新后置节点a的前置节点为b</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果原本p的后置节点是null，则p就是尾节点。 此时 更新last的引用为 p的前置节点b</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//原本尾节点是null  则，链表中就一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点的引用赋值成p</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">//修改modCount。</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示(注意这个图，1和6也应该是连在一起的，因为是双向循环链表，所以视为一个小错误)：</p><p><img src="http://hashmap.oursnail.cn/afterNodeAccess.png" alt="image"></p><p>说明：从图中可以看到，结点3链接到了尾结点后面。</p><p><strong>值得注意的是，<code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</strong></p><h2>九、判断元素是否存在</h2><p>它重写了该方法，相比<code>HashMap</code>的实现，更为高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历一遍链表，去比较有没有value相等的节点，并返回</span></span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>HashMap</code>，是用两个<code>for</code>循环遍历，相对低效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>十、替换某个元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用dst替换src</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = dst;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://hashmap.oursnail.cn/transferLinks.png" alt="image"></p><h2>十二、总结</h2><p><code>LinkedHashMap</code>相对于<code>HashMap</code>的源码比，是很简单的。因为大树底下好乘凉。它继承了<code>HashMap</code>，仅重写了几个方法，以改变它迭代遍历时的顺序。这也是其与<code>HashMap</code>相比最大的不同。<br>在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。</p><ul><li><p><code>accessOrder</code>默认是<code>false</code>，则迭代时输出的顺序是插入节点的顺序。若为<code>true</code>，则输出的顺序是按照访问节点的顺序。为<code>true</code>时，可以在这基础之上构建一个<code>LruCache</code>.</p></li><li><p><code>LinkedHashMap</code>并没有重写任何put方法。但是其重写了构建新节点的<code>newNode()</code>方法.在每次构建新节点时，将新节点链接在内部双向链表的尾部</p></li><li><p><code>accessOrder=true</code>的模式下,在<code>afterNodeAccess()</code>函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。值得注意的是，<code>afterNodeAccess()</code>函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</p></li><li><p><code>nextNode()</code> 就是迭代器里的<code>next()</code>方法 。该方法的实现可以看出，迭代<code>LinkedHashMap</code>，就是从内部维护的双链表的表头开始循环输出。</p></li><li><p>而双链表节点的顺序在<code>LinkedHashMap</code>的增、删、改、查时都会更新。以满足按照插入顺序输出，还是访问顺序输出。</p></li><li><p>它与<code>HashMap</code>比，还有一个小小的优化，重写了<code>containsValue()</code>方法，直接遍历内部链表去比对<code>value</code>值是否相等。</p></li></ul><p>整理自：</p><ul><li><a href="http://blog.csdn.net/zxt0601/article/details/77429150" target="_blank" rel="noopener">http://blog.csdn.net/zxt0601/article/details/77429150</a></li><li><a href="http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52659741" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52659741</a></li><li><a href="http://www.cnblogs.com/leesf456/p/5248868.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/5248868.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashSet</title>
      <link href="/2019/01/20/java-collection/6.HashSet/"/>
      <url>/2019/01/20/java-collection/6.HashSet/</url>
      <content type="html"><![CDATA[<p>HashSet 是一个不允许存储重复元素的集合，它是基于 HashMap 实现的， HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet  的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成。所以只要理解了 HashMap，HashSet 就水到渠成了。</p><a id="more"></a><h2>成员变量</h2><p>首先了解下<code>HashSet</code>的成员变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>发现主要就两个变量:</p><ul><li><code>map</code> ：用于存放最终数据的。</li><li><code>PRESENT</code> ：是所有写入<code>map</code>的<code>value</code>值。</li></ul><h2>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数很简单，利用了<code>HashMap</code>初始化了<code>map</code>。</p><h2>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会受到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p><p>该方法如果添加的是在 <code>HashSet</code> 中不存在的，则返回 <code>true</code>；如果添加的元素已经存在，返回 <code>false</code>。其原因在于我们之前提到的关于 <code>HashMap</code> 的 <code>put</code> 方法。该方法在添加 <code>key</code> 不重复的键值对的时候，会返回 <code>null</code>。</p><h2>总结</h2><p><code>HashSet</code> 的原理比较简单，几乎全部借助于 <code>HashMap</code> 来实现的。</p><p>所以 <code>HashMap</code> 会出现的问题 <code>HashSet</code> 依然不能避免。</p><p>对于 <code>HashSet</code> 中保存的对象，请注意正确重写其 <code>equals</code> 和 <code>hashCode</code> 方法，以保证放入的对象的唯一性。这两个方法是比较重要的。</p>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap</title>
      <link href="/2019/01/20/java-collection/5.HashMap/"/>
      <url>/2019/01/20/java-collection/5.HashMap/</url>
      <content type="html"><![CDATA[<p>HashMap基本是面试必问的点，因为这个数据结构用的太频繁了，jdk1.8中的优化也是比较巧妙。有必要去深入探讨一下。但是涉及的内容比较多，这里只先探讨jdk8中HashMap的实现，至于jdk7中HashMap的死循环问题、红黑树的原理等都不会在本篇文章扩展到。其他的文章将会再去探讨整理。</p><a id="more"></a><p>本篇文章较长，高能预警。</p><h2>一、前言</h2><p>之前的<code>List</code>，讲了<code>ArrayList</code>、<code>LinkedList</code>，最后讲到了<code>CopyOnWriteArrayList</code>，就前两者而言，反映的是两种思想：</p><p>（1）<code>ArrayList</code>以数组形式实现，顺序插入、查找快，插入、删除较慢</p><p>（2）<code>LinkedList</code>以链表形式实现，顺序插入、查找较慢，插入、删除方便</p><p>那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是<code>HashMap</code>。</p><p><code>HashMap</code>是一种非常常见、方便和有用的集合，是一种键值对（K-V）形式的存储结构，在有了<code>HashCode</code>的基础后，下面将还是用图示的方式解读<code>HashMap</code>的实现原理。</p><p>Java为数据结构中的映射定义了一个接口<code>java.util.Map</code>，此接口主要有四个常用的实现类，分别是<code>HashMap</code>、<code>Hashtable</code>、<code>LinkedHashMap</code>和<code>TreeMap</code>，类继承关系如下图所示：</p><p><img src="http://hashmap.oursnail.cn/map%E6%8E%A5%E5%8F%A3.png" alt="image"></p><p>(1) <code>HashMap</code>：它根据键的<code>hashCode</code>值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 <code>HashMap</code>最多只允许一条记录的键为<code>null</code>，允许多条记录的值为<code>null</code>。<code>HashMap</code>非线程安全，即任一时刻可以有多个线程同时写<code>HashMap</code>，可能会导致数据的不一致。如果需要满足线程安全，可以用 <code>Collections</code>的<code>synchronizedMap</code>方法使<code>HashMap</code>具有线程安全的能力，或者使用<code>ConcurrentHashMap</code>。</p><p>(2) <code>Hashtable</code>：<code>Hashtable</code>是遗留类，很多映射的常用功能与<code>HashMap</code>类似，不同的是它承自<code>Dictionary</code>类，并且是线程安全的，任一时间只有一个线程能写<code>Hashtable</code>，并发性不如<code>ConcurrentHashMap</code>，因为<code>ConcurrentHashMap</code>引入了分段锁。<code>Hashtable</code>不建议在新代码中使用，不需要线程安全的场合可以用<code>HashMap</code>替换，需要线程安全的场合可以用<code>ConcurrentHashMap</code>替换。</p><p>(3) <code>LinkedHashMap</code>：<code>LinkedHashMap</code>是<code>HashMap</code>的一个子类，保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>(4) <code>TreeMap</code>：<code>TreeMap</code>实现<code>SortedMap</code>接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code>遍历<code>TreeMap</code>时，得到的记录是排过序的。如果使用排序的映射，建议使用<code>TreeMap</code>。在使用<code>TreeMap</code>时，key必须实现<code>Comparable</code>接口或者在构造<code>TreeMap</code>传入自定义的<code>Comparator</code>，否则会在运行时抛出<code>java.lang.ClassCastException</code>类型的异常。</p><p>对于上述四种<code>Map</code>类型的类，要求映射中的<code>key</code>是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，<code>Map</code>对象很可能就定位不到映射的位置了。</p><h2>二、HashMap的结构</h2><p>其中哈希表是一个数组，<strong>我们经常把数组中的每一个节点称为一个桶</strong>，哈希表中的每个节点都用来存储一个键值对。</p><p>在插入元素时，如果发生冲突（即多个键值对映射到同一个桶上）的话，就会通过链表的形式来解决冲突。</p><p>因为<strong>一个桶上可能存在多个键值对</strong>，所以在查找的时候，会先通过<code>key</code>的哈希值先定位到桶，再遍历桶上的所有键值对，找出<code>key</code>相等的键值对，从而来获取<code>value</code>。</p><p><img src="http://bloghello.oursnail.cn/HashMap%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p><p>如图所示，<code>HashMap</code> 底层是基于数组和链表实现的。其中有两个重要的参数：</p><ul><li>容量</li><li>负载因子</li></ul><p>容量的默认大小是 16，负载因子是 0.75，当 <code>HashMap</code> 的 size &gt; 16*0.75 时就会发生扩容(容量和负载因子都可以自由调整)。</p><h2>三、继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p><code>HashMap</code>继承自<code>AbstractMap</code>，<code>AbstractMap</code>是<code>Map</code>接口的骨干实现，<code>AbstractMap</code>中实现了<code>Map</code>中最重要最常用和方法，这样<code>HashMap</code>继承<code>AbstractMap</code>就不需要实现<code>Map</code>的所有方法，让<code>HashMap</code>减少了大量的工作。</p></blockquote><h2>四、属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//最大的容量上限为2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的负载因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//变成树型结构的临界值为8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//恢复链式结构的临界值为6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表的最小树形化容量</span></span><br><span class="line"><span class="comment"> * 当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span></span><br><span class="line"><span class="comment"> * 否则桶内元素太多时会扩容，而不是树形化</span></span><br><span class="line"><span class="comment"> * 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//哈希表被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//它是通过capacity*load factor计算出来的，当size到达这个值时，就会进行扩容操作</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h5>4.1 几个属性的详细说明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>首先，<code>Node[] table</code>的初始化长度<code>length</code>(<strong>默认值是16</strong>)，<code>Load factor</code>为负载因子(<strong>默认值是0.75</strong>)，<code>threshold</code>是<code>HashMap</code>所能容纳的最大数据量的<code>Node</code>(键值对)个数。<code>threshold = length * Load factor</code>。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，<code>threshold</code>就是在此<code>Load factor</code>和<code>length</code>(数组长度)对应下允许的最大元素数目，超过这个数目就重新<code>resize</code>(扩容)，<strong>扩容后的<code>HashMap</code>容量是之前容量的两倍（为什么是两倍下文会说明）</strong>。</p><div class="tip">默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子`Load factor`的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子`loadFactor`的值，这个值可以大于1。</div><p><code>size</code>这个字段其实很好理解，就是<code>HashMap</code>中<strong>实际存在的键值对数量</strong>。<strong>注意<code>size</code>和<code>table</code>的长度<code>length</code>、容纳最大键值对数量<code>threshold</code>的区别</strong>。</p><p>而<code>modCount</code>字段主要用来记录<code>HashMap</code>内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，<strong>内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个<code>key</code>对应的<code>value</code>值被覆盖不属于结构变化。</strong></p><p><strong>在<code>HashMap</code>中，哈希桶数组<code>table</code>的长度<code>length</code>大小必须为2的n次方(一定是合数)</strong>，这是一种非常规的设计，因为常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考 <a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a> ，<code>Hashtable</code>初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。<strong><code>HashMap</code>采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，<code>HashMap</code>定位哈希桶索引位置时，也加入了高位参与运算的过程。下文会说明。</strong></p><p>这里存在一个问题，即使负载因子和<code>Hash</code>算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响<code>HashMap</code>的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。<strong>而当链表长度太长（默认超过8）时，并且链表的长度超过64时，链表就转换为红黑树</strong>，利用红黑树快速增删改查的特点提高<code>HashMap</code>的性能，其中会用到红黑树的插入、删除、查找等算法。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E7%BB%93%E6%9E%84.png" alt="image"></p><p>这里着重提一下<code>MIN_TREEIFY_CAPACITY</code>字段，容易与<code>TREEIFY_THRESHOLD</code>打架，<code>TREEIFY_THRESHOLD</code>是指桶中元素达到8个，就将其本来的链表结构改为红黑树，提高查询的效率。<code>MIN_TREEIFY_CAPACITY</code>是指最小树化的哈希表元素个数，也就是说，小于这个值，就算你(数组)桶里的元素数量大于8了，还是要用链表存储，只有同时满足：表中数据容量已经扩容到<code>MIN_TREEIFY_CAPACITY</code>这个长度，并且桶里的数据个数达到8个的时候，才会将该桶里的结构进行树化。注意扩容是数组的复制。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E7%BB%93%E6%9E%842.png" alt="image"></p><h5>4.2 Node结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code>是<code>HashMap</code>的一个内部类，实现了<code>Map.Entry</code>接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个<code>Node</code>对象。</p><p>例如程序执行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</span><br></pre></td></tr></table></figure><p>系统将调用&quot;美团&quot;这个<code>key</code>的<code>hashCode()</code>方法得到其<code>hashCode</code>值（该方法适用于每个<code>Java</code>对象）。</p><p>然后再通过<code>Hash</code>算法来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了<code>Hash</code>碰撞。</p><p>当然<code>Hash</code>算法计算结果越分散均匀，<code>Hash</code>碰撞的概率就越小，<code>map</code>的存取效率就会越高。</p><p>如果哈希桶数组很大，即使较差的<code>Hash</code>算法也会比较分散，如果哈希桶数组数组很小，即使好的<code>Hash</code>算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少<code>Hash</code>碰撞。</p><p><strong>那么通过什么方式来控制<code>map</code>使得<code>Hash</code>碰撞的概率又小，哈希桶数组（<code>Node[] table</code>）占用空间又少呢？答案就是好的<code>Hash</code>算法(5.4节)和扩容机制(5.5节)。下文会讲到。</strong></p><h2>五、方法</h2><h5>5.1 get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get方法主要调用的是getNode方法，所以重点要看getNode方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空 &amp;&amp; key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//是否直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//判断是否有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前的桶是采用红黑树处理冲突，则调用红黑树的get方法去获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该key</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现步骤大致如下：</p><ul><li>通过<code>hash</code>值获取该key映射到的桶。</li><li>桶上的<code>key</code>就是要查找的<code>key</code>，则直接命中。</li><li>桶上的<code>key</code>不是要查找的<code>key</code>，则查看后续节点：</li><li>如果后续节点是树节点，通过调用树的方法查找该<code>key</code>。</li><li>如果后续节点是链式节点，则通过循环遍历链查找该<code>key</code>。</li></ul><h5>5.2 put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法的具体实现也是在putVal方法中，所以我们重点看下面的putVal方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果哈希表为空，则先创建一个哈希表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果当前桶没有碰撞冲突，则直接把键值对插入，完事</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果桶上节点的key与当前key重复，那你就是我要找的节点了</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果是采用红黑树的方式处理冲突，则通过红黑树的putTreeVal方法去插入这个键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//否则就是传统的链式结构</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//采用循环遍历的方式，判断链中是否有重复的key</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//到了链尾还没找到重复的key，则说明HashMap没有包含该键</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                    <span class="comment">//创建一个新节点插入到尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果链的长度大于TREEIFY_THRESHOLD这个临界值，则把链变为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到了重复的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里表示在上面的操作中找到了重复的键，所以这里把该键的值替换为新值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断是否需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code>方法比较复杂，实现步骤大致如下：</p><ul><li>先通过<code>hash</code>值计算出<code>key</code>映射到哪个桶。</li><li>如果桶上没有碰撞冲突，则直接插入。</li><li>如果出现碰撞冲突了，则需要处理冲突：<ul><li>如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。</li><li>否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红黑树。</li></ul></li><li>如果桶中存在重复的键，则为该键替换新值。</li><li>如果<code>size</code>大于阈值，则进行扩容。</li></ul><p><img src="http://hashmap.oursnail.cn/hashmap%E6%89%A9%E5%AE%B9.jpg" alt="image"></p><h5>5.3 remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove方法的具体实现在removeNode方法中，所以我们重点看下面的removeNode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//如果当前key映射到的桶不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//如果桶上的节点就是要找的key，则直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是以红黑树处理冲突，则构建一个树节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//如果是以链式的方式处理冲突，则通过遍历链表来寻找节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比对找到的key的value跟要删除的是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//通过调用红黑树的方法来删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//使用链表的操作来删除节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>5.4 hash方法(确定哈希桶数组索引位置)</h5><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过<code>HashMap</code>的数据结构是数组和链表的结合，所以我们当然希望这个<code>HashMap</code>里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用<code>hash</code>算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。<code>HashMap</code>定位数组索引位置，直接决定了<code>hash</code>方法的离散性能。</p><p>注意<code>get</code>方法和<code>put</code>方法源码中都需要先计算<code>key</code>映射到哪个桶上，然后才进行之后的操作，计算的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>上面代码中的n指的是哈希表的大小，<code>hash</code>指的是<code>key</code>的哈希值，<code>hash</code>是通过下面这个方法计算出来的，采用了二次哈希的方式，其中<code>key的hashCode</code>方法是一个<code>native</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于任意给定的对象，只要它的<code>hashCode()</code>返回值相同，那么程序调用方法一所计算得到的<code>Hash</code>码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在<code>HashMap</code>中是这样做的：调用方法二来计算该对象应该保存在<code>table</code>数组的哪个索引处。</p><p>这个方法非常巧妙，它通过<code>h &amp; (table.length -1)</code>来得到该对象的保存位，而<code>HashMap</code>底层数组的长度总是2的n次方，这是<code>HashMap</code>在速度上的优化。当<code>length</code>总是2的n次方时，<code>h&amp; (length-1)</code>运算等价于对<code>length</code>取模，也就是<code>h%length</code>，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在数组<code>table</code>的<code>length</code>比较小的时候，也能保证考虑到高低<code>Bit</code>都参与到<code>Hash</code>的计算中，同时不会有太大的开销。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E6%89%A9%E5%AE%B92.jpg" alt="image"></p><blockquote><p>总结就是：由于在计算中位运算比取模运算效率高的多，所以 HashMap 规定数组的长度为 2^n 。这样用 2^n - 1 做位运算与取模效果一致，并且效率还要高出许多。这样回答了上文中：好的Hash算法到底是什么。</p></blockquote><h5>5.5 resize方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前容量超过最大容量，则无法进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没超过最大值则扩为原来的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的resize阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历旧哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果桶上只有一个键值对，则直接插入</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是通过红黑树来处理冲突的，则调用相关方法把树分离开</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果采用链式处理冲突</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//通过上面讲的方法来计算节点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashMap</code>在进行扩容时，使用的<code>rehash</code>方式非常巧妙，因为每次扩容都是翻倍，与原来计算<code>（n-1）&amp;hash</code>的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</p><p>例如，原来的容量为32，那么应该拿<code>hash</code>跟31（0x11111）做与操作；在扩容扩到了64的容量之后，应该拿<code>hash</code>跟63（0x111111）做与操作。新容量跟原来相比只是多了一个bit位，假设原来的位置在23，那么当新增的那个bit位的计算结果为0时，那么该节点还是在23；相反，计算结果为1时，则该节点会被分配到23+31的桶上。</p><p><strong>这样做的好处：正是因为这样巧妙的<code>rehash</code>方式，保证了<code>rehash</code>之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了<code>rehash</code>之后不会出现更严重的冲突。回答了上文中好的扩容机制。</strong></p><h2>六、总结</h2><ul><li><code>HashMap</code>的结构底层是一个数组，每个数组元素是一个桶，后面可能会连着一串因为碰撞而聚在一起的(key,value)节点，以链表的形式或者树的形式挂着</li><li>按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表的效率降低至O（n），而通过红黑树的方式，可以把效率改进至<code>O（logn）</code>。相比链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。</li><li><code>threshold</code>是数组长度扩容的临界值</li><li><code>modCount</code>字段主要用来记录HashMap内部结构发生变化的次数，这里结构变化必须是新的值塞进来或者某个值删除这种类型，而不是仅仅是覆盖</li><li>只有同时满足：表中数据容量已经扩容到<code>MIN_TREEIFY_CAPACITY</code>这个长度，并且桶里的数据个数达到8个的时候，才会将该桶里的结构进行树化。</li><li><strong>好的hash算法</strong>：由于在计算中位运算比取模运算效率高的多，所以<code>HashMap</code>规定数组的长度为 2^n 。这样用 <code>2^n - 1</code> 与 <code>hash</code> 做位运算与取模效果一致，并且效率还要高出许多。</li><li><strong>好的扩容机制</strong>：因为每次扩容都是翻倍，与原来计算<code>（n-1）&amp;hash</code>的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。这样做的好处：正是因为这样巧妙的rehash方式，保证了rehash之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了rehash之后不会出现更严重的冲突。</li><li>还有就是要记住<code>put</code>的过程。</li></ul><p>整理自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52649867" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52649867</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hashcode/Equals</title>
      <link href="/2019/01/20/java-collection/4.hashcode%E5%92%8Cequals/"/>
      <url>/2019/01/20/java-collection/4.hashcode%E5%92%8Cequals/</url>
      <content type="html"><![CDATA[<p>hashcode涉及到集合HashMap等集合，此篇侧重于了解hashcode和equals方法的作用的原理。有助于下一篇HashMap的理解。</p><a id="more"></a><h2>一、Hash是什么</h2><p><code>Hash</code>是散列的意思，就是把任意长度的输入，通过散列算法变换成固定长度的输出，该输出就是散列值。这个玩意还可以做加密。</p><ul><li>不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞。</li><li>如果两个<code>Hash</code>值不同（前提是同一<code>Hash</code>算法），那么这两个<code>Hash</code>值对应的原始输入必定不同</li></ul><h2>二、什么是hashcode</h2><p><code>HashCode</code>的存在主要是为了查找的快捷性，<code>HashCode</code>是用来在散列存储结构中确定对象的存储地址的。</p><p>如果两个对象的<code>HashCode</code>相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置。</p><p>如果对象的<code>equals</code>方法被重写，那么对象的<code>HashCode</code>方法也尽量重写。为什么呢？下文会说。</p><h2>三、HashCode有什么用</h2><p>比方说<code>Set</code>里面已经有1000个元素了，那么第1001个元素进来的时候，最多可能调用1000次<code>equals</code>方法，如果<code>equals</code>方法写得复杂，对比的东西特别多，那么效率会大大降低。</p><p>使用<code>HashCode</code>就不一样了，比方说<code>HashSet</code>，底层是基于<code>HashMap</code>实现的，先通过<code>HashCode</code>取一个模，这样一下子就固定到某个位置了，如果这个位置上没有元素，那么就可以肯定<code>HashSet</code>中必定没有和新添加的元素<code>equals</code>的元素，就可以直接存放了，都不需要比较；</p><p>如果这个位置上有元素了，逐一比较，比较的时候先比较<code>HashCode</code>，<code>HashCode</code>都不同接下去都不用比了，肯定不一样，<code>HashCode</code>相等，再<code>equals</code>比较，没有相同的元素就存，有相同的元素就不存。</p><p>如果原来的<code>Set</code>里面有相同的元素，只要<code>HashCode</code>的生成方式定义得好（不重复），不管<code>Set</code>里面原来有多少元素，只需要执行一次的<code>equals</code>就可以了。这样一来，实际调用<code>equals</code>方法的次数大大降低，提高了效率。</p><div class="tip">当俩个对象的`hashCode`值相同的时候，`Hashset`会将对象保存在同一个位置，但是他们`equals`返回`false`，所以实际上这个位置采用链式结构来保存多个对象。 </div><p><img src="http://bloghello.oursnail.cn/%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5%E6%95%A3%E5%88%97%E9%9B%86%E5%90%88%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p><h2>四、为什么重写Object的equals()方法尽量要重写Object的hashCode()方法</h2><p>面临问题：若两个对象<code>equals</code>相等，但由于不在一个区间，因为<code>hashCode</code>的值在重写之前是对内存地址计算得出，所以根本没有机会进行比较，会被认为是不同的对象(这就是为什么还要重写<code>hashcode</code>方法了)。所以<code>Java</code>对于<code>eqauls</code>方法和<code>hashCode</code>方法是这样规定的：</p><blockquote><p>1 如果两个对象相同(<code>equals</code>为<code>true</code>)，那么它们的<code>hashCode</code>值一定要相同。也告诉我们重写<code>equals</code>方法，一定要重写<code>hashCode</code>方法，也就是说<code>hashCode</code>值要和类中的成员变量挂上钩，对象相同–&gt;成员变量相同—-&gt;<code>hashCode</code>值一定相同。</p></blockquote><blockquote><p>2 如果两个对象的<code>hashCode</code>相同(只是映射到同一个位置而已)，它们并不一定相同，这里的对象相同指的是用<code>eqauls</code>方法比较。</p></blockquote><p>简单来说，如果只重写<code>equals</code>方法而不重写<code>hashcode</code>方法，会导致重复元素的产生。具体通过下面的例子进行说明。</p><h2>五、举例</h2><h5>6.1 Student类</h5><p>很简单，定义了<code>id</code>和<code>name</code>两个字段，无参和有参构造函数，<code>toString</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">get(),set()略...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>6.2 main方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"hh"</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"hh"</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">"gg"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashSet&lt;Student&gt; set = <span class="keyword">new</span> HashSet&lt;Student&gt;(); </span><br><span class="line">set.add(student1);</span><br><span class="line">set.add(student2);</span><br><span class="line">set.add(student3);</span><br><span class="line">set.add(student1);<span class="comment">//重复添加了student1</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"set集合容量为:  "</span>+set.size());</span><br><span class="line"></span><br><span class="line">Iterator&lt;Student&gt; iterator = set.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        Student student = iterator.next();  </span><br><span class="line">        System.out.println(student+<span class="string">"---"</span>+student.hashCode());  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  3</span><br><span class="line">Student [id=1, name=hh]---1735600054</span><br><span class="line">Student [id=1, name=hh]---356573597</span><br><span class="line">Student [id=2, name=gg]---21685669</span><br></pre></td></tr></table></figure><p>我们可以看到，只要是new的对象，他们的<code>hashcode</code>是不一样的。所以，就会认为他们是不一样的对象。所以，集合里面数量为3.</p><h5>6.3 只重写equals()方法，而不重写HashCode()方法</h5><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  <span class="number">3</span></span><br><span class="line">Student [id=<span class="number">2</span>, name=gg]---<span class="number">2018699554</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">366712642</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">1829164700</span></span><br></pre></td></tr></table></figure><p>结论：覆盖<code>equals</code>（<code>Object obj</code>）但不覆盖<code>hashCode()</code>,导致数据不唯一性。</p><p>在这里，其实我们可以看到，<code>student1</code>和<code>student2</code>其实是一个对象，但是由于都是new并且没有重写<code>hashcode</code>导致他们变成了两个不一样的对象。</p><p>分析：</p><blockquote><p>（1）当执行<code>set.add(student1)</code>时，集合为空，直接存入集合；</p></blockquote><blockquote><p>（2）当执行<code>set.add(student2)</code>时，首先判断该对象（<code>student2</code>）的<code>hashCode</code>值所在的存储区域是否有相同的<code>hashCode</code>，因为没有覆盖<code>hashCode</code>方法，所以jdk使用默认<code>Object</code>的<code>hashCode</code>方法，返回内存地址转换后的整数，因为不同对象的地址值不同，所以这里不存在与<code>student2</code>相同<code>hashCode</code>值的对象，因此<code>jdk</code>默认不同<code>hashCode</code>值，<code>equals</code>一定返回<code>false</code>，所以直接存入集合。</p></blockquote><blockquote><p>（3）当执行<code>set.add(student3)</code>时,与2同理。</p></blockquote><blockquote><p>（4）当最后执行<code>set.add(student1)</code>时，因为<code>student1</code>已经存入集合，同一对象返回的<code>hashCode</code>值是一样的，继续判断<code>equals</code>是否返回true，因为是同一对象所以返回<code>true</code>。此时jdk认为该对象已经存在于集合中，所以舍弃。</p></blockquote><h5>6.4 只重写HashCode()方法，equals()方法直接返回false</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  <span class="number">3</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">4320</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">4320</span></span><br><span class="line">Student [id=<span class="number">2</span>, name=gg]---<span class="number">4319</span></span><br></pre></td></tr></table></figure><p>按照上面的分析，可能会觉得里面应该装4个，因为两次add的student1，虽然他们的<code>hashcode</code>一样，但是<code>equals</code>直接返回<code>false</code>，那么应该判定为两个不同的对象。但是结果确跟我们预想的不一样。</p><p>分析：</p><blockquote><p>首先<code>student1</code>和<code>student2</code>的对象比较<code>hashCode</code>，因为重写了<code>HashCode</code>方法，所以<code>hashcode</code>相等,然后比较他们两的<code>equals</code>方法，因为<code>equals</code>方法始终返回<code>false</code>,所以<code>student1</code>和<code>student2</code>也是不相等的，所以<code>student2</code>也被放进了<code>set</code></p></blockquote><blockquote><p>首先<code>student1(student2)</code>和<code>student3</code>的对象比较<code>hashCode</code>，不相等，所以<code>student3</code>放进<code>set</code>中</p></blockquote><blockquote><p>最后再看最后重复添加的<code>student1</code>,与第一个<code>student1</code>的<code>hashCode</code>是相等的，在比较<code>equals</code>方法，因为<code>equals</code>返回<code>false</code>,所以<code>student1</code>和<code>student4</code>不相等;同样，<code>student2</code>和<code>student4</code>也是不相等的;<code>student3</code>和<code>student4</code>的<code>hashcode</code>都不相等，所以肯定不相等的，所以最后一个重复的<code>student1</code>应该可以放到<code>set</code>集合中，那么结果应该是<code>size:4</code>,那为什么会是3呢？</p></blockquote><p>这时候我们就需要查看<code>HashSet</code>的源码了，下面是<code>HashSet</code>中的<code>add</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到其实<code>HashSet</code>是基于<code>HashMap</code>实现的，我们在点击<code>HashMap</code>的<code>put</code>方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是判断<code>hashCode</code>是否相等，不相等的话，直接跳过，相等的话，<strong>然后再来比较这两个对象是否相等或者这两个对象的<code>equals</code>方法，因为是进行的或操作，所以只要有一个成立即可</strong>，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将<code>hashCode</code>方法设置成始终返回false的话，这个集合就是4了。</p><h5>6.5 同时重写</h5><p>我的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = result * <span class="number">31</span> + name.hashCode();</span><br><span class="line">    result = result * <span class="number">31</span> + id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Student o = (Student)obj;</span><br><span class="line">    <span class="keyword">return</span> o.name.equals(name) &amp;&amp; o.id == id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  2</span><br><span class="line">Student [id=2, name=gg]---118515</span><br><span class="line">Student [id=1, name=hh]---119506</span><br></pre></td></tr></table></figure><p>达到我们预期的效果。</p><h2>六、内存泄露</h2><p>我们上面实验了重写<code>equals</code>和<code>hashcode</code>方法，执行<code>main</code>，执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  <span class="number">2</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">4320</span></span><br><span class="line">Student [id=<span class="number">2</span>, name=gg]---<span class="number">4319</span></span><br></pre></td></tr></table></figure><p>将<code>main</code>方法改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"hh"</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"hh"</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">"gg"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashSet&lt;Student&gt; set = <span class="keyword">new</span> HashSet&lt;Student&gt;(); </span><br><span class="line">set.add(student1);</span><br><span class="line">set.add(student2);</span><br><span class="line">set.add(student3);</span><br><span class="line">set.add(student1);<span class="comment">//重复添加了student1</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"set集合容量为:  "</span>+set.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//------新增的开始-------</span></span><br><span class="line">student3.setId(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">set.remove(student3);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"set集合容量为:  "</span>+set.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//------新增的结束-------</span></span><br><span class="line"></span><br><span class="line">Iterator&lt;Student&gt; iterator = set.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        Student student = iterator.next();  </span><br><span class="line">        System.out.println(student+<span class="string">"---"</span>+student.hashCode());  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  <span class="number">2</span></span><br><span class="line">set集合容量为:  <span class="number">2</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">4320</span></span><br><span class="line">Student [id=<span class="number">11</span>, name=gg]---<span class="number">4598</span></span><br></pre></td></tr></table></figure><p>我们调用了<code>remove</code>删除<code>student3</code>对象，以为删除了<code>student3</code>,但事实上并没有删除，这就叫做内存泄露，就是不用的对象但是他还在内存中。所以我们多次这样操作之后，内存就爆了。</p><p>原因：</p><p><strong>在调用<code>remove</code>方法的时候，会先使用对象的<code>hashCode</code>值去找到这个对象，然后进行删除，这种问题就是因为我们在修改了对象<code>student3</code>的<code>id</code>属性的值，又因为<code>RectObject</code>对象的<code>hashCode</code>方法中有<code>id</code>值参与运算,所以<code>student3</code>对象的<code>hashCode</code>就发生改变了，所以<code>remove</code>方法中并没有找到student3了，所以删除失败</strong>。即<code>student3</code>的<code>hashCode</code>变了，但是他存储的位置没有更新，仍然在原来的位置上，所以当我们用他的新的<code>hashCode</code>去找肯定是找不到了。</p><p>总结：</p><p>上面的这个内存泄露告诉我一个信息：<strong>如果我们将对象的属性值参与了<code>hashCode</code>的运算中，在进行删除的时候，就不能对其属性值进行修改，否则会出现严重的问题</strong>。</p><h2>七、总结</h2><ul><li><code>hashCode</code>是为了提高在散列结构存储中查找的效率，在线性表中没有作用。</li><li><code>equals</code>和<code>hashCode</code>需要同时覆盖。</li><li>若两个对象<code>equals</code>返回true，则<code>hashCode</code>有必要也返回相同的int数。</li><li>若两个对象<code>equals</code>返回false，则<code>hashCode</code>不一定返回不同的int数,但为不相等的对象生成不同<code>hashCode</code>值可以提高哈希表的性能。</li><li>若两个对象<code>hashCode</code>返回相同int数，则<code>equals</code>不一定返回true。</li><li>同一对象在执行期间若已经存储在集合中，则不能修改影响<code>hashCode</code>值的相关信息，否则会导致内存泄露问题。</li></ul><p>整理自：</p><ul><li><a href="http://blog.csdn.net/haobaworenle/article/details/53819838" target="_blank" rel="noopener">http://blog.csdn.net/haobaworenle/article/details/53819838</a></li><li><a href="http://www.cnblogs.com/xrq730/p/4842028.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4842028.html</a></li><li><a href="http://blog.csdn.net/qq_21688757/article/details/53067814" target="_blank" rel="noopener">http://blog.csdn.net/qq_21688757/article/details/53067814</a></li><li><a href="http://blog.csdn.net/fyxxq/article/details/42066843" target="_blank" rel="noopener">http://blog.csdn.net/fyxxq/article/details/42066843</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CopyOnWriteArrayList</title>
      <link href="/2019/01/20/java-collection/3.CopyOnWriteArrayList/"/>
      <url>/2019/01/20/java-collection/3.CopyOnWriteArrayList/</url>
      <content type="html"><![CDATA[<p>CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p><a id="more"></a><p><code>CopyOnWriteArrayList</code>是一个写时复制的容器，采用了读写分离的思想。通俗点来讲，在对容器进行写操作时，不直接修改当前容器，而是先对当前容器进行拷贝得到一个副本，然后对副本进行写操作，最后再将原容器的引用指向拷贝出来的副本。这样做的好处就是可以对容器进行并发读而不用进行加锁。</p><h2>一、类的继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>含义不需要再赘述了。</p><h2>二、类的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 用于在对数组产生写操作的方法加锁. */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 底层的存储结构. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 反射机制. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** lock域的内存偏移量.是通过反射拿到的 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> lockOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = CopyOnWriteArrayList.class;</span><br><span class="line">        lockOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"lock"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、数组末尾添加一个元素</h2><p><img src="http://bloghello.oursnail.cn/CopyOnWriteArrayList%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 元素数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将要添加的元素放到副本数组的末尾去</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本原理很简单，就是对当前数组加锁，内部复制一个新数组，处理完毕，修改引用即可，达到最终一致的效果。</p><h2>四、如果没有这个元素则添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）。<strong>如何可以保证多线程环境下不会重复添加元素</strong>？</p><p>答案：<strong>通过快照数组和当前数组进行对比来确定是否一致，确保添加元素的线程安全</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123; <span class="comment">// 快照不等于当前数组，对数组进行了修改</span></span><br><span class="line">            <span class="comment">// 取较小者</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++) <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) <span class="comment">// 当前数组的元素与快照的元素不相等并且e与当前元素相等</span></span><br><span class="line">                    <span class="comment">// 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在</span></span><br><span class="line">                    <span class="comment">// 返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>) <span class="comment">// 在当前数组中找到e元素</span></span><br><span class="line">                    <span class="comment">// 返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对数组len索引的元素赋值为e</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的流程如下：</p><ol><li>获取锁，获取当前数组为<code>current</code>，<code>current</code>长度为<code>len</code>，判断数组之前的快照<code>snapshot</code>是否等于当前数组<code>current</code>，若不相等，则进入步骤2；否则，进入步骤3</li><li>不相等，表示在<code>snapshot</code>与<code>current</code>之间，对数组进行了修改，直接返回<code>false</code>结束;</li><li>说明当前数组等于快照数组，说明数组没有被改变。在当前数组中索引指定元素，若能够找到，说明已经存在此元素，直接返回<code>false</code>结束；否则进入4</li><li>说明没有当前要插入的元素，通过数组复制的方式添加到末尾</li><li>无论如何，都要释放锁</li></ol><h2>五、获取指定索引的元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过写时复制的方式，<code>CopyOnWriteArrayList</code> 的 <code>get</code> 方法不用加锁也可以保证线程安全，所以 <code>CopyOnWriteArrayList</code> 并发读的效率是非常高的，它是直接通过数组下标获取元素的。</p></blockquote><h2>六、总结</h2><h5>简单而言要记住它的三个特点：</h5><ul><li><code>CopyOnWriteArrayList</code> 是一个并发的数组容器，它的底层实现是数组。</li><li><code>CopyOnWriteArrayList</code> 采用写时复制的方式来保证线程安全。</li><li>通过写时复制的方式，可以高效的进行并发读，但是对于写操作，每次都要进行加锁以及拷贝副本，效率非常低，所以 <code>CopyOnWriteArrayList</code> 仅适合<strong>读多写少</strong>的场景。</li></ul><blockquote><p><code>Vector</code>虽然是线程安全的，但是只是一种相对的线程安全而不是绝对的线程安全，它只能够保证增、删、改、查的单个操作一定是原子的，不会被打断，但是如果组合起来用，并不能保证线程安全性。</p></blockquote><blockquote><p><code>CopyOnWriteArrayList</code>在并发下不会产生任何的线程安全问题，也就是<strong>绝对的线程安全</strong></p></blockquote><h5>另外，有两点必须讲一下。</h5><p>我认为<code>CopyOnWriteArrayList</code>这个并发组件，其实反映的是两个十分重要的分布式理念：</p><p>（1）读写分离</p><blockquote><p>我们读取<code>CopyOnWriteArrayList</code>的时候读取的是<code>CopyOnWriteArrayList</code>中的<code>Object[] array</code>，但是修改的时候，操作的是一个新的<code>Object[] array</code>，读和写操作的不是同一个对象，这就是读写分离。这种技术数据库用的非常多，在高并发下为了缓解数据库的压力，即使做了缓存也要对数据库做读写分离，读的时候使用读库，写的时候使用写库，然后读库、写库之间进行一定的同步，这样就避免同一个库上读、写的IO操作太多</p></blockquote><p>（2）最终一致</p><blockquote><p>对<code>CopyOnWriteArrayList</code>来说，线程1读取集合里面的数据，未必是最新的数据。因为线程2、线程3、线程4四个线程都修改了<code>CopyOnWriteArrayList</code>里面的数据，但是线程1拿到的还是最老的那个<code>Object[] array</code>，新添加进去的数据并没有，所以线程1读取的内容未必准确。不过这些数据虽然对于线程1是不一致的，但是对于之后的线程一定是一致的，它们拿到的<code>Object[] array</code>一定是三个线程都操作完毕之后的<code>Object array[]</code>，这就是最终一致。最终一致对于分布式系统也非常重要，它通过容忍一定时间的数据不一致，提升整个分布式系统的可用性与分区容错性。当然，最终一致并不是任何场景都适用的，像火车站售票这种系统用户对于数据的实时性要求非常非常高，就必须做成强一致性的。</p></blockquote><blockquote><p>最后总结一点，随着<code>CopyOnWriteArrayList</code>中元素的增加，<code>CopyOnWriteArrayList</code>的修改代价将越来越昂贵，因此，<code>CopyOnWriteArrayList</code>适用于读操作远多于修改操作的并发场景中。</p></blockquote><h2>感谢</h2><blockquote><p><a href="http://www.cnblogs.com/xrq730/p/5020760.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/5020760.html</a></p></blockquote><blockquote><p><a href="http://blog.csdn.net/u013124587/article/details/52863533" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52863533</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/leesf456/p/5547853.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/5547853.html</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedList</title>
      <link href="/2019/01/20/java-collection/2.LinkedList/"/>
      <url>/2019/01/20/java-collection/2.LinkedList/</url>
      <content type="html"><![CDATA[<p>提到ArrayList，就会比较与LinkedList的区别。本文来看看LinkedList的核心原理。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/collection2-1.jpg" alt="image"></p><p>如图所示 LinkedList 底层是基于双向链表实现的，也是实现了 List 接口，所以也拥有 List 的一些特点(JDK1.7/8 之后取消了循环，修改为双向链表)。</p><h2>一、LinkedList属性</h2><p><img src="http://bloghello.oursnail.cn/LinkedList%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%83%85%E5%86%B5.png" alt="LinkedList为空的情况图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的节点个数.</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Pointer to first node.</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">//Pointer to last node.</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h2>二、Node的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//后置指针</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//前置指针</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、添加元素</h2><h3>3.1 LinkedList表头添加一个元素</h3><p><img src="http://bloghello.oursnail.cn/LinkedList%E8%A1%A8%E5%A4%B4%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" alt="LinkedList表头添加元素图"></p><blockquote><p>当向表头插入一个节点时，很显然当前节点的前驱一定为 null，而后继结点是 first 指针指向的节点，当然还要修改 first 指针指向新的头节点。除此之外，原来的头节点变成了第二个节点，所以还要修改原来头节点的前驱指针，使它指向表头节点，源码的实现如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//新节点前置指针指向空，后置指针指向first节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//新节点作为新的first节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;<span class="comment">//初始就是个空LinkedList的话，last指向当前新节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;<span class="comment">//初始值不为空，将其前置指针指向新节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>3.2 LinkedList表尾添加一个元素</h3><p><img src="http://bloghello.oursnail.cn/LinkedList%E8%A1%A8%E5%B0%BE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" alt="表尾添加元素图"></p><blockquote><p>当向表尾插入一个节点时，很显然当前节点的后继一定为 null，而前驱结点是 last 指针指向的节点，然后还要修改 last 指针指向新的尾节点。此外，还要修改原来尾节点的后继指针，使它指向新的尾节点，源码的实现如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//新节点前置指针指向空，后置指针指向first节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//新节点作为新的last节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果原来有尾节点，则更新原来节点的后继指针，否则更新头指针</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>3.3 LinkedList在指定节点前添加一个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断数组是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);<span class="comment">//直接插在最后一个</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));<span class="comment">//在index节点之前插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">//找到索引位置的前面一个元素pred</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//新节点，前置指针指向pred,后置指针指向索引处元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//修改索引出元素的前置指针为新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;<span class="comment">//说明是插在表头</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;<span class="comment">//说明是插在非表头位置，修改pred后置指针为新指针</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见每次插入都是移动指针，和 <code>ArrayList</code> 的拷贝数组来说效率要高上不少。</p><h2>四、删除元素</h2><p><img src="http://bloghello.oursnail.cn/LinkList%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0.png" alt="删除元素图"></p><p>删除操作与添加操作大同小异，例如删除指定节点的过程如下图所示，需要把当前节点的前驱节点的后继修改为当前节点的后继，以及当前节点的后继结点的前驱修改为当前节点的前驱。</p><p>就不赘述了。</p><h2>五、获取元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取指定索引对应的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找元素的方向是根据index在表中的位置决定的</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//索引小于表长的一半，从表头开始往后找</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//索引大于表长的一半，从表尾往前开始找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，利用了双向链表的特性，如果<code>index</code>离链表头比较近，就从节点头部遍历。否则就从节点尾部开始遍历。使用空间（双向链表）来换取时间。</p><ul><li><code>node()</code>会以<code>O(n/2)</code>的性能去获取一个结点<ul><li>如果索引值大于链表大小的一半，那么将从尾结点开始遍历</li></ul></li></ul><p>这样的效率是非常低的，特别是当 <code>index</code> 越接近 <code>size</code> 的中间值时。</p><h2>总结</h2><blockquote><p>1、理论上无容量限制，只受虚拟机自身限制影响，所以没有扩容方法。</p></blockquote><blockquote><p>2、和<code>ArrayList</code>一样，<code>LinkedList</code>也是是未同步的，多线程并发读写时需要外部同步，如果不外部同步，那么可以使用<code>Collections.synchronizedList</code>方法对<code>LinkedList</code>的实例进行一次封装。</p></blockquote><blockquote><p>3、和<code>ArrayList</code>一样，<code>LinkedList</code>也对存储的元素无限制，允许<code>null</code>元素。</p></blockquote><blockquote><p>4、<strong>顺序插入</strong>速度<code>ArrayList</code>会比较快，因为<code>ArrayList</code>是基于数组实现的，数组是事先new好的，只要往指定位置塞一个数据就好了；<code>LinkedList</code>则不同，每次顺序插入的时候<code>LinkedList</code>将new一个对象出来，如果对象比较大，那么new的时间势必会长一点，再加上一些引用赋值的操作，所以顺序插入<code>LinkedList</code>必然慢于<code>ArrayList</code></p></blockquote><blockquote><p>5、基于上一点，因为<code>LinkedList</code>里面不仅维护了待插入的元素，还维护了<code>Entry</code>的前置<code>Entry</code>和后继<code>Entry</code>，如果一个<code>LinkedList</code>中的<code>Entry</code>非常多，那么<code>LinkedList</code>将比<code>ArrayList</code>更耗费一些内存</p></blockquote><blockquote><p>6、数据遍历的速度，看最后一部分，这里就不细讲了，结论是：使用各自遍历效率最高的方式，<code>ArrayList</code>的遍历效率会比<code>LinkedList</code>的遍历效率高一些</p></blockquote><blockquote><p>7、有些说法认为<code>LinkedList</code>做插入和删除更快，这种说法其实是不准确的：</p></blockquote><ul><li><code>LinkedList</code>做插入、删除的时候，慢在寻址，快在只需要改变前后<code>Entry</code>的引用地址</li><li><code>ArrayList</code>做插入、删除的时候，慢在数组元素的批量<code>copy</code>，快在寻址</li></ul><blockquote><p>所以，如果待插入、删除的元素是在数据结构的前半段尤其是非常靠前的位置的时候，<code>LinkedList</code>的效率将大大快过<code>ArrayList</code>，因为<code>ArrayList</code>将批量<code>copy</code>大量的元素；越往后，对于<code>LinkedList</code>来说，因为它是双向链表，所以在第2个元素后面插入一个数据和在倒数第2个元素后面插入一个元素在效率上基本没有差别，但是<code>ArrayList</code>由于要批量<code>copy</code>的元素越来越少，操作速度必然追上乃至超过<code>LinkedList</code>。</p></blockquote><blockquote><p>从这个分析看出，如果你十分确定你插入、删除的元素是在前半段，那么就使用<code>LinkedList</code>；如果你十分确定你删除、删除的元素在比较靠后的位置，那么可以考虑使用<code>ArrayList</code>。如果你不能确定你要做的插入、删除是在哪儿呢？那还是建议你使用<code>LinkedList</code>吧，因为一来<code>LinkedList</code>整体插入、删除的执行效率比较稳定，没有<code>ArrayList</code>这种越往后越快的情况；二来插入元素的时候，弄得不好<code>ArrayList</code>就要进行一次扩容，记住，<code>ArrayList</code>底层数组扩容是一个既消耗时间又消耗空间的操作.</p></blockquote><blockquote><p>8、<code>ArrayList</code>使用最普通的<code>for</code>循环遍历，<code>LinkedList</code>使用<code>foreach</code>循环比较快.注意到<code>ArrayList</code>是实现了<code>RandomAccess</code>接口而<code>LinkedList</code>则没有实现这个接口.关于<code>RandomAccess</code>这个接口的作用，看一下JDK API上的说法：</p></blockquote><p><img src="http://bloghello.oursnail.cn/RandomAccess%E6%8E%A5%E5%8F%A3%E4%BD%9C%E7%94%A8.png" alt="image"></p><blockquote><p>9、如果使用普通<code>for</code>循环遍历<code>LinkedList</code>，在大数据量的情况下，其遍历速度将慢得令人发指</p></blockquote><p>整理自：</p><ul><li>1、<a href="http://www.cnblogs.com/xrq730/p/5005347.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/5005347.html</a></li><li>2、<a href="http://blog.csdn.net/u013124587/article/details/52837848" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52837848</a></li><li>3、<a href="http://blog.csdn.net/u011392897/article/details/57115818" target="_blank" rel="noopener">http://blog.csdn.net/u011392897/article/details/57115818</a></li><li>4、<a href="http://blog.csdn.net/fighterandknight/article/details/61476335" target="_blank" rel="noopener">http://blog.csdn.net/fighterandknight/article/details/61476335</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayList/Vector</title>
      <link href="/2019/01/20/java-collection/1.ArrayList%E5%92%8CVector/"/>
      <url>/2019/01/20/java-collection/1.ArrayList%E5%92%8CVector/</url>
      <content type="html"><![CDATA[<p>面试中，关于java的一些容器，ArrayList是最简单也是最常问的，尤其是里面的扩容机制。</p><a id="more"></a><h2>ArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 实现于 <code>List</code>、<code>RandomAccess</code> 接口。可以插入空数据，也支持随机访问。</p><p>构造函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用初始容量作为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//初始容量大于0，实例化数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//初始容量等于0，赋予空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中我们可以看见，默认情况下，<code>elementData</code>是一个大小为0的空数组，当我们指定了初始大小的时候，<code>elementData</code>的初始大小就变成了我们所指定的初始大小了。</p><p><code>ArrayList</code>相当于动态数据，其中最重要的两个属性分别是: <code>elementData</code> 数组，以及 <code>size</code> 大小。 在调用 <code>add()</code> 方法的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先进行扩容校验。</li><li>将插入的值放到尾部，并将 size + 1 。</li></ul><p>如果是调用 <code>add(index,e)</code> 在指定位置添加的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//复制，向后移动</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也是首先扩容校验。</li><li>接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</li></ul><p>其实扩容最终调用的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是一个数组复制的过程，<code>ArrayList</code>每次扩容都是扩1.5倍，然后调用<code>Arrays</code>类的<code>copyOf</code>方法，把元素重新拷贝到一个新的数组中去。</p><p>由此可见 <code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。</p><h2>序列化</h2><p>由于 <code>ArrayList</code> 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 <code>transient</code> 修饰，可以防止被自动序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><p>因此 <code>ArrayList</code> 自定义了序列化与反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="comment">//只序列化了被使用的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当对象中自定义了 writeObject 和 readObject 方法时，JVM 会调用这两个自定义方法来实现序列化与反序列化。</p></blockquote><p>从实现中可以看出 <code>ArrayList</code> 只序列化了被使用的数据。</p><h2>Vector</h2><p><code>Vector</code> 也是实现于 <code>List</code> 接口，底层数据结构和 <code>ArrayList</code> 类似,也是一个动态数组存放数据。不过是在 <code>add()</code> 方法的时候使用 <code>synchronized</code> 进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p><p><code>Vector</code>比<code>ArrayList</code>多了一个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure><p>这个属性是在扩容的时候用到的，它表示每次扩容只扩<code>capacityIncrement</code>个空间就足够了。该属性可以通过构造方法给它赋值。先来看一下构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中，我们可以看出<code>Vector</code>的默认大小也是10，而且它在初始化的时候就已经创建了数组了，这点跟<code>ArrayList</code>不一样。再来看一下<code>grow</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ? capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>grow</code>方法中我们可以发现，<code>newCapacity</code>默认情况下是两倍的<code>oldCapacity</code>，而当指定了<code>capacityIncrement</code>的值之后，<code>newCapacity</code>变成了<code>oldCapacity+capacityIncrement</code>。</p><p>以下是 <code>add()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及指定位置插入数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年的最后一天，对商城项目的架构做个改造</title>
      <link href="/2019/01/20/2018%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%EF%BC%8C%E5%AF%B9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%B6%E6%9E%84%E5%81%9A%E4%B8%AA%E6%94%B9%E9%80%A0/"/>
      <url>/2019/01/20/2018%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%EF%BC%8C%E5%AF%B9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%B6%E6%9E%84%E5%81%9A%E4%B8%AA%E6%94%B9%E9%80%A0/</url>
      <content type="html"><![CDATA[<p>一直以来都是学习慕课的实战视频，虽然也跟着做出了一些东西，但是思路都是别人提供好的，脱离了老师，我一直在问自己一个问题：能不能独立地按照自己的思路做出一些东西来？</p><a id="more"></a><p>前方图片高能…更有几十兆gif演示动画，图片全部存放于七牛云上。</p><p><img src="http://bloghello.oursnail.cn/wallpaper.jpg" alt="image"></p><p>在去年，即2017年年底，我在慕课上学习了这两门课程：</p><p><img src="http://bloghello.oursnail.cn/scfs1-1.png" alt="https://coding.imooc.com/class/96.html"></p><p><img src="http://bloghello.oursnail.cn/scfs1-2.png" alt="https://coding.imooc.com/class/96.html"></p><p>第一期项目实现了比较简单的电商业务，整合SSM，并且部署到云端。</p><p>第二期实现了tomcat集群，配合redis实现分布式session，还有一些定时任务、redis分布式锁、maven环境隔离的一些东西，还涉及很多spring和springmvc的有用的机巧。</p><p>整体感觉是：一期实现业务，二期对于一期的提高不是太大，跟分布式无太大关系，仅仅实现了单点登陆和分布式session存储而已。</p><p>个人感觉下一期的课程应该是springCloud的分布式改造，进行服务拆分和治理。所以，在整合这两个课程的基础上用springCloud进行微服务治理。</p><h2>项目详细描述</h2><p>项目源码地址：<a href="https://github.com/sunweiguo/MMall" target="_blank" rel="noopener">https://github.com/sunweiguo/MMall</a></p><p>整体效果演示：</p><p><img src="http://bloghello.oursnail.cn/jdfw.gif" alt="image"></p><p>下面贴个小一点的gif:</p><p><img src="http://bloghello.oursnail.cn/jdfw-small.gif" alt="image"></p><p>部分页面截图：</p><p><img src="http://bloghello.oursnail.cn/mall-index.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-list.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-detail.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-cart.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-comfirm.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-pay.png" alt="image"></p><blockquote><p>经过一遍遍测试，商城还是存在一些无伤大雅的bug，但是主要还是锻炼自己的能力嘛！</p><p>下订单的时候，报错：商品不存在或库存不足，是因为我模拟的秒杀，所以商品的库存要提前预置于redis中，后端管理系统的商品管理页面有预置库存的按钮。</p><p>新增商品的时候，对于上传图片，需要耐心等待一会，需要等待FTP服务器上传完毕，给一个返回信息(Map，是图片的文件名)才能真正显示（对于富文本中的图片上传，在上传之后需要等待一会，时间与小图上传差不多，否则直接保存不报错，但是前端看不到图，因为还没上传完毕,url还没回传回来）</p><p>普通注册的账号，没有管理员权限，所以不能登陆后台管理系统。</p><p>后来做了eureka集群，但是配置文件还是只指向其中一个eureka</p></blockquote><p>在学习的视频中，一期只是实现业务功能，单体架构，一个tomcat。二期对其做了集群，并且解决了集群模式下session存储问题，实现了比较简单的单点登陆功能。架构如下：</p><p><img src="http://bloghello.oursnail.cn/snailmall-1.png" alt="image"></p><p>对于上面的架构来说，只是做了一些集群进行优化，随着业务的发展，用户越来越多，用户服务等其他服务必然要拆分出来独立成为一个服务，这样做的好处是，一方面一个团队负责一个服务可以提高开发效率，另外，对于扩展性也是非常有利的，但是也是有缺点的，会带来很多的复杂性，尤其是引入了分布式事务，所以不能为了分布式而分布式，而是针对不同的业务场景而采用合适的架构。</p><p>微服务的实现，主要有两种，国内是阿里系的以dubbo+zookeeper为核心的一套服务治理和发现生态。另一个则是大名鼎鼎的spring cloud栈。</p><p>spring cloud并不是像spring是一个框架，他是解决微服务的一种方案，是由各种优秀开源组件共同配合而实现的微服务治理架构。下面的图是我构思的项目结构图：</p><p><img src="http://bloghello.oursnail.cn/%E5%95%86%E5%9F%8E%E6%9E%B6%E6%9E%84-2.png" alt="image"></p><p>最前面是<code>Nginx</code>，这里就作为一个静态资源映射和负载均衡，<code>nginx</code>中有几个配置文件，分别为<code>www.oursnail.cn.conf</code>，这个主要是对<code>zuul</code>网关地址做一个负载均衡，指向网关所在的服务器，并且找到前台页面所在位置对页面进行渲染。<code>admin.oursnail.cn.conf</code>，这个主要是配置后端以及后端的页面文件；<code>img.oursnail.cn.conf</code>是对图片服务器地址进行映射。</p><p>然后是<code>zuul</code>网关，这里主要是用来限流、鉴权以及路由转发。</p><p>再后面就是我们的应用服务器啦。对服务器进行了服务追踪(<code>sleuth</code>)，实现了动态刷新配置(<code>spring cloud config</code>+<code>bus</code>)等功能。以<code>http restful</code>的方式进行通信(<code>openFeign</code>),构建起以<code>eureka</code>为注册中心的分布式架构。</p><p>每个服务都是基于<code>springboot</code>打造，结合<code>mybatis</code>持久层操作的框架，完成基本的业务需求。<code>springboot</code>基于<code>spring</code>，特点是快速启动、内置<code>tomcat</code>以及无<code>xml</code>配置。将很多东西封装起来，引入pom就可以直接使用，比如<code>springMVC</code>就基本上引入<code>starter-web</code>即可。</p><p>由于资源的原因，只有三台最低配的服务器，所以本来想做的基于ES的全文检索服务没有做，也没有分库分表。</p><p>至于定时任务以及Hystrix服务熔断和降级，比较简单，就不做了。</p><ul><li>项目的接口文档详见wiki：<a href="https://github.com/sunweiguo/spring-cloud-for-snailmall/wiki" target="_blank" rel="noopener">https://github.com/sunweiguo/spring-cloud-for-snailmall/wiki</a></li><li>项目的数据库表设计：snailmall.sql</li></ul><p>下面详细介绍每个模块实现的大体思路（仅供参考，毕竟应届生，真实项目没做过）：</p><ul><li>用户模块</li></ul><p>关于用户模块，核心的功能是登陆。再核心是如何验证以及如何存储用户信息。这里采取的方案为：</p><p><img src="http://bloghello.oursnail.cn/user.png" alt="image"></p><p>对于用户注册，我这里就是用户名（昵称），那么如何保证不重复呢（高并发）？这里还是用了分布式锁来保证的。</p><p>对于未登陆章台下用户修改密码，逻辑为：</p><p><img src="http://bloghello.oursnail.cn/user-2.png" alt="image"></p><ul><li>购物车模块</li></ul><p><img src="http://bloghello.oursnail.cn/cart.png" alt="image"></p><ul><li>订单模块</li></ul><p><img src="http://bloghello.oursnail.cn/order.png" alt="image"></p><p>针对这些问题，我想说一下我的思路。</p><p>对于幂等性，这里产生幂等性的主要原因在于MQ的重传机制，可能第一个消息久久没有发出去，然后重新发送一条，结果第一条消息突然又好了，那么就会重复发两跳，对于用户来说，只下一次单，但是服务器下了多次订单。网上解决这个问题的思路是创建一张表，如果是重复的订单号，就不可能创建多次了。还有一种可能方案是用分布式锁对该订单号锁住一段时间，由于只是锁住订单号，所以不影响性能，在这一段时间内是不可以再放同一个订单号的请求进来。</p><p>对于MQ消息不丢失，只能是订阅模式了。消息发出去之后，消费端给MQ回复一个接收到的信息，MQ本次消费成功，给订阅者一个回复。</p><p>对于全局唯一ID生成，这里用的是雪花算法，具体介绍可以看<a href="https://github.com/sunweiguo/swgBook/blob/master/mamabuy/05-%E4%BA%A4%E6%98%93%E5%B7%A5%E7%A8%8B(%E4%B8%8A).md" target="_blank" rel="noopener">我的笔记</a></p><p>对于分布式事务，比较复杂，这里其实并没有真正处理，对于数据库扣减库存和数据库插入订单，他们在不同的数据库，廖师兄比较倾向的方式是：</p><p><img src="http://bloghello.oursnail.cn/order-2.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/order-3.png" alt="image"></p><p>这一切的基础还是需要有一个可靠的消息服务，确保消息要能送达。</p><p>针对redis预减库存存在的并发问题，这里的思路是用lua+redis，在预减之前判断库存是否够，这两个操作要在一个原子操作里面才行，lua恰好可以实现原子性、顺序性地操作。</p><ul><li>支付模块</li></ul><p>这里对接的是支付宝-扫码支付，用到是支付宝沙箱环境。支付的扫码支付详细流程在这里聊一聊哈。</p><p>商户前台将商品参数发送至商户后台，商户后台生成<strong>内部订单号</strong>并用于请求支付平台创建<strong>预下单</strong>，支付平台创建完预订单后将订单二维码信息返还给商户，此时用户即可扫取二维码进行付款操作。</p><p>内部订单号：这是相对于支付宝平台而言的，这个订单号是我们商城自己生成的，对于我们商城来说是内部订单号，但是对于支付宝来说是外部订单号。</p><p>将一系列的数据按照支付宝的要求发送给支付宝平台，包括商品信息，生成的验签sign，公钥；支付宝去将sign解密，进行商品的各种信息校验。校验通过，<strong>同步</strong>返回二维码串。</p><p>支付业务流程图：</p><p><img src="http://bloghello.oursnail.cn/pay-1.png" alt="image"></p><p>在获取支付的二维码串之后，用工具包将其转换未二维码展示给用户扫码。</p><p>用户扫码后，会收到第一次支付宝的回调，展示要支付的金额，商品信息等。</p><p>用户输入密码成功后，正常情况会收到支付宝的第二次回调，即支付成功信息。</p><p>但是也可能会由于网络等原因，迟迟收不到支付宝的回调，这个时候就需要主动发起轮询去查看支付状态。</p><p>在支付成功之后，接收回调的接口要记得返回<code>success</code>告诉支付宝我已经收到你的回调了，不要再重复发给我了。接收回调的接口也要做好去除重复消息的逻辑。</p><p><img src="http://bloghello.oursnail.cn/pay-2.png" alt="image"></p><p>这个流程是多么地简单而理所当然！</p><p>对应于代码层面，其实就是两个接口，一个是用户点击去支付按钮，此时发起预下单，展示付款二维码，另一个是接收支付宝回调：</p><p>预下单：</p><p><img src="http://bloghello.oursnail.cn/pay-3.png" alt="image"><br><img src="http://bloghello.oursnail.cn/pay-4.png" alt="image"><br><img src="http://bloghello.oursnail.cn/pay-5.png" alt="image"></p><p>接收支付宝支付状态回调：</p><p><img src="http://bloghello.oursnail.cn/pay-6.png" alt="image"></p><h2>项目进展</h2><ul><li>[x] 2018/12/31 完成了聚合工程的创建、Eureka服务注册中心、spring cloud config+gitHub+spring cloud bus（rabbitMQ）实现配置自动刷新–v1.0</li><li>[x] 2018/12/31 将Eureka注册中心(单机)和配置中心部署到服务器上，这比较固定，所以先部署上去，以后本地就直接用这两个即可，对配置进行了一点点修改</li><li>[ ] 2018/12/31 关于配置的自动刷新，用postman发送post请求是可以的，但是用github webhook不行，不知道是不是这个版本的问题</li><li>[x] 2018/12/31 用户模块的逻辑实现,首先增加了一些pom文件的支持，整合mybatis，测试数据库都通过，下面就可以真正去实现业务代码了</li><li>[x] 2019/1/1 完成用户注册、登陆、校验用户名邮箱有效性、查看登陆用户信息、根据用户名去拿到对应的问题、校验答案是否正确、重置密码这个几个接口，在注册这个接口，增加一个ZK分布式锁来防止在高并发场景下出现用户名或邮箱重复问题</li><li>[x] 2019/1/2 上午完成门户用户模块所有接口–v2.0</li><li>[x] 2019/1/2 下午完成品类管理模块，关于繁琐的获取用户并且鉴权工作，这里先放每个接口里面处理，后面放到网关中去实现–v3.0</li><li>[x] 2019/1/3 上午引入网关服务，将后台重复的权限校验统一放到网关中去做，并且加了限流，解决了一下跨域问题。–v4.0</li><li>[x] 2019/1/3 下午和晚上完成门户和后台的商品管理模块所有的接口功能，除了上传文件的两个接口没有测试以外，其他接口都进行了简单的测试，其中还用Feign去调用了品类服务接口–v5.0</li><li>[x] 2019/1/3 初步把购物车模块和模块引入，通过基础测试，后面在此基础上直接开发代码即可，明天下午看《大黄蜂》，晚上师门聚餐吃火锅，明天早上赶一赶吧，今天任务结束！</li><li>[x] 2019/1/4 整理了接口文档，并且画了一下购物车模块的流程图以及订单服务的流程图，针对订单服务中，记录了需要一些注意的问题，尽可能地完善，提高可用性和性能。并且完成购物车模块的controller层。</li><li>[x] 2019/1/5 完成购物车模块，并且进行了简单的测试，这里进行了两处改造，一个是判断了一下是否需要判断库存；另一个是商品信息从redis中取，取不出来则调用商品服务初始化值</li><li>[x] 2019/1/5 收货地址管理模块，这个模块就是个增删改查，没啥东西写，这里就不加缓存了。</li><li>[x] 2019/1/6 完成了后台订单管理模块并且进行了测试，调用收货地址服务时，发现收货地址服务无法读取到cookie，通过这个方法(<a href="https://blog.csdn.net/WYA1993/article/details/84304243" target="_blank" rel="noopener">https://blog.csdn.net/WYA1993/article/details/84304243</a>) 暂时解决了问题</li><li>[x] 2019/1/6 预置所有商品库存到redis中；预置所有商品到redis中；大概确定好订单服务思路：预减库存（redis判断库存）—对userID增加分布式锁防止用户重复提交订单–MQ异步下订单</li><li>[x] 2019/1/6 新增全局唯一ID生成服务，雪花算法实现</li><li>[x] 2019/1/7 完善订单服务-这一块涉及跨库操作，并且不停地调用其他服务，脑子都快晕了，这里采取的策略是：用到购物车的时候，去调用购物车服务获取；产品详情从redis中获取。首先将商品以及商品库存全部缓存到redis中，然后用户下单，先从redis中判断库存，够则减，判断<br>和扣减放在lua脚本中原子执行，然后MQ异步出去生成订单（生成订单主表和订单详情表放在一个本地事务中），这两步操作成功之后，再用MQ去异步删除购物车。MQ消费不成功则重试。<br>对于扣减库存这一步，想法是用定时任务，定时与redis中进行同步。这里是模拟了秒杀场景，预减库存+MQ异步，提交订单–&gt;redis判断并且减库存–&gt;调用cart-service获取购物车–&gt;MQ异步(userId,shippingId)生成订单主表和详情表–&gt;上面都成功，则MQ异步(userId)<br>去清除购物车，库存用定时任务去同步(未做)，理想的做法是：MQ异步扣减库存，订单服务订阅扣减库存消息，一旦库存扣减成功，则进行订单生成。</li><li>[x] 2019/1/8 继续完善订单接口，完成支付服务，就直接放在订单服务里面了，因为与订单逻辑紧密，就放在一起了。</li><li>[x] 2019/1/8 使用了一下swagger，发现代码侵入比较强，每一个接口上面都要手动打上响应的注解</li><li>[x] 2019/1/8 关于hystrix熔断与降级，可以引入hystrix的依赖，用@HystrixCommand注解来控制超时时间、服务降级以及服务熔断。也可以直接再@FeignClient接口中指定服务降级的类，这里不演示了，因为设置比如超时时间，我还要重新测试，写起来很简单，测起来有点儿麻烦</li><li>[x] 2019/1/9 服务跟踪，服务端是直接用的线程的，只需要下载：wget -O zipkin.jar  ‘<a href="https://search.maven.org/remote_content?g=io.zipkin.java&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec" target="_blank" rel="noopener">https://search.maven.org/remote_content?g=io.zipkin.java&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec</a>’，然后nohup java -jar zipkin.jar &gt; zipkin.server.out &amp; ，开放9411端口，打开浏览器http://ip:9411看到页面即可。<br>客户端只需要添加相应依赖和配置文件即可。用客户端测试，发现死活不出现我的请求，经过搜索，发现需要增加spring.zipkin.sender.type= web这个配置项才行.</li><li>[x] 2019/1/10 初步把项目部署到服务器上，进行测试，bug多多，修改中…</li><li>[x] 2019/1/10 改了一天的bug，其中网关的超时时间以及feign的超时时间都要改大一点，否则会超时报错。最终成功，花了三台服务器，部署了11个服务。后面把部署过程写一下。</li><li>[x] 2019/1/11 将注册中心做成集群，因为早上一起来，注册中心挂了？？？</li><li>[ ] 2019/1/11 docker部署(商城第四期的改造目标:容器化+容器编排)，本期改造结束。</li><li>[x] 2019/1/11 完善readme文档</li><li>[x] 2019/1/12 两次发现redis数据被莫名其妙清空，我确定不是缓存到期，为了安全起见，设置了redis的密码，明天看缓存数据还在不在。</li><li>[x] 2019/1/14 redis数据没有再丢失，修复用户更新信息的bug</li></ul><h2>项目启动</h2><p>安装redis、zookeeper、mysql、jdk、nginx以及rabbitMQ。</p><p>对代码进行maven-package操作。打包成jar包。将其放到服务器上：</p><p><img src="http://bloghello.oursnail.cn/start.png" alt="image"></p><p>执行<code>nohup java -jar snailmall-user-service.8081 &gt; user-service.out &amp;</code>后台启动即可。</p><blockquote><p>补充：针对配置刷新，修改了github信息，用<code>postman</code>请求<code>http://xxxxx:8079/actuator/bus-refresh</code> 触发更新。</p><p>本改造是基于<a href="https://coding.imooc.com/class/96.html" target="_blank" rel="noopener">快乐慕商城一期</a>和<a href="https://coding.imooc.com/class/162.html" target="_blank" rel="noopener">快乐慕商城二期</a>的基础上进行改造。所以需要在其业务基础上改造会比较顺手。关于微服务，尤其是电商中的一些处理手段，很多思路都是学习于<a href="http://coder520.com/" target="_blank" rel="noopener">码吗在线</a>中分布式电商项目。再加上慕课网廖师兄的<a href="https://coding.imooc.com/class/187.html" target="_blank" rel="noopener">spring cloud微服务实践</a>。</p></blockquote><h2>前台项目</h2><p>只要阅读<code>readme</code>文档即可。代码仓库为：<a href="https://github.com/sunweiguo/snailmall-front" target="_blank" rel="noopener">https://github.com/sunweiguo/snailmall-front</a></p><p>学习不仅要有输入，更要有自己的输出，实践是提升的捷径！</p>]]></content>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试-进程与线程</title>
      <link href="/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>都是操作系统管理的对象，比较容易混淆，但是又是两样完全不同的东西，因此区别很多。从他们区别也可以发散出很多关于操作系统比较重要的知识。所以面试比较常问。</p><a id="more"></a><h2>1. 进程到底是什么？</h2><p>翻了一下书：《操作系统概念》第三章中提及了进程的概念。他是这样说的：</p><blockquote><p>进程是执行中的程序，这是一种非正式说法。进程不只是程序代码（代码块），进程还包含了当前活动，通过程序计数器的值和处理器寄存器的内容来表示。此外，进程还包含进程堆栈段（包括临时数据，如函数参数、返回地址和局部变量）和数据段（包括全局变量）。进程还可能包含堆，是在进程运行期间动态分配的内存。</p><p>程序本身不是进程。程序只是被动实体，如存储在磁盘上包含一系列指令的文件内容。而进程是活动实体，它有一个程序计数器来表示下一个要执行的命令和相关资源集合。当一个可执行文件被装入内存时，一个程序才能成为进程。</p></blockquote><p>总结一下进程是什么，是我个人理解：<strong>它是一个活动实体，运行在内存上。然后它占用很多独立的资源，比如：内存资源、程序运行肯定涉及CPU计算、占用的端口资源（公共的）、文件资源（公共的）、网络资源（公共的）等等等。要想执行这个进程，首先要有一个可执行文件，有了这个可执行文件，还要有相应的执行需要的资源。所以将可执行文件、当前进程的上下文、内存等资源结合起来，才是一个真正的进程。</strong></p><p><strong>那么，我们就可以理解一句话：进程是资源分配的基本单位。</strong></p><p>进程中的内存空间（虽然空间大小都一样，下文会说明）是独立的，否则就会出现一种情况：修改自己程序中的某个指针就可以指向其他程序中的地址，然后拿到里面的数据，岂不是很恐怖的场景？</p><p><img src="http://bloghello.oursnail.cn/operator1-1.png" alt="image"></p><p>如上图，进程中包含了线程。操作系统可能会运行几百个进程，进程中也可能有几个到几百个线程在运行。</p><p>文件和网络句柄是所有进程共享的，多个进程可以去打开同一个文件，去抢占同一个网络端口。</p><p>图中还有个内存。这个内存不是我们经常说的内存条，即物理内存，而是虚拟内存，是进程独立的，大小与实际物理内存无关。</p><h2>2. 寻址空间</h2><p>比如8086只有20根地址线，那么它的寻址空间就是1MB，我们就说8086能支持1MB的物理内存，及时我们安装了128M的内存条在板子上，我们也只能说8086拥有1MB的物理内存空间。</p><p>以前叫卖的32位的机子，32位是指寻址空间为2的32次方。32位的386以上CPU就可以支持最大4GB的物理内存空间了。</p><h2>3. 为什么会有虚拟内存和物理内存的区别</h2><p>正在运行的一个进程，他所需的内存是有可能大于内存条容量之和的，比如你的内存条是256M，你的程序却要创建一个2G的数据区，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，在通过调度进入物理内存。</p><p>所以，<strong>虚拟内存是进程运行时所有内存空间的总和</strong>，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。</p><p>关键的是不要把虚拟内存跟真实的插在主板上的内存条相挂钩，虚拟内存它是“虚拟的”不存在，假的啦，它只是内存管理的一种抽象！</p><h2>4. 虚拟内存地址和物理内存地址是如何映射呢</h2><p>假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0 ~ 0xFFFFFFFF（4G）的地址空间，但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？回答这个问题前，先说明计算机的<strong>内存分页机制</strong>。</p><p><img src="http://bloghello.oursnail.cn/operator1-4.png" alt="image"></p><p><strong>计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（page frame），这个页和页帧的大小是一样大的，所以呢，在这里，虚拟内存页的个数势必要大于物理内存页帧的个数。</strong></p><p>在计算机上有一个<strong>页表</strong>（page table），就是<strong>映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射</strong>，而且是一对一的映射。但是问题来了，虚拟内存页的个数 &gt; 物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？</p><p>不是的，操作系统是这样处理的。操作系统有个<strong>页面失效</strong>（page fault）功能。<strong>操作系统找到一个最少使用的页帧，让他失效，并把它写入磁盘，随后从磁盘中把把需要访问的数据所在的页放到最少使用的页帧中，并修改页表中的映射（即修改页号指向当前页帧），这样就保证所有的页都有被调度的可能了。这就是处理虚拟内存地址到物理内存的步骤。</strong></p><p>至于里面如何实现的细节，我没有过多去探究。</p><h2>5. 什么是虚拟内存地址和物理内存地址</h2><p>虚拟内存地址由页号和偏移量组成。页号就是上面所说的。偏移量就是我上面说的页（或者页帧）的大小，即这个页（或者页帧）到底能存多少数据。</p><p><strong>举个例子，有一个虚拟地址它的页号是4，偏移量是20，那么他的寻址过程是这样的：首先到页表中找到页号4对应的页帧号（比如为8），如果找不到对应的页桢，则用失效机制调入页。如果存在，把页帧号和偏移量传给MMU（CPU的内存管理单元）组成一个物理上真正存在的地址，接着就是访问物理内存中的数据了。</strong></p><h2>6. 线程里面有什么</h2><p>写到这里，好像还与本标题无关，即进程和线程到底是什么关系和区别等。但是我们要知道，面试或者学习一个知识点，不是为了学习这个区别而学习， 我们应该学习为什么有进程和线程，有了进程还需要线程吗？有了线程还要进程吗？你说进程是资源分配的单位，分配的是什么资源呢？进程中的内存是咋管理的呢？虚拟内存和物理内存是什么？什么是虚拟内存地址和物理内存地址？等等等，所以面试是千变万化的，重要的是我们尽可能地多问自己几个为什么，然后从为什么开始去逐个击破，形成一个体系。</p><p><img src="http://bloghello.oursnail.cn/operator1-2.png" alt="image"></p><p>说说这个栈，我们知道，执行程序从主程序入口进入开始，可能会调用很多的函数，那么这些函数的参数和返回地址都会被压入栈中，包括这些函数中定义的临时局部变量都会压入栈中，随着函数的执行完毕，再逐层地弹出栈，回到主函数运行的地方，再继续执行。</p><p>PC(program counter)，就是程序计数器，指向的下一条指令执行的地址。</p><p><strong>由此可见，操作系统运行的其实是一个一个的线程，而进程只是一个隔离资源的容器。</strong></p><p>上面说到，PC是指向下一条指令执行的地址。而这些指令是放在内存中的。</p><p>我们的计算机大多数是存储程序型的。就是说数据和程序是同时存储在同一片内存里的。</p><p>所以我们经常会听到一个漏洞叫做“<strong>缓冲区溢出</strong>”：比如有一个地方让用户输入用户名，但是黑客输入很长很长的字符串进去，那么很有可能就会超出存放这个用户名的一片缓冲区，而直接侵入到存放程序的地方，那么黑客就可以植入程序去执行。解决方案就是限制输入的用户名长度，不要超过缓冲区大小。</p><p>还有一块是<strong>TLS(thread local storage)</strong>，我们知道进程有自己独立的内存，那么我们的线程能不能也有一小块属于自己的内存区域呢？</p><p>这个东西，其实很简单，就是说，比如new一个对象，往往是在堆中开辟空间的，但是现在的情况是：在一个函数内，new出来一个对象，这个对象不引用外部对象，也不会被外部引用，是纯粹属于这个函数段，可以理解为这个对象是属于这个函数的局部临时变量。</p><p>此时，new这个对象就不需要再去堆中开辟空间了，因为一方面不需要共享，另一方面是在堆中开辟是比较慢的，并且可能有很多函数，这种局部对象零零总总加起来还是很多的，在堆中开辟会浪费空间。</p><p>所以，能不能在栈中就可以new出这个对象，反正用完就扔。TLS可以是现在这个。栈中直接new多方便多快，因为不需要走垃圾回收机制，还避免了线程安全问题。可以去搜索：<strong>栈上分配和逃逸分析</strong></p><h2>7. 线程VS进程</h2><p>到这里，就清晰了很多。我们也可以多多少少理解他们的区别。</p><p>可以做个简单的比喻，便于记忆：进程=火车，线程=车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－“互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul><p>再补充几句。</p><ul><li>线程是调度的基本单位，进程是资源分配的基本单位</li><li>进程间没有共享内存，所以交互要通过TCP/IP端口的等方式来实现。线程间由于有共享内存，所以交互比较方便。</li><li>线程占用很多资源，而线程只需要分配栈和PC即可。</li></ul><h2>8. 针对虚拟内存和物理内存的总结</h2><ul><li>每个进程都有自己独立的4G(32位系统下)内存空间，各个进程的内存空间具有类似的结构</li><li>一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间（建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于一个程序对应的多个进程这种情况，浪费内存！），哪些数据在哪里，都由进程控制表中的task_struct记录</li><li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址</li><li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</li><li>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li><li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常</li><li>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘</li></ul><h2>9. 关于进程和线程更深的认识</h2><p>关于为什么要分进程和线程，先抛出结论：</p><ul><li>进程process：进程就是时间总和=执行环境切换时间+程序执行时间------&gt;<strong>CPU加载执行环境-&gt;CPU执行程序-&gt;CPU保存执行环境</strong></li><li>线程thread：线程也是时间总和=执行环境切换时间（共享进程的）+程序模块执行时间------&gt;<strong>CPU加载执行环境（共享进程的）-&gt;CPU执行程序摸块-&gt;CPU保存执行环境（共享进程的）</strong></li><li>进程和线程都是描述CPU工作的时间段，线程是更细小的时间段。</li></ul><p>那么，如果CPU时间片临幸本进程，那么这个进程在恢复执行环境之后，执行里面的若干线程就不需要再不停地切换执行环境了，所以说，线程相比于进程是比较轻量的。</p><p>在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。</p><p>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文</p><p>线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p><p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境、更为细小的CPU时间段。</p><p><strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</strong></p><p>整理自：</p><ul><li><a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384</a></li><li><a href="https://blog.csdn.net/moshenglv/article/details/52242153" target="_blank" rel="noopener">https://blog.csdn.net/moshenglv/article/details/52242153</a></li><li><a href="https://blog.csdn.net/u012861978/article/details/53048077" target="_blank" rel="noopener">https://blog.csdn.net/u012861978/article/details/53048077</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 操作系统相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一步一步理解HTTPS</title>
      <link href="/2019/01/18/network/7.%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3HTTPS/"/>
      <url>/2019/01/18/network/7.%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3HTTPS/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第七篇文章。HTTPS（SSL/TLS）的加密机制是前端后端ios安卓等都应了解的基本问题。也是面试经常问的点。</p><a id="more"></a><h2>一、为什么需要加密？</h2><p>小时候看谍战片，情报发过来了之后，用一个小本本进行翻译，然后解密出情报。加密就是防止明文被别人看到甚至篡改嘛！</p><p>回到互联网，因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了，他还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。最简单容易理解的就是对称加密 。</p><h2>二、什么是对称加密？</h2><p><img src="http://bloghello.oursnail.cn/http7-1.png" alt="image"></p><p>小明写个求爱信给小红，小明担心小红的妈妈看到这封信的内容，他灵机一动，对信加个密，并确定好我用这个密钥加密的，小红收到之后也用这个密钥解密才行。</p><p>但是呢，这里有个麻烦的地方就是，小明和小红不在一个学校，这个钥匙呢，不方便直接送到手里。所以呢，小明得想办法把这个钥匙寄一个送给小红，好吧，就用最贵的顺丰吧！</p><p>就是有一个密钥，它可以对一段内容加密，加密后只能用它才能解密看到原本的内容，和我们日常生活中用的钥匙作用差不多。</p><h2>三、用对称加密可行吗？</h2><p>顺丰快递到了，结果小红不在家，小红的妈妈收到了，一看是个男同学寄的，怎么能忍住，赶紧打开，以看是一把钥匙，作为程序猿，妈妈得意一笑：哼哼，还能逃过我的眼睛？我赶紧复制一把藏着，我倒要看看他后面要寄啥来，还要加密？！</p><p>果然小红的妈妈等到了来自小明寄过来的情书，解密一看，实锤早恋。</p><p>同样地，小明这边也非常危险，快递员刚出发，就被小明的妈妈拦截了，拿到了这个钥匙，那小明还没寄出的信已经被妈妈看光了。</p><p><strong>所以问题的根本就是，这把钥匙要传输，传输就可能被截取。</strong></p><p><img src="http://bloghello.oursnail.cn/http7-2.png" alt="image"></p><p>回到互联网，如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。</p><p>然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。</p><p><strong>如果由服务器生成一个密钥并传输给浏览器，那这个传输过程中密钥被别人劫持弄到手了怎么办？</strong></p><p>换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行啦！这么做显然不现实。</p><p>怎么办？所以我们就需要神奇的非对称加密。</p><h2>四、什么是非对称加密？</h2><p>有两把密钥，通常一把叫做公钥、一把叫做私钥。</p><p>用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。</p><h2>五、用非对称加密可行吗？</h2><p><img src="http://bloghello.oursnail.cn/http7-4.png" alt="image"></p><p>公钥呢，还是要通过快递员送给小红的。OK，假设小红要回信，写好了用公钥加密，小红的妈妈因为拿不到私钥，看不到信的内容。</p><p>OK，但是反过来呢？小明用私钥加密传给小红，那么小红的妈妈可就能解密了（因为公钥可能会被小红的妈妈拿到）。</p><p>回到互联网，服务器先把公钥直接明文传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！因为只有服务器有相应的私钥能解开这条数据。</p><p>然而由服务器到浏览器的这条路怎么保障安全？</p><p>如果服务器用它的的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而<strong>这个公钥是一开始通过明文传输给浏览器的，这个公钥被谁劫持到的话，他也能用该公钥解密服务器传来的信息了。</strong></p><p>所以目前似乎只能保证由浏览器向服务器传输数据时的安全性（其实仍有漏洞，下文会说）。</p><h2>六、改良的非对称加密方案，似乎可以？</h2><p>小明和小红年纪不大，但是很聪明，针对这个情况，还是迅速升级加密方法。他们想到既然一组公钥私钥不够，那两组呢？</p><p><img src="http://bloghello.oursnail.cn/http7-5.png" alt="image"></p><p>OK，小明和小红各造了一对。下面就是互相交换公钥。那么就变成：</p><p><img src="http://bloghello.oursnail.cn/http7-6.png" alt="image"></p><p><strong>下面就好办啦，小明写信用公钥B加密，那么信的内容只有小红能破解，因为小红是随身携带私钥B。相反，小红用公钥A对信加密，这样只有小明能破解，因为小明也是随身携带私钥A</strong>。好像很安全啦！除了下面提到的漏洞，唯一的缺点可能是：小红得花半天时间才能解密完这封信，有点受不了。</p><p>回到互联网。请看下面的过程：</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥A；浏览器拥有用于非对称加密的公钥B、私钥B。</li><li>浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li>浏览器把公钥B明文传输给服务器。</li><li>之后浏览器向服务器传输的所有东西都用公钥A加密，服务器收到后用私钥A解密。由于只有服务器拥有这个私钥A可以解密，所以能保证这条数据的安全。</li><li>服务器向浏览器传输的所有东西都用公钥B加密，浏览器收到后用私钥B解密。同上也可以保证这条数据的安全。</li></ol><p>的确可以！抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。</p><h2>七、非对称加密+对称加密？</h2><p>小明也知道，这个信很长，用非对称加密，太慢！办法也有，没有必要对那么长的信加密，我只要保证这个真正解密的钥匙不被别人拿到就行，那么他灵机一动想到这个方法：</p><p><img src="http://bloghello.oursnail.cn/http7-7.png" alt="image"></p><p>小明和小红利用非对称加密对钥匙加密，姑且认为是这个钥匙被放在了一个盒子里，这个盒子也被锁起来了，只有小红或者小明才能打开盒子，再用钥匙去解密。</p><p>这个真正用于对称加密解密的钥匙别人就拿不到啦！</p><p>自从用了这个方案，感觉又安全，解密又快，感情又深温了呢！</p><p>回到互联网，步骤如下：</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥A。</li><li>浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li><strong>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器</strong>。</li><li><strong>服务器拿到后用私钥A解密得到密钥X</strong>。</li><li><strong>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密</strong>。</li></ol><p>HTTPS的基本思想就是基于这个。但是这个方案也存在上面一直在说的漏洞。</p><h2>八、中间人攻击</h2><p>像妈妈这样级别的程序猿可能是那他们两没办法啦，但是呢，校区有个看门的大爷，以前是个黑客，也不知道咋回事，明明才50岁，但是看起来像80岁，头上光溜溜的，冬天冷呢。整天在那胡言乱语：<code>docker</code>牛逼啊，<code>spring cloud</code>牛逼啊，这个开源软件XXX写的真好，跟周围的老大爷老大妈根本谈不到一起去。</p><p>他也是闲的蛋疼，非要掺和，因为据说他以前单身30年，苦逼敲代码，不知道谈恋爱是啥滋味，姑且认为他好奇心重吧。</p><p><strong>在小明第一次寄公钥A的时候，大爷出手了，截取下来。换成自己做的公钥B</strong>。然后送给小红。</p><p><strong>小红哪里会知道这公钥被掉包了呢</strong>，所以直接就用了，按照正常步骤，小红想了一个随机字符串，这次就叫<code>xiaomingwoxuanni</code>吧，OK，用这个公钥B对这个字符串加个密，这个字符串就被锁进了用大爷公钥B锁的盒子里。</p><p>老大爷在门口守着呢，一看到小红寄东西了，又偷偷地截取下来，<strong>用自己的私钥B来解密这个盒子</strong>。轻易地拿到了里面的字符串，OK，怕小明察觉，再用小明寄来的公钥A加密传给小明，这样双方都不知道他们的钥匙已经被大爷给获取了。</p><p>小明和小红之间的信就用<code>xiaomingwoxuanni</code>这个钥匙进行对称加密和对称解密，完全不知道有个大爷就天天拿着这个字符串去解密信件，看的不亦乐乎，甚至还偷偷改几个字呢。</p><p>回到互联网。中间人的确无法得到浏览器生成的密钥B，这个密钥本身被公钥A加密了，只有服务器才有私钥A解开拿到它呀！然而中间人却完全不需要拿到密钥A就能干坏事了。请看：</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥A。</li><li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li>中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B）。</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥B（浏览器不知道公钥被替换了）加密后传给服务器。</li><li>中间人劫持后用私钥B解密得到密钥X，再用公钥A加密后传给服务器。</li><li>服务器拿到后用私钥A解密得到密钥X。</li></ol><p>这样在双方都不会发现异常的情况下，中间人得到了密钥B。<strong>根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。只要解决了这个公钥一定是这个网站发来的，那么基本就OK了</strong></p><h2>九、如何证明浏览器收到的公钥一定是该网站的公钥？</h2><p>现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中能不能搞这么个公信机构呢？给网站颁发一个“身份证”？</p><h2>十、数字证书</h2><p>网站在使用HTTPS前，需要向“CA机构”申请颁发一份数字证书，即SSL证书，数字证书里有证书持有者、证书持有者的公钥等信息，<strong>服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”</strong>。然而这里又有一个显而易见的问题了，<strong>证书本身的传输过程中，如何防止被篡改</strong>？即如何证明证书本身的真实性？身份证有一些防伪技术，数字证书怎么防伪呢？解决这个问题我们就基本接近胜利了！</p><p>SSL证书内容：</p><ol><li>证书的发布机构CA</li><li>证书的有效期</li><li>公钥</li><li>证书所有者</li><li>签名</li></ol><h2>十一、如何放防止数字证书被篡改？</h2><p>我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名。</p><p>提到数字签名，其实原理很简单啦，就是比如我要传输一句话叫：“你给我转100块钱，我的账号是123456，转完了告诉我一声。”，如果不做任何处理，被刚才的老大爷截取了，他偷偷地改一下内容“你给我转200块钱，我的账号是654321，不要告诉任何人，尤其是你嫂子。”</p><p>是不是太坏了，弄不好被抓，大爷可不敢做大的，只敢骗个喝酒钱。</p><p>那么怎么防止大爷这种猥琐技术又高的人篡改呢？数字签名排上用场啦！</p><p>以后再传消息就是“你给我转100块钱，我的账号是123456，转完了告诉我一声。”+“！……@&amp;@%#……！￥@￥！@%……#￥！%……”,后面那一串东西就是数字签名，简单来说，就是想办法对前面的内容进行非对称加密（<strong>这样别人根本不知道你加密的私钥是什么，也就伪装不了签名了</strong>）。传过去之后，我要对其进行解密，与传过来的明文一一对比参数，看有没有被改动过。一旦发现哪里不对应，说明已经被篡改了。</p><p>“CA机构”制作签名的过程：</p><ol><li><strong>CA拥有非对称加密的私钥和公钥</strong>。</li><li><strong>CA对证书明文信息进行hash</strong>。</li><li><strong>对hash后的值用私钥加密，得到数字签名</strong>。</li></ol><p><strong>明文和数字签名共同组成了数字证书</strong>，这样一份数字证书就可以颁发给网站了。网站把这个数字证书传给浏览器。</p><p>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p><p>浏览器验证过程：</p><ol><li>拿到证书，得到明文T，数字签名S。</li><li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li><li>用证书里说明的hash算法对明文T进行hash得到T’。</li><li>比较S’是否等于T’，等于则表明证书可信。</li></ol><p>为什么这样可以证明证书可信呢？我们来仔细想一下。</p><h2>十二、中间人有可能篡改该证书吗？</h2><p>老大爷就算有天大的能耐，也拿不到加密的私钥，那么只是单纯地篡改明文，只会造成校验不通过。</p><p>回到互联网，假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。</p><p>浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><h2>十三、中间人有可能把证书掉包吗？</h2><p>假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。</p><p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p><p>总结：因为一个网站域名对应一个证书，你的证书根其他人的证书肯定是不一样的，那么你就算拿到了其他人的证书再掉包成自己的，也没用，毕竟浏览器那边只要看一下是不是我要查看的域名。</p><h2>十四、为什么制作数字签名时需要hash一次？</h2><p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。</p><h2>十五、怎么证明CA机构的公钥是可信的？</h2><p>让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站/机构等”，那这个CA机构的公钥是不是也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。</p><p>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链，也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。</p><p>另外，不知你们是否遇到过网站访问不了、提示要安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么没有该机构的根证书，你就得手动下载安装（风险自己承担XD）。安装该机构的根证书后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</p><p>也就是说，公钥是从证书中获取的。证书是网站从机构那边申请来的，证书+签名传给浏览器。只要校验通过，那么公钥必然没有被篡改过，并且一定是这个网站传来的，那么解决了我们最核心的问题：确定公钥是我们指定的网站传来的。</p><p>既然公钥是正确的，那么小红就会用正确的公钥对随机字符串加密，中间不会出现篡改。</p><h2>十六、HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？</h2><p>这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就行。</p><p>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p><h2>十七、HTTPS原理</h2><p>下面再来看看HTTPS原理就特别简单啦！</p><p>HTTPS 协议（<code>HyperText Transfer Protocol over Secure Socket Layer</code>）：可以理解为<code>HTTP</code>+<code>SSL/TLS</code>， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP</span><br><span class="line">SSL/TLS</span><br><span class="line">TCP</span><br><span class="line">IP</span><br></pre></td></tr></table></figure><p>我们只要知道，在SSL层里面可以完成校验和密钥的传输。</p><p><img src="http://bloghello.oursnail.cn/http7-8.png" alt="image"></p><p>理解了上面，这个图也就没啥好解释的了。</p><p>整理自：<a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43789231</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP基础知识提炼</title>
      <link href="/2019/01/18/network/6.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8F%90%E7%82%BC/"/>
      <url>/2019/01/18/network/6.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8F%90%E7%82%BC/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第六篇文章。这里简单记录一些关于HTTP的基本概念，比较基础。下面的内容是对《图解HTTP》提炼的再提炼，主要原因是很多重要的东西前面已经详细说过了，还有一些东西知道即可，用到再去查，作为一个后端攻城狮，也没有必要了解那么琐碎。</p><a id="more"></a><h2>HTTP是不保存状态的协议</h2><p>HTTP是无状态协议。自身不对请求和响应之间通信状态进行保存（即不做持久化处理）。 HTTP之所以设计得如此简单，是为了更快地处理大量事物，确保协议的可伸缩性。 HTTP/1.1 随时<strong>无状态协议</strong>，但可通过 Cookie 技术保存状态。</p><h2>告知服务器意图的HTTP方法</h2><ul><li>GET：获取资源</li><li>POST：传输实体主体</li><li>PUT：传输文件</li><li>HEAD：获得报文首部，与GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。</li><li>DELETE：删除文件，与PUT相反（响应返回204 No Content）。</li><li>OPTIONS：询问支持的方法，查询针对请求URI指定的资源支持的方法（Allow:GET、POST、HEAD、OPTIONS）。</li><li>TRACE：追踪路径</li><li>CONNECT：要求用隧道协议连接代理（主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输）。</li></ul><h2>URI、URL</h2><p>官方解释都是什么乱起八糟的东西。各种博客也是跟着抄，这两者到底是什么关系和意义？</p><p>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。</p><p>对应于实际例子就是：每个人都有身份证，这个身份证号码就对应这个人。比如张三的身份证号码为123456，那么我只要知道123456就可以找到这个人。</p><p>那什么是URL呢？从名字看是：统一资源定位器。</p><p>如果做类比，URL就是：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人</p><p>我们通过这个详细的地址也可以找到张三这个人。</p><p>那么他们俩到底是什么关系呢？</p><p>URI是以某种规则唯一地标识资源，手段不限，比如身份证号。当然了，地址可以唯一标识，那么也属于URI的一种手段。<strong>所以说URL是URI的子集</strong>。</p><p>回到Web上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。</p><p>而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。</p><p>对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息，如果有一天网址通过号码来标识变成了http://741236985.html，那感觉叫成URI更为合适。</p><h2>HTTP请求报文</h2><p><img src="http://bloghello.oursnail.cn/http6-1.png" alt="image"></p><h2>返回结果的HTTP状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。 状态码如200 OK，以3为数字和原因短语组成。 数字中的第一位定义了响应类别，后两位无分类。响应类别有以下五种：</p><table><thead><tr><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息性状态码)</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td></tr></tbody></table><h3>⭐2XX 成功</h3><ul><li><strong>200 OK：请求被正常处理</strong></li><li>204 No Content：一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li><li>206 Partial Content：客户端进行范围请求</li></ul><h3>⭐3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong>：<strong>永久重定向</strong>。表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。 也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</li><li><strong>302 Found</strong>：<strong>临时性重定向</strong>。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI（在Chrome中，还是会保存为重定向后的URI，不解）。</li><li>303 See Other：表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。这与302类似，但303明确表示客户端应当采用GET方法获取资源。</li><li>304 Not Modified：该状态码表示客户端发送附带条件的请求（指采用GET方法的请求报文中包含If-Match,If-Modified-Since，If-None-March，If-Range，If-Unmodified-Since中任一首部。）时，服务器端允许请求访问资源，但因发生请求为满足条件的情况后，直接返回304（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。<br>304虽被划分在3XX类别，但是和重定向没有关系。</li><li>307 Temporary Redirect：临时重定向。与302有相同含义。307遵守浏览器标准，不会从POST变成GET。</li></ul><h3>⭐4XX 客户端错误</h3><p>4XX的响应结果表明客户端是发生错误的原因所在。</p><ul><li><strong>400 Bad Request</strong>：表示请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong>：表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</li><li><strong>403 Forbidden</strong>：表明对请求资源的访问被服务器拒绝了。服务器端可在实体的主体部分对原因进行描述（可选）</li><li><strong>404 Not Found</strong>：表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时时用。</li></ul><h3>⭐5XX 服务器错误</h3><p>5XX的响应结果表明服务器本身发生错误。</p><ul><li><strong>500 Interval Server Error</strong>：表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</li><li><strong>503 Service Unavailable</strong>：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</li></ul><h2>HTTP的瓶颈</h2><ul><li><strong>一条连接上只可发送一个请求</strong>（前面讲到，持久化可保持TCP连接状态，但仍完成一次请求/响应后才能进行下一次请求/响应，而管线化方式可让一个TCP连接并行发送多个请求。）</li><li><strong>请求只能从客户端开始</strong>。客户端不可以接收除响应以外的指令</li><li><strong>请求/响应首部未经压缩就发送</strong>。首部信息越多延迟越大</li><li><strong>发送冗长(重复)的首部</strong>。每次互相发送相同的首部造成的浪费较多</li></ul><p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。</p><p>使用 SPDY后，HTTP协议额外获得以下功能。</p><ul><li><strong>多路复用流</strong>：通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。</li><li><strong>赋予请求优先级</strong>：SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li><li><strong>压缩HTTP首部</strong>：压缩HTTP请求和响应的首部。</li><li><strong>推送功能</strong>：支持服务器主动向客户端推送数据的功能。</li><li><strong>服务器提示功能</strong>：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</li></ul><h2>WebSocket</h2><p>利用<code>Ajax</code>和<code>Comet</code>技术进行通信可以提升<code>Web</code>的浏览速度。但问题在于通信若使用<code>HTTP</code>协议，就无法彻底解决瓶颈问题。</p><p><code>WebSocket</code>技术主要是为了解决<code>Ajax</code>和<code>Comet</code>里<code>XMLHttpRequst</code>附带的缺陷所引起的问题。</p><p>一旦Web服务器与客户端之间建立起<code>WebSocket</code>协议的通信连接，<strong>之后所有的通信都依靠这个专用协议进行</strong>。通信过程中可互相发送<code>JSON</code>、<code>XML</code>、<code>HTML</code>或图片等任意格式的数据。</p><p><code>WebSocket</code>的主要特点：</p><ul><li><strong>推送功能</strong>：支持由服务器向客户端推送数据。</li><li><strong>减少通信量</strong>：和<code>HTTP</code>相比，<strong>不但每次连接时的总开销减少</strong>，而且由于<code>WebSocket</code>的<strong>首部信息很小，通信量也相应较少</strong>。</li></ul><p>为了实现<code>WebSocket</code>通信，在HTTP连接建立之后，需要完成一次“握手”的步骤。</p><ul><li><strong>握手·请求</strong>：为了实现<code>WebSocket</code>通信，需要用到HTTP的<code>Upgrade</code>首部字段，告知服务器通信协议发生改变，以达到握手的目的。</li><li><strong>握手·响应</strong>：对于之前的请求，返回状态码<code>101 Switching Protocols</code> 的响应。<br>成功握手确立<code>WebSocket</code>连接后，通信时不再使用HTTP的数据帧，而采用<code>WebSocket</code>独立的数据帧。</li></ul><p>由于是建立在<code>HTTP</code>基础上的协议，因此连接的发起方仍是客户端，而一旦确立<code>WebSocket</code>通信连接，不论服务器端还是客户端，任意一方都可直接向对方发送报文。</p><p>整理自：<a href="https://github.com/JChehe/blog/blob/master/posts/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md" target="_blank" rel="noopener">https://github.com/JChehe/blog/blob/master/posts/《图解HTTP》读书笔记.md</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP三次握手和四次挥手</title>
      <link href="/2019/01/18/network/5.TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/01/18/network/5.TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第五篇文章。面试讲到TCP，那么基本都会问三次握手和四次挥手的过程，以及比如对于握手，为什么是三次，而不是两次或者四次，本章详细探讨其中的门道。</p><a id="more"></a><h2>1.复习</h2><p>首先针对http协议，我们有必要复习一下最重要的东西。</p><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p><p>在HTTP 1.0以0.9版本中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p><p>在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p><p>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。</p><p>通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道 客户端“在线”。</p><p>若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p><h2>2.SOCKET原理</h2><h3>2.1 套接字（socket）概念</h3><p>初次接触这个名词：“套接字”，说实话，心里是蒙蔽的，这是啥玩意，但是可以去搜索一下什么是套接管：</p><p><img src="http://bloghello.oursnail.cn/http5-1.jpg" alt="image"></p><p>我们可以看出来，两个管子可能直接连的话连不起来，那么可以通过中间一个东西连接起来。</p><p>那么，现在就好理解了，两个程序要通信，需要知道对方的一些信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p><img src="http://bloghello.oursnail.cn/http5-2.jpg" alt="image"></p><p>它是什么呢？它是网络通信过程中端点的抽象表示，这个抽象里面就包含了网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>那为什么一定要用它呢？</p><blockquote><p>在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的进程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。</p></blockquote><p>因为我们电脑上可能会跑很多的应用程序，TCP协议端口需要为这些同时运行的程序提供并发服务，或者说，传输层需要为应用层的多个进程提供通信服务，每个进程起一个TCP连接，那么这多个TCP连接可能是通过同一个 TCP协议端口传输数据。</p><p>如何区别哪个进程对应哪个TCP连接呢？</p><p>许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h3>2.2 建立socket连接</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为<code>ClientSocket</code> ，另一个运行于服务器端，称为<code>ServerSocket</code> 。</p><p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><p><strong>服务器监听</strong>：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p><p><strong>客户端请求</strong>：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p><p><strong>连接确认</strong>：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p><h3>2.3 SOCKET连接与TCP连接</h3><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p><h2>3.TCP基本字段</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>针对协议中的字段，我们只需要了解一下：ACK、SYN、序号这三个部分。</p><ul><li><p><strong>ACK</strong> : 确认</p><ul><li>TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li></ul></li><li><p><strong>SYN</strong> ： 在连接建立时用来同步序号。</p><ul><li>当SYN=1而ACK=0时，表明这是一个连接请求报文。</li><li>对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1.</li><li>因此, SYN置1就表示这是一个连接请求或连接接受报文。</li></ul></li><li><p><strong>FIN</strong> 即终结的意思， 用来释放一个连接。</p><ul><li>当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li></ul></li></ul><h2>4.三次握手(重要，细读)</h2><p><img src="http://bloghello.oursnail.cn/http5-3.jpg" alt="image"></p><p>首先，TCP作为一种可靠传输控制协议，其核心思想：<strong>既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！</strong></p><p>然后，要明确TCP连接握手，握的是啥？</p><p>答案：<strong>通信双方数据原点的序列号</strong>！</p><p>我们在上面一篇文章知道，消息的完整是靠给每个消息包搞一个编号，依次地ACK确认。确认机制是累计的，意味着 X 序列号之前(不包括 X) 包都是被确认接收到的。</p><p>TCP可靠传输的精髓：TCP连接的一方A，由<strong>操作系统动态随机选取一个32位长的序列号（Initial Sequence Number）</strong>。</p><p><strong>假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B。</strong></p><p><strong>让B有一个思想准备</strong>，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。</p><p>如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p><p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p><p>好了，在理解了握手的本质之后，下面就可以总结上面图的握手过程了。</p><p>对于A与B的握手过程，可以总结为：</p><ol><li>A 发送同步信号<code>SYN</code> + <code>A's Initial sequence number</code>（丢失会A会重传）</li><li>B 确认收到A的同步信号，并记录 <code>A's ISN</code> 到本地，命名 <code>B's ACK sequence number</code></li><li>B发送同步信号<code>SYN</code> + <code>B's Initial sequence number</code> （丢失B会周期性超时重传，直到收到A的确认）</li><li>A确认收到B的同步信号，并记录 <code>B's ISN</code> 到本地，命名 <code>A's ACK sequence number</code></li></ol><p><strong>很显然2和3 这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率</strong>。</p><p>这里就会引出一个问题，两次不行吗？</p><ol><li>A 发送同步信号SYN + A’s Initial sequence number</li><li>B发送同步信号SYN + B’s Initial sequence number + B’s ACK sequence number</li></ol><p><strong>这里有一个问题，A与B就A的初始序列号达成了一致，但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。</strong></p><p>所以A必须再给B一个确认，以确认A已经接收到B的同步信号。</p><blockquote><p>如果A发给B的确认丢了，该如何？</p></blockquote><p><strong>A会超时重传这个ACK吗？不会！TCP不会为没有数据的ACK超时重传。</strong></p><p><strong>那该如何是好？B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</strong></p><p>写到这里，其实我们已经明白了，握手其实就是各自确认对方的序列号。因为后面的数据编号就会以此为基础，从而保证后续数据的可靠性。</p><blockquote><p>谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：<strong>client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了</strong>，以致延误到连接释放以后的某个时间才到达server。<strong>本来这是一个早已失效的报文段</strong>。但server收到此失效的连接请求报文段后，就<strong>误认为是client再次发出的一个新的连接请求</strong>。于是就向client发出确认报文段，同意建立连接。<strong>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了</strong>。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。<strong>但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了</strong>。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。<strong>server由于收不到确认，就知道client并没有要求建立连接</strong>。”</p></blockquote><p>但是有的人指出，其实这只是表象，或者说并不是三次握手的设计初衷，我表示认同，这个防止已失效的连接请求报文段应该只是附加的一些好处，而不应该是解释为什么是三次握手的原因。</p><p><strong>TCP初始阶段为什么是三次握手，原因总结如下：</strong></p><blockquote><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。</p><p>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤，如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p></blockquote><h2>5.四次挥手</h2><p><img src="http://bloghello.oursnail.cn/http5-4.jpg" alt="image"></p><p>当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；</p><p>但是，这个时候主机1还是可以接受来自主机2的数据；</p><p>当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；</p><p>当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了；</p><p>主机1告诉主机2知道了，主机2收到这个确认之后就立马关闭自己。</p><p>主机1等待2MSL之后也关闭了自己。</p><p>针对最后一条消息，即主机1发送ack后，主机2接收到此消息，即认为双方达成了同步：双方都知道连接可以释放了，此时B可以安全地释放此TCP连接所占用的内存资源、端口号。</p><p><strong>所以被动关闭的B无需任何wait time，直接释放资源。</strong></p><p><strong>但是主机1并不知道主机2是否接到自己的ACK，主机1是这么想的</strong>：</p><ul><li>如果主机2没有收到自己的ACK，主机2会超时重传FiN，那么主机1再次接到重传的FIN，会再次发送ACK</li><li>如果主机2收到自己的ACK，也不会再发任何消息，包括ACK</li></ul><p>无论是情况1还是2，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：</p><p>主机2没有收到主机1的ACK，那么超时之后主机2会重传FIN，也就是说，要浪费一个<strong>主机1发出ACK的最大存活时间(MSL)+FIN消息的最大存活时间(MSL)</strong></p><p>不可能时间再多了，这个已经针对最糟糕的状况。</p><p>等待2MSL时间，A就可以放心地释放TCP占用的资源、端口号，此时可以使用该端口号连接任何服务器。</p><p>在等待的时间内，主机2可以重试多次，因为2MSL时间为240秒，超时重传只有0.5秒，1秒，2秒，，16秒。</p><p>当主机2重试次数达到上限，主机2会reset连接。</p><p>那么为什么是2MSL我们已经了解了，但是为什么要等这个时间呢？</p><p>如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部死翘翘，2MSL时间可以满足这个需求。</p><p>整理自：</p><ul><li><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633</a></li><li><a href="https://www.zhihu.com/question/67013338" target="_blank" rel="noopener">https://www.zhihu.com/question/67013338</a></li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/14</a></li><li><a href="https://www.jianshu.com/p/9968b16b607e" target="_blank" rel="noopener">https://www.jianshu.com/p/9968b16b607e</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP协议入门</title>
      <link href="/2019/01/18/network/4.TCP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
      <url>/2019/01/18/network/4.TCP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第四篇文章。首先要明确：信道本身不可靠（丢包、重复包、出错、乱序），不安全。所以引出了七层或五层模型来保证。因此，任何一个东西的提出都是为了解决某个问题的。学习计算机，从他的历史出发，理解为什么会有不断低迭代，因为是为了解决某个痛点问题。比如HTTP的发展，为什么在HTTP1.0基础上还要提出HTTP1.1，为什么还要提出HTTP2.0，我们学习了他的发展历史之后就会明白了。同样，下面再说一说为什么要有TCP协议，TCP到底解决了什么问题。</p><a id="more"></a><h2>一、回顾</h2><p>首先简单回顾一下。</p><h3>1.1 物理层</h3><p>物理层是相当于物理连接，将0101以电信号的形式传输出去。</p><h3>1.2 数据链路层</h3><p>数据链路层，有一个叫做以太网协议，规定了电子信号是如何组成数据包的，这个协议的头里面，包含了自身的网卡信息，还有目的地的网卡信息（一般我们可以知道对方的IP，IP可以通过DNS解析到，然后根据ARP协议将IP转换为MAC地址）。那么，如果在同一个局域网内，我们就可以通过广播的方式找到对应MAC地址的主机。—即以太网协议解决了子网内部的点对点通信。</p><h3>1.3 网络层</h3><p>但是呢，以太网协议不能解决多个局域网通信，每个局域网之间不是互通的，那么以太网这种广播的方式不可用，就算可用，网络那么大，通过广播进行找，是一个可怕的场景。那么，IP协议可以连接多个局域网，简单来说，IP 协议定义了一套自己的地址规则，称为 IP 地址。物理器件，比如说路由器，就是基于IP协议，里面保存一套地址指路牌，想去哪个局域网，可以通过这个牌子来找，然后逐步路由到目标局域网，最后就可以找到那台主机了。IP层就是对应了网络层。</p><h3>1.4 传输层</h3><p>那么，此时解决了多个局域网路由问题，也解决了局域网内寻址问题，即我这台主机已经可以找到那台主机了，下面还有什么事情需要做呢？显然，找到主机还不行啊，比如我用微信发一条消息，我发到你主机了，但是你主机上的微信不知道这条消息发给他了，这里说的就是端口，信息要发到这个端口上，监听这个端口的程序才会收到消息。</p><h3>1.5 应用层</h3><p>OK，最上层的应用层，就是最贴近用户的，他的一系列协议只是为了让两台主机会互相都理解而已。</p><h2>二、问题和解决</h2><h3>2.1 存在的问题</h3><p>在明白了计算机网络为什么要这几层模型之后，我们再回到一开始，如何保证安全、可靠、完整地传输信息呢？</p><p>很显然，上面提到的，只是保证信息能找到对方主机和端口，但是这个信息中途被拦截了、甚至被篡改了、信息延迟了（几分钟或者几个小时，或者几个世纪）、网络不通或者挂了，信息自己可不会告诉你他挂了或者要迟到一会，如果没有一个协议来保障可靠性，那么我这条消息发出去，能不能到、能不能及时到、能不能完整到、能不能不被篡改到等这些问题将会造成灾难，网络传输也就没有了意义。</p><p>计算机的前辈们，为我们提供了一系列的措施来尽可能保证信息能正确送达。</p><h3>2.2 数据校验</h3><p>首先在数据链路层，可以通过各种校验，比如奇偶校验等手段来判断数据包传的是否正确。</p><h3>2.3 数据可靠性</h3><p>好了，解决了数据是否正确之后，但是还不能保证线路是可靠的，加入某个包没发出去或者发错了，应该有一个出错重传机制，保证信息传输的可靠性。这就引出了TCP协议。</p><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>下面来看看TCP是如何解决丢包、重复包、出错、乱序等不可靠的一些问题的。</p><h2>三、滑动窗口协议的提出</h2><p>这就引出了TCP中最终的一个东西：滑动窗口协议。</p><h3>3.1 朴素的方法来确保可靠性</h3><p>先从简单的角度出发，自己想一下，如何保证不丢包、不乱序。</p><p><img src="http://bloghello.oursnail.cn/http3-1.png" alt="image"></p><p>按照顺序，发送一个确认一个，显然，吞吐量非常低。那么，一次性发几个包，然后一起确认呢？</p><h3>3.2 改进方案</h3><p><img src="http://bloghello.oursnail.cn/http3-2.png" alt="image"></p><p>那么就引出第二个问题，我一次性发几个包合适呢？就这引出了滑动窗口。</p><h2>四、数据包编号和重传机制</h2><h3>4.1 数据包编号</h3><p>在说明滑动窗口原理之前，必须要说一下TCP数据包的编号SEQ。</p><p>我们知道，由于以太网数据包大小限制，所以每个包承载的数据是有限的，如果发一个很大的包，必然是要拆分的。</p><p>发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。</p><p>第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。</p><h3>4.2 数据重传机制</h3><p>TCP协议就是根据这些编号来重新还原文件的。并且接收端保证顺序性返回ACK确认，比如有两个包发过去，为1号和2号，2号接收成功，但是发现1号包还没接收到，所以2号的ACK是不会发回去的，这个时候，如果在重传时间内收到1号了，那么就把这两个包的ACK都返回回去，如果超时了，就重传1号包。知道1号包接收成功，后续的才会返回ACK。</p><p>具体是如何做到的呢？</p><p>前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。</p><p>举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。</p><p>如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</p><p><img src="http://bloghello.oursnail.cn/http3-5.png" alt="image"></p><p>（图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。）</p><h2>五、慢启动</h2><p>下面再来说说慢启动。</p><p>服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。</p><p>最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。</p><p>TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。</p><p>Linux 内核里面设定了（常量<code>TCP_INIT_CWND</code>），刚开始通信的时候，发送方一次性发送10个数据包，即&quot;发送窗口&quot;的大小为10。然后停下来，等待接收方的确认，再继续发送。</p><p>默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。&quot;确认&quot;的英语是 <code>acknowledgement</code>，所以这个确认消息就简称 ACK。</p><p>ACK 携带两个信息：</p><ul><li>期待要收到下一个数据包的编号</li><li>接收方的接收窗口的剩余容量</li></ul><p>发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为&quot;发送窗口&quot;，这个窗口的大小是可变的。</p><p>我们可以知道，发送发和接收方都维护了一个缓冲区，可以理解为窗口。根据接收速度可以调整发送速度，逐渐达到这条线路最高的传输速率。</p><p>ok，下面就可以研究一下滑动窗口了。</p><h2>六、滑动窗口原理</h2><p>正常情况下：</p><p><img src="http://bloghello.oursnail.cn/http3-6.png" alt="image"></p><p>（如图，123表示已经正常发送并且收到了ACK确认。4567属于已发送但是还没有收到ACK。8910表示待发送。这个窗口当前长度为7.正常情况下，4号包收到ACK，那么窗口就会右移一格。）</p><p>但是往往会出现一些问题，比如5号包迟迟收不到ACK，在接收端可能是没有收到5号包，但是可能会收到6号包甚至是7、8号包，那么此时只能等待5号包，如果5号包顺利到达了，那么就把5678号包的ACK都发给发送端，那么发送端滑动窗口向右右移四格。如果迟迟收不到5号包，只能重传。</p><p><img src="http://bloghello.oursnail.cn/http3-3.png" alt="image"></p><p>以上就是关于TCP中比较重要的出错重传、编号、慢启动以及滑动窗口。这些保证了数据传输的可靠性。</p><p>整理自：<a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>http的前世今生</title>
      <link href="/2019/01/17/network/3.http%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/01/17/network/3.http%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第三篇文章。作为一个后端攻城狮，每天打交道最多的就是HTTP协议，在如今火热的微服务实现方案中，除了阿里的dubbo，就是spring cloud，而spring cloud目前适用的服务间通信方式也就是基于HTTP 的 restful接口来实现。并且作为浏览器上用的最多的协议，无论是前端、后端还是测试都应该去熟悉它，软件的发展是循序渐进的，每次的迭代升级都是为了解决上一版本的痛点，HTTP协议的发展也是如此，本章着重讲解HTTP的前世今生，让我们更加了解HTTP。</p><a id="more"></a><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><h2>一、HTTP/0.9</h2><h3>1.1 简介</h3><p>这是第一个定稿的HTTP协议。</p><ul><li>内容非常简单，只有一个命令GET</li><li>没有HEADER等描述数据的信息</li><li>服务器发送完毕，就关闭TCP连接（一个HTTP请求在一个TCP连接中完成）</li></ul><h3>1.2 请求格式</h3><p>比如发起一个GET请求：</p><blockquote><p>GET /index.html</p></blockquote><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p><h3>1.3 响应格式</h3><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器发送完毕，就关闭TCP连接。</p><h2>二、HTTP/1.0</h2><h3>2.1 简介</h3><p>跟现在比较普遍适用的1.1版本已经相差不多。</p><ul><li>增加很多命令，比如POST、HEAD等命令</li><li>增加status code 和 header</li><li>多字符集支持、多部分发送、权限、缓存等</li></ul><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h3>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>可以看到，这个格式与0.9版有很大变化。<br>第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。</p><p>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。上面代码中，客户端声明自己可以接受任何格式的数据。</p><h3>2.3 响应格式</h3><p>服务器的回应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>回应的格式是&quot;头信息 + 一个空行（\r\n） + 数据&quot;。其中，第一行是&quot;协议版本 + 状态码（status code） + 状态描述&quot;。</p><h3>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。</p><h3>2.5 缺点</h3><p>每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。</p><blockquote><p>Connection: keep-alive</p></blockquote><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p><blockquote><p>Connection: keep-alive</p></blockquote><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h2>三、HTTP/1.1</h2><h3>3.1 持久连接和管道机制</h3><ul><li>持久连接（以前的版本中，一个HTTP请求就创建一个TCP连接，请求返回之后就关闭TCP连接，然而建立一次TCP连接的过程是比较耗时的，效率会比较低，现在建立一个TCP连接后，后面的HTTP请求都可以复用这个TCP连接，即允许了在同一个连接里面发送多个请求，会提高效率）</li><li>pipeline（解决了同一个TCP连接中客户端可以发送多个HTTP请求，但是对于服务端来说，对于进来的请求要按照顺序进行内容的返回，如果前一个请求处理时间长，而后一个请求处理时间端，即便后面一个请求已经处理完毕了，也要等待前一个请求处理完毕返回他才可以返回结果，这种串行的方式比较慢）</li></ul><p>在1.1版本以前，每次HTTP请求，都会重新建立一次TCP连接，服务器响应后，就立刻关闭。众所周知，建立TCP连接的新建成本很高，因为需要三次握手，并且有着慢启动的特性导致发送速度较慢。而1.1版本添加的持久连接功能可以让一次TCP连接中发送多条HTTP请求，<strong>值得一提的是默认是，控制持久连接的Connection字段默认值是keep-alive，也就是说是默认打开持久连接，如果想要关闭，只需将该字段的值改为close。</strong></p><blockquote><p>Connection: close</p></blockquote><p>而管道化则赋予了客户端在一个TCP连接中连续发送多个请求的能力，而不需要等到前一个请求响应，这大大提高了效率。值得一提的是，虽然客户端可以连续发送多个请求，但是服务器返回依然是按照发送的顺序返回。（强调的是request不需要等待上一个request的response，其实发送的request还是有顺序的，服务端按照这个顺序接收，依次返回响应）</p><p>HTTP/1.1允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。（me：所有请求保持一个FIFO的队列，一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出；同时，服务器端返回这些请求的响应时也是按照FIFO的顺序）。管道化的表现可以大大提高页面加载的速度，尤其是在高延迟连接中。</p><h3>3.2 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。</p><blockquote><p>Content-Length: 3495</p></blockquote><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h3>3.3 分块传输编码</h3><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用&quot;流模式&quot;（stream）取代&quot;缓存模式&quot;（buffer）。</p><p>因此，1.1版规定可以不使用Content-Length字段，而使用&quot;分块传输编码&quot;（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。</p><blockquote><p>Transfer-Encoding: chunked</p></blockquote><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3>3.3 其他功能</h3><p>1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</p><blockquote><p>Host: <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></p></blockquote><p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h3>3.4 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为&quot;队头堵塞&quot;（Head-of-line blocking）。</p><h2>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><h2>五、HTTP/2</h2><h3>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。</p><p>HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h3>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了&quot;队头堵塞&quot;。</p><p><strong>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</strong></p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h3>5.3 数据流</h3><p><strong>因为 HTTP/2 的数据包是不按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h3>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h3>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><p>整理自：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从上到下看五层模型</title>
      <link href="/2019/01/17/network/2.%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/01/17/network/2.%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第二篇文章。经过上一篇文章的详细介绍，我们了解了一个数据是如何从物理层一步一步到达应用层的，那么本章从上而下的角度来看看一条请求时如何从浏览器传递到服务器并且返回的。</p><a id="more"></a><p>这个过程看的就是用户从浏览器输入一条url之后，是如何发送过去的。</p><h2>1.上一篇文章的小结</h2><p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p><p><img src="http://bloghello.oursnail.cn/http1-7.png" alt="image"></p><p>发送这个包，需要知道两个地址：</p><ul><li>对方的MAC地址</li><li>对方的IP地址</li></ul><p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p><p><img src="http://bloghello.oursnail.cn/http2-1.png" alt="image"></p><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。</p><p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。</p><p>有了一台新电脑之后，要想上网，一种方式是自己配置静态IP：</p><p><img src="http://bloghello.oursnail.cn/http2-2.png" alt="image"></p><p>很多人都没有进行过这个配置，因为一般情况下我们根本不需要这样。但是有的时候也会用到，比如我在电信实习的时候，他们每一个网口旁边都贴着这四个参数，你联网必须要适用他提供的一系列地址才行。其实经过上面的学习，我们已经知道，通信的时候，需要知道对方的IP（ARP知道对方的MAC地址）、子网掩码（确定所在的子网）、默认网关（不在一个子网，要通过网关取转发、路由）、DNS服务器（解析域名为IP地址）。</p><p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用&quot;动态IP地址上网&quot;。</p><h2>2.DHCP协议</h2><p>所谓&quot;动态IP地址&quot;，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。</p><p><strong>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址</strong>，它叫做&quot;DHCP服务器&quot;。新的计算机加入网络，必须向&quot;DHCP服务器&quot;发送一个&quot;DHCP请求&quot;数据包，申请IP地址和相关的网络参数。</p><p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，<strong>新加入的计算机不知道DHCP服务器的两个地址，怎么发送数据包呢</strong>？</p><p>DHCP协议做了一些巧妙的规定。</p><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p><p><img src="http://bloghello.oursnail.cn/http2-3.png" alt="image"></p><p>（1）最前面的&quot;以太网标头&quot;，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p>（2）后面的&quot;IP标头&quot;，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>（3）最后的&quot;UDP标头&quot;，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。</p><p>因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。</p><p>当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道&quot;这个包是发给我的&quot;，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个&quot;DHCP响应&quot;数据包。</p><p>这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><p>动态拿到最核心的四个参数：自己的IP地址、子网掩码、网关地址、DNS服务器，就可以联网了。</p><h2>3.访问google的过程</h2><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p><ul><li>本机的IP地址：192.168.1.100</li><li>子网掩码：255.255.255.0</li><li>网关的IP地址：192.168.1.1</li><li>DNS的IP地址：8.8.8.8</li></ul><p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>。</p><p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><h3>3.1 DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，<a href="http://xn--www-ot9d81uoqfzzwl33bu7n883b.google.com" target="_blank" rel="noopener">我们只知道网址www.google.com</a>，不知道它的IP地址。</p><p>DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p><p><img src="http://bloghello.oursnail.cn/http2-4.png" alt="image"></p><p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><h3>3.2 子网掩码</h3><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p><h3>3.3 应用层协议</h3><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p><p><img src="http://bloghello.oursnail.cn/http2-5.png" alt="image"></p><p>HTTP部分的内容，类似于下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　GET / HTTP/1.1</span><br><span class="line">　　Host: www.google.com</span><br><span class="line">　　Connection: keep-alive</span><br><span class="line">　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ......</span><br><span class="line">　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">　　Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">　　Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3</span><br><span class="line">　　Cookie: ... ...</span><br></pre></td></tr></table></figure><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><h3>3.4 TCP协议</h3><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><h3>3.5 IP协议</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><h3>3.6 以太网协议</h3><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><h3>3.7 服务器响应</h3><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的&quot;HTTP请求&quot;，接着做出&quot;HTTP响应&quot;，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p><p>整理自：<a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从下到上看五层模型</title>
      <link href="/2019/01/17/network/1.%E4%BB%8E%E4%B8%8B%E5%88%B0%E4%B8%8A%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/01/17/network/1.%E4%BB%8E%E4%B8%8B%E5%88%B0%E4%B8%8A%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第一篇文章。要想了解HTTP协议，必然要从最基本的计算机网络知识开始入手。本篇文章从下到上具体介绍五层经典模型，极速入门计算机网络。</p><a id="more"></a><h2>经典五层模型</h2><p><img src="http://bloghello.oursnail.cn/http1-6.png" alt="image"></p><p>下面我们先来了解一下各层做的事情！</p><h2>1.物理层</h2><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p>这就叫做&quot;物理层&quot;，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p><h2>2.数据链路层</h2><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p><p>这就是&quot;链接层&quot;的功能，它在&quot;实体层&quot;的上方，确定了0和1的分组方式。</p><h3>2.1 以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做&quot;以太网&quot;（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做&quot;帧&quot;（Frame）。每一帧分成两个部分：<strong>标头</strong>（Head）和<strong>数据</strong>（Data）。</p><p><img src="http://bloghello.oursnail.cn/http1-2.png" alt="image"></p><p>&quot;标头&quot;包含数据包的一些说明项，比如发送者、接受者、数据类型等等；&quot;数据&quot;则是数据包的具体内容。</p><p>&quot;标头&quot;的长度，固定为18字节。&quot;数据&quot;的长度，最短为46字节，最长为1500字节。因此，整个&quot;帧&quot;最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h3>2.2 MAC地址</h3><p>上面提到，以太网数据包的&quot;标头&quot;，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>以太网规定，连入网络的所有设备，都必须具有&quot;网卡&quot;接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h3>2.3 广播</h3><p>定义地址只是第一步，后面还有更多的步骤。</p><p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p><p>回答是有一种ARP协议，可以解决这个问题。下面介绍ARP。</p><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>回答是以太网采用了一种很&quot;原始&quot;的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><p><img src="http://bloghello.oursnail.cn/http1-1.png" alt="image"></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的&quot;标头&quot;，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做&quot;广播&quot;（broadcasting）。</p><p>有了数据包的定义、网卡的MAC地址、广播的发送方式，&quot;链接层&quot;就可以在多台计算机之间传送数据了。</p><h2>3.网络层</h2><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一&quot;包&quot;，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用&quot;路由&quot;方式发送。（&quot;路由&quot;的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了&quot;网络层&quot;的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做&quot;网络地址&quot;，简称&quot;网址&quot;。</p><p>于是，&quot;网络层&quot;出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><h3>3.1 IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数&quot;子网掩码&quot;（subnet mask）。</p><p>所谓&quot;子网掩码&quot;，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道&quot;子网掩码&quot;，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><h3>3.2 IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p><p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的&quot;数据&quot;部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>具体来说，IP数据包也分为&quot;标头&quot;和&quot;数据&quot;两个部分。&quot;标头&quot;部分主要包括版本、长度、IP地址等信息，&quot;数据&quot;部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p><p><img src="http://bloghello.oursnail.cn/http1-3.png" alt="image"></p><p>IP数据包的&quot;标头&quot;部分的长度为20个字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的&quot;数据&quot;部分，最长为65,515字节。前面说过，以太网数据包的&quot;数据&quot;部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><h3>3.3 ARP协议</h3><p>关于&quot;网络层&quot;，还有最后一点需要说明。</p><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的，但是我们不知道它的MAC地址。</p><p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的&quot;网关&quot;（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个&quot;广播&quot;地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h2>4. 传输层</h2><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做&quot;端口&quot;（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>&quot;端口&quot;是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>&quot;传输层&quot;的功能，就是建立&quot;端口到端口&quot;的通信。相比之下，“网络层&quot;的功能是建立&quot;主机到主机&quot;的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做&quot;套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p><h3>4.1 UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由&quot;标头&quot;和&quot;数据&quot;两部分组成。</p><p><img src="http://bloghello.oursnail.cn/http1-2.png" alt="image"></p><p>&quot;标头&quot;部分主要定义了发出端口和接收端口，&quot;数据&quot;部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的&quot;数据&quot;部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p><p><img src="http://bloghello.oursnail.cn/http1-4.png" alt="image"></p><p>UDP数据包非常简单，&quot;标头&quot;部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h3>4.2 TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的&quot;数据&quot;部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><p>关于TCP细节以后再探讨。</p><h2>5. 应用层</h2><p>应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p>&quot;应用层&quot;的作用，就是规定应用程序的数据格式。</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&quot;数据&quot;部分。因此，现在的以太网的数据包就变成下面这样。</p><p><img src="http://bloghello.oursnail.cn/http1-7.png" alt="image"></p><blockquote><p>*注：UDP头为8个字节，TCP头为20个字节</p></blockquote><p>整理于：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
