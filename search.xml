<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java基础之NIO</title>
      <link href="/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BNIO/"/>
      <url>/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BNIO/</url>
      <content type="html"><![CDATA[<p>为了限制篇幅，关于IO这一块的内容，已经从本笔记中移除，具体还是另外看笔记，这里主要还是介绍NIO。</p><a id="more"></a><h2>一、NIO</h2><p>非阻塞的输入/输出 (<code>NIO</code>) 库是在 <code>JDK 1.4</code> 中引入的。<code>NIO</code> 弥补了原来的 <code>I/O</code> 的不足，提供了高速的、面向块的 <code>I/O</code>。</p><h2>1.1 阻塞I/O通信模型</h2><p>假如现在你对阻塞I/O已有了一定了解，我们知道阻塞I/O在调用<code>InputStream.read()</code>方法时是阻塞的，它会一直等到数据到来时（或超时）才会返回；同样，在调用<code>ServerSocket.accept()</code>方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。阻塞I/O的通信模型示意图如下：</p><p><img src="http://xiaozhao.oursnail.cn/%E9%98%BB%E5%A1%9EIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="image"></p><p>缺点：</p><ol><li>当客户端多时，会创建大量的处理线程。且每个线程都要占用栈空间和一些CPU时间</li><li>阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。</li></ol><h2>1.2 java NIO原理及通信模型</h2><p>下面是<code>java NIO</code>的工作原理：</p><ol><li>由一个专门的线程来处理所有的 IO 事件，并负责分发。</li><li>事件驱动机制：事件到的时候触发，而不是同步的去监视事件。</li><li>线程通讯：线程之间通过 <code>wait</code>,<code>notify</code> 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。</li></ol><p><img src="http://xiaozhao.oursnail.cn/NIO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="image"></p><p><code>Java NIO</code>的服务端只需启动一个专门的线程来处理所有的 <code>IO</code> 事件，这种通信模型是怎么实现的呢？<code>java NIO</code>采用了双向通道（<code>channel</code>）进行数据传输，而不是单向的流（<code>stream</code>），在通道上可以注册我们感兴趣的事件。一共有以下四种事件：</p><table><thead><tr><th>事件名</th><th>对应值</th></tr></thead><tbody><tr><td>服务端接收客户端连接事件</td><td>SelectionKey.OP_ACCEPT(16)</td></tr><tr><td>客户端连接服务端事件</td><td>SelectionKey.OP_CONNECT(8)</td></tr><tr><td>读事件</td><td>SelectionKey.OP_READ(1)</td></tr><tr><td>写事件</td><td>SelectionKey.OP_WRITE(4)</td></tr></tbody></table><p>服务端和客户端各自维护一个管理通道的对象，我们称之为<code>selector</code>，该对象能检测一个或多个通道 (<code>channel</code>) 上的事件。我们以服务端为例，如果服务端的<code>selector</code>上注册了读事件，某时刻客户端给服务端发送了一些数据，阻塞<code>I/O</code>这时会调用<code>read()</code>方法阻塞地读取数据，而<code>NIO</code>的服务端会在<code>selector</code>中添加一个读事件。服务端的处理线程会轮询地访问<code>selector</code>，如果访问<code>selector</code>时发现有感兴趣的事件到达，则处理这些事件，如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达为止。下面是我理解的<code>java NIO</code>的通信模型示意图：</p><p><img src="http://xiaozhao.oursnail.cn/NIO%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="image"></p><h2>二、关于阻塞与非阻塞，同步与非同步的理解</h2><p>我们都知道常见的IO有四种方式，同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。然而对于同步和阻塞的理解却一直很模糊。</p><h4>2.1 同步与异步</h4><ul><li>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</li><li>而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</li><li>我们可以用打电话（同步）和发短信（异步）来很好的比喻同步与异步操作。</li></ul><h4>2.2 阻塞和非阻塞</h4><ul><li>阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。</li><li>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。</li><li>虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。</li></ul><h4>2.3 什么是阻塞IO？什么是非阻塞IO？</h4><p>在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。</p><p>通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。</p><p>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：</p><ul><li>查看数据是否就绪；</li><li>进行数据拷贝（内核将数据拷贝到用户线程）。</li></ul><p>那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于<font color="#ff0000">第一个阶段</font>，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p><p><font color="#ff0000">Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</font></p><h4>2.4 什么是同步IO？什么是异步IO？</h4><p>我们知道了，阻塞和非阻塞是判断数据是否就绪时如何处理，即IO操作的第一阶段。</p><p>那么什么是同步IO和异步IO呢？</p><p>我们知道，同步是打电话，异步是发短信，打电话需要等到电话通了才能进行下一步，发短信就不用操心那么多了，我发出去就行了，至于什么时候发送、如何发送以及如何保证我这个短信一定能发出去，我是不管的。</p><p>同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。</p><blockquote><p>描述的是用户线程与内核的交互方式：</p></blockquote><ul><li>同步是指用户线程发起 I/O 请求后需要等待或者轮询内核 I/O操作完成后才能继续执行；</li><li>异步是指用户线程发起I/O请求后仍继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</li></ul><h2>三、Channel（通道）</h2><p>通道，顾名思义，就是通向什么的道路，为某个提供了渠道。在传统IO中，我们要读取一个文件中的内容，通常是像下面这样读取的：</p><p><img src="http://bloghello.oursnail.cn/javabbasic13-1.png" alt="image"></p><p>这里的<code>InputStream</code>实际上就是为读取文件提供一个通道的。<br>因此可以将<code>NIO</code> 中的<code>Channel</code>同传统IO中的<code>Stream</code>来类比，但是要注意，传统IO中，<code>Stream</code>是单向的，比如<code>InputStream</code>只能进行读取操作，<code>OutputStream</code>只能进行写操作。而<code>Channel</code>是双向的，既可用来进行读操作，又可用来进行写操作。</p><p>通道包括以下类型：</p><ul><li><code>FileChannel</code>：从文件中读写数据；</li><li><code>DatagramChannel</code>：通过 UDP 读写网络中数据；</li><li><code>SocketChannel</code>：通过 TCP 读写网络中数据；</li><li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 <code>SocketChannel</code></li></ul><p>下面给出通过<code>FileChannel</code>来向文件中写入数据的一个例子：</p><p><img src="http://bloghello.oursnail.cn/javabasic13-2.png" alt="image"></p><h2>四、Buffer（缓冲区）</h2><p><code>Buffer</code>（缓冲区），是<code>NIO</code>中非常重要的一个东西，在<code>NIO</code>中所有数据的读和写都离不开<code>Buffer</code>。比如上面的一段代码中，读取的数据时放在<code>byte</code>数组当中，而在<code>NIO</code>中，读取的数据只能放在<code>Buffer</code>中。同样地，写入数据也是先写入到<code>Buffer</code>中。</p><p><img src="http://xiaozhao.oursnail.cn/NIOBuffer.jpg" alt="image"></p><p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入<code>Buffer</code>中，然后将<code>Buffer</code>中的内容写入通道。服务端这边接收数据必须通过<code>Channel</code>将数据读入到<code>Buffer</code>中，然后再从<code>Buffer</code>中取出数据来处理。</p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>如果是对于文件读写，上面几种<code>Buffer</code>都可能会用到。但是对于网络读写来说，用的最多的是<code>ByteBuffer</code>。</p><h2>五、缓冲区状态变量</h2><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 <code>position</code> 为 0，而 <code>limit = capacity = 8</code>。<code>capacity</code> 变量不会改变，下面的讨论会忽略它。</p><p><img src="http://xiaozhao.oursnail.cn/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="image"></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 <code>position</code> 移动设置为 5，<code>limit</code> 保持不变。</p><p><img src="http://xiaozhao.oursnail.cn/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="image"></p><p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 <code>flip()</code> 方法，这个方法将 <code>limit</code> 设置为当前 <code>position</code>，并将 <code>position</code> 设置为 0。</p><blockquote><p>buffer中的flip方法涉及到bufer中的Capacity,Position和Limit三个概念。其中Capacity在读写模式下都是固定的，就是我们分配的缓冲大小,Position类似于读写指针，表示当前读(写)到什么位置,Limit在写模式下表示最多能写入多少数据，此时和Capacity相同，在读模式下表示最多能读多少数据，此时和缓存中的实际数据大小相同。在写模式下调用flip方法，那么limit就设置为了position当前的值(即当前写了多少数据),postion会被置为0，以表示读操作从缓存的头开始读。也就是说调用flip之后，读写指针指到缓存头部，并且设置了最多只能读出之前写入的数据长度(而不是整个缓存的容量大小)。</p></blockquote><p><img src="http://xiaozhao.oursnail.cn/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="image"></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 <code>position</code> 设为 4。</p><p><img src="http://xiaozhao.oursnail.cn/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="image"></p><p>⑤ 最后需要调用 <code>clear()</code> 方法来清空缓冲区，此时 <code>position</code> 和 <code>limit</code> 都被设置为最初位置。</p><p><img src="http://xiaozhao.oursnail.cn/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="image"></p><h2>六、文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p><p><img src="http://bloghello.oursnail.cn/javabasic13-3.png" alt="image"></p><h2>七、Selector（选择器）</h2><p>可以说它是<code>NIO</code>中最关键的一个部分，<code>Selector</code>的作用就是用来轮询每个注册的<code>Channel</code>，一旦发现<code>Channel</code>有注册的事件发生，便获取事件然后进行处理。</p><p><img src="http://xiaozhao.oursnail.cn/4d930e22-f493-49ae-8dff-ea21cd6895dc.png" alt="image"></p><p>用单线程处理一个<code>Selector</code>，然后通过<code>Selector.select()</code>方法来获取到达事件，在获取了到达事件之后，就可以逐个地对这些事件进行响应处理。</p><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。</p><p>下面从编程的角度具体来看看选择器是如何实现的。</p><h3>7.1 创建选择器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3>7.2 将通道注册到选择器上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li><code>SelectionKey.OP_CONNECT</code></li><li><code>SelectionKey.OP_ACCEPT</code></li><li><code>SelectionKey.OP_READ</code></li><li><code>SelectionKey.OP_WRITE</code></li></ul><p>它们在 <code>SelectionKey</code> 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3>7.3 监听事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure><p>使用 <code>select()</code> 来监听事件到达，它会一直阻塞直到有至少一个事件到达。</p><h3>7.4 获取到达的事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>7.5 事件循环</h3><p>因为一次 <code>select()</code> 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>八、流与块</h2><p><code>I/O</code> 与 <code>NIO</code> 最重要的区别是数据打包和传输的方式，<code>I/O</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据。</p><p>面向流的 <code>I/O</code> 一次处理一个字节数据，一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 <code>I/O</code> 通常相当慢。</p><p>面向块的 <code>I/O</code> 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 <code>I/O</code> 缺少一些面向流的 <code>I/O</code> 所具有的优雅性和简单性。</p><p><code>I/O</code> 包和 <code>NIO</code> 已经很好地集成了，<code>java.io.*</code> 已经以 <code>NIO</code> 为基础重新实现了，所以现在它可以利用 <code>NIO</code> 的一些特性。例如，<code>java.io.*</code> 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h2>九、一个完整 NIO 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuffer data = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">"hello world"</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>十、NIO和IO的主要区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>无</td><td>选择器</td></tr></tbody></table><ul><li>面向流与面向缓冲</li></ul><blockquote><p>Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p></blockquote><ul><li>阻塞与非阻塞IO</li></ul><blockquote><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p></blockquote><ul><li>选择器（Selectors）</li></ul><blockquote><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p></blockquote><h2>十一、总结</h2><ul><li><code>NIO</code>其实实现的是一个IO的多路复用，用<code>select</code>来同时监听多个<code>channel</code>，本质上还是同步阻塞的，需要<code>select</code>不断监听端口。但是对于IO各个通道来说就是可以看做是异步。</li><li>基本可以认为 “NIO = I/O多路复用 + 非阻塞式I/O”，大部分情况下是单线程，但也有超过一个线程实现NIO的情况</li><li>我们可以用打电话（同步）和发短信（异步）来很好的比喻同步与异步操作</li><li>阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。</li><li>非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。两种方式各有优劣。</li><li>传统IO中，<code>Stream</code>是单向的，比如<code>InputStream</code>只能进行读取操作，<code>OutputStream</code>只能进行写操作。而<code>Channel</code>是双向的，既可用来进行读操作，又可用来进行写操作。</li><li>在<code>NIO</code>中，读取的数据只能放在<code>Buffer</code>中。同样地，写入数据也是先写入到<code>Buffer</code>中。缓冲区有三个状态变量：<code>capacity</code>：最大容量；<code>position</code>：当前已经读写的字节数；<code>limit</code>：还可以读写的字节数。</li><li>Selector的作用就是用来轮询每个注册的Channel，一旦发现Channel有注册的事件发生，便获取事件然后进行处理.</li><li>NIO和IO的主要区别。</li><li>NIO适用场景</li></ul><blockquote><p>服务器需要支持超大量的长时间连接。比如10000个连接以上，并且每个客户端并不会频繁地发送太多数据。例如总公司的一个中心服务器需要收集全国便利店各个收银机的交易信息，只需要少量线程按需处理维护的大量长期连接。</p></blockquote><ul><li>BIO适用场景</li></ul><blockquote><p>适用于连接数目比较小，并且一次发送大量数据的场景，这种方式对服务器资源要求比较高，并发局限于应用中。</p></blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3916526.html" target="_blank" rel="noopener">Java NIO：浅析I/O模型</a></li><li><a href="https://blog.csdn.net/shimiso/article/details/24990499" target="_blank" rel="noopener">NIO与传统IO的区别</a></li><li><a href="https://troywu0.gitbooks.io/spark/content/java-io%E6%B5%81.html" target="_blank" rel="noopener">Java NIO：NIO概述</a></li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20IO" target="_blank" rel="noopener">Java I/O</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Socket基础</title>
      <link href="/2019/02/20/Socket%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/02/20/Socket%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>学习I/O几种常见模型以及select、poll、epoll三种多路复用的具体实现。</p><a id="more"></a><h2>一、I/O 模型</h2><p>一个输入操作，即我们常说的读取一个文件，通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。我们看到，这是一个比较麻烦的过程，可能是性能出现瓶颈的地方。</p><p><code>Unix</code> 下有五种 <code>I/O</code> 模型：</p><ul><li>阻塞式 <code>I/O</code></li><li>非阻塞式 <code>I/O</code></li><li><code>I/O</code> 复用（<code>select</code> 和 <code>poll</code>）</li><li>信号驱动式 <code>I/O</code>（<code>SIGIO</code>）</li><li>异步 <code>I/O</code>（<code>AIO</code>）</li></ul><h3>1.1 阻塞式 I/O</h3><p>应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p><p>下图中，<code>recvfrom</code> 用于接收 <code>Socket</code> 传来的数据，并复制到应用进程的缓冲区 <code>buf</code> 中。这里把 <code>recvfrom()</code> 当成系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br></pre></td></tr></table></figure><p><img src="http://xiaozhao.oursnail.cn/%E9%98%BB%E5%A1%9E%E5%BC%8FIO1.png" alt="image"></p><h3>1.2 非阻塞式 I/O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 <code>I/O</code> 是否完成，这种方式成为轮询（<code>polling</code>）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><p><img src="http://xiaozhao.oursnail.cn/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO1.png" alt="image"></p><h3>1.3 I/O 复用</h3><p>使用 <code>select</code> 或者 <code>poll</code> 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 <code>recvfrom</code> 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 <code>Event Driven I/O</code>，即事件驱动 I/O。</p><p>如果一个 <code>Web</code> 服务器没有 I/O 复用，那么每一个 <code>Socket</code> 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><p><img src="http://xiaozhao.oursnail.cn/IO%E5%A4%8D%E7%94%A81.png" alt="image"></p><h3>1.4 信号驱动 I/O</h3><p>应用进程使用 <code>sigaction</code> 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 <code>SIGIO</code> 信号，应用进程收到之后在信号处理程序中调用 <code>recvfrom</code> 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><p><img src="http://xiaozhao.oursnail.cn/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO1.png" alt="image"></p><h3>1.5 异步 I/O</h3><p>进行 <code>aio_read</code> 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E6%AD%A5IO1.png" alt="image"></p><h3>1.6 同步 I/O 与异步 I/O</h3><ul><li>同步 I/O：应用进程在调用 <code>recvfrom</code> 操作时会阻塞。</li><li>异步 I/O：不会阻塞。</li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，虽然非阻塞式 I/O 和信号驱动 I/O 在等待数据阶段不会阻塞，但是在之后的将数据从内核复制到应用进程这个操作会阻塞。</p><h3>1.7 五大 I/O 模型比较</h3><p>前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的：将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p><p><img src="http://xiaozhao.oursnail.cn/%E4%BA%94%E5%A4%A7IO%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%831.png" alt="image"></p><h2>二、select/poll/epoll</h2><p>这三个都是 I/O 多路复用的具体实现，<code>select</code> 出现的最早，之后是 <code>poll</code>，再是 <code>epoll</code>。</p><h3>2.1 select</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-1.png" alt="image"></p><p><code>fd_set</code> 表示描述符集合类型，有三个参数：<code>readset</code>、<code>writeset</code> 和 <code>exceptset</code>，分别对应读、写、异常条件的描述符集合。</p><p><code>timeout</code> 参数告知内核等待所指定描述符中的任何一个就绪可花多少时间；</p><p>成功调用返回结果大于 0；出错返回结果为 -1；超时返回结果为 0。</p><p>每次调用 <code>select</code> 都需要将 <code>fd_set \*readfds, fd_set \*writefds, fd_set \*exceptfds</code> 链表内容全部从应用进程缓冲复制到内核缓冲。</p><p>返回结果中内核并没有声明 <code>fd_set</code> 中哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程需要遍历所有的 <code>fd_set</code>。</p><p><code>select</code> 最多支持 1024 个描述符，其中 1024 由内核的 <code>FD_SETSIZE</code> 决定。如果需要打破该限制可以修改 <code>FD_SETSIZE</code>，然后重新编译内核。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-2.png" alt="image"></p><h3>2.2 poll</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-3.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic12-4.png" alt="image"></p><p>它和 <code>select</code> 功能基本相同。同样需要每次将描述符从应用进程复制到内核，<code>poll</code> 调用返回后同样需要进行轮询才能知道哪些描述符已经准备好。</p><p><code>poll</code> 取消了 1024 个描述符数量上限，但是数量太大以后不能保证执行效率，因为复制大量内存到内核十分低效，所需时间与描述符数量成正比。</p><p><code>poll</code> 在描述符的重复利用上比 <code>select</code> 的 <code>fd_set</code> 会更好。</p><p>如果在多线程下，如果一个线程对某个描述符调用了 <code>poll</code> 系统调用，但是另一个线程关闭了该描述符，会导致 <code>poll</code> 调用结果不确定，该问题同样出现在 <code>select</code> 中。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-5.png" alt="image"></p><h3>2.3 epoll</h3><p><img src="http://bloghello.oursnail.cn/javabasic12-6.png" alt="image"></p><p><code>epoll</code> 仅仅适用于 <code>Linux OS</code>。</p><p>它是 <code>select</code> 和 <code>poll</code> 的增强版，更加灵活而且没有描述符数量限制。</p><p>它将用户关心的描述符放到内核的一个事件表中，从而只需要在用户空间和内核空间拷贝一次。</p><p><code>select</code> 和 <code>poll</code> 方式中，进程只有在调用一定的方法后，内核才对所有监视的描述符进行扫描。而 <code>epoll</code> 事先通过 <code>epoll_ctl()</code> 来注册描述符，一旦基于某个描述符就绪时，内核会采用类似 <code>callback</code> 的回调机制，迅速激活这个描述符，当进程调用 <code>epoll_wait()</code> 时便得到通知。</p><p>新版本的 <code>epoll_create(int size)</code> 参数 <code>size</code> 不起任何作用，在旧版本的 <code>epoll</code> 中如果描述符的数量大于 <code>size</code>，不保证服务质量。</p><p><code>epoll_ctl()</code> 执行一次系统调用，用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理。</p><p><code>epoll_wait()</code> 取出在内核中通过链表维护的 I/O 准备好的描述符，将他们从内核复制到应用进程中，不需要像 <code>select/poll</code> 对注册的所有描述符遍历一遍。</p><p><code>epoll</code> 对多线程编程更有友好，同时多个线程对同一个描述符调用了 <code>epoll_wait()</code> 也不会产生像 <code>select/poll</code> 的不确定情况。或者一个线程调用了 <code>epoll_wait</code> 另一个线程关闭了同一个描述符也不会产生不确定情况。</p><p><img src="http://bloghello.oursnail.cn/javabasic12-7.png" alt="image"></p><h2>三、select 和 poll 比较</h2><h3>3.1 功能</h3><p>它们提供了几乎相同的功能，但是在一些细节上有所不同：</p><ul><li><code>select</code> 会修改 <code>fd_set</code> 参数，而 <code>poll</code> 不会；</li><li><code>select</code> 默认只能监听 1024 个描述符，如果要监听更多的话，需要修改 <code>FD_SETSIZE</code> 之后重新编译；</li><li><code>poll</code> 提供了更多的事件类型。</li></ul><h3>3.2 速度</h3><p><code>poll</code> 和 <code>select</code> 在速度上都很慢。</p><ul><li>它们都采取轮询的方式来找到 I/O 完成的描述符，如果描述符很多，那么速度就会很慢；</li><li><code>select</code> 只使用每个描述符的 3 位，而 poll 通常需要使用 64 位，因此 <code>poll</code> 需要复制更多的内核空间。</li></ul><h3>3.3 可移植性</h3><p>几乎所有的系统都支持 <code>select</code>，但是只有比较新的系统支持 <code>poll</code>。</p><h2>四、eopll 工作模式</h2><p><code>epoll_event</code> 有两种触发模式：<code>LT</code>（<code>level trigger</code>）和 <code>ET</code>（<code>edge trigger</code>）。</p><h3>4.1 LT 模式</h3><p>当 <code>epoll_wait()</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 <code>epoll_wait()</code> 时，会再次响应应用程序并通知此事件。是默认的一种模式，并且同时支持 <code>Blocking</code> 和 <code>No-Blocking</code>。</p><h3>4.2 ET 模式</h3><p>当 <code>epoll_wait()</code> 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 <code>epoll_wait()</code> 时，不会再次响应应用程序并通知此事件。很大程度上减少了 <code>epoll</code> 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 <code>No-Blocking</code>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h2>五、select poll epoll 应用场景</h2><p>很容易产生一种错觉认为只要用 <code>epoll</code> 就可以了，<code>select poll</code> 都是历史遗留问题，并没有什么应用场景，其实并不是这样的。</p><h3>5.1 select 应用场景</h3><p><code>select() poll() epoll_wait()</code> 都有一个 <code>timeout</code>参数，在 <code>select()</code> 中 <code>timeout</code> 的精确度为 1ns，而 <code>poll()</code> 和 <code>epoll_wait()</code> 中则为 1ms。所以 <code>select</code> 更加适用于实时要求更高的场景，比如核反应堆的控制。</p><p><code>select</code> 历史更加悠久，它的可移植性更好，几乎被所有主流平台所支持。</p><h3>5.2 poll 应用场景</h3><p><code>poll</code> 没有最大描述符数量的限制，如果平台支持应该采用 <code>poll</code> 且对实时性要求并不是十分严格，而不是 <code>select</code>。</p><p>需要同时监控小于 1000 个描述符。那么也没有必要使用 <code>epoll</code>，因为这个应用场景下并不能体现 <code>epoll</code> 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的。因为 <code>epoll</code> 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 <code>epoll_ctl()</code> 进行系统调用，频繁系统调用降低效率。<code>epoll</code> 的描述符存储在内核，不容易调试。</p><h3>5.3 epoll 应用场景</h3><p>程序只需要运行在 <code>Linux</code> 平台上，有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p><h2>六、对比</h2><p>举例说明：老师收学生作业，相当于应用层调用I/O操作。</p><p>1、老师逐个收学生作业，学生没有做完，只能阻塞等待，收了之后，再去收下一个学生的作业。这显然存在性能问题。</p><p>2、怎么解决上面的问题？<br>老师找个班长，班长负责收作业，班长的做法是：遍历问学生作业写好了吗，写好的，收起来交给老师。休息一会，再去遍历。。。<br>这个班长就是<code>select</code>。</p><blockquote><p>存在问题</p></blockquote><ul><li>这个班长还有一个能力问题，最多只能管理1024个学生。</li><li>很多学生的作业没有写好，而且短时间写不好，班长还是不停地遍历去问，影响效率。</li></ul><blockquote><p>怎么解决问题1班长的能力问题？</p></blockquote><ul><li>换一个能力更强的班长，可以管理更多的学生，这个班长就是<code>poll</code>。</li></ul><blockquote><p>怎么解决问题1、2，存在的能力问题和效率问题？</p></blockquote><ul><li>换一个能力超级强的班长，可以管理无限多的学生，同时班长的做法是：遍历一次所有的学生，如果作业没有写完，告诉学生写好之后，放在一个固定的地方。这样的话，班长只需要定期到这个地方取作业就好了。这就是<code>epoll</code>。</li></ul><p>参考：</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Socket.md" target="_blank" rel="noopener">socket</a></li><li><a href="https://www.cnblogs.com/java2016/p/5538018.html" target="_blank" rel="noopener">理解 select poll epoll</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础之泛型下</title>
      <link href="/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8B/"/>
      <url>/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8B/</url>
      <content type="html"><![CDATA[<p>本节继续讨论泛型相关的知识。</p><a id="more"></a><h2>6、泛型上下边界</h2><p>我们再来讨论讨论通配符。</p><p>通配符有2种：</p><ul><li>无边界通配符，用<code>&lt;?&gt;</code>表示。</li><li>有边界通配符，用<code>&lt;? extends Object&gt;</code>或者<code>&lt;? super Object&gt;</code>来表示。（<code>Object</code>仅仅是一个示例）</li></ul><h5>6.1 无边界</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 合法</span></span><br><span class="line">List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;?&gt;(); <span class="comment">// 不合法</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;?&gt;(); <span class="comment">// 不合法</span></span><br></pre></td></tr></table></figure><p>对于带有通配符的引用变量，是不能调用具有与泛型参数有关的方法的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(1); // 编译不通过</span><br><span class="line">list.get(0); // 编译通过</span><br><span class="line">int size = list.size(); // 由于size()方法中不含泛型参数，所以可以在通配符变量中调用</span><br></pre></td></tr></table></figure><p>总结起来，无边界通配符主要用做引用，可以调用与泛型参数无关的方法，不能调用参数中包含泛型参数的方法。</p><h5>6.2 有边界</h5><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><ul><li>上边界通配，用&lt;? extends 类型&gt;表示。其语法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends 类型<span class="number">1</span>&gt; x = <span class="keyword">new</span> ArrayList&lt;类型<span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure><p>其中，类型2就只能是类型1或者是类型1的子类。下面代码验证合法性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; x = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//由于Integer是Number的子类，这是合法的</span></span><br><span class="line">List&lt;? extends Number&gt; x = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//由于String不是Number的子类，这是不合法的</span></span><br></pre></td></tr></table></figure><ul><li>下边界通配，用&lt;? super 类型&gt;表示。其语法为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> 类型<span class="number">1</span>&gt; x = <span class="keyword">new</span> ArrayList&lt;类型<span class="number">2</span>&gt;();</span><br></pre></td></tr></table></figure><p>其中，类型2就只能是类型1或者是类型1的超类。下面代码有验证合法性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> ArrayList&lt;Number&gt;(); <span class="comment">//由于Number是Integer的超类，这是合法的</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//由于String不是Integer的超类，这是不合法的</span></span><br></pre></td></tr></table></figure><p>那么到底什么时候使用下边界通配，什么时候使用上边界通配呢？首先考虑一下怎样才能保证不会发生运行时异常，这是泛型要解决的首要问题，通过前面的内容可以看到，任何可能导致类型转换异常的操作都无法编译通过。</p><ul><li>⭐上边界通配：可以保证存放的实际对象至多是上边界指定的类型，那么在读取对象时，我们总是可以放心地将对象赋予上边界类型的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">List&lt;? extends Number&gt; list2 = list1;</span><br><span class="line">Number a = list2.get(<span class="number">0</span>); <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><ul><li>⭐下边界通配：可以保证存放的实际对象至少是下边界指定的类型，那么在存入对象时，我们总是可以放心地将下边界类型的对象存入泛型对象中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list3.add(<span class="number">1</span>);</span><br><span class="line">list3.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p></blockquote><ul><li>如果你想从一个数据类型里获取数据，使用 ? extends 通配符。</li><li>如果你想把对象写入一个数据结构里，使用 ? super 通配符。</li><li>如果你既想存，又想取，那就别用通配符。</li></ul><p>对于泛型方法添加上下边界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>7、泛型的原理</h2><h5>7.1 类型擦除</h5><p><font color="#ff0000">Java中的泛型是通过类型擦除来实现的</font>。<strong>所谓类型擦除，是指通过类型参数合并，将泛型类型实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。</strong></p><p>下面通过两个例子来证明在编译时确实发生了类型擦除。</p><p>例1分别创建实际类型为<code>String</code>和<code>Integer</code>的<code>ArrayList</code>对象，通过<code>getClass()</code>方法获取两个实例的类，最后判断这个实例的类是相等的，证明两个实例共享同一个类。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-1.png" alt="image"></p><p>例2创建一个只能存储<code>Integer</code>的<code>ArrayList</code>对象，在<code>add</code>一个整型数值后，利用反射调用<code>add(Object o)</code> <code>add</code>一个<code>asd</code>字符串，此时运行代码不会报错，运行结果会打印出1和asd两个值。这时再里利用反射调用<code>add(Integer o)</code>方法，运行会抛出<code>codeNoSuchMethodException</code>异常。这充分证明了在编译后，擦除了<code>Integer</code>这个泛型信息，只保留了原始类型。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-2.png" alt="image"></p><h5>7.2 自动类型转换</h5><p>上一节上说到了类型擦除，Java编译器会擦除掉泛型信息。那么调用<code>ArrayList</code>的<code>get()</code>最终返回的必然会是一个<code>Object</code>对象，但是我们在源代码并没有写过<code>Object</code>转成<code>Integer</code>的代码，为什么就能“直接”将取出来的对象赋予一个<code>Integer</code>类型的变量呢（如下面的代码第12行）？</p><p><img src="http://bloghello.oursnail.cn/javabasic11-3.png" alt="image"></p><p><font color="#ff0000">实际上，Java的泛型除了类型擦除之外，还会自动生成<code>checkcast</code>指令进行强制类型转换</font>。上面的代码中的main方法编译后所对应的字节码如下。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-4.png" alt="image"></p><p>看到第26行代码就是将<code>Object</code>类型的对象强制转换为<code>Integer</code>的指令。我们完全可以将上面的代码转换为下面的代码，它所实现的效果跟上面的泛型是一模一样的。既然泛型也需要进行强制转换，所以泛型并不会提供运行时效率，不过可以大大降低编程时的出错概率。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-5.png" alt="image"></p><h2>8、简单总结</h2><h3>8.1 类型擦除(Type Erasure)</h3><ul><li>Java 的泛型是在编译器层次实现的。</li><li>在编译生成的字节码中不包含泛型中的类型参数，类型参数会在编译时去掉。</li><li>例如：<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在编译后都变成 <code>List</code>。</li><li>类型擦除的基本过程：将代码中的类型参数替换为具体的类，同时去掉 <code>&lt;&gt;</code> 的内容。</li></ul><h3>8.2 泛型的优势</h3><ul><li>编译时更强大的类型检测。</li></ul><p>例如如下代码：方法传入一个<code>String</code>对象，传出一个<code>String</code> 对象，并强制转换为<code>Integer</code>对象。这段代码编译可以通过，因为都是<code>Object</code>的子类，但是运行时会产生<code>ClassCastException</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-6.png" alt="image"></p><p>而如果通过泛型来实现，则会在编译时进行类型的检测。例如如下代码：会产生编译错误。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-7.png" alt="image"></p><ul><li>提供自动和隐式的类型转换</li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-8.png" alt="image"></p><h3>8.3 <code>&lt;T&gt;</code> VS <code>&lt;?&gt;</code></h3><p>不同点：</p><ul><li><code>&lt;T&gt;</code>用于泛型的定义，例如<code>class MyGeneric&lt;T&gt; {...}</code></li><li><code>&lt;?&gt;</code>用于泛型的声明，即泛型的使用，例如<code>MyGeneric&lt;?&gt; g = new MyGeneric&lt;&gt;()</code>;</li></ul><p>相同点：都可以指定上界和下界:</p><p><img src="http://bloghello.oursnail.cn/javabasic11-9.png" alt="image"></p><h3>8.4 <code>&lt;?&gt;</code>不同于<code>&lt;Object&gt;</code></h3><ul><li>指定未知类型，如<code>List&lt;?&gt;</code>。<code>List&lt;?&gt;</code>不等于<code>List&lt;Object&gt;</code></li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-10.png" alt="image"></p><p><code>String</code>是<code>Object</code>的子类，但是<code>List&lt;String&gt;</code>不是<code>List&lt;Object&gt;</code>的子类。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-11.png" alt="image"></p><p>如果将<code>List&lt;Object&gt;</code>换成<code>List&lt;?&gt;</code>，则可以编译通过。</p><p>注意：</p><ul><li>相同参数类型的泛型类的继承关系取决于泛型类自身的继承结构。<br>例如<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code>的子类</li><li>当类型声明中使用通配符<code>?</code>时，其子类型可以在两个维度上扩展。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如 Collection&lt;? extends Number&gt;</span><br><span class="line">在维度<span class="number">1</span>上扩展：List&lt;? extends Number&gt;</span><br><span class="line">在维度<span class="number">2</span>上扩展：Collection&lt;Integer&gt;</span><br></pre></td></tr></table></figure><h2>9、Java泛型中<code>List</code>、<code>List&lt;Object&gt;</code>、<code>List&lt;?&gt;</code>的区别</h2><ul><li><code>List</code>：原生态类型</li><li><code>List&lt;Object&gt;</code>：参数化的类型，表明<code>List</code>中可以<strong>容纳任意类型的对象</strong></li><li><code>List&lt;?&gt;</code>：无限定通配符类型，表示<strong>只能包含某一种未知对象类型</strong></li></ul><p><img src="http://bloghello.oursnail.cn/javabasic11-12.png" alt="image"></p><p>我们创建了一个<code>List&lt;String&gt;</code>类型的对象<code>strings</code>，再把它赋给原生态类型<code>List</code>，这是可以的。但是第5行中尝试把它传递给<code>List&lt;Object&gt;</code>时，出现了一个类型不相容错误，注意，这是一个编译期错误。</p><p>这是因为泛型有子类型化的规则：</p><p><code>List&lt;String&gt;</code>是原生态类型<code>List</code>的一个子类型。虽然<code>String</code>是<code>Object</code>的子类型，但是由于泛型是不可协变的，<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类型，所以这里的传递无法通过编译。</p><p><code>List&lt;Object&gt;</code>唯一特殊的地方只是<code>Object</code>是所有类型的超类，由于泛型的不可协变性，它只能表示<code>List</code>中可以容纳所有类型的对象，却不能表示任何参数类型的<code>List&lt;E&gt;</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic11-13.png" alt="image"></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">sss</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>List&lt;Object&gt;</code>:表示可用装载任意类型的对象，如上面最后一个例子，但是他不能接受<code>List&lt;String&gt;</code>的替换，因为不具有继承性，并且<code>List&lt;Object&gt;</code>如果可以被<code>List&lt;String&gt;</code>，就不符合原则了，因为<code>List&lt;String&gt;</code>只能接受String类型的对象。</li><li><code>List&lt;?&gt;</code>:解决上面表面有继承关系的List的赋值问题，还有就是，他是用作声明能接收一种未知对象类型，而不是大杂烩啥都能接收。</li><li><code>List</code>：原始类型，啥都没有限制。个人认为与<code>List&lt;Object&gt;</code>类似，但是又没有继承的限制。即啥类型都可以接收。</li></ul><h2>10、参考</h2><ul><li><a href="http://hinylover.space/2016/06/25/relearn-java-generic-1/" target="_blank" rel="noopener">http://hinylover.space/2016/06/25/relearn-java-generic-1/</a></li><li><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">java 泛型详解</a></li><li><a href="https://www.cnblogs.com/rese-t/p/8158870.html" target="_blank" rel="noopener">https://www.cnblogs.com/rese-t/p/8158870.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础之泛型上</title>
      <link href="/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8A/"/>
      <url>/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8A/</url>
      <content type="html"><![CDATA[<p>本篇文章全面介绍Java泛型中的基础及原理。本节主要介绍什么是泛型、泛型的核心特性、泛型与继承注意点、泛型与多态的原理以及泛型的使用。</p><a id="more"></a><h2>1、什么是泛型以及为什么用泛型</h2><p>直接上例子进行说明：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-1.png" alt="image"></p><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>为什么会出现这种问题呢？</p><ul><li>集合本身无法对其存放的对象类型进行限定，可以涵盖Java中的所有类型。缺口太大，导致各种蛇、蚁、虫、鼠通通都可以进来。</li></ul><ul><li>由于我们要使用的实际存放类型的方法，所以不可避免地要进行类型转换。小对象转大对象很容易，大对象转小对象则有很大的风险，因为在编译时，我们无从得知对象真正的类型。</li></ul><p>泛型就是为了解决这类问题而诞生的。</p><h2>2、泛型的特性</h2><h5>2.1 泛型只在编译阶段有效</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-2.png" alt="image"></p><p>输出结果：类型相同</p><blockquote><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。<font color="#ff0000"><strong>也就是说Java中的泛型，只在编译阶段有效</strong>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</font></p></blockquote><p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p><h5>2.2 泛型的兼容性</h5><p>Java编译器是向后兼容的，也就是低版本的源代码可以用高版本编译器进行编译。下面来看看那些兼容性代码。</p><blockquote><ol><li>引用和实例化都不包含泛型信息。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-3.png" alt="image"></p><p>上面的这段代码是可以通过编译的，这是JDK1.4之前的写法，所以可以验证JDK1.5之后的编译器是可以兼容JDK1.4之前的源代码的。不过，笔者在JDK1.8.x版本的编译器进行编译时，会抛出如下所示的警告信息。很显然，如果类被定义成泛型类，但是在实际使用时不使用泛型特性，这是不推荐的做法！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注: Compatibility.java使用了未经检查或不安全的操作。</span><br><span class="line">注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>引用使用泛型，实例化不使用泛型。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-4.png" alt="image"></p><p>上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的代码编译不通过，由于对引用使用了泛型，其中的所能容纳的对象必须为String 类型。这种写法实际上跟完整写法的作用一致，不过Eclipse仍然会警告。</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>引用不使用泛型，实例化使用泛型。</li></ol></blockquote><p><img src="http://bloghello.oursnail.cn/javabasic10-5.png" alt="image"></p><p>上面的这段代码可以编译通过，其效果与1（不使用泛型）完全一致。结合2、3可以知道，编译时只能做引用的类型检查，而无法检查引用所指向对象的实际类型。</p><h2>3、泛型与继承</h2><p>在使用泛型时，引用的参数类型与实际对象的参数类型要保持一致（通配符除外），就算两个参数类型是继承关系也是不允许的。看看下面的2行代码，它们均不能通过编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;(); <span class="comment">//编译错误  </span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>下面来探讨一下为什么不能这么做。</p><ul><li>第1种情况，如果这种代码可以通过编译，那么调用<code>get()</code>方法返回的对象应该是<code>String</code>，但它实际上可以存放任意<code>Object</code>类型的对象，这样在调用类型转换指令时会抛出<code>ClassCastException</code>。</li><li>第2种情况。虽然<code>String</code>类型的对象转换为<code>Object</code>不会有任何问题，但是这有什么意义呢？我们原本想要用<code>String</code>对象的方法，但最终将其赋予了一个<code>Object</code>类型的引用。如果需要使用<code>String</code>中的某些方法，必须将<code>Object</code>强制转换为<code>String</code>。这样不会抛出异常，但是却违背了泛型设计的初衷。</li></ul><h2>4、泛型与多态</h2><p>下面来考虑一下泛型中多态问题。普通类型的多态是通过继承并重写父类的方法来实现的，泛型也不例外，下面是一个泛型多态示例。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic10-7.png" alt="image"></p><p>上面定义了一个泛型父类和一个实际参数为<code>String</code>类型的子类，并“重写”了<code>set(T)</code>和<code>get()</code>方法。<code>Son</code>类中的<code>@Override</code>注解也清楚地显示这是一个重写方法，最终执行的结果如下，与想象中的结果完全一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am father, t=hello world</span><br><span class="line">I am son.</span><br></pre></td></tr></table></figure><p>真的这么简单么？虽然表面上（源代码层面）来看，泛型多态与普通类的多态并无二样，但是其内部的实时原理却大相径庭。</p><p>泛型类<code>Father</code>在编译后会擦除泛型信息，所有的泛型参数都会用<code>Object</code>类替代。实际上，<code>Father</code>编译后的字节码与下面的代码完全一致。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-8.png" alt="image"></p><p><code>Son</code>类的与最终会变为：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-9.png" alt="image"></p><p><code>Father</code>和<code>Son</code>类的<code>set()</code>方法的参数类型不一样，所以，这并不是方法重写，而是方法重载！但是，如果是重载，那么<code>Son</code>类就应该会继承<code>Father</code>类的<code>set(Object)</code>方法，也就是<code>Son</code>会同时包含<code>set(String)</code>和<code>set(Object)</code>，下面来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son son = <span class="keyword">new</span> Son();</span><br><span class="line">son.set(<span class="string">"test"</span>);</span><br><span class="line">son.set(<span class="keyword">new</span> Object()); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>当<code>set</code>一个<code>Object</code>对象时，编译无法通过。这就很奇怪了，感觉跟之前学到的知识是相悖的。我们原本想通过重写方法来实现多态，但由于泛型的类型擦除，却最终变成了重载，所以类型擦除与多态有了矛盾。那么Java是怎么解决这个问题的呢？还是从字节码中找答案吧。<code>Son</code>类最终的编译结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.String)</span></span>;         <span class="comment">// 我们重写的方法</span></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">get</span><span class="params">()</span></span>;              <span class="comment">// 我们重写的方法</span></span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">get</span><span class="params">()</span></span>;              <span class="comment">// 编译器生成的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(java.lang.Object)</span></span>;          <span class="comment">// 编译器生成的方法</span></span><br><span class="line">    ...</span><br><span class="line">    2: checkcast     #39                 // class java/lang/String</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><font color="#ff0000">⭐这里面多了一个<code>Object get()</code>方法和<code>set(Object)</code>方法，这两个方法在<code>Son</code>类源代码里面并不存在，这是编译器为了解决泛型的多态问题而自动生成的方法，称为“桥方法”。这两个方法的签名与<code>Father</code>类中的两个方法的签名完全一致，这才是真正的方法重写。也就是说，子类真正重写的我们看不到的桥方法，啊，多么痛的领悟！！！<code>@Override</code>注解只是假象，让人误以为他们真的是重写方法。</font></p><p>再看看<code>set(Object)</code>桥方法的实现细节，先将<code>Object</code>对象强制转换为<code>String</code>对象，然后调用<code>Son</code>中的<code>set(String)</code>方法。饶了一个圈，最终才回到我们“重写”的方法。<code>main</code>方法中原本调用父类的<code>set(Object)</code>方法，由于子类通过桥方法重写了这个方法，所以最终的调用顺序是：<code>set(Object)</code> -&gt; <code>set(String)</code>。</p><p>与<code>set(Object)</code>桥方法的意义不同，<code>Object get()</code>并不仅仅解决泛型与重写的冲突，而更具有一般性。看看下面的代码，这是一个普通类的继承:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralFather</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralSon</span> <span class="keyword">extends</span> <span class="title">GeneralFather</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的返回类型是父类的返回类型的子类，这是允许的，这种特性叫做Java返回值的协变性。而协变性的实现方法就是上面所述的桥方法。</p><p>这里还会有疑惑，<code>set</code>方法可以通过参数类型来确定调用的方法。但是，参数一样而返回值不一样是不能重载的。如果我们在源代码中通过编写<code>String get()</code>和<code>Object get()</code>方法是无法通过编译的。虽然，编译器无法通过编译，但是JVM是可以编写这两种方法的，它调用方法时，将返回值也作为方法签名的一部分。有种只许州官放火，不许百姓点灯的感觉。可以看到，JVM做了不少我们认为不合法的事情，所以如果不深入研究底层原理，有些问题根本解释不了。</p><h2>5、泛型的使用</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法.</p><h5>5.1 泛型类</h5><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：<code>List</code>、<code>Set</code>、<code>Map</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-10.png" alt="image"></p><p>下面进行实例化：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-11.png" alt="image"></p><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12-27 09:20:04.432 13063-13063/? D/泛型测试: key is 123456</span><br><span class="line">12-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-12.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D/泛型测试: key is 111111</span><br><span class="line">D/泛型测试: key is 4444</span><br><span class="line">D/泛型测试: key is 55.55</span><br><span class="line">D/泛型测试: key is false</span><br></pre></td></tr></table></figure><h5>5.2 泛型接口</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-13.png" alt="image"></p><p>当实现泛型接口的类，未传入泛型实参时：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-14.png" alt="image"></p><p>当实现泛型接口的类，传入泛型实参时：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-15.png" alt="image"></p><h5>5.3 泛型通配符</h5><p><font color="#ff0000">我们知道<code>Ingeter</code>是<code>Number</code>的一个子类，同时我们也验证过<code>Generic&lt;Ingeter&gt;</code>与<code>Generic&lt;Number&gt;</code>实际上是相同的一种基本类型。那么问题来了，在使用<code>Generic&lt;Number&gt;</code>作为形参的方法中，能否使用<code>Generic&lt;Ingeter&gt;</code>的实例传入呢？在逻辑上类似于<code>Generic&lt;Number&gt;</code>和<code>Generic&lt;Ingeter&gt;</code>是否可以看成具有父子关系的泛型类型呢？</font></p><p>为了弄清楚这个问题，我们使用<code>Generic&lt;T&gt;</code>这个泛型类继续看下面的例子：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-16.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/javabasic10-17.png" alt="image"></p><p>通过提示信息我们可以看到<code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。由此可以看出:<font color="#ff0000"><strong>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</strong></font>。</p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理<code>Generic&lt;Integer&gt;</code>类型的类，这显然与java中的多态理念相违背。因此我们需要一个在逻辑上可以表示同时是<code>Generic&lt;Integer&gt;</code>和<code>Generic&lt;Number&gt;</code>父类的引用类型。由此类型通配符应运而生。</p><p>我们可以将上面的方法改一下：</p><p><img src="http://bloghello.oursnail.cn/javabasic10-18.png" alt="image"></p><p>类型通配符一般是使用<code>'?'</code>代替具体的类型实参，注意，<font color="#ff0000"><strong>此处’?'是类型实参，而不是类型形参</strong></font> 。重要说三遍！此处<code>'?'</code>是类型实参，而不是类型形参 ！ 此处<code>'?'</code>是类型实参，而不是类型形参 ！再直白点的意思就是，此处的<code>'?'</code>和<code>Number</code>、<code>String</code>、<code>Integer</code>一样都是一种实际的类型，可以把<code>'?'</code>看成所有类型的父类。是一种真实的类型。</p><p>可以解决当具体类型不确定的时候，这个通配符就是<code>'?'</code>；当操作类型时，不需要使用类型的具体功能时，只使用<code>Object</code>类中的功能。那么可以用<code>'?'</code>通配符来表示未知类型。</p><h5>5.4 泛型方法</h5><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p><p><img src="http://bloghello.oursnail.cn/javabasic10-19.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));</span><br></pre></td></tr></table></figure><p>再对泛型方法进行一个比较，加深理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = key；</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//必须要声明E才行</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">setKey</span><span class="params">(E key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = (T)key;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">    <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>5.5 泛型方法与可变参数</h5><p><img src="http://bloghello.oursnail.cn/javabasic10-20.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure><h5>5.6 静态方法与泛型</h5><p><strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</strong></p><p><img src="http://bloghello.oursnail.cn/javabasic10-21.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础之克隆</title>
      <link href="/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%8B%E9%9A%86/"/>
      <url>/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%8B%E9%9A%86/</url>
      <content type="html"><![CDATA[<p>面试的时候可能会问到克隆相关的深拷贝和浅拷贝，至少我是被问过的，所以对它们的了解是必要的，本篇文章探讨Java克隆方面的知识。</p><a id="more"></a><h2>1. Java中对象创建的两种方式</h2><p><code>clone</code>顾名思义就是复制， 在<code>Java</code>语言中， <code>clone</code>方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象。那么在<code>java</code>语言中，有几种方式可以创建对象呢？</p><ul><li>使用new操作符创建一个对象</li><li>使用clone方法复制一个对象</li></ul><p>那么这两种方式有什么相同和不同呢？ <code>new</code>操作符的本意是分配内存。程序执行到<code>new</code>操作符时， 首先去看<code>new</code>操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</p><p>而<code>clone</code>在第一步是和<code>new</code>相似的， 都是分配内存，调用<code>clone</code>方法时，分配的内存和源对象（即调用<code>clone</code>方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，<code>clone</code>方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</p><h2>2. 复制对象 or 复制引用</h2><p>在Java中，以下类似的代码非常常见：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-1.png" alt="image"></p><p>当<code>Person p1 = p;</code>执行之后， 是创建了一个新的对象吗？ 首先看打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br></pre></td></tr></table></figure><p>可已看出，打印的地址值是相同的，既然地址都是相同的，那么肯定是同一个对象。p和p1只是引用而已，他们都指向了一个相同的对象<code>Person(23, &quot;zhang&quot;)</code> 。 可以把这种现象叫做引用的复制。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%95%E7%94%A8%E5%A4%8D%E5%88%B6.png" alt="image"></p><p>而下面的代码是真真正正的克隆了一个对象。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-2.png" alt="image"></p><p>从打印结果可以看出，两个对象的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.pansoft.zhangjg.testclone.Person@2f9ee1ac</span><br><span class="line">com.pansoft.zhangjg.testclone.Person@67f1fba0</span><br></pre></td></tr></table></figure><p>以上代码执行完成后， 内存中的情景如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1.png" alt="image"></p><h2>3. 深拷贝 or 浅拷贝</h2><p><img src="http://bloghello.oursnail.cn/javabasic9-3.png" alt="image"></p><ul><li><p><code>age</code>是基本数据类型，那么对它的拷贝没有什么疑议，直接将一个4字节的整数值拷贝过来就行。</p></li><li><p><code>name</code>是<code>String</code>类型的， 它只是一个引用， 指向一个真正的<code>String</code>对象，那么对它的拷贝有两种方式：</p><ul><li>直接将源对象中的<code>name</code>的引用值拷贝给新对象的<code>name</code>字段</li><li>或者是根据原<code>Person</code>对象中的<code>name</code>指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给新拷贝的<code>Person</code>对象的<code>name</code>字段。</li></ul></li><li><p>这两种拷贝方式分别叫做浅拷贝和深拷贝。深拷贝和浅拷贝的原理如下图所示：</p></li></ul><p><img src="http://xiaozhao.oursnail.cn/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="image"></p><p>下面通过代码进行验证。如果两个<code>Person</code>对象的<code>name</code>的地址值相同， 说明两个对象的<code>name</code>都指向同一个<code>String</code>对象， 也就是浅拷贝， 而如果两个对象的<code>name</code>的地址值不同， 那么就说明指向不同的<code>String</code>对象， 也就是在拷贝<code>Person</code>对象的时候， 同时拷贝了<code>name</code>引用的<code>String</code>对象， 也就是深拷贝。验证代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-4.png" alt="image"></p><p>覆盖<code>Object</code>中的<code>clone</code>方法， 实现深拷贝.假设<code>body</code>类里面组合了<code>head</code>类。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-5.png" alt="image"></p><p><code>Body</code>中组合了<code>Head</code>，重写了<code>Body</code>的<code>clone</code>方法，那么显然第一个输出为<code>false</code>；但是没有对<code>Head</code>进行重写<code>clone</code>方法，那么他们指向的是同一个内存空间。即，没有重写<code>clone的Head</code>类只是浅拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : <span class="keyword">false</span></span><br><span class="line">body.head == body1.head : <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>如果要使<code>Body</code>对象在<code>clone</code>时进行深拷贝， 那么就要在<code>Body</code>的<code>clone</code>方法中，将源对象引用的<code>Head</code>对象也<code>clone</code>一份。</p><p><img src="http://bloghello.oursnail.cn/javabasic9-6.png" alt="image"></p><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br></pre></td></tr></table></figure><p>由此，我们得到一个结论：如果想要深拷贝一个对象， 这个对象必须要实现<code>Cloneable</code>接口，实现<code>clone</code>方法，并且在<code>clone</code>方法内部，把该对象引用的其他对象也要<code>clone</code>一份 ， 这就要求这个被引用的对象必须也要实现<code>Cloneable</code>接口并且实现<code>clone</code>方法。</p><p>那么，按照上面的结论， <code>Body</code>类组合了<code>Head</code>类， 而<code>Head</code>类组合了<code>Face</code>类，要想深拷贝<code>Body</code>类，必须在<code>Body</code>类的<code>clone</code>方法中将<code>Head</code>类也要拷贝一份，但是在拷贝<code>Head</code>类时，默认执行的是浅拷贝，也就是说<code>Head</code>中组合的<code>Face</code>对象并不会被拷贝。验证代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-7.png" alt="image"></p><p>输出结果符合预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br><span class="line">body.head.face == body1.head.face : true</span><br></pre></td></tr></table></figure><p>内存结构图如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A12.png" alt="image"></p><p>那么此时<code>Head</code>中组合的<code>Face</code>又是一个浅拷贝。那么到底如何实现彻底的深拷贝呢？</p><p>对于上面的例子来说，怎样才能保证两个<code>Body</code>对象完全独立呢？只要在拷贝<code>Head</code>对象的时候，也将<code>Face</code>对象拷贝一份就可以了。这需要让<code>Face</code>类也实现<code>Cloneable</code>接口，实现<code>clone</code>方法，并且在在<code>Head</code>对象的<code>clone</code>方法中，拷贝它所引用的<code>Face</code>对象。修改的部分代码如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-8.png" alt="image"></p><p>再次运行上面的示例，得到的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body == body1 : false</span><br><span class="line">body.head == body1.head : false</span><br><span class="line">body.head.face == body1.head.face : false</span><br></pre></td></tr></table></figure><p>这说名两个<code>Body</code>已经完全独立了，他们间接引用的<code>face</code>对象已经被拷贝，也就是引用了独立的<code>Face</code>对象。内存结构图如下：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A13.png" alt="image"></p><p>显然，对于复杂的对象而言，用这种方式实现深拷贝是十分困难的。这时我们可以用序列化的方式来实现对象的深克隆。</p><h2>4. 序列化解决多层克隆问题</h2><p>首先由一个外部类<code>Outer</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-9.png" alt="image"></p><p>再来一个被序列化的类<code>Inner</code>:</p><p><img src="http://bloghello.oursnail.cn/javabasic9-10.png" alt="image"></p><p>再对克隆的对象进行测试：</p><p><img src="http://bloghello.oursnail.cn/javabasic9-11.png" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">outer的name值为：outer</span><br><span class="line">Inner的name值为：inner</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">Java提高篇——对象克隆（复制）</a></li><li><a href="https://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="noopener">详解Java中的clone方法 – 原型模式</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础之异常</title>
      <link href="/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<p>在开发中，异常处理是一个不可绕开的话题，我们对于异常的处理已经非常熟练了，对于异常本身的概念、用法等不再赘述了，直接结合面试问题来加深对异常的理解吧。</p><a id="more"></a><p><code>Throwable</code> 可以用来表示任何可以作为异常抛出的类，分为两种： <code>Error</code> 和 <code>Exception</code>。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E6%A0%91.png" alt="image"></p><h2>1. 什么是Java异常</h2><p>异常是发生在程序执行过程中阻碍程序正常执行的错误事件。比如：用户输入错误数据、硬件故障、网络阻塞等都会导致出现异常。</p><p>只要在Java语句执行中产生了异常，<strong>一个异常对象就会被创建</strong>，JRE就会试图寻找异常处理程序来处理异常。如果有合适的异常处理程序，异常对象就会被异常处理程序接管，否则，将引发运行环境异常，JRE终止程序执行。</p><p>Java异常处理框架只能处理运行时错误，编译错误不在其考虑范围之内。</p><h2>2. Error和Exception的区别</h2><p>Error：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM出现的问题。</p><p>例如，Java虚拟机运行错误，当 JVM 不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些异常发生时，Java虚拟机一般会选择线程终止。</p><h2>3. Java异常处理中有哪些关键字？</h2><ul><li><code>throw</code>:有时我们需要显式地创建并抛出异常对象来终止程序的正常执行。<code>throw</code>关键字用来抛出并处理运行时异常。</li><li><code>throws</code>:当我们抛出任何“被检查的异常(<code>checked exception</code>)”并不处理时，需要在方法签名中使用关键字<code>throws</code>来告知调用程序此方法可能会抛出的异常。调用方法可能会处理这些异常，或者同样用<code>throws</code>来将异常传给上一级调用方法。<code>throws</code>关键字后可接多个潜在异常，甚至是在<code>main()</code>中也可以使用<code>throws</code>。</li><li><code>try-catch</code>:我们在代码中用<code>try-catch</code>块处理异常。当然，一个<code>try</code>块之后可以有多个<code>catch</code>子句，<code>try-catch</code>块也能嵌套。每个<code>catch</code>块必须接受一个（且仅有一个）代表异常类型的参数。</li><li><code>finally</code>:<code>finally</code>块是可选的，并且只能配合<code>try-catch</code>一起使用。虽然异常终止了程序的执行，但是还有一些打开的资源没有被关闭，因此，我们能使用<code>finally</code>进行关闭。不管异常有没有出现，<code>finally</code>块总会被执行。</li></ul><h2>4. 描述一下异常的层级</h2><ul><li><code>Throwable</code>是所有异常的父类，它有两个直接子对象<code>Error</code>,<code>Exception</code>，其中<code>Exception</code>又被继续划分为“被检查的异常(<code>checked exception</code>)”和”运行时的异常（<code>runtime exception</code>,即不受检查的异常）”。 <code>Error</code>表示编译时和系统错误，通常不能预期和恢复，比如硬件故障、JVM崩溃、内存不足等。</li><li>被检查的异常（<code>Checked exception</code>）在程序中能预期，并要尝试修复，如<code>FileNotFoundException</code>。我们必须捕获此类异常，并为用户提供有用信息和合适日志来进行调试。<code>Exception</code>是所有被检查的异常的父类。</li><li>运行时异常（<code>Runtime Exception</code>）又称为不受检查异常，源于糟糕的编程。比如我们检索数组元素之前必须确认数组的长度，否则就可能会抛出<code>ArrayIndexOutOfBoundException</code>运行时异常。<code>RuntimeException</code>是所有运行时异常的父类。</li></ul><h2>5. 描述Java 7 ARM(Automatic Resource Management，自动资源管理)特征和多个catch块的使用</h2><p>如果一个<code>try</code>块中有多个异常要被捕获，<code>catch</code>块中的代码会变丑陋的同时还要用多余的代码来记录异常。有鉴于此，Java 7的一个新特征是：一个<code>catch</code>子句中可以捕获多个异常。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(IOException | SQLException | Exception ex)&#123;</span><br><span class="line">     logger.error(ex);</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> MyException(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数情况下，当忘记关闭资源或因资源耗尽出现运行时异常时，我们只是用<code>finally</code>子句来关闭资源。这些异常很难调试，我们需要深入到资源使用的每一步来确定是否已关闭。因此，Java 7用<code>try-with-resources</code>进行了改进：在<code>try</code>子句中能创建一个资源对象，当程序的执行完<code>try-catch</code>之后，运行环境自动关闭资源。</p><blockquote><p>利用Try-Catch-Finally管理资源（旧的代码风格）：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>);<span class="comment">//可能发生异常1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read();<span class="comment">//可能发生异常2</span></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">            input.close();<span class="comment">//可能发生异常3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设<code>try</code>语句块抛出一个异常，然后<code>finally</code>语句块被执行。同样假设<code>finally</code>语句块也抛出了一个异常。那么哪个异常会根据调用栈往外传播？</p><p><font color="#ff0000">即使<code>try</code>语句块中抛出的异常与异常传播更相关，最终还是<code>finally</code>语句块中抛出的异常会根据调用栈向外传播。</font></p><blockquote><p>在java7中，对于上面的例子可以用try-with-resource 结构这样写：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#ff0000">当<code>try</code>语句块运行结束时，<code>FileInputStream</code> 会被自动关闭。这是因为<code>FileInputStream</code> 实现了java中的<code>java.lang.AutoCloseable</code>接口。所有实现了这个接口的类都可以在<code>try-with-resources</code>结构中使用。</font></p><p><strong>当<code>try-with-resources</code>结构中抛出一个异常，同时<code>FileInputStream</code>被关闭时（调用了其<code>close</code>方法）也抛出一个异常，<code>try-with-resources</code>结构中抛出的异常会向外传播，而<code>FileInputStream</code>被关闭时抛出的异常被抑制了</strong>。</p><blockquote><p>你可以在块中使用多个资源而且这些资源都能被自动地关闭。下面是例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(  FileInputStream     input         = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>);</span><br><span class="line">          BufferedInputStream bufferedInput = <span class="keyword">new</span> BufferedInputStream(input)</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = bufferedInput.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">    data = bufferedInput.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些资源将按照他们被创建顺序的<strong>逆序</strong>来关闭。首先<code>BufferedInputStream</code> 会被关闭，然后<code>FileInputStream</code>会被关闭。</p><p>这个<code>try-with-resources</code>结构里不仅能够操作java内置的类。你也可以在自己的类中实现<code>java.lang.AutoCloseable</code>接口，然后在<code>try-with-resources</code>结构里使用这个类。</p><p><code>AutoClosable</code> 接口仅仅有一个方法，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoClosable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何实现了这个接口的方法都可以在<code>try-with-resources</code>结构中使用。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoClosable</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoClosable doing it!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoClosable closed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doIt()</code>是方法不是<code>AutoClosable</code> 接口中的一部分，之所以实现这个方法是因为我们想要这个类除了关闭方法外还能做点其他事。</p><p>下面是<code>MyAutoClosable</code> 在<code>try-with-resources</code>结构中使用的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myAutoClosable</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(MyAutoClosable myAutoClosable = <span class="keyword">new</span> MyAutoClosable())&#123;</span><br><span class="line">        myAutoClosable.doIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyAutoClosable doing it!</span><br><span class="line">MyAutoClosable closed!</span><br></pre></td></tr></table></figure><p>通过上面这些你可以看到，不论<code>try-catch</code>中使用的资源是自己创造的还是java内置的类型，<code>try-with-resources</code>都是一个能够确保资源能被正确地关闭的强大方法。</p><h2>6. 在Java中throw与throws关键字之间的区别？</h2><p>throws用于在方法签名中声明此方法可能抛出的异常，而throw关键字则是中断程序的执行并移交异常对象到运行时进行处理。</p><h2>7. 在Java中怎么写自定义的异常？</h2><p>我们能继承Exception类或其任何子类来实现自己的自定义异常类。这自定义异常类可以有自己变量和方法来传递错误代码或其它异常相关信息来处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyBikeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code = ResponseEnum.ERROR.getCode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HappyBikeException</span><span class="params">(Integer code,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HappyBikeException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>8. Java中final,finally,finalize的区别？</h2><p>这是一个垃圾问题，很想删除掉，但是考虑到新手，还是保留一下吧，至少从单词上有那么一点点像。</p><p><code>final</code>和<code>finally</code>在Java中是关键字，而finalize则是一个方法。</p><p><code>final</code>关键字使得类变量不可变，避免类被其它类继承或方法被重写。<code>finally</code>跟<code>try-catch</code>块一起使用，即使是出现了异常，其子句总会被执行，通常，<code>finally</code>子句用来关闭相关资源。<code>finally</code>方法中的对象被销毁之前会被垃圾回收。</p><h2>9. 在main方法抛出异常时发生了什么？</h2><p>答：当<code>main</code>方法抛出异常时，Java运行时间终止并在控制台打印异常信息和栈轨迹。</p><h2>10. catch子句能为空吗？</h2><p><code>catch</code>后面括号里面不能为空。</p><p>答：可以有空的<code>catch</code>子句，但那是最糟糕的编程，因为那样的话，异常即使被捕获，我们也得不到任何的有用信息，对于调试来说会是个噩梦，因此，编程时永远不要有空的<code>catch</code>子句。<code>Catch</code>子句中至少要包含一个日志语句输出到控制台或保存到日志文件中。</p><h2>11. 提供一些Java异常处理的最佳实践。</h2><ul><li>使用具体的异常方便调试</li><li>程序中早点抛出异常</li><li>捕获异常后让调用者处理异常</li><li>使用Java 7 ARM功能确保资源关闭或者用finally子句正确地关闭它们</li><li>为了调试需要总是记录异常信息</li><li>用多个catch子句实现更完全的关闭</li><li>你自己的应用API中用自定义的异常来抛出单种类型异常</li><li>遵循命名规定，以异常结束</li><li>在Javadoc中用@throws来标注方法抛出的异常</li><li><strong>处理异常是有花销的，因此只有在必要时才抛出</strong>。否则，你会扑空或毫无收获。</li></ul><h2>12. try、catch、finally三个语句块应注意的问题</h2><ul><li>try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。</li><li>try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。</li><li>多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，并且匹配catch语句的顺序是由上到下。</li><li>无论程序是否有异常，并且无论之间try-catch是否顺利执行完毕，都会执行finally语句。在以下特殊情况下，finally块不会执行：在finally语句块中发生异常；在前面代码中使用了System.exit()退出程序；程序所在线程死亡；关闭cpu。</li><li><strong>⭐当程序执行try块，catch块时遇到return语句或者throw语句，这两个语句都会导致该方法立即结束，所以系统并不会立即执行这两个语句，而是去寻找该异常处理流程中的finally块，如果没有finally块，程序立即执行return语句或者throw语句，方法终止。如果有finally块，系统立即开始执行finally块，只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句，如果finally块里也使用了return或throw等导致方法终止的语句，则finally块已经终止了方法，不用再跳回去执行try块、catch块里的任何代码了。</strong></li></ul><h2>13. 解释Java中的异常处理流程</h2><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%82%E5%B8%B8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="image"></p><h2>异常处理完成以后，Exception对象会发生什么变化？</h2><p>Exception对象会在下一个垃圾回收过程中被回收掉。</p><h2>请写出 5 种常见到的runtime exception。</h2><ul><li><code>NullPointerException</code>：当操作一个空引用时会出现此错误。</li><li><code>NumberFormatException</code>：数据格式转换出现问题时出现此异常。</li><li><code>ClassCastException</code>：强制类型转换类型不匹配时出现此异常。</li><li><code>ArrayIndexOutOfBoundsException</code>：数组下标越界，当使用一个不存在的数组下标时出现此异常。</li><li><code>ArithmeticException</code>：数学运行错误时出现此异常</li></ul><p>参考：</p><ul><li><a href="http://www.importnew.com/7383.html" target="_blank" rel="noopener">http://www.importnew.com/7383.html</a></li><li><a href="http://www.importnew.com/7541.html" target="_blank" rel="noopener">http://www.importnew.com/7541.html</a></li><li><a href="http://www.importnew.com/7820.html" target="_blank" rel="noopener">http://www.importnew.com/7820.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己实现一个简单的web服务器</title>
      <link href="/2019/02/18/thread/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/02/18/thread/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>这里涉及网络编程的基本知识以及HTTP协议的基本认识，下面来一步一步实现一下最简单的一个web服务器。</p><a id="more"></a><h2>一、用户请求域名到底发送了什么信息来</h2><p>如果服务端都不知道客户端发来的是什么，那何谈对内容的解析呢？所以我们首先在服务端解析客户端的访问信息，比如我们比较关心的是请求的是什么路径：</p><p><img src="http://bloghello.oursnail.cn/thread17-1.png" alt="image"></p><p>此时我们访问地址： localhost:8888 打印出来的结果为：</p><p><img src="http://bloghello.oursnail.cn/thread17-2.png" alt="image"></p><p>其实对于我们这种比较简单的实现来说，红框的信息已经足够了。我们只要知道客户端要发来的资源名字是什么，我们根据这个名字取找响应的资源返回给客户端展示即可。由于我其实请求的是根路径，所以是<code>/</code>。如果我在这里请求 localhost:8888/index.html 那么就会显示 <code>GET /index.html HTTP/1.1</code>这样的信息。不再演示。</p><p>但是上面的写法是存在问题的，仅仅是演示而用，因为它会一直等待输入。</p><p>那么，不用<code>while</code>一直等待，而且只需要第一行即可，那么可以这样写：</p><p><img src="http://bloghello.oursnail.cn/thread17-3.png" alt="image"></p><p>好了，不能总之只接收吧，我们服务端要给客户端点什么。</p><h2>二、服务端如何响应资源给客户端展示</h2><p>首先我们得有资源才能展示，假设我们要展示<code>index.html</code>，我们将其暂时放在<code>F:/webrooot</code>下。</p><p>内容暂时为：</p><p><img src="http://bloghello.oursnail.cn/thread17-4.png" alt="image"></p><p>只是展示一下欢迎信息而已。服务端就需要读取这个文件，然后以流的形式发送给客户端的浏览器上，浏览器再解析展示。</p><p><img src="http://bloghello.oursnail.cn/thread17-5.png" alt="image"></p><p>此时再去访问页面，就会显示欢迎的信息啦！</p><p><img src="http://bloghello.oursnail.cn/thread17-6.png" alt="image"></p><p>这里没有关闭流，也没有关闭<code>socket</code>，不过下面都会关闭掉。这个不重要，重要的是，这玩意都是在主线程中做的，显然不如多线程来的快，并且全写在主线程里，肯定是不够好的。下面就用多线程来实现。</p><h2>三、普通的多线程实现方式</h2><p><img src="http://bloghello.oursnail.cn/thread17-7.png" alt="image"></p><p>就是在这个线程中处理数据和返回数据。</p><p><img src="http://bloghello.oursnail.cn/thread17-8.png" alt="image"></p><p>其很简单，但是如果我想显示一张图片呢？</p><p>比如我的根目录下有一张图片叫做：<code>hh.jpg</code></p><p><img src="http://bloghello.oursnail.cn/thread17-9.png" alt="image"></p><p>很显然现在还是无法展示的，原因是我这里写死了是以<code>text/html</code>的形式响应，但是图片正确的响应是<code>image/jpeg</code>这种格式。</p><p>所以我们不能无脑写死，要进行适当的判断才行。下面贴出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//根目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String webroot = <span class="string">"F:\\webroot\\"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket client;</span><br><span class="line">    InputStream ins;</span><br><span class="line">    OutputStream out;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存放类型，比如jpg对应的是image/jpeg，这是http协议规定的每种类型的响应格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,String&gt; contentMap =  <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        contentMap.put(<span class="string">"html"</span>,<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">        contentMap.put(<span class="string">"jpg"</span>,<span class="string">"image/jpeg"</span>);</span><br><span class="line">        contentMap.put(<span class="string">"png"</span>,<span class="string">"image/jpeg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket client)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ins = client.getInputStream();</span><br><span class="line">            out = client.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            go();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求内容</span></span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(ins));</span><br><span class="line">        <span class="comment">//获取到请求的资源名称</span></span><br><span class="line">        String line = reader.readLine().split(<span class="string">" "</span>)[<span class="number">1</span>].replace(<span class="string">"/"</span>,<span class="string">"\\"</span>);</span><br><span class="line">        <span class="keyword">if</span>(line.equals(<span class="string">"\\"</span>))&#123;</span><br><span class="line">            line += <span class="string">"index.html"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">        <span class="comment">//拼接起来就是资源的完整路径</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(webroot + line);</span><br><span class="line">        <span class="comment">//判断是否存在，存在则响应内容，不存在则告知不存在</span></span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="comment">//给用户响应</span></span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(out);</span><br><span class="line">            InputStream i = <span class="keyword">new</span> FileInputStream(webroot + line);</span><br><span class="line">            <span class="comment">//由于需要将图片也要传给前端，再用这个就不好办了，得用普通的文件输入流</span></span><br><span class="line"><span class="comment">//          BufferedReader fr = new BufferedReader(new InputStreamReader(i));</span></span><br><span class="line">            pw.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">            <span class="comment">//返回的类型是动态判断的，图片用图片的类型，文本用文本的类型</span></span><br><span class="line">            String s = contentMap.get(line.substring(line.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>,line.length()));</span><br><span class="line">            System.out.println(<span class="string">"返回的类型为："</span>+ s);</span><br><span class="line">            pw.println(<span class="string">"Content-Type: "</span> + s);</span><br><span class="line">            pw.println(<span class="string">"Content-Length:"</span> + i.available());</span><br><span class="line">            pw.println(<span class="string">"Server: hello-server"</span>);</span><br><span class="line">            pw.println(<span class="string">"Date:"</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">            pw.println(<span class="string">""</span>);</span><br><span class="line">            pw.flush();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写入输出流中通过PrintWriter发给浏览器</span></span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ( (len = i.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            pw.flush();</span><br><span class="line">            pw.close();</span><br><span class="line">            i.close();</span><br><span class="line">            reader.close();</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuffer error = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            error.append(<span class="string">"HTTP /1.1 400 file not found /r/n"</span>);</span><br><span class="line">            error.append(<span class="string">"Content-Type:text/html \r\n"</span>);</span><br><span class="line">            error.append(<span class="string">"Content-Length:20 \r\n"</span>).append(<span class="string">"\r\n"</span>);</span><br><span class="line">            error.append(<span class="string">"&lt;h1 &gt;File Not Found..&lt;/h1&gt;"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.write(error.toString().getBytes());</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,你会发现，我还添加了判断资源存在不存在的逻辑，这样显得更加健全一点。</p><p>当找得到资源得时候：</p><p><img src="http://bloghello.oursnail.cn/thread17-10.png" alt="image"></p><p>当找不到资源得时候：</p><p><img src="http://bloghello.oursnail.cn/thread17-11.png" alt="image"></p><h2>四、线程池方式</h2><p>其实很简单，线程池的优势以前也说过，不赘述，直接贴一下代码结束。</p><p><img src="http://bloghello.oursnail.cn/thread17-12.png" alt="image"></p><p>至此，我们完成了一个比较简单的web服务器的开发。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础之JDK动态代理</title>
      <link href="/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>代理模式可以说是经常面试被问的一个东西，因为spring aop的实现原理就是基于它，关于它，只要记住，它是运行时动态生成的一个代理类。在这个基础上，再去看看它底层源码，其实JDK已经帮我们最大程度上封装成简单的函数了，我们只需要传入几个参数就可以生成对应的代理对象。</p><a id="more"></a><h2>代理模式是什么</h2><p>定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p><ul><li><code>RealSubject</code> 是原对象（本文把原对象称为&quot;委托对象&quot;），<code>Proxy</code> 是代理对象。</li><li><code>Subject</code> 是委托对象和代理对象都共同实现的接口。</li><li><code>Request()</code> 是委托对象和代理对象共同拥有的方法。</li></ul><h2>结合生活理解代理模式</h2><p>要理解代理模式很简单，其实生活当中就存在代理模式：</p><blockquote><p>我们购买火车票可以去火车站买，但是也可以去火车票代售处买，此处的火车票代售处就是火车站购票的代理，即我们在代售点发出买票请求，代售点会把请求发给火车站，火车站把购买成功响应发给代售点，代售点再告诉你。</p><p>但是代售点只能买票，不能退票，而火车站能买票也能退票，因此代理对象支持的操作可能和委托对象的操作有所不同。</p></blockquote><h2>Java实现静态代理示例</h2><p><img src="http://bloghello.oursnail.cn/javabasic8-1.png" alt="image"></p><p>代理的实现分为：</p><ul><li>静态代理</li></ul><p>代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 <code>class</code> 文件。</p><ul><li>动态代理</li></ul><p>代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 <code>class</code> 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p><h2>Java 实现动态代理</h2><h5>几个重要名词:</h5><ul><li>委托类和委托对象：委托类是一个类，委托对象是委托类的实例，即原类。</li><li>代理类和代理对象：代理类是一个类，代理对象是代理类的实例。</li></ul><h5>Java实现动态代理的大致步骤如下:</h5><ol><li>定义一个委托类和公共接口。</li><li>自己定义一个类（调用处理器类，即实现 <code>InvocationHandler</code> 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括<code>Preprocess</code>和<code>Postprocess</code>），即代理类调用任何方法都会经过这个调用处理器类（在本文最后一节对此进行解释）。</li><li>生成代理对象（当然也会生成代理类），需要为他指定(1)类加载器对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。</li></ol><h5>Java 实现动态代理主要涉及以下几个类:</h5><ul><li><code>java.lang.reflect.Proxy</code>: 这是生成代理类的主类，通过 <code>Proxy</code> 类生成的代理类都继承了 <code>Proxy</code> 类，即 <code>DynamicProxyClass extends Proxy</code>。</li><li><code>java.lang.reflect.InvocationHandler</code>: 这里称他为&quot;调用处理器&quot;，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 <code>InvocationHandler</code> 接口。</li></ul><h5>Proxy 类主要方法为：</h5><p><img src="http://bloghello.oursnail.cn/javabasic8-2.png" alt="image"></p><ul><li>这个静态函数的第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区）</li><li>第二个参数是接口（表明你这个代理类需要实现哪些接口）</li><li>第三个参数是调用处理器类实例（指定代理类中具体要干什么）。</li><li>这个函数是 JDK 为了程序员方便创建代理对象而封装的一个函数，因此你调用<code>newProxyInstance()</code>时直接创建了代理对象（略去了创建代理类的代码）。其实他主要完成了以下几个工作：</li></ul><p><img src="http://bloghello.oursnail.cn/javabasic8-3.png" alt="image"></p><p><code>Proxy</code> 类还有一些静态方法，比如：</p><ul><li><code>InvocationHandler getInvocationHandler(Object proxy)</code>: 获得代理对象对应的调用处理器对象。</li><li><code>Class getProxyClass(ClassLoader loader, Class[] interfaces)</code>: 根据类加载器和实现的接口获得代理类。</li></ul><p><code>Proxy</code> 类中有一个映射表，映射关系为：(<code>&lt;ClassLoader&gt;</code>,(<code>&lt;Interfaces&gt;</code>,<code>&lt;ProxyClass&gt;</code>) )，可以看出一级key为类加载器，根据这个一级key获得二级映射表，二级key为接口数组，因此可以看出：一个类加载器对象和一个接口数组确定了一个代理类。</p><p>我们写一个简单的例子来阐述 Java 实现动态代理的整个过程：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-4.png" alt="image"></p><p><code>InvocationHandler</code> 接口中有方法：<code>invoke(Object proxy, Method method, Object[] args)</code></p><p>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，<strong>第一个参数是代理对象</strong>（表示哪个代理对象调用了method方法，传递来的是），<strong>第二个参数是 Method 对象</strong>（表示哪个方法被调用了），<strong>第三个参数是指定调用方法的参数</strong>。</p><p>动态生成的代理类具有几个特点：</p><ul><li>继承 <code>Proxy</code> 类，并实现了在<code>Proxy.newProxyInstance()</code>中提供的接口数组。</li><li><code>public final</code>。</li><li>命名方式为 <code>$ProxyN</code>，其中N会慢慢增加，一开始是 <code>$Proxy1</code>，接下来是<code>$Proxy2</code>…</li><li>有一个参数为 <code>InvocationHandler</code> 的构造函数。这个从 <code>Proxy.newProxyInstance()</code> 函数内部的<code>clazz.getConstructor(new Class[] { InvocationHandler.class })</code> 可以看出。</li></ul><p>Java 实现动态代理的缺点：因为 Java 的单继承特性（每个代理类都继承了 Proxy 类），只能针对接口创建代理类，不能针对类创建代理类。</p><blockquote><p>不难发现，代理类的实现是有很多共性的（重复代码），动态代理的好处在于避免了这些重复代码，只需要关注操作。</p></blockquote><h2>小栗子</h2><p>假设模拟一个场景，买衣服，正常情况所有人买这件衣服要100块钱。</p><p>定义一个销售接口：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-5.png" alt="image"></p><p>一个具体的实现类：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-6.png" alt="image"></p><p>那么正常情况大家都要花100才能买这件衣服。但是现在对会员做活动，会员打5折。怎么做呢？正常思维是：增加一个接口，甚至更糟的想法是修改一下这个实现类，都是不好的，那么我们是否想过这样的方案：新建一个新的类，让这个代理类去做相应的逻辑呢？既不用修改原来的代码，而且还很简单就能实现。</p><p>现在写一个代理类：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-7.png" alt="image"></p><p>那么调用的时候，一个是会员，一个是普通用户，根据身份调不同的方法即可：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-8.png" alt="image"></p><h2>Java 动态代理的内部实现</h2><p>现在我们就会有一个问题： Java 是怎么保证代理对象调用的任何方法都会调用 <code>InvocationHandler</code> 的 <code>invoke()</code> 方法的？</p><p>这就涉及到动态代理的内部实现。假设有一个接口 <code>Subject</code>，且里面有 <code>int request(int i)</code> 方法，则生成的代理类大致如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic8-9.png" alt="image"></p><p>通过上面的方法就成功调用了 <code>invoke()</code> 方法，所以这是代理类中已经注定要去执行 <code>invoke()</code> 方法了。</p><p>有一篇文章比较生动地阐述了动态代理的含义：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513926&amp;idx=1&amp;sn=1c43c5557ba18fed34f3d68bfed6b8bd&amp;chksm=80d67b85b7a1f2930ede2803d6b08925474090f4127eefbb267e647dff11793d380e09f222a8#rd" target="_blank" rel="noopener">Java帝国之动态代理</a></p>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础之注解</title>
      <link href="/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>注解是一系列元数据，它提供数据用来解释程序代码，注释是给人看的，注解是给编译器看的，因此注解只在编译器有效。注解的实现原理涉及反射和动态代理，关于反射已经在前面说过，动态代理还没说，留在下一节。</p><a id="more"></a><h2>注解语法</h2><p>相信有不少的人员会认为注解的地位不高。其实同 <code>classs</code> 和 <code>interface</code> 一样，注解也属于一种类型。它是在 Java SE 5.0 版本中开始引入的概念。</p><h2>注解的定义</h2><p>注解通过 <code>@interface</code> 关键字进行定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><p>你可以简单理解为创建了一张名字为 <code>TestAnnotation</code> 的标签。</p><h2>注解的使用</h2><p>上面创建了一个注解，那么注解的的使用方法是什么呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。</p><h2>什么是元注解</h2><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p><p>元标签有 <code>@Retention</code>、<code>@Documented</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Repeatable</code> 5 种。</p><blockquote><p>@Retention</p></blockquote><p><code>Retention</code> 的英文意为保留期的意思。当 <code>@Retention</code> 应用到一个注解上的时候，它解释说明了这个<strong>注解的的存活时间</strong>。</p><ul><li><code>RetentionPolicy.SOURCE</code> 注解只在<strong>源码阶段</strong>保留，在编译器进行<strong>编译时它将被丢弃</strong>忽视。</li><li><code>RetentionPolicy.CLASS</code> 注解<strong>只被保留到编译进行</strong>的时候，它并<strong>不会被加载到 JVM</strong> 中。</li><li><code>RetentionPolicy.RUNTIME</code> 注解可以<strong>保留到程序运行</strong>的时候，它<strong>会被加载进入到 JVM</strong> 中，所以在程序运行时可以获取到它们。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Documented</p></blockquote><p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 <code>Javadoc</code> 中去。</p><blockquote><p>@Target</p></blockquote><p><code>Target</code> 是目标的意思，<code>@Target</code> 指定了注解运用的地方。</p><ul><li><code>ElementType.ANNOTATION_TYPE</code> 可以给一个注解进行注解</li><li><code>ElementType.CONSTRUCTOR</code> 可以给构造方法进行注解</li><li><code>ElementType.FIELD</code> 可以给属性进行注解</li><li><code>ElementType.LOCAL_VARIABLE</code> 可以给局部变量进行注解</li><li><code>ElementType.METHOD</code> 可以给方法进行注解</li><li><code>ElementType.PACKAGE</code> 可以给一个包进行注解</li><li><code>ElementType.PARAMETER</code> 可以给一个方法内的参数进行注解</li><li><code>ElementType.TYPE</code> 可以给一个类型进行注解，比如类、接口、枚举</li></ul><blockquote><p>@Inherited</p></blockquote><p><code>Inherited</code> 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个<strong>超类被 <code>@Inherited</code> 注解过的注解进行注解</strong>的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个被@Inherited注解的注解@Test</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类被@Test注解，即上面说的被@Inherited 注解过的注解进行注解</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//那么class B也拥有@Test注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Repeatable</p></blockquote><p><code>Repeatable</code> 自然是可重复的意思。<code>@Repeatable</code> 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照规定，它里面必须要有一个 value 的属性</span></span><br><span class="line"><span class="comment">//属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。</span></span><br><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Repeatable 后面括号中的类相当于一个容器注解</span></span><br><span class="line"><span class="comment">//什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    <span class="function">String <span class="title">role</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有了上面两个注解，Persons相当于一个总标签</span></span><br><span class="line"><span class="comment">//他里面可以放任意多个子标签，这些子标签类型是Person</span></span><br><span class="line"><span class="comment">//并且是存放于这个总标签的Person类型的数组中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么既然有了总标签和放子标签的数组，那么，下面就可以定义子标签</span></span><br><span class="line"><span class="comment">//子标签的类型自然就是Person，里面这里假设定义role属性</span></span><br><span class="line"><span class="comment">//就是说这些子标签表示人的角色。</span></span><br><span class="line"><span class="comment">//自然也就支持多种角色，那么定义多次即可。如下</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"artist"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"coder"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"PM"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>注解的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有默认值的时候，可以不执行属性</span></span><br><span class="line"><span class="meta">@TestAnnotation</span>(id=<span class="number">3</span>,msg=<span class="string">"hello annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一些规则：</p><ul><li>修饰符只能是<code>public</code> 或默认(<code>default</code>)</li><li>参数成员只能用基本类型<code>byte</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>float</code>,<code>double</code>,<code>boolean</code>,<code>char</code>八种基本类型和<code>String</code>,<code>Enum</code>,<code>Class</code>,<code>annotations</code>及这些类型的数组</li><li>如果只有一个参数成员,最好将名称设为”value”</li><li>注解元素必须有确定的值,可以在注解中定义默认值,也可以使用注解时指定,非基本类型的值不可为null,常使用空字符串或0作默认值</li><li>在表现一个元素存在或缺失的状态时,定义一下特殊值来表示,如空字符串或负值</li></ul><h2>Java 预置的注解</h2><blockquote><p>@Deprecated</p></blockquote><p>这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。</p><blockquote><p>@Override</p></blockquote><p>这个大家应该很熟悉了，提示子类要复写父类中被 <code>@Override</code> 修饰的方法</p><blockquote><p>@SuppressWarnings</p></blockquote><p>阻止警告的意思。之前说过调用被 <code>@Deprecated</code> 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 <code>@SuppressWarnings</code> 达到目的。</p><blockquote><p>@SafeVarargs</p></blockquote><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 <code>unchecked</code> 这样的警告。</p><blockquote><p>@FunctionalInterface</p></blockquote><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。</p><p>函数式接口 (<code>Functional Interface</code>) 就是一个具有一个方法的普通接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行线程开发中常用的 <code>Runnable</code> 就是一个典型的函数式接口，上面源码可以看到它就被 <code>@FunctionalInterface</code> 注解。</p><p>可能有人会疑惑，函数式接口标记有什么用，这个原因是函数式接口可以很容易转换为 <code>Lambda</code> 表达式。</p><h2>注解与反射</h2><blockquote><p>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者是 getAnnotations() 方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里举个例子：</p><p>首先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个类，打上这个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再main函数中拿到注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断Test.class中是否存在TestAnnotation注解</span></span><br><span class="line">        <span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span>(hasAnnotation)&#123;</span><br><span class="line">            System.out.println(<span class="string">"注解存在..."</span>);</span><br><span class="line">            <span class="comment">//从Test类中拿出TestAnnotation注解</span></span><br><span class="line">            TestAnnotation annotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">            <span class="comment">//拿到注解之后，可以拿出注解中的属性对应的默认值</span></span><br><span class="line">            System.out.println(annotation.id());</span><br><span class="line">            System.out.println(annotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面演示的是从类上拿到注解，对于属性、方法同样都可以用反射拿到注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>(value=<span class="string">"hi"</span>)</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Perform</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*************拿到属性上的注解****************/</span></span><br><span class="line">            Field a = Test.class.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">            a.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//获取一个成员变量上的注解</span></span><br><span class="line">            Check check = a.getAnnotation(Check.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( check != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                System.out.println(<span class="string">"check value:"</span>+check.value());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************拿到方法上的注解****************/</span></span><br><span class="line">            Method testMethod = Test.class.getDeclaredMethod(<span class="string">"testMethod"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( testMethod != <span class="keyword">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// 获取方法中的注解</span></span><br><span class="line">                Annotation[] ans = testMethod.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ans.length;i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"method testMethod annotation:"</span>+ans[i].annotationType().getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>注解实现原理</h2><p>在上面获取注解时是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestAnnotation annotation = Test.class.getAnnotation(TestAnnotation.class);</span><br></pre></td></tr></table></figure><p>它是从<code>class</code>中获取出<code>TestAnnotation</code>注解的，所以肯定是在某个时候注解被加入到<code>class</code>结构中去了。</p><ul><li>首先，我们知道从<code>java</code>源码到<code>class</code>字节码是由编译器完成的，编译器会对<code>java</code>源码进行解析并生成<code>class</code>文件。</li><li>而注解也是在编译时由编译器进行处理，编译器会对注解符号处理并附加到<code>class</code>结构中</li><li>根据<code>jvm</code>规范，<code>class</code>文件结构是严格有序的格式，唯一可以附加信息到<code>class</code>结构中的方式就是保存到<code>class</code>结构的<code>attributes</code>属性中</li><li>我们知道对于类、字段、方法，在<code>class</code>结构中都有自己特定的表结构，而且各自都有自己的属性，而对于注解，作用的范围也可以不同，可以作用在类上，也可以作用在字段或方法上，这时编译器会对应将注解信息存放到类、字段、方法自己的属性上。</li><li>在我们的<code>Test</code>类被编译后，在对应的<code>Test.class</code>文件中会包含一个<code>RuntimeVisibleAnnotations</code>属性，由于这个注解是作用在类上，所以此属性被添加到类的属性集上。即<code>TestAnnotation</code>注解的键值对<code>value=test</code>会被记录起来。</li><li>而当<code>JVM</code>加载<code>Test.class</code>文件字节码时，就会将<code>RuntimeVisibleAnnotations</code>属性值保存到<code>Test</code>的<code>Class</code>对象中，于是就可以通过<code>Test.class.getAnnotation(TestAnnotation.class)</code>获取到<code>Test</code>注解对象，进而再通过<code>Test</code>注解对象获取到<code>Test</code>里面的属性值。</li><li><code>Test</code>注解对象是什么？其实注解被编译后的本质就是一个继承<code>Annotation</code>接口的接口。所以<code>@TestAnnotation</code>其实就是“public interface TestAnnotation extends Annotation”</li><li>当我们通过<code>Test.class.getAnnotation(TestAnnotation.class)</code>调用时，<code>JDK</code>会通过动态代理生成一个实现了<code>TestAnnotation</code>接口的对象，并把将<code>RuntimeVisibleAnnotations</code>属性值设置进此对象中，此对象即为<code>TestAnnotation</code>注解对象，通过它的<code>value()</code>方法就可以获取到注解值。</li></ul><h2>总结注解到底是什么以及注解到底有什么应用场景</h2><p>注释是给人看的，<strong>注解是给编译器看的</strong>，以<code>@Override</code>注解为例，他的作用是告诉编译器他所注解的方法是重写父类中的方法，这样编译器就会去检查父类是否存在这个方法，以及这个方法的签名与父类是否相同。</p><p><strong>注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用</strong>；</p><p>也就是说，注解只是描述java代码的代码，能被编译器解析，<strong>只有编译器或者虚拟机来主动解析他的时候，他才可能发挥作用</strong>。</p><p>注解分为三类，元注解，java自带的标准注解以及自定义注解。</p><p>注解的使用场景：</p><ul><li>生成文档，通过代码里标识的元数据生成javadoc文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><p>我觉得这些说的太空洞了，注解在<code>spring</code>中就是非常常用的技术，比如，我指定这个类是<code>@Controller</code>或者<code>@Service</code>之类，那么我配置包扫描将其类路径全部扫描到后，启动容器的时候，这些类就会自动被spring所管理，即自动向<code>spring</code>注册，以后要注入这些组件的时候，就直接从<code>spring</code>的<code>IOC</code>容器中取出来即可。</p>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基础之冰川表面</title>
      <link href="/2019/02/17/java-basic/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%B0%E5%B7%9D%E8%A1%A8%E9%9D%A2/"/>
      <url>/2019/02/17/java-basic/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%B0%E5%B7%9D%E8%A1%A8%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>本篇文章是罗列一些关于java基础的核心点，这些点是基础中的基础，也是重点中的重点。为什么本篇文章叫做冰川表面呢？我想表达的意思是，这些基础只是一个引子，背后牵扯出来的东西可能会很多，面试往往都是从基础的知识点慢慢深入挖掘的，所以千万不能忽视对于它们的复习。</p><a id="more"></a><h1>一、关键字</h1><h2>final</h2><p><strong>1. 数据</strong></p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，<code>final</code> 使数值不变；</li><li>对于引用类型，<code>final</code> 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable 'x'</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>2. 方法</strong></p><p>声明方法不能被子类覆盖。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是覆盖基类方法，而是在子类中定义了一个新的方法。</p><p><strong>3. 类</strong></p><p>声明类不允许被继承。</p><h2>static</h2><p><strong>1. 静态变量</strong></p><p>静态变量在内存中只存在一份，只在类初始化时赋值一次。</p><ul><li>静态变量：类所有的实例都共享静态变量，可以直接通过类名来访问它；</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;        <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong></p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（<code>abstract</code>）。</p><p><strong>3. 静态语句块</strong></p><p>静态语句块在类初始化时运行一次。</p><p><strong>4. 静态内部类</strong></p><p>内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。</p><p><strong>5. 静态导包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure><p>在使用静态变量和方法时不用再指明 <code>ClassName</code>，从而简化代码，但可读性大大降低。</p><p><strong>6. 变量赋值顺序</strong></p><p>静态变量的赋值和静态语句块的运行优先于实例变量的赋值和普通语句块的运行，静态变量的赋值和静态语句块的运行哪个先执行取决于它们在代码中的顺序。</p><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h1>二、Object 通用方法</h1><h2>概览</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2>equals()</h2><p><strong>1. equals() 与 == 的区别</strong></p><ul><li>对于基本类型，<code>==</code> 判断两个值是否相等，基本类型没有 <code>equals()</code> 方法。</li><li>对于引用类型，<code>==</code> 判断两个实例是否引用同一个对象，而 <code>equals()</code> 判断引用的对象是否等价。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>默认情况下也就是从超类<code>Object</code>继承而来的<code>equals</code>方法与<code>==</code>是完全等价的，比较的都是对象的内存地址，但我们可以重写<code>equals</code>方法，使其按照我们的需求的方式进行比较，如<code>String</code>类重写了<code>equals</code>方法，使其比较的是字符的序列，而不再是内存地址。</p><p><strong>2. 等价关系</strong></p><p>（一）自反性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（二）对称性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（三）传递性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><p>（四）一致性</p><p>多次调用 <code>equals()</code> 方法结果不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（五）与 <code>null</code> 的比较</p><p>对任何不是 <code>null</code> 的对象 <code>x</code> 调用 <code>x.equals(null)</code> 结果都为 <code>false</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.euqals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure><p><strong>3. 实现</strong></p><ul><li>检查是否为同一个对象的引用，如果是直接返回 <code>true</code>；</li><li>检查是否是同一个类型，如果不是，直接返回 <code>false</code>；</li><li>将 <code>Object</code> 实例进行转型；</li><li>判断每个关键域是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EqualExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        EqualExample that = (EqualExample) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> z == that.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>hashCode()</h2><p><code>hasCode()</code> 返回散列值，而 <code>equals()</code> 是用来判断两个实例是否等价。等价的两个实例散列值一定要相同，但是散列值相同的两个实例不一定等价。</p><p>在覆盖 <code>equals()</code> 方法时应当总是覆盖 <code>hashCode()</code> 方法，保证等价的两个实例散列值也相等。</p><p>下面的代码中，新建了两个等价的实例，并将它们添加到 <code>HashSet</code> 中。我们希望将这两个实例当成一样的，只在集合中添加一个实例，但是因为 <code>EqualExample</code> 没有实现 <code>hasCode()</code> 方法，因此这两个实例的散列值是不同的，最终导致集合添加了两个等价的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><blockquote><p>之所以选择31，是因为它是个奇素数，如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算。使用素数的好处并不是很明显，但是习惯上都使用素数来计算散列结果。31有个很好的特性，就是用移位和减法来代替乘法，可以得到更好的性能：31*i==(i&lt;&lt;5)-i。现在的VM可以自动完成这种优化。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>clone()</h2><p><strong>1. cloneable</strong></p><p><code>clone()</code> 是 <code>Object</code> 的受保护方法，这意味着，如果一个类不显式去覆盖 <code>clone()</code> 就没有这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="comment">// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object'</span></span><br></pre></td></tr></table></figure><p>接下来覆盖 <code>Object</code> 的 <code>clone()</code> 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> CloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    CloneExample e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.CloneNotSupportedException: CloneTest</span><br></pre></td></tr></table></figure><p>以上抛出了 <code>CloneNotSupportedException</code>，这是因为 <code>CloneTest</code> 没有实现 <code>Cloneable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p><strong>2. 深拷贝与浅拷贝</strong></p><ul><li>浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；</li><li>深拷贝：拷贝实例和原始实例的引用类型引用不同对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShallowCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ShallowCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ShallowCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ShallowCloneExample e1 = <span class="keyword">new</span> ShallowCloneExample();</span><br><span class="line">ShallowCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneExample</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepCloneExample <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        DeepCloneExample result = (DeepCloneExample) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeepCloneExample e1 = <span class="keyword">new</span> DeepCloneExample();</span><br><span class="line">DeepCloneExample e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用 <code>clone()</code> 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。<code>Effective Java</code> 书上讲到，最好不要去使用 <code>clone()</code>，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneConstructorExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloneConstructorExample</span><span class="params">(CloneConstructorExample original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloneConstructorExample e1 = <span class="keyword">new</span> CloneConstructorExample();</span><br><span class="line">CloneConstructorExample e2 = <span class="keyword">new</span> CloneConstructorExample(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h1>四、继承</h1><h2>访问权限</h2><p>Java 中有三个访问权限修饰符：<code>private</code>、<code>default</code>、<code>protected</code> 以及<code>public</code>，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>成员可见表示其它类可以用这个类的实例访问到该成员；</li><li>类可见表示其它类可以用这个类创建对象。</li></ul><p><code>protected</code> 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>如果子类的方法覆盖了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。可以使用公有的 <code>getter</code> 和 <code>setter</code> 方法来替换公有字段。</p><h2>抽象类与接口</h2><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用 <code>abstract</code> 进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClassExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExtendClassExample</span> <span class="keyword">extends</span> <span class="title">AbstractClassExample</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated</span></span><br><span class="line">AbstractClassExample ac2 = <span class="keyword">new</span> AbstractExtendClassExample();</span><br><span class="line">ac2.func1();</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员（字段 + 方法）默认都是 <code>public</code> 的，并且不允许定义为 <code>private</code> 或者<code>protected</code>。</p><p><img src="http://bloghello.oursnail.cn/javabasic7-1.png" alt="image"></p><p>接口的字段默认都是 <code>static</code> 和 <code>final</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// int y;                // Variable 'y' might not have been initialized</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> z = <span class="number">0</span>;       <span class="comment">// Modifier 'public' is redundant for interface fields</span></span><br><span class="line">    <span class="comment">// private int k = 0;   // Modifier 'private' not allowed here</span></span><br><span class="line">    <span class="comment">// protected int l = 0; // Modifier 'protected' not allowed here</span></span><br><span class="line">    <span class="comment">// private void fun3(); // Modifier 'private' not allowed here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceImplementExample</span> <span class="keyword">implements</span> <span class="title">InterfaceExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated</span></span><br><span class="line">InterfaceExample ie2 = <span class="keyword">new</span> InterfaceImplementExample();</span><br><span class="line">ie2.func1();</span><br><span class="line">System.out.println(InterfaceExample.x);</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong></p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 <code>static</code> 和 <code>final</code> 类型的，而抽象类的字段没有这种限制。</li><li>接口的方法只能是 <code>public</code> 的，而抽象类的方法可以由多种访问权限。</li></ul><p><strong>4. 使用选择</strong></p><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的方法和域的访问权限，而不是都为 <code>public</code>。</li><li>需要继承非静态（<code>non-static</code>）和非常量（<code>non-final</code>）字段。</li></ul><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 <code>Compareable</code> 接口中的 <code>compareTo()</code> 方法；</li><li>需要使用多重继承。</li></ul><p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h2>super</h2><ul><li>访问父类的构造函数：可以使用 <code>super()</code> 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 <code>super</code> 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">"SuperExtendExample.func()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><h2>覆盖与重载</h2><ul><li><p>覆盖（<code>Override</code>）存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法；</p></li><li><p>重载（<code>Overload</code>）存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。</p></li></ul><h1>五、String</h1><h2>String, StringBuffer and StringBuilder</h2><p><strong>1. 是否可变</strong></p><ul><li><code>String</code> 不可变</li><li><code>StringBuffer</code> 和 <code>StringBuilder</code> 可变</li></ul><p><strong>2. 是否线程安全</strong></p><ul><li><code>String</code> 不可变，因此是线程安全的</li><li><code>StringBuilder</code> 不是线程安全的</li><li><code>StringBuffer</code> 是线程安全的，内部使用 <code>synchronized</code> 来同步</li></ul><h2>String 不可变的原因</h2><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 <code>String</code> 的 <code>hash</code> 值经常被使用，例如 <code>String</code> 用做 <code>HashMap</code> 的 <code>key</code>。不可变的特性可以使得 <code>hash</code> 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 <code>String</code> 对象已经被创建过了，那么就会从 <code>String Pool</code> 中取得引用。只有 <code>String</code> 是不可变的，才可能使用 <code>String Pool</code>。</p><p><strong>3. 安全性</strong></p><p><code>String</code> 经常作为参数，<code>String</code> 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 <code>String</code> 是可变的，那么在网络连接过程中，<code>String</code> 被改变，改变 <code>String</code> 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p><code>String</code> 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><h2>String.intern()</h2><p>使用 <code>String.intern()</code> 可以保证相同内容的字符串实例引用相同的内存对象。</p><p>下面示例中，<code>s1</code> 和 <code>s2</code> 采用 <code>new String()</code> 的方式新建了两个不同对象，而 <code>s3</code> 是通过 <code>s1.intern()</code> 方法取得一个对象引用，这个方法首先把 <code>s1</code> 引用的对象放到 <code>String Poll</code>（字符串常量池）中，然后返回这个对象引用。因此 <code>s3</code> 和 <code>s1</code> 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">"bbb"</span>;</span><br><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被放在堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p></blockquote><h1>六、基本类型与运算</h1><h2>包装类型</h2><p>八个基本类型：</p><ul><li>boolean/1</li><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><p><code>new Integer(123)</code> 与 <code>Integer.valueOf(123)</code> 的区别在于，<code>new Integer(123)</code> 每次都会新建一个对象，而 <code>Integer.valueOf(123)</code> 可能会使用缓存对象，因此多次使用 <code>Integer.valueOf(123)</code> 会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 <code>valueOf()</code> 方法，因此多个 <code>Integer</code> 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>valueOf()</code> 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，<code>Integer</code> 缓存池的大小默认为 -128~127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><blockquote><p><a href="https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123" target="_blank" rel="noopener">Differences between new Integer(123), Integer.valueOf(123) and just 123<br></a></p></blockquote><h2>switch</h2><p>从 Java 7 开始，可以在 <code>switch</code> 条件判断语句中使用 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 不支持 <code>long</code>，是因为 <code>swicth</code> 的设计初衷是为那些只需要对少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Condition详解</title>
      <link href="/2019/02/15/thread/Condition%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/15/thread/Condition%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>在<a href="http://fourcolor.oursnail.cn/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">线程间通信方式总结</a>中有一个需求：轮流打印奇数和偶数，我们用wait和notify实现了一下，但是这种方式存在弊端，就是不能精确控制唤醒哪个线程，比如现在有一个需求是轮流打印ABC该怎么办呢？</p><a id="more"></a><p>首先准备三个线程，分别执行打印方法，是一个死循环，每次休息一秒。</p><p><img src="http://bloghello.oursnail.cn/thread16-1.jpg" alt="image"></p><h2>一、wait/notify实现轮流打印ABC三个字母</h2><p>如果是不加任何控制策略的话，必然是无法保证按照<code>A</code> <code>B</code> <code>C</code>的顺序依次循环执行的，比如：</p><p><img src="http://bloghello.oursnail.cn/thread16-2.jpg" alt="image"></p><p>执行结果是：</p><p>1694620367</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么如何保证按照我们这个顺序执行呢？如果还是沿用这个方法，只能这样写：</p><p><img src="http://bloghello.oursnail.cn/thread16-3.jpg" alt="image"></p><p>思想也很简单，就是搞一个变量，规定只有0的时候才打印<code>A</code>，只有1的时候才打印<code>B</code>，只有2的时候才打印<code>C</code>。那么，对于打印<code>A</code>的线程，只要不是0就<code>wait()</code>等待，一旦等于0就打印，并且加一；对于打印<code>B</code>的线程，只要不是1就<code>wait()</code>等待，一旦等于1就打印，并且加一。剩下同理。</p><p>这样，由于<code>signal</code>是一个成员变量，初始值为0.那么三个线程中<code>PrintB</code>和<code>PrintC</code>都等待，只有<code>PrintA</code>能执行打印，然后加为1，唤醒所有等待的线程来判断，此时打印<code>A</code>的线程和打印<code>C</code>的线程发现都不符合他们打印的条件，都进入了<code>while</code>中等待了，只有打印<code>B</code>的线程发现等于1，则不进入<code>while</code>循环，打印再加一。依次反复，可以得到顺序打印的<code>A</code>、<code>B</code>、<code>C</code>。</p><p>这种方式显然很不好，是靠<code>notifyAll</code>来唤醒所有线程来实现的，那么我们能不能唤醒指定的线程呢？这样处理起来更加优雅效率也会更高！</p><h2>二、Condition来实现</h2><p><img src="http://bloghello.oursnail.cn/thread16-4.jpg" alt="image"></p><p>达到了上面一样的效果。此时，我们发现它的强大之处在于我们可以指定哪个线程唤醒了，这看起来是一点点进步，但是我们学习多线程那么长时间了，在我看来，是很大的一个进步，因为之前用<code>notify</code>是随机唤醒一个，<code>notifyAll</code>是唤醒全部，总是不能受我们的完全控制，虽然说线程的执行本身就是不确定的，因此不确定性是他们的天生属性，但是在某些场景下我们确实需要一个高效并且优雅的实现可控的方式，所以是很重要的。</p><p>它这种功能可以给我们带来什么呢？下面用它实现一个有界队列。（关于生产者消费者模式，当然也可以用了，写法非常简单，就是对照上面的例子改一下即可。）</p><h2>三、Condition实现有界队列</h2><p>我们已经接触了线程池，它里面涉及队列，有很多种队列，最常见的是<code>ArrayBlockingQueue</code>以及<code>LinkedBlockingQueue</code>，他们的源码中其实也是靠<code>Condition</code>来实现阻塞塞值和阻塞取值的。现在我们也来实现一个比较简单的<code>ArrayBlockingQueue</code>吧！</p><p>首先明确一下队列是<code>FIFO</code>的，即先进先出，那么我们要保证先插入的要先弹出。其次要注意的是当没有元素的时候要阻塞，即等待有元素了才能获取；放入元素也是同理，要等有空位的才能重新放入。</p><p>如何实现以上这种数据结构呢？关于先进的先出来，我们可以用两个指针来实现，一个叫做<code>addIndex</code>，一个叫做<code>removeIndex</code>，初始都是指向第一个元素处。当塞进来一个元素，那么<code>addIndex</code>就自增，当自增到最后一个位置，这个时候数组不一定是满的，因为有可能前面的值已经被取出去了，所以还需要一个变量<code>count</code>来标志是否已经塞满，如果满了就阻塞，否则如果<code>addIndex</code>到最后一个位置，就重新置0.</p><p>对于<code>removeIndex</code>也是相同方向移除，假设最简单的情况，就是长度为5的数组，那么第一个元素放在0位置，第二个元素放在1位置，第三个元素放在2位置，此时要移除，那么第一个元素就是我们要的最先进来的元素，我们将其移除，并且<code>removeIndex</code>加一指向第二个元素。如此反复执行。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指向的是刚入队的元素的下角标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex;</span><br><span class="line">    <span class="comment">//指向的是刚出队的元素后面一个元素的下角标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> removeIndex;</span><br><span class="line">    <span class="comment">//实际元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition putCondition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition getCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化队列的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        myQueue = <span class="keyword">new</span> Object[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列的尾部放入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == myQueue.length)&#123;</span><br><span class="line">            <span class="comment">//说明队列已经满了，需要等待一下，那么放元素的线程就要阻塞住，即等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--队列已满，不能再塞值了，我要阻塞一会...."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                putCondition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明是可以放入元素的</span></span><br><span class="line">        myQueue[addIndex++] = object;</span><br><span class="line">        <span class="keyword">if</span>(addIndex == myQueue.length)&#123;</span><br><span class="line">            addIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素的数量要加一</span></span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功向队列放入一个元素，当前队列元素个数为---"</span>+count);</span><br><span class="line">        System.out.println();</span><br><span class="line">        getCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列的头部获取元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//说明队列已经满了，需要等待一下，那么取元素的线程就要阻塞住，即等待</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--队列已空，不能再取值了，我要阻塞一会...."</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getCondition.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> removeValue = (<span class="keyword">int</span>) myQueue[removeIndex];</span><br><span class="line">        myQueue[removeIndex++] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (removeIndex == myQueue.length)&#123;</span><br><span class="line">            removeIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功从队列获取一个元素，当前队列的元素个数为---"</span>+count);</span><br><span class="line">        putCondition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">return</span> removeValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue myQueue = <span class="keyword">new</span> MyQueue(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PutThread(myQueue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TakeThread(myQueue)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TakeThread(myQueue)).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyQueue myQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PutThread</span><span class="params">(MyQueue myQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myQueue = myQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"成功放入一个元素，元素为："</span>+i);</span><br><span class="line">            myQueue.put(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TakeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyQueue myQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TakeThread</span><span class="params">(MyQueue myQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myQueue = myQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>) myQueue.get();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"成功放入一个元素，元素为："</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>四、Condition原理概述</h2><p>我们在上面的学习中看到，对于一个线程，我们就要准备一个<code>Condition</code>对象，并且还要用可重入锁<code>ReentrantLock</code>来实现加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">public</span> Condition cp = lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> Condition cc = lock.newCondition();</span><br></pre></td></tr></table></figure><p>它的原理是什么呢？</p><p>我们看到，创建一个<code>condition</code>对象是通过<code>lock.newCondition()</code>,而这个方法实际上是会<code>new</code>出一个<code>ConditionObject</code>对象，该类是<code>AQS</code>的一个内部类.</p><p>我们知道在锁机制的实现上，<code>AQS</code>内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，<code>condition</code>内部也是使用同样的方式，内部维护了一个 等待队列，所有调用<code>condition.await</code>方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到<code>ConditionObject</code>中有两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><p>这样我们就可以看出来<code>ConditionObject</code>通过持有等待队列的头尾指针来管理等待队列。主要注意的是<code>Node</code>类复用了在<code>AQS</code>中的<code>Node</code>类。所以理解了<code>AQS</code>就简单了。但是这个队列有一点不同，他是一个单向链表，而<code>AQS</code>中的同步队列式一个双向链表。</p><p><img src="http://bloghello.oursnail.cn/thread16-5.jpg" alt="image"></p><p>同时还有一点需要注意的是：我们可以多次调用<code>lock.newCondition()</code>方法创建多个<code>condition</code>对象，也就是一个<code>lock</code>可以持有多个等待队列。而在之前利用<code>Object</code>的方式实际上是指在对象<code>Object</code>对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的<code>Lock</code>拥有一个同步队列和多个等待队列。示意图如下：</p><p><img src="http://bloghello.oursnail.cn/thread16-6.jpg" alt="image"></p><p>如图所示，<code>ConditionObject</code>是<code>AQS</code>的内部类，因此每个<code>ConditionObject</code>能够访问到<code>AQS</code>提供的方法，相当于每个<code>Condition</code>都拥有所属同步器的引用。</p><p>好了，至此我们已经知道多次调用<code>lock.newCondition()</code>方法创建多个<code>condition</code>对象，并且实际上这个对象就是<code>ConditionObject</code>。AQS维护的同步队列是一个双向链表结构，而这个<code>Condition</code>对象维护的是一个单项链表结构。</p><h2>五、await实现原理</h2><p>当调用<code>condition.await()</code>方法后会使得当前获取<code>lock</code>的线程进入到等待队列，如果该线程能够从<code>await()</code>方法返回的话一定是该线程获取了与<code>condition</code>相关联的<code>lock</code>。<code>await()</code>方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-7.jpg" alt="image"></p><p>在当前线程调用<code>condition.await()</code>方法后，会使得当前线程释放<code>lock</code>然后加入到等待队列中，直至被<code>signal</code>/<code>signalAll</code>后会使得当前线程从等待队列中移至到同步队列中去，直到获得了<code>lock</code>后才会从<code>await</code>方法返回(跳出<code>while</code>循环那就不用继续等待了呗)，或者在等待时被中断会做中断处理。</p><p>所以对于<code>await()</code>方法来说，它实现的功能为：将要等待的线程封装成节点尾插入到等待队列中，然后跟<code>wait</code>一样释放这个等待线程的锁。这些做完了之后还需要<code>while</code>循环判断是否已经在同步队列中，这个<code>isOnsyncQueue</code>是由下面说到的<code>signal</code>方法触发的，由于此时还没有<code>signal</code>所以陷在死循环中出不来，就调用<code>lockSupport.park</code>方法使他进入等待状态；当有<code>signal</code>或者有中断发生的时候，就跳出循环，继续执行，此时如果是<code>signal</code>触发的，就会进入下一个<code>if</code>,那就调用<code>acquireQueue</code>方法，这个方法在我们之前说的<code>AQS</code>中是提及的，主要思想是如果这个节点的前驱节点是<code>head</code>那么就自旋获取锁，否则可能会阻塞。这里已经从大体上说明了这个方法的整体思路，下面继续详细分析分析。</p><p>在这段代码中，我们将知道：</p><ul><li>是怎样将当前线程添加到等待队列中去的？</li><li>释放锁的过程？</li><li>怎样才能从<code>await</code>方法退出？</li></ul><p>第一个问题：是怎样将当前线程添加到等待队列中去的？</p><p><img src="http://bloghello.oursnail.cn/thread16-8.jpg" alt="image"></p><p>这段代码就很容易理解了，将当前节点包装成<code>Node</code>，如果等待队列的<code>firstWaiter</code>为<code>null</code>的话（等待队列为空队列），则将<code>firstWaiter</code>指向当前的<code>Node</code>,否则，更新<code>lastWaiter</code>(尾节点)即可。就是通过尾插入的方式将当前线程封装的<code>Node</code>插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前我们学习<code>AQS</code>时知道同步队列是一个带头结点的链式队列，这是两者的一个区别。将当前节点插入到等待队列之后，会使当前线程释放<code>lock</code>，由<code>fullyRelease</code>方法实现，<code>fullyRelease</code>源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-9.jpg" alt="image"></p><p>调用<code>AQS</code>的模板方法<code>release</code>方法释放<code>AQS</code>的同步状态(这样也说明了退出<code>await</code>方法必须是已经获得了<code>condition</code>引用（关联）的<code>lock</code>)并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。到目前为止，这两段代码已经解决了前面的两个问题的答案了，还剩下第三个问题，怎样从<code>await</code>方法退出？现在回过头再来看<code>await</code>方法有这样一段逻辑：</p><p><img src="http://bloghello.oursnail.cn/thread16-10.jpg" alt="image"></p><p>很显然，当线程第一次调用<code>condition.await()</code>方法时，会进入到这个<code>while()</code>循环中，因为判断的条件是这个线程是否在同步队列中，我们这个刚进等待队列，咋可能在同步队列。</p><p>然后通过<code>LockSupport.park(this)</code>方法使得当前线程进入等待状态，那么要想退出这个<code>await</code>方法第一个前提条件自然而然的是要先退出这个<code>while</code>循环，出口就只剩下两个地方：</p><ol><li>逻辑走到<code>break</code>退出<code>while</code>循环；</li><li><code>while</code>循环中的逻辑判断为<code>false</code>。</li></ol><p>再看代码出现第1种情况的条件是当前等待的线程被中断后代码会走到<code>break</code>退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的<code>condition</code>的<code>signal</code>或者<code>signalAll</code>方法），<code>while</code>中逻辑判断为<code>false</code>后结束<code>while</code>循环。</p><p>总结下，就是当前线程被中断或者调用<code>condition.signal</code>/<code>condition.signalAll</code>方法当前节点移动到了同步队列后 ，这是当前线程退出<code>await</code>方法的前提条件。</p><p>当退出<code>while</code>循环后就会调用<code>acquireQueued(node, savedState)</code>，这个方法在介绍AQS的底层实现时说过了，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到<code>lock</code>）。</p><p><code>await</code>方法示意图如下图：</p><p><img src="http://bloghello.oursnail.cn/thread16-11.jpg" alt="image"></p><p>如图，调用<code>condition.await</code>方法的线程必须是已经获得了<code>lock</code>，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的<code>Node</code>尾插入到等待队列中。</p><p>此外，<code>await</code>也支持超时等待和不响应中断，这里不再赘述。</p><h2>六、signal/signalAll实现原理</h2><p>调用<code>condition</code>的<code>signal</code>或者<code>signalAll</code>方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得<code>lock</code>。按照等待队列是先进先出（<code>FIFO</code>）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用<code>condition</code>的<code>signal</code>方法是将头节点移动到同步队列中。</p><p><img src="http://bloghello.oursnail.cn/thread16-12.jpg" alt="image"></p><p><code>signal</code>方法首先会检测当前线程是否已经获取<code>lock</code>，如果没有获取<code>lock</code>会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的<code>doSignal</code>方法也是基于该节点。下面我们来看看<code>doSignal</code>方法做了些什么事情，<code>doSignal</code>方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-13.jpg" alt="image"></p><p>具体逻辑请看注释，真正对头节点做处理的逻辑在<code>transferForSignal</code>中，该方法源码为：</p><p><img src="http://bloghello.oursnail.cn/thread16-14.jpg" alt="image"></p><p>关键逻辑请看注释，这段代码主要做了两件事情1.将头结点的状态更改为<code>CONDITION</code>；2.调用<code>enq</code>方法，将该节点尾插入到同步队列中，关于<code>enq</code>方法请看<code>AQS</code>的底层实现这篇文章。现在我们可以得出结论：调用<code>condition</code>的<code>signal</code>的前提条件是当前线程已经获取了<code>lock</code>，该方法会使得等待队列中的头节点即等待时间最长的那个节点移入到同步队列，而移入到同步队列后才有机会使得等待线程被唤醒，即从<code>await</code>方法中的<code>LockSupport.park(this)</code>方法中返回，从而才有机会使得调用<code>await</code>方法的线程成功退出，此时就要回过头去再看看<code>await</code>方法的后续处理流程了。<code>signal</code>执行示意图如下图：</p><p><img src="http://bloghello.oursnail.cn/thread16-15.jpg" alt="image"></p><p><code>sigllAll</code>与<code>sigal</code>方法的区别体现在<code>doSignalAll</code>方法上，前面我们已经知道<code>doSignal</code>方法只会对等待队列的头节点进行操作，而<code>doSignalAll</code>只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用<code>condition.await()</code>方法的每一个线程。</p><p>整理自：<a href="https://juejin.im/post/5aeea5e951882506a36c67f0" target="_blank" rel="noopener">详解Condition的await和signal等待/通知机制</a></p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实现生产者消费者模式</title>
      <link href="/2019/02/13/thread/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/02/13/thread/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>无论是面试还是工作中，生产者和消费者模式一直是一个比较常见的问题，今天，我们用各种方式来实现它。</p><a id="more"></a><h2>前言</h2><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p><p><img src="http://bloghello.oursnail.cn/thread11-1.jpg" alt="image"></p><h2>一、wait/notify/notifyAll实现</h2><p>有一个天猫小店专门负责生产商品，用户也可以去买商品：</p><p><img src="http://bloghello.oursnail.cn/thread15-1.jpg" alt="image"></p><p>一个生产者的线程：</p><p><img src="http://bloghello.oursnail.cn/thread15-2.jpg" alt="image"></p><p>同理，一个消费者的线程：</p><p><img src="http://bloghello.oursnail.cn/thread15-3.jpg" alt="image"></p><p>下面进行测试：</p><p><img src="http://bloghello.oursnail.cn/thread15-4.jpg" alt="image"></p><p>此时的结果为：</p><p><img src="http://bloghello.oursnail.cn/thread15-5.jpg" alt="image"></p><p>由于生产大于消费，造成产能过剩。</p><h2>二、阻塞队列实现</h2><p>这个的实现已经在<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/" target="_blank" rel="noopener">JUC组件拓展-BlockingQueue</a>中实现了。不再赘述。主要就是用到阻塞的<code>put()</code>和<code>take()</code>两个方法。</p><h2>三、condition+Lock实现</h2><p>这个也很简单，就是基于<code>wait</code>和<code>notify</code>的代码稍微改一下即可。</p><p><img src="http://bloghello.oursnail.cn/thread15-7.jpg" alt="image"></p><p>生产者改为：</p><p><img src="http://bloghello.oursnail.cn/thread15-8.jpg" alt="image"></p><p>消费者跟生产者一样的改法：</p><p><img src="http://bloghello.oursnail.cn/thread15-9.jpg" alt="image"></p><p>执行效果类似。关于<code>Condition</code>接口，在<a href="">Condition详解</a>这篇文章中进行了详细介绍。</p><p>其实还有一些其他的方式也可以实现生产者消费者模型，但是我觉得最核心的就是上面讲的三种，掌握这个就不慌了。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程间通信方式总结</title>
      <link href="/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>在前面的文章中已经介绍了wait和notify的基本知识，我们知道了他们都是Object这个基类中的方法，因此每个对象都天生拥有这两个方法，可见其重要性，在多线程的学习中，他们两兄弟可以实现线程之间的通信，当然了，还有许多其他的方式实现线程间通信，下面逐一击破。</p><a id="more"></a><h2>一、前言</h2><p>开发中不免会遇到需要所有子线程执行完毕通知主线程处理某些逻辑的场景。或者是线程 A 在执行到某个条件通知线程 B 执行某个操作。</p><h2>二、等待通知机制</h2><p>即用<code>wait</code>+<code>notify</code>来实现。</p><p>案例目标：两个线程交替打印奇偶数，一共100个。注意，这也是阿里的一道面试编程题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoThreadWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TwoThreadWaitNotify twoThreadWaitNotify = <span class="keyword">new</span> TwoThreadWaitNotify();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintOdd(twoThreadWaitNotify)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PrintEven(twoThreadWaitNotify)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印奇数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOdd</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify twoThreadWaitNotify;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintOdd</span><span class="params">(TwoThreadWaitNotify twoThreadWaitNotify)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.twoThreadWaitNotify = twoThreadWaitNotify;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(twoThreadWaitNotify.count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!twoThreadWaitNotify.flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"奇数线程开始执行，打印："</span>+twoThreadWaitNotify.count);</span><br><span class="line">                        twoThreadWaitNotify.count++;</span><br><span class="line">                        twoThreadWaitNotify.flag = <span class="keyword">true</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印偶数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintEven</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TwoThreadWaitNotify twoThreadWaitNotify;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PrintEven</span><span class="params">(TwoThreadWaitNotify twoThreadWaitNotify)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.twoThreadWaitNotify = twoThreadWaitNotify;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(twoThreadWaitNotify.count &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TwoThreadWaitNotify.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(twoThreadWaitNotify.flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"偶数线程开始执行，打印："</span>+twoThreadWaitNotify.count);</span><br><span class="line">                        twoThreadWaitNotify.count++;</span><br><span class="line">                        twoThreadWaitNotify.flag = <span class="keyword">false</span>;</span><br><span class="line">                        TwoThreadWaitNotify.class.notify();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TwoThreadWaitNotify.class.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果部分截图：</p><p><img src="http://bloghello.oursnail.cn/thread10-2.jpg" alt="image"></p><p>这里的线程 <code>A</code> 和线程 <code>B</code> 都对同一个对象 <code>TwoThreadWaitNotify.class</code> 获取锁，<code>A</code> 线程调用了同步对象的 <code>wait()</code> 方法释放了锁并进入 <code>WAITING</code> 状态。</p><p><code>B</code> 线程调用了 <code>notify()</code> 方法，这样 <code>A</code> 线程收到通知之后就可以从 <code>wait()</code> 方法中返回。</p><p>这里利用了 <code>TwoThreadWaitNotify.class</code> 对象完成了通信。</p><p>有一些需要注意:</p><ul><li><code>wait()</code> 、<code>notify()</code>、<code>notifyAll()</code> 调用的前提都是获得了对象的锁(也可称为对象监视器)。</li><li>调用 <code>wait()</code> 方法后线程会释放锁，进入<code>WAITING</code> 状态，该线程也会被移动到等待队列中。</li><li>调用 <code>notify()</code> 方法会将等待队列中的线程移动到同步队列中，线程状态也会更新为 <code>BLOCKED</code></li><li>从 <code>wait()</code> 方法返回的前提是调用 <code>notify()</code> 方法的线程释放锁，<code>wait()</code> 方法的线程获得锁。</li></ul><p><strong>⭐等待通知有着一个经典范式：</strong></p><p>线程 A 作为消费者：</p><ol><li>获取对象的锁。<br>2.进入 while(判断条件)，并调用 wait() 方法。</li><li>当条件满足跳出循环执行具体处理逻辑。</li></ol><p>线程 B 作为生产者:</p><ol><li>获取对象锁。</li><li>更改与线程 A 共用的判断条件。</li><li>调用 notify() 方法。</li></ol><p>伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Thread A</span><br><span class="line"></span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    while(条件)&#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Thread B</span><br><span class="line">synchronized(Object)&#123;</span><br><span class="line">    条件=false;//改变条件</span><br><span class="line">    Object.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、Join方式</h2><p><img src="http://bloghello.oursnail.cn/thread14-1.jpg" alt="image"></p><p>这个之前也是提及过的，主要是可以打断主线程让子线程先执行完，但是缺点是粒度不够细腻，我不能控制子线程在某个点停一下让其他子线程执行。</p><p><img src="http://bloghello.oursnail.cn/thread14-2.jpg" alt="image"></p><p>核心逻辑:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>join</code> 线程完成后会调用 <code>notifyAll()</code> 方法，是在 <code>JVM</code> 实现中调用，所以这里看不出来。</p><h2>四、volatile 共享内存</h2><p>因为 Java 是采用共享内存的方式进行线程通信的，所以可以采用以下方式用主线程关闭 A 线程:</p><p><img src="http://bloghello.oursnail.cn/thread14-3.jpg" alt="image"></p><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A正在运行。。。</span><br><span class="line">thread A执行完毕</span><br></pre></td></tr></table></figure><p>这里的 <code>flag</code> 存放于主内存中，所以主线程和线程 <code>A</code> 都可以看到。<code>flag</code> 采用 <code>volatile</code> 修饰主要是为了内存可见性。</p><h2>五、CountDownLatch 并发工具</h2><p>在前面的<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">文章</a>中我们基本知道它的使用，但是很遗憾，没有找一个比较实际的场景来描述它的功能，下面我将以一个实际场景来用<code>CountDownLatch</code>来解决这个问题。</p><p>假设小明和小红是一对夫妻，他们两准备烧一个菜，就叫做青椒炒肉丝。我们知道，要想炒出青椒炒肉丝，需要切好青椒，然后切好肉丝，如果想要肉的质感爽嫩，需要用淀粉揉一揉，加点醋，加点料酒去去腥，并且弄好了之后需要先炒一下肉。最后两样都准备好之后：即切好的青椒和预热好的肉丝，那么就可以合在一起炒一下出锅了。</p><p>假设切青椒需要3分钟，准备好肉需要5分钟，这两个同时准备好之后就可以进行烧菜了。如何最大程度上提高效率呢？</p><p>显然，就是小明切青椒，小红搞肉丝，两个人并行。这个时候，我们可以用<code>CountDownLatch</code>来模拟这个场景。</p><p>切青椒线程：</p><p><img src="http://bloghello.oursnail.cn/thread14-4.jpg" alt="image"></p><p>准备肉丝的线程：</p><p><img src="http://bloghello.oursnail.cn/thread14-5.jpg" alt="image"></p><p>测试：</p><p><img src="http://bloghello.oursnail.cn/thread14-6.jpg" alt="image"></p><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小明开始切青椒...</span><br><span class="line">小红开始准备肉丝...</span><br><span class="line">小明切好青椒了...</span><br><span class="line">小红准备好肉丝了...</span><br><span class="line">over，食材全部准备好了，一起下锅 cost:5010</span><br></pre></td></tr></table></figure><p>这里突出的就是，主线程等待两个线程都执行完了才能继续执行。</p><p><code>CountDownLatch</code> 也是基于 <code>AQS</code>(<code>AbstractQueuedSynchronizer</code>) 实现的.</p><ul><li>初始化一个 <code>CountDownLatch</code> 时告诉并发的线程，然后在每个线程处理完毕之后调用 <code>countDown()</code> 方法。</li><li>该方法会将 <code>AQS</code> 内置的一个 <code>state</code> 状态 -1 。</li><li>最终在主线程调用 <code>await()</code> 方法，它会阻塞直到 <code>state == 0</code> 的时候返回。</li></ul><p>这个功能是不是很类似于上面的<code>join</code>，但是它比<code>join</code>灵活多了。</p><h2>六、CyclicBarrier 并发工具</h2><p>这个工具类从原理上来看与<code>CountDownLatch</code>非常类似，具体的使用可以看<a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">AQS实现的一些同步组件介绍</a>。他们两是有区别的。该工具可以实现 <code>CountDownLatch</code> 同样的功能，但是要更加灵活。甚至可以调用 <code>reset()</code> 方法重置 <code>CyclicBarrier</code> (需要自行捕获 <code>BrokenBarrierException</code> 处理) 然后重新执行。就不再赘述了。</p><h2>七、线程响应中断</h2><p>这个我们之前也是提过的，就是<code>interrupt</code>来实现，线程方法里面用<code>while</code>不停地判断中断标志位从而达到自主中断的目的。</p><p><img src="http://bloghello.oursnail.cn/thread14-7.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread A运行中。。</span><br><span class="line">thread A运行中。。</span><br><span class="line">thread A退出。。</span><br></pre></td></tr></table></figure><p>可以采用中断线程的方式来通信，调用了 <code>thread.interrupt()</code> 方法其实就是将 <code>thread</code> 中的一个标志属性置为了 <code>true</code>。</p><p>并不是说调用了该方法就可以中断线程，如果不对这个标志进行响应其实是没有什么作用(这里对这个标志进行了判断)。</p><p>但是如果抛出了 <code>InterruptedException</code> 异常，该标志就会被 <code>JVM</code> 重置为 <code>false</code>。</p><h2>八、线程池 awaitTermination() 方法</h2><p>这个玩意与我们知道<code>shutdown</code>方法组合使用，我们知道，调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p><p>关于<code>awaitTermination()</code>方法，接收<code>timeout</code>和<code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回<code>true</code>，否则返回<code>false</code>.因此，在<code>shutdwon</code>之后，我们可以用<code>awaitTermination()</code>不断地监测剩下的线程的执行状态，执行完毕就可以执行主线程了。</p><p><img src="http://bloghello.oursnail.cn/thread14-8.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-2] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 20:18:01.273 [pool-1-thread-1] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 20:18:02.273 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:03.278 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。</span><br><span class="line">2018-03-16 20:18:04.278 [main] INFO  c.c.actual.ThreadCommunication - main over</span><br></pre></td></tr></table></figure><p>最后再强调一下：</p><p>使用这个 <code>awaitTermination()</code> 方法的前提需要关闭线程池，如调用了 <code>shutdown()</code> 方法。</p><p>调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p><h2>九、管道通信</h2><p>这个方式我见到的比较少，了解一下。</p><p><img src="http://bloghello.oursnail.cn/thread14-9.jpg" alt="image"></p><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2018-03-16 19:56:43.014 [Thread-0] INFO  c.c.actual.ThreadCommunication - running</span><br><span class="line">2018-03-16 19:56:43.014 [Thread-1] INFO  c.c.actual.ThreadCommunication - running2</span><br><span class="line">2018-03-16 19:56:43.130 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=0</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=1</span><br><span class="line">2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=2</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=3</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=4</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=5</span><br><span class="line">2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=6</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=7</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=8</span><br><span class="line">2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=9</span><br></pre></td></tr></table></figure><p>Java 虽说是基于内存通信的，但也可以使用管道通信。</p><p>需要注意的是，输入流和输出流需要首先建立连接。这样线程 B 就可以收到线程 A 发出的消息了。</p><h2>十、总结</h2><p>实际开发中可以灵活根据需求选择最适合的线程通信方式。</p><p>整理自：<a href="https://crossoverjie.top/JCSprout/#/thread/thread-communication?id=%e7%ba%bf%e7%a8%8b%e6%b1%a0-awaittermination-%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">深入理解线程通信</a></p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC组件拓展-BlockingQueue</title>
      <link href="/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/"/>
      <url>/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/</url>
      <content type="html"><![CDATA[<p>在之前的线程池原理介绍中，我们了解到在核心线程被全部占用并且没有空闲线程的时候，就会把后续的线程任务先放入一个队列结构中，然后按照队列的方式去消化任务。虽然队列有很多种，但是他们都有一个共同的名字叫做阻塞队列，本文来逐个击破揭开他们的面纱。</p><a id="more"></a><h2>一、BlockingQueue</h2><p>在Java中，<code>BlockingQueue</code>是一个接口，它的实现类有<code>ArrayBlockingQueue</code>、<code>DelayQueue</code>、 <code>LinkedBlockingDeque</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>、<code>SynchronousQueue</code>等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于<code>take</code>与<code>put</code>操作的原理，却是类似的。</p><p><img src="http://bloghello.oursnail.cn/BlockingQueue%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86" alt="image"></p><p><code>BlockingQueue</code> 是一个先进先出的队列（<code>Queue</code>），为什么说是阻塞（<code>Blocking</code>）的呢？是因为 <code>BlockingQueue</code> 支持当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。</p><p><img src="http://bloghello.oursnail.cn/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="image"></p><ul><li><code>add(anObject)</code>:把<code>anObject</code>加到<code>BlockingQueue</code>里,即如果<code>BlockingQueue</code>可以容纳,则返回true,否则抛出异常</li><li><code>offer(anObject)</code>:表示如果可能的话,将<code>anObject</code>加到<code>BlockingQueue</code>里,即如果<code>BlockingQueue</code>可以容纳,则返回true,否则返回false.</li><li>⭐<code>put(anObject)</code>:把<code>anObject</code>加到<code>BlockingQueue</code>里,如果<code>BlockQueue</code>没有空间,则调用此方法的线程被阻断直到<code>BlockingQueue</code>里面有空间再继续.</li><li>⭐与<code>put</code>相对应的是<code>take()</code>:取走<code>BlockingQueue</code>里排在首位的对象,若<code>BlockingQueue</code>为空,阻断进入等待状态直到<code>Blocking</code>有新的对象被加入为止</li><li><code>poll(time)</code>:取走<code>BlockingQueue</code>里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null</li></ul><div class="tip">注意：BlockingQueue 不接受 null 元素。试图 add 、 put 或 offer 一个 null  元素时，某些实现会抛出 NullPointerException 。 null 被用作指示 poll  操作失败的警戒值。</div><blockquote><p><code>BlockingQueue</code> 的各个实现都遵循了这些规则，当然我们也不用死记这个表格，知道有这么回事，然后写代码的时候根据自己的需要去看方法的注释来选取合适的方法即可。</p></blockquote><blockquote><p>一个 <code>BlockingQueue</code> 可能是有界的，如果在插入的时候，发现队列满了，那么 <code>put</code> 操作将会阻塞。通常，在这里我们说的无界队列也不是说真正的无界，而是它的容量是 <code>Integer.MAX_VALUE</code>（21亿多）。</p></blockquote><blockquote><p><code>BlockingQueue</code> 实现主要用于生产者-消费者队列，但它另外还支持<code>Collection</code> 接口。因此，举例来说，使用<code>remove(x)</code> 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</p></blockquote><blockquote><p><code>BlockingQueue</code> 的实现都是线程安全的，但是批量的集合操作如 <code>addAll</code>, <code>containsAll</code>, <code>retainAll</code> 和 <code>removeAll</code> 不一定是原子操作。如 <code>addAll(c)</code> 有可能在添加了一些元素后中途抛出异常，此时 <code>BlockingQueue</code> 中已经添加了部分元素，这个是允许的，取决于具体的实现。</p></blockquote><p>下面来看看阻塞队列的各种具体的实现类。</p><h2>二、ArrayBlockingQueue</h2><ul><li>构造函数必须带一个int参数来指明其大小</li><li>一个由数组结构组成的有界阻塞队列.</li><li>此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序.</li><li>⭐其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</li><li>⭐如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。</li><li>⭐如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</li><li>支持公平锁和非公平锁。公平的获取锁，也就是当前等待时间最长的线程先获取锁</li></ul><h2>三、LinkedBlockingQueue</h2><ul><li>大小不定的<code>BlockingQueue</code></li><li>若其构造函数带一个规定大小的参数,生成的<code>BlockingQueue</code>有大小限制</li><li>若不带大小参数,所生成的BlockingQueue的大小由<code>Integer.MAX_VALUE</code>来决定</li><li>其所含的对象是以<code>FIFO</code>(先入先出)顺序排序的</li><li>⭐链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低</li><li>最新插入的数据在尾部，最新移除的对象在头部</li></ul><h2>四、PriorityBlockingQueue</h2><ul><li>⭐类似于<code>LinkedBlockQueue</code>,但其所含对象的排序不是<code>FIFO</code>,而是依据对象的自然排序顺序或者是构造函数的<code>Comparator</code>决定的顺序</li><li>一个无界的阻塞队列</li></ul><h2>五、SynchronousQueue</h2><ul><li>⭐它是一种阻塞队列，其中每个 <code>put</code> 必须等待一个 <code>take</code>，反之亦然。</li><li>⭐同步队列没有任何内部容量，甚至连一个队列的容量都没有。</li><li>它是线程安全的，是阻塞的。</li><li>不允许使用 <code>null</code> 元素。</li><li>公平排序策略是指调用 <code>put</code> 的线程之间，或 <code>take</code> 的线程之间。</li></ul><p>一个没有容量的并发队列有什么用了？或者说存在的意义是什么？</p><p>尽管元素在<code>SynchronousQueue</code> 内部不会“停留”，但是并不意味着<code>SynchronousQueue</code> 内部没有队列。实际上<code>SynchronousQueue</code> 维护着线程队列，也就是插入线程或者移除线程在不同时存在的时候就会有线程队列。既然有队列，同样就有公平性和非公平性特性，公平性保证正在等待的插入线 程或者移除线程以<code>FIFO</code>的顺序传递资源。</p><p>它模拟的功能类似于生活中一手交钱一手交货这种情形，像那种货到付款或者先付款后发货模型不适合使用<code>SynchronousQueue</code>。首先要知道<code>SynchronousQueue</code>没有容纳元素的能力，即它的<code>isEmpty()</code>方法总是返回true，但是给人的感觉却像是只能容纳一个元素。</p><h2>六、DelayQueue</h2><ul><li><code>DelayQueue</code> 对元素进行持有直到一个特定的延迟到期。注意其中的元素必须实现 <code>java.util.concurrent.Delayed</code> 接口。</li></ul><h2>七、生产者与消费者模式</h2><p>阻塞队列的最常使用的例子就是生产者消费者模式,也是各种实现生产者消费者模式方式中首选的方式。使用者不用关心什么阻塞生产，什么时候阻塞消费，使用非常方便。</p><p><code>LinkedBlockingQueue</code>来实现一个生产者与消费者模型：</p><p><img src="http://bloghello.oursnail.cn/thread13-1.png" alt="image"></p><p>运行效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">producer1 produce 95</span><br><span class="line">producer3 produce 36</span><br><span class="line">consumer0 consumer 95</span><br><span class="line">consumer2 consumer 36</span><br><span class="line">producer0 produce 27</span><br><span class="line">consumer4 consumer 27</span><br><span class="line">producer2 produce 75</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2>八、ArrayBlockingQueue和LinkedBlockingQueue的区别</h2><ul><li>队列中锁的实现不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；另外，可以指定是否为公平锁，默认是非公平锁。</p><p><code>LinkedBlockingQueue</code>实现的队列中的锁是分离的，在队头和队尾各持有一把锁，入队和出队之间不存在竞争。即生产用的是<code>putLock</code>，消费是<code>takeLock</code>，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p></blockquote><ul><li>在生产或消费时操作不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；</p><p><code>LinkedBlockingQueue</code>实现的队列中在生产和消费的时候，需要把枚举对象转换为<code>Node&lt;E&gt;</code>进行插入或移出(会生成一个额外的<code>Node</code>对象，这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。)</p></blockquote><ul><li>队列大小初始化方式不同</li></ul><blockquote><p><code>ArrayBlockingQueue</code>实现的队列中必须指定队列的大小；</p><p><code>LinkedBlockingQueue</code>实现的队列中可以不指定队列的大小，但是默认是<code>Integer.MAX_VALUE</code></p></blockquote><ul><li>作为开发者，我们需要注意的是，如果构造一个<code>LinkedBlockingQueue</code>对象，而没有指定其容量大小，<code>LinkedBlockingQueue</code>会默认一个类似无限大小的容量（<code>Integer.MAX_VALUE</code>），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</li><li>在使用<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>分别对1000000个简单字符做入队操作时，<code>LinkedBlockingQueue</code>的消耗是<code>ArrayBlockingQueue</code>消耗的10倍左右，即<code>LinkedBlockingQueue</code>消耗在1500毫秒左右，而<code>ArrayBlockingQueue</code>只需150毫秒左右。</li><li>按照实现原理来分析，<code>ArrayBlockingQueue</code>完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。<code>Doug Lea</code>之所以没这样去做，也许是因为<code>ArrayBlockingQueue</code>的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC组件拓展-ForkJoin简介</title>
      <link href="/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-ForkJoin%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-ForkJoin%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>JUC组件拓展-ForkJoin简介，本文只是初步认识认识一下ForkJoin是什么，不深究里面的原理。</p><a id="more"></a><h2>ForkJoin</h2><h4>什么是Fork/Join框架</h4><p><code>Fork/Join</code>框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>我们再通过<code>Fork</code>和<code>Join</code>这两个单词来理解下<code>Fork/Join</code>框架，<code>Fork</code>就是把一个大任务切分为若干子任务并行的执行，<code>Join</code>就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+。。＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。</p><p><img src="http://bloghello.oursnail.cn/ForkJoin%E6%A8%A1%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="image"></p><h4>工作窃取算法</h4><p>工作窃取（<code>work-stealing</code>）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：</p><p><img src="http://bloghello.oursnail.cn/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt="image"></p><ul><li>那么为什么需要使用工作窃取算法呢？</li></ul><blockquote><p>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></blockquote><ul><li><code>Fork/Join</code>框架如何实现工作窃取的？</li></ul><blockquote><p>这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p></blockquote><ul><li><code>Fork/Join</code>框架有没有什么缺点？</li></ul><blockquote><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></blockquote><ul><li>该如何设计一个<code>Fork/Join</code>框架?</li></ul><blockquote><p>第一步分割任务。首先我们需要有一个<code>fork</code>类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</p><p>第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p></blockquote><p>这里就先简单介绍一下，如果有必要，以后再细谈。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AQS实现的一些并发工具类</title>
      <link href="/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>在前面我们已经深入了解了AQS原理，本节介绍几个常用的基于AQS实现的并发工具类。</p><a id="more"></a><h2>一、CountDownLatch</h2><p>计数器减到0，处于等待的线程才会继续执行。只能用一次，不能重置。</p><p>比如有一个运算量很大的任务，我们可以将它拆分为多个子任务，等所有子任务全部完成之后，再执行最后的汇总工作。</p><p><img src="http://bloghello.oursnail.cn/CountDownLatch.png" alt="image"></p><p>下面用一个实例来看看它是如何使用的：</p><p><img src="http://bloghello.oursnail.cn/thread12-1.jpg" alt="image"></p><p>运行结果，截取了最后一点：</p><p><img src="http://bloghello.oursnail.cn/thread12-2.jpg" alt="image"></p><p>我们可以看到，主程序等待所有的子程序执行完毕，再执行，它是通过<code>await()</code>阻塞等待，直到计数器的值减到0为止。</p><p>那如果是这种场景呢：计算若干个子任务，给定一个时间，超过这个时间的话，就把这个任务放弃掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h2>二、Semaphore</h2><p>能控制同一时间并发线程的数目</p><blockquote><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。很多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-14/16690827.jpg" alt="image"></p><p><code>Semaphore</code>可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用<code>Semaphore</code>来做流控，代码如下：</p><p><img src="http://bloghello.oursnail.cn/thread12-3.jpg" alt="image"></p><p>再来一个例子：</p><p><img src="http://bloghello.oursnail.cn/thread12-4.jpg" alt="image"></p><blockquote><p>这里是一个线程获取一个许可，那么同一时间，可以有三个线程进来一起工作。那如果我改成一个线程获取三个许可呢？就像一个人同时占三个坑位，那么只有等这个人拉完了才能轮到下一个人了，那么此时就变成跟单线程一样了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">3</span>);</span><br><span class="line">test(threadNum);</span><br><span class="line">semaphore.release(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>考虑这个场景：并发太高了，就算是控制线程数量，也比较棘手；一个厕所三个坑位，外面人太多了，让三个人进来，其他的都给轰走。如何做到呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(semaphore.tryAcquire())&#123;<span class="comment">//尝试获取一个许可</span></span><br><span class="line">    test(threadNum);</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：只有三条信息打印出来，其他的线程就都被丢弃了。</p><p>也可以给他一个超时时间，这里是5000毫秒。每个命令需要运行1000毫秒，那么程序等1000毫秒之后会打印三条；然后再等1000毫秒，又可以拿到新的三个许可，再打印三条；直到5000毫秒用完。可能会打印3*5条记录。剩下的5条记录由于已经超时，全部被放弃掉。</p><h2>三、CyclicBarrier</h2><blockquote><p><code>CyclicBarrier</code>也是一个同步辅助类 , 它允许一组线程相互等待 , 直到到达某个公共的屏障点 , 通过它可以完成多个线程之间相互等待 ,只有当每个线程都准备好之后, 才能各自继续往下执行后续的操作, 和 <code>CountDownLatch</code>相似的地方就是, 它也是通过计数器来实现的. 当某个线程调用了 <code>await()</code>方法之后, 该线程就进入了等待状态 . 而且计数器就进行 -1 操作 , 当计数器的值达到了我们设置的初始值0的时候 , 之前调用了<code>await()</code> 方法而进入等待状态的线程会被唤醒继续执行后续的操作. 因为 <code>CyclicBarrier</code>释放线程之后可以重用, 所以又称之为循环屏障 . <code>CyclicBarrier</code> 使用场景和  <code>CountDownLatch</code> 很相似 , 可以用于多线程计算数据, 最后合并计算结果的应用场景 .</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-14/65784628.jpg" alt="image"></p><p>两者的区别：</p><ul><li><p><code>CountDownLatch</code>的计数器只能使用一次 , 而 <code>CyclicBarrier</code> 的计数器可以使用 <code>reset</code>重置 循环使用</p></li><li><p><code>CountDownLatch</code> 主要是 1 个 或者 n 个线程需要等待其它线程完成某项操作之后才能继续往下执行 , 其描述的是 1 个 或者 n 个线程与其它线程的关系 ; CyclicBarrier 主要是实现了 1 个或者多个线程之间相互等待,直到所有的线程都满足条件之后, 才执行后续的操作 , 其描述的是内部各个线程相互等待的关系 .</p></li></ul><p><code>CyclicBarrier</code> 假如有 5 个线程都调用了 <code>await()</code> 方法 , 那这个 5 个线程就等着 , 当这 5 个线程都准备好之后, 它们有各自往下继续执行 , 如果这 5 个线程在后续有一个计算发生错误了 , 这里可以重置计数器 , 并让这 5 个线程再执行一遍 .</p><p><img src="http://bloghello.oursnail.cn/thread12-5.jpg" alt="image"></p><p>运行效果：先每隔一秒执行<code>race</code>方法打印出<code>ready</code>,等3个线程打印完毕，立即都将阻塞的<code>log.info(&quot;continue...&quot;);</code>全部打印出来。</p><p><img src="http://bloghello.oursnail.cn/thread12-6.jpg" alt="image"></p><p>也可以设定超时时间，超过时间了就不等了。</p><p><img src="http://bloghello.oursnail.cn/thread12-7.jpg" alt="image"></p><p>如果在大家已经都准备好了的时候，可以先做一件事情，即初始化执行一个线程，可以在声明<code>CyclicBarrier</code>后面增加一个线程来执行。</p><p>就像开会，人都到齐了之后，我们喊一声，人都到齐，我们现在开始开会了啊。下面就开始正式开会。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>,() -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"callback is running..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2>四、Exchanger</h2><p><code>Exchanger</code> 类表示一种会合点，两个线程可以在这里交换对象。两个线程各自调用<code>exchange</code> 方法进行交换，当线程 <code>A</code> 调用 <code>Exchange</code> 对象的 <code>exchange</code> 方法后，它会陷入阻塞状态，直到线程 <code>B</code> 也调用了 <code>exchange</code> 方法，然后以线程安全的方式交换数据，之后线程 <code>A</code> 和 <code>B</code> 继续运行。</p><p><img src="http://bloghello.oursnail.cn/thread12-8.png" alt="image"></p><p><code>exchange</code> 方法有两个重载实现，在交换数据的时候还可以设置超时时间。如果一个线程在超时时间内没有其他线程与之交换数据，就会抛出 <code>TimeoutException</code> 超时异常。如果没有设置超时时间，则会一直等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换数据，并设置超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br><span class="line"><span class="function"><span class="comment">//交换数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>下面看一个小例子：</p><p><img src="http://bloghello.oursnail.cn/thread12-9.png" alt="image"></p><p>我们要注意，交换的时候两个线程要同时到达一个汇合点才会继续执行，即这里的a线程拿到b线程的值并且b拿到a的值，程序才会继续执行。</p><p><img src="http://bloghello.oursnail.cn/thread12-10.png" alt="image"></p><p>例子很简单，当两个线程都到达调用<code>exchange</code>方法的同步点的时候，两个线程就能交换彼此的数据。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程池原理详解</title>
      <link href="/2019/02/12/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/12/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>JAVA帮助开发者封装了一些现成的线程池调用，但是每种线程池都有自己的使用场景，如果不了解里面的原理，那么很容易掉进坑里，线程池原理也是面试的重灾区，因此本问将完整分析线程池的原理。</p><a id="more"></a><h2>一、new thread弊端</h2><p>从学习java多线程开始，我们就学习了用<code>new thread</code>来创建线程。但是他有一定的弊端：</p><ul><li>每次<code>new Thread</code>新建对象，性能差</li><li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，有可能占用过多系统资源导致死机或OOM</li><li>缺少更多功能，如更多执行、定期执行、线程中断</li></ul><h2>二、线程池好处</h2><ul><li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li><li>可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li><li>提供定时执行、定期执行、单线程、并发数控制等功能</li></ul><h2>三、线程池相关参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>corePoolSize</code>:核心线程数量</li></ul><blockquote><p>默认情况下，在创建了线程池后，线程池中的线程数为0，<br>（除非调用<code>prestartAllCoreThreads()</code>和<code>prestartCoreThread()</code>方法，从方法名字可以看出，是预创建线程的意思，即在没有任务到来之前，就创建<code>corePoolSize</code>个线程或1个线程）当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中；</p><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p></blockquote><ul><li><code>maximumPoolSize</code>:线程最大线程数</li></ul><blockquote><p>线程池中的最大线程数，表示线程池中最多能创建多少个线程。</p><p>超过就执行<code>reject</code>策略:如果队列满了,并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务</p></blockquote><ul><li><code>workQueue</code>:阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响，一般有以下几种选择：</li></ul><blockquote><p><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 <code>FIFO</code>（先进先出）原则对元素进行排序；</p><p><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于<code>ArrayBlockingQueue</code>。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列；</p><p><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列；</p><p><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列；底层用<code>DelayedWorkQueue</code>实现。</p></blockquote><ul><li><code>keepAliveTime</code>：线程没有任务执行时最多保持多久时间终止</li></ul><blockquote><p>当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。（但是如果调用了<code>allowCoreThreadTimeOut(boolean value)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0；）</p></blockquote><ul><li><code>unit</code>:<code>keepAliveTime</code>的时间单位</li><li><code>threadFactory</code>：线程工厂，用来创建线程</li></ul><blockquote><p><code>threadFactory</code>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</p></blockquote><ul><li><code>handler</code>:饱和策略</li></ul><blockquote><p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是<code>AbortPolicy</code>，表示无法处理新任务时抛出异常。</p></blockquote><p>这些参数全部传给<code>ThreadPoolExecutor</code>之后，<code>ThreadPoolExecutor</code>就可以为我们提供一个线程池，我们可以对这个线程池提交以及终止线程任务。</p><h2>四、饱和策略</h2><p>当线程池中已经到了完全没有办法再接收新的线程进来的时候，就会启动饱和策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</span><br></pre></td></tr></table></figure><ol><li><code>AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常（默认）</li><li><code>CallerRunsPolicy</code>：只用调用所在的线程运行任务</li><li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li><code>DiscardPolicy</code>：不处理，丢弃掉,不抛出异常。</li></ol><h2>五、线程池的源码解读</h2><p>程序中要声明线程池，是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">exec.excute(Runnable command);</span><br></pre></td></tr></table></figure><p>先来看看<code>ExecutorService</code>其中的奥秘。</p><h5>5.1 ExecutorService和Executor的关系</h5><p><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为<code>void</code>，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>ExecutorService</code>具备管理执行器和任务生命周期的方法，提交任务机制更加完善。<code>Executor</code>只是运行新任务的简单接口，目的是将任务提交和任务执行解耦。</p><h5>5.2 ThreadPoolExecutor重要方法</h5><p>我们知道，在执行<code>Executors.newCachedThreadPool()</code>的时候，内部是调用<code>ThreadPoolExecutor</code>的构造函数来生成<code>Exceutors</code>对象，即生成了线程池，因为继承关系是：<code>ThreadPoolExecutor extends AbstractExecutorService implements ExecutorService extends Executor</code>。构建好之后，就可以构建工作线程去执行任务。其中，流程是这样的：</p><p><img src="http://bloghello.oursnail.cn/thread11-2.jpg" alt="image"></p><p>所以，用于<code>execute()</code>或者<code>submit()</code>的线程任务都是被封装成<code>worker</code>去执行的。下面来看看<code>execute()</code>和<code>submit()</code>等核心方法。</p><p>在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p><ul><li><code>execute()</code></li></ul><blockquote><p><code>execute()</code>方法实际上是<code>Executor</code>中声明的方法，在<code>ThreadPoolExecutor</code>进行了具体的实现，这个方法是<code>ThreadPoolExecutor</code>的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p></blockquote><ul><li><code>submit()</code></li></ul><blockquote><p><code>submit()</code>方法是在<code>ExecutorService</code>中声明的方法,这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code>方法不同，它能够返回任务执行的结果，去看<code>submit()</code>方法的实现，会发现它实际上还是调用的<code>execute()</code>方法，只不过它利用了<code>Future</code>来获取任务执行结果。</p></blockquote><ul><li><code>shutdown()</code><br>将线程池状态置为<code>SHUTDOWN</code>,并不会立即停止：</li></ul><blockquote><p>停止接收外部<code>submit</code>的任务内部正在跑的任务和队列里等待的任务，会执行完等到第二步完成后，才真正停止</p></blockquote><ul><li><code>shutdownNow()</code><br>将线程池状态置为<code>STOP</code>。企图立即停止，事实上不一定：</li></ul><blockquote><p>跟<code>shutdown()</code>一样，先停止接收外部提交的任务忽略队列里等待的任务尝试将正在跑的任务<code>interrupt</code>中断返回未执行的任务列表</p><p>它试图终止线程的方法是通过调用<code>Thread.interrupt()</code>方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有<code>sleep</code> 、<code>wait</code>、<code>Condition</code>、定时锁等应用, <code>interrupt()</code>方法是无法中断当前的线程的。所以，<code>ShutdownNow()</code>并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。但是大多数时候是能立即退出的</p></blockquote><ul><li><code>awaitTermination(long timeOut, TimeUnit unit)</code></li></ul><blockquote><p>接收<code>timeout</code>和<code>TimeUnit</code>两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测<code>ExecutorService</code>是否已经关闭，若关闭则返回<code>true</code>，否则返回<code>false</code>。一般情况下会和<code>shutdown</code>方法组合使用。</p></blockquote><h5>5.3 Executors生成线程池</h5><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>Executors</code>类里面提供了一些静态工厂，生成一些常用的线程池。这个就涉及上面我们反复提及的核心类：<code>ThreadPoolExecutor</code>。</p><p>⭐其实都是通过调用<code>ThreadPoolExecutor</code>来完成的，最后可以返回<code>ExecutorService</code>对象，其实说白了都是<code>Excutor</code>对象。</p><p>下面来分别看看比较常用的线程池。</p><ul><li><code>newSingleThreadExecutor</code></li></ul><blockquote><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为1的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="comment">//线程由DefaultThreadFactory默认创建，有统一的命名规范，并且优先级是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                               <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                               <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                               threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:10,index:1</span><br><span class="line">task:10,index:2</span><br><span class="line">task:10,index:3</span><br><span class="line">task:10,index:4</span><br><span class="line">task:10,index:5</span><br><span class="line">task:10,index:6</span><br><span class="line">task:10,index:7</span><br><span class="line">task:10,index:8</span><br><span class="line">task:10,index:9</span><br></pre></td></tr></table></figure><p>运行结果分析：单线程+有序。</p><ul><li><code>newFixedThreadPool</code></li></ul><blockquote><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个核心线程个数和最大线程个数都为nThreads的线程池</span></span><br><span class="line"><span class="comment">//阻塞队列长度为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//keeyAliveTime=0说明只要线程个数比核心线程个数多并且当前空闲则回收</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:11,index:1</span><br><span class="line">task:11,index:3</span><br><span class="line">task:11,index:4</span><br><span class="line">task:11,index:5</span><br><span class="line">task:11,index:6</span><br><span class="line">task:11,index:7</span><br><span class="line">task:11,index:8</span><br><span class="line">task:11,index:9</span><br><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br></pre></td></tr></table></figure><p>结果分析：只创建了三个线程来执行。</p><ul><li><code>newCachedThreadPool</code></li></ul><blockquote><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个按需创建线程的线程池，初始线程个数为0，最多线程个数为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为同步队列</span></span><br><span class="line"><span class="comment">//keeyAliveTime=60说明只要当前线程60s内空闲则回收</span></span><br><span class="line"><span class="comment">//特殊在于加入到同步队列的任务会被马上被执行，同步队列里面最多只有一个任务，并且存在后马上会拿出执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用自己的线程工厂来创建线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                 <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">"task:&#123;&#125;,index:&#123;&#125;"</span>,Thread.currentThread().getId(),index);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task:10,index:0</span><br><span class="line">task:12,index:2</span><br><span class="line">task:14,index:4</span><br><span class="line">task:16,index:6</span><br><span class="line">task:18,index:8</span><br><span class="line">task:11,index:1</span><br><span class="line">task:13,index:3</span><br><span class="line">task:15,index:5</span><br><span class="line">task:17,index:7</span><br><span class="line">task:19,index:9</span><br></pre></td></tr></table></figure><p>结果分析：按需创建线程，几乎一次循环就创建了一个新的线程来执行。</p><ul><li><code>newScheduledThreadPool</code></li></ul><blockquote><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多长时间之后执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时执行，这里是每隔3秒执行一次</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        exec.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">"schedule run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);<span class="comment">//一开始延迟1秒执行任务，之后每隔3秒执行一次任务，不适合调用exec.shutdown();，因为会被关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>newSingleThreadScheduledExecutor</code></li></ul><blockquote><p>创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个最小线程个数corePoolSize为1，最大为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">//阻塞队列为DelayedWorkQueue的线程池。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">       (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上。demo不再赘述。</p><h5>5.4  线程池实现原理–线程池状态</h5><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" alt="image"></p><ul><li><code>static final int RUNNING = 0;</code></li></ul><blockquote><p>当创建线程池后，初始时，线程池处于RUNNING状态；</p></blockquote><ul><li><code>static final int SHUTDOWN = 1;</code></li></ul><blockquote><p>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p></blockquote><ul><li><code>static final int STOP = 2;</code></li></ul><blockquote><p>如果调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p></blockquote><ul><li><code>static final int TERMINATED = 3;</code></li></ul><blockquote><p>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</p></blockquote><h5>6.5 线程池实现原理–任务的执行</h5><p><code>corePoolSize</code>与<code>maximumPoolSize</code>的关系举个简单的例子形象理解就是：</p><blockquote><p>假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p><p>如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p><p>然后就将任务也分配给这4个临时工人做；</p><p>如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p></blockquote><p>这个例子中的<code>corePoolSize</code>就是10，而<code>maximumPoolSize</code>就是14（10+4）。</p><p><code>maximumPoolSize</code>可以看作是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>在<code>ThreadPoolExecutor</code>类中，最核心的任务提交方法是<code>execute()</code>方法，虽然通过<code>submit</code>也可以提交任务，但是实际上<code>submit</code>方法里面最终调用的还是<code>execute()</code>方法，所以我们只需要研究<code>execute()</code>方法的实现原理即可：</p><p>注：<code>execute()</code>方法和<code>submit()</code>方法已经在前面讲过区别了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">     <span class="comment">// Proceed in 3 steps:</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 1. </span></span><br><span class="line">     <span class="comment">// 判断当前的线程数是否小于corePoolSize,如果是，使用入参任务通过addWord方法创建一个新的线程，</span></span><br><span class="line">     <span class="comment">// 如果能完成新线程创建exexute方法结束，成功提交任务</span></span><br><span class="line">     <span class="comment">// 2. </span></span><br><span class="line">     <span class="comment">// 在第一步没有完成任务提交；状态为运行并且能够成功加入任务到工作队列后，再进行一次check，如果状态</span></span><br><span class="line">     <span class="comment">// 在任务加入队列后变为了非运行（有可能是在执行到这里线程池shutdown了），非运行状态下当然是需要</span></span><br><span class="line">     <span class="comment">// reject；然后再判断当前线程数是否为0（有可能这个时候线程数变为了0），如是，新增一个线程；</span></span><br><span class="line">     <span class="comment">// 3. </span></span><br><span class="line">     <span class="comment">// 如果不能加入任务到工作队列，将尝试使用任务新增一个线程，如果失败，则是线程池已经shutdown或者线程池</span></span><br><span class="line">     <span class="comment">// 已经达到饱和状态，所以reject这个任务</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果工作线程数大于等于核心线程数</span></span><br><span class="line">    <span class="comment">// 线程的的状态为RUNNING并且队列notfull</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次检查线程的运行状态，如果不是RUNNING直接从队列中移除</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 移除成功，拒绝该非运行的任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">            <span class="comment">// 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列满了或者是非运行的任务都拒绝执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的程序流程图为：</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B111.png" alt="image"></p><p>为了理解更加得透彻，用下图配合文字总结一下：</p><p><img src="http://bloghello.oursnail.cn/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86111.png" alt="image"></p><ul><li>1.如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>2.如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>3.如果无法将任务加入<code>BlockingQueue</code>（队列已满），则在非<code>corePool</code>中创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li><li>4.如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ul><blockquote><p><code>ThreadPoolExecutor</code>采取上述步骤的总体设计思路，是为了在执行<code>execute()</code>方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在<code>ThreadPoolExecutor</code>完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从CAS到Atomic包原理</title>
      <link href="/2019/02/12/thread/%E4%BB%8ECAS%E5%88%B0Atomic%E5%8C%85%E5%8E%9F%E7%90%86/"/>
      <url>/2019/02/12/thread/%E4%BB%8ECAS%E5%88%B0Atomic%E5%8C%85%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>我们知道，volatile保证了可见性，但是不能保证原子性，在面对线程安全问题时，就显地力不从心，那么除了synchronized关键字外，还有什么方式可以实现线程安全更新呢？本文首先介绍CAS是什么，引出JUC下一个重要的包：Atomic包。</p><a id="more"></a><h2>一、CAS简介</h2><p><code>CAS</code>（<code>Compare and Swap</code>），即比较并替换，实现并发算法时常用到的一种技术，<code>Doug lea</code>大神在java同步器中大量使用了<code>CAS</code>技术，鬼斧神工的实现了多线程执行的安全性。</p><p><code>CAS</code>的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回<code>true</code>，否则什么都不做，并返回<code>false</code>。</p><h2>二、n++问题</h2><p><img src="http://bloghello.oursnail.cn/thread9-1.jpg" alt="image"></p><p>通过<code>javap -verbose Case</code>看看<code>add</code>方法的字节码指令：</p><p><img src="http://bloghello.oursnail.cn/thread9-2.jpg" alt="image"></p><p>我们可以看到，<code>n++</code>被拆分成了下面几个指令：</p><ul><li>执行<code>getfield</code>拿到原始<code>n</code>；</li><li>执行<code>iadd</code>进行加1操作；</li><li>执行<code>putfield</code>写把累加后的值写回<code>n</code>；</li></ul><p>通过<code>volatile</code>修饰的变量可以保证线程之间的可见性，但并不能保证这3个指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果，那么应该如何解决呢？</p><p>这里顺便提一下线程安全三个特性</p><ul><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程观察到。</li><li>有序性：一个线程观察其他线程中的指令的执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ul><p>可以看到原子性是线程安全的一大特性。</p><h2>三、解决方案一</h2><p>在<code>add</code>方法加上<code>synchronized</code>修饰解决。</p><p><img src="http://bloghello.oursnail.cn/thread9-3.jpg" alt="image"></p><p>这个方案当然可行，但是性能上差了点，还有其它方案么？</p><h2>四、解决方案二</h2><p>我们可不可以用一下乐观锁的思想呢？即不加锁，等真正要赋值的时候比较一下。</p><p><img src="http://bloghello.oursnail.cn/thread9-4.jpg" alt="image"></p><p>当然了，这段代码如果真的在并发下执行，肯定出问题，只有把这整个过程变成一个原子操作才行，即同一时刻只有一个线程才能修改变量<code>a</code>。</p><p>如何实现呢？</p><p>我们注意到JUC下有个好东西，以<code>Atomic</code>打头的一些类。就可以很好地帮助我们实现对一个数加一减一的原子性操作。比如我们要安全地对<code>n</code>加一，可以这样做：</p><p><img src="http://bloghello.oursnail.cn/thread9-5.jpg" alt="image"></p><p>下面就以<code>AtomicInteger</code>的实现为例，分析一下<code>CAS</code>是如何实现的。</p><p><img src="http://bloghello.oursnail.cn/thread9-6.jpg" alt="image"></p><ul><li><code>Unsafe</code>，是<code>CAS</code>的核心类，由于Java方法无法直接访问底层系统，需要通过本地（<code>native</code>）方法来访问，<code>Unsafe</code>相当于一个后门，基于该类可以直接操作特定内存的数据。</li><li>变量<code>valueOffset</code>，表示该变量值在内存中的偏移地址，因为<code>Unsafe</code>就是根据内存偏移地址获取数据的。</li><li>变量<code>value</code>用<code>volatile</code>修饰，保证了多线程之间的内存可见性。</li></ul><p>看看<code>AtomicInteger</code>如何实现并发下的累加操作：</p><p><img src="http://bloghello.oursnail.cn/thread9-7.jpg" alt="image"></p><p>假设线程<code>A</code>和线程<code>B</code>同时执行<code>getAndIncrement</code>操作（分别跑在不同CPU上）：</p><ul><li>假设<code>AtomicInteger</code>里面的<code>value</code>原始值为0，即主内存中<code>AtomicInteger</code>的<code>value</code>为0，根据Java内存模型，线程A和线程B各自持有一份<code>value</code>的副本，值为0。</li><li>线程A通过<code>getIntVolatile(var1, var2)</code>拿到<code>value</code>值0，这时线程A被挂起。</li><li>线程B也通过<code>getIntVolatile(var1, var2)</code>方法获取到<code>value</code>值0，运气好，线程B没有被挂起，并执行<code>compareAndSwapInt</code>方法比较内存值也为0，成功修改内存值为1。</li><li>这时线程A恢复，执行<code>compareAndSwapInt</code>方法比较，发现自己手里的值(0)和内存的值(1)不一致，说明该值已经被其它线程提前修改过了，那只能重新来一遍了。</li><li>重新获取<code>value</code>值，因为变量<code>value</code>被<code>volatile</code>修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt</code>进行比较替换，直到成功。</li></ul><p>整个过程中，利用<code>CAS</code>保证了对于<code>value</code>的修改的并发安全，继续深入看看<code>Unsafe</code>类中的<code>compareAndSwapInt</code>方法实现。</p><p><img src="http://bloghello.oursnail.cn/thread9-8.jpg" alt="image"></p><p>我们看到是一个本地方法，并且在每个操作系统的具体实现都是不大一样的，这里我们就不再深究了。只要知道它的比较和替换是一个原子操作即可。</p><h2>五、其他重要的Atomic类</h2><h5>5.1 LongAdder</h5><p>上面提到了<code>AtomicInteger</code>，那么必然也存在``AtomicLong`。用法和原理是一样的。</p><p>既然用<code>LongAddr</code>也可以，但是为什么不使用<code>AtomicLong</code>呢？换句话说，为什么<code>AtomicLong</code>可以实现，还要有<code>LongAddr</code>这个类呢？？？</p><p><code>LongAddr</code>优点：我们从<code>AtomicInteger</code>这个类的实现看到，他是在一个死循环内不停地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功的几率很高。否则修改失败的概率就会很高。在大量修改失败的时候，多次尝试，性能会受到一定的影响。</p><p>对于普通类型的<code>Long</code>和<code>Double</code>变量，JVM允许将64位的读操作和写操作拆成两个32位的操作。</p><blockquote><p>我们知道<code>JUC</code>下面提供的原子类都是基于<code>Unsafe</code>类实现的，并由<code>Unsafe</code>来提供<code>CAS</code>的能力。<code>CAS</code> (<code>compare-and-swap</code>)本质上是由现代<code>CPU</code>在硬件级实现的原子指令，允许进行无阻塞，多线程的数据操作同时兼顾了安全性以及效率。<code>getAndAddLong</code>方法会以<code>volatile</code>的语义去读需要自增的域的最新值，然后通过<code>CAS</code>去尝试更新，正常情况下会直接成功后返回，但是在高并发下可能会同时有很多线程同时尝试这个过程，也就是说线程A读到的最新值可能实际已经过期了，因此需要在<code>while</code>循环中不断的重试，造成很多不必要的开销。</p></blockquote><p>将<code>AtomicLong</code>核心数据<code>value</code>分离成一个数组，每个线程访问时，通过<code>hash</code>等算法，映射到其中一个数字进行计数。最终的计数结果则为这个数组的求和累加。其中热点数据<code>value</code>会被分离成多个单元的<code>cell</code>，每个<code>cell</code>独自维护内部的值，当前对象的实际值由<code>cell</code>累计合成。这样，热点就得到有效的分离并提高了并行度。 <code>LongAddr</code>在<code>AtomicLong</code>基础上将单点的更新压力分散到各个节点上。低并发时通过对<code>base</code>直接更新，得到与<code>AtomicLong</code>一样的性能。</p><div class="tip">缺陷：统计的时候，如果有并发更新，会有统计的误差，例如获取一个全局唯一的ID还是采用`AtomicLong`更好一点。</div><h5>5.2 AtomicReference</h5><p>这个其实很简单，用法如下：</p><p><img src="http://bloghello.oursnail.cn/thread9-9.jpg" alt="image"></p><p>其实这个方法实现的是对一个共享对象的原子性操作，保证对象更新的原子性。</p><h5>5.3 AtomicIntegerFieldUpdater</h5><p>假设现在有这样的一个场景： 一百个线程同时对一个int对象进行修改，要求只能有一个线程可以修改。</p><p>可能有的同学会这么写：</p><p><img src="http://bloghello.oursnail.cn/thread9-10.jpg" alt="image"></p><p>我们来分析一下，对于<code>volatile</code>变量，写的时候会将线程本地内存的数据刷新到主内存上，读的时候会将主内存的数据加载到本地内存里，所以可以保证可见行和单个读/写操作的原子性。</p><p>但是上例中先</p><ul><li>先判断:<code>!ischanged</code></li><li>再执行赋值操作：<code>ischanged=true</code></li></ul><p>该组合操作就不能保证原子性了，也就是说线程A A1-&gt;A2 , 线程B B1-&gt;B2 (第一个操作为<code>volatile</code>读或者第二个操作为<code>volatile</code>写的时候，编译器不会对两个语句重排序，所以最后的执行顺序满足顺序一致性模型的)，但是最后的执行结果可能是A1-&gt;B1-&gt;A2-&gt;B2。不满足需求.</p><p>这种情况下，<code>AtomicIntegerFieldUpdater</code>就可以派上用场了。</p><p><img src="http://bloghello.oursnail.cn/thread9-11.jpg" alt="image"></p><p>对于这个代码的理解可以用下面这个代码来：</p><p><img src="http://bloghello.oursnail.cn/thread9-12.jpg" alt="image"></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update success 1:200</span><br><span class="line">update fail</span><br></pre></td></tr></table></figure><p>用<code>AtomicIntegerFieldUpdater.newUpdater</code>指定类里面的属性。这里我们要更新<code>Test</code>类里面的<code>A</code>字段（必须是<code>volatile</code>且不是<code>static</code>对象）。<code>update.compareAndSet()</code>方法使用<code>cas</code>机制，每次提交的时候都比较下<code>test.a</code>是不是100，如果是，则更新。</p><p>注意，不能使用<code>final</code>变量，因为语义冲突。对于<code>AtomicIntegerFieldUpdater</code>和<code>AtomicLongFieldUpdater</code>只能修改<code>int</code>/<code>long</code>类型的字段，不能修改其包装类型（<code>Integer</code>/<code>Long</code>）。如果要修改包装类型就需要使用<code>AtomicReferenceFieldUpdater</code>。</p><h5>5.4 AtomicStampedReference</h5><p>对于上面说的<code>AtomicInteger</code>等存在一个问题就是ABA问题。</p><p>ABA问题：其他线程将A改为B，又重新改为了A，本线程用期望值A与之进行比较，发现是相等的，则进行下面的操作。因为这个值已经被改变过，这就是ABA问题。</p><p>解决：用个版本号来控制，来防止ABA问题。</p><h5>5.5 AtomicBoolean</h5><p>场景：若干个线程进来，但是这个方法只能执行一次。</p><p><img src="http://bloghello.oursnail.cn/thread9-13.jpg" alt="image"></p><p>好了，其实<code>Atomic</code>包最核心的思想就是用无阻塞的<code>CAS</code>来代替锁实现高性能操作，是实现线程安全的一种可行方法，理解了<code>CAS</code>原理和他们的基本用法和场景使用，基本就可以了。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>volatile详解</title>
      <link href="/2019/02/11/thread/volatile%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/11/thread/volatile%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>volatile是比较重要的关键字，它涉及JMM，我们需要对其进行深入了解。</p><a id="more"></a><h2>一、java内存模型JMM</h2><p>JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。</p><p>请务必区分HMM和JAVA内存区域，JMM描述的是一组规则，围绕原子性、有序性以及可见性展开。</p><p><img src="http://bloghello.oursnail.cn/thread8-1.png" alt="image"></p><p>大多数的变量是只能存储在主内存中的，线程也不能直接去主内存中读取数据，而是获取数据的副本，每个线程对这个副本进行修改后，会在某个时机刷新回主内存。每个线程之间的工作内存的值是互不透明的，因此不能互相访问，线程间的通信必须通过主内存来完成。</p><h2>二、JMM主内存和工作内存都放些什么</h2><ul><li>主内存<ul><li>存储JAVA实例对象</li><li>包括实例变量、类信息、常量、静态变量等</li><li>属于数据共享的区域，多线程并发操作时会引起线程安全问题</li></ul></li><li>工作内存<ul><li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见(方法里的基本数据类型会直接被存储在工作内存的栈帧结构中)</li><li>字节码行号指示器、Native方法信息</li><li>如果是引用类型，引用存储在工作内存中，实例存储在主内存中</li><li>属于线程私有数据区域，不存在线程安全问题</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/thread8-2.jpg" alt="image"></p><h2>三、指令重排序</h2><p>为了提高执行性能，JVM会进行一定的指令重排序，禁止方式就是加入内存屏障指令，下面会说。</p><p>当然了，指令重排序需要满足一定的条件：</p><ul><li>在单线程环境下不能改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序</li></ul><p>无法通过<code>happend-before</code>原则推导出来的，才能进行指令的重排序。</p><h2>四、happend-before</h2><p>多线程有两个基本的问题，就是原子性和可见性，而<code>happens-before</code>规则就是用来解决可见性的。</p><p>即：在时间上，动作A发生在动作B之前，能不能<strong>保证</strong>B可以看见A？如果可以保证的话，那么就可以说<code>hb(A,B)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="keyword">true</span>;               <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="keyword">int</span> i =  a;           <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程A执行<code>writer()</code>方法之后，线程B执行<code>reader()</code>方法。根据happens before规则，这个过程建立的happens before 关系可以分为两类：</p><ul><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据volatile规则，2 happens before 3。</li><li>根据happens before 的传递性规则，1 happens before 4。</li></ul><p>上述<code>happens before</code> 关系的图形化表现形式如下：</p><p><img src="http://bloghello.oursnail.cn/thread8-3.png" alt="image"></p><p>在上图中，每一个箭头链接的两个节点，代表了一个<code>happens before</code> 关系。黑色箭头表示程序顺序规则；橙色箭头表示<code>volatile</code>规则；蓝色箭头表示组合这些规则后提供的<code>happens before</code>保证。</p><p>这里A线程写一个<code>volatile</code>变量后，B线程读同一个<code>volatile</code>变量。A线程在写<code>volatile</code>变量之前所有可见的共享变量，在B线程读同一个<code>volatile</code>变量后，将立即变得对B线程可见。</p><p>说了那么多，java中是如何保证这种可见性的呢？<code>Volatile</code>闪亮登场。</p><h2>五、什么是volatile</h2><p><code>volatile</code>关键字的目的是保证被它修饰的共享变量对所有线程总是可见的。</p><h2>六、为什么要用volatile</h2><p><code>Volatile</code>变量修饰符如果使用恰当的话，它比<code>synchronized</code>的使用和执行成本会更低，因为它不会引起线程上下文的切换和调度。</p><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被<code>volatile</code>修饰之后，那么就具备了两层语义：</p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ul><h2>七、volatile如何保证可见性</h2><p><code>voliatile</code>关键字保证了在进程中变量的变化的可见性。</p><p>在多线程的应用里，如果线程操作了一个没有被<code>volatile</code>关键字标记的变量，那么每个线程都会在使用到这个变量时从主存里拷贝这个变量到CPU的<code>cache</code>里面（为了性能！CPU缓存可比内存快多了）。如果你的电脑有多于一个CPU，那么每个线程都会在不同的CPU上面运行，这意味着每个线程都会把这个变量拷贝到不同的CPU <code>cache</code>里面，正如下图所示：</p><p><img src="http://bloghello.oursnail.cn/thread8-4.png" alt="image"></p><p>一个不带有<code>volatile</code>关键字的变量在JVM从主存里面读取数据到CPU cache或者从cache里面写入数据到主存时是没有保证的。</p><p>想象这样一个场景，当一到两个线程允许去共享一个包含了一个计数变量的对象，这个计数变量如下所定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">//无关键字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这线程一增加了<code>counter</code>变量的值，但是，但是同时线程一和线程二都有可能随时读取这个<code>counter</code>变量。</p><p>如果这个<code>counter</code>变量未曾使用<code>volatile</code>声明，那么我们就无法保证这个变量在两个线程中所位于的CPU的cache和主存中的值是否保持一致了。示意图如下：</p><p><img src="http://bloghello.oursnail.cn/thread8-5.png" alt="image"></p><p>那么部分的线程就不能看到这个变量最新的样子，因为这个变量还没有被线程写回到主存中，这就是可见性的问题，这个线程更新的变量对于其他线程是不可视的。</p><p>在声明了<code>counter</code>变量的<code>volatile</code>关键字后，所有写入到<code>counter</code>变量的值会被立即写回到主存中。同时，所有读取这个变量的线程会先把对应的工作内存置为无效，从主存里面读取这个变量，下面的代码就是声明带<code>volatile</code>关键字的变量的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此声明这个变量就保证了这个变量对于其他写这个变量的线程的可见性。</p><p>总结：</p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了<code>Volatile</code>变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><h2>八、来详细说说volatile写-读的内存语义</h2><p><strong>volatile写的内存语义如下</strong>：</p><blockquote><p>当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。</p></blockquote><p>以上面示例程序<code>VolatileExample</code>为例，假设线程A首先执行<code>writer()</code>方法，随后线程B执行<code>reader()</code>方法，初始时两个线程的本地内存中的flag和a都是初始状态。下图是线程A执行<code>volatile</code>写后，共享变量的状态示意图：</p><p><img src="http://bloghello.oursnail.cn/thread8-6.png" alt="image"></p><p>如上图所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。</p><p><strong>volatile读的内存语义如下</strong>：</p><blockquote><p>当读一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></blockquote><p><img src="http://bloghello.oursnail.cn/thread8-7.png" alt="image"></p><p>如上图所示，在读flag变量后，本地内存B已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把<code>volatile</code>写和<code>volatile</code>读这两个步骤综合起来看的话，在读线程B读一个<code>volatile</code>变量后，写线程A在写这个<code>volatile</code>变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p><p>下面对<code>volatile</code>写和<code>volatile</code>读的内存语义做个总结：</p><ul><li>线程A写一个<code>volatile</code>变量，实质上是线程A向接下来将要读这个<code>volatile</code>变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程B读一个<code>volatile</code>变量，实质上是线程B接收了之前某个线程发出的（在写这个<code>volatile</code>变量之前对共享变量所做修改的）消息。</li><li>线程A写一个<code>volatile</code>变量，随后线程B读这个<code>volatile</code>变量，这个过程实质上是线程A通过主内存向线程B发送消息。</li></ul><h2>九、volatile如何禁止指令重排序</h2><p>这就不得不提一个指令叫做：内存屏障了。</p><p>它可就厉害了，</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性</li></ul><p>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化。</p><p>这个指令对编译器和CPU的执行都是起作用的，可用强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><p>因此，从根本上来说，是内存屏障指令实现了<code>volatile</code>的可见性和禁止指令重排序的。</p><h2>十、volatile的应用场景</h2><blockquote><p><code>volatile</code>关键字只能对32位和64位的变量使用</p></blockquote><p><code>synchronized</code>关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而<code>volatile</code>关键字在某些情况下性能要优于<code>synchronized</code>，但是要注意<code>volatile</code>关键字是无法替代<code>synchronized</code>关键字的，因为<code>volatile</code>关键字无法保证操作的原子性。通常来说，使用<code>volatile</code>必须具备以下2个条件：</p><blockquote><p>1）对变量的写操作不依赖于当前值</p></blockquote><blockquote><p>2）该变量没有包含在具有其他变量的不变式中</p></blockquote><p>下面列举几个Java中使用<code>volatile</code>的几个场景。</p><p>①.状态标记量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②.单例模式中的<code>double check</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();<span class="comment">//非原子操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>instance = new Singleton();</code>//非原子操作</p></blockquote><p>执行这一句，JVM发生了如下事情：</p><ul><li>给 <code>instance</code> 分配内存</li><li>调用 <code>Singleton</code> 的构造函数来初始化成员变量</li><li>将<code>instance</code>对象指向分配的内存空间（执行完这步 <code>instance</code> 就为非 <code>null</code> 了）</li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 <code>instance</code> 已经是非 <code>null</code> 了（但却没有初始化），所以线程二会直接返回 <code>instance</code>，然后使用，然后顺理成章地出错了，不再是单例了。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读写锁ReentrantReadWriteLock</title>
      <link href="/2019/02/11/thread/%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/"/>
      <url>/2019/02/11/thread/%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/</url>
      <content type="html"><![CDATA[<p>读写锁的出现是为了提高性能，思想是：读读不互斥，读写互斥，写写互斥。本文来了解一下读写锁的使用和锁降级的概念。</p><a id="more"></a><h2>1. 锁的分类</h2><ul><li>排他锁：在同一时刻只允许一个线程进行访问，其他线程等待；</li><li>读写锁：在同一时刻允许多个读线程访问，但是当写线程访问，所有的写线程和读线程均被阻塞。读写锁维护了一个读锁加一个写锁，通过读写锁分离的模式来保证线程安全，性能高于一般的排他锁。</li></ul><h2>2. 读写锁</h2><p>我们对数据的操作无非两种：“读”和“写”，试想一个这样的情景，当十个线程同时读取某个数据时，这个操作应不应该加同步。答案是没必要的。只有以下两种情况需要加同步：</p><ul><li>这十个线程对这个公共数据既有读又有写</li><li>这十个线程对公共数据进行写操作</li><li>以上两点归结起来就一点就是有对数据进行改变的操作就需要同步</li></ul><p>所以</p><p><strong>java5提供了读写锁这种锁支持多线程读操作不互斥，多线程读写互斥，多线程写互斥</strong>。读操作不互斥这样有助于性能的提高，这点在java5以前没有。</p><h2>3. java并发包提供的读写锁</h2><p>java并发包提供了读写锁的具体实现<code>ReentrantReadWriteLock</code>，它主要提供了一下特性：</p><ul><li>公平性选择：支持公平和非公平（默认）两种获取锁的方式，非公平锁的吞吐量优于公平锁；</li><li>可重入：支持可重入，读线程在获取读锁之后能够再次获取读锁，写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁；</li><li>锁降级：线程获取锁的顺序遵循获取写锁，获取读锁，释放写锁，写锁可以降级成为读锁。</li></ul><h2>4. 先看个小例子</h2><p><strong>读取数据和写入数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个map用来读取和存放数据</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化ReentrantReadWriteLock</span></span><br><span class="line"><span class="keyword">private</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据实例化对象分别获取读锁和写锁</span></span><br><span class="line"><span class="keyword">private</span> Lock r = rwl.readLock();</span><br><span class="line"><span class="keyword">private</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上读锁</span></span><br><span class="line">r.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 读操作开始执行"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">System.out.println(map.get(key));</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解读锁</span></span><br><span class="line">r.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 读操作执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入数据，即写数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,String value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//上写锁</span></span><br><span class="line">w.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 写操作开始执行"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写数据</span></span><br><span class="line">map.put(key, value);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//解写锁</span></span><br><span class="line">w.unlock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 写操作执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main进行创建多线程测试：先来测试一下存在写的情况(只有写或者写读都有)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//读</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 写操作开始执行</span><br><span class="line">Thread-0 写操作执行完毕</span><br><span class="line">Thread-1 读操作开始执行</span><br><span class="line">value1</span><br><span class="line">Thread-1 读操作执行完毕</span><br><span class="line">Thread-2 写操作开始执行</span><br><span class="line">Thread-2 写操作执行完毕</span><br><span class="line">Thread-3 写操作开始执行</span><br><span class="line">Thread-3 写操作执行完毕</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>发现存在写的情况，那么就是一个同步等待的过程，即开始执行，然后等待3秒，执行完毕，符合第2个目录中提到的规则。</p><p><strong>对只有读操作的情形进行测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">demo.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">demo.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">demo.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">demo.get(<span class="string">"key3"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 读操作开始执行</span><br><span class="line">Thread-1 读操作开始执行</span><br><span class="line">Thread-2 读操作开始执行</span><br><span class="line">value1</span><br><span class="line">Thread-0 读操作执行完毕</span><br><span class="line">value2</span><br><span class="line">Thread-1 读操作执行完毕</span><br><span class="line">value3</span><br><span class="line">Thread-2 读操作执行完毕</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>在主线程中先<code>put</code>进去几个数用于读的测试，下面开辟三个读线程，我们可以从执行结果中发现，其中一个线程进去之后，另外的线程能够立即再次进入，即这三把锁不是互斥的。</p><h2>5. 锁降级</h2><p>锁降级是指写锁将为读锁。</p><p>锁降级：从写锁变成读锁；锁升级：从读锁变成写锁。读锁是可以被多线程共享的，写锁是单线程独占的。也就是说写锁的并发限制比读锁高，这可能就是升级/降级名称的来源。</p><p>如下代码会产生死锁，因为同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，<code>ReentrantReadWriteLock</code>是不支持的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line">rtLock.readLock().lock();  <span class="comment">//上读锁</span></span><br><span class="line">System.out.println(<span class="string">"get readLock."</span>);  </span><br><span class="line">rtLock.writeLock().lock();  <span class="comment">//读锁还没有释放，不允许上死锁</span></span><br><span class="line">System.out.println(<span class="string">"blocking"</span>);</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code>支持锁降级，如下代码不会产生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReadWriteLock rtLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </span><br><span class="line">rtLock.writeLock().lock();  <span class="comment">//上写锁</span></span><br><span class="line">System.out.println(<span class="string">"writeLock"</span>);  </span><br><span class="line">  </span><br><span class="line">rtLock.readLock().lock();  <span class="comment">//可以在写锁没有释放的时候立即上读锁</span></span><br><span class="line">System.out.println(<span class="string">"get read lock"</span>);</span><br></pre></td></tr></table></figure><p>利用这个机制：<strong>同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，<code>ReentrantReadWriteLock</code>是不支持的。</strong></p><p>在写锁没有释放的时候，先获取到读锁，然后再释放写锁，保证后面读到的数据的一致性。</p><p><img src="https://segmentfault.com/img/bVOGUM?w=1063&amp;h=246" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isUpdate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">r.lock();<span class="comment">//为了保证isUpdate能够拿到最新的值</span></span><br><span class="line"><span class="keyword">if</span>(isUpdate)&#123;</span><br><span class="line">r.unlock();</span><br><span class="line">w.lock();</span><br><span class="line">map.put(<span class="string">"xxx"</span>,<span class="string">"xxx"</span>);</span><br><span class="line">r.lock();<span class="comment">//写锁还没有释放，立即获取读锁，阻塞本线程，保证本线程下面读的一致性</span></span><br><span class="line">w.unlock();</span><br><span class="line">&#125;</span><br><span class="line">String value = map.get(<span class="string">"xxx"</span>); <span class="comment">//读到的数据是本线程自己更新的数据，不会被其他线程打扰</span></span><br><span class="line">System.out.println(value);</span><br><span class="line">r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从ReentrantLock引出AQS的原理</title>
      <link href="/2019/02/11/thread/%E4%BB%8EReentrantLock%E5%BC%95%E5%87%BAAQS%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2019/02/11/thread/%E4%BB%8EReentrantLock%E5%BC%95%E5%87%BAAQS%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>如果对并发编程稍微熟悉的话，就不会对ReentrantLock陌生，也可能对一些组件比如CountDownLatch,FutureTask以及Semaphore等同步组件耳闻过，他们都是JUC包下的类或者工具，他们都有一个共同的基础：AQS，即AbstractQueuedSynchronizer，从今天开始，让我们记住它，并且尝试去理解它。</p><a id="more"></a><h2>一、ReentrantLock</h2><p>首先我们先来看看<code>ReentrantLock</code>这个可重入锁的性质和使用，因为它往往会在面试中被面试官拿来同<code>synchronized</code>相比较。如果这种基本的比较都不知道的话，那就没有后续深入的探讨了，面试可能也会结束了。</p><p>它的用法极其简单，如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-1.jpg" alt="image"></p><p>他们两兄弟的区别是：</p><ul><li><code>synchronized</code>是关键字，<code>ReentrantLock</code>是一个类</li><li><code>ReentrantLock</code>可以对获取锁的等待时间进行设置，避免死锁</li><li><code>ReentrantLock</code>可以获取各种锁的信息</li><li><code>ReentrantLock</code>可以灵活地实现多路通知</li><li>机制：<code>synchronized</code>操作<code>MarkWord</code>，<code>lock</code>调用<code>Unsafe</code>类的<code>park()</code>方法</li><li><code>ReentrantLock</code>可以设置锁的公平性</li><li><code>ReentrantLock</code>调用<code>lock()</code>之后必须调用<code>unlock()</code>释放锁</li><li>性能上<code>ReentrantLock</code>未必就比<code>synchronized</code>高，他们都是可重入的</li></ul><p>可以看出，<code>ReentrantLock</code>更加灵活，可以更加细腻度操作锁，而<code>synchronized</code>看起来则相对比较笨拙，但是笨拙的是简单的，不存在忘记释放锁的问题。可谓存在即合理嘛！</p><p>针对上文中提到的<code>Unsafe</code>类，其中最经典的一个方法是：<code>compareAndSwapXXX</code>这类<code>CAS</code>方法，它其实是JAVA留的一个后门，它可以直接操作内存，因此如果普通开发者拿来用的话，可能会出现各种问题，因此被成为不安全的类。</p><p>好了，关于区别已经说的差不多了，下面我们就要来真格的了，首先来翻翻源码。<strong>前方高能预警，请非战斗人员紧急撤离现场，老司机要开车了。</strong></p><p>首先呢，我们来看看<code>lock()</code>方法的实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里多了一个东西叫<code>Sync</code>，<code>Sync</code>为<code>ReentrantLock</code>里面的一个内部类，它继承<code>AQS</code>，它有两个子类：公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>。</p><p><code>ReentrantLock</code>里面大部分的功能都是委托给<code>Sync</code>来实现的，同时<code>Sync</code>内部定义了<code>lock()</code>抽象方法由其子类去实现，默认实现了<code>nonfairTryAcquire(int acquires)</code>方法，可以看出它是非公平锁的默认实现方式。</p><p><img src="http://bloghello.oursnail.cn/thread7-2.jpg" alt="image"></p><p>几乎每一个方法都是通过<code>sync.xxx</code>来实现的，而<code>Sync</code>这个内部类在<code>AQS</code>的基础上增加一些东西而已，所以本质上都是基于<code>AQS</code>来实现的。</p><p>不仅仅是这个，JUC包基本都是以<code>AQS</code>为基础构成，因此<code>AQS</code>可以理解为JUC的一个实现框架。既然<code>AQS</code>这么重要，下面有必要挖地三尺掘出它的原理。</p><h2>二、AQS简介</h2><p>java的内置锁一直都是备受争议的，在JDK 1.6之前，<code>synchronized</code>这个重量级锁性能一直都是较为低下，虽然在1.6后，进行大量的锁优化策略,但是与<code>Lock</code>相比<code>synchronized</code>还是存在一些缺陷的：虽然<code>synchronized</code>提供了便捷性的隐式获取锁释放锁机制（基于JVM机制），但是它却缺少了获取锁与释放锁的可操作性，可中断、超时获取锁，且它为独占式在高并发场景下性能大打折扣。</p><p>AQS：<code>AbstractQueuedSynchronizer</code>，即队列同步器。它是构建锁或者其他同步组件的基础框架（如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<br><code>Semaphore</code>等），JUC并发包的作者（<code>Doug Lea</code>）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。</p><p>AQS解决了在实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p><p>AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS使用一个<code>int</code>类型的成员变量<code>state</code>来表示同步状态，当<code>state&gt;0</code>时表示已经获取了锁，当<code>state = 0</code>时表示释放了锁。它提供了三个方法（<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect,int update)</code>）来对同步状态<code>state</code>进行操作，当然AQS可以确保对<code>state</code>的操作是安全的。</p><p>AQS通过内置的<code>FIFO</code>同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</p><h2>三、CLH同步队列</h2><p><code>CLH</code>同步队列是一个<code>FIFO</code>双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p><p>在<code>CLH</code>同步队列中，一个节点表示一个线程，它保存着线程的引用（<code>thread</code>）、状态（<code>waitStatus</code>）、前驱节点（<code>prev</code>）、后继节点（<code>next</code>），<code>CLH</code>同步队列结构图如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-9.jpg" alt="image"></p><p>举例理解：假设目前有三个线程<code>Thread1</code>、<code>Thread2</code>、<code>Thread3</code>同时去竞争锁，如果结果是<code>Thread1</code>获取了锁，<code>Thread2</code>和<code>Thread3</code>进入了等待队列，那么他们的样子如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-10.jpg" alt="image"></p><p>AQS的等待队列基于一个双向链表实现的，<code>HEAD</code>节点不关联线程，后面两个节点分别关联<code>Thread2</code>和<code>Thread3</code>，他们将会按照先后顺序被串联在这个队列上。这个时候如果后面再有线程进来的话将会被当做队列的<code>TAIL</code>。</p><h2>四、入列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//快速尝试添加尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWaiter(Node node)</code>先通过快速尝试设置尾节点，如果失败，则调用<code>enq(Node node)</code>方法设置尾节点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多次尝试，直到成功为止 </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//tail不存在，设置为首节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置为尾节点 </span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就很明了了，首先是尝试快速用<code>CAS</code>设置当前的节点为尾节点，但是可能存在并发问题设置不成功，下面用死循环的方式不断地尝试添加节点并且设置为尾节点，直到成功。</p><p>过程如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-4.jpg" alt="image"></p><h2>五、出列</h2><p>CLH同步队列遵循<code>FIFO</code>，首节点的线程释放同步状态后，将会唤醒它的后继节点（<code>next</code>），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的<code>next</code>和当前节点的<code>prev</code>即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。</p><p><img src="http://bloghello.oursnail.cn/thread7-5.jpg" alt="image"></p><p>其实这里按照源码的解释，是将第一个获取到同步状态的<code>node</code>作为新的<code>head</code>，然后将原来的<code>head</code>置空。</p><h2>六、同步状态的获取与释放</h2><p>在前面提到过，AQS是构建Java同步组件的基础，我们期待它能够成为实现大部分同步需求的基础。AQS的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态，对于子类而言它并没有太多的活要做，AQS提供了大量的模板方法来实现同步，主要是分为三类：独占式获取和释放同步状态、共享式获取和释放同步状态、查询同步队列中的等待线程情况。自定义子类使用AQS提供的模板方法就可以实现自己的同步语义。</p><p><strong>下面具体来解释一下独占式和共享式的含义</strong></p><p>在具体分析之前，我们先解释两种同步的方式，独占模式和共享模式：</p><ul><li>独占模式：资源是独占的，一次只能一个线程获取。</li><li>共享模式：同时可以被多个线程获取，具体的资源的个数可以通过参数指定。</li></ul><p>如果我们自己实现一个同步器的框架，我们怎么设计呢？下面可能是我们想到的比较通用的设计方案（独占模式）:</p><ul><li>定义一个变量<code>int state=0</code>，使用这个变量表示被获取的资源的数量。</li><li>线程在获取资源前要先检查<code>state</code>的状态，如果为0，则修改为1，表示获取资源成功，否则表示资源已经被其他线程占用，此时线程要堵塞以等待其他线程释放资源。</li><li>为了能使得资源释放后找到那些为了等待资源而堵塞的线程，我们把这些线程保存在FIFO队列中。</li><li>当占有资源的线程释放掉资源后，可以从队列中唤醒一个堵塞的线程，由于此时资源已经释放，因此这个被唤醒的线程可以获取资源并且执行。</li></ul><p>这个<code>state</code>变量到底是什么呢？</p><ul><li>当<code>AQS</code>的子类实现独占功能时，如<code>ReentrantLock</code>，资源是否可以被访问被定义为：只要<code>AQS</code>的<code>state</code>变量不为0，并且持有锁的线程不是当前线程，那么代表资源不可访问。此时，<code>state</code>是用来表示当前线程获取锁的可重入次数；</li><li>当<code>AQS</code>的子类实现共享功能时，如<code>CountDownLatch</code>，资源是否可以被访问被定义为：只要<code>AQS</code>的<code>state</code>变量不为0，那么代表资源不可以为访问。此时，<code>state</code>用来表示当前计数器的值。</li></ul><h2>七、独占式-独占式同步状态获取</h2><p>独占式，同一时刻仅有一个线程持有同步状态。</p><p>独占式同步状态获取<code>acquire(int arg)</code>方法为AQS提供的模板方法，该方法为独占式获取同步状态，但是该方法对中断不敏感，也就是说由于线程获取同步状态失败加入到CLH同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移除。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire</code>：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现(<code>ReentrantLock</code>中实现公平锁和非公平锁就是分别重写了这个方法实现的，下面看<code>ReentrantLock</code>的原理的时候就明白了)，该方法必须要保证线程安全的获取同步状态。</li><li><code>addWaiter</code>：如果<code>tryAcquire</code>返回<code>FALSE</code>（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。</li><li><code>acquireQueued</code>：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。</li><li><code>selfInterrupt</code>：产生一个中断。</li></ul><p>对这里的<code>acquireQueued</code>有疑惑，下面来看看它做了什么。<code>acquireQueued</code>方法为一个自旋的过程，也就是说当前线程（<code>Node</code>）进入同步队列后，就会先进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点node的前驱结点p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果p确实是head，那说明当前节点node是可用的第一个线程</span></span><br><span class="line">            <span class="comment">//即为当前队列的第一个线程，则最先处理它</span></span><br><span class="line">            <span class="comment">//当前线程则尝试获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//从这里可以看出，更新当前节点为头节点</span></span><br><span class="line">                <span class="comment">//将原来头节点的next引用置空以供JVM回收</span></span><br><span class="line">                <span class="comment">//具体见出列小标题下的示意图</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前驱节点不是头节点就继续阻塞继续等待呗</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看到，当前线程会一直尝试获取同步状态，当然前提是只有其前驱节点为头结点才能够尝试获取同步状态，理由：</p><ul><li>保持FIFO同步队列原则。</li><li>头节点释放同步状态后，将会唤醒其后继节点，后继节点被唤醒后需要检查自己是否为头节点。</li></ul><p>对这个的理解简单来说就是：</p><blockquote><p>在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的队尾并一直保持着自旋。在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果当前节点的前驱节点就是头节点，则表明当前节点是当前队列中的第一个可用线程，则让其不断尝试获取同步状态，如果获取到，则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</p></blockquote><p>继续，我们看到，如果发现前驱节点并不是<code>head</code>，那么就说明是比较靠后的节点了，这个时候，很有可能需要一段时间之后才会用到它，所以根本不需要再参与自旋浪费CPU的性能了，即下面一个if:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>通过这段代码我们可以看到，在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法，该方法主要靠前驱节点判断当前线程是否应该被阻塞，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前驱节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//状态为signal，表示当前线程处于等待状态，直接放回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//前驱节点状态 &gt; 0 ，则为Cancelled,表明该节点已经超时或者被中断了，需要从同步队列中取消</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前驱节点状态为Condition、propagate</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要检查当前线程是否需要被阻塞，具体规则如下：</p><ul><li>如果当前线程的前驱节点状态为<code>SINNAL</code>，则表明当前线程需要被阻塞，调用<code>unpark()</code>方法唤醒，直接返回true，当前线程阻塞</li><li>如果当前线程的前驱节点状态为<code>CANCELLED（ws &gt; 0）</code>，则表明该线程的前驱节点已经等待超时或者被中断了，则需要从CLH队列中将该前驱节点删除掉，直到回溯到前驱节点状态 &lt;= 0 ，返回false</li><li>如果前驱节点非<code>SINNAL</code>，非<code>CANCELLED</code>，则通过CAS的方式将其前驱节点设置为<code>SINNAL</code>，返回false</li></ul><p>针对<code>pred.waitStatus</code>的几种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法返回<code>true</code>，则调用<code>parkAndCheckInterrupt()</code>方法阻塞当前线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parkAndCheckInterrupt()</code> 方法主要是把当前线程挂起，从而阻塞住线程的调用栈，同时返回当前线程的中断状态。其内部则是调用<code>LockSupport</code>工具类的<code>park()</code>方法来阻塞该方法。</p><p>那么，此时，当第一个线程已经执行完毕，释放锁了，就需要唤醒队列中后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>unparkSuccessor(Node node)</code>唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前节点状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//当前状态 &lt; 0 则设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从tail节点来找可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会存在当前线程的后继节点为<code>null</code>，超时、被中断的情况，如果遇到这种情况了，则需要跳过该节点，但是为何是从<code>tail</code>尾节点开始，而不是从<code>node.next</code>开始呢？原因在于<code>node.next</code>仍然可能会存在<code>null</code>或者取消了，所以采用<code>tail</code>回溯办法找第一个可用的线程。最后调用<code>LockSupport</code>的<code>unpark(Thread thread)</code>方法唤醒该线程。</p><p>从上面我可以看到，当需要阻塞或者唤醒一个线程的时候，AQS都是使用LockSupport这个工具类来完成的。</p><p><code>LockSupport</code>定义了一系列以<code>park</code>开头的方法来阻塞当前线程，<code>unpark(Thread thread)</code>方法来唤醒一个被阻塞的线程。这些方法的实现都是通过<code>Unsafe</code>类调用<code>native</code>方法来实现的。</p><p>好了，至此就完完全全地搞明白了独占式同步状态获取<code>acquire(int arg)</code>方法的原理，特别是其中节点如何进出、队列第一个节点如何尝试获取同步状态、如何阻塞后继线程以及如何唤醒。</p><h2>八、独占式获取响应中断</h2><p><code>AQS</code>提供了<code>acquire(int arg)</code>方法以供独占式获取同步状态，但是该方法对中断不响应，对线程进行中断操作后，该线程会依然位于<code>CLH</code>同步队列中等待着获取同步状态。为了响应中断，<code>AQS</code>提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常<code>InterruptedException</code>。</p><p>具体原理就不深究了，其实源码跟上面个相差不大，只是不再是使用<code>interrupted</code>标志，而是直接抛出<code>InterruptedException</code>异常。再深究这博客没法继续写啦。</p><h2>九、独占式超时获取</h2><p><code>AQS</code>除了提供上面两个方法外，还提供了一个增强版的方法：<code>tryAcquireNanos(int arg,long nanos)</code>。该方法为<code>acquireInterruptibly</code>方法的进一步增强，它除了响应中断外，还有超时控制。即如果当前线程没有在指定时间内获取同步状态，则会返回<code>false</code>，否则返回<code>true</code>。</p><p>针对超时控制，程序首先记录唤醒时间<code>deadline</code> :<code>deadline</code> = <code>System.nanoTime()</code> +<code>nanosTimeout</code>（时间间隔）。</p><p>如果获取同步状态失败，则需要计算出需要休眠的时间间隔<code>nanosTimeout</code> = <code>deadline</code> - <code>System.nanoTime()</code>，如果<code>nanosTimeout</code> &lt;= 0 表示已经超时了，返回<code>false</code>;</p><p>如果大于<code>spinForTimeoutThreshold(1000L)</code>则需要休眠<code>nanosTimeout</code> ;</p><p>如果<code>nanosTimeout</code> &lt;= <code>spinForTimeoutThreshold</code> ，就不需要休眠了，直接进入快速自旋的过程。原因在于 <code>spinForTimeoutThreshold</code> 已经非常小了，非常短的时间等待无法做到十分精确，如果这时再次进行超时等待，相反会让<code>nanosTimeout</code> 的超时从整体上面表现得不是那么精确，所以在超时非常短的场景中，AQS会进行无条件的快速自旋。</p><p>流程图如下：</p><p><img src="http://bloghello.oursnail.cn/thread7-8.jpg" alt="image"></p><h2>十、共享式-共享式同步状态获取</h2><p>共享式与独占式的最主要区别在于同一时刻独占式只能有一个线程获取同步状态，而共享式在同一时刻可以有多个线程获取同步状态。例如读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。</p><p><code>AQS</code>提供<code>acquireShared(int arg)</code>方法共享式获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面程序可以看出，方法首先是调用<code>tryAcquireShared(int arg)</code>方法尝试获取同步状态，如果获取失败则调用<code>doAcquireShared(int arg)</code>自旋方式获取同步状态，共享式获取同步状态的标志是返回 &gt;= 0 的值表示获取成功。自旋方式获取同步状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且<code>tryAcquireShared(arg)</code>返回值大于等于0即能成功获得同步状态。</p><p><code>acquireShared(int arg)</code>方法不响应中断，与独占式相似，AQS也提供了响应中断、超时的方法，分别是：<code>acquireSharedInterruptibly(int arg)</code>、<code>tryAcquireSharedNanos(int arg,long nanos)</code>，这里就不做解释了。</p><h2>十一、共享式同步状态释放</h2><p>获取同步状态后，需要调用<code>release(int arg)</code>方法释放同步状态，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为可能会存在多个线程同时进行释放同步状态资源，所以需要确保同步状态安全地成功释放，一般都是通过CAS和循环来完成的。</p><h2>十二、再回过头来看看ReentrantLock的原理</h2><p>在对AQS原理进行大概了梳理之后，再来理解<code>ReentrantLock</code>就比较容易了，因为大部分的事情都由AQS做完了，剩下的只要重写几个个性化的方法即可。</p><p>还是要看看最核心的方法：<code>lock()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看这个<code>lock()</code>，一点点进了抽象静态内部类<code>Sync</code>中去了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>上面说过，<code>ReentrantLock</code>里面大部分的功能都是委托给<code>Sync</code>来实现的，同时<code>Sync</code>内部定义了<code>lock()</code>抽象方法由其子类去实现的，所以这个<code>lock</code>方法的具体实现是在子类中完成的。<code>Sync</code>的子类有<code>NonfairSync</code>和<code>FairSync</code>这两个，一看就知道了，一个是非公平一个是公平。</p><h2>十三、非公平锁</h2><p>先来看看比较简单的非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到，这个<code>lock()</code>方法里面首先用<code>CAS</code>尝试获取锁，获取不到则执行<code>acquire()</code>方法，这个方法就恰好是完全由<code>AQS</code>实现，那么就回到了上面介绍过的内容了。这里为了方便再贴一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是调用<code>tryAcquire()</code>这个方法，即尝试获取锁，这个方法上面也提过，是留给具体的类自己去实现的，所以我们还要回到<code>ReentrantLock</code>中来看看，果然，在上面贴的<code>NonfairSync</code>这个类中对这个方法进行了重写。即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的方法就是实现尝试获取锁的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//state == 0,表示该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取锁成功，设置为当前线程所有</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程重入</span></span><br><span class="line">    <span class="comment">//判断锁持有的线程是否为当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就很简单了，值得注意的是，为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作。</p><p>另外需要注意的是，这是非公平锁，就是说，一个线程进来，可能是比先进来的线程先获取锁，就像在开车的时候，总是会由一些车插到你的前面一样。但是如果它没有获取锁，则入队。</p><p>那么尝试获取锁的逻辑我们知道了，那么释放锁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1. 同步状态减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//2. 只有当同步状态为0时，锁成功被释放，返回true</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 3. 锁未被完全释放，返回false</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。</p><h2>十四、公平锁</h2><p>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足<code>FIFO</code>。<code>ReentrantLock</code>的构造方法无参时是构造非公平锁。</p><p>提供了有参构造函数，可传入一个<code>boolean</code>值，<code>true</code>时为公平锁，<code>false</code>时为非公平锁，源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面非公平锁获取时（<code>nonfairTryAcquire</code>方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑与<code>nonfairTryAcquire</code>基本上一致，唯一的不同在于增加了<code>hasQueuedPredecessors</code>的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。</p><h2>十五、公平锁 VS 非公平锁</h2><ul><li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。</li><li>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，<code>ReentrantLock</code>默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从底层理解synchronized</title>
      <link href="/2019/02/11/thread/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3synchronized/"/>
      <url>/2019/02/11/thread/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3synchronized/</url>
      <content type="html"><![CDATA[<p>上一章了解了synchronized的基本使用方式之后，接下来我们来深入了解了解其底层原理，并且说明对它的优化。</p><a id="more"></a><h2>一、synchronized底层实现原理</h2><p>首先给出一个不是结论的结论，<code>synchronized</code>的实现基础是：<code>JAVA</code>对象头和<code>Monitor</code>，理解了这两者的作用就理解了<code>synchronized</code>的实现原理。下面进行详细讲解。</p><p>⭐然后在正式开始之前，先介绍一下锁的内存语义：</p><ul><li>当线程释放锁时，JAVA内存模型会把该线程对应额本地内存中的共享变量刷新到主内存中</li><li>当线程获取锁时，JAVA内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</li></ul><p>在<a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/" target="_blank" rel="noopener">JAVA内存模型-线程共享</a>这篇文章中介绍了对象头里面的基本构成。</p><p><img src="http://bloghello.oursnail.cn/thread6-1.jpg" alt="image"></p><p>我们着重看一下对象头，下面两个这里不需要关心。我们可以看到一个关键字：锁状态标志。因此<code>Mark Word</code>是实现锁的关键了。</p><p>我们也知道，<code>Mark Word</code>是一个可变的结构，可变的部分主要有如下：</p><p><img src="http://bloghello.oursnail.cn/thread6-2.jpg" alt="image"></p><p>其中，偏向所和轻量级锁是JDK1.6之后对<code>synchronized</code>优化所新加的，后文会探讨对<code>synchronized</code>的优化。</p><p>OK，到这里我们知道了每个对象区域的对象头这一块存储了关于锁的信息，即锁状态。仔细看表格，比如重量级锁，就是我们熟知的<code>synchronized</code>对象锁，它的说明是：指向重量级锁的指针。那这个锁是什么呢？指向的是什么位置呢？这个就不得不提及第二个关键字啦：<code>Monitor</code></p><p><code>Monitor</code>:每个对象打娘胎生下来就自带了一把看不见的锁，成为内部锁或者<code>Monitor</code>锁，也称为管程或者监视器锁。我们可以理解为一种同步工具，也可以理解为同步对象。</p><p>那么回到上面的问题上来，这个指针指向的就是<code>Monitor</code>对象的起始地址，因此，每个对象都会存在一个<code>Monitor</code>与之关联，当这个<code>Monitor</code>被一个线程持有时，它就会处于锁定状态。</p><p>在<code>Hotspot</code>虚拟机中，这个<code>Monitor</code>是由<code>ObjectMonitor</code>实现的，位于虚拟机源码中，用<code>C++</code>实现。我们一起来看看吧！</p><p>这个源码地址为：<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/76a9c9cf14f1/src/share/vm/runtime/objectMonitor.hpp" target="_blank" rel="noopener">objectMonitor.hpp</a></p><p><img src="http://bloghello.oursnail.cn/thread6-3.jpg" alt="image"></p><p>我们看到了几个比较重要的关键字，首先，每个等待获取锁的线程都会被封装为<code>ObjectWaiter</code>对象。<code>_WaitSet</code>就是之前说的所有<code>wait</code>状态的线程都会被放在这里等待唤醒再去竞争锁；<code>_EntryList</code>就是所有等待获取锁的线程对象存放的地方。<code>_owner</code>指向的是当前获取到锁的线程对象。<code>_count</code>为计数，这个就跟可重入相关了，线程进来一次就加一次，为0的时候就说明释放锁了，那么此时处于<code>_EntryList</code>池中的线程都可以去竞争这把锁了。</p><p>将上面文字转换为图来理解就是：</p><p><img src="http://bloghello.oursnail.cn/thread6-4.jpg" alt="image"></p><p>以上就是<code>Synchronized</code>实现锁的原理。</p><h2>二、synchronized在字节码层面的语义</h2><p>我们拿下面这段程序作为示例：</p><p><img src="http://bloghello.oursnail.cn/thread6-5.jpg" alt="image"></p><p>我们对这两个方法进行<code>javap</code>的分析，针对第一个同步代码块：</p><p><img src="http://bloghello.oursnail.cn/thread6-6.jpg" alt="image"></p><p>我们可以看出来，<code>synchronized</code>同步代码块实现同步的关键指令是<code>monitorenter</code>和<code>monitorexit</code>。这恰好与上面说的<code>monitor</code>锁对应上，即多个线程在<code>_EntryList</code>中竞争，看谁能拿到<code>monitor</code>锁的指向全，拿到了就可以进来，拿不到就阻塞在<code>monitorenter</code>处继续等待。知道这个锁被释放了为止。</p><p>那么对于<code>synchronized</code>修饰的方法呢？</p><p><img src="http://bloghello.oursnail.cn/thread6-7.jpg" alt="image"></p><p>如果是同步方法，在字节码层面的表示是略有不同的。我们注意到，是在某个标识位上给其打上<code>ACC_SYNCHRONIZED</code>标志，表示这是一个<code>synchronized</code>修饰的同步方法，那么下面对于锁竞争啥的都与上面一样，所以只是字节码层面的表示不同而已，原理都一样。</p><h2>三、对synchronized的优化</h2><p>对于<code>synchronized</code>的性能，在以前一直是嗤之以鼻的，这种观念从老一代的程序猿们口口相传到如今，可谓是根深蒂固，在以前的版本中，确实是很慢，原因如下：</p><ul><li>早期版本中，<code>synchronized</code>属于重量级锁，依赖于<code>Mutex Lock</code>实现</li><li>线程之间的切换需要从用户态转换到核心态，开销较大</li></ul><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h5>3.1 自旋锁</h5><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p>何谓自旋锁？</p><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p><p>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用<code>-XX:+UseSpinning</code>开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数<code>-XX:PreBlockSpin</code>来调整；</p><p>如果通过参数<code>-XX:preBlockSpin</code>来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h5>3.2 适应自旋锁</h5><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p><p>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h5>3.3 锁消除</h5><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。</p><p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如<code>StringBuffer</code>、<code>Vector</code>、<code>HashTable</code>等，这个时候会存在隐形的加锁操作。比如<code>StringBuffer</code>的<code>append()</code>方法，<code>Vector</code>的<code>add()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">        vector.add(i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM可以明显检测到变量<code>vector</code>没有逃逸出方法<code>vectorTest()</code>之外，所以JVM可以大胆地将<code>vector</code>内部的加锁操作消除。</p><h5>3.4 锁粗化</h5><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p><p>在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。</p><p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：<code>vector</code>每次add的时候都需要加锁操作，JVM检测到对同一个对象（<code>vector</code>）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到<code>for</code>循环之外。</p><h5>3.5 偏向锁</h5><p>在大多数情况下，锁不存在多线程竞争，总是由同一个线程多次获得。</p><blockquote><p>⭐⭐⭐核心的思想是：如果一个线程获得了锁，那么锁就会进入偏向模式，此时<code>Mark Word</code>的结构也变为偏向锁结构，当该结构再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查<code>Mark Word</code>的锁标记位位偏向锁以及当前线程ID等于<code>Mark Word</code>的<code>ThreadId</code>即可，这样省去了大量有关锁申请的操作。</p></blockquote><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换<code>ThreadID</code>的时候依赖一次<code>CAS</code>原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的<code>CAS</code>原子指令的性能消耗）。<strong>上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</strong></p><p>它的思想可以理解为<code>CAS</code>，因此这种锁不适合于锁竞争比较激烈的多线程场合。</p><p>偏向锁的获取和释放：</p><blockquote><ul><li>访问 Mark Word 中偏向锁的标识位是否为1，如果是1，则确定为偏向锁。<ul><li>如果偏向锁的标识位为0，说明此时是处于无锁状态，则当前线程通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；并且将偏向标识位设为1。</li><li>如果偏向锁的标识位不为1，也不为0(此时偏向锁的标识位没有值)，说明发生了竞争，偏向锁已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁。</li></ul></li><li>如果是偏向锁，则判断 Mark Word 中的偏向线程ID是否指向当前线程，如果偏向线程ID指向当前线程，则表明当前线程已经获取到了锁；</li><li>如果偏向线程ID并未指向当前线程，则通过CAS操作尝试获取偏向锁，如果获取锁成功，则将 Mark Word 中的偏向线程ID设置为当前线程ID；</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时(在这个时间点上没有正在执行的字节码)，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>偏向锁的释放：<ul><li>当其它的线程尝试获取偏向锁时，持有偏向锁的线程才会释放偏向锁。</li><li>释放偏向锁需要等待全局安全点(在这个时间点上没有正在执行的字节码)。<ul><li>- 首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，</li><li>- 如果线程还活着，说明此时发生了竞争，则偏向锁升级为轻量级锁，然后刚刚被暂停的线程会继续往下执行同步代码。</li></ul></li></ul></li></ul></blockquote><h5>3.6 轻量级锁</h5><p>引入轻量级锁的主要目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p><p><strong>⭐轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</strong></p><p>轻量级锁的加锁过程：</p><blockquote><p>1.当使用轻量级锁(锁标识位为00)时，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(注:锁记录中的标识字段称为Displaced Mark Word)。</p><p>2.将对象头中的MarkWord复制到栈桢中的锁记录中之后，虚拟机将尝试使用CAS将对象头中Mark Word替换为指向该线程虚拟机栈中锁记录的指针，此时如果没有线程占有锁或者没有线程竞争锁，则当前线程成功获取到锁，然后执行同步块中的代码。</p><p>3.如果在获取到锁的线程执行同步代码的过程中，另一个线程也完成了栈桢中锁记录的创建，并且已经将对象头中的MarkWord复制到了自己的锁记录中，然后尝试使用CAS将对象头中的MarkWord修改为指向自己的锁记录的指针，但是由于之前获取到锁的线程已经将对象头中的MarkWord修改过了(并且现在还在执行同步体中的代码,即仍然持有着锁)，所以此时对象头中的MarkWord与当前线程锁记录中MarkWord的值不同，导致CAS操作失败，然后该线程就会不停地循环使用CAS操作试图将对象头中的MarkWord替换为自己锁记录中MarkWord的值，(当循环次数或循环时间达到上限时停止循环)如果在循环结束之前CAS操作成功，那么该线程就可以成功获取到锁，如果循环结束之后依然获取不到锁，则锁获取失败，对象头中的MarkWord会被修改为指向重量级锁的指针，然后这个获取锁失败的线程就会被挂起，阻塞了。</p><p>4.当持有锁的那个线程执行完同步体之后，使用CAS操作将对象头中的MarkWord还原为最初的状态时(将对象头中指向锁记录的指针替换为Displaced Mark Word )，发现MarkWord已被修改为指向重量级锁的指针，因此CAS操作失败，该线程会释放锁并唤起阻塞等待的线程，开始新一轮夺锁之争，而此时，轻量级锁已经膨胀为重量级锁，所有竞争失败的线程都会阻塞，而不是自旋。</p></blockquote><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>试用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从卖票程序初步看synchronized的特性</title>
      <link href="/2019/02/10/thread/%E4%BB%8E%E5%8D%96%E7%A5%A8%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5%E7%9C%8Bsynchronized%E7%9A%84%E7%89%B9%E6%80%A7/"/>
      <url>/2019/02/10/thread/%E4%BB%8E%E5%8D%96%E7%A5%A8%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5%E7%9C%8Bsynchronized%E7%9A%84%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第五篇，在多线程学习和编程中，synchronized都是我们第一个要碰见的关键字，它很重要，因为它被认为还有优化的空间，并且它代表的是互斥锁的基本思想，JDK或者其他地方的源码随处可见，本文用一个卖票程序来切入synchronized的学习，从语法和使用上进行全面了解，并且对其引申出来的一些概念进行说明。</p><a id="more"></a><h2>1. 线程安全问题产生原因</h2><ul><li>存在共享数据</li><li>存在多条线程共同操作这些共享数据</li></ul><h2>2. 线程安全问题解决方法</h2><p>上面的问题归根结底是由于两个线程访问相同的资源造成的。对于并发编程，需要采取措施防止两个线程来访问相同的资源。</p><p>一种措施是当资源被一个线程访问时，为其加锁。第一个访问资源的线程必须锁定该资源，是其他任务在资源被解锁前不能访问该资源。</p><p>基本上所有的并发模式在解决线程安全问题时，都采用“序列化访问临界资源”的方案。即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问。通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。</p><p>这里来好好谈谈<code>Synchronized</code>实现加锁的方式。</p><h2>3. synchronized修饰符</h2><p><code>synchronized</code>：可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”.</p><p><code>synchronized</code>满足了以下重要特性：</p><ul><li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块进行访问，互斥性也称为操作的原子性。</li><li>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致</li></ul><p>⭐<code>synchronized</code>锁的不是代码，是对象！</p><h5>3.1 不使用synchronized会出现线程不安全问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sellTicket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SellTicket sellTicket = <span class="keyword">new</span> SellTicket();</span><br><span class="line"><span class="comment">//同时开启五个线程去卖票</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(sellTicket, <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某一次运行的结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread2,还剩2</span><br><span class="line">thread1,还剩2</span><br><span class="line">thread3,还剩2</span><br><span class="line">thread4,还剩0</span><br><span class="line">thread5,还剩0</span><br></pre></td></tr></table></figure><p>很显然，多个线程之间打架了，数据混乱了。这是因为，多个线程同时操作<code>run（）</code>方法，对<code>count</code>进行修改，进而造成错误。</p><h5>3.2 使用synchronized来加锁</h5><p>对卖票的核心方法上加上<code>synchronized</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者写成同步代码块的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果只有一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1 count:4</span><br><span class="line">thread4 count:3</span><br><span class="line">thread5 count:2</span><br><span class="line">thread3 count:1</span><br><span class="line">thread2 count:0</span><br></pre></td></tr></table></figure><p>结果是正确的，可以看出代码A和代码B的区别就是在<code>sellTicket()</code>方法上加上了<code>synchronized</code>修饰。</p><p><strong>说明</strong>：当多个线程访问<code>MyThread</code> 的<code>run</code>方法的时候，如果使用了<code>synchronized</code>修饰，那个多线程就会以排队的方式进行处理（这里排队是按照CPU分配的先后顺序而定的），一个线程想要执行<code>synchronized</code>修饰的方法里的代码，首先是尝试获得锁，如果拿到锁，执行<code>synchronized</code>代码体的内容，如果拿不到锁的话，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且多个线程同时去竞争这把锁，也就是会出现锁竞争的问题。</p><h5>3.3 一个对象有一把锁！不同对象不同锁！</h5><p>每次开启一个线程就new一个对象的话，即对每个不同的对象加锁，则互不干扰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程任务<code>SellTicket()</code>无论给不给<code>sellTicket()</code>加锁，结果都是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1,还剩4</span><br><span class="line">thread2,还剩4</span><br><span class="line">thread3,还剩4</span><br><span class="line">thread5,还剩4</span><br><span class="line">thread4,还剩4</span><br></pre></td></tr></table></figure><p>这是因为我这里是五个不同的对象，每个对象各自获取自己的锁，互不影响，所以都是4.</p><p>关键字<code>synchronized</code>取得的锁都是对象锁，而不是把一段代码或方法当做锁，所以上述实例代码C中哪个线程先执行<code>synchronized</code> 关键字的方法，那个线程就持有该方法所属对象的锁，五个对象，线程获得的就是两个不同对象的不同的锁，他们互不影响的。</p><p>那么，我们在正常的场景的时候，肯定是有一种情况的就是，一个类<code>new</code>出来的所有对象会对一个变量<code>count</code>进行操作，那么如何实现哪？很简单就是加<code>static</code>，我们知道，用<code>static</code>修改的方法或者变量，在该类的所有对象是具有相同的引用的，这样的话，无论实例化多少对象，调用的都是一个方法。</p><p><code>Main</code>函数不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread3"</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread4"</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SellTicket(), <span class="string">"thread5"</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">t4.start();</span><br><span class="line">t5.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SellTicket</code>则在卖票方法上增加<code>static</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sellTicket();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者显示地锁住<code>Class</code>对象，即锁住类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SellTicket.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">",还剩"</span>+count);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"票卖光了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1,还剩4</span><br><span class="line">thread2,还剩3</span><br><span class="line">thread4,还剩2</span><br><span class="line">thread3,还剩1</span><br><span class="line">thread5,还剩0</span><br></pre></td></tr></table></figure><p>仔细看，我们给<code>sellTicket</code>设定为<code>static</code>静态方法，那么这个方法就从之前的对象方法上升到类级别方法，这个类所有的对象都调用的同一个方法。实现资源的共享和加锁。</p><p>上面讲的时对象锁和类锁，前者锁定的是某个实例对象，后者锁定的是Class对象。下面总结一下：</p><ul><li>有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块</li><li>若锁住的时同一个对象，一个线程在访问对象的同步代码块(同步方法)时，另一个访问对象的同步代码块(同步方法)的线程会被阻塞</li><li>同一个类的不同对象的对象锁互不干扰</li><li>类锁由于也是一种特殊的对象锁，因此表现与上述一致，只是由于一个类只有一把类锁，所以同一个类的不同对象使用类锁是同步的</li><li>类锁和对象锁互不干扰</li></ul><h2>4. Synchronized锁重入</h2><h5>4.1 什么是可重入锁</h5><p>锁的概念就不用多解释了,当某个线程A已经持有了一个锁,当线程B尝试进入被这个锁保护的代码段的时候.就会被阻塞.</p><p><strong>⭐而锁的操作粒度是&quot;线程”,而不是调用.同一个线程再次进入同步代码的时候.可以使用自己已经获取到的锁,这就是可重入锁。</strong></p><h5>4.2 可重入锁的小例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDubbo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method1..."</span>);</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method2..."</span>);</span><br><span class="line">method3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"method3..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SyncDubbo syncDubbo = <span class="keyword">new</span> SyncDubbo();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">syncDubbo.method1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码向我们演示了，如何在一个已经被<code>synchronized</code>关键字修饰过的方法再去调用对象中其他被<code>synchronized</code>修饰的方法。</p><h5>4.3 为什么要可重入</h5><p>我们上一篇文章中介绍了“一个对象一把锁，多个对象多把锁”，可重入锁的概念就是：<strong>自己可以获取自己的内部锁</strong>。</p><p><strong>假如有1个线程T获得了对象A的锁，那么该线程T如果在未释放前再次请求该对象的锁时</strong>，如果没有可重入锁的机制，是不会获取到锁的，这样的话就会出现死锁的情况。</p><p>就如代码A体现的那样，线程T在执行到<code>method1（）</code>内部的时候，由于该线程已经获取了该对象<code>syncDubbo</code> 的对象锁，当执行到调用<code>method2（）</code> 的时候，会再次请求该对象的对象锁，如果没有可重入锁机制的话，由于该线程T还未释放在刚进入<code>method1（）</code> 时获取的对象锁，当执行到调用<code>method2（）</code> 的时候，就会出现死锁。</p><h5>4.4 可重入锁到底有什么用哪？</h5><p>正如上述代码A和（4.3）中解释那样，最大的作用是避免死锁。假如有一个场景：用户名和密码保存在本地txt文件中，则登录验证方法和更新密码方法都应该被加<code>synchronized</code>，那么当更新密码的时候需要验证密码的合法性，所以需要调用验证方法，此时是可以调用的。</p><h5>4.5  什么是死锁？</h5><p>线程A当前持有互斥所锁<code>lock1</code>，线程B当前持有互斥锁<code>lock2</code>。接下来，当线程A仍然持有<code>lock1</code>时，它试图获取<code>lock2</code>，因为线程B正持有<code>lock2</code>，因此线程A会阻塞等待线程B对<code>lock2</code>的释放。如果此时线程B在持有<code>lock2</code>的时候，也在试图获取<code>lock1</code>，因为线程A正持有<code>lock1</code>，因此线程B会阻塞等待A对<code>lock1</code>的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p><p>一个例子来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">System.out.println(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">System.out.println(<span class="string">"b"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">DeadLock d = <span class="keyword">new</span> DeadLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">d.a();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">d.b();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>产生死锁的原因主要是：</strong></p><ul><li>（1） 因为系统资源不足。</li><li>（2） 进程运行推进的顺序不合适。</li><li>（3） 资源分配不当等。</li></ul><p><strong>如何解决死锁：</strong></p><ul><li>尽量一个线程只获取一个锁。</li><li>一个线程只占用一个资源。</li><li>尝试使用定时锁，至少能保证锁最终会被释放。</li></ul><h5>4.6 可重入锁支持在父子类继承的环境中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">super</span>.doSomething();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行子类的方法的时候,先获取了一次<code>Widget</code>的锁,然后在执行<code>super</code>的时候,就要获取一次,如果不可重入,那么就跪了.</p><p>在这里，可能会产生疑问：</p><blockquote><p>重入”代表一个线程可以再次获得同一个对象的锁。可是你给出的代码示例中，我理解的是一个线程调用<code>Child</code>的<code>doSomething</code>方法前或得了<code>Child</code>对象的锁，<code>super.doSomething</code>方法调用时，次线程获得了<code>Child</code>对象父对象的锁。两个锁属于不同的对象，这还算是重入吗？</p></blockquote><p>解释：当<code>Child</code>实例对象调用<code>doSomething</code>方法时，此时持有的是<code>Child</code>实例对象的锁，之后调用<code>super.doSomething();</code>，这时仍然对于<code>Child</code>实例对象加锁，因为此时仍然使用的是<code>Child</code>实例对象内存空间的数据。</p><p>至于这句话的理解，就牵涉到继承的机制：</p><blockquote><p>在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。</p></blockquote><p>之所以网上有很多说只继承<code>protected</code>或者<code>private</code>的，是因为从语言的角度出发的：</p><p><img src="https://uploadfiles.nowcoder.net/images/20171019/1829253_1508380548300_1372D420D0F13C1126C6FCB3DC35A515" alt="image"></p><p>从内存的角度来看，的确是继承了的，可以写一个简单的继承类，debug看子类的属性是否存在父类的private属性，事实证明是有的。</p><p>针对这里有人说：不是创建一个父类对象，而只是创建一个父类空间并进行相应的初始化。对此，我一开始也是这么想的，不过当我看到这个答案的时候，又觉得很有道理：</p><blockquote><p>会创建父类对象。《Java编程思想》（第四版）129页，当创建一个导出类对象时，该对象包含了一个基类的子对象，这子对象与你用基类直接创建的对象是一样的，二者区别在于后者来源于外部，而基类的子对象被包装在导出类对象内部。</p></blockquote><h2>5. 发生异常时会自动释放锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" , i= "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                Integer.parseInt(<span class="string">"a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SyncException se = <span class="keyword">new</span> SyncException();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                se.operation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t1 , i= 2</span><br><span class="line">t1 , i= 3</span><br><span class="line">t1 , i= 4</span><br><span class="line">t1 , i= 5</span><br><span class="line">t1 , i= 6</span><br><span class="line">t1 , i= 7</span><br><span class="line">t1 , i= 8</span><br><span class="line">t1 , i= 9</span><br><span class="line">t1 , i= 10</span><br><span class="line">java.lang.NumberFormatException: For input string: &quot;a&quot;</span><br><span class="line">    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">    //其他输出信息</span><br></pre></td></tr></table></figure><p>关于<code>synchronized</code>的优化放到后文去讲。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程重要的相关方法</title>
      <link href="/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第四篇，本篇文章主要来看看线程相关的几个重要方法。</p><a id="more"></a><h2>wait和sleep</h2><p>他们最基本的差异是：</p><ul><li><code>wait</code>是<code>Object</code>的一个方法，<code>sleep</code>是<code>Thread</code>类的方法</li><li><code>sleep</code>可以在任何地方使用，但是<code>wait</code>方法只能在<code>synchronied</code>方法或<code>synchronied</code>块中使用</li></ul><p>本质的区别是：</p><ul><li><code>Thread.sleep</code>只会让出CPu，不会导致锁行为的改变</li><li><code>Object.wait</code>不仅让出CPU，还会释放已经占用的同步资源锁</li></ul><p>这个区别也就解释了为什么<code>wait</code>方法只能在<code>synchronied</code>方法或<code>synchronied</code>块中使用，因为没有获取过锁哪里来的释放锁呢？所以释放锁的前提是要获取锁。</p><p>下面来验证一下，眼见为实！</p><p><img src="http://bloghello.oursnail.cn/thread4-1.jpg" alt="image"></p><p>对于<code>sleep</code>来说是没有锁的要求的，既不用获取锁也不用释放锁，关于这一点就不再验证了。</p><h2>notify和notifyAll</h2><p>先来了解一下锁池和等待池的概念。</p><ul><li>锁池EntryLisy</li></ul><blockquote><p>假设线程A已经拥有了某个对象(不是类)的锁，而其他线程B、C想要调用这个对象的某个synchronized方法或块，由于B、C线程在进入对象的synchronized方法或块之前必须先获得该对象锁得拥有权，而恰巧该对象的锁正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待所得释放，这个地方就是该对象得锁池。</p></blockquote><ul><li>等待池WaitSet</li></ul><blockquote><p>假设线程A调用了某个对象的wait方法后，线程A就会释放该对象得锁，同时线程A句进入到该对象得等待池中，进入到等待池中得线程不会去竞争该对象的锁。</p></blockquote><p><code>notify</code>的作用就是<strong>随机</strong>唤醒<strong>一个</strong>线程进入等待池的线程，而<code>notifyAll</code>是唤醒所有处于等待池中线程，唤醒之后就可以再去竞争获得锁的机会了。</p><p>刚才的例子稍微改造一下，来了解一下<code>notify</code>的作用。还拿刚才那个例子：</p><p><img src="http://bloghello.oursnail.cn/thread4-2.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/thread4-3.jpg" alt="image"></p><h2>yield</h2><p><img src="http://bloghello.oursnail.cn/thread4-4.jpg" alt="image"></p><p>当调用<code>Thread.yield()</code>函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。并且它也不会释放当前线程占用的锁。</p><p><code>yield()</code>与无参的<code>wait()</code>的区别：</p><ul><li>执行<code>yield()</code>后，当前线程由运行状态变为就绪状态。执行<code>wait</code>后，当前线程会失去对象的锁，状态变为<code>WAITING</code>状态。</li><li>执行<code>yield()</code>后，当前线程不会释放锁。执行<code>wait</code>后，当前线程会释放锁。</li></ul><p>比较简单，就不举例了。</p><h2>interrupt</h2><p>它只是通知线程应该中断了。</p><ul><li>如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个<code>interruptedException</code>异常</li><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><p>也就是说，中断一个线程是由被调用的线程状态和自己程序判断决定的。</p><ul><li>阻塞状态下，线程会立即退出，并抛出异常</li><li>正常状态下，需要被调用的线程检查中断标志位，然后再根据中断标志位自行地停止线程</li></ul><p>下面写一个demo来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable interruptTask = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程</span></span><br><span class="line">                    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                        i++;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" ("</span> + Thread.currentThread().getState() + <span class="string">") loop "</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ("</span> + Thread.currentThread().getState() + <span class="string">") catch InterruptedException."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(interruptTask, <span class="string">"t1"</span>);</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is new."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.启动“线程t1”</span></span><br><span class="line">        t1.start();                      </span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is started."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.主线程休眠300ms，然后主线程给t1发“中断”指令。</span></span><br><span class="line">        Thread.sleep(<span class="number">400</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.主线程休眠300ms，然后查看t1的状态。</span></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted now."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 (NEW) is new.</span><br><span class="line">t1 (RUNNABLE) is started.</span><br><span class="line">t1 (RUNNABLE) loop 1</span><br><span class="line">t1 (RUNNABLE) loop 2</span><br><span class="line">t1 (RUNNABLE) loop 3</span><br><span class="line">t1 (TIMED_WAITING) is interrupted.</span><br><span class="line">t1 (RUNNABLE) catch InterruptedException.</span><br><span class="line">t1 (TERMINATED) is interrupted now.</span><br></pre></td></tr></table></figure><p>首先，是就绪状态，为<code>new</code>；接下来启动这个线程，状态变为<code>started</code>，由于此时一切安好，没有“打扰”这个线程的执行，所以每隔100毫秒打印一句<code>(RUNNABLE) loop i</code>出来；在400毫秒的安好之后，给他一个<code>t1.interrupt();</code>，此时线程可能恰好在执行<code>sleep</code>睡觉呢，这个<code>interrupt</code>一看你在阻塞(睡觉)，那还得了，立马停止这个线程并且抛出异常。</p><p>但是话说回头，本程序还用了if判断，只要标志位为<code>false</code>就不停循环，一旦标志位变为<code>true</code>则立马退出循环。所以即使你不睡觉，但是我还是能通过这个If来终止你的循环。</p><h2>join</h2><p><code>join</code>是加入的意思，非常形象生动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die.</span></span><br><span class="line"><span class="comment"> * 调用方线程（调用join方法的线程）执行等待操作，</span></span><br><span class="line"><span class="comment"> * 直到被调用的线程（join方法所属的线程）结束，再被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现如下：</p><p><img src="http://bloghello.oursnail.cn/thread4-5.jpg" alt="image"></p><p>我们知道<code>wait</code>是需要释放当前线程所占的对象锁的，而<code>join</code>基于<code>wait</code>实现，显然是可以的。</p><p>这里判断如果线程还在运行中的话，则继续等待，如果指定时间到了，或者线程运行完成了，则代码继续向下执行，调用线程就可以执行后面的逻辑了。</p><p>但是在这里没有看到哪里调用<code>notify</code>或者<code>notifyAll</code>方法，如果没有调用的话，那调用方线程会一直等待下去，那是哪里调用了唤醒它的方法呢？通过查证得知，原来在线程结束时，java虚拟机会执行该线程的本地<code>exit</code>方法，这个<code>exit</code>方法里面会调用<code>notifyAll</code>方法，唤醒所有等待的线程。</p><p>下面来两个例子来彻底理解它的用法。</p><p>例子一：有耐心的男孩：</p><p><img src="http://bloghello.oursnail.cn/thread4-6.jpg" alt="image"></p><blockquote><p>男孩和女孩准备出去逛街</p><p>女孩开始化妆,男孩在等待。。。</p><p>女孩化妆完成！，耗时5000</p><p>男孩和女孩开始去逛街了</p></blockquote><p>就是男孩和女孩准备去逛街，女孩要化妆先，等女孩化妆完成了，再一起去逛街。</p><p>例子二：没有耐心的男孩：</p><p><img src="http://bloghello.oursnail.cn/thread4-7.jpg" alt="image"></p><blockquote><p>男孩和女孩准备出去逛街</p><p>女孩开始化妆,男孩在等待。。。</p><p>男孩等了2000, 不想再等了，去逛街了</p><p>女孩化妆完成！，耗时5000</p></blockquote><p>男孩等了<code>join(time)</code>中的<code>time</code>时间，如果这个<code>time</code>时间到达之后，女孩所在的线程还没执行完，则不等待了，继续执行后面的逻辑，就是不等女孩了，自己去逛街。</p><h2>总结</h2><p>了解了这些核心方法之后，就可以对下面这幅图简单说一说啦：</p><p><img src="http://bloghello.oursnail.cn/thread2-9.jpg" alt="image"></p><p>首先是<code>new Thread()</code>只是新建状态，只有<code>start</code>之后才会进入<code>runnable</code>状态，注意这个状态里面可能有两种状态，一种是正在运行，即<code>running</code>，还有一种是就绪状态即<code>ready</code>，这两个状态归属于一类的原因是他们之间是在不断切换的，即CPU的时间片内临幸到这个进程，这个进程中有若干个线程的话，就会高速地切换各个线程逐个执行，达到宏观上是并行执行的效果。我们知道<code>yield</code>是给线程调度器一个暗示让出当前执行的线程的时间片，至于这个线程调度器听不听那就不知道了，所以存在一定的随机性。如果正常执行结束就进入最后的终止状态。往右边看，如果发生带时间的超时等待，如<code>sleep(100)</code>，本线程会阻塞，让出CPU执行权并且不改变锁状态，与之区别的是<code>wait(100)</code>这个方法不仅让出CPU执行权，还会释放锁，所以要调用<code>wait</code>方法必然要先获取锁，所以一般都是在<code>synchronized</code>中调用它。至于<code>join(100)</code>是指阻塞当前线程，让其他的线程先执行，底层是<code>wait</code>所以也会释放锁。超时等待只要等它时间过了就可以跳出阻塞状态了，或者用<code>notify</code>或者<code>interrupt</code>之类的来唤醒或者打断它。往左下角看，是锁获取的时候可能发生阻塞，这个时候只能等其他线程释放锁才行了。往左边看，是无限期等待的代表，唤醒手段与有限期等待是一样的。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程的状态</title>
      <link href="/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
      <url>/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
      <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第三篇，主要介绍一下线程的几个状态的含义。</p><a id="more"></a><p><code>Thread</code>类源码中规定了几种线程的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实源码中已经详细说明了这几种状态的含义以及发生的时机。下面还是再看看：</p><ul><li>新建(<code>new</code>)：创建后尚未启动的线程的状态</li><li>运行(<code>Runnable</code>)：包含<code>Running</code>和<code>Ready</code>两种状态</li><li>无限期等待(<code>Waiting</code>)：不会被分配CPU执行时间，需要显式被唤醒<ul><li>无<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>无<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.park()</code>方法</li></ul></li><li>限期等待(<code>Timed Waiting</code>)：不会被分配CPU执行时间，在一定时间后会由系统自动唤醒<ul><li><code>Thread.sleep()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Object.wait()</code>方法</li><li>设置了<code>Timeout</code>参数的<code>Thread.join()</code>方法</li><li><code>LockSupport.parkNanos()</code>方法</li><li><code>LockSupport.parkUntil()</code>方法</li></ul></li><li>阻塞(<code>Blocked</code>)：等待获取排他锁</li><li>结束(<code>Terminated</code>)：已终止线程的状态，线程已经结束执行</li></ul><p>既然有这么多线程状态，那么必然会存在状态的转换，他们的状态是如何转换的呢？下面这张图就是比较全面的状态转换图：</p><p><img src="http://bloghello.oursnail.cn/thread2-9.jpg" alt="image"></p><p>初学者看到这张图一张是比较晕的，各种乱七八糟的东西堆在这里实在是难以下咽，不过一开始不能完全看懂是很正常的，需要进一步地学习一些细节，不断地来回顾，总有一天就会真正理解了。</p><p>下面就是要详细说说<code>Thread</code>类里面的一些方法啦，理解了这些方法，状态的切换图便一目了然。为了限制篇幅，本文先说到这里。</p>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java多线程之传参和返回值处理</title>
      <link href="/2019/02/10/thread/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86/"/>
      <url>/2019/02/10/thread/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第二篇，对于传参和返回值的问题，是面试中关于多线程这一块问得比较多的问题了，这里进行详细的说明。</p><a id="more"></a><h2>一、如何给run()方法传参</h2><p>我们知道多线程是通过<code>star()</code>方法让线程处于准备就绪状态，而实际运行的业务逻辑是放在<code>run()</code>方法体中的，但是<code>run()</code>方法是没有参数的方法，实际的业务场景中，我们可能需要向方法体中传递参数，实现的方式主要有三种：</p><ul><li>构造函数传参，这个在上一篇文章中已经演示了。</li><li>成员变量传参，这个就是依靠<code>set</code>方法。</li><li>回调函数传参，这个稍微特殊一点。这里说明一下。</li></ul><p>上面的两种向线程中传递数据的方法是最常用的。但这两种方法都是<code>main</code>方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。</p><p>然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的<code>run</code>方法中产生了3个随机数，然后通过<code>Work</code>类的<code>process</code>方法求这三个随机数的和，并通过<code>Data</code>类的<code>value</code>将结果返回。从这个例子可以看出，在返回<code>value</code>之前，必须要得到三个随机数。也就是说，这个 <code>value</code>是无法事先就传入线程类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span>  value =  <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Work</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">process</span><span class="params">(Data data, Integer[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>  ( <span class="keyword">int</span>  n : numbers) &#123;</span><br><span class="line">            data.value += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>  <span class="title">MyThread3</span>  <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Work work;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">MyThread3</span><span class="params">(Work work)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span> .work = work;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.随机生成3个数放进数组中</span></span><br><span class="line">        java.util.Random random =  <span class="keyword">new</span>  java.util.Random();</span><br><span class="line">        Data data =  <span class="keyword">new</span>  Data();</span><br><span class="line">        <span class="keyword">int</span>  n1 = random.nextInt( <span class="number">1000</span> );</span><br><span class="line">        <span class="keyword">int</span>  n2 = random.nextInt( <span class="number">2000</span> );</span><br><span class="line">        <span class="keyword">int</span>  n3 = random.nextInt( <span class="number">3000</span> );</span><br><span class="line">        Integer[] numbers = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">        numbers[<span class="number">0</span>] = n1;</span><br><span class="line">        numbers[<span class="number">1</span>] = n2;</span><br><span class="line">        numbers[<span class="number">2</span>] = n3;</span><br><span class="line">        <span class="comment">//调用函数去计算这三个数之和，计算的结果存在Data实例中的value属性中</span></span><br><span class="line">        <span class="comment">//这里process相当于回调函数，我调用这个函数，给我一个计算结果</span></span><br><span class="line">        work.process(data, numbers);    </span><br><span class="line">        System.out.println(String.valueOf(n1) +  <span class="string">"+"</span>  + String.valueOf(n2) +  <span class="string">"+"</span></span><br><span class="line">                + String.valueOf(n3) +  <span class="string">"="</span>  + data.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t =  <span class="keyword">new</span>  MyThread3( <span class="keyword">new</span>  Work());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一次的执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">707+678+173=1558</span><br></pre></td></tr></table></figure><p>在上面代码中的<code>process</code>方法被称为回调函数。从本质上说，回调函数就是事件函数。在<code>Windows API</code>中常使用回调函数和调用API的程序之间进行数据交互。因此，调用回调函数的过程就是最原始的引发事件的过程。在这个例子中调用了<code>process</code>方法来获得数据也就相当于在<code>run</code>方法中引发了一个事件。</p><h2>二、如何处理线程返回值</h2><p>由于线程相当于一个异步的处理函数，想要获取它的结果就不能像传统的获取它的<code>return</code>的值那么简单了，主要问题就在于它什么时候能处理好是不知道的，需要一定的机制去等待它处理好了再去获取它的处理结果。方式一般有三种。</p><h5>2.1 主线程等待法</h5><p>这个方法是最简单也是最容易想到的处理方式。下面搞个实例来看看大概是如何操作的。</p><p>首先写一个类，写这个的含义是，假如主线程不等待，将会一口气执行到最后一行，此时子线程可能还没执行完。就会出现打印空。</p><p><img src="http://bloghello.oursnail.cn/thread2-1.jpg" alt="image"></p><p>那么我们的主线程如何获取到子线程中赋予的值呢？一种方式就是死等，不停地轮询看你的值是否已经计算好了，一旦计算好就可以拿到这个值。类似于以下：</p><p><img src="http://bloghello.oursnail.cn/thread2-2.jpg" alt="image"></p><p>其实这就是自旋，即CPU停在这里等待，不能干其他事情，这必然会大大浪费CPU资源，所以虽然这种方式实现起来非常简单，但是不适合用。另外的缺点就是代码臃肿，比如我要等待的值不止一个，有多个，那是不是要写多个while循环来等待呢？此外，我们大多时候根本不知道这个子线程到底要执行多久，因为我们这里是每隔100毫秒轮询一次，那假如这个值在这100毫秒内值已经有了，那么是不能立即获取的。</p><p>针对以上不能精准控制的缺点，这里便有了第二种方法。</p><h2>Join方法</h2><p><code>Thread</code>类中的<code>join</code>方法可以阻塞当前线程以等待子线程处理完毕。</p><p><img src="http://bloghello.oursnail.cn/thread2-3.jpg" alt="image"></p><p>在这里，由于是在主线程中调用的<code>join</code>，所以阻塞主线程，让子线程执行完毕再继续执行。</p><p>这种方法更简单，但是存在多个子线程的情况下，做到灵活以及精准控制是做不到的。</p><h2>Callable接口实现</h2><p>JAVA提供了有返回值的任务，即实现了<code>Callable</code>接口的任务，执行这个任务之后可以获取一个叫做<code>Futrue</code>的对象，通过<code>get()</code>就可以获取<code>Callable</code>任务返回的内容。</p><p>具体是如何获取返回的内容呢？有两种方式，一个是通过<code>FutureTask</code>这个类来获取，一个是通过线程池获取。</p><p>对于第一种方式，我们通过例子来理解。</p><p>先新建一个实现了<code>Callable</code>接口的任务：</p><p><img src="http://bloghello.oursnail.cn/thread2-5.jpg" alt="image"></p><p>把<code>Callable</code>任务放进<code>FutureTask</code>中，这个<code>FutureTask</code>再放进<code>Thread</code>中去执行：</p><p><img src="http://bloghello.oursnail.cn/thread2-4.jpg" alt="image"></p><p>发现我们的程序并没有显示地等待，<code>FutureTask</code>的<code>get()</code>方法完成了等待和获取返回值。下面来看看<code>Future</code>的继承关系：</p><p><img src="http://bloghello.oursnail.cn/thread2-6.jpg" alt="image"></p><p>我们发现，<code>FutureTask</code>实质上都是<code>Runnable</code>接口的实例，只是它还是<code>Futrue</code>接口的实例，所以不仅可以作为一个线程任务被执行，还可以接受一个<code>Callable</code>接口去接受它的返回值。因此是一个升级版的<code>Runnable</code>实例。</p><p>说完了<code>FutureTask</code>的实现方式，下面再来看看另一种方式，即线程池来实现。关于线程池，后文还会详细介绍，这里只是简单先运用一下。</p><p><img src="http://bloghello.oursnail.cn/thread2-7.jpg" alt="image"></p><p>达到了一样的效果。我们来分析分析。</p><p><img src="http://bloghello.oursnail.cn/thread2-8.jpg" alt="image"></p><p>我们发现，其实两种方式的根本就是<code>Future</code>这个接口，第一种是直接用了<code>FutureTask</code>这个类来手动实现，即不仅需要它接收一个<code>Callable</code>任务，还需要将其作为一个线程任务去手动执行。而第二种方式就比较简单了，有了线程池，我直接把<code>Callable</code>任务扔线程池去<code>submit</code>，就可以得到一个可以获取返回值的<code>Future</code>类型对象，就可以根据这个对象获取到值了。</p><p>所以两种方式本质上是一样一样的。</p><p>下面补充一下关于<code>Runnable</code>和<code>Callable</code>两者的区别：</p><p>表面区别：</p><ul><li><code>Runnable</code>不返回任务执行结果，<code>Callable</code>可返回任务执行结果</li><li><code>Callable</code>在任务无法计算结果时抛出异常，而<code>Runnable</code>不能</li></ul><p>本质区别：</p><ul><li><code>Runnable</code>的<code>call</code>方法是被线程调用的，在<code>run</code>方法中是异步执行的；而<code>callable</code>的<code>call</code>方法不是异步执行的，是由<code>Future</code>的<code>run</code>方法调用的</li></ul>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程基本知识梳理</title>
      <link href="/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
      <url>/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文是关于JAVA多线程和并发的第一篇，主要说明基本概念，这是面试中最基本的要会的东西，如果这些都回答不了，基本上就没有机会了，本文从源码稍微深入一点去探讨常见的基本概念。本文并不会从最最最最基本的知识开始说起，将不费笔墨直击要害，所以需要一点多线程的基本知识才行，这也符合本博客的宗旨，即知识点再次提炼和升级。</p><a id="more"></a><h2>一、进程和线程的区别</h2><p>这一块详见 <a href="http://fourcolor.oursnail.cn/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">面试-进程与线程</a> 里面的内容，相信已经够用了。</p><h2>二、start()和run()方法的区别</h2><p>以一个小例子入手，在主函数中尝试新建一个线程，并且以<code>t.run()</code>的形式去调用，从结果可以看出，java默认开启主线程来执行，当我们用<code>t.run()</code>去执行的时候，只是相当于简单的函数调用，因为从打印结果可以看出都是<code>main</code>进程，那么，实质上并没有新建一个子线程。</p><p><img src="http://bloghello.oursnail.cn/thread1-1.jpg" alt="image"></p><p>（注意，不是一调用就会去执行，而是说这个线程处于就绪状态，将有资格获得CPU的临幸，关于线程状态，后文会再次详细说明，关于start之后处于就绪状态这一点默认读者是清楚的，下面表述可能不会太顾及说明这一点）：</p><p><img src="http://bloghello.oursnail.cn/thread1-2.jpg" alt="image"></p><p>那么，从表象上我们已经知道，<code>run</code>只是简单的函数调用，<code>start</code>才会真正地开启一个新线程来执行，下面从源码层面来看看<code>start()</code>的基本实现方式。</p><p><img src="http://bloghello.oursnail.cn/thread1-3.jpg" alt="image"></p><p>说明一下，本源码是基于JDK1.8，我们看到它的核心实现是一个<code>native</code>方法，IDEA上已经看不了，只好去看看<code>openJDK</code>了。</p><p>直接打开网址： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/f0b93fbd8cf8/src/share/native/java/lang/Thread.c" target="_blank" rel="noopener">Thread.c</a>  我们可以看到：</p><p><img src="http://bloghello.oursnail.cn/thread1-4.jpg" alt="image"></p><p>我们看到很多关于线程的方法，但是这里是看不到具体的实现的，我们看到上面引入了<code>jvm.h</code>的库，所以实现应该是在<code>jvm</code>相关的代码中，直接点开： <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/76a9c9cf14f1/src/share/vm/prims/jvm.cpp" target="_blank" rel="noopener">jvm.cpp</a>  可以看到如下：</p><p><img src="http://bloghello.oursnail.cn/thread1-5.jpg" alt="image"></p><p>emmm，虽然不大看得懂，但是我们确实看到了<code>start()</code>会调用虚拟机去创建一个新的线程，最终再去调用<code>run</code>方法去执行。所以流程如下：</p><p><img src="http://bloghello.oursnail.cn/thread1-6.jpg" alt="image"></p><p>最终总结：</p><ul><li>调用<code>start()</code>方法会创建一个新的子线程并启动</li><li><code>run()</code>方法只是<code>thread</code>的一个普通方法的调用</li></ul><h2>三、Thread和Runnable是什么关系</h2><p>还是老规矩，先来翻翻源码：</p><p>我们可以看到，<code>Thread</code>是一个<code>class</code>，而<code>Runnable</code>是一个<code>interface</code>，而<code>Runnable</code>中只有一个抽象方法就是<code>run()</code>.</p><p><img src="http://bloghello.oursnail.cn/thread1-7.jpg" alt="image"></p><p>那么，我们上面说到，新建一个线程是要靠<code>start()</code>来实现的，那么<code>Runnable</code>是如何来新建一个线程呢？它不是只有一个<code>run()</code>方法吗？</p><p>此时再来看<code>Thread</code>类，它里面有大量的方法，就包含了<code>run()</code>和<code>start()</code>方法，它还有一个重要的构造函数为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>就是说，传入<code>Runable</code>接口实例，再调用<code>Thread</code>的<code>start()</code>方法创建子线程，再来调用重写的<code>run()</code>方法就可以了。下面举个例子。</p><p>先说说用<code>Thread</code>的方式来创建一个子线程类：</p><p><img src="http://bloghello.oursnail.cn/thread1-8.jpg" alt="image"></p><p>这也从侧面证明了，线程是交替执行的，但是因为属于同一个进程，共享同一个地址和资源，所以不需要进行切换，极大提高了CPU执行效率。</p><p>下面再来看看<code>Runnable</code>接口是怎么实现多线程的：</p><p><img src="http://bloghello.oursnail.cn/thread1-9.jpg" alt="image"></p><p>总结一下他们俩：</p><ul><li><code>Thread</code>是一个类，<code>Runnable</code>是一个接口，前者实现后者</li><li><code>Thread</code>有<code>start</code>方法，结合<code>run()</code>可以实现多线程，但是<code>Runnable</code>没有<code>start()</code>方法，所以要通过<code>Thread()</code>来实现，所以，两种方式最终都是通过<code>Thread</code>的<code>start()</code>来实现<code>run()</code>的多线程特性</li><li>由于JAVA是单一继承的，所以推荐多使用<code>Runnable</code>接口</li></ul>]]></content>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实例说明类加载过程</title>
      <link href="/2019/02/09/JVM/%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/02/09/JVM/%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十三篇文章，本文从一个简单程序入手，将前面所学串联起来，详细来看看类加载的过程到底是什么样子的。</p><a id="more"></a><h2>零、Java虚拟机启动、加载类过程分析</h2><p>下面我将定义一个非常简单的java程序并运行它，来逐步分析java虚拟机启动的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.luanlouis.jvm.load;  </span><br><span class="line"><span class="keyword">import</span> sun.security.pkcs11.P11Util;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Hello,World!"</span>);  </span><br><span class="line">  </span><br><span class="line">        ClassLoader loader = P11Util.class.getClassLoader();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(loader);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>windows</code>命令行下输入： <code>java org.luanlouis.jvm.load.Main</code></p><p>当输入上述的命令时： <code>windows</code>开始运行<code>{JRE_HOME}/bin/java.exe</code>程序，<code>java.exe</code> 程序将完成以下步骤：</p><blockquote><p>1.根据JVM内存配置要求，为JVM申请特定大小的内存空间；</p><p>2.创建一个引导类加载器实例，初步加载系统类到内存方法区区域中；</p><p>3.创建JVM 启动器实例 <code>Launcher</code>,并取得类加载器<code>ClassLoader</code>；</p><p>4.使用上述获取的<code>ClassLoader</code>实例加载我们定义的 <code>org.luanlouis.jvm.load.Main</code>类；</p><p>5.加载完成时候JVM会执行Main类的<code>main</code>方法入口，执行Main类的<code>main</code>方法；</p><p>6.结束，java程序运行结束，JVM销毁。</p></blockquote><p>下面逐一分析一下这几个步骤。</p><h3>一、根据JVM内存配置要求，为JVM申请特定大小的内存空间</h3><p>JVM内存按照功能上的划分，可以粗略地划分为方法区(<code>Method Area</code>) 和堆(<code>Heap</code>),而所有的类的定义信息都会被加载到方法区中。</p><p><img src="http://bloghello.oursnail.cn/jvm9-1.jpg" alt="image"></p><h3>二、创建一个引导类加载器实例，初步加载系统类到内存方法区区域中</h3><p>JVM申请好内存空间后，JVM会创建一个<strong>引导类加载器</strong>（<code>Bootstrap Classloader</code>）实例，引导类加载器是使用<code>C++</code>语言实现的，负责加载JVM虚拟机运行时所需的基本系统级别的类，如<code>java.lang.String</code>, <code>java.lang.Object</code>等等。<br>引导类加载器(<code>Bootstrap Classloader</code>)会读取 <code>{JRE_HOME}/lib</code> 下的jar包和配置，然后将这些系统类加载到方法区内。</p><p>本例中，引导类加载器是用 <code>{JRE_HOME}/lib</code>加载类的，不过，你也可以使用参数 <code>-Xbootclasspath</code> 或 系统变量<code>sun.boot.class.path</code>来指定的目录来加载类。</p><p>一般而言，<code>{JRE_HOME}/lib</code>下存放着JVM正常工作所需要的系统类，如下表所示：</p><table><thead><tr><th>文件名</th><th>描述</th></tr></thead><tbody><tr><td>rt.jar</td><td>运行环境包，rt即runtime，J2SE 的类定义都在这个包内</td></tr><tr><td>charsets.jar</td><td>字符集支持包</td></tr><tr><td>jce.jar</td><td>是一组包，它们提供用于加密、密钥生成和协商以及 Message Authentication Code（MAC）</td></tr><tr><td>jsse.jar</td><td>安全套接字拓展包Java™ Secure Socket Extension</td></tr><tr><td>classlist</td><td>该文件内表示是引导类加载器应该加载的类的清单</td></tr><tr><td>net.properties</td><td>JVM 网络配置信息</td></tr></tbody></table><p>引导类加载器(<code>Bootstrap ClassLoader</code>） 加载系统类后，JVM内存会呈现如下格局：</p><p><img src="http://bloghello.oursnail.cn/jvm9-2.jpg" alt="image"></p><ul><li>引导类加载器将类信息加载到方法区中，以特定方式组织，对于某一个特定的类而言，在方法区中它应该有 运行时常量池、类型信息、字段信息、方法信息、类加载器的引用，对应class实例的引用等信息。</li><li>类加载器的引用,由于这些类是由引导类加载器(<code>Bootstrap Classloader</code>)进行加载的，而 引导类加载器是由C++语言实现的，所以是无法访问的，故而该引用为NULL</li><li>对应class实例的引用， 类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</li></ul><h3>三、创建JVM 启动器实例 Launcher,并取得类加载器ClassLoader</h3><p>上述步骤完成，JVM基本运行环境就准备就绪了。接着，我们要让JVM工作起来了：运行我们定义的程序 <code>org.luanlouis,jvm.load.Main</code>。</p><p>此时，JVM虚拟机调用已经加载在方法区的类<code>sun.misc.Launcher</code> 的静态方法<code>getLauncher()</code>,  获取<code>sun.misc.Launcher</code> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Java启动器 </span></span><br><span class="line">sun.misc.Launcher launcher = sun.misc.Launcher.getLauncher(); </span><br><span class="line"><span class="comment">//获取类加载器ClassLoader用来加载class到内存来  </span></span><br><span class="line">ClassLoader classLoader = launcher.getClassLoader();</span><br></pre></td></tr></table></figure><p><code>sun.misc.Launcher</code> 使用了单例模式设计，保证一个JVM虚拟机内只有一个<code>sun.misc.Launcher</code>实例。</p><p>在<code>Launcher</code>的内部，其定义了两个类加载器(<code>ClassLoader</code>),分别是<code>sun.misc.Launcher.ExtClassLoader</code>和<code>sun.misc.Launcher.AppClassLoader</code>，这两个类加载器分别被称为拓展类加载器(<code>Extension ClassLoader</code>) 和 应用类加载器(<code>Application ClassLoader</code>).如下图所示：</p><p><img src="http://bloghello.oursnail.cn/jvm9-3.jpg" alt="image"></p><h3>四、使用类加载器ClassLoader加载Main类</h3><p>通过 <code>launcher.getClassLoader()</code>方法返回<code>AppClassLoader</code>实例，接着就是<code>AppClassLoader</code>加载 <code>org.luanlouis.jvm.load.Main</code>类的时候了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lassLoader classloader = launcher.getClassLoader();<span class="comment">//取得AppClassLoader类  </span></span><br><span class="line">classLoader.loadClass(<span class="string">"org.luanlouis.jvm.load.Main"</span>);<span class="comment">//加载自定义类</span></span><br></pre></td></tr></table></figure><p>上述定义的<code>org.luanlouis.jvm.load.Main</code>类被编译成<code>org.luanlouis.jvm.load.Main class</code>二进制文件，这个class文件中有一个叫常量池(<code>Constant Pool</code>)的结构体来存储该class的常量信息。常量池中有<code>CONSTANT_CLASS_INFO</code>类型的常量，表示该class中声明了要用到那些类：</p><p><img src="http://bloghello.oursnail.cn/jvm9-4.jpg" alt="image"></p><p>当<code>AppClassLoader</code>要加载 <code>org.luanlouis.jvm.load.Main</code>类时，会去查看该类的定义，发现它内部声明使用了其它的类： <code>sun.security.pkcs11.P11Util</code>、<code>java.lang.Object</code>、<code>java.lang.System</code>、<code>java.io.PrintStream</code>、<code>java.lang.Class</code>；<code>org.luanlouis.jvm.load.Main</code>类要想正常工作，首先要能够保证这些其内部声明的类加载成功。所以<code>AppClassLoader</code>要先将这些类加载到内存中。（注：为了理解方便，这里没有考虑懒加载的情况，事实上的JVM加载类过程比这复杂的多）</p><p><strong>加载顺序：</strong></p><ol><li>加载<code>java.lang.Object</code>、<code>java.lang.System</code>、<code>java.io.PrintStream</code>、<code>java,lang.Class</code></li></ol><blockquote><p><code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；</p><p>而<code>ExtClassLoader</code>发现不是其加载范围，其返回null；</p><p><code>AppClassLoader</code>发现父类加载器<code>ExtClassLoader</code>无法加载，<br>则会查询这些类是否已经被<code>BootstrapClassLoader</code>加载过，<br>结果表明这些类已经被<code>BootstrapClassLoader</code>加载过，<br>则无需重复加载，直接返回对应的<code>Class&lt;T&gt;</code>实例；</p></blockquote><ol start="2"><li>加载<code>sun.security.pkcs11.P11Util</code></li></ol><blockquote><p>此在<code>{JRE_HOME}/lib/ext/sunpkcs11.jar</code>包内，属于<code>ExtClassLoader</code>负责加载的范畴。</p><p><code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；</p><p>而<code>ExtClassLoader</code>发现其正好属于加载范围，故<code>ExtClassLoader</code>负责将其加载到内存中。</p><p><code>ExtClassLoader</code>在加载<code>sun.security.pkcs11.P11Util</code>时也分析这个类内都使用了哪些类，<br>并将这些类先加载内存后，才开始加载<code>sun.security.pkcs11.P11Util</code>，<br>加载成功后直接返回对应的<code>Class&lt;sun.security.pkcs11.P11Util&gt;</code>实例；</p></blockquote><ol start="3"><li>加载<code>org.luanlouis.jvm.load.Main</code></li></ol><blockquote><p><code>AppClassLoader</code>尝试加载这些类的时候，会先委托<code>ExtClassLoader</code>进行加载；<br><code>而ExtClassLoader</code>发现不是其加载范围，其返回null；</p><p><code>AppClassLoader</code>发现父类加载器<code>ExtClassLoader</code>无法加载，<br>则会查询这些类是否已经被<code>BootstrapClassLoader</code>加载过。<br>而结果表明<code>BootstrapClassLoader</code> 没有加载过它，<br>这时候<code>AppClassLoader</code>只能自己动手负责将其加载到内存中，<br>然后返回对应的<code>Class&lt;org.luanlouis.jvm.load.Main&gt;</code>实例引用；</p></blockquote><p>以上三步骤都成功，才表示<code>classLoader.loadClass(&quot;org.luanlouis.jvm.load.Main&quot;)</code>完成，上述操作完成后，JVM内存方法区的格局会如下所示：</p><p><img src="http://bloghello.oursnail.cn/jvm9-5.jpg" alt="image"></p><p>如上图所示：</p><ul><li>JVM方法区的类信息区是按照类加载器进行划分的，每个类加载器会维护自己加载类信息；</li><li>某个类加载器在加载相应的类时，会相应地在JVM内存堆（<code>Heap</code>）中创建一个对应的<code>Class&lt;T&gt;</code>，用来表示访问该类信息的入口</li></ul><h2>五、使用Main类的main方法作为程序入口运行程序</h2><p>就是去执行指令，过程与<a href="http://fourcolor.oursnail.cn/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">Java如何执行一个最简单的程序</a>类似。</p><h2>六、方法执行完毕，JVM销毁，释放内存</h2><p>对于本程序，主程序执行完毕，释放主函数所在的栈帧，释放堆中的内存。</p><h2>七、再来回顾回顾java类加载器相关的概念吧</h2><p>本处的内容为再次简单说明，具体见<a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">双亲委派模型</a>。类加载器(<code>Class Loader</code>)：顾名思义，指的是可以加载类的工具。JVM自身定义了三个类加载器：引导类加载器(<code>Bootstrap Class</code> Loader)、拓展类加载器(<code>Extension Class Loader</code> )、应用加载器(<code>Application Class Loader</code>)。当然，我们有时候也会自己定义一些类加载器来满足自身的需要。</p><p>引导类加载器(<code>Bootstrap Class Loader</code>): 该类加载器使JVM使用C++/C底层代码实现的加载器，用以加载JVM运行时所需要的系统类，这些系统类在<code>{JRE_HOME}/lib</code>目录下。<strong>由于类加载器是使用平台相关的底层<code>C++/C</code>语言实现的， 所以该加载器不能被Java代码访问到。但是，我们可以查询某个类是否被引导类加载器加载过</strong>。我们经常使用的系统类如：<code>java.lang.String</code>,<code>java.lang.Object</code>,<code>java.lang*</code>… 这些都被放在 <code>{JRE_HOME}/lib/rt.jar</code>包内， 当JVM系统启动的时候，引导类加载器会将其加载到 JVM内存的方法区中。</p><p>拓展类加载器(<code>Extension Class Loader</code>): 该加载器是用于加载 java 的拓展类 ，拓展类一般会放在<code>{JRE_HOME}/lib/ext/</code> 目录下，用来提供除了系统类之外的额外功能。拓展类加载器是是整个JVM加载器的Java代码可以访问到的类加载器的最顶端，即是超级父加载器，拓展类加载器是没有父类加载器的。（注意，其实引导类加载器不能算是扩展类加载器的父类，我们从源码中可以看出来的）</p><p>应用类加载器(<code>Applocatoin Class Loader</code>): 该类加载器是用于加载用户代码，是用户代码的入口。我经常执行指令 <code>java xxx.x.xxx.x.x.XClass</code> , 实际上，JVM就是使用的<code>AppClassLoader</code>加载 <code>xxx.x.xxx.x.x.XClass</code> 类的。</p><p>用户自定义类加载器（<code>Customized Class Loader</code>）：用户可以自己定义类加载器来加载类。所有的类加载器都要继承<code>java.lang.ClassLoader</code>类。</p><p>关于双亲委派模型，就不再赘述了。</p><p><img src="http://bloghello.oursnail.cn/jvm9-6.jpg" alt="image"></p><h2>八、线程上下文加载器</h2><p>Java 任何一段代码的执行，都有对应的线程上下文。如果我们在代码中，想看当前是哪一个线程在执行当前代码，我们经常是使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread  thread = Thread.currentThread();<span class="comment">//返回对当当前运行线程的引用</span></span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/jvm9-7.jpg" alt="image"></p><p>相应地，我们可以为当前的线程指定类加载器。在上述的例子中， 当执行   <code>java org.luanlouis.jvm.load.Main</code> 的时候，JVM会创建一个<code>Main</code>线程，而创建应用类加载器<code>AppClassLoader</code>的时候，会将<code>AppClassLoader</code>设置成Main线程的上下文类加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  Launcher.ExtClassLoader var1;  </span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">      var1 = Launcher.ExtClassLoader.getExtClassLoader();  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException var10) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">      <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException var9) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="comment">//将AppClassLoader设置成当前线程的上下文加载器  </span></span><br><span class="line">  Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);  </span><br><span class="line">  <span class="comment">//.......  </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程上下文类加载器是从线程的角度来看待类的加载，为每一个线程绑定一个类加载器，可以将类的加载从单纯的 双亲加载模型解放出来，进而实现特定的加载需求。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>静态分派和动态分派</title>
      <link href="/2019/02/09/JVM/%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/"/>
      <url>/2019/02/09/JVM/%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十二篇文章，本章说明静态分派和动态分派的原理。</p><a id="more"></a><p>这里所谓的分派指的是在Java中对方法的调用。Java中有三大特性：封装、继承和多态。分派是多态性的体现，Java虚拟机底层提供了我们开发中“重写”和“重载”的底层实现。其中重载属于静态分派，而重写则是动态分派的过程。除了使用分派的方式对方法进行调用之外，还可以使用解析调用，解析调用是在编译期间就已经确定了，在类装载的解析阶段就会把符号引用转化为直接引用，不会延迟到运行期间再去完成。而分派调用则既可以是静态的也可以是动态（就是这里的静态分派和动态分派）的。</p><h2>方法解析</h2><p>对于方法的调用，虚拟机提供了四条方法调用的字节码指令，分别是：</p><ul><li><p><code>invokestatic</code>: 调用静态方法</p></li><li><p><code>invokespecial</code>: 调用构造方法，私有方法，父类方法</p></li><li><p><code>invokevirtual</code>: 调用虚方法</p></li><li><p><code>invokeinterface</code>: 调用接口方法</p></li></ul><p>其中，1和2都可以在类加载阶段确定方法的唯一版本，因此，在类加载阶段就可以把符号引用解析为直接引用，在调用时刻直接找到方法代码块的内存地址进行执行（编译时已经找到了，并且存在方法调用的入口）；3和4则是在运行期间动态绑定方法的直接引用。</p><p><code>invokestatic</code>指令和<code>invokespecial</code>指令调用的方法称为非虚方法，注意，<code>final</code>修饰的方法也属于虚方法。</p><h2>静态分派</h2><p>静态分派只会涉及重载，而重载是在编译期间确定的，那么静态分派自然是一个静态的过程（因为还没有涉及到Java虚拟机）。静态分派的最直接的解释是在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的。比如创建一个类<code>O</code>，在<code>O</code>中创建了静态类内部类<code>A</code>，<code>O</code>中又有两个静态类内部类<code>B</code>、<code>C</code>继承了这个静态内部类<code>A</code>，那么实际上当编写如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">O</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(C c)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"C method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        O o = <span class="keyword">new</span> O();</span><br><span class="line">        A b = <span class="keyword">new</span> B();</span><br><span class="line">        A c = <span class="keyword">new</span> C();</span><br><span class="line">        o.a(b);</span><br><span class="line">        o.a(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果是打印出连个<code>“A method”</code>。原因在于静态类型的变化仅仅在使用时发生，变量本身的类型不会发生变化。</p><p>比如我们这里中<code>A b = new B();</code>虽然在创建的时候是<code>B</code>的对象，但是当调用<code>o.a(b)</code>的时候才发现是<code>A</code>的对象，所以会输出<code>“A method”</code>。**也就是说在发生重载的时候，Java虚拟机是通过参数的静态类型而不是实际参数类型作为判断依据的。**因此，在编译阶段，Javac编译器选择了<code>a(A a)</code>这个重载方法。</p><p>虽然编译器能够在编译阶段确定方法的版本，但是很多情况下重载的版本不是唯一的，在这种模糊的情况下，编译器会选择一个更合适的版本。例如，重载的方法中，参数列表除了参数类型不一样，其他都一样，例接收的参数有char\int\long等，传入参数‘a’，则会调用需要char类型参数的方法，去掉需要char类型参数的方法，则会调用需要int类型参数的方法。这时发生了一次自动类型转换。同样，去掉需要int类型参数的方法，则会调用需要long类型参数的方法。这里再次发生类型转换，会按照char-&gt;int-&gt;long-&gt;float-&gt;double转换类型。</p><h2>动态分派</h2><p>动态分派与重写(Override)有着很密切的关联。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtayfjpk.jvm.chapter8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"man say hello"</span>);              </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">"woman say hello"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();  </span><br><span class="line">        man.sayHello();  </span><br><span class="line">        woman.sayHello();  </span><br><span class="line">        man = <span class="keyword">new</span> Woman();  </span><br><span class="line">        man.sayHello();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里显然不可能是根据静态类型来决定的，因为静态类型都是<code>Human</code>的两个变量<code>man</code>和<code>woman</code>在调用<code>sayHello()</code>方法时执行了不同的行为，并且变量<code>man</code>在两次调用中执行了不同的方法。</p><p>导致这个现象的原是是这两个变量的实际类型不同。那么Java虚拟机是如何根据实际类型来分派方法执行版本的呢，我们使用<code>javap</code>命令输出这段代码的字节码，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;  </span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC  </span><br><span class="line">  Code:  </span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span>  </span><br><span class="line">       0: new           #16                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Man  </span><br><span class="line">       <span class="number">3</span>: dup  </span><br><span class="line">       4: invokespecial #18                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Man."&lt;init&gt;":()V  </span><br><span class="line">       <span class="number">7</span>: astore_1  </span><br><span class="line">       8: new           #19                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman  </span><br><span class="line">      <span class="number">11</span>: dup  </span><br><span class="line">      12: invokespecial #21                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman."&lt;init&gt;":()V  </span><br><span class="line">      <span class="number">15</span>: astore_2  </span><br><span class="line">      <span class="number">16</span>: aload_1  </span><br><span class="line">      17: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      <span class="number">20</span>: aload_2  </span><br><span class="line">      21: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      24: new           #19                 // class com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman  </span><br><span class="line">      <span class="number">27</span>: dup  </span><br><span class="line">      28: invokespecial #21                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Woman."&lt;init&gt;":()V  </span><br><span class="line">      <span class="number">31</span>: astore_1  </span><br><span class="line">      <span class="number">32</span>: aload_1  </span><br><span class="line">      33: invokevirtual #22                 // Method com/xtayfjpk/jvm/chapter8/DynamicDispatch$Human.sayHello:()V  </span><br><span class="line">      <span class="number">36</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>0-15行的字节码是准备动作，作用是建立<code>man</code>和<code>woman</code>的内存空间，调用<code>Man</code>和<code>Woman</code>类的实例构造器，将这两个实例的引用存放在第1和第2个局部变量表Slot之中，这个动作对应了代码中这两句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();  </span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure><p>接下来的第16-21行是关键部分，第16和第20两行分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将执行的<code>sayHello()</code>方法的所有者，称为接收者(Receiver)。</p><p>第17和第21两行是方法调用指令，单从字节码的角度来看，这两条调用指令无论是指令(都是<code>invokevirtual</code>)还是参数(都是常量池中<code>Human.sayHello()</code>的符号引用)都完全一样，但是这两条指令最终执行的目标方法并不相同，其原因需要从<code>invokevirutal</code>指令的多态查找过程开始说起，<code>invokevirtual</code>指令的运行时解析过程大致分为以下步骤：</p><ul><li>找到操作数栈顶的第一个元素所指向的对象实际类型，记作<code>C</code>。</li><li>如果在类型<code>C</code>中找到与常量中描述符和简单名称都相同的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找结束；不通过则返回<code>java.lang.IllegalAccessError</code>错误。</li><li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行第2步的搜索与校验过程。</li><li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>错误。</li></ul><p>由于<code>invokevirtual</code>指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h2>单分派与多分派</h2><p>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派与多分派两种。单分派是根据一个宗量来对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p><p>在编译期的静态分派过程选择目标方法的依据有两点：一是静态类型；二是方法参数，所以Java语言的静态分派属于多分派类型。在运行阶段虚拟机的动态分派过程只能接收者的实际类型一个宗量作为目标方法选择依据，所以Java语言的动态分派属于单分派类型。<strong>所以Java语言是一门静态多分派，动态单分派语言</strong>。</p><h2>JVM实现动态分派</h2><p>动态分派在Java中被大量使用，使用频率及其高，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率，因此JVM在类的方法区中建立虚方法表（<code>virtual method table</code>）来提高性能。</p><p><strong>⭐⭐⭐每个类中都有一个虚方法表，表中存放着各个方法的实际入口。如果某个方法在子类中没有被重写，那子类的虚方法表中该方法的地址入口和父类该方法的地址入口一样，即子类的方法入口指向父类的方法入口。如果子类重写父类的方法，那么子类的虚方法表中该方法的实际入口将会被替换为指向子类实现版本的入口地址</strong>。</p><p>那么虚方法表什么时候被创建？虚方法表会在类加载的连接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类的初始化过程</title>
      <link href="/2019/02/09/JVM/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/02/09/JVM/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十一篇文章，其实在前面的文章中已经说到了类加载机制，但是为了本文的完整性，前面一部分还是重复地放在这里，后面会着重说明初始化过程。</p><a id="more"></a><h2>1. 类加载过程</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（<code>Loading</code>）、验证（<code>Verification</code>）、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>Using</code>)和卸载(<code>Unloading</code>)7个阶段。其中准备、验证、解析3个部分统称为连接（<code>Linking</code>）。如图所示：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" alt="image"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都以<code>HotSpot</code>为基准。</p><h2>2. 加载</h2><p><strong>在加载阶段</strong>（可以参考<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法），虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li></ul><p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h2>3. 验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>验证阶段大致会完成4个阶段的检验动作</strong>：</p><blockquote><p>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></blockquote><blockquote><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</p></blockquote><blockquote><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></blockquote><blockquote><p>符号引用验证：确保解析动作能正确执行。</p></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2>4. 准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量<code>value</code>在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把<code>value</code>赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器()方法之中，所以把<code>value</code>赋值为123的动作将在初始化阶段才会执行。</p><p><strong>至于“特殊情况”是指</strong>：<code>public static final int value=123</code>，即当类字段的字段属性是<code>ConstantValue</code>时，会在准备阶段初始化为指定的值，所以标注为<code>final</code>之后，<code>value</code>的值在准备阶段初始化为123而非0.</p><h2>5. 解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h2>6. 初始化</h2><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程.</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，<strong>静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        System.out.println(i);<span class="comment">//这句编译器会报错：Cannot reference a field before it is defined（非法向前应用）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么去掉报错的那句，改成下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        i=0;</span><br><span class="line">//      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    static int i=1;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是什么呢？当然是1啦~在准备阶段我们知道i=0，然后类初始化阶段按照顺序执行，首先执行<code>static</code>块中的i=0,接着执行<code>static</code>赋值操作i=1,最后在main方法中获取i的值为1。</p><p><code>&lt;clinit&gt;()</code>方法与实例构造器<code>&lt;init&gt;()</code>方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<code>&lt;cinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕.</p><p>⭐由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p><p><code>&lt;clinit&gt;()</code>方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<code>&lt;clinit&gt;()</code>方法。</p><p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。</p><p>虚拟机规范严格规定了<strong>有且只有</strong>5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><blockquote><ol><li>遇到 <code>new</code> , <code>getstatic</code> , <code>putstatic</code> , <code>invokestatic</code> 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：<strong>①使用new关键字实例化对象的时候</strong>、<strong>②读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候</strong>，以及<strong>③调用一个类的静态方法的时候</strong>。</li></ol></blockquote><blockquote><ol start="2"><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li></ol></blockquote><blockquote><ol start="3"><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li></ol></blockquote><blockquote><ol start="4"><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li></ol></blockquote><p>下面说明三种被动引用(除了上面提到的五种情况外，所有引用类的方法都不会触发初始化，成为被动引用)。</p><p><strong>第一种：通过子类引用父类的静态字段，不会导致子类初始化。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superclass static init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass static init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superclass static init</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>说明：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p><strong>第二种：通过数组定义来引用类，不会触发此类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter12;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SuperClass复用上面个代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：（无）</p><p>说明：从结果来看，显然没有触发类<code>chapter12.SuperClass</code>的初始化阶段，但是这段代码触发了另一个名叫 <code>&quot;[Lchapter12.SuperClass&quot;</code>的类的初始化阶段。这显然不是一个合法的类名称，他是由虚拟机自动生成的、直接继承于<code>java.lang.Object</code>的子类，创建动作由字节码制定<code>newarray</code>触发。</p><p>这个类代表了一个元素类型为<code>chapter12.SuperClass</code>的一维数组，数组中应有的属性和方法(用于可直接使用的只有被修饰为<code>public</code>的<code>length</code>属性和<code>clone()</code>方法)都实现在这个类里。Java语言中对数组的访问比<code>C/C++</code>相对安全是因为这个类封装了数组元素的访问方法，而<code>C/C++</code>     直接翻译为对数组指针的移动。</p><p><strong>第三种：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：hello world</p><p>说明：上述代码虽然在java源码中引用了<code>ConstClass</code>类中的常量<code>hello world</code>，但是其实在编译阶段通过常量传播优化，已经将此常量值<code>hello world</code>存储到了<code>NotInitialization</code>的常量池中，以后<code>NotInitialization</code>对常量<code>ConstClass.HELLOWORLD</code>的引用实际上都被转化为<code>NotInitialization</code>对自身常量池的引用了。</p><h2>7. 接口的加载</h2><p>接口的加载过程与类加载过程有一些不同，针对接口需要做一些特殊说明：</p><p>接口也有初始化过程，而接口中不能使用<code>static{}</code>语句块，但编译器仍然会为接口生成<code>&quot;&lt;clinit()&gt;&quot;</code>类构造器，用于初始化接口中所定义的成员变量。</p><p>接口与类真正所区别的是前面讲述的5种“有且仅有”情况的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个借口在初始化时，并不要求其父接口全部都已经完成了初始化，只有在真正用到父接口时（如引用接口中定义的常量）才会初始化。</p><h2>8. 例子巩固</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SSClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> <span class="keyword">extends</span> <span class="title">SSClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init SuperClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init SubClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SSClass</span><br><span class="line">SuperClass init!</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>说明：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><h2>9.总结java执行顺序</h2><p>举例立刻明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Children构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Children普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Children静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Children children = <span class="keyword">new</span> Children();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent普通代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parent静态代码块</span><br><span class="line">Children静态代码块</span><br><span class="line">Parent普通代码块</span><br><span class="line">Parent构造函数</span><br><span class="line">Children普通代码块</span><br><span class="line">Children构造函数</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类静态块</span><br><span class="line">自身静态块</span><br><span class="line">父类块</span><br><span class="line">父类构造器</span><br><span class="line">自身块</span><br><span class="line">自身构造器</span><br></pre></td></tr></table></figure><h2>10. 总结java赋值顺序</h2><p>举例立刻明白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag = <span class="string">"父类成员变量赋值"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"父类构造器---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"父类构造器赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"父类构造器---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类代码块---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"父类代码块赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"父类代码块---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag = <span class="string">"成员变量赋值"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类构造器---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"子类构造器赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"子类构造器---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类代码快---&gt;"</span> + flag);</span><br><span class="line">        flag = <span class="string">"子类代码块赋值"</span>;</span><br><span class="line">        System.out.println(<span class="string">"子类代码块---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"子类方法---&gt;"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Children children = <span class="keyword">new</span> Children();</span><br><span class="line">        children.setFlag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">父类代码块---&gt;父类成员变量赋值</span><br><span class="line">父类代码块---&gt;父类代码块赋值</span><br><span class="line"></span><br><span class="line">父类构造器---&gt;父类代码块赋值</span><br><span class="line">父类构造器---&gt;父类构造器赋值</span><br><span class="line"></span><br><span class="line">子类代码快---&gt;成员变量赋值</span><br><span class="line">子类代码块---&gt;子类代码块赋值</span><br><span class="line"></span><br><span class="line">子类构造器---&gt;子类代码块赋值</span><br><span class="line">子类构造器---&gt;子类构造器赋值</span><br><span class="line"></span><br><span class="line">子类方法---&gt;子类构造器赋值</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">父类的静态变量赋值</span><br><span class="line">自身的静态变量赋值</span><br><span class="line"></span><br><span class="line">父类成员变量赋值</span><br><span class="line">父类块赋值</span><br><span class="line">父类构造器赋值</span><br><span class="line"></span><br><span class="line">自身成员变量赋值</span><br><span class="line">自身块赋值</span><br><span class="line">自身构造器赋值</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补充阅读5-Class文件中的方法表集合--method方法在class文件中是怎样组织的</title>
      <link href="/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB5-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88--method%E6%96%B9%E6%B3%95%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/"/>
      <url>/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB5-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88--method%E6%96%B9%E6%B3%95%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>继续讲class文件中的方法表集合。</p><a id="more"></a><h2>1. 方法表集合概述</h2><p>方法表集合是指由若干个方法表（method_info）组成的集合。对于在类中定义的若干个经过JVM编译成class文件后，会将相应的method方法信息组织到一个叫做方法表集合的结构中，字段表集合是一个类数组结构，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9591" alt="image"></p><h2>2. method方法的描述-方法表集合在class文件中的位置</h2><p>method方法的描述-方法表集合紧跟在字段表集合的后面，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9592" alt="image"></p><h2>3. 一个类中的method方法应该包含哪些信息？----method_info结构体的定义</h2><p>对于一个方法的表示，我们根据我们可以概括的信息如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9593" alt="image"></p><p>实际上JVM还会对method方法的描述添加其他信息，我们将在后面详细讨论。如上图中的method_info结构体的定义，该结构体的定义跟描述field字段 的field_info结构体的结构几乎完全一致,如下图所示。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9594" alt="image"></p><p>方法表的结构体由：访问标志(access_flags)、名称索引(name_index)、描述索引(descriptor_index)、属性表(attribute_info)集合组成。</p><p><strong>访问标志(access_flags)：</strong></p><p>method_info结构体最前面的两个字节表示的访问标志（access_flags），记录这这个方法的作用域、静态or非静态、可变性、是否可同步、是否本地方法、是否抽象等信息，实际上不止这些信息，我们后面会详细介绍访问标志这两个字节的每一位具体表示什么意思。</p><p><strong>名称索引(name_index)：</strong></p><p>紧跟在访问标志（access_flags）后面的两个字节称为名称索引，这两个字节中的值指向了常量池中的某一个常量池项，这个方法的名称以UTF-8格式的字符串存储在这个常量池项中。如public void methodName(),很显然，“methodName”则表示着这个方法的名称，那么在常量池中会有一个CONSTANT_Utf8_info格式的常量池项，里面存储着“methodName”字符串，而mehodName()方法的方法表中的名称索引则指向了这个常量池项。</p><p><strong>描述索引(descriptor_index)：</strong></p><p>描述索引表示的是这个方法的特征或者说是签名，一个方法会有若干个参数和返回值，而若干个参数的数据类型和返回值的数据类型构成了这个方法的描述，其基本格式为：     (参数数据类型描述列表)返回值数据类型   。我们将在后面继续讨论。</p><p><strong>属性表(attribute_info)集合：</strong></p><p>这个属性表集合非常重要，方法的实现被JVM编译成JVM的机器码指令，机器码指令就存放在一个Code类型的属性表中；如果方法声明要抛出异常，那么异常信息会在一个Exceptions类型的属性表中予以展现。Code类型的属性表可以说是非常复杂的内容，也是本文最难的地方。</p><h2>4. 访问标志(access_flags)—记录着method方法的访问信息</h2><p>访问标志（access_flags）共占有2 个字节，分为 16 位，这 16位 表示的含义如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9595" alt="image"></p><p><strong>举例：某个类中定义了如下方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>greeting()方法的修饰符有：public、static、synchronized、final 这几个修饰符修饰，那么相对应地，greeting()方法的访问标志中的ACC_PUBLIC、ACC_STATIC、ACC_SYNCHRONIZED、ACC_FINAL标志位都应该是1，即：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9596" alt="image"></p><p>从上图中可以看出访问标志的值应该是二进制00000000 00111001,即十六进制0x0039。我们将在文章的最后一个例子中证实这点。</p><h2>5. 名称索引和描述符索引----一个方法的签名</h2><p>紧接着访问标志（access_flags）后面的两个字节，叫做<strong>名称索引(name_index)</strong>，这两个字节中的值是指向了常量池中某个常量池项的索引，该常量池项表示这这个方法名称的字符串。</p><p><strong>方法描述符索引</strong>(descrptor_index)是紧跟在名称索引后面的两个字节，这两个字节中的值跟名称索引中的值性质一样，都是指向了常量池中的某个常量池项。这两个字节中的指向的常量池项，是表示了方法描述符的字符串。</p><p><strong>所谓的方法描述符，实质上就是指用一个什么样的字符串来描述一个方法</strong>，方法描述符的组成如下图所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9597" alt="image"></p><p>举例：对于如下定义的的greeting()方法，我们来看一下对应的method_info结构体中的名称索引和描述符索引信息是怎样组织的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示,method_info结构体的名称索引中存储了一个索引值x，指向了常量池中的第x项，第 x项表示的是字符串&quot;greeting&quot;,即表示该方法名称是&quot;greeting&quot;；描述符索引中的y 值指向了常量池的第y项，该项表示字符串&quot;()V&quot;，即表示该方法没有参数，返回值是void类型。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9598" alt="image"></p><h2>6. 属性表集合–记录方法的机器指令和抛出异常等信息</h2><p>属性表集合记录了某个方法的一些属性信息，这些信息包括：</p><blockquote><ol><li>这个方法的代码实现，即方法的可执行的机器指令</li><li>这个方法声明的要抛出的异常信息</li><li>这个方法是否被@deprecated注解表示</li><li>这个方法是否是编译器自动生成的</li></ol></blockquote><p>属性表（attribute_info）结构体的一般结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%9599" alt="image"></p><p><ins>修正：属性长度为4个字节。</ins></p><h3>6.1 Code类型的属性表–method方法中的机器指令的信息</h3><p>Code类型的属性表(attribute_info)可以说是class文件中最为重要的部分，因为它包含的是JVM可以运行的机器码指令，JVM能够运行这个类，就是从这个属性中取出机器码的。除了要执行的机器码，它还包含了一些其他信息，如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95910" alt="image"></p><p><strong>Code属性表的组成部分</strong>：</p><blockquote><p>机器指令----code：</p></blockquote><p>目前的JVM使用一个字节表示机器操作码，即对JVM底层而言，它能表示的机器操作码不多于2的 8 次方，即 256个。class文件中的机器指令部分是class文件中最重要的部分，并且非常复杂，本文的重点不止介绍它</p><blockquote><p>异常处理跳转信息—exception_table：</p></blockquote><p>如果代码中出现了try{}catch{}块，那么try{}块内的机器指令的地址范围记录下来，并且记录对应的catch{}块中的起始机器指令地址，当运行时在try块中有异常抛出的话，JVM会将catch{}块对应懂得其实机器指令地址传递给PC寄存器，从而实现指令跳转；</p><blockquote><p>Java源码行号和机器指令的对应关系—LineNumberTable属性表：</p></blockquote><p>编译器在将java源码编译成class文件时，会将源码中的语句行号跟编译好的机器指令关联起来，这样的class文件加载到内存中并运行时，如果抛出异常，JVM可以根据这个对应关系，抛出异常信息，告诉我们我们的源码的多少行有问题，方便我们定位问题。这个信息不是运行时必不可少的信息，但是默认情况下，编译器会生成这一项信息，如果你项取消这一信息，你可以使用-g:none 或-g:lines来取消或者要求设置这一项信息。如果使用了-g:none来生成class文件，class文件中将不会有LineNumberTable属性表，造成的影响就是 将来如果代码报错，将无法定位错误信息报错的行，并且如果项调试代码，将不能在此类中打断点（因为没有指定行号。）</p><blockquote><p>局部变量表描述信息----LocalVariableTable属性表：</p></blockquote><p>局部变量表信息会记录栈帧局部变量表中的变量和java源码中定义的变量之间的关系，这个信息不是运行时必须的属性，默认情况下不会生成到class文件中。你可以根据javac指令的-g:none或者-g:vars选项来取消或者设置这一项信息。<br>它有什么作用呢？  当我们使用IDE进行开发时，最喜欢的莫过于它们的代码提示功能了。如果在项目中引用到了第三方的jar包，而第三方的包中的class文件中有无LocalVariableTable属性表的区别如下所示：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95911" alt="image"></p><p><strong>Code属性表结构体的解释：</strong></p><ol><li><p>attribute_name_index,属性名称索引，占有2个字节，其内的值指向了常量池中的某一项，该项表示字符串“Code”;</p></li><li><p>attribute_length,属性长度，占有 4个字节，其内的值表示后面有多少个字节是属于此Code属性表的；</p></li><li><p>max_stack,操作数栈深度的最大值，占有 2 个字节，在方法执行的任意时刻，操作数栈都不应该超过这个值，虚拟机的运行的时候，会根据这个值来设置该方法对应的栈帧(Stack Frame)中的操作数栈的深度；</p></li><li><p>max_locals,最大局部变量数目，占有 2个字节，其内的值表示局部变量表所需要的存储空间大小；</p></li><li><p>code_length,机器指令长度，占有 4 个字节，表示跟在其后的多少个字节表示的是机器指令；</p></li><li><p>code,机器指令区域，该区域占有的字节数目由 code_length中的值决定。JVM最底层的要执行的机器指令就存储在这里；</p></li><li><p>exception_table_length,显式异常表长度，占有2个字节，如果在方法代码中出现了try{} catch()形式的结构，该值不会为空，紧跟其后会跟着若干个exception_table结构体，以表示异常捕获情况；</p></li><li><p>exception_table，显式异常表，占有8 个字节，start_pc,end_pc,handler_pc中的值都表示的是PC计数器中的指令地址。exception_table表示的意思是：如果字节码从第start_pc行到第end_pc行之间出现了catch_type所描述的异常类型，那么将跳转到handler_pc行继续处理。</p></li><li><p>attribute_count,属性计数器，占有 2 个字节，表示Code属性表的其他属性的数目</p></li><li><p>attribute_info,表示Code属性表具有的属性表，它主要分为两个类型的属性表：“LineNumberTable”类型和“LocalVariableTable”类型。<br>“LineNumberTable”类型的属性表记录着Java源码和机器指令之间的对应关系<br>“LocalVariableTable”类型的属性表记录着局部变量描述</p></li></ol><p><strong>举例：</strong></p><p>如下定义Simple类，使用javac -g:none Simple.java 编译出Simple.class 文件，并使用javap -v Simple &gt; Simple.txt 查看反编译的信息，然后看Simple.class文件中的方法表集合是怎样组织的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>1. Simple.class文件组织信息如下所示：</h4><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95912" alt="image"></p><p>如上所示，方法表集合使用了蓝色线段圈了起来。<br>请注意：方法表集合的头两个字节，即方法表计数器（method_count）的值是0x0002，它表示该类中有2 个方法。细心的读者会注意到，我们的Simple.java中就定义了一个greeting()方法，为什么class文件中会显示有两个方法呢？？</p><blockquote><p>JVM为没有显式定义实例化构造方法的类，自动生成默认的实例化构造方法&quot;<init>()&quot;</init></p></blockquote><p>除了实例化构造方法，JVM还会在特殊的情况下生成一个叫类构造方法&quot;<cinit>()&quot;。如果我们在类中使用到了static修饰的代码块，那么，JVM会在class文件中生成一个“<cinit>()”构造方法。关于它们的具体细节，我将在后续的文章中详细讨论，在这里就不展开了。</cinit></cinit></p><blockquote><ol start="2"><li>Simple.class 中的<init>() 方法:</init></li></ol></blockquote><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95913" alt="image"></p><p>解释：</p><ol><li><p>方法访问标志(access_flags)： 占有 2个字节，值为0x0001,即标志位的第 16 位为 1，所以该<init>()方法的修饰符是：ACC_PUBLIC;</init></p></li><li><p>名称索引(name_index)： 占有 2 个字节，值为 0x0004，指向常量池的第 4项，该项表示字符串“<init>”，即该方法的名称是“<init>”;</init></init></p></li><li><p>描述符索引(descriptor_index): 占有 2 个字节，值为0x0005,指向常量池的第 5 项，该项表示字符串“()V”，即表示该方法不带参数，并且无返回值（构造函数确实也没有返回值）；</p></li><li><p>属性计数器（attribute_count): 占有 2 个字节，值为0x0001,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；</p></li><li><p>属性表的名称索引(attribute_name_index)：占有 2 个字节，值为0x0006,指向常量池中的第6 项，该项表示字符串“Code”，表示这个属性表是Code类型的属性表；</p></li><li><p>属性长度（attribute_length）：占有4个字节，值为0x0000 0011，即十进制的 17，表明后续的 17 个字节可以表示这个Code属性表的属性信息；</p></li><li><p>操作数栈的最大深度（max_stack）：占有2个字节，值为0x0001,表示栈帧中操作数栈的最大深度是1；</p></li><li><p>局部变量表的最大容量（max_variable）：占有2个字节，值为0x0001, JVM在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；</p></li><li><p>机器指令数目(code_length)：占有4个字节，值为0x0000 0005,表示后续的5 个字节 0x2A 、0xB7、 0x00、0x01、0xB1表示机器指令;</p></li><li><p>机器指令集(code[code_length])：这里共有  5个字节，值为0x2A 、0xB7、 0x00、0x01、0xB1；</p></li><li><p>显式异常表集合（exception_table_count）： 占有2 个字节，值为0x0000,表示方法中没有需要处理的异常信息；</p></li><li><p>Code属性表的属性表集合（attribute_count）： 占有2 个字节，值为0x0000，表示它没有其他的属性表集合，因为我们使用了-g:none 禁止编译器生成Code属性表的 LineNumberTable 和LocalVariableTable;</p></li></ol><blockquote><p>B. Simple.class 中的greeting() 方法:</p></blockquote><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95914" alt="image"></p><p>解释：</p><ol><li><p>方法访问标志(access_flags)： 占有 2个字节，值为 0x0039 ,即二进制的00000000 00111001,即标志位的第11、12、13、16位为1，根据上面讲的方法标志位的表示，可以得到该greeting()方法的修饰符有：ACC_SYNCHRONIZED、ACC_FINAL、ACC_STATIC、ACC_PUBLIC;</p></li><li><p>名称索引(name_index)： 占有 2 个字节，值为 0x0007，指向常量池的第 7 项，该项表示字符串“greeting”，即该方法的名称是“greeting”;</p></li><li><p>描述符索引(descriptor_index): 占有 2 个字节，值为0x0005,指向常量池的第 5 项，该项表示字符串“()V”，即表示该方法不带参数，并且无返回值；</p></li><li><p>属性计数器（attribute_count): 占有 2 个字节，值为0x0001,表示该方法表中含有一个属性表，后面会紧跟着一个属性表；</p></li><li><p>属性表的名称索引(attribute_name_index)：占有 2 个字节，值为0x0006,指向常量池中的第6 项，该项表示字符串“Code”，表示这个属性表是Code类型的属性表；</p></li><li><p>属性长度（attribute_length）：占有4个字节，值为0x0000 0010，即十进制的16，表明后续的16个字节可以表示这个Code属性表的属性信息；</p></li><li><p>操作数栈的最大深度（max_stack）：占有2个字节，值为0x0001,表示栈帧中操作数栈的最大深度是1；</p></li><li><p>局部变量表的最大容量（max_variable）：占有2个字节，值为0x0001, JVM在调用该方法时，根据这个值设置栈帧中的局部变量表的大小；</p></li><li><p>机器指令数目(code_length)：占有4 个字节，值为0x0000 0004,表示后续的4个字节0x10、 0x0A、 0x3B、0xB1的是表示机器指令;</p></li><li><p>机器指令集(code[code_length])：这里共有4 个字节，值为0x10、 0x0A、 0x3B、0xB1 ；</p></li><li><p>显式异常表集合（exception_table_count）： 占有2 个字节，值为0x0000,表示方法中没有需要处理的异常信息；</p></li><li><p>Code属性表的属性表集合（attribute_count）： 占有2 个字节，值为0x0000，表示它没有其他的属性表集合，因为我们使用了-g:none 禁止编译器生成Code属性表的 LineNumberTable 和LocalVariableTable;</p></li></ol><h3>6.2 Exceptions类型的属性表----method方法声明的要抛出的异常信息</h3><p>有些方法在定义的时候，会声明该方法会抛出什么类型的异常，如下定义一个Interface接口，它声明了sayHello()方法，抛出Exception异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们看一下Exceptions类型的属性表(attribute_info)结构体是怎样组织的：</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95915" alt="image"></p><p>如上图所示，Exceptions类型的属性表(attribute_info)结构体由一下元素组成：</p><p>属性名称索引(attribute_name_index)：占有 2个字节，其中的值指向了常量池中的表示&quot;Exceptions&quot;字符串的常量池项；</p><p>属性长度(attribute_length)：它比较特殊，占有4个字节，它的值表示跟在其后面多少个字节表示异常信息；</p><p>异常数量(number_of_exceptions)：占有2 个字节，它的值表示方法声明抛出了多少个异常，即表示跟在其后有多少个异常名称索引；</p><p>异常名称索引(exceptions_index_table)：占有2个字节，它的值指向了常量池中的某一项，该项是一个CONSTANT_Class_info类型的项，表示这个异常的完全限定名称；</p><p><strong>Exceptions类型的属性表的长度计算</strong></p><p>如果某个方法定义中，没有声明抛出异常，那么，表示该方法的方法表(method_info)结构体中的属性表集合中不会有Exceptions类型的属性表；换句话说，如果方法声明了要抛出的异常，方法表(method_info)结构体中的属性表集合中必然会有Exceptions类型的属性表，并且该属性表中的异常数量不小于1。<br>我们假设异常数量中的值为 N，那么后面的异常名称索引的数量就为N，它们总共占有的字节数为N*2，而异常数量占有2个字节，那么将有下面的这个关系式：</p><blockquote><p>属性长度(attribute_length)中的值= 2  + 2*异常数量(number_of_exceptions)中的值</p></blockquote><blockquote><p>Exceptions类型的属性表（attribute_info）的长度=2+4+属性长度(attribute_length)中的值</p></blockquote><p><strong>举例：</strong><br>将上面定义的Interface接口类编译成class文件，然后我们查看Interface.class文件，找出方法表集合所在位置和相应的数据，并辅助javap -v  Inerface 查看</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95916" alt="image"></p><p>由于sayHello()方法是在的Interface接口类中声明的，它没有被实现，所以它对应的方法表(method_info)结构体中的属性表集合中没有Code类型的属性表。</p><ol><li><p>方法计数器（methods_count）中的值为0x0001，表明其后的方法表(method_info)就一个,即我们就定义了一个方法，其后会紧跟着一个方法表(method_info)结构体；</p></li><li><p>方法的访问标志（access_flags）的值是0x0401，二进制是00000100 00000001,第6位和第16位是1，对应上面的标志位信息，可以得出它的访问标志符有：ACC_ABSTRACT、ACC_PUBLIC。细心的读者可能会发现，在上面声明的sayHello()方法中并没有声明为abstract类型啊。确实如此，这是因为编译器对于接口内声明的方法自动加上ACC_ABSTRACT标志。</p></li><li><p>名称索引（name_index）中的值为0x0005，0x0005指向了常量池的第5项，第五项表示的字符串为“sayHello”，即表示的方法名称是sayHello</p></li><li><p>描述符索引(descriptor_index)中的值为0x0006,0x0006指向了常量池中的第6项，第6项表示的字符串为“()V” 表示这个方法的无入参，返回值为void类型</p></li><li><p>属性表计数器(attribute_count)中的值为0x0001,表示后面的属性表的个数就1个，后面紧跟着一个attribute_info结构体；</p></li><li><p>属性表（attribute_info）中的属性名称索引(attribute_name_index)中的值为0x0007，0x0007指向了常量池中的第7 项，第 7项指向字符串“Exceptions”，即表示该属性表表示的异常信息；</p></li><li><p>属性长度（attribute_length）中的值为：0x00000004,即后续的4个字节将会被解析成属性值；</p></li><li><p>异常数量（number_of_exceptions）中的值为0x0001,表示这个方法声明抛出的异常个数是1个；</p></li><li><p>异常名称索引(exception_index_table)中的值为0x0008,指向了常量池中的第8项，第8项表示的是CONSTANT_Class_info类型的常量池项，表示“java/lang/Exception”，即表示此方法抛出了java.lang.Exception异常。</p></li></ol><h2>7. IDE代码提示功能实现的基本原理</h2><p>每个IDE都提供了代码提示功能，它们实现的基本原理其实就是IDE针对它们项目下的包中所有的class文件进行建模，解析出它们的方法信息，当我们一定的条件时，IDE会自动地将合适条件的方法列表展示给开发者，供开发者使用。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%95917" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补充阅读4-Class文件中的字段表集合--field字段在class文件中是怎样组织的</title>
      <link href="/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB4-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88--field%E5%AD%97%E6%AE%B5%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/"/>
      <url>/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB4-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88--field%E5%AD%97%E6%AE%B5%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>继续讲class文件中的字段表集合。</p><a id="more"></a><h2>1. 字段表集合概述</h2><p>字段表集合是指由若干个字段表（field_info）组成的集合。对于在类中定义的若干个字段，经过JVM编译成class文件后，会将相应的字段信息组织到一个叫做字段表集合的结构中，字段表集合是一个类数组结构，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B581" alt="image"></p><p>注意：这里所讲的字段是指在类中定义的静态或者非静态的变量，而不是在类中的方法内定义的变量。请注意区别。<br>比如，如果某个类中定义了5个字段，那么，JVM在编译此类的时候，会生成5个字段表（field_info）信息,然后将字段表集合中的字段计数器的值设置成5，将5个字段表信息依次放置到字段计数器的后面。</p><h2>2. 字段表集合在class文件中的位置</h2><p>字段表集合紧跟在class文件的接口索引集合结构的后面，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B582" alt="image"></p><h2>3.  Java中的一个Field字段应该包含那些信息？------字段表field_info结构体的定义</h2><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B583" alt="image"></p><p>针对上述的字段表示，JVM虚拟机规范规定了field_info结构体来描述字段，其表示信息如下：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B584" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B585" alt="image"></p><p>下面我将一一讲解FIeld_info的组成元素：访问标志（access_flags）、名称索引（name_index）、描述索引（descriptor_index）、属性表集合</p><h2>4. field字段的访问标志</h2><p>如上图所示定义的field_info结构体，field字段的访问标志(access_flags)占有两个字节，它能够表述的信息如下所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B586" alt="image"></p><p>举例：如果我们在某个类中有定义field域：private static String str;，那么在访问标志上，第15位ACC_PRIVATE和第13位ACC_STATIC标志位都应该为1。field域str的访问标志信息应该是如下所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B587" alt="image"></p><h2>5. 字段的数据类型表示和字段名称表示</h2><p>class文件对数据类型的表示如下图所示：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B588" alt="image"></p><p>field字段名称，我们定义了一个形如private static String str的field字段，其中&quot;str&quot;就是这个字段的名称。<br>class文件将字段名称和field字段的数据类型表示作为字符串存储在常量池中。在field_info结构体中，紧接着访问标志的，就是字段名称索引和字段描述符索引，它们分别占有两个字节，其内部存储的是指向了常量池中的某个常量池项的索引，对应的常量池项中存储的字符串，分别表示该字段的名称和字段描述符。</p><h2>6. 属性表集合-----静态field字段的初始化</h2><p>在定义field字段的过程中，我们有时候会很自然地对field字段直接赋值，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX=<span class="number">100</span>;  </span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>对于虚拟机而言，上述的两个field字段赋值的时机是不同的：</p><blockquote><p>对于非静态（即无static修饰）的field字段的赋值将会出现在实例构造方法<init>()中</init></p></blockquote><blockquote><p>对于静态的field字段，有两个选择：1、在静态构造方法<cinit>()中进行；2 、使用ConstantValue属性进行赋值</cinit></p></blockquote><p>Sun javac编译器对于静态field字段的初始化赋值策略：</p><blockquote><p>如果使用final和static同时修饰一个field字段，并且这个字段是基本类型或者String类型的，那么编译器在编译这个字段的时候，会在对应的field_info结构体中增加一个ConstantValue类型的结构体，在赋值的时候使用这个ConstantValue进行赋值；</p></blockquote><blockquote><p>如果该field字段并没有被final修饰，或者不是基本类型或者String类型，那么将在类构造方法<cinit>()中赋值。</cinit></p></blockquote><p>对于上述的public static final init MAX=100：</p><blockquote><p>javac编译器在编译此field字段构建field_info结构体时，除了访问标志、名称索引、描述符索引外，会增加一个ConstantValue类型的属性表。</p></blockquote><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B589" alt="image"></p><h2>7. 实例解析</h2><p>定义如下一个简单的Simple类，然后通过查看Simple.class文件内容并结合javap -v Simple 生成的常量池内容，分析str field字段的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">transient</span> <span class="keyword">static</span> <span class="keyword">final</span> String str =<span class="string">"This is a test"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B5810" alt="image"></p><blockquote><ol><li>字段计数器中的值为0x0001,表示这个类就定义了一个field字段</li></ol></blockquote><blockquote><ol start="2"><li>字段的访问标志是0x009A,二进制是00000000 10011010，即第9、12、13、15位标志位为1，这个字段的标志符有：ACC_TRANSIENT、ACC_FINAL、ACC_STATIC、ACC_PRIVATE;</li></ol></blockquote><blockquote><ol start="3"><li>名称索引中的值为0x0005,指向了常量池中的第5项，为“str”,表明这个field字段的名称是str；</li></ol></blockquote><blockquote><ol start="4"><li>描述索引中的值为0x0006,指向了常量池中的第6项，为&quot;Ljava/lang/String;&quot;，表明这个field字段的数据类型是java.lang.String类型；</li></ol></blockquote><blockquote><p>5.属性表计数器中的值为0x0001,表明field_info还有一个属性表；</p></blockquote><blockquote><p>6.属性表名称索引中的值为0x0007,指向常量池中的第7项，为“ConstantValue”,表明这个属性表的名称是ConstantValue，即属性表的类型是ConstantValue类型的；</p></blockquote><blockquote><p>7.属性长度中的值为0x0002，因为此属性表是ConstantValue类型，它的值固定为2；</p></blockquote><blockquote><p>8.常量值索引 中的值为0x0008,指向了常量池中的第8项，为CONSTANT_String_info类型的项，表示“This is a test” 的常量。在对此field赋值时，会使用此常量对field赋值。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补充阅读3-Class文件中的访问标志、类索引、父类索引、接口索引集合</title>
      <link href="/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB3-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88/"/>
      <url>/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB3-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p>讲完了class文件中的常量池，我们就相当于克服了class文件中最麻烦的模块了。现在，我们来看一下class文件中紧接着常量池后面的几个东西：访问标志、类索引、父类索引、接口索引集合。</p><a id="more"></a><h2>1. 访问标志、类索引、父类索引、接口索引集合 在class文件中的位置</h2><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%20%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE" alt="image"></p><h2>2. 访问标志(access_flags)能够表示什么？</h2><p>访问标志（access_flags）紧接着常量池后，占有两个字节，总共16位，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%28access_flags%29%E8%83%BD%E5%A4%9F%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88%EF%BC%9F" alt="image"></p><p>当JVM在编译某个类或者接口的源代码时，JVM会解析出这个类或者接口的访问标志信息，然后，将这些标志设置到访问标志（access_flags）这16个位上。JVM会考虑如下设置如下访问表示信息：</p><h4>a. 类或接口</h4><p>我们知道，每个定义的类或者接口都会生成class文件（这里也包括内部类，在某个类中定义的静态内部类也会单独生成一个class文件）。</p><blockquote><p>对于定义的类，JVM在将其编译成class文件时，会将class文件的访问标志的第11位设置为1 。第11位叫做ACC_SUPER标志位；</p></blockquote><blockquote><p>对于定义的接口，JVM在将其编译成class文件时，会将class文件的访问标志的第8位 设置为 1 。第8位叫做ACC_INTERFACE标志位；</p></blockquote><h4>b. 访问权限：public类型和包package类型。</h4><p>如果类或者接口被声明为public类型的，那么，JVM将其编译成class文件时，会将class文件的访问标志的第16位设置为1 。第16位叫做ACC_PUBLIC标志符；</p><h4>c. 类是否为抽象类型的，即我们定义的类有没有被abstract关键字修饰，即我们定义的类是否为抽象类。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;......&#125;</span><br></pre></td></tr></table></figure><p>定义某个类时，JVM将它编译成class文件的时候，会将class文件的访问标志的第7位设置为1 。第7位叫做ACC_ABSTRACT标志位。</p><p>另外值得注意的是，对于定义的接口，JVM在编译接口的时候也会对class文件的访问标志上的ACC_ABSTRACT标志位设置为 1；</p><h4>d. 该类是否被声明了final类型,即表示该类不能被继承。</h4><p>此时JVM会在编译class文件的过程中，会将class文件的访问标志的第12位设置为 1 。第12位叫做ACC_FINAL标志位；</p><h4>e.是否是JVM通过java源代码文件编译而成的</h4><p>如果我们这个class文件不是JVM通过java源代码文件编译而成的，而是用户自己通过class文件的组织规则生成的，那么，一般会对class文件的访问标志第4位设置为 1 。通过JVM编译源代码产生的class文件此标志位为 0，第4位叫做ACC_SYNTHETIC标志位；</p><h4>f. 枚举类</h4><p>对于定义的枚举类如：public enum EnumTest{…}，JVM也会对此枚举类编译成class文件，这时，对于这样的class文件，JVM会对访问标志第2位设置为 1 ，以表示它是枚举类。第2位叫做ACC_ENUM标志位；</p><h4>g. 注解类</h4><p>对于定义的注解类如：public @interface{…},JVM会对此注解类编译成class文件，对于这样的class文件，JVM会将访问标志第3位设置为1，以表示这是个注解类，第3位叫做ACC_ANNOTATION标志位。</p><p>当JVM确定了上述标志位的值后，就可以确定访问标志（access_flags）的值了。实际上JVM上述标志会根据上述确定的标志位的值，对这些标志位的值取或，便得到了访问标志（access_flags）。如下图所示:</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97" alt="image"></p><h4>举例</h4><p>定义一个最简单的类Simple.java，使用编译器编译成class文件，然后观察class文件中的访问标志的值，以及使用javap -v Simple 查看访问标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用UltraEdit查看编译成的class文件，如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%972" alt="image"></p><p>上述的图中黄色部分表示的是常量池部分,常量池后面紧跟着就是访问标志，它的十六进制值为0x0021,二进制的值为：00000000 00100001，由二进制的1的位数可以得出第11、16位为1，分别对应ACC_SUPER标志位和ACC_PUBLIC标志位。验证一下:</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%973" alt="image"></p><h2>3. 类索引(this_class)是什么？</h2><p>我们知道一般情况下一个Java类源文件经过JVM编译会生成一个class文件，也有可能一个Java类源文件中定义了其他类或者内部类，这样编译出来的class文件就不止一个，但每一个class文件表示某一个类，至于这个class表示哪一个类，便可以通过 类索引 这个数据项来确定。JVM通过类的完全限定名确定是某一个类。</p><p><strong>类索引的作用，就是为了指出class文件所描述的这个类叫什么名字。</strong></p><p>类索引紧接着访问标志的后面，占有两个字节，在这两个字节中存储的值是一个指向常量池的一个索引，该索引指向的是CONSTANT_Class_info常量池项.</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%951" alt="image"></p><p>以上面定义的Simple.class 为例，如下图所示，查看他的类索引在什么位置和取什么值。</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%952" alt="image"></p><p>由上可知，它的类索引值为0x0001,那么，它指向了常量池中的第一个常量池项，那我们再看一下常量池中的信息。使用javap -v Simple,常量池中有以下信息：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%953" alt="image"></p><p>可以看到常量池中的第一项是CONSTANT_Class_info项，它表示一个&quot;com/louis/jvm/Simple&quot;的类名。即类索引是告诉我们这个class文件所表示的是哪一个类。</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%954" alt="image"></p><h2>4. 父类索引(super_class)是什么？</h2><p>Java支持单继承模式，除了java.lang.Object 类除外，每一个类都会有且只有一个父类。class文件中紧接着类索引(this_class)之后的两个字节区域表示父类索引，跟类索引一样，父类索引这两个字节中的值指向了常量池中的某个常量池项CONSTANT_Class_info，表示该class表示的类是继承自哪一个类。</p><p><img src="http://javajvm.oursnail.cn/%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95" alt="image"></p><h2>5. 接口索引集合(interfaces)是什么？</h2><p>一个类可以不实现任何接口，也可以实现很多个接口，为了表示当前类实现的接口信息，class文件使用了如下结构体描述某个类的接口实现信息:</p><p><img src="http://javajvm.oursnail.cn/%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95" alt="image"></p><p>由于类实现的接口数目不确定，所以接口索引集合的描述的前部分叫做接口计数器（interfaces_count），接口计数器占用两个字节，其中的值表示着这个类实现了多少个接口，紧跟着接口计数器的部分就是接口索引部分了，每一个接口索引占有两个字节，接口计数器的值代表着后面跟着的接口索引的个数。接口索引和类索引和父类索引一样，其内的值存储的是指向了常量池中的常量池项的索引，表示着这个接口的完全限定名。</p><p><strong>举例：</strong></p><p>定义一个Worker接口，然后类Programmer实现这个Worker接口，然后我们观察Programmer的接口索引集合是怎样表示的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">implements</span> <span class="title">Worker</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"I'm Programmer,Just coding...."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E7%B4%A2%E5%BC%954" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补充阅读2-Class文件中的常量池</title>
      <link href="/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB2-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB2-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      <content type="html"><![CDATA[<p>上一节Class类文件结构大致地介绍了class文件的组织结构，接下来，我们将深入每一个结构，来详细了解它们。这一章节呢，我们就来扒一扒class文件中非常重要 的一个数据区域------常量池。它在JVM虚拟机中扮演了非常重要的地位。</p><a id="more"></a><p>本篇内容来自于<a href="http://blog.csdn.net/luanlouis/article/details/40148053" target="_blank" rel="noopener">java虚拟机原理图解</a>，自己一边理解一边进行复制整理得此文章，<strong>也是看了很多遍，逐渐地好像懂了常量池怎么玩的，所以一定要坚持，读不懂多读几遍一定可以读懂的。</strong></p><p>本篇文章内容过多，这里将目录列举在此。</p><blockquote><ol><li>常量池是什么</li><li>常量池在class文件的什么位置？</li><li>常量池里面是怎么组织的？</li><li>常量池项 (cp_info) 的结构是什么？</li><li>常量池能够表示哪些信息？</li><li>int和float数据类型的常量在常量池中是怎样表示和存储的？</li><li>long和 double数据类型的常量在常量池中是怎样表示和存储的？</li><li>String类型的字符串常量在常量池中是怎样表示和存储的？</li><li>类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？</li><li>类中引用到的field字段在常量池中是怎样描述的？</li><li>类中引用到的method方法在常量池中是怎样描述的？</li><li>类中引用到某个接口中定义的method方法在常量池中是怎样描述的？</li><li>更好地支持动态语言所增加的三项</li></ol></blockquote><hr><h2>1. 常量池是什么</h2><p>可以理解为class文件之中的资源仓库，它是class文件结构中与其他项目关联最多的数据类型，也是占用class文件空间最大的数据项目之一，同时它还是class文件中第一个出现表类型的数据项目．</p><p>由于常量池的数量是不固定的，所以在常量池入口需要放置一项u2（即２个字节）类型的数据，代表常量池容量计数值（constant-pool-count）(从１开始，将０表示不引用任何常量).</p><p>常量池中主要存放两大类常量：<strong>字面量（Literal）和符号引用(Synbolic Reference)</strong>．</p><p>字面量：比较接近于Java语言层面的常量概念，如文本字符串，声明为final的常量值.</p><p>符号引用：包括如下三类常量：</p><blockquote><ol><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ol></blockquote><h2>2. 常量池在class文件的什么位置？</h2><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BD%8D%E7%BD%AE" alt="image"></p><h2>3. 常量池的里面是怎么组织的？</h2><p>常量池的组织很简单，前端的两个字节占有的位置叫做常量池计数器(constant_pool_count)，它记录着常量池的组成元素  常量池项(cp_info) 的个数。紧接着会排列着constant_pool_count-1个常量池项(cp_info)。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%84%E7%BB%87" alt="image"></p><h2>4. 常量池项 (cp_info) 的结构是什么？</h2><p>每个常量池项(cp_info) 都会对应记录着class文件中的某种类型的字面量。让我们先来了解一下常量池项(cp_info)的结构吧：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%93%E6%9E%84" alt="image"></p><p>JVM虚拟机规定了不同的tag值和不同类型的字面量对应关系如下：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%842" alt="image"></p><p>所以根据cp_info中的tag 不同的值，可以将cp_info 更细化为以下结构体：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%843" alt="image"></p><p>现在让我们看一下细化了的常量池的结构会是类似下图所示的样子：</p><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E9%A1%B9%E7%BB%93%E6%9E%844" alt="image"></p><h2>5. 常量池能够表示那些信息？</h2><p><img src="http://javajvm.oursnail.cn/%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%83%BD%E5%A4%9F%E8%A1%A8%E7%A4%BA%E9%82%A3%E4%BA%9B%E4%BF%A1%E6%81%AF" alt="image"></p><h2>6. int和float数据类型的常量在常量池中是怎样表示和存储的？(CONSTANT_Integer_info, CONSTANT_Float_info)</h2><p>Java语言规范规定了 int类型和Float 类型的数据类型占用 4 个字节的空间。那么存在于class字节码文件中的该类型的常量是如何存储的呢？相应地，在常量池中，将 int和Float类型的常量分别使用CONSTANT_Integer_info和 Constant_float_info表示，他们的结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" alt="image"></p><p>举例：建下面的类 IntAndFloatTest.java，在这个类中，我们声明了五个变量，但是取值就两种int类型的10 和Float类型的11f.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntAndFloatTest</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> c = <span class="number">11f</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> d = <span class="number">11f</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> e = <span class="number">11f</span>;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用编译器编译成IntAndFloatTest.class字节码文件，我们通过javap -v IntAndFloatTest 指令来看一下其常量池中的信息，可以看到虽然我们在代码中写了两次10 和三次11f，但是常量池中，就只有一个常量10 和一个常量11f,如下图所示:</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2" alt="image"></p><p>从结果上可以看到常量池第#8 个常量池项(cp_info) 就是CONSTANT_Integer_info,值为10；第#23个常量池项(cp_info) 就是CONSTANT_Float_info,值为11f。</p><p>代码中所有用到 int 类型 10 的地方，会使用指向常量池的指针值#8 定位到第#8 个常量池项(cp_info)，即值为 10的结构体 CONSTANT_Integer_info，而用到float类型的11f时，也会指向常量池的指针值#23来定位到第#23个常量池项(cp_info) 即值为11f的结构体CONSTANT_Float_info。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/int%E5%92%8Cfloat%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B3" alt="image"></p><h2>7. long和 double数据类型的常量在常量池中是怎样表示和存储的？(CONSTANT_Long_info、CONSTANT_Double_info )</h2><p>Java语言规范规定了 long 类型和 double类型的数据类型占用8 个字节的空间。那么存在于class 字节码文件中的该类型的常量是如何存储的呢？相应地，在常量池中，将long和double类型的常量分别使用CONSTANT_Long_info和Constant_Double_info表示，他们的结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/long%E5%92%8C%20double%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" alt="image"></p><p>代码中所有用到 long 类型-6076574518398440533L 的地方，会使用指向常量池的指针值#18 定位到第 #18 个常量池项(cp_info)，即值为-6076574518398440533L 的结构体CONSTANT_Long_info，而用到double类型的10.1234567890D时，也会指向常量池的指针值#26 来定位到第 #26 个常量池项(cp_info) 即值为10.1234567890D的结构体CONSTANT_Double_info。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/long%E5%92%8C%20double%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B2" alt="image"></p><h2>8. String类型的字符串常量在常量池中是怎样表示和存储的？（CONSTANT_String_info、CONSTANT_Utf8_info）</h2><p>对于字符串而言，JVM会将字符串类型的字面量以UTF-8 编码格式存储到在class字节码文件中。这么说可能有点摸不着北，我们先从直观的Java源码中中出现的用双引号&quot;&quot; 括起来的字符串来看，在编译器编译的时候，都会将这些字符串转换成CONSTANT_String_info结构体，然后放置于常量池中。其结构如下所示：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B" alt="image"></p><p>如上图所示的结构体，CONSTANT_String_info结构体中的string_index的值指向了CONSTANT_Utf8_info结构体，而字符串的utf-8编码数据就在这个结构体之中。如下图所示：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B" alt="image"></p><p>请看一例，定义一个简单的StringTest.java类，然后在这个类里加一个&quot;JVM原理&quot; 字符串，然后，我们来看看它在class文件中是怎样组织的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String s1 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s2 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s3 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">    <span class="keyword">private</span> String s4 = <span class="string">"JVM原理"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B3" alt="image"></p><p>在上面的图中，我们可以看到CONSTANT_String_info结构体位于常量池的第#15个索引位置。而存放&quot;Java虚拟机原理&quot; 字符串的 UTF-8编码格式的字节数组被放到CONSTANT_Utf8_info结构体中，该结构体位于常量池的第#16个索引位置。上面的图只是看了个轮廓，让我们再深入地看一下它们的组织吧。请看下图：</p><p><img src="http://javajvm.oursnail.cn/String%E7%B1%BB%E5%9E%8B4" alt="image"></p><h2>9. 类文件中定义的类名和类中使用到的类在常量池中是怎样被组织和存储的？(CONSTANT_Class_info)</h2><p>JVM会将某个Java 类中所有使用到了的类的完全限定名 以二进制形式的完全限定名 封装成CONSTANT_Class_info结构体中，然后将其放置到常量池里。CONSTANT_Class_info 的tag值为 7 。其结构如下：</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B61" alt="image"></p><p><strong>类的完全限定名和二进制形式的完全限定名</strong></p><p>在某个Java源码中，我们会使用很多个类，比如我们定义了一个 ClassTest的类，并把它放到com.louis.jvm 包下，则 ClassTest类的完全限定名为com.louis.jvm.ClassTest，将JVM编译器将类编译成class文件后，此完全限定名在class文件中，是以二进制形式的完全限定名存储的，即它会把完全限定符的&quot;.“换成”/&quot; ，即在class文件中存储的 ClassTest类的完全限定名称是&quot;com/louis/jvm/ClassTest&quot;。因为这种形式的完全限定名是放在了class二进制形式的字节码文件中，所以就称之为 二进制形式的完全限定名。</p><p>举例，我们定义一个很简单的ClassTest类，来看一下常量池是怎么对类的完全限定名进行存储的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Date date =<span class="keyword">new</span> Date();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B62" alt="image"></p><p>如上图所示，在ClassTest.class文件的常量池中，共有 3 个CONSTANT_Class_info结构体，分别表示ClassTest 中用到的Class信息。 我们就看其中一个表示com/jvm.ClassTest的CONSTANT_Class_info 结构体。它在常量池中的位置是#1，它的name_index值为#2，它指向了常量池的第2 个常量池项，如下所示:</p><p><img src="http://javajvm.oursnail.cn/%E7%B1%BB%E6%96%87%E4%BB%B63" alt="image"></p><p>注意：</p><p>对于某个类而言，其class文件中至少要有两个CONSTANT_Class_info常量池项，用来表示自己的类信息和其父类信息。(除了java.lang.Object类除外，其他的任何类都会默认继承自java.lang.Object）如果类声明实现了某些接口，那么接口的信息也会生成对应的CONSTANT_Class_info常量池项。</p><p>除此之外，如果在类中使用到了其他的类，只有真正使用到了相应的类，JDK编译器才会将类的信息组成CONSTANT_Class_info常量池项放置到常量池中。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Date date;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Other</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        Date da;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的Other的类，在JDK将其编译成class文件时，常量池中并没有java.util.Date对应的CONSTANT_Class_info常量池项，为什么呢?</p><p>在Other类中虽然定义了Date类型的两个变量date、da，但是JDK编译的时候，认为你只是声明了“Ljava/util/Date”类型的变量，并没有实际使用到Ljava/util/Date类。将类信息放置到常量池中的目的，是为了在后续的代码中有可能会反复用到它。很显然，JDK在编译Other类的时候，会解析到Date类有没有用到，发现该类在代码中就没有用到过，所以就认为没有必要将它的信息放置到常量池中了。</p><p>将上述的Other类改写一下，仅使用new Date()，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Other</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">new</span> Date();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><blockquote><ol><li>对于某个类或接口而言，其自身、父类和继承或实现的接口的信息会被直接组装成CONSTANT_Class_info常量池项放置到常量池中；</li><li>类中或接口中使用到了其他的类，只有在类中实际使用到了该类时，该类的信息才会在常量池中有对应的CONSTANT_Class_info常量池项；</li><li>类中或接口中仅仅定义某种类型的变量，JDK只会将变量的类型描述信息以UTF-8字符串组成CONSTANT_Utf8_info常量池项放置到常量池中，上面在类中的private Date date;JDK编译器只会将表示date的数据类型的“Ljava/util/Date”字符串放置到常量池中。</li></ol></blockquote><h2>10. 类中引用到的field字段在常量池中是怎样描述的？(CONSTANT_Fieldref_info, CONSTANT_Name_Type_info)</h2><p>一般而言，我们在定义类的过程中会定义一些 field 字段，然后会在这个类的其他地方（如方法中）使用到它。有可能我们在类的方法中只使用field字段一次，也有可能我们会在类定义的方法中使用它很多很多次。</p><p>举一个简单的例子，我们定一个叫Person的简单java bean，它有name和age两个field字段，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面定义的类中，我们在Person类中的一系列方法里，多次引用到namefield字段 和agefield字段，对于JVM编译器而言，name和age只是一个符号而已，并且它在由于它可能会在此类中重复出现多次，所以JVM把它当作常量来看待，将name和age以field字段常量的形式保存到常量池中。</p><p>将它name和age封装成 CONSTANT_Fieldref_info 常量池项，放到常量池中，在类中引用到它的地方，直接放置一个指向field字段所在常量池的索引。</p><p>上面的Person类，使用javap -v Person指令，查看class文件的信息，你会看到，在Person类中引用到age和namefield字段的地方，都是指向了常量池中age和namefield字段对应的常量池项中。表示field字段的常量池项叫做CONSTANT_Fieldref_info。</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B51" alt="image"></p><p>怎样描述某一个field字段的引用？</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B52" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B53" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B54" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B55" alt="image"></p><p>实例解析： 现在，让我们来看一下Person类中定义的namefield字段在常量池中的表示。通过使用javap -v Person会查看到如下的常量池信息：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B56" alt="image"></p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B57" alt="image"></p><p>请读者看上图中namefield字段的数据类型，它在#6个常量池项，以UTF-8编码格式的字符串“Ljava/lang/String;” 表示，这表示着这个field 字段是java.lang.String 类型的。关于field字段的数据类型，class文件中存储的方式和我们在源码中声明的有些不一样。请看下图的对应关系：</p><p><img src="http://javajvm.oursnail.cn/field%E5%AD%97%E6%AE%B58" alt="image"></p><p><strong>注意：</strong></p><p>如果我们在类中定义了field 字段，但是没有在类中的其他地方用到这些字段，它是不会被编译器放到常量池中的。</p><p>只有在类中的其他地方引用到了，才会将他放到常量池中。</p><h2>11. 类中引用到的method方法在常量池中是怎样描述的？(CONSTANT_Methodref_info, CONSTANT_Name_Type_info)</h2><h3>1. 举例</h3><p>还是以Person类为例。在Person类中，我们定义了setName(String name)、getName()、setAge(int age)、getAge()这些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们定义了方法，但是这些方法没有在类总的其他地方被用到（即没有在类中其他的方法中引用到），所以它们的方法引用信息并不会放到常量中。</p><p>现在我们在类中加一个方法 getInfo()，调用了getName()和getAge() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> getName()+<span class="string">"\t"</span>+getAge();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候JVM编译器会将getName()和getAge()方法的引用信息包装成CONSTANT_Methodref_info结构体放入到常量池之中。</p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%951" alt="image"></p><p>这里的方法调用的方式牵涉到Java非常重要的一个术语和机制，叫动态绑定。这个动态绑定问题以后在单独谈谈。</p><h3>2. 表示一个方法引用</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%952" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%953" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%954" alt="image"></p><h3>3. 方法描述符的组成</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%955" alt="image"></p><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%956" alt="image"></p><h3>4. getName() 方法引用在常量池中的表示</h3><p><img src="http://javajvm.oursnail.cn/method%E6%96%B9%E6%B3%957" alt="image"></p><h2>12. 类中引用到某个接口中定义的method方法在常量池中是怎样描述的？(CONSTANT_InterfaceMethodref_info, CONSTANT_Name_Type_info)</h2><p>当我们在某个类中使用到了某个接口中的方法，JVM会将用到的接口中的方法信息方知道这个类的常量池中。<br>比如我们定义了一个Worker接口，和一个Boss类，在Boss类中调用了Worker接口中的方法，这时候在Boss类的常量池中会有Worker接口的方法的引用表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Worker</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">(Worker worker)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        worker.work();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://javajvm.oursnail.cn/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84method%E6%96%B9%E6%B3%951" alt="image"></p><p>如上图所示，在Boss类的makeMoney()方法中调用了Worker接口的work()方法，机器指令是通过invokeinterface指令完成的，invokeinterface指令后面的操作数，是指向了Boss常量池中Worker接口的work()方法描述，表示的意思就是：“我要调用Worker接口的work()方法”。</p><p>Worker接口的work()方法引用信息，JVM会使用CONSTANT_InterfaceMethodref_info结构体来描述，CONSTANT_InterfaceMethodref_info定义如下：</p><p><img src="http://javajvm.oursnail.cn/%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84method%E6%96%B9%E6%B3%952" alt="image"></p><p>CONSTANT_InterfaceMethodref_info结构体和上面介绍的CONSTANT_Methodref_info 结构体很基本上相同，它们的不同点只有：</p><blockquote><ol><li>CONSTANT_InterfaceMethodref_info 的tag 值为11，而CONSTANT_Methodref_info的tag值为10；</li></ol></blockquote><blockquote><ol start="2"><li>CONSTANT_InterfaceMethodref_info 描述的是接口中定义的方法，而CONSTANT_Methodref_info描述的是实例类中的方法；</li></ol></blockquote><p>其他的基本与上面一个一毛一样。参照上面个理解即可。</p><h2>13. CONSTANT_MethodType_info，CONSTANT_MethodHandle_info，CONSTANT_InvokeDynamic_info</h2><p>这三项主要是为了让Java语言支持动态语言特性而在Java 7 版本中新增的三个常量池项，只会在极其特别的情况能用到它，在class文件中几乎不会生成这三个常量池项。   其实我花了一些时间来研究这三项，并且想通过各种方式生成这三项，不过没有成功，最后搞的还是迷迷糊糊的。从我了解到的信息来看，Java 7对动态语言的支持很笨拙，并且当前没有什么应用价值，然后就对着三项的研究先放一放了。）</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补充阅读1-Class类文件结构</title>
      <link href="/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB-Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB-Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>总体概览一下Class文件是什么以及有什么。</p><a id="more"></a><h2>整体感知</h2><p><code>class</code>文件是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得<code>class</code>文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间。 我们的Java源文件， 在被编译之后， 每个类（或者接口）都单独占据一个<code>class</code>文件， 并且类中的所有信息都会在<code>class</code>文件中有相应的描述， 由于<code>class</code>文件很灵活， 它甚至比Java源文件有着更强的描述能力。</p><h2>Class文件格式</h2><p><img src="http://javajvm.oursnail.cn/Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt="image"></p><p><strong>换成表格的形式：</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count - 1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><h3>NO1. 魔数(magic)</h3><p>所有的由Java编译器编译而成的class文件的前4个字节都是“0xCAFEBABE”</p><p>它的作用在于：</p><blockquote><p>当JVM在尝试加载某个文件到内存中来的时候，会首先判断此class文件有没有JVM认为可以接受的“签名”，即JVM会首先读取文件的前4个字节，判断该4个字节是否是“0xCAFEBABE”，如果是，则JVM会认为可以将此文件当作class文件来加载并使用。</p></blockquote><h3>NO2.版本号(minor_version,major_version)</h3><p>主版本号和次版本号在class文件中各占两个字节，<strong>副版本号占用第5、6两个字节，而主版本号则占用第7，8两个字节</strong>。JDK1.0的主版本号为45，以后的每个新主版本都会在原先版本的基础上加1。若现在使用的是JDK1.7编译出来的class文件，则相应的主版本号应该是51,对应的7，8个字节的十六进制的值应该是 0x33。</p><p>JVM在加载class文件的时候，会读取出主版本号，然后比较这个class文件的主版本号和JVM本身的版本号，如果JVM本身的版本号小于class文件的版本号，JVM会认为加载不了这个class文件，会抛出我们经常见到的<code>&quot;java.lang.UnsupportedClassVersionError: Bad version number in .class file &quot; Error</code>错误；反之，JVM会认为可以加载此class文件，继续加载此class文件。</p><h3>NO3.常量池计数器(constant_pool_count)</h3><p>常量池是class文件中非常重要的结构，它描述着整个class文件的字面量信息。 常量池是由一组<code>constant_pool</code>结构体数组组成的，而数组的大小则由常量池计数器指定。常量池计数器<code>constant_pool_count</code> 的值等于<code>constant_pool</code>表中的成员数+ 1。<code>constant_pool</code>表的索引值只有在大于 0 且小于<code>constant_pool_count</code>时(即1~(constant_pool_count-1))才会被认为是有效的。</p><p>这个容量计数是从1而不是从0开始的，如果常量池容量为十六进制数0x0016，即十进制22，这就代表着常量池中有21个常量，索引值范围为1-21。在Class文件格式规范制定时，设计者将第0项常量空出来是有特殊考虑的，用于在特定情况下表达“不引用任何一个常量池项目”。</p><h3>NO4.常量池数据区(constant_pool[contstant_pool_count-1])</h3><p>常量池，constant_pool是一种表结构,它包含 Class 文件结构及其子结构中引用的所有字符串常量、 类或接口名、字段名和其它常量。 常量池中的每一项都具备相同的格式特征——第一个字节作为类型标记用于识别该项是哪种类型的常量，称为 “tag byte” 。常量池的索引范围是 1 至constant_pool_count−1。常量池的具体细节我们会稍后讨论。</p><h3>NO6.访问标志(access_flags)</h3><p>访问标志，access_flags 是一种掩码标志，用于表示某个类或者接口的访问权限及基础属性。</p><p><img src="http://javajvm.oursnail.cn/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="image"></p><h3>NO7.类索引(this_class)</h3><p>类索引，this_class的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类或接口。</p><h3>NO8.父类索引(super_class)</h3><p>父类索引，对于类来说，super_class 的值必须为 0 或者是对constant_pool 表中项目的一个有效索引值。如果它的值不为 0，那 constant_pool 表在这个索引处的项必须为CONSTANT_Class_info 类型常量，表示这个 Class 文件所定义的类的直接父类。当前类的直接父类，以及它所有间接父类的access_flag 中都不能带有ACC_FINAL 标记。对于接口来说，它的Class文件的super_class项的值必须是对constant_pool表中项目的一个有效索引值。constant_pool表在这个索引处的项必须为代表 java.lang.Object 的 CONSTANT_Class_info 类型常量 。如果 Class 文件的 super_class的值为 0，那这个Class文件只可能是定义的是java.lang.Object类，只有它是唯一没有父类的类。</p><h3>NO9.接口计数器(interfaces_count)</h3><p>接口计数器，interfaces_count的值表示当前类或接口的直接父接口数量。</p><h3>NO10.接口信息数据区(interfaces[interfaces_count])</h3><p>接口表，interfaces[]数组中的每个成员的值必须是一个对constant_pool表中项目的一个有效索引值， 它的长度为 interfaces_count。每个成员 interfaces[i]  必须为 CONSTANT_Class_info类型常量，其中 0 ≤ i &lt;interfaces_count。在interfaces[]数组中，成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><h3>NO11.字段计数器(fields_count)</h3><p>字段计数器，fields_count的值表示当前 Class 文件 fields[]数组的成员个数。 fields[]数组中每一项都是一个field_info结构的数据项，它用于表示该类或接口声明的类字段或者实例字段。</p><h3>NO12.字段信息数据区(fields[fields_count])</h3><p>字段表，fields[]数组中的每个成员都必须是一个fields_info结构的数据项，用于表示当前类或接口中某个字段的完整描述。 fields[]数组描述当前类或接口声明的所有字段，但不包括从父类或父接口继承的部分。</p><h3>NO13.方法计数器(methods_count)</h3><p>方法计数器， methods_count的值表示当前Class 文件 methods[]数组的成员个数。Methods[]数组中每一项都是一个 method_info 结构的数据项。</p><h3>NO14.方法信息数据区(methods[methods_count])</h3><p>方法表，methods[] 数组中的每个成员都必须是一个 method_info 结构的数据项，用于表示当前类或接口中某个方法的完整描述。如果某个method_info 结构的access_flags 项既没有设置 ACC_NATIVE 标志也没有设置ACC_ABSTRACT 标志，那么它所对应的方法体就应当可以被 Java 虚拟机直接从当前类加载，而不需要引用其它类。 method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法方法和类或接口初始化方法方法 。methods[]数组只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。</p><h3>NO15.属性计数器(attributes_count)</h3><p>属性计数器，attributes_count的值表示当前 Class 文件attributes表的成员个数。attributes表中每一项都是一个attribute_info 结构的数据项。</p><h3>NO16.属性信息数据区(attributes[attributes_count])</h3><p>属性表，attributes 表的每个项的值必须是attribute_info结构。</p><p>在Java 7 规范里，Class文件结构中的attributes表的项包括下列定义的属性： InnerClasses  、 EnclosingMethod 、 Synthetic  、Signature、SourceFile，SourceDebugExtension 、Deprecated、RuntimeVisibleAnnotations 、RuntimeInvisibleAnnotations以及BootstrapMethods属性。</p><p>对于支持 Class 文件格式版本号为 49.0 或更高的 Java 虚拟机实现，必须正确识别并读取attributes表中的Signature、RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。对于支持Class文件格式版本号为 51.0 或更高的 Java 虚拟机实现，必须正确识别并读取 attributes表中的BootstrapMethods属性。Java 7 规范 要求任一 Java 虚拟机实现可以自动忽略 Class 文件的 attributes表中的若干 （甚至全部） 它不可识别的属性项。任何本规范未定义的属性不能影响Class文件的语义，只能提供附加的描述信息 。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内存分配和回收策略</title>
      <link href="/2019/02/09/JVM/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
      <url>/2019/02/09/JVM/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第十篇文章，本章对内存分配和垃圾回收的细节再次详细说明一下，并且说明一下逃逸分析/栈上分配以及TLAB两种方式的概念和原理。</p><a id="more"></a><h2>1. 对象优先在Eden分配</h2><p><strong>前面文章曾介绍HotSpot虚拟机新生代内存布局及算法:</strong></p><blockquote><p>（1）、将新生代内存分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间；</p><p>（2）、每次使用<code>Eden</code>和其中一块<code>Survivor</code>；</p><p>（3）、当回收时，将<code>Eden</code>和使用中的<code>Survivor</code>中还存活的对象一次性复制到另外一块<code>Survivor</code>；</p><p>（4）、而后清理掉<code>Eden</code>和使用过的<code>Survivor</code>空间；</p><p>（5）、后面就使用<code>Eden</code>和复制到的那一块<code>Survivor</code>空间，重复步骤3；</p></blockquote><p>默认<code>Eden：Survivor=8:1</code>，即每次可以使用90%的空间，只有一块<code>Survivor</code>的空间被浪费；</p><p>大多数情况下，对象在新生代<code>Eden</code>区中分配；</p><p>当<code>Eden</code>区没有足够空间进行分配时，JVM将发起一次<code>Minor GC</code>（新生代GC）；</p><p><code>Minor GC</code>时，如果发现存活的对象无法全部放入<code>Survivor</code>空间，只好通过分配担保机制提前转移到老年代。</p><h2>2. 大对象直接进入老年代</h2><p>大对象指需要大量连续内存空间的Java对象，如，很长的字符串、数组；</p><p>经常出现大对象容易导致内存还有不少空间就提前触发GC,以获取足够的连续空间来存放它们，所以应该尽量避免使用创建大对象；</p><p><code>-XX:PretenureSizeThreshold</code>：</p><p><strong>可以设置这个阈值，大于这个参数值的对象直接在老年代分配；</strong></p><p>默认为0（无效），且只对<code>Serail</code>和<code>ParNew</code>两款收集器有效；</p><p>如果需要使用该参数，可考虑<code>ParNew+CMS</code>组合。</p><h2>3. 长期存活的对象将进入老年代</h2><p>JVM给每个对象定义一个对象年龄计数器，其计算流程如下：</p><blockquote><p>在<code>Eden</code>中分配的对象，经<code>Minor GC</code>后还存活，就复制移动到<code>Survivor</code>区，年龄为1；</p><p>而后每经一次<code>Minor GC</code>后还存活，在<code>Survivor</code>区复制移动一次，年龄就增加1岁；</p><p>如果年龄达到一定程度，就晋升到老年代中；</p></blockquote><p><code>-XX:MaxTenuringThreshold</code>：</p><p><strong>设置新生代对象晋升老年代的年龄阈值，默认为15；</strong></p><h2>4. 动态对象年龄判定</h2><p>JVM为更好适应不同程序，不是永远要求等到<code>MaxTenuringThreshold</code>中设置的年龄；</p><p>如果在<code>Survivor</code>空间中相同年龄的所有对象大小总和大于<code>Survivor</code>空间的一半，大于或等于该年龄的对象就可以直接进入老年代</p><h2>5. 空间分配担保</h2><p>在前面曾简单介绍过分配担保：</p><p>当<code>Survivor</code>空间不够用时，需要依赖其他内存（老年代）进行分配担保（<code>Handle Promotion</code>）；</p><p><strong>分配担保的流程如下：</strong></p><blockquote><p>在发生<code>Minor GC</code>前，JVM先检查老年代最大可用的连续空间是否大于新生所有对象空间；</p></blockquote><blockquote><p>如果大于，那可以确保<code>Minor GC</code>是安全的；</p></blockquote><blockquote><p>如果不大于，则<code>JVM</code>查看<code>HandlePromotionFailure</code>值是否允许担保失败；</p></blockquote><blockquote><p>如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小；</p></blockquote><blockquote><p>如果大于，将尝试进行一次<code>Minor GC</code>，但这是有风险的；</p></blockquote><blockquote><p>如果小于或<code>HandlePromotionFailure</code>值不允许冒险，那这些也要改为进行一次<code>Full GC</code>；</p></blockquote><p><strong>尝试<code>Minor GC</code>的风险–担保失败：</strong></p><blockquote><p>因为尝试<code>Minor GC</code>前面，无法知道存活的对象大小，所以使用历次晋升到老年代对象的平均大小作为经验值；</p><p>假如尝试的<code>Minor GC</code>最终存活的对象远远高于经验值的话，会导致担保失败（<code>Handle Promotion Failure</code>）；</p><p>失败后只有重新发起一次<code>Full GC</code>，这绕了一个大圈，代价较高；</p></blockquote><p><strong>但一般还是要开启<code>HandlePromotionFailure</code>，避免<code>Full GC</code>过于频繁，而且担保失败概率还是比较低的；</strong></p><p><strong>JDK6-u24后，JVM代码中已经不再使用<code>HandlePromotionFailure</code>参数了；</strong></p><p>规则变为：</p><p>⭐⭐⭐<strong>只要老年代最大可用的连续空间大于新生所有对象空间或历次晋升到老年代对象的平均大小，就会进行<code>Minor GC</code>；否则进行<code>Full GC</code>；</strong></p><p>⭐⭐⭐即老年代最大可用的连续空间小于新生所有对象空间时，不再检查<code>HandelPromotionFailure</code>，而直接检查历次晋升到老年代对象的平均大小；</p><h2>6. 逃逸分析</h2><p>般认为new出来的对象都是被分配在堆上，但是这个结论不是那么的绝对，通过对Java对象分配的过程分析，可以知道有两个地方会导致Java中new出来的对象并不一定分配在所认为的堆上。这两个点分别是Java中的逃逸分析和<code>TLAB</code>（<code>Thread Local Allocation Buffer</code>）。</p><h5>6.1 什么是栈上分配？</h5><p>栈上分配主要是指在Java程序的执行过程中，<strong>在方法体中声明的变量以及创建的对象，将直接从该线程所使用的栈中分配空间</strong>。</p><p>一般而言，创建对象都是从堆中来分配的，这里是指在栈上来分配空间给新创建的对象。</p><h5>6.2 什么是逃逸？</h5><p>逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；</p><p>这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。</p><p>正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；而此时由于无法回收，即成为逃逸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> V global_v;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> V v=b_method();  </span><br><span class="line"> c_method();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">b_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> V v=<span class="keyword">new</span> V();  </span><br><span class="line"> <span class="keyword">return</span> v;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c_method</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> global_v=<span class="keyword">new</span> V();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>b_method</code>方法内部生成的V对象的引用被返回给<code>a_method</code>方法内的变量v，<code>c_method</code>方法内生成的V对象被赋给了全局变量<code>global_v</code>。这两种场景都发生了（引用）逃逸。</p><h5>6.3 逃逸分析</h5><p>在JDK 6之后支持对象的栈上分析和逃逸分析，在JDK7中完全支持栈上分配对象。其是否打开逃逸分析依赖于以下JVM的设置：</p><blockquote><p><code>-XX:+DoEscapeAnalysis</code></p></blockquote><h5>6.4 栈上分配与逃逸分析的关系</h5><p>进行逃逸分析之后，产生的后果是所有的对象都将由栈上分配，而非从JVM内存模型中的堆来分配。</p><h5>6.5 逃逸分析／栈上分配的优劣分析</h5><p>JVM在<code>Server</code>模式下的逃逸分析可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配，由于该对象一定是局部的，所以栈上分配不会有问题。</p><blockquote><p>消除同步。</p></blockquote><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。逃逸分析可以判断出某个对象是否始终只被一个线程访问，如果只被一个线程访问，那么对该对象的同步操作就可以转化成没有同步保护的操作，这样就能大大提高并发程度和性能。</p><blockquote><p>矢量替代。</p></blockquote><p>逃逸分析方法如果发现对象的内存存储结构不需要连续进行的话，就可以将对象的部分甚至全部都保存在CPU寄存器内，这样能大大提高访问速度。</p><blockquote><p>劣势：</p></blockquote><p>栈上分配受限于栈的空间大小，一般自我迭代类的需求以及大的对象空间需求操作，将导致栈的内存溢出；故只适用于一定范围之内的内存范围请求。</p><h5>6.6 测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//会发生逃逸</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            x = (++counter);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">10</span>; ++i) &#123;  </span><br><span class="line">            Foo foo = <span class="keyword">new</span> Foo();  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();  </span><br><span class="line">        System.out.println(<span class="string">"Time cost is "</span> + (end - start));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未开启逃逸分析设置为：</p><blockquote><p>-server -verbose:gc</p></blockquote><p>在未开启逃逸分析的状况下运行情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC 5376K-&gt;427K(63872K), 0.0006051 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(63872K), 0.0003928 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(63872K), 0.0003639 secs]  </span><br><span class="line">[GC 5803K-&gt;427K(69248K), 0.0003770 secs]  </span><br><span class="line">[GC 11179K-&gt;427K(69248K), 0.0003987 secs]  </span><br><span class="line">[GC 11179K-&gt;427K(79552K), 0.0003817 secs]  </span><br><span class="line">[GC 21931K-&gt;399K(79552K), 0.0004342 secs]  </span><br><span class="line">[GC 21903K-&gt;399K(101120K), 0.0002175 secs]  </span><br><span class="line">[GC 43343K-&gt;399K(101184K), 0.0001421 secs]  </span><br><span class="line">Time cost is 58514571</span><br></pre></td></tr></table></figure><p>开启逃逸分析设置为：</p><blockquote><p>-server -verbose:gc -XX:+DoEscapeAnalysis</p></blockquote><p>开启逃逸分析的状况下，运行情况如下：</p><blockquote><p>Time cost is 10031306</p></blockquote><p>未开启逃逸分析时，运行上述代码，JVM执行了GC操作，而在开启逃逸分析情况下，JVM并没有执行GC操作。同时，操作时间上，开启逃逸分析的程序运行时间是未开启逃逸分析时间的1/5。</p><h2>7. 再来聊聊TLAB</h2><p>JVM在内存新生代<code>Eden Space</code>中开辟了一小块线程私有的区域，称作<code>TLAB</code>（<code>Thread-local allocation buffer</code>）。默认设定为占用<code>Eden Space</code>的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且<code>TLAB</code>上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。<br>也就是说，Java中每个线程都会有自己的缓冲区称作<code>TLAB</code>（<code>Thread-local allocation buffer</code>），每个<code>TLAB</code>都只有一个线程可以操作，TLAB结合<code>bump-the-pointer</code>技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。</p><h2>8. 对象内存分配过程再升级</h2><blockquote><ol><li>编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.</li></ol></blockquote><blockquote><ol start="2"><li>如果<code>tlab_top + size &lt;= tlab_end</code>，则在在TLAB上直接分配对象并增加<code>tlab_top</code><br>的值，如果现有的TLAB不足以存放当前对象则3.</li></ol></blockquote><blockquote><ol start="3"><li>重新申请一个<code>TLAB</code>，并再次尝试存放当前对象。如果放不下，则4.</li></ol></blockquote><blockquote><ol start="4"><li>在<code>Eden</code>区加锁（这个区是多线程共享的），如果<code>eden_top + size &lt;= eden_end</code>则将对象存放在<code>Eden</code>区，增加<code>eden_top</code> 的值，如果<code>Eden</code>区不足以存放，则5.</li></ol></blockquote><blockquote><ol start="5"><li>执行一次<code>Young GC</code>（<code>minor collection</code>）。</li></ol></blockquote><blockquote><ol start="6"><li>经过<code>Young GC</code>之后，如果<code>Eden</code>区任然不足以存放当前对象，则直接分配到老年代。</li></ol></blockquote><blockquote><ol start="7"><li>老年代还是不足，则触发Full GC，再不足就OOM错误</li></ol></blockquote>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>垃圾收集器介绍</title>
      <link href="/2019/02/09/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/02/09/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第九篇文章，主要介绍七种比较经典的垃圾收集器的实现原理。</p><a id="more"></a><h2>垃圾收集器</h2><p><img src="http://xiaozhao.oursnail.cn/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>以上是 <code>HotSpot</code> 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><h3>1. Serial 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/Serial%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p><code>Serial</code> 翻译为串行，垃圾收集和用户程序不能同时执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 <code>CMS</code> 和 <code>G1</code> 之外，其它收集器都是以串行的方式执行。<code>CMS</code> 和 <code>G1</code> 可以使得垃圾收集和用户程序同时执行，被称为并发执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 <code>Client</code> 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。<code>Serial</code> 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h3>2. ParNew 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>它是 <code>Serial</code> 收集器的多线程版本。</p><p>是 <code>Server</code>模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 <code>Serial</code> 收集器，只有它能与 <code>CMS</code> 收集器配合工作。</p><p>默认开始的线程数量与 CPU 数量相同，可以使用 <code>-XX:ParallelGCThreads</code> 参数来设置线程数。</p><h3>3. Parallel Scavenge 收集器</h3><p>与 <code>ParNew</code> 一样是并行的多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 <code>-XX:MaxGCPauseMillis</code> 参数以及直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>还提供了一个参数 <code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 和 <code>Survivor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（<code>GC Ergonomics</code>）。</p><h3>4. Serial Old 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/SerialOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>是 <code>Serial</code> 收集器的老年代版本，也是给 <code>Client</code> 模式下的虚拟机使用。如果用在 <code>Server</code> 模式下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（<code>Parallel Old</code> 诞生以前）中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li><li>作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li></ul><h3>5. Parallel Old 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/ParallelOld%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p>是 <code>Parallel Scavenge</code> 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器。</p><h3>6. CMS 收集器</h3><p><img src="http://xiaozhao.oursnail.cn/CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image"></p><p><code>CMS</code>（Concurrent Mark Sweep），<code>Mark Sweep</code> 指的是标记 - 清除算法。</p><p>特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 <code>GC Roots</code> 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行<code>GC Roots Tracing</code> 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 <code>-XX:CMSInitiatingOccupancyFraction</code> 来改变触发 <code>CMS</code> 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 <code>Serial Old</code> 来替代 <code>CMS</code>。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code>。</li></ul><h3>7. G1 收集器</h3><p><code>G1</code>（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。<code>HotSpot</code> 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>G1 把新生代和老年代划分成多个大小相等的独立区域（<code>Region</code>），新生代和永久代不再物理隔离。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A82.png" alt="image"></p><p>通过引入 <code>Region</code> 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用来记录该 <code>Region</code> 对象的引用对象所在的 <code>Region</code>。通过使用 <code>Remembered Set</code>，在做可达性分析的时候就可以避免全堆扫描。</p><p><img src="http://xiaozhao.oursnail.cn/G1%E6%94%B6%E9%9B%86%E5%99%A83.jpg" alt="image"></p><p>如果不计算维护 <code>Remembered Set</code> 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 <code>Region</code> 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 <code>Region</code> 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h3>8. 比较</h3><table><thead><tr><th style="text-align:center">收集器</th><th style="text-align:center">串行/并行/并发</th><th style="text-align:center">新生代/老年代</th><th style="text-align:center">收集算法</th><th style="text-align:center">目标</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Serial</strong></td><td style="text-align:center">串行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单 CPU 环境下的 Client 模式</td></tr><tr><td style="text-align:center"><strong>Serial Old</strong></td><td style="text-align:center">串行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">单 CPU 环境下的 Client 模式、CMS 的后备预案</td></tr><tr><td style="text-align:center"><strong>ParNew</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr><tr><td style="text-align:center"><strong>Parallel Scavenge</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>Parallel Old</strong></td><td style="text-align:center">串行 + 并行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">吞吐量优先</td><td style="text-align:center">在后台运算而不需要太多交互的任务</td></tr><tr><td style="text-align:center"><strong>CMS</strong></td><td style="text-align:center">并行 + 并发</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-清除</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">集中在互联网站或 B/S 系统服务端上的 Java 应用</td></tr><tr><td style="text-align:center"><strong>G1</strong></td><td style="text-align:center">并行 + 并发</td><td style="text-align:center">新生代 + 老年代</td><td style="text-align:center">标记-整理 + 复制算法</td><td style="text-align:center">响应速度优先</td><td style="text-align:center">面向服务端应用，将来替换 CMS</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GC相关</title>
      <link href="/2019/02/09/JVM/GC%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/02/09/JVM/GC%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第八篇文章，我们知道，JVM为我们管理垃圾对象实现自动回收，让我们不需要太关心内存释放问题，一定程度上减少了内存溢出的错误。这一切的背后是如何实现的呢？</p><a id="more"></a><h2>一、垃圾标记算法</h2><h5>1.1 引用计数法</h5><p><strong>算法思想</strong></p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器☞减一；任何时候计数器为0的对象是不可能再被使用的。</p><p><strong>主要缺陷</strong></p><p>无法解决对象间相互循环引用的问题。</p><p><strong>举个例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Test objA = <span class="keyword">new</span> Test();<span class="comment">//count=1</span></span><br><span class="line">    Test objB = <span class="keyword">new</span> Test();<span class="comment">//count=1</span></span><br><span class="line"></span><br><span class="line">        objA.instance = objB;<span class="comment">//count=2</span></span><br><span class="line">        objB.instance = objA;<span class="comment">//count=2</span></span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;<span class="comment">//count=1</span></span><br><span class="line">        objB = <span class="keyword">null</span>;<span class="comment">//count=1</span></span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">testGC();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入参数</strong></p><blockquote><p>-verbose:gc -XX:+PrintGCDetails</p></blockquote><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 6063K-&gt;600K(37888K)] 6063K-&gt;608K(123904K), 0.0037131 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 600K-&gt;0K(37888K)] [ParOldGen: 8K-&gt;529K(86016K)] 608K-&gt;529K(123904K), [Metaspace: 2595K-&gt;2595K(1056768K)], 0.0062705 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 37888K, used 328K [0x00000000d6100000, 0x00000000d8b00000, 0x0000000100000000)</span><br><span class="line">  eden space 32768K, 1% used [0x00000000d6100000,0x00000000d6152030,0x00000000d8100000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d8100000,0x00000000d8100000,0x00000000d8600000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8600000,0x00000000d8600000,0x00000000d8b00000)</span><br><span class="line"> ParOldGen       total 86016K, used 529K [0x0000000082200000, 0x0000000087600000, 0x00000000d6100000)</span><br><span class="line">  object space 86016K, 0% used [0x0000000082200000,0x0000000082284778,0x0000000087600000)</span><br><span class="line"> Metaspace       used 2601K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 288K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>日志中6063K-&gt;600K(37888K)，从原来的6M内存变成了600k，表明对象已被回收，从而表明JVM没有使用引用计数算法。Java中使用了可达性分析算法来来判定对象是否存活。</p><h5>1.2 可达性分析算法</h5><p>这个算法的基本思路就是通过一系列的称谓<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径为引用链，当一个对象到<code>GC Roots</code>没有任何引用链时，则证明此对象时不可用的，下面看一下例子：</p><p><img src="http://img.blog.csdn.net/20141102164158981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamlhbmd3ZWkwOTEwNDEwMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><p>上面的这张图，对象<code>object5</code>、<code>object6</code>、<code>object7</code>虽然互相没有关联，但是它们到<code>GC Roots</code>是不可达的，所以它们将会被判定为是可回收的对象</p><p>注：Java语言中，可作为<code>GC Roots</code>的对象包括下面几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li><li>活跃线程引用的对象</li></ul><h2>二、Java中的引用类型</h2><p>从JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用，虚引用，这四种引用的强度一次逐渐减弱</p><ol><li><p>强引用就是指在程序代码之中普遍存在的，类似 <code>Object obj = new Object()</code> 这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</p></li><li><p>软引用是用来描述一些还有用但并非需要的对象，对于软引用关联着的对象，在系统将要发生内存异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存异常</p></li><li><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存释放足够，都会回收掉只被弱引用关联的对象</p></li><li><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，对一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</p></li></ol><h3>三、两次标记</h3><p>《深入理解java虚拟机》原文：</p><blockquote><p>在java根搜索算法中判断对象的可达性，对于不可达的对象，也并不一定是必须清理。这个时候有一个缓刑期，真正的判断一个对象死亡，至少要经过俩次标记过程：</p><p>如果对象在进行根搜索后发现没有与<code>GC roots</code>相关联的引用链，那他将会第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这俩种情况都视为“没有必要执行”。</p><p>即当一个对象重写了<code>finalize()</code>方法的时候，这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象被放置在<code>F-Queue</code>队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行。这里所谓的执行是指虚拟机会出发这个方法，但不承诺会等待它运行结束。这样做的原因：如果一个对象在<code>finalize()</code>方法中执行缓慢，或者发生了死循环（极端的情况下），将可能会导致<code>F-Queue</code>队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象要在<code>finalize()</code>中成功拯救自己----只要重新与引用链上的任何建立关联即可，那么在第二次标记时它将会被移出“即将回收”的集合；如果对象这时候没有逃脱，就会被回收。</p></blockquote><h5>3.1 finalize的工作原理</h5><p>一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用<code>finalize()</code>，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存.所以如果使用<code>finalize()</code>，就可以在垃圾收集期间进行一些重要的清除或清扫工作.</p><h5>3.2 finalize()在什么时候被调用?</h5><ol><li>所有对象被<code>Garbage Collection</code>时自动调用,比如运行<code>System.gc()</code>的时候.</li><li>程序退出时为每个对象调用一次<code>finalize</code>方法。</li><li>显式的调用<code>finalize</code>方法</li></ol><p>这个方法的用途就是：在该对象被回收之前，该对象的<code>finalize()</code>方法会被调用。<strong>这里的回收之前指的就是被标记之后</strong>，问题就出在这里，有没有一种情况就是原本一个对象开始不再上一章所讲的“关系网”（引用链）中，但是当开发者重写了<code>finalize()</code>后，并且将该对象重新加入到了“关系网”中，也就是说该对象对我们还有用，不应该被回收，但是已经被标记啦，怎么办呢？</p><p>针对这个问题，虚拟机的做法是进行两次标记，即<strong>第一次标记不在“关系网”中的对象，并且要判断该对象有没有实现<code>finalize()</code>方法</strong>了，如果没有实现就直接判断该对象可回收。如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它。</p><p><strong>随后就会进行第二次的小规模标记</strong>，如果对象还没有逃脱，在这次被标记的对象就会真正的被回收了。</p><h2>四、垃圾收集算法</h2><h5>4.1 标记-清除算法</h5><p>最基础的收集算法是“标记-清除”（<code>Mark-Sweep</code>）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经基本介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。<strong>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</strong>。</p><p>标记-清除算法的执行过程如图：</p><p><img src="http://bloghello.oursnail.cn/jvm8-1.jpg" alt="image"></p><h5>4.2 复制算法</h5><p>为了解决效率问题，一种称为“复制”（<code>Copying</code>）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<strong>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点</strong>。</p><p>复制算法的执行过程如图：</p><p><img src="http://bloghello.oursnail.cn/jvm8-2.jpg" alt="image"></p><h5>4.3 标记-整理算法</h5><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就<strong>需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法</strong>。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（<code>Mark-Compact</code>）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图</p><p><img src="http://bloghello.oursnail.cn/jvm8-3.jpg" alt="image"></p><h5>4.4 分代收集算法</h5><p>当前商业虚拟机的垃圾收集都采用“分代收集”（<code>Generational Collection</code>）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收</strong></p><p><img src="http://bloghello.oursnail.cn/jvm8-4.jpg" alt="image"></p><h2>五、新生代和老年代</h2><h5>5.1 新生代</h5><p>新生代分为三个区域，一个<code>Eden</code>区和两个<code>Survivor</code>区，它们之间的比例为（8：1：1），这个比例也是可以修改的。通常情况下，对象主要分配在新生代的<code>Eden</code>区上，少数情况下也可能会直接分配在老年代中。</p><p>Java虚拟机每次使用新生代中的<code>Eden</code>和其中一块<code>Survivor</code>（<code>From</code>），在经过一次<code>MinorGC</code>后，将<code>Eden</code>和<code>Survivor</code>中还存活的对象一次性地复制到另一块<code>Survivor</code>空间上（这里使用的复制算法进行GC），最后清理掉<code>Eden</code>和刚才用过的<code>Survivor</code>（<code>From</code>）空间。将此时在<code>Survivor</code>空间存活下来的对象的年龄设置为1，以后这些对象每在<code>Survivor</code>区熬过一次GC，它们的年龄就加1，当对象年龄达到某个年龄（默认值为15）时，就会把它们移到老年代中。</p><p>在新生代中进行GC时，有可能遇到另外一块<code>Survivor</code>空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><p>总结：</p><p>1、<code>Minor GC</code>是发生在新生代中的垃圾收集，采用的复制算法；</p><p>2、新生代中每次使用的空间不超过90%，主要用来存放新生的对象；</p><p>3、<code>Minor GC</code>每次收集后Eden区和一块<code>Survivor</code>区都被清空；</p><h5>5.1 老年代</h5><p>老年代里面存放都是生命周期长的对象，对于一些较大的对象（即需要分配一块较大的连续内存空间），是直接存入老年代的，还有很多从新生代的<code>Survivor</code>区域中熬过来的对象。</p><p>老年代中使用的是<code>Full GC</code>，<code>Full GC</code>所采用的是标记-清除或者标记-整理算法。老年代中的<code>Full GC</code>不像<code>Minor GC</code>操作那么频繁，并且进行一次<code>Full GC</code>所需要的时间要比<code>Minor GC</code>的时间长。</p><h5>5.2 触发Full GC的条件</h5><ul><li>老年代空间不足</li><li>JDK8以前的永久代空间不足，现在永久代已经被元数据区代替</li><li>CMS GC时出现<code>promotion failed</code>，<code>concurrent mode failure</code>(下面文章讲到CMS垃圾收集器的时候会说明)</li><li><code>minor GC</code>晋升到老年代的平均大小大于老年代的剩余空间</li><li>调用<code>System.gc()</code>提醒JVM回收一下，只是提醒</li></ul><h5>5.3 对象如何晋升到老年代</h5><p>一般有如下情况会晋升：</p><ul><li>经历一定minor次数依然存活的对象</li><li>survivor区中存放不下的对象</li><li>新生成的大对象</li></ul><h5>5.4 常用的调优参数</h5><p><img src="http://bloghello.oursnail.cn/jvm8-5.jpg" alt="image"></p><h5>5.5 内存申请过程</h5><p>A. JVM会试图为相关Java对象在<code>Eden</code>中初始化一块内存区域</p><p>B. 当<code>Eden</code>空间足够时，内存申请结束。否则到下一步</p><p>C. <code>JVM</code>试图释放在<code>Eden</code>中所有不活跃的对象（<code>Minor GC</code>）, 释放后若<code>Eden</code>空间仍然不足以放入新对象，则试图将部分<code>Eden</code>中活跃对象放入<code>Survivor</code>区</p><p>D. 当<code>Survivor</code>区空间不够时或者某些对象熬的时间比较长，则<code>Survivor</code>区这些对象会被移到<code>Old</code>区</p><p>E. 当<code>Old</code>区空间不够时，<code>JVM</code>会在<code>Old</code>区进行完全的垃圾收集（<code>Full GC</code>）</p><p>F. 完全垃圾收集后，若<code>Survivor</code>及<code>Old</code>区仍然无法存放从<code>Eden</code>复制过来的部分对象，导致<code>JVM</code>无法在<code>Eden</code>区为新对象创建内存区域，则出现<code>out of memory</code>错误.</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA内存模型常问面试题</title>
      <link href="/2019/02/08/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%B8%B8%E9%97%AE%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/02/08/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%B8%B8%E9%97%AE%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第七篇文章，介绍一些面试比较常问的问题。</p><a id="more"></a><h2>一、JVM三大性能调优参数-Xms -Xmx -Xss的含义</h2><p>一般我们可以传入以下参数去调整堆和内存所占的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms128m -Xmx128m -Xss256k -jar xxx.jar</span><br></pre></td></tr></table></figure><ul><li>-Xms ：堆的初始值</li><li>-Xmx ：堆能达到的最大值</li><li>-Xss ：规定了每个线程虚拟机栈的大小</li></ul><h2>二、JAVA内存模型中堆和栈的区别</h2><p>首先来了解一下几种不同的内存分配策略：</p><ul><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求，比如static声明的静态变量，这里的数据一般都放在方法区，java8中这个区域叫做元数据区，用的时物理内存，并且之前合在一起的字符串常量池也被移到了堆区，详情见上一篇文章。</li><li>栈式存储：数据去需求在编译时未知，运行时模块入口前确定，比如基本数据类型，都是在运行的时候，才知道数据(字面量)到底是什么，对于JVM，一个方法内的执行，局部变量表和操作数栈的大小时确定的，即引用变量和栈空间大小是编译器确定的，至于字面量等运行时才能确定。</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态分配，比如可变长度串、对象实例</li></ul><p>下面来看看栈和堆的联系：</p><p>引用对象或者数组时，栈里定义变量保存堆中目标的首地址。</p><p><img src="http://bloghello.oursnail.cn/jvm7-1.png" alt="image"></p><p>下面来看看栈和堆的区别：</p><ul><li>管理方式：栈自动释放，堆需要GC</li><li>空间大小：栈比堆小</li><li>碎片相关：栈产生的碎片远小于堆</li><li>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</li><li>效率：栈的效率比堆高</li></ul><p>简单总结：栈比较小，随着方法执行完毕自动释放，栈数据结构简单，所以操作也简单高效。堆放各种对象实例和数组，必定要比较大的空间，那么需要GC来回收不需要的数据，效率低并且碎片也比较多，由于堆的操作比较复杂，所以数据结构也复杂，效率低。</p><h2>三、元空间、堆、线程独占部分间的联系</h2><p>先来看一个最简单的程序：</p><p><img src="http://bloghello.oursnail.cn/jvm7-2.png" alt="image"></p><p>我们分别从元空间、堆、以及线程独占的部分来看看分别存储了啥：</p><p><img src="http://bloghello.oursnail.cn/jvm7-3.png" alt="image"></p><p>学到这里，对于这些东西已经不需要解释了。针对JVM内存模型的知识在这里就串联起来了。了解到这里，对内存模型这一块基本的知识已经差不多了。</p><h2>四、再来说说字符串</h2><p>之前在<a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" target="_blank" rel="noopener">java字符串核心一网打尽</a>文章中，其实是对于JDK8这个版本的字符串特性进行详细的解读，其中也介绍了<code>intern</code>这个方法的含义和用法，由于JDK6和JDK6+关于<code>intern</code>是不一样的，这里对比一下。</p><p>对于JDK8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况</span></span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    str1.intern();</span><br><span class="line">    String str2 = <span class="string">"a"</span>;</span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种情况</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    str3.intern();</span><br><span class="line">    String str4 = <span class="string">"aa"</span>;</span><br><span class="line">    System.out.println(str3 == str4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>但是在JDK6中执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>这个问题困扰了我很久，由于之前基础不是太扎实，所以直接就跳过了这个问题，在面试的时候几乎也不会太深究，但是一直成为我心里的坎。今天要把他解决掉。在说明这个问题之前，需要说明一下JVM有三种常量池：</p><h5>4.1 三种常量池</h5><ol><li>Class文件中的常量池</li></ol><p>这里面主要存放两大类常量：字面量和符号引用，符号引用包含三类常量：</p><ul><li>类和接口的全限定名(<code>Full Qualified Name</code>)</li><li>字段的名称和描述符(<code>Descriptor</code>)</li><li>方法的名称和描述符</li></ul><p>这个用<code>javap</code>看一下就能明白，这里只涉及字符串就不谈其他的了。简单地说，用双引号引起来的字符串字面量都会进这里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>str2</code>就是符号引用，<code>a</code>就是字面量。</p><ol start="2"><li>运行时常量池</li></ol><p>方法区的一部分。<code>Class</code>文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池(<code>Constant Pool Table</code>)，存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。</p><ol start="3"><li>全局字符串</li></ol><p><code>HotSpot VM</code>里，记录<code>interned string</code>的一个全局表叫做<code>StringTable</code>，它本质上就是个<code>HashSet&lt;String&gt;</code>。这是个纯运行时的结构，而且是惰性（<code>lazy</code>）维护的。</p><p>注意，它里面存放的是引用。</p><p>所以，一般我们说一个字符串进入了全局的字符串常量池其实是说在这个<code>StringTable</code>中保存了对它的引用，反之，如果说没有在其中就是说<code>StringTable</code>中没有对它的引用。</p><h5>4.2 字面量进入字符串常量池的时机</h5><p>先给出一个结论：就<code>HotSpot VM</code>的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在<code>StringTable</code>中并没有相应的引用，在堆中也没有对应的对象产生）</p><p>那么加载类的过程发生的是什么呢？</p><p>R大的一篇文章：</p><blockquote><p>在类加载阶段， JVM会在堆中创建 对应这些 class文件常量池中的 字符串对象实例 并在字符串常量池中驻留其引用。具体在resolve阶段执行。这些常量全局共享。</p></blockquote><p>这里说的比较笼统，没错，是<code>resolve</code>阶段，但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 <strong>JVM规范里明确指定resolve阶段可以是lazy的。</strong></p><p>所以，类加载的时候，必定要做的东西是，将class文件中字面量和符号引用放入运行时常量池中，而<code>JVM</code>规范里<code>Class</code>文件的常量池项的类型，有两种东西：<code>CONSTANT_Utf8</code>和<code>CONSTANT_String</code>。后者是<code>String</code>常量的类型，但它并不直接持有<code>String</code>常量的内容，而是只持有一个<code>index</code>，这个<code>index</code>所指定的另一个常量池项必须是一个<code>CONSTANT_Utf8</code>类型的常量，这里才真正持有字符串的内容。</p><p><code>CONSTANT_Utf8</code>会在类加载的过程中就全部创建出来，而<code>CONSTANT_String</code>则是<code>lazy resolve</code>的，例如说在第一次引用该项的<code>ldc</code>指令被第一次执行到的时候才会<code>resolve</code>。</p><h5>4.3 ldc指令是什么东西？</h5><p>简单地说，它用于将int、float或String型常量值从常量池中推送至栈顶</p><p>以下面代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abc</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        String a = <span class="string">"AA"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看其编译后的Class文件如下：</p><p><img src="http://bloghello.oursnail.cn/jvm7-4.png" alt="image"></p><p>根据上面说的，在类加载阶段，这个 <code>resolve</code> 阶段（ <code>constant pool resolution</code>）是<code>lazy</code>的。换句话说并没有真正的对象，字符串常量池里自然也没有。执行<code>ldc</code>指令就是触发这个<code>lazy resolution</code>动作的条件。</p><p>ldc字节码在这里的执行语义是：到当前类的运行时常量池去查找该<code>index</code>对应的项,即上面说的<code>CONSTANT_String</code>指向的<code>index</code>，如果该项尚未<code>resolve</code>则<code>resolve</code>之，并返回<code>resolve</code>后的内容。</p><p>在遇到<code>String</code>类型常量时，<code>resolve</code>的过程如果发现<code>StringTable</code>已经有了内容匹配的<code>java.lang.String</code>的引用，则直接返回这个引用，反之，如果<code>StringTable</code>里尚未有内容匹配的<code>String</code>实例的引用，则会在<code>Java</code>堆里创建一个对应内容的<code>String</code>对象，然后在<code>StringTable</code>记录下这个引用，并返回这个引用出去。</p><p>这里很重要，昭示了一个重要问题：<code>String a = &quot;AA&quot;;</code>这一句执行完，要看字符串常量池中是否已经存在，不存在的话是要在堆中先创建对象的，然后把堆地址给全局的字符串常量池。</p><p>理解到这，有些问题就可以解决了，这里先不回答最上面的问题，先来看看下面的例子。注意运行环境是JDK8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTest0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s1=<span class="string">"static"</span>;  <span class="comment">// 第一句</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"he"</span>)+<span class="keyword">new</span> String(<span class="string">"llo"</span>); <span class="comment">//第二句</span></span><br><span class="line">        s2.intern(); <span class="comment">// 第三句</span></span><br><span class="line">        String s3=<span class="string">"hello"</span>;  <span class="comment">//第四句</span></span><br><span class="line">        System.out.println(s2 == s3);<span class="comment">//第五句，输出是true。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;static&quot;</code> <code>&quot;he&quot;</code> <code>&quot;llo&quot;</code> <code>&quot;hello&quot;</code>都会进入<code>Class</code>的常量池， 按照上面说的，类加载阶段由于<code>resolve</code> 阶段是<code>lazy</code>的，所以是不会创建实例，更不会驻留字符串常量池了。</p><p>但是要注意这个<code>“static”</code>和其他三个不一样，它是静态的，在类加载阶段中的初始化阶段，会为静态变量指定初始值，也就是要把<code>“static”</code>赋值给<code>s1</code>，这个赋值操作要怎么搞啊，先<code>ldc</code>指令把它放到栈顶，然后用<code>putstatic</code>指令完成赋值。注意，<code>ldc</code>指令，根据上面说的，会创建<code>&quot;static&quot;</code>字符串对象，并且会保存一个指向它的引用到字符串常量池。</p><p>运行<code>main</code>方法后，首先是第二句，一样的，要先用<code>ldc</code>把<code>&quot;he&quot;</code>和<code>&quot;llo&quot;</code>送到栈顶，换句话说，会创建他俩的对象（注意，在堆中开辟本体所占的空间，还没到new的那一步），并且会保存引用到字符串常量池中（把本地在堆中空间地址传给字符串常量池）；然后有个<code>＋</code>号对吧，内部是创建了一个<code>StringBuilder</code>对象，一路<code>append</code>，最后调用<code>StringBuilder</code>对象的<code>toString</code>方法得到一个<code>String</code>对象（内容是<code>hello</code>，注意这个<code>toString</code>方法会<code>new</code>一个<code>String</code>对象），并把它赋值给<code>s2</code>（s2指向的是new出来的新对象，是新的一块内存空间）。</p><p>注意，此时还没有把<code>hello</code>的引用放入字符串常量池。然后是第三句，<code>intern</code>方法一看，字符串常量池里面没有，它会把上面的这个<code>hello</code>对象的引用保存到字符串常量池，然后返回这个引用，但是这个返回值我们并没有使用变量去接收，所以没用。</p><p>第四句，字符串常量池里面已经有了，直接用嘛。所以<code>s2</code>和<code>s3</code>都是<code>s2</code>的指向的地址。</p><p>再来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    String s1=<span class="keyword">new</span> String(<span class="string">"he"</span>)+<span class="keyword">new</span> String(<span class="string">"llo"</span>);</span><br><span class="line">    String s2=<span class="keyword">new</span> String(<span class="string">"h"</span>)+<span class="keyword">new</span> String(<span class="string">"ello"</span>);</span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    String s3=s1.intern();</span><br><span class="line">    <span class="comment">// ③</span></span><br><span class="line">    String s4=s2.intern();</span><br><span class="line">    <span class="comment">// ④</span></span><br><span class="line">    System.out.println(s1==s3);</span><br><span class="line">    System.out.println(s1==s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是将一些符号引用和字面量从class文件的常量池中撞到运行时常量池。然后运行main方法，先看第一句，会创建<code>&quot;he&quot;</code>和<code>&quot;llo&quot;</code>对象，并放入字符串常量池，然后会创建一个<code>&quot;hello&quot;</code>对象，没有放入字符串常量池，<code>s1</code>指向这个<code>&quot;hello&quot;</code>对象。</p><p>第二句，创建<code>&quot;h&quot;</code>和<code>&quot;ello&quot;</code>对象，并放入字符串常量池，然后会创建一个<code>&quot;hello&quot;</code>对象，没有放入字符串常量池，<code>s2</code>指向这个<code>&quot;hello&quot;</code>对象。</p><p>第三句，字符串常量池里面还没有，于是会把<code>s1</code>指向的<code>String</code>对象的引用放入字符串常量池（换句话说，放入池中的引用和<code>s1</code>指向了同一个对象），然后会把这个引用返回给了<code>s3</code>，所以<code>s3==s1</code>是<code>true</code>。</p><p>第四句，字符串常量池里面已经有了，直接将它返回给了<code>s4</code>，所以<code>s4==s1</code>是<code>true</code>。</p><p>此时，回到一开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//第一种情况</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    String str1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    str1.intern();</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    String str2 = <span class="string">"a"</span>;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种情况</span></span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    String str3 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">    <span class="comment">//6</span></span><br><span class="line">    str3.intern();</span><br><span class="line">    <span class="comment">//7</span></span><br><span class="line">    String str4 = <span class="string">"aa"</span>;</span><br><span class="line">    <span class="comment">//8</span></span><br><span class="line">    System.out.println(str3 == str4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jdk1.6及以前，调用<code>intern()</code></p><blockquote><p>如果常量池中不存在值相等的字符串时，jvm会复制一个字符串到创量池中，并返回常量池中的字符串。</p></blockquote><p>而在jdk1.7及以后，调用<code>intern()</code></p><blockquote><p>如果常量池中不存在值相等的字符串时，jvm只是在常量池记录当前字符串的引用，并返回当前字符串的引用。</p></blockquote><p>所以在JDK6情况下，都是返回false，原因是：第一种情况下，执行第一句，看到有个字符串<code>&quot;a&quot;</code>，那么首先是创建<code>&quot;a&quot;</code>本体对象，并且把副本放入字符串常量池中。执行第二句，发现字符串常量池中已经存在，则不放了。执行第三句，<br>s2指向的是字符串常量池中的<code>&quot;a&quot;</code>，这个字符串常量池<code>&quot;a&quot;</code>所在的地址，肯定与堆中的新new出来的不一样。所以返回false。</p><p>第二种情况，第一句相当于：</p><p>其实相当于:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String str3 =  (<span class="keyword">new</span> StringBuilder()).apend(s1).apend(s2).toString();</span><br></pre></td></tr></table></figure><p>会先在堆中创建两个对象<code>&quot;a&quot;</code>，拷贝一个副本到字符串常量池中，此时<code>&quot;a&quot;</code>已经存在于字符串常量池中了。然后拼接生成一个新的对象<code>&quot;aa&quot;</code>在堆中，这种拼接出来的<code>&quot;aa&quot;</code>此时是不会把副本放进字符串常量池的，因为字符串常量池只保存已确定的字面量，这种拼接的属于运行完成才能确定，所以字符串常量池中没有，直到执行第6句，才会尝试把<code>&quot;aa&quot;</code>副本放入字符串常量池，但是还是跟上面一样，一个指向堆，一个指向字符串常量池，肯定不相等。</p><p>在JDK6+情况下，第一个返回false，第二个返回true。原因是：第一种情况下，执行第一句，首先是创建<code>&quot;a&quot;</code>本体对象，并且把引用放进字符串常量池中，然后new，开辟新的地址空间，此时<code>str1</code>指向的是new出来的空间的引用。执行第二句，尝试将<code>str1</code>的引用放入字符串常量池，但是池中已经存在了，所以不能放，所以一个指向堆，一个是本体对象的引用，不一样，所以为false。第二种情况，<code>&quot;a&quot;</code>跟上面一样，在堆中开辟，然后引用放入字符串常量池中，后面拼接成<code>&quot;aa&quot;</code>，此时只是在堆中开辟空间，下面执行<code>intern</code>尝试把它的引用传给字符串常量池，由于字符串常量池中没有，所以就放进去了。此时字符串常量池中的引用与<code>&quot;aa&quot;</code>对象实际的堆地址是一样的，所以为true.</p><p>这边有一个事实：在执行<code>String s1 = new String(&quot;a&quot;)</code>的<code>new</code>之前，JVM先看到有一个字符串<code>&quot;a&quot;</code>，则会先看看字符串常量池中是否有这个<code>&quot;a&quot;</code>，有则直接返回字符串常量池引用，没有则给它开辟空间，并且把这个空间的引用传给字符串常量池。</p><p><img src="http://bloghello.oursnail.cn/jvm7-7.png" alt="image"></p><p>整理自：<a href="https://www.zhihu.com/question/55994121/answer/147296098" target="_blank" rel="noopener">木女孩的回答</a></p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内连接和外连接</title>
      <link href="/2019/02/05/mysql/%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/02/05/mysql/%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>在电信实习的时候，天天有人来面试，问的问题我都听的蛮清楚的，比如内连接和外连接的区别，好像很简单，但还是说的不好，这里总结一下。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A表                         B表</span><br><span class="line">id      name                id      name </span><br><span class="line">1          a                1       b </span><br><span class="line">2          b                3       c</span><br><span class="line">4          c</span><br></pre></td></tr></table></figure><h3>内连接</h3><p>内连接就是左表和右表相同的数据:</p><p><img src="http://bloghello.oursnail.cn/mysql9-1.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id      name            id      name </span><br><span class="line">1         a              1       b</span><br></pre></td></tr></table></figure><h3>左外连接</h3><p>左外连接就是以左表为准，去匹配右表，左表有多少条数据，结果就是多少条数据</p><p><img src="http://bloghello.oursnail.cn/mysql9-2.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id      name        id     name </span><br><span class="line">1         a          1       b </span><br><span class="line">2         b         null    null</span><br><span class="line">4         c         null    null</span><br></pre></td></tr></table></figure><h3>右外连接</h3><p>右外连接就是与左外连接反之，以右表为准，去匹配左表，右表有多少条数据，结果就是多少条数据</p><p><img src="http://bloghello.oursnail.cn/mysql9-3.png" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.id=B.id</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id      name            id     name </span><br><span class="line">1         a             1       b </span><br><span class="line">null    null            3       c</span><br></pre></td></tr></table></figure><h3>交叉连接</h3><p>交叉连接不带 <code>WHERE</code> 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到<br>结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查<br>询条件的数据行数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">join</span> B</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id  name  id  name</span><br><span class="line">1 a  1   b</span><br><span class="line">1 a  3   c</span><br><span class="line">2 b    1    b</span><br><span class="line">2 b  3   c</span><br><span class="line">4 c  1   b</span><br><span class="line">4 c  3   c</span><br></pre></td></tr></table></figure><h3>内连接和外连接的区别</h3><p>内连接只列出两张表共同匹配的数据行，而外连接的结果集中不仅包含符合连接条件的数据行，还包括左表(左外连接或左连接)或右表(右外连接或右连接)中的所有数据行。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA内存模型-线程共享</title>
      <link href="/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/"/>
      <url>/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第六篇文章，介绍线程共享区域。</p><a id="more"></a><h2>一、内存模型–JAVA堆</h2><ul><li><p>java堆一般是java虚拟机所管理的内存中最大的一块。</p></li><li><p>java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p></li><li><p>堆上存放对象实例和数组。</p></li><li><p>java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p></li><li><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p></li></ul><h2>二、内存模型–方法区</h2><p><img src="http://bloghello.oursnail.cn/jvm5-4.png" alt="image"></p><blockquote><p>方法区和堆一样，是各个线程共享的内存区域。</p></blockquote><blockquote><p>它用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。</p></blockquote><blockquote><p>其中，类信息包含类的版本、字段、接口、方法</p></blockquote><h2>八、PermGen与Metaspace</h2><p>其实，方法区可以理解为一个规范，jdk6的具体实现是<code>PermGen</code>,而后来的版本具体实现是<code>Metaspace</code>。它们有一定的区别。</p><p>在 <code>HotSpot JVM</code> 中，永久代中用于存放类和方法的元数据以及常量池，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>永久代是有大小限制的，它用的是JVM内存，即与堆内存等价的<code>no heap</code>区域，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <code>java.lang.OutOfMemoryError: PermGen</code> ，为此我们不得不对虚拟机做调优。</p><ol><li>由于 <code>PermGen</code> 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 <code>JVM</code> 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM</li><li>移除 <code>PermGen</code> 可以促进 <code>HotSpot JVM</code> 与 <code>JRockit VM</code> 的融合，因为 <code>JRockit</code> 没有永久代。</li></ol><p>根据上面的各种原因，<code>PermGen</code> 最终被移除，方法区移至 <code>Metaspace</code>，字符串常量移至 <code>Java Heap</code>。<code>Metaspace</code>并不在虚拟机中，而是使用本地内存,十分方便管理，不会出现永久带内存溢出问题，垃圾回收的时候这个单独区域方便处理。</p><h2>三、运行时常量池</h2><blockquote><p>是方法区的一部分。</p></blockquote><blockquote><p>类文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法的运行时常量池中存放。</p></blockquote><blockquote><p>这里尤其值得注意的是字符串的创建，会被扔到字符串常量池中。如果是new，那么还是在堆重创建的。当然，运行时也可以产生新的常量放入池中，比如讲new出来的字符串用<code>intern()</code>方法便可以在运行时将其放到常量池中。</p></blockquote><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str3.intern()); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><blockquote><p>对于直接声明的内容相同的字符串，对于str2来说是不需要重新分配地址的，因为str1的hello这个常量已经存在于常量池中了。所以他们两个其实是一个东西。</p></blockquote><blockquote><p>对于new出来的str3，是不会直接扔到常量池中的，他是在堆中分配，地址不一样，所以显然是false。</p></blockquote><blockquote><p>String类的<code>intern()</code>方法，使得运行时将堆中产生的对象放入常量池中，所以是true。</p></blockquote><p>这里我在<a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" target="_blank" rel="noopener">java字符串核心一网打尽</a>中已经详细说明了，不再赘述。</p><h2>四、对象探秘</h2><h5>4.1 对象的创建过程</h5><ul><li><p>类加载检查：检查该对象的类是否已经被加载、解析、初始化过，如果没有则先进行类加载操作。</p></li><li><p>分配内存：如果内存规整使用“指针碰撞”分配，否则一般使用“空闲列表”分配，具体看垃圾回收器是否带有整理（<code>Compact</code>）空闲内存功能。</p></li><li><p>初始化：将内存区初始化置零，不包含对象头，这一步保证了对象的实例字段在java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p>对象头设置：这个对象是哪个类的实例、如何找到类的元数据信息、哈希码、GC分代年龄信息等即为对象头</p></li><li><p>对象的方法：即按照程序员的意愿进行初始化</p></li></ul><h5>4.2 对象的内存布局</h5><ul><li>对象头</li></ul><p><strong>一部分称为<code>Mark Word</code>，存储对象自身运行时的数据</strong>，包含哈希码、GC分代年龄、锁状态标志等等。</p><p>采用压缩存储，压缩到虚拟机位数（32位/64位）。由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计为一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。</p><p><strong>另一部分为类型指针，指向它的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例</strong>。并不是所有虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。</p><p>如果对象是一个java数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通java对象的元数据信息确定java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p><ul><li><p>实例数据</p><ul><li>实例数据部分是对象真正存储的有效信息，也是在程序中定义的各种类型的字段内容。</li><li>无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li><li>从分配策略中可以看出，相同宽度的字段总是分配在一起，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</li></ul></li><li><p>对齐填充</p><ul><li>非必需，只有前两者加起来非8的倍数时才会有。</li><li>因为<code>HotSpot VM</code> 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍。不对齐的时候，需要通过它来填充对齐。</li></ul></li></ul><h2>九、对象的访问定位</h2><ul><li>通过句柄访问</li></ul><p><img src="http://bloghello.oursnail.cn/jvm5-5.png" alt="image"></p><p>通过句柄访问对象：当java虚拟机GC移动堆对象时，并不需要修改<code>reference</code>，只需修改句柄对象的实例数据指针。</p><ul><li>通过直接指针访问</li></ul><p><img src="http://bloghello.oursnail.cn/jvm5-6.png" alt="image"></p><p>通过直接指针访问对象：加快了对象访问速度，比间接访问少一次对象实例数据的访问，<code>HotSpot</code>则采用的这种访问方式。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA内存模型-线程私有</title>
      <link href="/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
      <url>/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第五篇文章，JVM的内存模型一般是面试必问的点，因为对JVM内存模型有所了解，才会有可能知道调优手段。本篇文章首先介绍线程私有的一些区域。</p><a id="more"></a><h2>一、从整体看JVM运行时内存模型</h2><p><img src="http://bloghello.oursnail.cn/jvm5-1.png" alt="image"></p><p>下面详细说说各个部分的作用。</p><h2>二、内存模型–程序计数器</h2><ul><li><p><strong>占用内存小</strong>：是一块较小的内存空间，当前线程所执行的字节码的行号指示器。</p></li><li><p><strong>PC作用</strong>：字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></li><li><p><strong>线程独立</strong>：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们成这类内存区域为“线程私有”的内存。</p></li><li><p><strong>native方法</strong>：如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空(undefined).</p></li><li><p><strong>无内存溢出异常</strong>：此内存区域是唯一一个在java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p></li></ul><h2>三、内存模型–JAVA虚拟机栈</h2><p><img src="http://bloghello.oursnail.cn/jvm5-2.png" alt="image"></p><ul><li><p>线程私有，生命周期与线程相同。</p></li><li><p>虚拟机栈描述的是Java方法的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p></li></ul><h2>四、栈帧</h2><p><img src="http://bloghello.oursnail.cn/jvm5-3.png" alt="image"></p><ul><li><p>我们口中常常提到的栈与堆，其中栈就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p></li><li><p>局部变量表存放了编译期可知的各种基本数据类型(<code>boolean</code>,<code>byte</code>,<code>char</code>,<code>short</code>,<code>int</code>,<code>float</code>,<code>long</code>,<code>double</code>),对象引用(它不等同于对象本身，可能是一个指向对象地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)、<code>returnAddress</code>类型(指向了一条字节码指令的地址)</p></li><li><p>其中64位长度的<code>long</code>和<code>double</code>类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p></li><li><p>局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p></li><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，比如递归层数过多，将抛出<code>StackOverflowError</code>异常；如果虚拟机可以动态扩展，即虚拟机栈申请过多，扩展时却无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>异常。</p></li></ul><h2>五、内存模型–本地方法栈</h2><ul><li><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈尾虚拟机执行java方法(也就是字节码)服务，而本地方法栈则为虚拟机用到的Native方法服务。</p></li><li><p><code>Sun HotSpot</code>虚拟机直接将本地方法栈和虚拟机栈合二为一。</p></li><li><p>与虚拟机栈一样会抛出<code>StackOverflowError</code>异常或者<code>OutOfMemoryError</code>异常。</p></li></ul><p><strong>什么是native方法？</strong></p><p>简单地讲，一个<code>Native Method</code>就是一个java调用非java代码的接口。一个<code>Native Method</code>是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在<code>C＋＋</code>中，你可以用<code>extern “C”</code>告知<code>C＋＋</code>编译器去调用一个C的函数。</p><p>下一篇来看看线程共享的区域。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>细谈loadClass</title>
      <link href="/2019/02/05/JVM/%E7%BB%86%E8%B0%88loadClass/"/>
      <url>/2019/02/05/JVM/%E7%BB%86%E8%B0%88loadClass/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第四篇文章，对于获取Class对象，其实我们不知不觉中已经接触过两种了，一种就是loadClass，一种就是<a href="http://fourcolor.oursnail.cn/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/" target="_blank" rel="noopener">反射</a>中的forName，它们到底有什么区别呢？其实涉及了类加载过程的区别。下面好好来探讨一下。</p><a id="more"></a><h2>一、问题的提出</h2><p>对于之前的 测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\swg\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"Robot"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家有没有疑惑，我们这里是用了<code>loadClass(name)</code>来加载对应的<code>Class</code>对象的，最后还需要进行<code>newInstance()</code>。那么为什么要调用<code>newInstance()</code>才行呢？</p><h5>1.1 new的方式构建对象实例</h5><p>下面要进行相应的测试。对于<code>Robot.java</code>:</p><p><img src="http://bloghello.oursnail.cn/jvm4-1.png" alt="image"></p><p>首先用<code>new</code>的方式：</p><p><img src="http://bloghello.oursnail.cn/jvm4-2.png" alt="image"></p><p>显示结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><h5>1.2 loadClass来获取Class对象</h5><p><img src="http://bloghello.oursnail.cn/jvm4-3.png" alt="image"></p><p>如果仅仅这样写，显示结果仅仅为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>也就是说，并不会触发<code>static</code>静态块的执行，也就是说这个类根本就没有初始化。</p><h5>1.3 forName来获取Class对象</h5><p><img src="http://bloghello.oursnail.cn/jvm4-4.png" alt="image"></p><p>显示结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><p>触发了静态块的执行。</p><h2>二、类加载过程</h2><p>要想说明上面区别产生的原因，这里必须要介绍一个从未使用过的类加载的过程。</p><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（<code>Loading</code>）、验证（<code>Verification</code>）、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>Using</code>)和卸载(<code>Unloading</code>)7个阶段。其中准备、验证、解析3个部分统称为连接（<code>Linking</code>）。如图所示：</p><p><img src="http://bloghello.oursnail.cn/jvm4-5.png" alt="image"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p><h5>2.1 加载</h5><p><strong>在加载阶段</strong>（可以参考<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法），虚拟机需要完成以下3件事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个<code>Class</code>文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口；</li></ul><p>加载阶段和连接阶段（<code>Linking</code>）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h5>2.2 验证</h5><p>验证是连接阶段的第一步，这一阶段的目的是为了确保<code>Class</code>文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>验证阶段大致会完成4个阶段的检验动作</strong>：</p><blockquote><p>文件格式验证：验证字节流是否符合<code>Class</code>文件格式的规范；例如：是否以魔术<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p></blockquote><blockquote><p>元数据验证：对字节码描述的信息进行语义分析（注意：对比<code>javac</code>编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了<code>java.lang.Object</code>之外。</p></blockquote><blockquote><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p></blockquote><blockquote><p>符号引用验证：确保解析动作能正确执行。</p></blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h5>2.3 准备</h5><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被<code>static</code>修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那变量<code>value</code>在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把<code>value</code>赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器()方法之中，所以把<code>value</code>赋值为123的动作将在初始化阶段才会执行。</p><p><strong>至于“特殊情况”是指</strong>：<code>public static final int value=123</code>，即当类字段的字段属性是<code>ConstantValue</code>时，会在准备阶段初始化为指定的值，所以标注为<code>final</code>之后，<code>value</code>的值在准备阶段初始化为123而非0.</p><h5>2.4 解析</h5><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><p>对于这里说的：将符号引用替换为直接引用。很多人包括我第一次看到的时候感觉莫名其妙，教材上也是直接用这些专用名词，给我们的学习带来了极大的困扰。这里还是要解释一下。</p><p>比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>s</code>是符号引用，而<code>abc</code>是字面量。</p><p>此时，知道了什么是符号引用就好办了，因为符号引用一般都是放在栈中的，这个玩意肯定是依赖于实际的东西，相当于一个指针，多以我们程序需要将其解析成这个实际东西所在的真正的地址。所以，一旦解析了，那么内存中必然实际存在了这个对象，即拥有实际的物理地址了。</p><h5>2.5 初始化</h5><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程.</p><h2>三、new、loadClass、forName</h2><p>正常情况下，我们一般构建对象实例是通过<code>new</code>的方式，<code>new</code>是隐式构建对象实例，不需要<code>newInstance()</code>，并且可以用带参数的构造器来生成对象实例；</p><p>对于<code>new</code>，我们有点基础的，是知道，已经一直来到了最后初始化完成的这一步，生成了可以直接使用的对象实例。由于篇幅不宜太长，不想展开讲new的过程发生了什么，这里先贴个我觉得讲的不错的链接：<a href="https://www.jianshu.com/p/ebaa1a03c594" target="_blank" rel="noopener">https://www.jianshu.com/p/ebaa1a03c594</a></p><p>然而<code>loadClass(name)</code>这种显示调用的方式，我们可以看到，只有加载的功能，而没有后续连接以及初始化的过程。</p><p>所以<code>loadClass(name)</code>需要进行<code>newInstance()</code>才能生成对应的对象实例，并且这个<code>newInstance()</code>方法不支持参数调用，要想实现输入参数生成实例对象，需要通过反射获取构造器对象传入参数再生成对象实例。</p><p>这里也就解释了为什么要<code>newInstance()</code>，因为不这样，<code>loadClass(name)</code>只是加载，并没有后续过程，也就是说这个类根本就没有动它，仅仅是加载进来而已。从代码层面调用<code>loadClass()</code>的时候，我们可以看到一个之前故意忽视的东西：</p><p><img src="http://bloghello.oursnail.cn/jvm4-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/jvm4-7.png" alt="image"></p><p>这个<code>resolve</code>默认是传入<code>false</code>的，那么进来看看这个<code>resolveClass()</code>方法：</p><p><img src="http://bloghello.oursnail.cn/jvm4-8.png" alt="image"></p><p>再下去是<code>native</code>方法，不必关心，我们只看方法的注释即可，写的是链接指定的类，就是上面的连接过程。我们由上面知道，如果这个方法能执行，那么就会触发验证、准备、解析这三个过程，而准备阶段是会去执行静态方法或静态块，类变量会被进行初始化，即分配内存，但是仅仅赋初值即可。</p><p>所以，<code>loadClass(name)</code>有一种懒加载的思想在里面，要用了再去进行初始化，而不是一开始就初始化好。</p><p>既然已经知道了<code>new</code>和<code>loadClass</code>的区别了，下面再来看看<code>Class.forName()</code>,聪明的读者估计已经可以猜到了，没错，根据实验的结果来看，它至少要进行到连接完，实质它也完成了初始化，即已经到达第三步：</p><p><img src="http://bloghello.oursnail.cn/jvm4-9.png" alt="image"></p><p>总结一下：<code>loadClass</code>仅仅是第一步的加载，而<code>forName</code>和<code>new</code>都是已经初始化好了。</p><h2>存在的原因</h2><p>所谓存在即合理，<code>forName</code>的用法，最常见的莫过于用于加载数据库驱动这，我们这里实验一下，首先引入相关的依赖：</p><p><img src="http://bloghello.oursnail.cn/jvm4-10.png" alt="image"></p><p>经典写法来啦：</p><p><img src="http://bloghello.oursnail.cn/jvm4-11.png" alt="image"></p><p>点进去看看：</p><p><img src="http://bloghello.oursnail.cn/jvm4-12.png" alt="image"></p><p>我们这个时候发现，里面是一个<code>static</code>方法，也就是说，我们要立即创建驱动。所以这个时候必须用<code>forname</code>方法啦！</p><p>那么对于<code>loadClass</code>，其实上面已经提及了，就是懒加载，这个思想再<code>spring</code>中是到处可见的，<code>bean</code>只是加载，但是步进行初始化，等用的时候再去初始化，提高性能。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双亲委派模型</title>
      <link href="/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第三篇文章，谈到JVM类加载机制，双亲委派模型是绕不开的话题，名字看好像是个高大上、深不可测的玩意，其实逐步揭开面纱之后很简单。下面我们就来揭揭看。</p><a id="more"></a><h2>回顾类加载器</h2><p>上一节简单说明了类加载器的作用，只说到一个核心功能是加载class文件。但是，绝对没有这么简单，神书《深入理解Java虚拟机》第二版对类加载器的说明：</p><blockquote><p>代码编译的结果从本地机器码转变成字节码，是存储格式的一小步，却是编程语言发展的一大步。</p><p>Java虚拟机把描述类的数据从Class文件加载进内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这动作的代码模块成为“类加载器”。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载他的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。这句话可以表达的更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这个两个类就必定不相等。</p></blockquote><p>对于上面进行一些说明：</p><p>注意，加载之后要将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）</p><p>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。这个<code>Class</code>对象并没有规定是在<code>Java</code>堆内存中，它比较特殊，虽为对象，但存放在方法区中。</p><p>这样，就可以使用这个类了。</p><p>还有，关于相等，只有在满足如下三个类“相等”判定条件，才能判定两个类相等。</p><ul><li>两个类来自同一个Class文件</li><li>两个类是由同一个虚拟机加载</li><li>两个类是由同一个类加载器加载</li></ul><h2>什么是双亲委派模型</h2><p>我们上一节已经知道了有四种类加载器，它们的实际关系为：</p><p><img src="http://bloghello.oursnail.cn/jvm3-1.png" alt="image"></p><p>从这个图来看，是一个继承的关系，是这样吗？我们用代码来看看是不是真的是这样。</p><p>代码还是用上一篇文章自定义类加载器来测试：</p><p><img src="http://bloghello.oursnail.cn/jvm3-3.png" alt="image"></p><p>结果是：</p><p><img src="http://bloghello.oursnail.cn/jvm3-4.png" alt="image"></p><p>从这个结果就很容易看出，层级关系是与上图所述的一样。那么，这个层级关系其实就是我们下面要说的双亲委派模型的结构。</p><p>这里还想补充一点：就是为什么最后一个是null，即<code>bootstrap</code>为什么显示null，其实是因为它是用C++实现的，不是java语言实现的，所以与其他几个都有区别，这里根据就调用不到，所以显示null。如果非要看<code>bootstrap</code>里面大概如何实现的，需要去看看<code>opjdk</code>的代码。</p><p>结合代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//2.首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">//3.如果当前类加载器没有加载过，进来</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//4.看是否有父类加载器，有则进来</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//5.父类加载器看看是否已经加载过</span></span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//进到这个，是来看看bootstrap类加载器是否加载过，没有加载过则加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一开始是false</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，就是先一级一级往上查询是否已经加载过，加载过直接返回即可；一直查询到<code>bootstrap</code>类加载器，都没有加载过，那么就从<code>bootstrap</code>类加载器开始一级一级向下到他们的扫描范围内尝试加载这个class文件，知道自定义类加载(如果有的话)，没有则返回找不到。</p><p>说一下代码的实现思路。代码使用递归实现的，先一级一级找父亲，即一级一级向上入栈，某一个查到了就返回，每一层递归停留在<code>c = parent.loadClass(name, false);</code>；都查不到，再一级一级出栈去执行，那么就从<code>c = findBootstrapClassOrNull(name);</code>后面的代码继续执行，那么显然就是执行<code>if (c == null) {...}</code>尝试去加载。</p><h2>为什么要用双亲委派模型</h2><p>为什么需要双亲委派模型呢？假设没有双亲委派模型，试想一个场景：</p><blockquote><p>黑客自定义一个java.lang.String类，该String类具有系统的String类一样的功能，只<br>是在某个函数稍作修改。比如equals函数，这个函数经常使用，如果在这这个函数中，<br>黑客加入一些“病毒代码”。并且通过自定义类加载器加入到JVM中。此时，如果没有双亲<br>委派模型，那么JVM就可能误以为黑客自定义的java.lang.String类是系统的String类，<br>导致“病毒代码”被执行。</p></blockquote><p>而有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。</p><p>或许你会想，我在自定义的类加载器里面强制加载自定义的<code>java.lang.String</code>类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回<code>false</code>。</p><p>举个简单例子：</p><blockquote><p>ClassLoader1、ClassLoader2都加载java.lang.String类，对应Class1、Class2对象。<br>那么Class1对象不属于ClassLoad2对象加载的java.lang.String类型。</p></blockquote><p>委托机制的意义：防止内存中出现多份同样的字节码</p><p>比如两个类A和类B都要加载<code>System</code>类：</p><p>如果不用委托而是自己加载自己的，那么类A就会加载一份<code>System</code>字节码，然后类B又会加载一份<code>System</code>字节码，这样内存中就出现了两份<code>System</code>字节码。</p><p>如果使用委托机制，会递归的向父类查找，也就是首选用<code>Bootstrap</code>尝试加载，如果找不到再向下。这里的<code>System</code>就能在<code>Bootstrap</code>中找到然后加载，如果此时类B也要加载<code>System</code>，也从<code>Bootstrap</code>开始，此时<code>Bootstrap</code>发现已经加载过了<code>System</code>那么直接返回内存中的<code>System</code>即可而不需要重新加载，这样内存中就只有一份<code>System</code>的字节码了。</p><h2>一个面试题</h2><p>能不能自己写个类叫<code>java.lang.System</code>？</p><p>显然是不可以的，可能方案是自己搞一个这个类放在特殊目录，用自定义类加载器去加载，然而系统自身的类加载器会先去加载使用，下次再用的时候，是先逐级向上查询是否已经加载过，根本没有机会让自定义类加载器去加载。</p><p>所以，如果非要用，那么必定是要破坏双亲委派模型了，那么又回到为什么要用双亲委派模型的问题上了，所以，为了自己写一个<code>java.lang.System</code>而破坏双亲委派模型，我只能说，脑子秀逗了。所以不要搞这些东西，包名或类名写的不一样即可。</p><h2>一个问题</h2><p>那么为什么不能用一个加载器去一个目录加载所有呢？还要分这么多的类加载器，不是麻烦么？</p><p>其实，这个问题也是比较可笑的，毕竟每个层级的功能是不一样的，比如<code>bootstrap</code>是加载最核心的文件，没有它，都玩不起来。而自定义的呢？是比较特殊的需求，需要的时候才用到。对于这种有个性化的要求，一套代码来实现，显然是不合理的。</p><p>比如这个回答是根据加载的方式来思考的：</p><blockquote><p>每一个类加载器都是为了去在不同的情景下去加载类。比如，你可以从联网服务器上加载一个class文件，也可以从远程web服务器下载二进制类。这么设计是因为我们需要类加载器提供一致的接口，这样客户端就可以加载类但是却不用管类加载器到底是怎么实现的。启动类加载器能够加载JVM_HOME/lib 下的类，但如果我们需要在其他的情况下加载类呢？简单来说，加载类的方法有无数种，我们需要一个灵活的加载器系统去在特定的情况下按照我们的想法来加载类。</p></blockquote><p>还有一个回答是说更方便地对特定类进行优化：</p><blockquote><p>虽然 对java 虚拟机没有研究过，java 为什么不能 一个加载器 加载全部的类<br>很明显， 实现起来也可以<br>但是需要 的 代码 更多，也更难 为各种类进行 优化，为了更简单的抽象<br>我在明确知道 该类是启动类的情况下，我就会 为该类 进行优化。<br>如果是自定义类，可能就 不会进行 此类优化。<br>在明确 目的的情况下， 专用代码 比 通用代码 更简单，也更有效。</p></blockquote><p>总之，就是为了清晰和方便，这也是我们在进行软件设计的时候最基本的要求，即不能写死代码，影响扩展性；层次结构也不能写的太乱，影响后续的优化。</p><p>至此，双亲委派模型就讲完了。我们也清晰地知道了其设计思想和好处。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈ClassLoader</title>
      <link href="/2019/02/05/JVM/%E6%B5%85%E8%B0%88ClassLoader/"/>
      <url>/2019/02/05/JVM/%E6%B5%85%E8%B0%88ClassLoader/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第二篇文章，上一篇文章初步提到了class文件，以及一个最简单程序执行的指令含义，我们提到，是由JAVA虚拟机先加载这些编译好的class文件，然后再去根据解析出来的指令去转换为具体平台上的机器指令执行，但是加载这个class文件时如何加载的呢？其实就涉及比较重要的东西：ClassLoader</p><a id="more"></a><p>有一个基本认识，从编译到实例化对象的过程可以概括为以下三个阶段：</p><ul><li>编译器将<code>xxx.java</code>源文件编译为<code>xxx.class</code>字节码文件</li><li><code>ClassLoader</code>将字节码转换为JVM种的<code>Class&lt;xxx&gt;</code>对象</li><li>JVM利用<code>Class&lt;xxx&gt;</code>对象实例化为<code>xxx</code>对象</li></ul><h2>一、JVM系统结构</h2><p><img src="http://bloghello.oursnail.cn/jvm2-1.png" alt="image"></p><ul><li><code>ClassLoader</code>：依据特定格式，加载class文件到内存</li><li><code>Execution Engine</code>：对命令进行解析</li><li><code>Native Interface</code>：融合不同开发语言的原生库为Java所用</li><li><code>Runtime Data Area</code>：JVM内存空间结构模型</li></ul><p>首先通过<code>ClassLoader</code>加载符合条件的字节码文件到内存中，然后通过<code>Execution Engine</code>解析字节码指令，交由操作系统去执行。</p><h2>二、什么是ClassLoader</h2><p><code>ClassLoader</code>在java中有着非常重要的作用，它主要工作在<code>Class</code>装载的加载阶段，其主要作用是从系统外部获得<code>Class</code>二进制数据流。他是JAVA的核心组件，所有的<code>Class</code>都是由<code>ClassLoader</code>进行加载的，<code>ClassLoader</code>负责通过将<code>Class</code>文件里的二进制数据流装载进系统，然后交给JAVA虚拟机进行连接、初始化等操作。</p><p>简而言之，就是加载字节码文件。</p><p>我们翻开<code>ClassLoader</code>源码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>它是一个抽象类，下面我们再来说具体的实现类。</p><p>里面比较重要的是<code>loadClass()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是根据<code>name</code>来加载字节码文件，返回<code>Class</code>实例，加载不到则抛出<code>ClassNotFoundException</code>异常。</p><h2>三、ClassLoader的种类</h2><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：由<code>C++</code>语言实现（针对<code>HotSpot</code>）,加载核心库<code>java.*</code>。</li></ul><ul><li>扩展类加载器（<code>Extension ClassLoader</code>）：Java编写，加载扩展库<code>javax.*</code></li></ul><p>它扫描的是哪个路径呢？</p><p><img src="http://bloghello.oursnail.cn/jvm2-2.png" alt="image"></p><p>我们看到，它负责将 <code>&lt;JAVA_HOME &gt;/lib/ext</code>或者由系统变量<code>-Djava.ext.dir</code>指定位置中的类库 加载到内存中。</p><ul><li>应用程序类加载器（<code>Application ClassLoader</code>）：Java编写，加载程序所在目录</li></ul><p><img src="http://bloghello.oursnail.cn/jvm2-3.png" alt="image"></p><p>它负责将 用户类路径(<code>java -classpath</code>或<code>-Djava.class.path</code>变量所指的目录，即当前类所在路径及其引用的第三方类库的路径，看截图的最后一行，显示的是当前项目路径。</p><ul><li>自定义<code>ClassLoader</code>：自定义</li></ul><h2>四、如何自定义ClassLoader</h2><p>要自己实现一个<code>ClassLoader</code>，其核心涉及两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="keyword">null</span>, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先想一下为什么是这两个类？</p><p>其实答案在<code>loadClass()</code>这个方法里面。如果已经熟悉双亲委派模型的同学，都会知道加载<code>Class</code>对象是先委派给父亲，看父亲是否已经加载，如果没有加载过，则从最顶层父亲开始逐层往下进行加载，这一块详细在下一篇文章中解释，我们先走马观花看看这个的核心方法长啥样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先看看当前类加载器是否已经加载过，没有则委派给父亲查询</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//注意，这里是各递归函数，如果由下至上查询都没有加载过，则从上至下尝试去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果所有类加载器都没有加载过，则开始尝试从上而下逐级去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">//去加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不去重写<code>findClass(name)</code>方法，默认是直接抛出找不到的异常，所以我们要对这个方法进行重写。</p><p>由于字节码文件是一堆二进制流，所以需要一个方法来根据这个二进制流来定义成一个类，即<code>defineClass()</code>这个方法来实现这个功能。</p><p>说的比较抽象，下面来真正实践一把！</p><h2>五、实践自定义ClassLoader</h2><p>首先写一个类：Robot.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello , i am a robot!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对<code>Robot.java</code>用<code>javac</code>编译之后形成<code>Robot.class</code>文件，就要删除本项目下的这个<code>Robot.java</code>文件，要不然就会被<code>AppClassLoader</code>类加载先加载了，而无法再被我们的自定义类加载器再去加载。这个<code>Robot.class</code>文件我就直接放到桌面去了。路径为<code>C:/Users/swg/Desktop/</code>.</p><p>然后定义一个自定义的<code>ClassLoader</code>，按照上面的理论，只要重写<code>findClass</code>就可以指定到某个地方获取class字节码文件，此时获取的是二进制流文件，转换为字节数组，最后借用<code>defineClass</code>获取真正的<code>Class</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行加载的class文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">//自定义类加载器的名字</span></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    MyClassLoader(String path,String classLoaderName)&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于寻找类文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于加载类文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        name = path + name + <span class="string">".class"</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            in  = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">            out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试一下能不能用自定义类加载器去加载到<code>Robot</code>对应的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\swg\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = myClassLoader.loadClass(<span class="string">"Robot"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader@677327b6</span><br><span class="line">hello , i am a robot!</span><br></pre></td></tr></table></figure><p>好了，学习了关于<code>ClassLoader</code>的分类以及如何自定义<code>ClassLoader</code>，我们知道了类加载器的基本实现，上面谈到了一个重要方法是<code>loadClass</code>，这就涉及了类加载器的双亲委派模型。下一节从代码层面好好来说说这个，其实很简单。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019年展望</title>
      <link href="/2019/02/05/suibi/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/"/>
      <url>/2019/02/05/suibi/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/</url>
      <content type="html"><![CDATA[<p>今天是大年初一，算是真正步入2019年了。保存几张老家门口拍的照片，以作纪念。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/suibi1-2.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/suibi1-3.jpg" alt="image"></p><p>老家越来越冷清，越来越萧条。</p><p>今年四月底顺利毕业的话，就真的工作了，在南京，本科+研究生读了七年书，加上小时候每年暑假都来南京玩，对南京的熟悉的程度远远大于家乡盐城。</p><p>所以希望可以努力，在南京能扎下根，然后一家人全搬过去。</p><p>在找工作方面，不想过多地提及了，我相信只要一直努力，就一定会有好的结果。</p><p>在2018年，算是学习java的进阶之年，自己学习了很多新的技术，也好好地夯实了基础，把以前很多模糊的问题搞清楚了，确实，基础真的太重要的，光学时髦的框架，可以写写简单的CRUD应用，是远远不够的，我觉得程序员的目标是可以造出大家都认可并且乐于使用的开源作品，没有好的基础，便是天方夜谭，也只能永远做一个普通的码农。</p><p>所以，我给自己定一个三年的目标，三年以后，无论是搞java还是搞大数据还是其他，我希望能达到中高级水平，在这个行业方向上有较好的基础和较深的认识。为后续更高的发展打下坚实的基础。</p><p>我希望，github真正能成为我出发的地方，并且能够走很远。犹记得，14年在大神室友的推荐下，注册了github，但是真正使用还是从去年开始吧。所以甚是惭愧，如果早一点上路，虽然追赶不上大神的脚步（已经进了google），但是进个二线比如京东、美团等都是轻而易举吧，但是谈这些确实是废话，没有人有假如。</p><p>除了对未来三年的一些初步想法之外，我还是希望我与家人都有一个健健康康的身体，所以工作以后身体的锻炼是必不可少的，八块腹肌是不指望了，至少爬几层楼不用喘吧。</p><p>一切还是视实际情况而定，但是终身学习的信念要埋藏在心里，这个时代以及未来的时代，选择了这一行，掉头发是注定的了，但是如果仅仅以掉头发的代价，可以让家人舒舒服服，健健康康，开开心心的话，那给我剃个光头也无妨了。</p><p>废话不多说了，我要继续完成本笔记的JVM部分了，不忘初心，套用喜剧之王的台词：努力，奋斗！</p><p><img src="http://bloghello.oursnail.cn/suibi1-4.jpg" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>彻底理解java反射机制</title>
      <link href="/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<p>反射机制这一块也是面试经常会被问到的，我从反射的基本概念到反射的一些面试题出发，好好理一理反射的知识。</p><a id="more"></a><h2>1. 什么是反射</h2><p>标准定义：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用方法的功能成为反射机制。</p><p>注意几个关键字：运行状态中，动态获取。</p><h2>2. Class对象和实例对象</h2><p>想要理解反射首先需要知道<code>Class</code>这个类，它的全称是<code>java.lang.Class</code>类。java是面向对象的语言，讲究万物皆对象，即使强大到一个类，它依然是另一个类（<code>Class</code>类）的对象，换句话说，普通类是<code>Class</code>类的对象，即<code>Class</code>是所有类的类（<code>There is a class named Class</code>）。</p><p>我们知道java世界是运行在JVM之上的，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的<code>.class</code>文件，这个就是JVM可以加载执行的字节码。</p><p>运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(<code>class loader</code>)的<code>defineClass()</code>被JVM调用，便会为这个类产生一个<code>Class</code>对象（一个<code>Class</code>类的实例），用来表达这个类，该类的所有实例都共同拥有着这个<code>Class</code>对象，而且是唯一的。</p><p>也就是说，加载<code>.class</code>文件之后会生成一个对应的<code>Class</code>对象。下面说说如何获取这个<code>Class</code>对象。</p><h2>3. 取得Class对象的三种方式</h2><p>我们假设有这么一个类叫<code>MyClass</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li>第一种方式：通过“类名.class”的方式取得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class classInstance= MyClass.class;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Car.class;</span><br><span class="line">Class cls1 = int.class;</span><br><span class="line">Class cls2 = String.class;</span><br></pre></td></tr></table></figure><ul><li>第二种方式：通过类创建的实例对象的<code>getClass</code>方法取得</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">Class classInstance = myClass.getClass();</span><br></pre></td></tr></table></figure><ul><li>第三种方式：通过<code>Class</code>类的静态方法<code>forName</code>方法取得（参数是带包名的完整的类名）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Class classInstance = Class.forName(<span class="string">"mypackage.MyClass"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种方法取得的对象都是相同的，所以效果上等价。</p><p><code>classInstance</code>是类类型，通过类类型可以得到一个类的属性和方法等参数，这是反射的基础。</p><h2>4. 利用反射API全面分析类的信息——方法，成员变量，构造器</h2><p>反射的一大作用是用于分析类的结构，或者说用于分析和这个类有关的所有信息。而这些信息就是类的基本的组成： 方法，成员变量和构造器。</p><p>在java种万物皆对象，一个类中的方法，成员变量和构造器也分别对应着一个对象</p><ol><li>每个方法都对应有一个保存和该方法有关信息的<strong>Method对象</strong>， 这个对象所属的类是<code>java.lang.reflect.Method</code>;</li><li>每个成员变量都对应有一个保存和该变量有关信息的<strong>Field对象</strong>，这个对象所属的类是 <code>java.lang.reflect.Field</code></li><li>每个构造器都对应有一个保存和该构造器有关信息的<strong>Constructor对象</strong>，这个对象所属的类是<code>java.lang.reflect.Constructor</code></li></ol><p>假设c是一个类的Class对象：</p><ul><li>通过 <code>c.getDeclaredMethods()</code>可取得这个类中所有声明方法对应的<code>Method</code>对象组成的数组</li><li>通过 <code>c.getDeclaredFields()</code>可取得这个类中所有声明的成员变量对应的<code>Field</code>对象组成的数组</li><li>通过 <code>c.getConstructors()</code>; 可取得这个类中所有构造函数所对应的<code>Constructor</code>对象所组成的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Method [] methods = c.getDeclaredMethods(); <span class="comment">// 获取方法对象列表</span></span><br><span class="line"> </span><br><span class="line">Field [] fields = c.getDeclaredFields();   <span class="comment">// 获取成员变量对象列表</span></span><br><span class="line"></span><br><span class="line">Constructor [] constructors = c.getConstructors();  <span class="comment">// 获取构造函数对象列表</span></span><br><span class="line"></span><br><span class="line">xxx.getName()就可以打印出对应的名字了。</span><br></pre></td></tr></table></figure><h2>5. 更多的反射api</h2><h5>getMethods和getDeclaredMethods方法</h5><ul><li><code>getMethods</code>取得的<code>method</code>对应的方法<strong>包括从父类中继承的那一部分</strong>，而</li><li><code>getDeclaredMethods</code>取得的<code>method</code>对应的方法<strong>不包括从父类中继承的那一部分</strong></li></ul><p>一个普通的类，他们的基类都是<code>Object</code>，那么如果用<code>getMethods</code>，遍历得到的结果，会发现<code>Object</code>中的基础方法名都会被打印出来。</p><p>诸如<code>wait()</code>,<code>equals()</code>,<code>toString()</code>,<code>getClass()</code>,<br><code>notify()</code>,<code>notifyAll()</code>,<code>hashCode()</code>等等。</p><h5>通过method.getReturnType()获取方法返回值对应的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class returnClass = method.getReturnType(); <span class="comment">// 获取方法返回值对应的Class对象</span></span><br><span class="line">String returnName = returnClass.getName();  <span class="comment">//获取返回值所属类的类名——也即返回值类型</span></span><br></pre></td></tr></table></figure><h5>通过method.getParameterTypes()获取方法各参数的Class对象组成的数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class [] paramsClasses = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class pc: paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName(); <span class="comment">// 获取当前参数类型</span></span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>获取成员变量类型对应的的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = c.getDeclaredField(<span class="string">"name"</span>);  <span class="comment">// 取得名称为name的field对象</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 这一步很重要！！！设置为true才能访问私有成员变量name的值！</span></span><br><span class="line">String nameValue = (String) field.get(obj); <span class="comment">// 获取obj中name成员变量的值</span></span><br></pre></td></tr></table></figure><h5>通过getType方法读取成员变量类型的Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = class1.getDeclaredField(number<span class="string">");</span></span><br><span class="line"><span class="string">System.out.print(field.getType().getName());</span></span><br></pre></td></tr></table></figure><p>因为java权限的原因，直接读取私有成员变量的值是非法的（加了<code>field.setAccessible(true)</code>后就可以了），但仍可以直接读取私有成员变量的类型</p><h5>利用反射API分析类中构造器信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> a, String str)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printContructorsMessage</span> <span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">Class c = obj.getClass();  <span class="comment">// 取得obj所属类对应的Class对象</span></span><br><span class="line">Constructor [] constructors = c.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">  Class [] paramsClasses =  constructor.getParameterTypes();</span><br><span class="line">  String paramsStr = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (Class pc : paramsClasses) &#123;</span><br><span class="line">    String paramStr = pc.getName();</span><br><span class="line">    paramsStr+=paramStr + <span class="string">"  "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"构造函数的所有参数的类型列表："</span> + paramsStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数的所有参数的类型列表：<span class="keyword">int</span>  java.lang.String</span><br></pre></td></tr></table></figure><h2>6. 利用反射动态加载类，并用该类创建实例对象</h2><p>我们用普通的方式使用一个类的时候，类是静态加载的<br>，<strong>而使用Class.forName(“XXX”)这种方式，则属于动态加载一个类</strong></p><p>静态加载的类在编译的时候就能确定该类是否存在，但动态加载一个类的时候却无法在编译阶段确定是否存在该类，而是在运行时候才能够确定是否有这个类，所以要捕捉可能发生的异常.</p><p>Class对象有一个<code>newInstance</code>方法，我们可以用它来创建实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class classInstance = Class.forName(<span class="string">"mypackage.MyClass"</span>);</span><br><span class="line">MyClass myClass = (MyClass) classInstance.newInstance();</span><br></pre></td></tr></table></figure><h2>7. 总结</h2><ul><li>反射为我们提供了全面的分析类信息的能力，例如类的方法，成员变量和构造器等的相关信息，反射能够让我们很方便的获取这些信息， 而实现这个获取过程的关键是取得类的<code>Class</code>对象，然后根据<code>Class</code>对象取得相应的<code>Method</code>对象，<code>Field</code>对象和<code>Constructor</code>对象，再分别根据各自的API取得信息。</li><li>反射还为我们提供动态加载类的能力</li><li>API中<code>getDeclaredXXX</code>和<code>getXXX</code>的区别在于前者只获取本类声明的XXX（如成员变量或方法），而不获取超类中继承的XXX， 后者都可以获取</li><li>API中， <code>getXXXs</code>（注意后面的s）返回的是一个数组， 而对应的 <code>getXXX</code>（“键”）按键获取一个值（这个时候因为可能报已检查异常所以要用try*catch语句包裹）</li><li>私有成员变量是不能直接获取到值的！因为java本身的保护机制，允许你取得私有成员变量的类型，但是不允许直接获取值，所以要对对应的<code>field</code>对象调用<code>field.setAccessible(true)</code> 放开权限</li></ul><h2>8. 面试</h2><h4>什么是反射</h4><p>反射是一种能够在程序运行时动态访问、修改某个类中任意属性（状态）和方法（行为）的机制</p><h4>反射到底有什么具体的用处</h4><ul><li>操作因访问权限限制的属性和方法；</li><li>实现自定义注解；</li><li>动态加载第三方jar包，解决android开发中方法数不能超过65536个的问题；</li><li>按需加载类，节省编译和初始化APK的时间；</li></ul><h4>反射的原理是什么</h4><p>当我们编写完一个Java项目之后，每个java文件都会被编译成一个.class文件，这些Class对象承载了这个类的所有信息，包括父类、接口、构造函数、方法、属性等，这些class文件在程序运行时会被ClassLoader加载到虚拟机中。当一个类被加载以后，Java虚拟机就会在内存中自动产生一个Class对象。我们通过new的形式创建对象实际上就是通过这些Class来创建，只是这个过程对于我们是透明的而已。</p><p>反射的工作原理就是借助<code>Class.java</code>、<code>Constructor.java</code>、<br><code>Method.java</code>、<code>Field.java</code>这四个类在程序运行时动态访问和修改任何类的行为和状态。</p><h4>如何获取Class对象</h4><ul><li><code>Class</code>的<code>forName()</code>方法的返回值就是<code>Class</code>类型，也就是动态导入类的<code>Class</code>对象的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure><ul><li>每个类都会有一个名称为<code>Class</code>的静态属性，通过它也是可以获取到<code>Class</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Student&gt; clazz = Student.class;</span><br></pre></td></tr></table></figure><ul><li><code>Object</code>类中有一个名为<code>getClass</code>的成员方法，它返回的是对象的运行时类的<code>Class</code>对象。因为<code>Object</code>类是所有类的父类，所以，所有的对象都可以使用该方法得到它运行时类的<code>Class</code>对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">Class&lt;Student&gt; clazz = stu.getClass();</span><br></pre></td></tr></table></figure><h4>反射的特点</h4><blockquote><p>优点</p></blockquote><ul><li>灵活、自由度高：不受类的访问权限限制，想对类做啥就做啥</li></ul><blockquote><p>缺点</p></blockquote><ul><li>性能问题</li></ul><p>通过反射访问、修改类的属性和方法时会远慢于直接操作，但性能问题的严重程度取决于在程序中是如何使用反射的。如果使用得很少，不是很频繁，性能将不会是什么问题；</p><ul><li>安全性问题</li></ul><p>反射可以随意访问和修改类的所有状态和行为，破坏了类的封装性，如果不熟悉被反射类的实现原理，随意修改可能导致潜在的逻辑问题；</p><h4>如何提高反射性能</h4><p>java应用反射的时候，性能往往是java程序员担心的地方，那么在大量运用反射的时候，性能的微弱提升，对这个系统而言都是如旱地逢甘霖。</p><ul><li><code>setAccessible(true)</code>,可以防止安全性检查（做这个很费时）</li><li>做缓存，把要经常访问的元数据信息放入内存中，<code>class.forName</code> 太耗时</li><li><code>getMethods()</code> 等方法尽量少用，尽量调用<code>getMethod(name)</code>指定方法的名称，减少遍历次数</li></ul><h4>java面试中面试官让你讲讲反射，应该从何讲起？</h4><p>先讲反射机制，反射就是程序运行期间JVM会对任意一个类洞悉它的属性和方法，对任意一个对象都能够访问它的属性和方法。依靠此机制，可以动态的创建一个类的对象和调用对象的方法。</p><p>其次就是反射相关的API，只讲一些常用的，比如获取一个<code>Class</code>对象。<code>Class.forName(完整类名)</code>。通过<code>Class</code>对象获取类的构造方法，<code>class.getConstructor</code>。根据<code>Class</code>对象获取类的方法，<code>getMethod</code>和<code>getMethods</code>。使用<code>Class</code>对象创建一个对象，<code>class.newInstance</code>等。</p><p>最后可以说一下反射的优点和缺点，优点就是增加灵活性，可以在运行时动态获取对象实例。缺点是反射的效率很低，而且会破坏封装，通过反射可以访问类的私有方法，不安全。</p>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java如何执行一个最简单的程序</title>
      <link href="/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>本篇为学习JAVA虚拟机的第一篇文章，需要之前对JVM有一定了解的基础。我们都知道，JAVA号称：一次编译多处运行。这就离不开字节码文件和虚拟机啦！那么，虚拟机到底是如何去执行一个简单的程序的呢？理解了这个，我们就可以理解java时如何做到平台无关的了。下面我们来分析分析。</p><a id="more"></a><p>首先，写一个最简单的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">5</span>;</span><br><span class="line">        i++;</span><br><span class="line">        ++j;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后的结果想必就一目了然，我们就通过这个程序来分析分析到底是怎么执行这个程序额的。</p><p>首先呢，java程序的执行经历编译，编译成系统能识别的文件，这里的系统对应java语言就是JVM，即JAVA虚拟机。JVM在识别之后，再去与我们真正的操作系统进行交互和处理。</p><p>所以，我们要执行一个.java程序，必须要先进行编译。初学者都会学习一个指令叫做<code>javac</code>：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-1.png" alt="image"></p><p>我们会发现路径下面就会多一个.class文件，这就是编译之后的文件。直接点开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> var1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> var2 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> var3 = var1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> var4 = var2 + <span class="number">1</span>;</span><br><span class="line">        System.out.println(var3);</span><br><span class="line">        System.out.println(var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看第一行注释，说的是编译后的文件已经自动被<code>IDEA</code>反编译了，所以我们还能看得懂。真正的文件是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">漱壕   4 </span><br><span class="line">    </span><br><span class="line">     &lt;init&gt; ()V Code LineNumberTable main ([Ljava/lang/String;)V </span><br><span class="line">SourceFile Main.java         Main java/lang/Object java/lang/System out Ljava/io/PrintStream; java/io/PrintStream println (I)V !                    *? ?             </span><br><span class="line">      E     &lt;=??? ? ? ? ?</span><br></pre></td></tr></table></figure><p>我们可以看到，其实是一堆乱码，根本看不懂。而在执行的时候，class文件是一种8位字节的二进制流文件。放在<code>sublime</code>中可以看到二进制文件（以16进制显示，在JAVA虚拟机中将来了解这各文件的含义，我们可以看到第一个单词是cafe babe，表明这是一个class字节码文件）：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-2.png" alt="image"></p><p>那么我们想看看.class中的信息，还是需要反编译，这个时候可以用<code>javap</code>指令来做。如果我们对其不熟悉，可以先执行<code>javap -help</code>来了解了解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>我们注意到，有一个<code>-c</code>是进行反汇编，那么就用它试试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;javap -c Main.class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Compiled from &quot;Main.java&quot;</span><br><span class="line">public class Main &#123;</span><br><span class="line">  public Main();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: istore_1</span><br><span class="line">       2: iconst_5</span><br><span class="line">       3: istore_2</span><br><span class="line">       4: iinc          1, 1</span><br><span class="line">       7: iinc          2, 1</span><br><span class="line">      10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      13: iload_1</span><br><span class="line">      14: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      17: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: iload_2</span><br><span class="line">      21: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      24: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这反汇编出来的东西是什么呢？这是一连串的指令，其实这些是加载class文件时真正执行的java虚拟机指令。</p><p>我们来看看它的含义吧！</p><p><img src="http://bloghello.oursnail.cn/javabasic6-3.png" alt="image"></p><p>仔细看看，其实发现并不神秘，一个函数的执行是一个入栈出栈的过程。ok，大体了解了字节码文件是什么以及里面的指令含义之后，我们对java如何执行它已经大体清楚了。下面执行一下：</p><p>那么如何运行呢？</p><p><img src="http://bloghello.oursnail.cn/javabasic6-4.png" alt="image"></p><p>其实这是废话，初学java其实是<code>java Main</code>运行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\JavaBasic\src&gt;java Main</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>这个时候，class文件可以移植到任何平台上去，比如直接上传到<code>linux</code>上，只要JDK或者JRE环境类似即可，就可以直接运行了，不需要编译，也不需要关心是什么系统。这就做到了一次编译到处运行。</p><p>下面总结一下：</p><p><img src="http://bloghello.oursnail.cn/javabasic6-5.png" alt="image"></p><p>Java源码首先被编译成字节码，再由不同平台的JVM进行解析，JAVA语言在不同平台上运行时不需要进行重新编译，JAVA虚拟机在执行字节码的时候，把字节码转换为具体平台上的机器指令，然后各种操作系统就可以正确识别了。这就是JAVA如何执行代码和平台无关性的原因。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Redis一些重要的面试点</title>
      <link href="/2019/02/02/redis/%E5%85%B3%E4%BA%8ERedis%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%82%B9/"/>
      <url>/2019/02/02/redis/%E5%85%B3%E4%BA%8ERedis%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>这里整理一些面试题目，很多已经在前面的文章中详细说明了，这里算是总结一下。也补充了一点新的知识。</p><a id="more"></a><h2>Redis有哪些数据结构？</h2><p>字符串 <code>String</code>、字典 <code>Hash</code> 、列表 <code>List</code> 、集合 <code>Set</code> 、有序集合 <code>SortedSet</code>。</p><p>如果你是Redis中高级用户，还需要加上下面几种数据结构<code>HyperLogLog</code>、<code>Geo</code>、<code>Pub/Sub</code>。</p><h2>String类型的底层数据结构</h2><p>Redis 是一个键值对数据库, 数据库的值可以是字符串、集合、列表等多种类型的对象， 而数据库的键则总是字符串对象。</p><p>对于那些包含字符串值的字符串对象来说， 每个字符串对象都包含一个 <code>sds</code> 值。</p><div class="tip">“包含字符串值的字符串对象”，这种说法初听上去可能会有点奇怪， 但是在 Redis 中， 一个字符串对象除了可以保存字符串值之外， 还可以保存 long 类型的值， 所以为了严谨起见， 这里需要强调一下： 当字符串对象保存的是字符串时， 它包含的才是 sds 值， 否则的话， 它就是一个 long 类型的值。</div><p>举个例子， 以下命令创建了一个新的数据库键值对， 这个键值对的键和值都是字符串对象， 它们都包含一个 <code>sds</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET book &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET book</span><br><span class="line">&quot;Mastering C++ in 21 days&quot;</span><br></pre></td></tr></table></figure><p>目前来说， 只要记住这个事实即可： 在 <code>Redis</code> 中， 客户端传入服务器的协议内容、 aof 缓存、 返回给客户端的回复， 等等， 这些重要的内容都是由 <code>sds</code> 类型来保存的。</p><p>在 C 语言中，字符串可以用一个 <code>\0</code> 结尾的 <code>char</code> 数组来表示。</p><p>比如说， <code>hello world</code> 在 C 语言中就可以表示为 <code>&quot;hello world\0&quot;</code> 。</p><p>这种简单的字符串表示，在大多数情况下都能满足要求，但是，它并不能高效地支持长度计算和追加（<code>append</code>）这两种操作：</p><ul><li>每次计算字符串长度（<code>strlen(s)</code>）的复杂度为 θ(N) 。</li><li>对字符串进行 N 次追加，必定需要对字符串进行 N 次内存重分配（<code>realloc</code>）。</li></ul><p>在 <code>Redis</code> 内部， 字符串的追加和长度计算很常见， 而 <code>APPEND</code> 和 <code>STRLEN</code> 更是这两种操作，在 <code>Redis</code> 命令中的直接映射， 这两个简单的操作不应该成为性能的瓶颈。</p><p>另外， <code>Redis</code> 除了处理字符串之外， 还需要处理单纯的字节数组， 以及服务器协议等内容， 所以为了方便起见， <code>Redis</code> 的字符串表示还应该是二进制安全的： 程序不应对字符串里面保存的数据做任何假设， 数据可以是以 \0 结尾的 C 字符串， 也可以是单纯的字节数组， 或者其他格式的数据。</p><p>考虑到这两个原因， <code>Redis</code> 使用 <code>sds</code> 类型替换了 C 语言的默认字符串表示： sds 既可高效地实现追加和长度计算， 同时是二进制安全的。</p><p>在前面的内容中， 我们一直将 <code>sds</code> 作为一种抽象数据结构来说明， 实际上， 它的实现由以下两部分组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 已占用长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 剩余可用长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，类型 <code>sds</code> 是 <code>char *</code> 的别名（alias），而结构 <code>sdshdr</code> 则保存了 <code>len</code> 、 <code>free</code> 和 <code>buf</code> 三个属性。</p><p>作为例子，以下是新创建的，同样保存 <code>hello world</code> 字符串的 <code>sdshdr</code> 结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    len = 11;</span><br><span class="line">    free = 0;</span><br><span class="line">    buf = &quot;hello world\0&quot;;  // buf 的实际长度为 len + 1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>len</code> 属性， <code>sdshdr</code> 可以实现复杂度为 θ(1) 的长度计算操作。</p><p>另一方面， 通过对 <code>buf</code> 分配一些额外的空间， 并使用 <code>free</code> 记录未使用空间的大小， <code>sdshdr</code> 可以让执行追加操作所需的内存重分配次数大大减少。</p><p>为了易于理解，我们用一个 <code>Redis</code> 执行实例作为例子，解释一下，当执行以下代码时， <code>Redis</code> 内部发生了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND msg <span class="string">" again!"</span></span><br><span class="line">(integer) <span class="number">18</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line"><span class="string">"hello world again!"</span></span><br></pre></td></tr></table></figure><p>首先， <code>SET</code> 命令创建并保存 <code>hello world</code> 到一个 <code>sdshdr</code> 中，这个 <code>sdshdr</code> 的值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    buf = <span class="string">"hello world\0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <code>APPEND</code> 命令时，相应的 <code>sdshdr</code> 被更新，字符串 &quot; again!&quot; 会被追加到原来的 “hello world” 之后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    len = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">free</span> = <span class="number">18</span>;</span><br><span class="line">    buf = <span class="string">"hello world again!\0                  "</span>;     <span class="comment">// 空白的地方为预分配空间，共 18 + 18 + 1 个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中， 保存 “hello world again!” 共需要 18 + 1 个字节， 但程序却为我们分配了 18 + 18 + 1 = 37 个字节 —— 这样一来， 如果将来再次对同一个 <code>sdshdr</code> 进行追加操作， 只要追加内容的长度不超过 <code>free</code> 属性的值， 那么就不需要对 <code>buf</code> 进行内存重分配。</p><div class="tip">这种分配策略会浪费内存吗？执行过 APPEND 命令的字符串会带有额外的预分配空间， 这些预分配空间不会被释放， 除非该字符串所对应的键被删除， 或者等到关闭 Redis 之后， 再次启动时重新载入的字符串对象将不会有预分配空间。<p>因为执行 APPEND 命令的字符串键数量通常并不多， 占用内存的体积通常也不大， 所以这一般并不算什么问题。</p><p>另一方面， 如果执行 APPEND 操作的键很多， 而字符串的体积又很大的话， 那可能就需要修改 Redis 服务器， 让它定时释放一些字符串键的预分配空间， 从而更有效地使用内存。</p></div><p>当然， <code>sds</code> 也对操作的正确实现提出了要求 —— 所有处理 <code>sdshdr</code> 的函数，都必须正确地更新 <code>len</code> 和 <code>free</code> 属性，否则就会造成 bug 。</p><p>更多参见：<a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/sds.html" target="_blank" rel="noopener">简单动态字符串</a></p><h2>从海量数据中查询某一固定前缀的key</h2><p>使用<code>keys</code>指令可以扫出指定模式的key列表。</p><p>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</p><p>这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<code>scan</code>指令，scan指令可以<strong>无阻塞</strong>的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><p>基于游标的迭代器，需要使用上一次游标延续之前的迭代过程。游标为0的时候代表开始或结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#模式</span><br><span class="line">scan cursor match pattern count</span><br><span class="line">#示例</span><br><span class="line">scan 0 match k* count 10</span><br></pre></td></tr></table></figure><h2>Redis做异步队列</h2><p>一般使用<code>list</code>结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当<code>lpop</code>没有消息的时候，要适当<code>sleep</code>一会再重试。</p><p>如果对方追问可不可以不用<code>sleep</code>呢？<code>list</code>还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p><p>如果对方追问能不能生产一次消费多次呢？使用<code>pub/sub</code>主题订阅者模式，可以实现1:N的消息队列。</p><p>如果对方追问<code>pub/sub</code>有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>rabbitmq</code>等。</p><p>如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用<code>sortedset</code>，拿时间戳作为<code>score</code>，消息内容作为<code>key</code>调用<code>zadd</code>来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理。</p><h2>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2>Redis如何做持久化的？</h2><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。</p><p>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><p>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h2>Redis的同步机制了解么？</h2><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h2>是否使用过Redis集群，集群的原理是什么？</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p><p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><p>整理自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32540678" target="_blank" rel="noopener">天下无难试之Redis面试题刁难大全</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种主流缓存框架介绍</title>
      <link href="/2019/02/02/redis/%E5%87%A0%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/02/02/redis/%E5%87%A0%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第十二篇文章。本文对Guava Cache,Memcache以及redis进行简单介绍和对比。</p><a id="more"></a><h2>缓存特征</h2><p>缓存都会涉及：命中率、最大元素、清空策略(<code>FIFO</code>,<code>LFU</code>,<code>LRU</code>,过期时间，随机)</p><h2>影响缓存命中率因素</h2><ul><li>业务场景和业务需求：适合读多写少的场景</li><li>缓存的设计(粒度和策略)：缓存粒度越小，命中率越高</li><li>缓存容量(经常用LRU)和基础设施(是否可扩展，避免缓存失效-一致性hash算法和几点冗余)</li></ul><h2>缓存分类</h2><ul><li>本地缓存：编程实现（成员变量、局部变量、静态变量）、Guava Cache</li><li>分布式缓存：Memcache，Redis</li></ul><p>本地缓存：各应用之间无法很好地共享，与应用本身耦合过紧；而分布式缓存，本身就是独立的应用，各独立应用之间共享缓存。</p><h2>Guava Cache</h2><p><img src="http://bloghello.oursnail.cn/GuavaCache.png" alt="image"></p><p>设计思想类似于jdk1.7中的<code>ConcurrentHashMap</code>，也是用多个<code>segments</code>的细粒度锁，在保证线程安全的同时，支持高并发场景的需求。</p><p>下面数据存储就是以键值对的形式存储，另外，需要处理缓存过期、动态加载等算法逻辑，所以需要一些额外的信息来实现这些操作。</p><p>主要实现的功能有：自动将节点加入到缓存结构中，当缓存的数据超过设置的最大值时，用LRU算法来移除。他具备根据节点上次被访问或者写入的时间来计算他的过期机制。</p><h2>memcache</h2><h5>memcache简单认识</h5><p><code>memcache</code>是一个高性能的分布式的内存对象缓存系统，它在内存里维护一个统一的巨大的<code>hash</code>表。能用来缓存各种格式的数据，包括图像、视频、文件以及数据库检索等结果.</p><p><code>memcache</code>是以守护程序方式运行于一个或多个服务器中，随时会接收客户的连接和操作。</p><p>存在<code>memcache</code>中的对象实际放置在内存中，这也是<code>memcache</code>如此高效的原因。</p><p>本身是不提供分布式的解决方案的。分布式是在客户端实现的，通过客户端的路由来处理达到分布式的目的。</p><p>应用服务器每次在存储某个<code>key</code>和<code>value</code>的时候，通过某种算法把<code>key</code>映射到某台服务器上。</p><h5>一致性hash算法</h5><p>客户端实现分布式：一致性<code>hash</code>算法，<a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">这个算法已经详细介绍过了</a>。</p><p><img src="http://bloghello.oursnail.cn/memcache%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="image"></p><h5>memcache一些特性</h5><blockquote><p><code>Memcached</code>单进程在32位系统中最大使用内存为2G，若在64位系统则没有限制,这是由于32位系统限制单进程最多可使用2G内存,要使用更多内存，可以分多个端口开启多个<code>Memcached</code>进程。</p></blockquote><p>32 位寻址空间只有 4GB 大小，于是 32 位应用程序进程最大只能用到 4GB 的内存。然而，除了应用程序本身要用内存，操作系统内核也需要使用。应用程序使用的内存空间分为用户空间和内核空间，每个 32 位程序的用户空间可独享前 2GB 空间（指针值为正数），而内核空间为所有进程共享 2GB 空间（指针值为负数）。所以，32 位应用程序实际能够访问的内存地址空间最多只有 2GB。</p><blockquote><p>最大30天的数据过期时间，设置为永久也会在这个时间过期。最长键长为250字节，大于该长度无法存储。最大同时连接数是200;</p></blockquote><blockquote><p><code>memcache</code>是一种无阻塞的<code>socket</code>通信方式服务，基于<code>libevent</code>库，犹豫无阻塞通信，对内存读写速度非常快。</p></blockquote><h5>不适用memcached的业务场景？</h5><blockquote><p>缓存对象的大小大于1MB</p></blockquote><blockquote><p>虚拟主机不让运行<code>memcached</code>服务</p></blockquote><blockquote><p>key的长度大于250字符</p></blockquote><blockquote><p>需要持久化</p></blockquote><h5>不能够遍历memcached中所有的item？</h5><p>这个操作的速度相对缓慢且阻塞其他的操作</p><h5>memcache如何分配内存？</h5><p>这张图片里面涉及了<code>slab_class</code>、<code>slab</code>、<code>page</code>、<code>chunk</code>四个概念，它们之间的关系是：</p><ul><li><code>MemCache</code>将内存空间分为一组<code>slab</code></li><li>每个<code>slab</code>下又有若干个<code>page</code>，每个<code>page</code>默认是1M，如果一个<code>slab</code>占用100M内存的话，那么这个slab下应该有100个page</li><li>每个page里面包含一组<code>chunk</code>，<code>chunk</code>是真正存放数据的地方，同一个<code>slab</code>里面的<code>chunk</code>的大小是固定的</li><li>有相同大小<code>chunk</code>的<code>slab</code>被组织在一起，称为<code>slab_class</code></li></ul><p><img src="http://bloghello.oursnail.cn/memcache%E5%8E%9F%E7%90%86.png" alt="image"></p><p><strong>那么是具体如何分配的呢？</strong></p><blockquote><p><code>MemCache</code>中的<code>value</code>过来存放的地方是由<code>value</code>的大小决定的，<code>value</code>总是会被存放到与<code>chunk</code>大小最接近的一个<code>slab</code>中，比如<code>slab[1]</code>的<code>chunk</code>大小为80字节、<code>slab[2]</code>的<code>chunk</code>大小为100字节、<code>slab[3]</code>的<code>chunk</code>大小为128字节（相邻<code>slab</code>内的<code>chunk</code>基本以1.25为比例进行增长，<code>MemCache</code>启动时可以用-f指定这个比例），那么过来一个88字节的<code>value</code>，这个<code>value</code>将被放到2号<code>slab</code>中。</p></blockquote><blockquote><p>放<code>slab</code>的时候，首先<code>slab</code>要申请内存，申请内存是以<code>page</code>为单位的，所以在放入第一个数据的时候，无论大小为多少，都会有1M大小的<code>page</code>被分配给该<code>slab</code>。申请到<code>page</code>后，<code>slab</code>会将这个<code>page</code>的内存按<code>chunk</code>的大小进行切分，这样就变成了一个<code>chunk</code>数组，最后从这个<code>chunk</code>数组中选择一个用于存储数据。</p></blockquote><blockquote><p>如果这个slab中没有<code>chunk</code>可以分配了怎么办，如果<code>MemCache</code>启动没有追加-M（禁止LRU，这种情况下内存不够会报<code>Out Of Memory</code>错误），那么<code>MemCache</code>会把这个<code>slab</code>中最近最少使用的<code>chunk</code>中的数据清理掉，然后放上最新的数据。</p></blockquote><blockquote><ol><li><code>MemCache</code>的内存分配<code>chunk</code>里面会有内存浪费，88字节的<code>value</code>分配在128字节（紧接着大的用）的<code>chunk</code>中，就损失了30字节，但是这也避免了管理内存碎片的问题</li></ol></blockquote><blockquote><ol start="2"><li><code>MemCache</code>的<code>LRU</code>算法不是针对全局的，是针对<code>slab</code>的</li></ol></blockquote><blockquote><ol start="3"><li>该可以理解为什么<code>MemCache</code>存放的<code>value</code>大小是限制的，因为一个新数据过来，<code>slab</code>会先以<code>page</code>为单位申请一块内存，申请的内存最多就只有1M，所以<code>value</code>大小自然不能大于1M了</li></ol></blockquote><h5>最后再总结一下memcache</h5><ul><li><code>MemCache</code>中可以保存的<code>item</code>数据量是没有限制的，只要内存足够</li><li><code>MemCache</code>单进程在32位机中最大使用内存为2G，64位机则没有限制</li><li><code>Key</code>最大为250个字节，超过该长度无法存储</li><li>单个<code>item</code>最大数据是1MB，超过1MB的数据不予存储</li><li><code>MemCache</code>服务端是不安全的，比如已知某个<code>MemCache</code>节点，可以直接<code>telnet</code>过去，并通过<code>flush_all</code>让已经存在的键值对立即失效</li><li>不能够遍历<code>MemCache</code>中所有的<code>item</code>，因为这个操作的速度相对缓慢且会阻塞其他的操作</li><li><code>MemCache</code>的高性能源自于两阶段哈希结构：第一阶段在客户端，通过<code>Hash</code>算法根据<code>Key</code>值算出一个节点；第二阶段在服务端，通过一个内部的<code>Hash</code>算法，查找真正的<code>item</code>并返回给客户端。从实现的角度看，<code>MemCache</code>是一个非阻塞的、基于事件的服务器程序</li><li><code>MemCache</code>设置添加某一个<code>Key</code>值的时候，传入<code>expire</code>为0表示这个<code>Key</code>值永久有效，这个<code>Key</code>值也会在30天之后失效</li></ul><h2>redis</h2><h5>redis特点</h5><ul><li>支持数据持久化，可以将内存中的数据保存到磁盘。</li><li>支持更多的数据结构</li><li>支持数据备份</li><li>性能极高，读可以达到11万次每秒；写达到8万1千次每秒</li><li>redis所有操作都是原子性，并且支持几个操作一起的原子性</li><li>支持发布-订阅功能</li></ul><h5>redis适用场景</h5><ul><li>取最新n个数据、排行榜</li><li>精准过期时间</li><li>计数器</li><li>唯一性检查</li><li>实时系统、垃圾系统、缓存等</li></ul><h2>redis VS memcache</h2><p>当提到<code>redis</code>就问<code>memcache</code>，当提到<code>memcache</code>就提到<code>redis</code>，说明这两者用的都十分广泛，<code>redis</code>号称“强化版<code>memcached</code>”，他们之间的区别到底是啥呢？</p><ul><li>基本命令</li></ul><blockquote><p><code>memcache</code>支持的命令很少，因为他只支持<code>String</code>的操作，通讯协议包括文本格式和二进制格式，用于满足简单网络客户端工具（如<code>telnet</code>）和对性能要求更高的客户端的不同需求；<code>redis</code>操作类似，只是数据结构更复杂以支持更多的特性，如发布订阅、消息队列等。<code>redis</code>的客户端-服务器通讯协议完全采用文本格式(Redis Cluster服务端节点之间通讯采用二进制格式)。</p></blockquote><ul><li>事务</li></ul><blockquote><p><code>redis</code>通过<code>multi</code> / <code>watch</code> / <code>exec</code>等命令可以支持事务的概念，原子性的执行一批命令;</p><p><code>memcache</code>:即使在多线程模式，所有的命令都是原子的；命令序列不是原子的。在并发的情况下，您也可能覆写了一个被其他进程set的item。<code>memcached 1.2.5</code>以及更高版本，提供了<code>gets</code>和<code>cas</code>命令，它们可以解决上面的问题。如果您使用<code>gets</code>命令查询某个<code>key</code>的<code>item</code>，<code>memcached</code>会给您返回该<code>item</code>当前值的唯一标识。如果您覆写了这个<code>item</code>并想把它写回到<code>memcached</code>中，您可以通过<code>cas</code>命令把那个唯一标识一起发送给 <code>memcached</code>。如果该<code>item</code>存放在<code>memcached</code>中的唯一标识与您提供的一致，您的写操作将会成功。如果另一个进程在这期间也修改了这个 <code>item</code>，那么该<code>item</code>存放在<code>memcached</code>中的唯一标识将会改变，您的写操作就会失败。</p></blockquote><ul><li>数据备份，有效性，持久化等</li></ul><blockquote><p><code>memcached</code>不保证存储的数据的有效性，<code>slab</code>内部基于<code>LRU</code>也会自动淘汰旧数据;<code>memcached</code>也不做数据的持久化工作;</p><p><code>redis</code>可以以<code>master-slave</code>的方式配置服务器，<code>slave</code>节点对数据进行<code>replica</code>备份，<code>slave</code>节点也可以充当<code>read only</code>的节点分担数据读取的工作;<code>redis</code>内建支持两种持久化方案，<code>snapshot</code>快照和<code>AOF</code>增量<code>Log</code>方式。</p></blockquote><ul><li>性能</li></ul><blockquote><p><code>memcached</code>自身并不主动定期检查和标记哪些数据需要被淘汰，只有当再次读取相关数据时才检查时间戳，或者当内存不够使用需要主动淘汰数据时进一步检查<code>LRU</code>数据。</p><p><code>redis</code>为了减少大量小数据CMD操作的网络通讯时间开销 <code>RTT (Round Trip Time)</code>，支持<code>pipeline</code>和<code>script</code>技术。</p></blockquote><ul><li>集群</li></ul><blockquote><p><code>memcached</code>的服务器端互相完全独立，客户端通常通过对键值应用<code>hash</code>算法决定数据的分区，为了减少服务器的增减对<code>hash</code>结果的影响，导致大面积的缓存失效，多数客户端实现了一致性<code>hash</code>算法。</p><p><code>redis3.0</code>已经支持服务端集群了。</p></blockquote><ul><li>性能对比</li></ul><blockquote><p>由于<code>redis</code>只使用单核，而<code>memcached</code>可以使用多核，所以平均每一个核上<code>redis</code>在存储小数据时比<code>memcached</code>性能更高。而在100k以上的数据中，<code>memcached</code>性能要高于<code>redis</code>，虽然<code>redis</code>最近也在存储大数据的性能上进行优化，但是比起<code>memcached</code>，还是稍有逊色</p></blockquote><ul><li>内存使用效率</li></ul><blockquote><p>使用简单的<code>key-value</code>存储的话，<code>memcached</code>的内存利用率更高，而如果<code>redis</code>采用<code>hash</code>结构来做<code>key-value</code>存储，由于其组合式的压缩，其内存利用率会高于<code>memcached</code>。另外，<code>memcached</code>使用预分配的内存池的方式，带来一定程度的空间浪费 并且在内存仍然有很大空间时，新的数据也可能会被剔除，而<code>redis</code>使用现场申请内存的方式来存储数据，不会剔除任何非临时数据 redis更适合作为存储而不是<code>cache</code>。</p></blockquote><ul><li><code>redis</code>支持服务器端的数据操作</li></ul><blockquote><p><code>redis</code>相比<code>memcached</code>来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在<code>memcached</code>里，你需要将数据拿到客户端来进行类似的修改再<code>set</code>回去。这大大增加了网络IO的次数和数据体积。在<code>redis</code>中，这些复杂的操作通常和一般的<code>GET/SET</code>一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么<code>redis</code>会是不错的选择</p></blockquote><hr><p>何时应该使用<code>memcache</code>:</p><blockquote><p>首先就是对小型静态数据进行缓存处理，最具代表性的例子就是HTML代码片段。这是因为<code>memcached</code>在处理元数据时所消耗的内存资源相对更少.</p><p>在以前，<code>redis3.0</code>版本之前，<code>memcached</code>在横向扩展方面也比<code>redis</code>更具优势。由于其在设计上的思路倾向以及相对更为简单的功能设置，<code>memcached</code>在实现扩展时的难度比redis低得多。</p></blockquote><p>何时应该使用<code>redis</code>：</p><blockquote><p>其他场景都可以用<code>redis</code>来替换。</p><p>相比于武断的<code>LRU</code>(即最低近期使用量)算法，<code>redis</code>允许用户更为精准地进行细化控制，利用六种不同回收策略确切提高缓存资源的实际利用率。<code>redis</code>还采用更为复杂的内存管理与回收对象备选方案。</p><p><code>memcached</code>将键名限制在250字节，值也被限制在不超过1MB，且只适用于普通字符串。<code>redis</code>则将键名与值的最大上限各自设定为512MB，且支持二进制格式。</p><p>它所保存的数据具备透明化特性，也就是说服务器能够直接对这些数据进行操作.</p><p><code>redis</code>还提供可选而且能够具体调整的数据持久性方案</p><p><code>redis</code>能够提供复制功能。复制功能旨在帮助缓存体系实现高可用性配置方案，从而在遭遇故障的情况下继续为应用程序提供不间断的缓存服务。</p></blockquote><p>使用<code>redis</code>的正确姿势：</p><blockquote><p>要进行<code>master-slave</code>配置，出现服务故障时可以支持切换。</p><p>在<code>master</code>侧禁用数据持久化，只需在<code>slave</code>上配置数据持久化。</p><p>物理内存+虚拟内存不足，这个时候<code>dump</code>一直死着，时间久了机器挂掉。这个情况就是灾难。</p><p>当<code>redis</code>物理内存使用超过内存总容量的3/5时就会开始比较危险了，就开始做<code>swap</code>,内存碎片大。</p><p>当达到最大内存时，会清空带有过期时间的<code>key</code>，即使<code>key</code>未到过期时间。</p><p><code>redis</code>与<code>DB</code>同步写的问题，先写<code>DB</code>，后写<code>redis</code>，因为写内存基本上没有问题。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis事务</title>
      <link href="/2019/02/02/redis/Redis%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/02/02/redis/Redis%E4%BA%8B%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第十一篇文章。详细探讨redis事务的用法和原理。</p><a id="more"></a><p>redis 事务是一组命令的集合，至少是两个或两个以上的命令，redis 事务保证这些命令被执行时中间不会被任何其他操作打断。</p><h3>事务基本认识</h3><p>当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行。</p><p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队。</p><p><img src="http://xiaozhao.oursnail.cn/redis%E4%BA%8B%E5%8A%A1.svg" alt="image"></p><h3>事务执行</h3><p>前面说到， 当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。</p><p>但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 <code>EXEC</code> 、 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code> 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：</p><p><img src="http://xiaozhao.oursnail.cn/redis%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1.svg" alt="image"></p><p>如果客户端正处于事务状态， 那么当 <code>EXEC</code> 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（<code>FIFO</code>）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p><h3>事务基本命令介绍</h3><p>除了 <code>EXEC</code> 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code> 。</p><p><code>DISCARD</code> 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。</p><p><code>Redis</code> 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 <code>MULTI</code> 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 <code>MULTI</code> 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p><p><code>WATCH</code> 只能在客户端进入事务状态之前执行， 在事务状态下发送 <code>WATCH</code> 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 <code>MULTI</code> 的情况一样）。</p><h3>正常情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//命令入队</span><br><span class="line">exec//提交事务（执行命令）</span><br></pre></td></tr></table></figure><h3>异常情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">set key//错误命令，直接报错</span><br><span class="line">exec//事务被丢弃，提交失败</span><br></pre></td></tr></table></figure><h3>例外情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">incr key//虽然字符串不能增一，但是不报错，入队</span><br><span class="line">exec//自增会失败，但是key被设置成功了，整个事务没有回滚</span><br></pre></td></tr></table></figure><h3>放弃事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multi//开启事务，下面的命令先不执行，先暂时保存起来</span><br><span class="line">set key val//正常命令入队</span><br><span class="line">discard</span><br></pre></td></tr></table></figure><h3>乐观锁</h3><p>乐观锁：每次拿数据的时候都认为别人不会修改该数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这条数据，一般使用版本号进行判断，乐观锁使用于读多写少的应用类型，这样可以提高吞吐量。</p><p>乐观锁大多情况是根据数据版本号(<code>version</code>)的机制实现的，何为数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库添加一个<code>version</code>字段来实现读取出数据时，将此版本号一起读出，之后更新时，对此版本号加1，此时将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库表的当前版本，则予以更新，否则认为是过期数据，不予更新。</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>读出版本号为1，操作</td><td>A操作时，读出版本号也为1，进行某个操作(修改)</td></tr><tr><td>执行修改，version+1=2，因为2&gt;1，所以更新</td><td>…</td></tr><tr><td>…</td><td>执行修改，version+1=2，发现数据库记录的版本也为2，2=2,更新失败</td></tr></tbody></table><h3>watch机制</h3><p><code>WATCH</code> 命令用于在事务开始之前监视任意数量的键： 当调用 <code>EXEC</code> 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set k1 1     //设置k1值为1</span><br><span class="line">watch k1     //监视k1(其他客户端不能修改k1值)</span><br><span class="line">set k1 2     //设置k1值为2</span><br><span class="line">multi        //开始事务</span><br><span class="line">set k1 3     //修改k1值为3</span><br><span class="line">exex         //提交事务，k1值仍为2，因为事务开始之前k1值被修改了</span><br></pre></td></tr></table></figure><h3>watch机制举例</h3><p>大家可能知道<code>redis</code>提供了基于<code>incr</code>命令来操作一个整数型数值的原子递增，那么我们假设如果<code>redis</code>没有这个<code>incr</code>命令，我们该怎么实现这个<code>incr</code>的操作呢？</p><p>正常情况下我们想要对一个整形数值做修改是这么做的(伪代码实现)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure><p>但是上述的代码会出现一个问题,因为上面吧正常的一个<code>incr</code>(原子递增操作)分为了两部分,那么在多线程(分布式)环境中，这个操作就有可能不再具有原子性了。</p><p>研究过<code>java</code>的<code>juc</code>包的人应该都知道<code>cas</code>，那么<code>redis</code>也提供了这样的一个机制，就是利用<code>watch</code>命令来实现的。</p><p>具体做法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + <span class="number">1</span></span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>和此前代码不同的是，新代码在获取<code>mykey</code>的值之前先通过<code>WATCH</code>命令监控了该键，此后又将<code>set</code>命令包围在事务中，这样就可以有效的保证每个连接在执行<code>EXEC</code>之前，如果当前连接获取的<code>mykey</code>的值被其它连接的客户端修改，那么当前连接的<code>EXEC</code>命令将执行失败。这样调用者在判断返回值后就可以获悉<code>val</code>是否被重新设置成功。</p><p>由于<code>WATCH</code>命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以在一般的情况下我们需要在<code>EXEC</code>执行失败后重新执行整个函数。</p><p>执行<code>EXEC</code>命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用<code>UNWATCH</code>命令来取消监控。</p><h3>watch机制原理</h3><h4>WATCH 命令的实现</h4><p>在每个代表数据库的 <code>redis.h/redisDb</code> 结构类型中， 都保存了一个 <code>watched_keys</code> 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。</p><p>比如说，以下字典就展示了一个 <code>watched_keys</code> 字典的例子：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%861.svg" alt="image"></p><p>其中， 键 <code>key1</code> 正在被 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p><p><code>WATCH</code> 命令的作用， 就是将当前客户端和要监视的键在 <code>watched_keys</code> 中进行关联。</p><p>举个例子， 如果当前客户端为 <code>client10086</code> ， 那么当客户端执行 <code>WATCH key1 key2</code> 时， 前面展示的 <code>watched_keys</code> 将被修改成这个样子：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%862.svg" alt="image"></p><p>通过 <code>watched_keys</code> 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p><h4>WATCH 的触发</h4><p>在任何对数据库键空间（<code>key space</code>）进行修改的命令成功执行之后 （比如 <code>FLUSHDB</code> 、 <code>SET</code> 、 <code>DEL</code> 、 <code>LPUSH</code> 、 <code>SADD</code> 、 <code>ZREM</code> ，诸如此类）， <code>multi.c/touchWatchedKey</code> 函数都会被调用 —— 它检查数据库的 <code>watched_keys</code> 字典， 看是否有客户端在监视已经被命令修改的键， 如果有的话， 程序将所有监视这个/这些被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%863.svg" alt="image"></p><p>当客户端发送 <code>EXEC</code> 命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p><ul><li>如果客户端的 <code>REDIS_DIRTY_CAS</code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li><li>如果 <code>REDIS_DIRTY_CAS</code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li></ul><p>举个例子，假设数据库的 <code>watched_keys</code> 字典如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/watch%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%864.svg" alt="image"></p><p>如果某个客户端对 <code>key1</code> 进行了修改（比如执行 <code>DEL key1</code> ）， 那么所有监视 <code>key1</code> 的客户端， 包括 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 的 <code>REDIS_DIRTY_CAS</code> 选项都会被打开， 当客户端 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 执行 <code>EXEC</code> 的时候， 它们的事务都会以失败告终。</p><p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code>watched_keys</code> 字典中和这个客户端相关的资料都会被清除。</p><h3>事务的 ACID 性质</h3><p><code>Redis</code> 事务保证了其中的一致性（偶尔也有可能不一致）和隔离性，但并不保证原子性和持久性。</p><h4>原子性（Atomicity）</h4><p>单个 <code>Redis</code> 命令的执行是原子性的，但 <code>Redis</code> 没有在事务上增加任何维持原子性的机制，所以 <code>Redis</code> 事务的执行并不是原子性的。</p><p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p><p>另一方面，如果 <code>Redis</code> 服务器进程在执行事务的过程中被停止 —— 比如接到 <code>KILL</code> 信号、宿主机器停机，等等，那么事务执行失败。</p><p>当事务失败时，<code>Redis</code> 也不会进行任何的重试或者回滚动作。</p><h4>一致性（Consistency）</h4><p><code>Redis</code> 的一致性问题可以分为三部分来讨论：入队错误、执行错误、<code>Redis</code> 进程被终结。</p><p>前面两者上面已经讨论过了，这里再重复一下.</p><ul><li>入队错误</li></ul><p>入队错误一般是错误的命令(不考虑能不能执行，命令本身就是错误的)，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性；</p><ul><li>执行错误</li></ul><p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 <code>key</code> 执行了错误的操作， 那么 <code>Redis</code> 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。</p><ul><li><code>Redis</code> 进程被终结</li></ul><p>如果 <code>Redis</code> 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 <code>Redis</code> 所使用的持久化模式，可能有以下情况出现：</p><blockquote><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p></blockquote><blockquote><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。所以显然会造成不一致</p></blockquote><blockquote><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行,如果事务语句未写入到 AOF 文件，那么显然是一致的，因为事务里的操作全部失败；如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p></blockquote><h4>隔离性（Isolation）</h4><p><code>Redis</code> 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<code>Redis</code> 的事务是总是带有隔离性的。</p><h4>持久性（Durability）</h4><ul><li>在单纯的内存模式下，事务肯定是不持久的。</li><li>在 <code>RDB</code> 模式下，服务器可能在事务执行之后、<code>RDB</code> 文件更新之前的这段时间宕机，所以 <code>RDB</code> 模式下的 <code>Redis</code> 事务也是不持久的。</li><li>在 <code>AOF</code> 的“总是 <code>SYNC</code> ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code>fsync</code> 或 <code>fdatasync</code> 将事务数据写入到 <code>AOF</code> 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，服务器也有可能出现问题，所以这种模式下的事务也是不持久的。</li><li>都是不持久的。</li></ul><h3>总结</h3><ul><li><code>MULTI</code> 命令的执行标记着事务的开始</li><li>当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队</li><li><code>Redis</code> 的事务保证了 <code>ACID</code> 中的一致性（C）（偶尔也有可能不一致）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li><li>不加入到事务队列而直接执行的四个命令为：<code>EXEC</code> 、 <code>DISCARD</code> 、 <code>MULTI</code> 和 <code>WATCH</code></li><li><code>DISCARD</code> 命令用于取消一个事务</li><li><code>Redis</code> 的事务是不可嵌套的</li><li><code>WATCH</code> 只能在客户端进入事务状态之前执行</li><li><code>WATCH</code>机制的原理</li></ul><p>参考：</p><ul><li><a href="http://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">事务</a></li><li><a href="https://www.jianshu.com/p/361cb9cd13d5" target="_blank" rel="noopener">redis的事务和watch</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis缓存更新</title>
      <link href="/2019/02/02/redis/Redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
      <url>/2019/02/02/redis/Redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第十篇文章。redis缓存更新策略学习。</p><a id="more"></a><p>更新缓存的的<code>Design Pattern</code>有四种：<code>Cache aside</code>, <code>Read through</code>, <code>Write through</code>, <code>Write behind caching</code>，我们下面一一来看一下这四种<code>Pattern</code>。这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，<strong>我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）</strong>。</p><p>先来看看缓存可能存在的一些问题，目的是突出缓存使用策略选择的重要性。</p><h2>1.缓存穿透</h2><p>缓存穿透是说访问一个缓存中没有的数据，但是这个数据数据库中也不存在。</p><p>解决方案是：</p><ul><li>缓存空对象。如果缓存未命中，而数据库中也没有这个对象，则可以缓存一个空对象到缓存。如果使用<code>Redis</code>，这种<code>key</code>需设置一个较短的时间，以防内存浪费。</li><li>缓存预测。预测<code>key</code>是否存在。如果缓存的量不大可以使用<code>hash</code>来判断，如果量大可以使用布隆过滤器来做判断。采用布隆，将所有可能存在的数据哈希到一个足够大的<code>BitSet</code>中，不存在的数据将会被拦截掉，从而避免了对存储系统的查询压力。</li></ul><h2>2.缓存并发</h2><p>多个客户端同时访问一个没有在<code>cache</code>中的数据，这时每个客户端都会执行从<code>DB</code>加载数据<code>set</code>到缓存，就会造成缓存并发。</p><ul><li>缓存预热。提前把所有预期的热数据加到缓存。定位热数据还是比较复杂的事情，需要根据自己的服务访问情况去评估。这个方案只能减轻缓存并发的发生次数不能全部抵制。</li><li>缓存加锁。 如果多个客户端访问不存在的缓存时，在执行加载数据并<code>set</code>缓存这个逻辑之前先加锁，只能让一个客户端执行这段逻辑。</li></ul><h2>3.缓存雪崩</h2><p>缓存雪崩是缓存服务暂时不能提供服务，导致所有的请求都直接访问DB。</p><p>解决方案：</p><ul><li>构建高可用的缓存系统。目前常用的缓存系统<code>Redis</code>和<code>Memcache</code>都支持高可用的部署方式，所以部署的时候不防先考虑是否要以高可用的集群方式部署。</li><li>限流。<code>Netflix</code>的<code>Hystrix</code>是非常不错的工具，在用缓存时不妨搭配它来使用。</li></ul><h2>4.Cache Aside Pattern</h2><p><strong>一种错误的做法是</strong>：先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，直到这个缓存失效为止。</p><p><code>Cache Aside Pattern</code>是最常用最常用的<code>pattern</code>了。其具体逻辑如下：</p><ul><li>失效：应用程序先从<code>cache</code>取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li>命中：应用程序从<code>cache</code>中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><p><strong>注意，我们的更新是先更新数据库，成功后，让缓存失效</strong>。那么，这种方式是否可以没有文章前面提到过的那个问题呢？</p><p>一个是查询操作，一个是更新操作的并发，首先，没有了删除<code>cache</code>数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。<strong>而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据</strong>。</p><p><strong>但还是存在问题的</strong>。比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。不过，实际上出现的概率可能非常低.</p><p>所以，这也就是<code>Quora</code>上的那个答案里说的，要么通过<code>2PC</code>或是<code>Paxos</code>协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而<code>Facebook</code>使用了这个降低概率的玩法，因为<code>2PC</code>太慢，而<code>Paxos</code>太复杂。当然，最好还是为缓存设置上过期时间。</p><h2>5.Read/Write Through Pattern</h2><ul><li><code>Read Through</code>：读取数据的时候如果当前缓存中没有数据，惯常的操作都是应用程序去<code>DB</code>加载数据，然后加入到缓存中。<code>Read Through</code>与之不同的是我们不需要在应用程序自己加载数据了，缓存层会帮忙做件事。</li><li><code>Write Through</code>：更新数据的时候，如果命中缓存，则先更新缓存然后缓存在负责把数据更新到数据库；如果没有命中缓存则直接更新数据库。</li></ul><p>这种方式缓存层直接屏蔽了DB，应用程序只需要更缓存打交道。优点是应用逻辑简单了，而且更高效了；缺点是缓存层的实现相对复杂一些。</p><h2>6.Write Back Pattern</h2><p><code>Write Back</code>套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的<code>I/O</code>操作飞快无比（因为直接操作内存嘛 ），因为异步，<code>write backg</code>还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p><p>但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道<code>Unix/Linux</code>非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。</p><p>另外，<code>Write Back</code>实现逻辑比较复杂，因为他需要<code>track</code>有哪数据是被更新了的，需要刷到持久层上。操作系统的<code>write back</code>会在仅当这个<code>cache</code>需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫<code>lazy write</code>。</p><h2>7.实际使用的一些策略</h2><h4>业务方（调用者）更新</h4><p>传统上，更新缓存都是由业务方来做，也就是由调用者负责更新DB和缓存。</p><h4>DB中间件监听DB变化，更新缓存</h4><p>现在有种新的办法就是利用<code>DB</code>中间件监听<code>DB</code>变化（比如阿里的<code>Canal</code>中间件，点评的<code>Puma</code>），从而对缓存进行更新。<br>这种办法的一个好处就是：把缓存的更新逻辑，和业务逻辑解藕。业务只更新DB，缓存的更新被放在另外一个专门的系统里面。</p><h2>8.总结</h2><p>一句话，无论谁先谁后，只要更新缓存和更新DB不是原子的，就可能导致不一致。</p><p>总之，只是从实际业务来讲，一般缓存也都是保持“最终一致性“，而不是和<code>DB</code>的强一致性。</p><p><strong>并且一般建议先更新DB，再更新缓存，优先保证DB数据正确。</strong></p><h2>9.一致性问题</h2><p>上面，我们没有考虑缓存（<code>Cache</code>）和持久层（<code>Repository</code>）的整体事务的问题。比如，更新<code>Cache</code>成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——<code>prepare</code>, <code>commit/rollback</code>.后续再探讨。</p><ul><li>参考1：<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17416.html</a></li><li>参考2：<a href="https://www.jianshu.com/p/3c111e4719b8" target="_blank" rel="noopener">https://www.jianshu.com/p/3c111e4719b8</a></li><li>参考3：<a href="https://blog.csdn.net/chunlongyu/article/details/53384933" target="_blank" rel="noopener">缓存更新策略/缓存穿透/缓存雪崩</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis缓存设计与优化</title>
      <link href="/2019/02/01/redis/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2019/02/01/redis/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第九篇文章。介绍redis缓存中 一些重要的问题。</p><a id="more"></a><h2>1. 缓存收益和成本</h2><h4>1.1 收益</h4><ul><li>加速读写</li><li>降低后端负载(降低mysql负载)</li></ul><h4>1.2 成本</h4><ul><li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</li><li>代码维护成本：多了一层缓存逻辑</li><li>运维成本：例如<code>redis cluster</code></li></ul><h4>1.3 使用场景</h4><ul><li>降低后端负载：对于高消耗的SQL：join结果集、分组统计结果；对这些结果进行缓存。</li><li>加速请求响应</li><li>大量写合并为批量写：如计数器先redis累加再批量写入DB</li></ul><h2>2. 缓存的更新策略</h2><ul><li><code>LRU/LFU/FIFO</code>算法剔除：例如<code>maxmemory-policy</code></li></ul><blockquote><p><code>FIFO(first in first out)</code></p><p>先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。</p><p><code>LFU(less frequently used)</code></p><p>最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。</p><p><code>LRU(least recently used)</code></p><p>最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</p></blockquote><ul><li>超时剔除：例如<code>expire</code></li><li>主动更新：开发控制生命周期（最终一致性，时间间隔比较短）</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/51026002.jpg" alt="image"></p><ul><li>低一致性：最大内存和淘汰策略</li><li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底。</li></ul><h2>3. 缓存粒度控制</h2><p><img src="http://bloghello.oursnail.cn/18-5-12/56376367.jpg" alt="image"></p><h4>3.1 缓存粒度控制三个角度</h4><ul><li>通用性：全量属性更好(添加删除属性不需要改东西)</li><li>占用空间：部分属性更好</li><li>代码维护：表面上全量属性更好(添加删除属性不需要改东西)</li></ul><h2>4. 缓存穿透优化</h2><h4>4.1 定义</h4><p>大量请求不命中,缓存已经没有存在的意义了：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/69826621.jpg" alt="image"></p><h4>4.2 产生原因</h4><ul><li>业务代码自身问题</li><li>恶意攻击、爬虫等</li></ul><h4>4.3 如何发现</h4><ul><li>业务响应时间</li><li>业务本身问题</li><li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ul><h4>4.4 解决方案</h4><ul><li>方案一：缓存空对象</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/30770379.jpg" alt="image"></p><blockquote><p>存在的问题</p><p>需要更多的键:恶意攻击、爬虫会有很多乱七八糟的键，当量很大时，会有风险，所以会对这种空对象设置缓存时间控制风险</p><p>缓存层和存储层数据“短期”不一致：缓存了空对象，但是当业务恢复了，真实数据又存在于DB中了，那么在这个空对象过期时间内，取到的仍然是空对象，造成短期内数据不一致的问题。解决：可以订阅消息，当恢复正常后接受到消息，然后刷新缓存。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/91489515.jpg" alt="image"></p><ul><li>方案二：布隆过滤器拦截</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/74465100.jpg" alt="image"></p><p>什么是<code>Bloom Filter</code>？</p><blockquote><p>布隆过滤器（<code>Bloom Filter</code>）是1970年由布隆提出的, “<code>a space-efficient probabilistic data structure</code>”。它实际上是一个很长的二进制矢量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，<code>Hash table</code>）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为<code>O(n),O(log n),O(n/k)</code>。</p><p><strong>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1</strong>。</p><p>优点：相比于其它的数据结构，<ins>布隆过滤器在空间和时间方面都有巨大的优势</ins>。布隆过滤器存储空间和插入/查询时间都是常数（O（k））。另外, 散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。布隆过滤器可以表示全集，其它任何数据结构都不能；k和m相同，使用同一组散列函数的两个布隆过滤器的交并差运算可以使用位操作进行。</p><p>缺点：但是布隆过滤器的缺点和优点一样明显。<ins>误算率是其中之一</ins>。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。另外，<ins>一般情况下不能从布隆过滤器中删除元素</ins>。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1,这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/60082067.jpg" alt="image"></p><p>检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：<ins>如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在</ins>。这就是布隆过滤器的基本思想。</p><p><code>Bloom Filter</code>应用场景？</p><p><img src="http://bloghello.oursnail.cn/18-5-12/1394689.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-5-12/76148797.jpg" alt="image"></p><p>用<code>Redis</code>的<code>Bitmap</code>作为位数组构建起来的可扩展的布隆过滤器。</p><p><a href="https://blog.csdn.net/NEWCIH/article/details/78934420" target="_blank" rel="noopener">Redis实现的布隆过滤器如何快速有效删除数据？</a>：EXPIRE “bitmap的key值” 0</p><h4>4.5 解决方案对比</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/38205091.jpg" alt="image"></p><h2>5. 无底洞问题优化</h2><h4>5.1 问题描述</h4><ul><li>2010年，facebook有了3000个<code>Memcache</code>节点</li><li>发现问题：&quot;加&quot;机器性能没能提升，反而下降</li></ul><h4>5.2 问题原因</h4><p>当存在的节点异常多的时候，IO的代价已经超过数据传输，上文提到的facebook的节点已经超过3000个，在这种情况下再增加节点已经没法再提高效率了。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/45516608.jpg" alt="image"></p><h4>5.3 问题解决—优化IO</h4><ul><li>命令本身的效率：例如sql优化，命令优化</li><li>网络次数：减少通信次数</li><li>降低接入成本:长连/连接池,NIO等。</li><li>IO访问合并:O(n)到O(1)过程:批量接口(mget)，就是上一篇文章中介绍的对于mget的四个方案。</li></ul><h2>6. 缓存雪崩优化</h2><h4>6.1 什么是缓存雪崩？</h4><p>从下图可以很清晰出什么是缓存雪崩：由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。 缓存雪崩的英文原意是 stampeding herd（奔逃的野牛），指的是缓存层宕掉后，流量会像奔逃的野牛一样，打向后端存储。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/92547625.jpg" alt="image"></p><h4>6.2 如何防止缓存雪崩？</h4><ul><li>保证缓存层服务高可用性。</li></ul><p>和飞机都有多个引擎一样，如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如前面介绍过的 <code>Redis Sentinel</code> 和 <code>Redis Cluster</code> 都实现了高可用。</p><ul><li>依赖隔离组件为后端限流并降级</li></ul><p>无论是缓存层还是存储层都会有出错的概率，可以将它们视同为资源。作为并发量较大的系统，假如有一个资源不可用，可能会造成线程全部 hang 在这个资源上，造成整个系统不可用。降级在高并发系统中是非常正常的：比如推荐服务中，如果个性化推荐服务不可用，可以降级补充热点数据，不至于造成前端页面是开天窗。</p><p><strong>在实际项目中，我们需要对重要的资源 ( 例如 <code>Redis</code>、 <code>MySQL</code>、 <code>Hbase</code>、外部接口 ) 都进行隔离</strong>，让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响。但是线程池如何管理，比如如何关闭资源池，开启资源池，资源池阀值管理，这些做起来还是相当复杂的，这里推荐一个 Java 依赖隔离工具 <code>Hystrix</code>。超出范围了。不再赘述。</p><h2>7. 热点key重建优化</h2><h4>7.1 问题</h4><p>热点<code>key</code>( 例如一个热门的娱乐新闻）+较长的重建时间（可能是一个复杂计算，例如复杂的 SQL、多次 IO、多个依赖等）</p><p>就是说在高并发的情况下，某个key在缓存中重建时间太长，以至于高并发下缓存查不到，都去DB进行查询。对于DB压力很大，并且响应时间长。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/85568274.jpg" alt="image"></p><p>三个目标：<strong>要减少缓存重建次数、数据尽可能一致、减少潜在危险</strong>。</p><p>两个解决：互斥锁、永远不过期</p><h4>7.2 互斥锁—setex,setnx</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/40535698.jpg" alt="image"></p><p>存在问题：有等待时间。</p><p>伪代码：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/13945208.jpg" alt="image"></p><blockquote><p>(1) 从 <code>Redis</code> 获取数据，如果值不为空，则直接返回值，否则执行 (2.1) 和 (2.2)。</p><p>(2) 如果 <code>set(nx 和 ex)</code> 结果为 true，说明此时没有其他线程重建缓存，那么当前线程执行缓存构建逻辑。</p><p>(2.2) 如果 <code>setnx(nx 和 ex)</code> 结果为 false，说明此时已经有其他线程正在执行构建缓存的工作，那么当前线程将休息指定时间 ( 例如这里是 50 毫秒，取决于构建缓存的速度 ) 后，重新执行函数，直到获取到数据。</p></blockquote><h4>7.3 永远不过期</h4><blockquote><p>这里我想了很久到底是什么意思，，，我感觉这是一个场景：保证数据的定期更新。对于热点<code>key</code>,无非是并发特别大并且重建缓存时间比较长，如果直接设置过期时间，那么时间到的时候，巨大的访问量会压迫到数据库上，所以我们实际上，是不给他设置过期时间，但是不设置过期时间，怎么做到定时更新呢？这里的方案是给热点key的val增加一个逻辑过期时间字段，并发访问的时候，判断这个逻辑字段的时间值是否大于当前时间，大于了说明要对缓存进行更新了，那么这个时候，依然让所有线程访问老的缓存，因为缓存并没有设置过期，但是另开一个线程对缓存进行重构。等重构成功，即执行了<code>redis set</code>操作之后，所有的线程就可以访问到重构后的缓存中的新的内容了。不知道我的理解是不是正确。</p></blockquote><p>“永远不过期”包含两层意思：</p><blockquote><p>从缓存层面来看，确实没有设置过期时间，所以不会出现热点 <code>key</code> 过期后产生的问题，也就是“物理”不过期。</p><p>从功能层面来看，为每个 <code>value</code> 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</p></blockquote><p>2018/6/19 号补充：物理上缓存确实是不过期的，保证所有线程都能访问到，但是有可能是老的数据；逻辑上给 value 增加过期时间，如果当过期时间超过当前时间(每一个线程拿缓存数据的时候都会判断一下，<strong>也就是说这里仍然使用互斥锁</strong>，其中一个线程发现过期时间超过当前时间了，那么锁住，另开一个线程去完成数据重建)，新开一个线程去构建缓存，构建成功之后，设置新内容到缓存中并且删除老缓存，就完成了热点 key 的重建。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/84104163.jpg" alt="image"></p><p>伪代码实现：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/97521024.jpg" alt="image"></p><h4>两种方案对比</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/92977181.jpg" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis-Cluster理论详解</title>
      <link href="/2019/02/01/redis/Redis-Cluster%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/01/redis/Redis-Cluster%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第八篇文章。<a href="http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" target="_blank" rel="noopener">上一篇</a>我们学习了redis sentinel，知道了它是redis高可用的一种实现方案。但是面对要求很高的场景，一台master是一定不能解决问题的，redis 3.0给我们带来了服务端集群方案，解决了这个问题。</p><a id="more"></a><h2>1. 数据分区</h2><p>集群，那么就会涉及到数据是如何分片的。有两种方式：顺序分区和哈希分区</p><p><img src="http://bloghello.oursnail.cn/18-5-11/75952046.jpg" alt="image"></p><p>两者对比：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/86878706.jpg" alt="image"></p><p>直接<code>hash</code>取模进行数据分片时，当节点增加，会有很多数据命中不了，需要重新映射。如果大多数数据在增加或者减少节点之后进行迁移的话，对于性能影响是很大的，因为数据迁移，那么缓存中现在是无法命中的，必须去数据库取，是灾难性的行为。</p><p>早期的做法就是这样，在客户端<code>hash</code>取余节点个数来进行数据分片。如果非要这样，采取翻倍扩容会稍微好一点，迁移数据量会小一点。不过无论如何，这种方式在大数据量情况下是不可行的。</p><h2>2. 一致性hash算法</h2><p>对于上面提到的直接hash取余的方式，会导致大量数据的迁移。那么有没有一种方式，在增加或减少节点时，只有少部分数据迁移呢？</p><p>针对一致性<code>hash</code>算法，已经在<a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">简明理解一致性hash算法</a>中详细说明了，不再赘述。</p><p>对于redis 3.0之前，客户端可以用这种方式来实现数据分片。在redis 3.0之后，就不需要客户端来实现分片算法了，而是直接给我们提供了服务端集群方案<code>redis cluster</code>.</p><h2>3. 虚拟槽</h2><p><code>redis cluster</code>引入槽的概念，一定要与一致性<code>hash</code>的槽区分！这里每一个槽映射一个数据集。</p><blockquote><p>CRC16(key) &amp; 16383</p></blockquote><p>这里计算结果发送给<code>redis cluster</code>任意一个<code>redis</code>节点，这个<code>redis</code>节点发现他是属于自己管辖范围的，那就将它放进去；不属于他的槽范围的话，由于<code>redis</code>之间是相互通信的，这个节点是知道其他<code>redis</code>节点的槽的信息，那么会告诉他去那个<code>redis</code>节点去看看。</p><p>那么就实现了服务端对于槽、节点、数据的管理。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/92222837.jpg" alt="image"></p><p>当<code>master</code>节点增加时，即扩容时，对于以上两种方案，都会出现数据迁移，那么只能作为缓存场景使用。但是<code>redis cluster</code>，由于每个节点维护的槽的范围是固定的，当有新加入的节点时，是不会干扰到其他节点的槽的，必须是以前的节点将使用槽的权利分配给你，并且将数据分配给你，这样，新的节点才会真正拥有这些槽和数据。这种实现还处于半自动状态，需要人工介入。-----主要的思想是：槽到集群节点的映射关系要改变，不变的是键到槽的映射关系.</p><p><code>Redis</code>集群，要保证16384个槽对应的<code>node</code>都正常工作，<strong>如果某个<code>node</code>发生故障，那它负责的<code>slots</code>也就失效，整个集群将不能工作</strong>。为了增加集群的可访问性，官方推荐的方案是将<code>node</code>配置成主从结构，即一个<code>master</code>主节点，挂n个<code>slave</code>从节点。这时，如果主节点失效，<code>Redis Cluster</code>会根据选举算法从<code>slave</code>节点中选择一个上升为主节点，整个集群继续对外提供服务。</p><h2>4. 某个Master又怎么知道某个槽自己是不是拥有呢？</h2><p><code>Master</code>节点维护着一个16384/8字节的位序列，<code>Master</code>节点用bit来标识对于某个槽自己是否拥有。比如对于编号为1的槽，<code>Master</code>只要判断序列的第二位（索引从0开始）是不是为1即可。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/45417990.jpg" alt="image"></p><p>如上面的序列，表示当前<code>Master</code>拥有编号为1，134的槽。集群同时还维护着槽到集群节点的映射，是由长度为16384类型为节点的数组实现的，槽编号为数组的下标，数组内容为集群节点，这样就可以很快地通过槽编号找到负责这个槽的节点。位序列这个结构很精巧，即不浪费存储空间，操作起来又很便捷。</p><p>具体参照：<a href="http://blog.jobbole.com/103258/" target="_blank" rel="noopener">http://blog.jobbole.com/103258/</a> ,还提到了<code>slot</code>迁移的一些细节。</p><h2>5. redis节点之间如何通信的？</h2><p><img src="http://bloghello.oursnail.cn/18-5-11/14610782.jpg" alt="image"></p><ul><li><code>gossip</code>协议：节点之间彼此不断通信交换信息，一段时间后所有节点都会知道集群完整的信息。</li><li>节点与节点之间通过<strong>二进制协议</strong>进行通信。</li><li>客户端和集群节点之间通信和通常一样，通过文本协议进行。</li><li>集群节点不会代理查询。</li></ul><h2>6. 集群伸缩</h2><p>这里6385为新加入的节点，一开始是没有槽的，所以进行<code>slot</code>的迁移。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/10996863.jpg" alt="image"></p><p>集群伸缩：槽和数据在节点之间的移动。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/8930549.jpg" alt="image"></p><p>迁移数据的流程图：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/7140273.jpg" alt="image"></p><p><strong>迁移key可以用<code>pipeline</code>进行批量的迁移。</strong></p><p>对于扩容，原理已经很清晰了，至于具体操作，网上很多。至于缩容，也是先手动完成数据迁移，再关闭<code>redis</code>。</p><h2>7. 客户端路由</h2><h4>7.1 moved重定向</h4><p><img src="http://bloghello.oursnail.cn/18-5-11/69037262.jpg" alt="image"></p><p>其中，槽直接命中的话，就直接返回槽编号：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/48809003.jpg" alt="image"></p><p>槽不命中，返回带提示信息的异常，客户端需要重新发送一条命令：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/38968206.jpg" alt="image"></p><p>对于命令行的实验，用<code>redis-cli</code>去连接集群：</p><p><code>redis -c -p 7000</code>:加上<code>-c</code>，表示使用集群模式，帮助我们在第一次不命中的情况下自动跳转到对应的节点上：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/53223278.jpg" alt="image"></p><p>如果不加-c的话，会返回moved异常，不会自动跳转：</p><p><img src="http://bloghello.oursnail.cn/18-5-11/7791978.jpg" alt="image"></p><h4>7.2 ask重定向</h4><p>在扩容缩容的时候，由于需要遍历这个节点上的所有的<code>key</code>然后进行迁移，是比较慢的，对客户端是一个挑战。因为假设一个场景，客户端访问某个key，节点告诉客户端这个<code>key</code>在源节点，当我们再去源节点访问的时候，却发现<code>key</code>已经迁移到目标节点。</p><p><img src="http://bloghello.oursnail.cn/18-5-11/35563321.jpg" alt="image"></p><h4>7.3 moved重定向和ask重定向对比</h4><ul><li>两者都是客户端的重定向</li><li>moved：槽已经确定转移</li><li>ask:槽还在迁移中</li></ul><p>问题：如果节点众多，那么让客户端随机访问节点，那么直接命中的概率只有百分之一，还有就是发生<code>ask</code>异常时（即节点正在迁移时）客户端如何还能高效运转？</p><p>总结一句话就是<code>redis cluster</code>的客户端的实现会更复杂。</p><h2>8. smart客户端</h2><h4>8.1 追求目标</h4><p>追求性能，不会使用代理模式，而是直连对应节点。需要对<code>moved</code>异常和<code>ask</code>异常做兼容。也就是说，需要有一个这个语言对应的客户端来高效实现查找等操作。</p><h4>8.2 smart原理</h4><ul><li>从集群中选一个可运行节点，使用<code>cluster slots</code>初始化槽和节点映射</li><li>将<code>slot</code>与<code>node</code>节点的结果映射到本地，为每个节点创建<code>JedisPool</code></li><li>准备执行命令</li></ul><p>第一步中将<code>slot</code>与<code>node</code>节点的对应关系放在了<code>map</code>中，形成一个映射关系；<code>key</code>是通过<code>CRC16</code>算法再取余得到<code>slot</code>，所以<code>key</code>与<code>slot</code>的映射关系也是确定的。我们就可以直接发送命令。只要后面集群没有发生数据迁移，那么就会连接成功。但是如果在连接的时候出现了连接出错，说明这个<code>key</code>已经迁移到其他的<code>node</code>上了。如果发现<code>key</code>不停地迁移，超过5次就报错。</p><p>在发生<code>moved</code>异常的时候，则需要刷新缓存，即一开始维护的<code>map</code>。<br><img src="http://bloghello.oursnail.cn/18-5-12/49065180.jpg" alt="image"></p><p>有一个情况比较全的图：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/16371398.jpg" alt="image"></p><p><code>java redis cluster</code>客户端：<code>jedisCluster</code>基本使用–伪代码</p><p><img src="http://bloghello.oursnail.cn/18-5-12/31666045.jpg" alt="image"></p><p><code>jedisCluster</code>内部已经封装好池的借还操作等。</p><p>先写一个<code>JedisClusterFactory</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.HostAndPort;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisCluster;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hostPortList;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里可以设置相关参数</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从配置文件中读取ip:port的参数放进Set中</span></span><br><span class="line">        Set&lt;HostAndPort&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String hostPort : hostPortList)&#123;</span><br><span class="line">            String[] arr = hostPort.split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr.length != <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(<span class="keyword">new</span> HostAndPort(arr[<span class="number">0</span>],Integer.parseInt(arr[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedisCluster = <span class="keyword">new</span> JedisCluster(nodeSet,timeout,jedisPoolConfig);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedisCluster != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jedisCluster.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisCluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring注入hostPortList和timeout</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHostPortList</span><span class="params">(List&lt;String&gt; hostPortList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hostPortList = hostPortList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hostPortList</code> 放入<code>spring bean</code>中，<code>spring</code>自动完成注入。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/83900230.jpg" alt="image"></p><h4>8.3 多节点命令实现</h4><p>有的时候我们想操作所有节点的数据。如何实现呢？</p><p><img src="http://bloghello.oursnail.cn/18-5-12/68192871.jpg" alt="image"></p><h4>8.4 批量操作</h4><p><strong><code>mget</code>,<code>mset</code>必须在一个槽</strong>。这个条件比较苛刻，一般是不能保证的，那么如何实现批量的操作呢？</p><blockquote><p><code>Redis Cluster</code>的行为和<code>Redis</code> 的单节点不同，甚至和一个<code>Sentinel</code> 监控的主从模式也不一样。主要原因是集群自动分片，将一个<code>key</code> 映射到16384个槽中的一个，这些槽分布在多个节点上。因此操作多个<code>key</code> 的命令必须保证所有的<code>key</code> 都映射到同一个槽上，避免跨槽执行错误。更进一步说，今后一个单独的集群节点，只服务于一组专用的<code>keys</code>，请求一个命令到一个<code>Server</code>，只能得到该<code>Server</code> 上拥有<code>keys</code> 的对应结果。一个非常简单的例子是执行<code>KEYS</code>命令，当发布该命令到集群环境中的某个节时，只能得到该节点上拥有的<code>keys</code>，而不是集群中所有的<code>keys</code>。所以要得到集群中所有的<code>keys</code>，必须从集群的所有主节点上获取所有的<code>keys</code>。</p></blockquote><p>对于分散在<code>redis</code>集群中不同节点的数据，我们如何比较高效地批量获取数据呢？？？？</p><ol><li>串行mget–原始方案，整一个for循环</li></ol><p><img src="http://bloghello.oursnail.cn/18-5-12/58584180.jpg" alt="image"></p><ol start="2"><li>串行IO</li></ol><p>对key进行RCR16和取余操作得到<code>slot</code>，将<code>slots</code>按照节点进行分批传送：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/35132332.jpg" alt="image"></p><ol start="3"><li>并行IO</li></ol><p><img src="http://bloghello.oursnail.cn/18-5-12/42467098.jpg" alt="image"></p><ol start="4"><li>hash_tag</li></ol><p>不做任何改变的话，<code>hash</code>之后就比较均匀地散在每个节点上：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/67459261.jpg" alt="image"></p><p>那么我们能不能像使用单机<code>redis</code>一样，一次IO将所有的<code>key</code>取出来呢？<code>hash-tag</code>提供了这样的功能，如果将上述的<code>key</code>改为如下，<strong>也就是用大括号括起来相同的内容，那么这些key就会到指定的一个节点上</strong>。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/77254754.jpg" alt="image"></p><p>在<code>mget</code>的时候只需要在一台机器上去即可。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/77494164.jpg" alt="image"></p><ol start="5"><li>对比</li></ol><p>方案三比较复杂，一般不用；方案四可能会出现数据倾斜，也不用。方案一在key小的时候可以用；方案二相对来说有一点优势；</p><p><img src="http://bloghello.oursnail.cn/18-5-12/2180496.jpg" alt="image"></p><p>为什么说是一点优势呢？<code>pipeline</code>批量处理不应该比串行处理好很多吗？</p><ul><li><a href="http://xiezefan.me/2015/12/13/redis_cluster_research_2/" target="_blank" rel="noopener">http://xiezefan.me/2015/12/13/redis_cluster_research_2/</a></li><li><a href="http://trumandu.github.io/2016/05/09/RedisCluster%E6%9E%84%E5%BB%BA%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%8E%A2%E8%AE%A8/" target="_blank" rel="noopener">http://trumandu.github.io/2016/05/09/RedisCluster构建批量操作探讨/</a></li></ul><h2>9. 故障转移</h2><h4>9.1 故障发现</h4><ul><li>通过<code>ping/pong</code>消息实现故障发现：不需要<code>sentinel</code></li><li>分为主观下线和客观下线</li></ul><p>主观下线：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/34676048.jpg" alt="image"></p><p>客观下线：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/16678200.jpg" alt="image"></p><p>pfail消息就是主观下线的信息，维护在一个链表中，链表中包含了所有其他节点对其他节点所有的主观信息，是有时间周期的，为了防止很早以前的主观下线信息还残留在这里。对这个链表进行分析，符合条件就尝试客观下线。</p><p><img src="http://bloghello.oursnail.cn/18-5-12/42802351.jpg" alt="image"></p><h4>9.2 故障恢复</h4><p>从节点接收到他的主节点客观下线的通知，则进行故障恢复的操作。</p><ul><li>资格检查</li></ul><p>选取出符合条件的从节点：当从节点和故障主节点的断线时间太长，会被取消资格。</p><ul><li>准备选举时间</li></ul><p>就是为了保证偏移量大的从节点优先被选举投票</p><p><img src="http://bloghello.oursnail.cn/18-5-12/46928842.jpg" alt="image"></p><ul><li>选举投票</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/64039470.jpg" alt="image"></p><ul><li>替换主节点</li></ul><p><img src="http://bloghello.oursnail.cn/18-5-12/70736400.jpg" alt="image"></p><p>这些所有步骤加起来，差不多十几秒左右。最后如果故障节点又恢复功能了，就称为新的<code>Master</code>的<code>slave</code>节点。</p><h2>10. 常见问题</h2><h4>10.1 集群完整性</h4><p><code>cluster-require-full-coverage</code>默认为yes</p><pre><code>- 要求所有节点都在服务，集群中16384个槽全部可用：保证集群完整性- 节点故障或者正在故障转移：`(error)CLUSTERDOWN the cluster is down`</code></pre><p><strong>但是大多数业务都无法容忍。需要将<code>cluster-require-full-coverage</code>设置为<code>no</code></strong></p><h4>10.2 带宽消耗</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/18544066.jpg" alt="image"></p><ul><li>消息发送频率：节点发现与其他节点最后通信时间超过<code>cluster-node-timeout/2</code>时会直接发送<code>Ping</code>消息</li><li>消息数据量：<code>slots</code>槽数组(2k空间)和整个集群1、10的状态数据(10个节点状态数据约10k)</li><li>节点部署的机器规模：进去分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽越高。</li><li>优化：避免“大”集群，：避免多业务使用一个集群，大业务可用多集群；<code>cluster-node-timeout</code>时间设置要注意是带宽和故障转移速度的均衡；尽量均匀分配到多机器上：保证高可用和带宽。</li></ul><h4>10.3 PubSub广播</h4><p><img src="http://bloghello.oursnail.cn/18-5-12/49491067.jpg" alt="image"></p><ul><li>问题：<code>publish</code>在集群中每个节点广播：加重带宽。</li><li>解决：单独“走”一套<code>redis sentinel</code>。就是针对目标的几个节点构建<code>redis sentinel</code>，在这个里面实现广播。</li></ul><h4>10.4 数据倾斜</h4><ul><li>节点和槽分配不均匀<ul><li><code>./redis-trib.rb info ip:port</code>查看节点、槽、键值分布</li><li>慎用<code>rebalance</code>命令</li></ul></li><li>不同槽位对应键数量差异较大<ul><li>CRC16正常情况下比较均匀</li><li>可能存在<code>hash_tag</code></li><li><code>cluster countKeysinslot {slot}</code>获取槽对应键值个数</li></ul></li><li>包含<code>bigkey</code><ul><li>例如大字符串、几百万的元素的<code>hash</code>、<code>set</code>等</li><li>在从节点上执行:<code>redis-cli --bigkeys</code>来查看<code>bigkey</code>情况</li><li>优化：优化数据结构</li></ul></li><li>内存相关配置不一致<ul><li>因为某种情况下，某个节点对<code>hash</code>或者<code>Set</code>这种数据结构进行了单独的优化，而其他节点都没有配置，会出现配置不一致的情况。</li></ul></li></ul><h4>10.5 请求倾斜</h4><ul><li>热点key：重要的<code>key</code>或者<code>bigkey</code></li><li>优化：避免<code>bigkey;</code>热键不使用<code>hash_tag</code>；当一致性不高时，可以用本地缓存+MQ</li></ul><h4>10.6 读写分离</h4><ul><li>只读连接：集群模式的从节点不接受任何读写请求</li></ul><blockquote><p>重定向到负责槽的主节点(对从节点进行读，都是重定向到主节点再返回信息)</p><p>readonly命令可以读：连接级别命令(每次重新连接都要写一次)</p></blockquote><p><img src="http://bloghello.oursnail.cn/18-5-12/57749242.jpg" alt="image"></p><p>上图可以看出，<strong><code>redis cluster</code> 默认<code>slave</code> 也是不能读的，如果要读取，需要执行 <code>readonly</code></strong>，就可以了。</p><ul><li>读写分离：更加复杂（成本很高，尽量不要使用）</li></ul><blockquote><p>同样的问题：复制延迟、读取过期数据、从节点故障</p><p>修改客户端</p></blockquote><h4>10.7 数据迁移</h4><p>分为离线迁移和在线迁移(唯品会<code>redis-migrate-tool</code>和豌豆荚<code>redis-port</code>)。</p><p>官方的方式：只能从单机迁移到集群、不支持在线迁移、不支持断点续传、单线程迁移影响速度</p><blockquote><p><code>./redis-trib.rb import --from 源ip:port --copy 目标ip:port</code></p></blockquote><p>加入在迁移时再往源<code>redis</code>插入几条数据，这几条数据会丢失(丢失一部分)</p><h4>10.8 集群vs单机</h4><p>集群也有一定的限制：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/73133214.jpg" alt="image"></p><p>分布式<code>redis</code>不一定是好的：</p><p><img src="http://bloghello.oursnail.cn/18-5-12/6295367.jpg" alt="image"></p><h2>11. 简单总结</h2><p><img src="http://bloghello.oursnail.cn/18-5-12/415428.jpg" alt="image"></p><p><img src="http://bloghello.oursnail.cn/18-5-12/24688449.jpg" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简明理解一致性hash算法</title>
      <link href="/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
      <url>/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。接下来主要讲解一下一致性哈希算法是如何设计的。</p><a id="more"></a><h2>环形Hash空间</h2><p>按照常用的hash算法来将对应的key哈希到一个具有2^32 次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图</p><p><img src="http://bloghello.oursnail.cn/zaji15-1.png" alt="image"></p><p>把数据通过一定的hash算法处理后映射到环上<br>现在我们将<code>object1</code>、<code>object2</code>、<code>object3</code>、<code>object4</code>四个对象通过特定的<code>Hash</code>函数计算出对应的<code>key</code>值，然后散列到<code>Hash</code>环上。如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hash(object1) = key1；</span><br><span class="line">Hash(object2) = key2；</span><br><span class="line">Hash(object3) = key3；</span><br><span class="line">Hash(object4) = key4；</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/zaji15-2.png" alt="image"></p><p>将机器通过hash算法映射到环上<br>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的Hash算法将机器也映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。<br>假设现在有<code>NODE1</code>，<code>NODE2</code>，<code>NODE3</code>三台机器，通过Hash算法得到对应的KEY值，映射到环中，其示意图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hash(NODE1) = KEY1;</span><br><span class="line">Hash(NODE2) = KEY2;</span><br><span class="line">Hash(NODE3) = KEY3;</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/zaji15-3.png" alt="image"></p><p>通过上图可以看出对象与机器处于同一哈希空间中，这样按顺时针转动<code>object1</code>存储到了<code>NODE1</code>中，<code>object3</code>存储到了<code>NODE2</code>中，<code>object2</code>、<code>object4</code>存储到了<code>NODE3</code>中。在这样的部署环境中，hash环是不会变更的，因此，通过算出对象的hash值就能快速的定位到对应的机器中，这样就能找到对象真正的存储位置了。</p><h2>机器的删除与添加</h2><p>普通hash求余算法最为不妥的地方就是在有机器的添加或者删除之后会照成大量的对象存储位置失效，这样就大大的不满足单调性了。下面来分析一下一致性哈希算法是如何处理的。</p><h3>节点（机器）的删除</h3><p>以上面的分布为例，如果<code>NODE2</code>出现故障被删除了，那么按照顺时针迁移的方法，<code>object3</code>将会被迁移到<code>NODE3</code>中，这样仅仅是<code>object3</code>的映射位置发生了变化，其它的对象没有任何的改动。如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-4.png" alt="image"></p><h3>节点（机器）的添加</h3><p>如果往集群中添加一个新的节点<code>NODE4</code>，通过对应的哈希算法得到<code>KEY4</code>，并映射到环中，如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-5.png" alt="image"></p><p>通过按顺时针迁移的规则，那么<code>object2</code>被迁移到了<code>NODE4</code>中，其它对象还保持这原有的存储位置。通过对节点的添加和删除的分析，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。</p><h2>平衡性</h2><p>根据上面的图解分析，一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但这还并不能当做其被广泛应用的原由，因为还缺少了平衡性。下面将分析一致性哈希算法是如何满足平衡性的。</p><p>hash算法是不保证平衡的，如上面只部署了<code>NODE1</code>和<code>NODE3</code>的情况（<code>NODE2</code>被删除的图），<code>object1</code>存储到了<code>NODE1</code>中，而<code>object2</code>、<code>object3</code>、<code>object4</code>都存储到了<code>NODE3</code>中，这样就照成了非常不平衡的状态。在一致性哈希算法中，为了尽可能的满足平衡性，其引入了虚拟节点。</p><blockquote><p>“虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品（ replica ），一实际个节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</p></blockquote><p>以上面只部署了<code>NODE1</code>和<code>NODE3</code>的情况（<code>NODE2</code>被删除的图）为例，之前的对象在机器上的分布很不均衡，现在我们以2个副本（复制个数）为例，这样整个hash环中就存在了4个虚拟节点，最后对象映射的关系图如下：</p><p><img src="http://bloghello.oursnail.cn/zaji15-6.png" alt="image"></p><p>根据上图可知对象的映射关系：<code>object1</code>-&gt;<code>NODE1-1</code>，<code>object2</code>-&gt;<code>NODE1-2</code>，<code>object3</code>-&gt;<code>NODE3-2</code>，<code>object4</code>-&gt;<code>NODE3-1</code>。通过虚拟节点的引入，对象的分布就比较均衡了。那么在实际操作中，真正的对象查询是如何工作的呢？对象从hash到虚拟节点到实际节点的转换如下图：</p><p><img src="http://bloghello.oursnail.cn/zaji15-7.png" alt="image"></p><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设<code>NODE1</code>的IP地址为<code>192.168.1.100</code>。引入“虚拟节点”前，计算 <code>cache A</code> 的 <code>hash</code> 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100”);</span><br></pre></td></tr></table></figure><p>引入“虚拟节点”后，计算“虚拟节”点<code>NODE1-1</code>和<code>NODE1-2</code>的<code>hash</code>值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash(“192.168.1.100#1”); // NODE1-1</span><br><span class="line">Hash(“192.168.1.100#2”); // NODE1-2</span><br></pre></td></tr></table></figure><p>整理自：</p><ul><li><a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">五分钟理解一致性哈希算法</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis-Sentinel实现高可用读写分离</title>
      <link href="/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第七篇文章。Redis Sentinel 是一个分布式系统，你可以在一个架构中运行多个 Sentinel 进程，这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息，并使用投票协议（agreement protocols）来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器。</p><a id="more"></a><p>虽然 <code>Redis Sentinel</code> 是一个单独的可执行文件 <code>redis-sentinel</code> ，但实际上它只是一个运行在特殊模式下的 <code>Redis</code> 服务器，你可以在启动一个普通 <code>Redis</code> 服务器时通过给定 <code>–sentinel</code> 选项来启动 <code>Redis Sentinel</code> 。</p><ul><li>启动方式一：使用<code>sentinel</code>可执行文件 <code>redis-sentinel</code> 程序来启动 <code>Sentinel</code> 系统，命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure><ul><li><code>sentinel</code>只是运行在特殊模式下的<code>redis</code>服务器，你可以用启动<code>redis</code>服务的命令来启动一个运行在 <code>Sentinel</code> 模式下的 <code>Redis</code> 服务器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure><h2>1. redis sentinel</h2><p>首先来看看什么是 <code>redis sentinel</code>，中文翻译是redis哨兵。顾名思义，哨兵是站岗监督突发情况的，那么这里具体的功能上很类似：</p><ul><li>监控：<code>Sentinel</code> 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒：当被监控的某个 <code>Redis</code> 服务器出现问题时，<code>Sentinel</code> 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移：当一个主服务器不能正常工作时，<code>Sentinel</code> 会开始一次自动故障迁移操作，它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。</li></ul><p><img src="http://bloghello.oursnail.cn/redis_sentinel%E7%BB%93%E6%9E%84.png" alt="image"></p><p>其中总结一下故障转移的基本原理：</p><ul><li>多个<code>sentinel</code>发现并确认<code>master</code>有问题</li><li>选举出一个<code>sentinel</code>作为领导</li><li>选出一个可以成为新的<code>master</code>的<code>slave</code></li><li>通知其他的<code>slave</code>称为新的<code>master</code>的<code>slave</code></li><li>通知客户端主从变化</li><li>等待老的<code>master</code>复活称为新的<code>master</code>的<code>slave</code></li></ul><p>也支持多个<code>master-slave</code>结构：</p><p><img src="http://bloghello.oursnail.cn/%E5%A4%9A%E4%B8%AAmaster_slave.png" alt="image"></p><h2>2. 安装与配置</h2><ol><li>配置开启主从节点</li><li>配置开启<code>sentinel</code>监控主节点（<code>sentinel</code>是特殊的<code>redis</code>）</li><li>实际应该多台机器，但是演示方便，只用一台机器来搭建</li><li>详细配置节点</li></ol><p>本地安装的结构图：</p><p><img src="http://bloghello.oursnail.cn/%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="image"></p><p>对于<code>master:redis-7000.conf</code>配置：</p><p><img src="http://bloghello.oursnail.cn/redis-7000.conf.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /usr/local/redis/data/redis-7000.pid</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br></pre></td></tr></table></figure><p>对于<code>slave:redis-7001</code>和<code>redis-7002</code>配置：</p><p><img src="http://bloghello.oursnail.cn/redis-slave.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /usr/local/redis/data/redis-7001.pid</span><br><span class="line">logfile &quot;7001.log&quot;</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br><span class="line">slaveof 127.0.0.1 7000</span><br></pre></td></tr></table></figure><p>启动<code>redis</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server ../config/redis-7000.conf</span><br></pre></td></tr></table></figure><p>访问7000端口的<code>master redis</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7000 info replication</span><br></pre></td></tr></table></figure><p>显示他有两个从节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=7002,state=online,offset=99550,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=7001,state=online,offset=99816,lag=0</span><br><span class="line">master_repl_offset:99816</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:99815</span><br></pre></td></tr></table></figure><p>对于<code>sentinel</code>主要配置：</p><p><img src="http://bloghello.oursnail.cn/sentinel%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE.png" alt="image"></p><p><code>master sentinel config</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/usr/local/redis/data&quot;</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>启动<code>redis sentinel</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel ../config/redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure><p>访问26379 <code>redis sentinel master</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 26379 info sentinel</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:7000,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看这六个进程是否都起来了：ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>注意，如果上面是配置在虚拟机的话，需要将127.0.0.1改为虚拟机的ip，要不然找不着。</p><h2>3. 故障转移演练</h2><h4>3.1 java客户端程序</h4><p><code>JedisSentinelPool</code>只是一个配置中心，不需要具体连接某个<code>redis</code>，注意它不是代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(AppTest.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//哨兵配置，我们访问redis，就通过sentinel来访问</span></span><br><span class="line">    String masername = <span class="string">"mymaster"</span>;</span><br><span class="line">    Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26379"</span>);</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26380"</span>);</span><br><span class="line">    sentinels.add(<span class="string">"10.128.24.176:26381"</span>);</span><br><span class="line"></span><br><span class="line">    JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masername,sentinels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个while死循环，每隔一秒往master塞入一个值，并且日志打印</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = sentinelPool.getResource();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">100000</span>);</span><br><span class="line">            String key = <span class="string">"k-"</span> + index;</span><br><span class="line">            String value = <span class="string">"v-"</span> + index;</span><br><span class="line">            jedis.set(key,value);</span><br><span class="line">            logger.info(<span class="string">"&#123;&#125;  value is &#123;&#125;"</span>,key,jedis.get(key));</span><br><span class="line"></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(jedis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>maven</code>依赖是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--slf4j日志接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--logback日志实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动程序，发现是正常写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">16:16:01.424 [main] INFO  com.njupt.swg.AppTest - k-54795  value is v-54795</span><br><span class="line">16:16:02.426 [main] INFO  com.njupt.swg.AppTest - k-55630  value is v-55630</span><br><span class="line">16:16:03.429 [main] INFO  com.njupt.swg.AppTest - k-70642  value is v-70642</span><br><span class="line">16:16:04.430 [main] INFO  com.njupt.swg.AppTest - k-42978  value is v-42978</span><br><span class="line">16:16:05.431 [main] INFO  com.njupt.swg.AppTest - k-96297  value is v-96297</span><br><span class="line">16:16:06.433 [main] INFO  com.njupt.swg.AppTest - k-4220  value is v-4220</span><br><span class="line">16:16:07.435 [main] INFO  com.njupt.swg.AppTest - k-34103  value is v-34103</span><br><span class="line">16:16:08.436 [main] INFO  com.njupt.swg.AppTest - k-9177  value is v-9177</span><br><span class="line">16:16:09.437 [main] INFO  com.njupt.swg.AppTest - k-24389  value is v-24389</span><br><span class="line">16:16:10.439 [main] INFO  com.njupt.swg.AppTest - k-32325  value is v-32325</span><br><span class="line">16:16:11.440 [main] INFO  com.njupt.swg.AppTest - k-68538  value is v-68538</span><br><span class="line">16:16:12.441 [main] INFO  com.njupt.swg.AppTest - k-36233  value is v-36233</span><br><span class="line">16:16:13.443 [main] INFO  com.njupt.swg.AppTest - k-305  value is v-305</span><br><span class="line">16:16:14.444 [main] INFO  com.njupt.swg.AppTest - k-59279  value is v-59279</span><br></pre></td></tr></table></figure><p>我们将现在的端口为7000的<code>redis master</code> 给<code>kill</code>掉</p><blockquote><p>kill -9 master的pid</p></blockquote><p>我们会发现：客户端报异常，但是在大概十几秒之后，就继续正常塞值了。原因是服务端的哨兵机制的选举<code>matser</code>需要一定的时间。</p><h2>4. 三个定时任务</h2><h4>4.1 每10秒每个sentinel对master和slave执行Info</h4><ul><li>发现<code>slave</code>节点</li><li>确认主从关系</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h4>4.2 每2秒每个sentinel通过master节点的channel交换信息(pub/sub)</h4><ul><li>通过<code>__sentinel__</code>:hello进行频道交互</li><li>交互对节点的“看法”和自身信息</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h4>4.3 每1秒每个<code>sentinel</code>对其他<code>sentinel</code>和<code>redis</code>执行<code>ping</code></h4><ul><li>心跳监测，失败判定依据</li></ul><p><img src="http://bloghello.oursnail.cn/%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%AE%9A%E6%97%B6.png" alt="image"></p><h2>5. 主观下线和客观下线</h2><p>对于之前的<code>Sentinel</code>配置文件中有两条配置：</p><p>监控<code>master redis</code>节点，这里是当超过两个<code>sentinel</code>认为<code>master</code>挂了，则认为<code>master</code>挂了。</p><blockquote><p><code>sentinel monitor &lt;masterName&gt; &lt;masterIp&gt; &lt;msterPort&gt; &lt;quorum&gt;</code></p><p><code>sentinel monitor mymaster 127.0.0.1 6379 2</code></p></blockquote><p>这里是每秒<code>sentinel</code>都会去<code>Ping</code>周围的<code>master redis</code>，超过30秒没有任何响应，说明其挂了。</p><blockquote><p><code>sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;</code></p><p><code>sentinel down-after-milliseconds mymaster 300000</code></p></blockquote><h4>5.1 主观下线</h4><p>主观下线：每个<code>sentinel</code>节点对<code>Redis</code>节点失败的“偏见”</p><p>这是一种主观下线。因为在复杂的网络环境下，这个<code>sentinel</code>与这个<code>master</code>不通，但是<code>master</code>与其他的<code>sentinel</code>都是通的呢？所以是一种“偏见”</p><p>这是依靠的第三种定时：每秒去ping一下周围的<code>sentinel</code>和<code>redis</code>。对于<code>slave redis</code>,可以使用这个主观下线，因为他不需要进行故障转移。</p><h4>5.2 客观下线</h4><p>客观下线：所有<code>sentinel</code>节点对<code>master Redis</code>节点失败“达成共识”（超过<code>quorum</code>个则统一）</p><p>这是依靠的第二种定时：每两秒，<code>sentinel</code>之间进行“商量”，传递的消息是:<code>sentinel is-master-down-by-addr</code></p><p>对于<code>master redis</code>的下线，必须要达成共识才可以，因为涉及故障转移，仅仅依靠一个<code>sentinel</code>判断是不够的。</p><h2>6. 领导者选举</h2><p>原因：只有一个<code>sentinel</code>节点完成故障转移</p><p>选举：通过<code>sentinel is-master-down-by-addr</code>命令都希望成为领导者</p><ul><li>每个做主观下线的<code>sentinel</code>节点向其他<code>sentinel</code>节点发送命令，要求将它设置为领导者</li><li>收到命令的<code>sentinel</code>节点如果还没有同意过其他<code>semtinel</code>节点发送的命令，那么将同意该请求，否则拒绝</li><li>如果该<code>sentinel</code>节点发现自己的票数已经超过<code>sentinel</code>集合半数并且超过<code>quorum</code>，那么它将成为领导者。</li><li>如果此过程中多个<code>sentinel</code>节点成为了领导者，那么将等待一段时间重新进行选举</li></ul><h2>7. 故障转移</h2><ul><li>从<code>slave</code>节点中选出一个“合适的”节点作为新的<code>master</code>节点</li><li>对上述的<code>slave</code>节点执行“<code>slaveof no one</code>”命令使其成为<code>master</code>节点</li><li>向剩余的<code>slave</code>节点发送命令，让它们成为新<code>master</code>节点的<code>slave</code>节点，复制规则和<code>parallel-syncs</code>参数一样</li><li>更新对原来的<code>master</code>节点配置为<code>slave</code>，并保持着对其“关注”，当恢复后命令他去复制新的<code>master</code>节点</li></ul><p>那么，如何选择“合适”的<code>slave</code>节点呢？</p><ul><li>选择<code>slave-priority</code>(<code>slave</code>节点优先级)最高的<code>slave</code>节点，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的<code>slave</code>节点(复制得最完整)，如果存在则返回，不存在则继续</li><li>选择<code>run_id</code>最小的<code>slave</code>节点(最早的节点)</li></ul><h2>8. 节点下线</h2><p>主节点下线：<code>sentinel failover &lt;masterName&gt;</code></p><p>从节点下线要注意读写分离问题。</p><h2>9. 总结与思考</h2><blockquote><p><code>redis sentinel</code>是<code>redis</code>高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。</p></blockquote><blockquote><p><code>redis sentinel</code>从<code>redis2.8</code>版本才正式生产可用，之前版本不可生产用。</p></blockquote><blockquote><p>尽可能在不同物理机上部署<code>redis sentinel</code>所有节点。</p></blockquote><blockquote><p><code>redis sentinel</code>中的<code>sentinel</code>节点个数应该大于等于3且最好是奇数。</p></blockquote><blockquote><p><code>redis sentinel</code>中的数据节点和普通数据节点没有区别。每个<code>sentinel</code>节点在本质上还是一个<code>redis</code>实例，只不过和<code>redis</code>数据节点不同的是，其主要作用是监控<code>redis</code>数据节点</p></blockquote><blockquote><p>客户端初始化时连接的是<code>sentinel</code>节点集合，不再是具体的<code>redis</code>节点，但<code>sentinel</code>只是配置中心不是代理。</p></blockquote><blockquote><p><code>redis sentinel</code>通过三个定时任务实现了<code>sentinel</code>节点对于主节点、从节点、其余<code>sentinel</code>节点的监控。</p></blockquote><blockquote><p><code>redis sentinel</code>在对节点做失败判定时分为主观下线和客观下线。</p></blockquote><blockquote><p>看懂<code>redis sentinel</code>故障转移日志对于<code>redis sentine</code>l以及问题排查非常有用。</p></blockquote><blockquote><p><code>redis sentinel</code>实现读写分离高可用可以依赖<code>sentinel</code>节点的消息通知，获取<code>redis</code>数据节点的状态变化。</p></blockquote><p><code>redis sentinel</code>可以实现高可用的读写分离，高可用体现在故障转移，那么实现高可用的基础就是要有从节点，主从节点还实现了读写分离，减少<code>master</code>的压力。但是如果是从节点下线了，<code>sentinel</code>是不会对其进行故障转移的，并且连接从节点的客户端也无法获取到新的可用从节点，而这些问题在<code>Cluster</code>中都得到了有效的解决。</p><p>对于性能提高、容量扩展的时候，这种方式是比较复杂的，比较推荐的是使用集群，就是下面讨论的<code>redis cluster</code>!</p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数值计算精度丢失问题</title>
      <link href="/2019/01/31/miscellany/14%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/31/miscellany/14%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>无论在什么业务中，钱是非常重要的东西，对账的时候一定要对的上，不能这边少一分那边多一分。对于数值的计算，尤其是小数，<code>double</code>和<code>double</code>都是禁止使用的。</p><a id="more"></a><blockquote><p>阿里强制要求存放小数时使用 decimal，禁止使用 float 和 double。</p><p>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 <code>decimal</code> 的范围，建议将数据拆成整数和小数分开存储。</p></blockquote><p>处理方式可以为：<code>mysql</code> 可以用 <code>decimal</code> ，如果你是用 <code>java</code>， 在商业计算中我们要用 <code>java.math.BigDecimal</code>，注意：如果需要精确计算，非要用<code>String</code>来够造<code>BigDecimal</code>不可！</p><p>那么到底是什么情况？</p><h2>一个例子说明</h2><p>废话不多说，上图：</p><p><img src="http://bloghello.oursnail.cn/zaji8-1.png" alt="image"></p><h2>问题原因</h2><p>无论是我们本文提到的<code>double</code>，还是<code>float</code>，都是浮点数。</p><p>在计算机科学中，浮点（英语：<code>floating point</code>，缩写为FP）<strong>是一种对于实数的近似值数值表现法</strong>，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（<code>floating-point number</code>）。</p><p>其实我觉得很好理解，我们之前说过，计算机计算加减乘除啊，都是用的加法器，实质都是二进制的加法处理。那么这里就有一个二进制表示的问题。试想，4，2，8之流都是2的幂次方，可以完美用二进制表示，计算当然不会出现问题。对于0，1，3，5之类也都可以用二进制来表示出来，所以，正数肯定是没问题的。</p><p>但是对于小数呢？1、0.5、0.25那都是可以转换成二进制的小数，如十进制的0.1，就无法用二进制准确的表示出来。因此只能使用近似值的方式表达。</p><p><img src="http://bloghello.oursnail.cn/zaji8-2.png" alt="image"></p><p>如果我们尝试着把10进制的0.1转化成二进制，会怎么转呢？</p><p>在十进制中，0.1如何计算出来的呢？</p><blockquote><p>0.1 = 1 ÷ 10</p></blockquote><p>那么二进制中也是同理：</p><blockquote><p>1 ÷ 1010</p></blockquote><p>我们回到小学的课堂，来列竖式吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       0.000110011...</span><br><span class="line">      ------------------</span><br><span class="line">1010 ) 1 0000</span><br><span class="line">         1010</span><br><span class="line">       ------</span><br><span class="line">          1100</span><br><span class="line">          1010</span><br><span class="line">          ----</span><br><span class="line">            10000</span><br><span class="line">             1010</span><br><span class="line">            -----</span><br><span class="line">              1100</span><br><span class="line">              1010</span><br><span class="line">              ----</span><br><span class="line">                10</span><br></pre></td></tr></table></figure><p>很显然，除不尽，除出了一个无限循环小数：二进制的 0.0001100110011…</p><p>那么，如何在计算机中表示这个无限不循环的小数呢？只能考虑按照不同的精度保理不同的位数。</p><p>我们知道float是单精度的，double是双精度的。不同的精度，其实就是保留的有效数字位数不同，保留的位数越多，精度越高。</p><p>所以，浮点数在Java中是无法精确表示的，因为大部分浮点数转换成二进制是一个无限不循环的小数，只能通过保留精度的方式进行近似表示。</p><h2>问题的解决</h2><p><code>String</code> 构造方法是完全可预知的：写入 <code>newBigDecimal(&quot;0.1&quot;)</code> 将创建一个 <code>BigDecimal</code>，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用<code>String</code>构造方法。</p><p>使用<code>BigDecimal(String val)</code>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.add(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">sub</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.subtract(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">mul</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.multiply(b2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(<span class="keyword">double</span> v1,<span class="keyword">double</span> v2)</span></span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.divide(b2,<span class="number">2</span>,BigDecimal.ROUND_HALF_UP);<span class="comment">//四舍五入,保留2位小数,应对除不尽的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，上面的精度丢失问题就迎刃而解了。但是除不尽怎么办？比如10.0除以这里的3.0，保留小数点后三位有效数字：</p><p><img src="http://bloghello.oursnail.cn/zaji8-3.png" alt="image"></p><p>那么，每个用户得到的都是3.333元，三个用户加起来是得不到10块钱的。</p><p>对于除法，始终会产生除不尽的情况怎么办？有个词叫轧差</p><p>什么意思呢？举个简单例子。假如现在需要把10元分成3分，如果是10除以3这么除，会发现为3.33333无穷尽的3。这些数字完全无法在程序或数据库中进行精确的存储。</p><p>简单理解就是，当除不尽或需去除小数点的时候，前面的n-1笔（这里n=3）做四舍五入。最后一笔做兜底（总金额减去前面n-1笔之和）。这样保证总金额的不会丢失。</p><p>比如10块钱，三个用户分，前面两个用户只能各分到3。333块钱，最后一个用户分到3.334块钱。保证总额不变。</p><p>至于原理，有一点点数学化，以后再作探讨吧。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis主从复制</title>
      <link href="/2019/01/31/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/01/31/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第六篇文章。介绍redis主从复制功能实现原理。作为高可用的基础，了解一下其中的门道是有必要的。</p><a id="more"></a><h2>1.单机有什么问题</h2><ul><li>机器故障</li><li>容量瓶颈</li><li>QPS瓶颈</li></ul><h2>2. 主从复制的作用</h2><ul><li>数据副本</li><li>扩展读性能，<code>slave</code>专门用来读</li><li>一个<code>master</code>可以有多个<code>slave</code>，一个<code>salve</code>只能有一个<code>master</code></li></ul><h2>3. 两种实现方式</h2><ul><li>方式一：<code>slaveof</code>命令<ul><li><code>slaveof masterIp masterPort</code></li><li><code>slaveof no one</code>(不会清除原来同步的数据，而是新的数据不会再同步给他)</li></ul></li><li>方式二：配置<ul><li>修改某一行的配置：<code>slaveof ip port</code></li><li>从节点只做读操作：<code>slave-read-only yes</code></li></ul></li><li>对比<ul><li>命令的优点：不需要重启</li><li>命令的缺点：不便于管理</li><li>配置的优点：统一配置</li><li>配置的缺点：需要重启</li></ul></li></ul><p>一个场景，假如6380是6379的一个从节点，然后将6380执行<code>salveof no one</code>，然后插入一些新的数据；再重新变成6379的从节点，那么里面的新数据会被清除掉。</p><ul><li>查看run_id<ul><li><code>redis-cli -p 6379 info server | grep run</code></li></ul></li></ul><h2>4. 全量复制</h2><ul><li>全量复制开销<ul><li>bgsave时间</li><li>rdb网络传输时间</li><li>从节点清空数据的时间</li><li>从节点加载RDB的时间</li><li>可能的AOF重写时间</li></ul></li><li>存在的问题<ul><li>时间开销比较大</li><li>如果<code>master</code>和<code>slave</code>之间网络扰动甚至断开，那么<code>master</code>此间更新的数据对于<code>slave</code>是不知道的，最简单的方法就是再进行一次全量复制，但是显然，消耗太大了。</li></ul></li></ul><p><img src="http://bloghello.oursnail.cn/%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png" alt="image"></p><h2>5. 部分复制</h2><p><img src="http://bloghello.oursnail.cn/%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6.png" alt="image"></p><h2>6. 开发与运维的问题</h2><ul><li>读写分离</li></ul><p><code>master</code>只做写操作，<code>slave</code>来做读操作，来分摊流量。但是会有一些问题：</p><blockquote><p>复制数据延迟</p><p>读到过期数据</p><p>从节点故障</p></blockquote><ul><li>主从配置不一致</li></ul><blockquote><p>例如<code>maxmemory</code>不一致：丢失数据</p><p>数据结构优化参数：内存不一致</p></blockquote><ul><li>规避全量复制</li></ul><blockquote><p>第一次全量复制：不可避免—小主节点(<code>maxmemroy</code>不要太大)或者在低峰时进行操作</p><p>节点<code>run_id</code>不匹配（主节点重启，那么<code>master</code>的<code>run_id</code>会发生变化，<code>slave</code>发现其<code>run_id</code>变化，会进行全量复制）；我们可以用故障转移，例如哨兵或集群来避免全量复制。</p><p>复制积压缓冲区不足(网络中断，部分复制无法满足)，可以增大复制缓冲区配置<code>size</code>，网络增强</p></blockquote><ul><li>规避复制风暴</li></ul><blockquote><p>概念：主节点宕机造成大量的全量复制</p><p>单主节点复制风暴：主节点重启，多从节点复制；解决：更换复制拓扑</p><p>单机器复制风暴：机器宕机后（该机器全是<code>Mater</code>），大量全量复制。解决：<code>master</code>分散多机器。</p></blockquote><p>说到底，还是需要有一种高可用的实现方式，在<code>master</code>出现故障之后，如何自动实现从<code>slave</code>晋升为<code>master</code>继续使用.而不是一直死守着原来老的<code>master</code>不放，因为老的<code>master</code>啥时候恢复不知道，恢复了可能会造成复制风暴，既然从节点本来是一直与<code>master</code>节点保持尽量的同步的，那么为什么不将数据最新的从节点升级为主节点呢？下一章继续来分析。</p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2019/01/31/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2019/01/31/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第五篇文章。redis处理数据都是在内存中进行，所以速度特别快，同样，它也可以支持持久化，这里注意，并不是说redis要来充当mysql那种角色，其实更多的是为了在崩溃的时候快速恢复以及主从复制这样的功能。redis的持久化主要有两种方式，一种是RDB，一种是AOF，对于他们的原理和区别都是比较重要的面试考察点，需要掌握。</p><a id="more"></a><h2>1. 什么是持久化</h2><p><code>redis</code>所有数据保持在内存中，对数据的更新将异步地保存到磁盘中。</p><h2>2. 持久化的方式</h2><p>快照—<code>mysql dump</code>或者<code>redis rdb</code></p><p>写日志—<code>mysql binlog</code>或者<code>hbase glog</code>或者<code>redis aof</code></p><h2>3. RDB</h2><h4>什么是RDB</h4><p><img src="http://bloghello.oursnail.cn/%E4%BB%80%E4%B9%88%E6%98%AFRDB.png" alt="image"></p><h4>触发机制三种主要方式</h4><ul><li>save(<strong>同步持久化，会造成redis主线程的阻塞，不推荐使用</strong>)</li></ul><p><code>save</code>是同步的，当保存的数据量很大时，可能造成<code>redis</code>的阻塞，即客户端访问<code>redis</code>被阻塞。</p><p><img src="http://bloghello.oursnail.cn/save%E5%91%BD%E4%BB%A4.png" alt="image"></p><p>他的文件策略是：如果存在老的<code>RDB</code>文件，则新的替换老的。复杂度为<code>O(n)</code>。</p><ul><li>bgsave(<strong>异步，fork一个子进程来进行持久化，不会造成主线程的阻塞</strong>)</li></ul><p>一般情况下，<code>fork</code>是比较快的，但是也可以会慢，这时会阻塞<code>redis</code>。只要<code>fork</code>不慢，客户端不会被阻塞。</p><p><img src="http://bloghello.oursnail.cn/newbgsave.png" alt="image"></p><p>他的文件策略和复杂度与save是一样的。</p><p><code>save</code>和<code>bgsave</code>两者对比：</p><p><img src="http://bloghello.oursnail.cn/save%E5%92%8Cbgsave%E5%AF%B9%E6%AF%94.png" alt="image"></p><ul><li>自动</li></ul><p><code>redis</code>的自动保存的默认配置是：</p><table><thead><tr><th>配置</th><th>seconds</th><th>changes</th></tr></thead><tbody><tr><td>save</td><td>900</td><td>1</td></tr><tr><td>save</td><td>300</td><td>10</td></tr><tr><td>save</td><td>60</td><td>10000</td></tr></tbody></table><p>就是说，在60秒内改变了10000条数据，就自动保存；在300秒内有10条改变才自动保存；900秒内有1一条改变就保存。</p><h4>RDB总结</h4><ol><li><code>RDB</code>是<code>Redis</code>内存到硬盘的快照，用于持久化。</li><li><code>save</code>通常会阻塞<code>redis</code>。</li><li><code>bgsave</code>不会阻塞<code>redis</code>，但是会<code>fork</code>新进程。</li><li><code>save</code>自动配置满足任一就会被执行。</li><li>有些触发机制不容忽视。</li></ol><h2>4. AOF</h2><h4>RDB问题</h4><ul><li>全量数据存入磁盘</li></ul><p><code>O(n)</code>数据的备份，很耗时间；对于<code>bgsave</code>来说，<code>fork()</code>是一个很消耗内存的操作；将数据全写到硬盘，必然对硬盘IO占用很大。</p><ul><li>宕机丢失数据多</li></ul><p>还有一点是：<strong>某个时间点宕机，那么在某个时间段的数据就丢失了</strong>。</p><h4>AOF原理</h4><p>将对<code>redis</code>的操作追加到<code>aof</code>文件中。当<code>redis</code>宕机之后，使用<code>aof</code>恢复所有的操作继而实现数据的恢复。</p><h4>AOF三种策略</h4><ul><li>always</li></ul><p><img src="http://bloghello.oursnail.cn/aof-always.png" alt="image"></p><ul><li>everysec</li></ul><p><img src="http://bloghello.oursnail.cn/aof-everysec.png" alt="image"></p><p><code>redis</code>出现故障，有可能丢失一秒的数据。<code>redis</code>默认方式。</p><ul><li>no</li></ul><p><img src="http://bloghello.oursnail.cn/aof-no.png" alt=""></p><h4>三种策略的比较</h4><p><img src="http://bloghello.oursnail.cn/aof%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="image"></p><h4>AOF重写</h4><p><img src="http://bloghello.oursnail.cn/AOF%E9%87%8D%E5%86%99.png" alt="image"></p><p>好处是：减少硬盘占用、减少数据丢失</p><p>下面是AOF的<code>bgrewirteaof</code>的过程：</p><p><img src="http://bloghello.oursnail.cn/bgrewriteaof.png" alt="image"></p><p>注意：这里的重写并不是上面演示的，将原来的<code>aof</code>文件进行重写，而是根据<code>redis</code>现在的内存数据进行一次回溯。</p><h4>aof重写流程</h4><p><img src="http://bloghello.oursnail.cn/aof%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" alt="image"></p><p>也就是说，子进程在执行 AOF 重写时，主进程需要执行以下三个工作：</p><ul><li>1.处理命令请求；</li><li>2.将写命令追加到现有的 AOF 文件中；</li><li>3.将写命令追加到 AOF 重写缓存中。</li></ul><p>如此可以保证：</p><ul><li>现有的AOF功能继续执行，即使 AOF 重写期间发生停机，也不会有任何数据丢失；</li><li>所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。</li></ul><p>当子进程完成对 AOF 文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：(阻塞)</p><ul><li>将 AOF 重写缓存中的内容全部写入到新的 AOF 文件中；(现有 AOF 文件、新的 AOF 文件和数据库三者的状态就完全一致了)</li><li>对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。(执行完毕后，程序就完成了新旧两个 AOF 文件的替换)</li></ul><p>当这个信号处理函数执行完毕之后，主进程就可以继续像往常一样接收命令请求了。在整个 AOF 后台重写过程中，<strong>只有最后的“主进程写入命令到AOF缓存”和“对新的 AOF 文件进行改名，覆盖原有的 AOF 文件”这两个步骤会造成主进程阻塞，在其他时候， AOF 后台重写都不会对主进程造成阻塞，这将 AOF 重写对性能造成的影响降到最低。</strong></p><p>小结：</p><ul><li>AOF 重写的目的是轻量地保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求；</li><li>AOF在redis宕机的时候最多丢失一秒的数据，比RDB要好一点，并且可读性高，基本上能看得懂</li><li>AOF 重写其实是一个有歧义的名字，实际上重写工作是针对数据库的当前值来进行的，重写过程中不会读写、也不适用原来的 AOF 文件；</li><li>AOF 可以由用户手动触发，也可以由服务器自动触发。</li></ul><h2>5. 持久化的取舍和选择</h2><h4>RDB和AOF对比</h4><p><img src="http://bloghello.oursnail.cn/RDB%E5%92%8CAOF%E5%AF%B9%E6%AF%94.png" alt="image"></p><p>可以看出，世界上没有完美的东西，只有合适的东西。AOF同样存在一些问题：AOF文件的体积通常要大于RDB文件的体积、且恢复速度慢。</p><h4>RDB最佳策略</h4><p>“关”：建议关闭，但是后面主从复制功能是需要他的，因为需要主节点执行<code>dbsave</code>，然后将<code>rdb</code>文件传给从节点。所以说，关不是永久关。</p><p><strong>“集中管理”：虽然<code>RDB</code>很重，但是对于数据备份是很重要的，按照小时或者天集中地进行备份比较好，因为他的文件很小，利于传输。</strong></p><p>“主从，从开”：有时候从节点打开这个功能是比较好的，但是备份太频繁，取决于实际的场景。</p><h4>AOF最佳策略</h4><ul><li>“开”：建议打开，如果仅仅是作为一个普通缓存，对于数据要求不是很高，这次数据丢了，下次可以从数据库取(数据库压力不是很大)，这种情况就建议关闭，因为<code>AOF</code>还是有性能开销的。</li><li>“everysec”</li></ul><h4>Redis4</h4><p><code>Redis 4.0</code> 新增了 <code>RDB-AOF</code> 混合持久化格式， 这是一个可选的功能，</p><p>在开启了这个功能之后， <code>AOF</code> 重写产生的文件将同时包含 <code>RDB</code> 格式的内容和 <code>AOF</code> 格式的内容， 其中 <code>RDB</code> 格式的内容用于记录已有的数据， 而 <code>AOF</code> 格式的内存则用于记录最近发生了变化的数据， 这样 <code>Redis</code> 就可以同时兼有 <code>RDB</code> 持久化和 <code>AOF</code> 持久化的优点 —— 既能够快速地生成重写文件， 也能够在出现问题时， 快速地载入数据。</p><p>RDB和AOF共存的情况下如何恢复数据：</p><p><img src="http://bloghello.oursnail.cn/redis5-1.png" alt="image"></p><ul><li>优点：<ul><li>混合持久化结合了<code>RDB</code>持久化 和 <code>AOF</code> 持久化的优点,</li><li>由于绝大部分都是<code>RDB</code>格式，加载速度快，同时结合<code>AOF</code>，增量的数据以<code>AOF</code>方式保存了，数据更少的丢失。</li></ul></li><li>缺点：<ul><li>兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该<code>aof</code>文件，同时由于前部分是<code>RDB</code>格式，阅读性较差</li></ul></li></ul><p>策略是：</p><h2>6. 总结</h2><ul><li><a href="http://www.ywnds.com/?p=4876" target="_blank" rel="noopener">http://www.ywnds.com/?p=4876</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入Nginx原理</title>
      <link href="/2019/01/30/miscellany/13%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Nginx%E5%8E%9F%E7%90%86/"/>
      <url>/2019/01/30/miscellany/13%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Nginx%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Nginx是一个高性能的HTTP和反向代理服务器，及电子邮件（IMAP/POP3）代理服务器，同时也是一个非常高效的反向代理、负载平衡中间件。是非常常用的web server.我们需要理解它的原理，才能达到游刃有余的程度。</p><a id="more"></a><p>本篇文章需要对Nginx有基本的使用以及对IO复用模型有一定的了解。文章比较长。</p><h2>1.正向代理和反向代理</h2><p><img src="http://xiaozhao.oursnail.cn/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="image"></p><p><strong>正向代理的工作原理就像一个跳板</strong>，比如：我访问不了<code>google.com</code>，但是我能访问一个代理服务器A，A能访问<code>google.com</code>，于是我先连上代理服务器A，告诉他我需要<code>google.com</code>的内容，A就去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p><p><img src="http://xiaozhao.oursnail.cn/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="image"></p><p>反向代理（<code>Reverse Proxy</code>）方式是指以代理服务器来接受<code>internet</code>上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给<code>internet</code>上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p><p>简单来说：</p><ul><li>正向代理是不知道客户端是谁，代理是一个跳板，所有客户端通过这个跳板来访问到对应的内容。</li><li>反向代理是不知道服务端是谁，用户的请求被转发到内部的某台服务器去处理。</li></ul><h2>2.基本的工作流程</h2><p><img src="http://xiaozhao.oursnail.cn/nginx%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="image"></p><ol><li>用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址；</li><li>反向代理服务器接受用户的请求；</li><li>反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</li><li>如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是缓存的还会把它保存到缓存中。</li></ol><h2>3.优点</h2><ul><li>保护了真实的web服务器，保证了web服务器的资源安全</li><li>节约了有限的IP地址资源</li><li>减少WEB服务器压力，提高响应速度(缓存功能)</li><li>请求的统一控制，包括设置权限、过滤规则等</li><li>实现负载均衡</li><li>区分动态和静态可缓存内容</li><li>…</li></ul><h2>4.使用场景</h2><ul><li>Nginx作为Http代理、反向代理</li><li>Nginx作为负载均衡器</li><li>Ip hash算法，对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。</li><li>Nginx作为Web缓存</li></ul><h2>5.Nginx的Master-Worker模式</h2><p><img src="http://xiaozhao.oursnail.cn/Nginx%E7%9A%84Master-Worker%E6%A8%A1%E5%BC%8F.png" alt="image"></p><p>启动<code>Nginx</code>后，其实就是在80端口启动了<code>Socket</code>服务进行监听，如图所示，<code>Nginx</code>涉及<code>Master</code>进程和<code>Worker</code>进程。</p><p><img src="http://xiaozhao.oursnail.cn/Master-Worker%E6%A8%A1%E5%BC%8F.png" alt="image"></p><h2>6.Master进程的作用是？</h2><p>读取并验证配置文件<code>nginx.conf</code>；管理<code>worker</code>进程；</p><ul><li>接收来自外界的信号</li><li>向各worker进程发送信号</li><li>监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程</li></ul><h2>7.Worker进程的作用是？</h2><p>每一个<code>Worker</code>进程都维护一个线程（避免线程切换），处理连接和请求；注意<code>Worker</code>进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个<code>Worker</code>进程。</p><h5>思考：Nginx如何做到热部署？</h5><blockquote><p>所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载/nginx -t检查配置/nginx -s stop）</p><p>通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p>方案一：</p><p>修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点volatile的味道）</p><p>方案二：</p><p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p></blockquote><p>Nginx采用的就是方案二来达到热部署的！</p><h5>思考：Nginx如何做到高并发下的高效处理？</h5><blockquote><p>上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p><p>作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞…</p><p>要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</p><p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</p></blockquote><h5>思考：Nginx挂了怎么办？</h5><blockquote><p>Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p><p>答案是：Keepalived+Nginx实现高可用。</p><p>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</p><p>Keepalived+Nginx实现高可用的思路：</p><p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p><p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,从而实现Nginx故障切换）</p></blockquote><p><img src="http://xiaozhao.oursnail.cn/Keepalived+Nginx.png" alt="image"></p><h2>6.nginx.conf</h2><p><img src="http://xiaozhao.oursnail.cn/nginx.conf.png" alt="image"></p><ul><li>第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</li><li>第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。</li><li>第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</li><li>第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。</li></ul><p>除了可以映射静态资源，上面已经说了，可以作为一个代理服务器来使用。</p><blockquote><p>所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理，上面已经说了，过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。</p></blockquote><p>负载均衡【upstream】</p><blockquote><p>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><p>第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</p><p>第二，将proxy_pass替换成upstream指定的值即可。</p><p>负载均衡可能带来的问题？</p><p>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</p></blockquote><h2>7.惊群现象</h2><p>定义：惊群效应就是当一个fd的事件被触发时，所有等待这个fd的线程或进程都被唤醒。</p><p><code>Nginx</code>的IO通常使用<code>epoll</code>，<code>epoll</code>函数使用了I/O复用模型。与I/O阻塞模型比较，I/O复用模型的优势在于可以同时等待多个（而不只是一个）套接字描述符就绪。<code>Nginx</code>的<code>epoll</code>工作流程如下：</p><ul><li>master进程先建好需要listen的socket后，然后再fork出多个woker进程，这样每个work进程都可以去accept这个socket</li><li>当一个client连接到来时，所有accept的work进程都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败，Nginx提供了一把<strong>共享锁accept_mutex</strong>来保证同一时刻只有一个work进程在accept连接，从而解决惊群问题</li><li>当一个worker进程accept这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了</li></ul><h2>8.Nginx架构及工作流程</h2><p><img src="http://xiaozhao.oursnail.cn/Nginx%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p><p><code>Nginx</code>真正处理请求业务的是<code>Worker</code>之下的线程。<code>worker</code>进程中有一个<code>ngx_worker_process_cycle()</code>函数，执行无限循环，不断处理收到的来自客户端的请求，并进行处理，直到整个<code>Nginx</code>服务被停止。</p><p>当一个 <code>worker</code> 进程在 <code>accept()</code> 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个完整的请求。一个请求，完全由 <code>worker</code> 进程来处理，而且只能在一个 <code>worker</code> 进程中处理。</p><p>这样做带来的好处：</p><ol><li>节省锁带来的开销。每个 <code>worker</code> 进程都是独立的进程，不共享资源，不需要加锁。同时在编程以及问题查上时，也会方便很多。</li><li>独立进程，减少风险。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，<code>master</code> 进程则很快重新启动新的 <code>worker</code> 进程。当然，<code>worker</code> 进程的也能发生意外退出。</li></ol><h2>9.nginx为什么高性能</h2><p><strong>因为nginx是多进程单线程的代表，多进程模型每个进程/线程只能处理一路IO，那么 Nginx是如何处理多路IO呢？</strong></p><p>如果不使用 IO 多路复用，那么在一个进程中，同时只能处理一个请求，比如执行 <code>accept()</code>，如果没有连接过来，那么程序会阻塞在这里，直到有一个连接过来，才能继续向下执行。</p><p>而多路复用，允许我们只在事件发生时才将控制返回给程序，而其他时候内核都挂起进程，随时待命。</p><p><strong>核心：Nginx采用的 IO多路复用模型epoll</strong></p><p><code>epoll</code>通过在<code>Linux</code>内核中申请一个简易的文件系统（文件系统一般用什么数据结构实现？B+树），其工作流程分为三部分：</p><ol><li>调用 <code>int epoll_create(int size)</code>建立一个<code>epoll</code>对象，内核会创建一个<code>eventpoll</code>结构体，用于存放通过<code>epoll_ctl()</code>向<code>epoll</code>对象中添加进来的事件，这些事件都会挂载在红黑树中。</li><li>调用 <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code> 在 <code>epoll</code> 对象中为 fd 注册事件，所有添加到<code>epoll</code>中的事件都会与设备驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个<code>sockfd</code>的回调方法，将<code>sockfd</code>添加到<code>eventpoll</code> 中的双链表</li><li>调用 <code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code> 来等待事件的发生，<code>timeout</code> 为 -1 时，该调用会阻塞直到有事件发生</li></ol><p>这样，注册好事件之后，只要有 fd 上事件发生，<code>epoll_wait()</code> 就能检测到并返回给用户，用户就能”非阻塞“地进行 I/O 了。</p><p><code>epoll()</code> 中内核则维护一个链表，<code>epoll_wait</code> 直接检查链表是不是空就知道是否有文件描述符准备好了。（<code>epoll</code> 与 <code>select</code> 相比最大的优点是不会随着 <code>sockfd</code> 数目增长而降低效率，使用 <code>select()</code> 时，内核采用轮训的方法来查看是否有fd 准备好，其中的保存 <code>sockfd</code> 的是类似数组的数据结构 <code>fd_set</code>，key 为 fd，value 为 0 或者 1。）</p><p>能达到这种效果，是因为在内核实现中 <code>epoll</code> 是根据每个 <code>sockfd</code> 上面的与设备驱动程序建立起来的回调函数实现的。那么，某个 <code>sockfd</code> 上的事件发生时，与它对应的回调函数就会被调用，来把这个 <code>sockfd</code> 加入链表，其他处于“空闲的”状态的则不会。在这点上，<code>epoll</code> 实现了一个”伪”AIO。但是如果绝大部分的 I/O 都是“活跃的”，每个 <code>socket</code> 使用率很高的话，<code>epoll</code>效率不一定比 <code>select</code> 高（可能是要维护队列复杂）。</p><p>可以看出，因为一个进程里只有一个线程，所以一个进程同时只能做一件事，但是可以通过不断地切换来“同时”处理多个请求。</p><p>例子：<code>Nginx</code> 会注册一个事件：“如果来自一个新客户端的连接请求到来了，再通知我”，此后只有连接请求到来，服务器才会执行 <code>accept()</code> 来接收请求。又比如向上游服务器（比如 PHP-FPM）转发请求，并等待请求返回时，这个处理的 <code>worker</code> 不会在这阻塞，它会在发送完请求后，注册一个事件：“如果缓冲区接收到数据了，告诉我一声，我再将它读进来”，于是进程就空闲下来等待事件发生。</p><p>这样，基于 多进程+epoll， Nginx 便能实现高并发。</p><h2>10.几种负载均衡的算法介绍</h2><blockquote><p>轮询（默认）</p></blockquote><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><blockquote><p>weight</p></blockquote><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><blockquote><p>ip_hash</p></blockquote><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问同一个后端服务器，可以解决session的问题。但是不能解决宕机问题。<br>前三种是nginx自带的，直接在配置文件中配置即可使用。</p><blockquote><p>fair（第三方）</p></blockquote><p>按后端服务器的相应时间来分配请求，相应时间短的优先分配。</p><blockquote><p>url_hash（第三方）</p></blockquote><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><h2>11.基于不同层次的负载均衡</h2><p><img src="http://bloghello.oursnail.cn/http1-6.png" alt="image"></p><p>七层就是基于URL等应用层信息的负载均衡；<br>同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。</p><p>换句话说:</p><ul><li>二层负载均衡会通过一个虚拟MAC地址接受请求，然后再分配到真是的MAC地址；</li><li>三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；</li><li>四层通过虚拟的URL或主机名接收请求，然后再分配到真是的服务器。</li></ul><p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。</p><p>比如四层的负载均衡，就是通过发布三层的IP地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。</p><p>七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p><p>负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。</p><p>负载均衡设备也常被称为&quot;四到七层交换机&quot;，那么四层和七层两者到底区别在哪里？</p><blockquote><p>第一，技术原理上的区别。</p></blockquote><p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><blockquote><p>第二，应用场景的需求。</p></blockquote><p>七层应用负载的好处，是使得整个网络更&quot;智能化&quot;。例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。</p><p>另外一个常常被提到功能就是安全性。</p><h2>12.总结</h2><ol><li>理解正向代理和反向代理的概念</li><li>nginx的优点和使用场景</li><li>master和work两种进程的作用</li><li>如何热部署</li><li>Nginx单点故障的预防</li><li>映射静态文件、反向代理跳转到后端服务器处理的写法</li><li>惊群现象</li><li>Nginx 采用的是多进程（单线程） &amp; 多路IO复用模型(底层依靠epoll实现)</li><li>几种负载均衡的算法</li><li>四层的负载均衡和七层的负载均衡</li></ol>]]></content>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis为什么快</title>
      <link href="/2019/01/30/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/"/>
      <url>/2019/01/30/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第四篇文章，本文主要攻克面试题-Redis为什么这么快。这就涉及Redis的线程模型啦。</p><a id="more"></a><h2>完全基于内存</h2><p><code>Redis</code>是纯内存数据库，相对于读写磁盘，读写内存的速度就不是几倍几十倍了，一般，<code>hash</code>查找可以达到每秒百万次的数量级。</p><h2>多路复用IO</h2><p>“多路”指的是多个网络连接，“复用”指的是复用同一个线程。<strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗）。</p><h2>Redis为什么是单线程的？</h2><p>因为CPU不是<code>Redis</code>的瓶颈。<code>Redis</code>的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><h2>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</h2><p>首先，<code>Redis</code> 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p><blockquote><p>假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ol><li><p>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p></li><li><p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</p></li><li><p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。</p></li></ol><p>第三种就是IO复用模型，<code>Linux</code>下的<code>select</code>、<code>poll</code>和<code>epoll</code>就是干这个的。<strong>将用户<code>socket</code>对应的<code>fd</code>注册进<code>epoll</code>，然后<code>epoll</code>帮你监听哪些<code>socket</code>上有消息到达</strong>，这样就避免了大量的无用操作。此时的<code>socket</code>应该采用非阻塞模式。这样，整个过程只在调用<code>select</code>、<code>poll</code>、<code>epoll</code>这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的<code>reactor</code>模式。</p></blockquote><p>所以，I/O多路复用的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。</p><p>这里还涉及一个名词：<strong>fd文件描述符。</strong></p><p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p><h2>redis的线程模型？</h2><p><code>Redis</code> 服务采用 <code>Reactor</code> 的方式来实现文件事件处理器。</p><p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p><p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 <code>Redis</code> 服务实现的简单。</p><p><img src="http://bloghello.oursnail.cn/redis%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86111.png-1000width" alt="image"></p><p>上面简单理解就是：多个网络连接并发读写redis的时候，先将对应的fd注册到<code>epoll</code>上，I/O多路复用模块会监听这些网络请求的情况，一旦有一个网络连接产生了<code>accept</code>、<code>read</code>、<code>write</code> 和 <code>close</code> 文件事件，I/O多路复用模块就会向文件事件分派器传送那些产生了事件的网络连接。</p><p><img src="http://bloghello.oursnail.cn/redis4-1.png" alt="image"></p><p>当然了，上面的文件事件可能会并发产生，这时的策略是，将所有产生事件的套接字（对应上面的网络连接）都入队到一个队列里面， 然后通过这个队列， 以有序（<code>sequentially</code>）、同步（<code>synchronously</code>）、每次一个套接字的方式向文件事件分派器传送套接字： 当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。再看看下图，与上图使一样的：</p><p><img src="http://bloghello.oursnail.cn/redis4-2.png" alt="image"></p><p>文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。</p><p>服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。</p><p><strong>整个模块使 <code>Redis</code> 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性，单线程还减少线程切换和调度，实现更加简单</strong></p><p><strong>最后总结一下</strong>，为什么<code>redis</code>比较快大概思路通俗的说就是：<code>Redis</code>是纯内存数据库，读取快，瓶颈在于IO上，如果使用阻塞式IO，因为是单线程的缘故，就会停止等待。所以采用IO多路复用监听文件描述符的状态，将对<code>redis</code>的开关读写换成事件，加入队列进行相应的事件处理，吞吐量比较大。</p><h2>IO复用模型的选择</h2><p>因为 Redis 需要在多个平台上运行，同时为了最大化执行的效率与性能，所以会根据编译平台的不同选择不同的 I/O 多路复用函数作为子模块，提供给上层统一的接口；</p><p>因为 <code>select</code> 函数是作为 <code>POSIX</code> 标准中的系统调用，在不同版本的操作系统上都会实现，所以将其作为保底方案：</p><p><img src="http://bloghello.oursnail.cn/redis4-3.png" alt="image"></p><p><code>Redis</code> 会优先选择时间复杂度为 <code>O(1)</code> 的 I/O 多路复用函数作为底层实现，包括 <code>Solaries 10</code> 中的 <code>evport</code>、<code>Linux</code> 中的 <code>epoll</code> 和 <code>macOS/FreeBSD</code> 中的 <code>kqueue</code>，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。</p><p>但是如果当前编译环境没有上述函数，就会选择 <code>select</code> 作为备选方案，由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 <code>O(n)</code>，并且只能同时服务 1024 个文件描述符，所以一般并不会以 <code>select</code> 作为第一方案使用。</p><h2>reids在linux下的安装</h2><p><code>Redis</code>对于<code>Linux</code>是官方支持的，安装起来也非常地简单，直接编译源码然后进行安装即可。</p><p>这里以<code>centos</code>为例，大概说一下步骤：</p><blockquote><p>下载redis编译工具:<code>yum install gcc</code>和<code>yum install g++</code></p></blockquote><blockquote><p>解压<code>redis.tar.gz</code>文件，进去之后进行编译:<code>make</code></p></blockquote><blockquote><p>然后安装：<code>make install PREFIX=/usr/local/redis</code></p></blockquote><blockquote><p>安装成功之后进入<code>/usr/local/redis/bin</code>下启动<code>redis</code></p><p><code>./redis-server</code></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis其他的功能介绍</title>
      <link href="/2019/01/29/redis/Redis%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/01/29/redis/Redis%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第三篇文章，本文主要介绍redis一些其他的功能。遇到某些场景的时候可以想到redis是不是可以实现。</p><a id="more"></a><h2>一、慢查询日志</h2><h4>1.1 什么是慢查询日志</h4><p>慢查询日志帮助开发和运维人员定位系统存在的慢操作。慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（慢查询ID，发生时间戳，耗时，命令的详细信息）记录下来。</p><h4>1.2 redis一条命令简单的生命周期</h4><p><img src="http://xiaozhao.oursnail.cn/redis%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image"></p><p>慢查询只会出现在【<strong>3.执行命令</strong>】这个阶段，即慢查询只记录命令执行时间，并不包括命令排队时间和网络传输时间。</p><h4>1.3 慢查询配置参数</h4><blockquote><p>慢查询的预设阀值  <code>slowlog-log-slower-than</code></p></blockquote><ul><li><code>slowlog-log-slower-than</code>参数就是预设阀值，单位是微秒,默认值是10000，如果一条命令的执行时间超过10000微妙(10毫秒)，那么它将被记录在慢查询日志中。</li><li>如果<code>slowlog-log-slower-than</code>的值是0，则会记录所有命令。</li><li>如果<code>slowlog-log-slower-than</code>的值小于0，则任何命令都不会记录日志。</li><li><code>redis</code>的操作一般是微妙级，<code>slowlog-log-slower-than</code>不要设置太大，一般设置为1毫秒。支持动态设置。</li></ul><blockquote><p>慢查询日志的长度<code>slowlog-max-len</code></p></blockquote><ul><li><code>slowlog-max-len</code>只是说明了慢查询日志最多存储多少条。</li><li><code>Redis</code>使用一个列表来存储慢查询日志，<code>showlog-max-len</code>就是列表的最大长度。</li><li>当慢查询日志已经到达列表的最大长度时，又有慢查询日志要进入列表，则最早插入列表的日志将会被移出列表，新日志被插入列表的末尾。</li><li>默认是128，但是<code>slowlog-max-len</code>不要设置太小，可以设置为1000以上.</li></ul><p><strong>慢查询日志是一个先进先出队列，慢查询较多的情况下，可能会丢失部分慢查询命令，可以定期执行<code>slow get</code>命令将慢查询日志持久化到其他存储中。然后制作可视化界面查询。</strong></p><h2>二、pipeline</h2><h4>2.1 为什么会出现Pipeline</h4><p>用普通的<code>get</code>和<code>set</code>，如果同时需要执行大量的命令，那就是等待上一条命令应答后再执行，这中间不仅仅多了<code>RTT（Round Time Trip）</code>，而且还频繁的调用系统IO，发送网络请求。</p><p><img src="http://bloghello.oursnail.cn/%E6%89%B9%E9%87%8F%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>对于多条命令不是有<code>mget</code>和<code>mset</code>吗？确实对于一批的<code>get</code>和<code>set</code>可以用<code>mget</code>和<code>mset</code>，但是它的问题在于如果我们需要同时传输<code>get</code>和<code>hget</code>呢？此时<code>pipeline</code>(流水线)就出现了。</p><p><img src="http://bloghello.oursnail.cn/%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="image"></p><p>所以流水线解决的问题是N条命令网络通信的减少。</p><p><img src="http://bloghello.oursnail.cn/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="image"></p><p>为什么说网络耗费时间大呢？这里给出一个极端的例子。</p><p><img src="http://bloghello.oursnail.cn/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%97%B6%E9%97%B4.png" alt="image"></p><p><code>pipeline</code>与原生M操作的对比。</p><ul><li>原生M操作是一个原子操作。</li></ul><p><img src="http://bloghello.oursnail.cn/%E5%8E%9F%E7%94%9FM%E6%93%8D%E4%BD%9C.png" alt="image"></p><ul><li><code>pipeline</code>非原子命令。</li></ul><p><img src="http://bloghello.oursnail.cn/pipeline%E9%9D%9E%E5%8E%9F%E5%AD%90%E5%91%BD%E4%BB%A4.png" alt="image"></p><p>当某个命令的执行需要依赖前一个命令的返回结果时，无法使用<code>pipeline</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset a “a1” b “b” c “c1” </span><br><span class="line">mget a b c</span><br></pre></td></tr></table></figure><p><code>mget</code>和<code>mset</code>命令也是为了减少网络连接和传输时间所设置的，其本质和<code>pipeline</code>的应用区别不大，但是在特定场景下只能用<code>pipeline</code>实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get a</span><br><span class="line">set b ‘1’</span><br></pre></td></tr></table></figure><p><code>pipeline</code>适合执行这种连续，且无相关性的命令。</p><h4>2.2 一个demo</h4><p>搭建一个<code>quickstart</code>的<code>maven</code>工程。过程略。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接再单元测试中进行测试：普通的直接<code>hset</code> 10000条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">        jedis.hset(<span class="string">"hashkey"</span>+i,<span class="string">"filed"</span>+i,<span class="string">"value"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"一共耗时: "</span>+(after-before)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>一共耗时: 1526ms</p></blockquote><p>但是用pipeline后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//分为10次批量发送</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Pipeline pipeline = jedis.pipelined();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1000</span>*i;j&lt;(i+<span class="number">1</span>)*<span class="number">1000</span>;j++)&#123;</span><br><span class="line">            pipeline.hset(<span class="string">"hashkey:"</span>+j,<span class="string">"field:"</span>+j,<span class="string">"value:"</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        pipeline.syncAndReturnAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用pipeline一共耗时: "</span>+(after-before)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：使用<code>pipeline</code>一共耗时: 139ms</p></blockquote><p>可以预见，对于更多的传输次数，<code>pipeline</code>的优势将越来越明显。但是<code>pipeline</code>每次只能作用在一个<code>redis</code>节点上。</p><h2>三、发布订阅</h2><h4>3.1 角色</h4><p>发布者----频道----订阅者</p><h4>3.2 模型</h4><p><img src="http://bloghello.oursnail.cn/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>注意，新订阅的，是不能收到之前的消息的。</p><ul><li>订阅者1：subscribe mytopic</li><li>订阅者2：subscribe mytopic</li><li>订阅者3：subscribe mytopic</li><li>发布者：publish mytopic “hello”</li></ul><p>缺点是不能保证消息可达，所以还是用专业的消息队列传达比较保障。</p><p>与发布订阅模型很类似的是<strong>消息队列</strong>模型。</p><p><img src="http://bloghello.oursnail.cn/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>只有一个是可以收到消息的。</p><h2>四、bitMap</h2><h5>4.1 位图是什么</h5><p>就是通过一个<code>bit</code>位来表示某个元素对应的值或者状态,其中的<code>key</code>就是对应元素本身。我们知道8个<code>bit</code>可以组成一个<code>Byte</code>，所以<code>bitmap</code>本身会极大的节省储存空间。</p><p><code>Bitmap</code>不是一个确切的数据类型，而是基于<code>String</code>类型定义的一系列面向位操作的方法。因为<code>String</code>是二进制安全的并且它们的最大长度是512MB，<br>所以<code>String</code>类型很合适去作为一个2^32长度的位数组。</p><p>比如我们执行 <code>set hello big</code></p><p>那么这个<code>big</code>其实是这个形态：</p><p><img src="http://bloghello.oursnail.cn/%E5%AD%97%E7%AC%A6%E4%B8%B2big%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="image"></p><p>执行<code>getbit hello 0</code>  得到0； 执行<code>getbit hello 1</code> 得到1</p><p><code>setbit hello 7 1</code>，那么再<code>get hello</code> 将得到<code>cig</code></p><h5>4.2 位图有什么用呢？</h5><p>位图除了<code>getbit</code>和<code>setbit</code>之外，还有<code>bitcount key [start end]</code>，就是获取执行范围内的1的个数。</p><p><code>bitop</code>作用是做多个<code>Bitmap</code>的<code>and</code>,<code>or</code>,<code>not</code>,<code>xor</code>操作。</p><blockquote><p>以一个场景为例：日活跃用户</p></blockquote><p>每次用户登录时会执行一次<code>redis.setbit(daily_active_users, user_id, 1)</code></p><p>因为日活跃用户每天都变化，所以需要每天创建一个新的<code>bitmap</code>。我们简单地把日期（年月日）添加到key后面，以后就可以根据年月日这个key找到某天活跃用户。实现了这个功能。</p><blockquote><p>第二个场景：用户签到情况</p></blockquote><p>将那天所代表的网站的上线日作为<code>offset</code>参数， 比如,如果今天是网站上线的第100天,而用户$uid=10001在今天阅览过网站, 那么执行命令<code>SETBIT peter 100 1</code>. 如果明天<code>$uid=10001</code>也继续阅览网站,那么执行命令<code>SETBIT peter 101 1</code> ,以此类推.</p><p>仔细想想，用位图，一天签到一次只要占一个bit，8天才占一个字节。那么一年这个用户签到占的数据是365/8=45.625个字节.如果不用位图实现，保存一条记录将远远大于一个比特吧，那么当用户量很大的时候，差距将会特别大。</p><h2>五、hyperLogLog</h2><p>基于<code>HyperLogLog</code>算法：极小空间完成独立数量统计。本质还是字符串。</p><ul><li><code>pfadd key element [element...]</code>:向<code>hyperloglog</code>添加元素</li><li><code>pfcount key [key...]</code>:计算<code>hyperloglog</code>的独立总数</li><li><code>pfmerge destkey sourcekey [sourcekey...]</code>:合并多个<code>hyperloglog</code></li></ul><h4>api例子</h4><p><img src="http://bloghello.oursnail.cn/hyperloglogdemo.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/hyperloglogdemo2.png" alt="image"></p><h4>为什么要用hyperLogLog呢</h4><p>我们上面例子可以看到，他的功能类似于去重，统计出所有不一样元素的个数。</p><p>他的优点是：占用内存极小。</p><p><img src="http://bloghello.oursnail.cn/hyperloglog%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97.png" alt="image"></p><p>缺点也有：</p><ul><li>他可能会出错，错误率为0.81%，看你是否能够容忍错误了</li><li>不能拿到单条数据</li></ul><h2>六、geo</h2><p>存储经纬度、计算两地距离、范围计算等。</p><p>提到<code>LBS(Location Based Service)</code>，基于位置的服务。我立即想起<code>Mongodb</code>的<code>GEO</code>实现地理坐标查询等功能，具体介绍为<a href="http://fourcolor.oursnail.cn/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">地理位置附近查询的GEOHASH解决方案</a>。</p><p><code>mongodb</code>最大的特点是灵活，因为其数据是以<code>json</code>的格式存储，所以字段随时可以增加或减少；<code>Redis</code>的特点是快，适合单一的，简单的，大量数据的存储；<code>HBase</code>我没有做深入研究，它的特点是大，适合做离线缓存。在处理社交这种关系复杂的数据存储时，依然还是需要用<code>mysql</code>这种关系型数据库，<code>nosql</code>并不能完全替代。</p><h2>七、总结</h2><ul><li>首先是慢查询日志，可以定时地持久化，并且用一个可视化页面进行监测。</li><li>pipeline解决的是对没有相互依赖的操作的批量执行，减少网络传输和IO时间。但是呢，需要注意一般只能往一个节点放数据，面对集群的时候，就需要采取一些策略了。mset、mget，目前只支持具有相同slot值的key执行批量操作。后文再讲。</li><li>可以实现发布订阅模型以及消息队列，但是消息是无状态的，不能保证消息一定送达，所以需要用专业的MQ来实现。</li><li>位图，可以实现极小的空间完成对大量用户信息的统计。</li><li>地理坐标服务</li></ul>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis基本数据结构和操作</title>
      <link href="/2019/01/29/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/01/29/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第二篇文章，本文主要介绍redis如何启动，以及基本的键命令和五种基本数据类型的操作。部分图片可能看不清楚，可以拖到新窗口打开。</p><a id="more"></a><h2>一、启动方式</h2><p>我的环境是<code>windows</code>，那么直接进入<code>redis</code>的解压目录中，分别执行<code>redis-server.exe</code>和<code>redis-cli.exe</code>两个可执行的程序。也可以通过<code>cmd</code>启动：</p><p><img src="http://bloghello.oursnail.cn/redis2-1.png" alt="image"></p><p>不要直接用<code>crtl+C</code>关闭<code>server</code>，在<code>linux</code>下，直接停掉<code>server</code>的话，会导致数据的丢失。正确的做法是在客户端执行 <code>redis-cli.exe shutdown</code></p><p><img src="http://bloghello.oursnail.cn/redis2-2.png" alt="image"></p><p>还可以指定端口启动：<code>./redis-server.exe --port 6380</code></p><p><img src="http://bloghello.oursnail.cn/redis2-3.png" alt="image"></p><p>那么对应客户端连接也要指定相应 的端口才能连接。关闭服务端也要指定相应的端口才行：</p><p><img src="http://bloghello.oursnail.cn/redis2-4.png" alt="image"></p><p><code>-h</code>指定远程<code>redis</code>的<code>ip</code></p><p><img src="http://bloghello.oursnail.cn/redis2-5.png" alt="image"></p><p>通过配置文件启动,可以在下面这个文件中指定端口号：</p><p><img src="http://bloghello.oursnail.cn/redis2-6.png" alt="image"></p><p>结合配置文件启动:</p><p><img src="http://bloghello.oursnail.cn/redis2-7.png" alt="image"></p><p>还可以设置密码：</p><p><img src="http://bloghello.oursnail.cn/redis2-8.png" alt="image"></p><p>那么客户端连接就必须要密码验证了：</p><p><img src="http://bloghello.oursnail.cn/redis2-9.png" alt="image"></p><h2>二、命令</h2><h6>1、基础命令</h6><p><code>info</code>:查看系统信息</p><p><code>select (0-15)</code>，redis一共有16个工作区间，一般默认从0开始，到15.</p><p><img src="http://bloghello.oursnail.cn/redis2-10.png" alt="image"></p><ul><li><code>flushdb</code>：清空当前选择的空间</li><li><code>flushall</code>：清空所有</li><li><code>dbsize</code>：当前空间里面key-value键值对的数目</li><li><code>save</code>：人工实现redis的持久化</li><li><code>quit</code>：退出</li></ul><h6>2、键命令</h6><p><code>del key</code>成功返回1，失败返回0.</p><p><img src="http://bloghello.oursnail.cn/redis2-11.png" alt="image"></p><p><code>exits key</code></p><p><img src="http://bloghello.oursnail.cn/redis2-12.png" alt="image"></p><p><code>ttl</code>和<code>expire</code></p><p><img src="http://bloghello.oursnail.cn/redis2-13.png" alt="image"></p><p><code>type key</code> 查看key的类型</p><p><code>randomkey</code>:</p><p><img src="http://bloghello.oursnail.cn/redis2-14.png" alt="image"></p><p><code>rename oldkey newkey</code></p><p><img src="http://bloghello.oursnail.cn/redis2-15.png" alt="image"></p><p>如果是重命名为已经存在的key呢？</p><p><img src="http://bloghello.oursnail.cn/redis2-16.png" alt="image"></p><p><code>renamenx</code>:</p><p><img src="http://bloghello.oursnail.cn/redis2-17.png" alt="image"></p><h2>三、redis数据结构</h2><h6>1、String字符串</h6><p><code>setex</code>&amp;<code>psetex</code></p><p><img src="http://bloghello.oursnail.cn/redis2-18.png" alt="image"></p><p><code>getrange</code>&amp;<code>getset</code></p><p><img src="http://bloghello.oursnail.cn/redis2-19.png" alt="image"></p><p><code>mset</code>&amp;<code>mget</code>&amp;<code>strlen</code></p><p><img src="http://bloghello.oursnail.cn/redis2-20.png" alt="image"></p><p><code>setnx</code>&amp;<code>msetnx</code></p><p><img src="http://bloghello.oursnail.cn/redis2-21.png" alt="image"></p><p>数值操作</p><p><img src="http://bloghello.oursnail.cn/redis2-22.png" alt="image"></p><h5>2、hash</h5><p><img src="http://bloghello.oursnail.cn/redis2-23.png" alt="image"></p><h5>3、list</h5><p><img src="http://bloghello.oursnail.cn/redis2-24.png" alt="image"></p><h5>4、set</h5><p><img src="http://bloghello.oursnail.cn/redis2-25.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/redis2-26.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/redis2-27.png" alt="image"></p><h6>5、sorted set</h6><p><img src="http://bloghello.oursnail.cn/redis2-28.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初步认识Redis</title>
      <link href="/2019/01/29/redis/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86Redis/"/>
      <url>/2019/01/29/redis/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86Redis/</url>
      <content type="html"><![CDATA[<p>本文为redis学习笔记的第一篇文章，主要从感性层面来认识一下这个开发中的宠儿，无论是什么应用，只要有点用户量的，不上redis是不可能的。作为当今最优秀的缓存中间件，没有理由不去深入了解它！</p><a id="more"></a><h2>一、redis是什么</h2><p>redis很快，官方宣称QPS(每秒查询率)达10万。</p><p><code>Redis</code>是一个开源的使用<code>ANSI C</code>语言编写、支持网络、<strong>单进程单线程</strong>、<strong>可基于内存亦可持久化</strong>、一个高性能的<code>key-value</code>数据库。</p><p>简而言之，就是一个缓存数据库，基于内存，也可以持久化，速度贼快，几乎所有互联网公司都在使用。</p><p>有的初学者可能看到数据库这个字眼，就把他归类于mysql之类，其实不是，mysql是一种关系型数据库，是存在磁盘中的。核心的数据是一定要落地到mysql之类的数据库中的。redis其实使用最多的功能是缓存，既然能存东西，那么必然也有数据库的功能，但是有可能会造成数据的缺失。所以，数据一定是要落入数据库才保险，redis可以作为缓存，缓存热点数据或者只读数据，提高性能并保护数据库。</p><h2>二、为什么要用redis</h2><p>好了，我们已经知道它是一个高性能的缓存中间件。那么必然一大功能是作为缓存使用。那为什么要用缓存呢？直接从数据库查不就行了码？</p><p>在实际的业务场景中，用户量一上来，数据库是吃不消的。数据库是性能的一大瓶颈，如果不采取措施，用户的操作将卡在数据库处理这一块，最终可能导致不可用。</p><p>那么，此时，加入缓存，比如商城首页有很多很多内容，这些内容不可能经常变化，至少也要两三天吧？所以，可以将这些数据放到redis中，用户进商城之后，数据直接从redis中获取即可。速度极快，提高了用户的体验。</p><p>既然是缓存，那么必定会存在数据不一致的情况，所以缓存最适合于读多写少的情况，当然啦，要修改缓存肯定是可以的，但是要注意热点key的问题，比如微博最火的一片新闻，此时有几百万人再看，你却要修改一下，肯定是要注意点什么东西才行的，后续的文章会讲到如何处理热点key修改的问题。</p><h2>三、Redis与其他key-value存储有什么不同</h2><p>这里先简单说说，后面会有文章详细比价一下。</p><ul><li>多样的数据结构和原子性操作</li></ul><p><code>Redis</code>有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。<code>redis</code>中的单个命令都是原子性的，什么是原子性，就是该命令不可分割。</p><ul><li>运行于内存+持久化于磁盘</li></ul><p><code>Redis</code>运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。另一个优点是， <strong>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样<code>Redis</code>可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</strong>。</p><p>注：我们要知道，对于磁盘的顺序访问速度是远大于随机访问的。这种在硬盘上顺序追加效率很高。</p><h2>四、redis特点</h2><ul><li><strong>速度快</strong>： 基于内存,这是快的最主要原因。</li><li><strong>持久化</strong>： 可以同步或异步保存到磁盘中</li><li><strong>多种数据结构</strong>： 除了五种基本数据类型，还支持位图、<code>HyperLogLog</code>，<code>GEO</code>等</li><li><strong>支持多种编程语言客户端</strong>： <code>java</code>，<code>python</code>，<code>ruby</code>，<code>Lua</code>…</li><li><strong>功能丰富</strong>： 可以实现发布-订阅，支持事务、<code>Lua</code>脚本</li><li><strong>简单</strong>： 不依赖与外部库、单线程模型</li><li><strong>主从复制</strong>： 主服务器同步数据到从服务器，是高可用的基础</li><li><strong>高可用、分布式</strong>： 高可用：<code>redis-Sentinel</code>(v2.8版本)；分布式：<code>redis-cluster</code>(v3.0版本)</li></ul><h2>五、redis典型应用场景</h2><ul><li><strong>缓存系统</strong>：这个就不多说了，<code>redis</code>作为高速缓存是其主要存在价值。</li><li><strong>计数器</strong>：因为是原子操作<code>incr</code>+单线程，作为计数器永远不会出错</li><li><strong>消息队列系统</strong>：数据结构<code>list</code>可以实现这种生产者-消费者模式的消息队列。</li><li><strong>排行榜</strong>：有序集合<code>sorted set</code>就可以实现</li><li><strong>社交网络</strong>：<code>redis</code>与社交网络就是一家，非常方便用<code>set</code>就能实现诸如共同好友这些功能。</li></ul><h2>六、redis优势</h2><ul><li><strong>缓存管理</strong>：可以在必要时将无效的旧数据从内存中删除，为新数据腾出新的空间</li><li><strong>提供更大的灵活性</strong>：<code>redis</code>支持多种类型，并且采用<code>key-value</code> 的形式存储，<code>key</code>和<code>value</code>的大小限制都是512Mb,与编码无关，所以数据安全。但是<code>memcached</code>限制<code>key</code>最大为250字节，<code>value</code>为1MB，况且只支持<code>String</code>类型。</li><li><strong><code>redis</code>提供主从复制</strong>：实现高可用的<code>cache</code>系统，支持集群中多个服务器之间的数据同步。</li><li><strong>数据持久化</strong>：<code>redis</code>可以通过两种方式将数据进行持久化，一定程度上规避缓存中的数据不稳定的问题，也可以在重启服务器时最快的恢复缓存中所需的数据，提高了效率的同时减轻了主数据库系统的开销。</li></ul><p>与传统的<code>Memcached</code>相比，优势还是很大的，两者的具体对比我会在后续的文章中详细说明。这里注意存在即合理，<code>Memcached</code>也有不可替代的适用场景：</p><ul><li>存储一些粒度比较小的静态数据，比如一些html片段，<code>Memcached</code>便是我们更好的选择。相对于<code>redis</code>而言，<code>Memcached</code>的元数据<code>metadata</code>更小些，所以相对来讲对于数据存储管理的性能更高，额外开销更小。</li><li><code>Memcached</code>的特点：<code>Memcached</code>唯一支持的数据类型是<code>String</code>,所以更适合存储只读数据，因为字符串并不会因为额外的处理造成额外的开销。毕竟<code>Memcached</code>每次更新一个对象时，都需要重复执行下面的操作：获取整个字符串-&gt;反序列化为对象-&gt;修改其中的值-&gt;再次序列化该对象-&gt;在缓存中将整个字符串替换为新字符串。这样一来，更新存储数据就会有更高的消耗，可能就不是我们的最佳选择了。</li></ul><h2>七、总结</h2><p>只要记住redis三个关键字：快、持久化、高可用和分布式</p>]]></content>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>地理位置附近查询的GEOHASH解决方案</title>
      <link href="/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>地理位置附近查询的GEOHASH解决方案</p><a id="more"></a><h2>1.需求场景</h2><p>现今互联网确实从方方面面影响我们的生活。现在我们可以足不出户就能买到我们心仪的衣服，找到附近的美食。当我们点开一个外卖的app就能看到自己附近的餐厅，那我们有没有想过这是怎么实现的呢？</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881.png" alt="image"></p><h2>2.尝试解决</h2><ul><li>首先我们能想到的就是把所有餐厅的经纬度存下来</li><li>然后当用户选择附近餐厅时</li><li>我们先获取用户的经纬度，然后到数据库中查出所有的经纬度，依次计算它们和用户间的距离。</li><li>最后根据用户输入的距离范围过滤出合适的餐厅，并根据距离做一个升序排列。</li></ul><p>这样貌似能查出附近的餐厅，但是餐厅的数量这么多，直接全查出来内存也要爆掉，即使分批处理计算量也十分大。这样用户等待的时间就会特别长。那有什么办法能减少我们的计算量呢？</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%883.png" alt="image"></p><p>其实很简单，我们应该只计算用户关心的那一片数据，而不是计算所有的。例如用户在北京，那完全没必要计算海南，黑龙江，新疆，浙江等其它地区的数据。如果我们能快速定位到北京甚至某个区，那么我们的计算量将大大减少。我们发现这其实就是索引的功能，但是<code>MySQL</code>对这种二维的地理位置的索引支持并不友好（<code>mongodb</code>有直接的地理位置索引），它对一维的像字符串这样的支持很好。那如果我们的数据在MySQL中，有没有什么方法能将我们的二维坐标转换为一种可比较的字符串呢？这就是我们今天要介绍的<code>geohash</code>算法。</p><h2>3.基本思想</h2><p><strong><code>geohash</code>简单来说就是将一个地理坐标转换为一个可比较的字符串的算法。不过生成的字符串表示的是一个矩形的范围，并不是一个点。</strong></p><p>比如西二旗地铁附近这一片矩形区域就可以用<code>wx4eyu82</code>这个字符串表示，并且越靠前的编码表示额范围越大，比如中国绝大部分地区可以用w这个字母表示的矩形区域内。像<code>wx4eyu82</code>表示的区域一定在<code>wx4e</code>表示的区域范围内。利用这些特性我们就可以实现附近餐厅的功能了，比如我们希望查看西二旗地铁附近的餐厅就可以这样查询：<code>select * from table where geohash like 'wx4eyu82%';</code> 这样就可以利用索引，快速查询出相关餐厅的信息了。并且我们还可以用<code>wx4eyu82</code>为<code>key</code>，餐厅信息为<code>value</code>做缓存。</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882.png" alt="image"></p><p><strong>通过上面的介绍我们知道了<code>GeoHash</code>就是一种将经纬度转换成字符串的方法，并且使得在大部分情况下，字符串前缀匹配越多的距离越近.</strong></p><h2>4.GeoHash算法的步骤</h2><ul><li>首先我们将经度和纬度都单独转换为一个二进制编码</li><li>得到经度和纬度的二进制编码后，我们按照奇数位放纬度，偶数为放经度的规则（我们这里奇数偶数下标是从0开始）将它们合成一个二进制编码</li><li>最后我们需要将这个二进制编码转换为base32编码</li></ul><p><strong>举例</strong></p><ul><li>地球纬度区间是[-90,90]， 北海公园的纬度是39.928167，可以通过下面算法对纬度39.928167进行逼近编码:<ul><li>区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1；</li><li>接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0；</li><li>递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167；</li><li>如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，这样随着算法的进行会产生一个序列1011100，序列的长度跟给定的区间划分次数有关。</li></ul></li><li>通过上述计算，纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。</li><li>最后使用用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，首先将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。</li></ul><h2>5.缺陷-geohash的边界问题</h2><p>比如红色的点是我们的位置，绿色的两个点分别是附近的两个餐馆，但是在查询的时候会发现距离较远餐馆的<code>GeoHash</code>编码与我们一样（因为在同一个GeoHash区域块上），而较近餐馆的<code>GeoHash</code>编码与我们不一致。</p><p><img src="http://xiaozhao.oursnail.cn/GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%884.png" alt="image"></p><p>目前比较通行的做法就是我们不仅获取当前我们所在的矩形区域，还获取周围8个矩形块中的点。那么怎样定位周围8个点呢？关键就是需要获取周围8个点的经纬度，那我们已经知道自己的经纬度，只需要用自己的经纬度减去最小划分单位的经纬度就行。因为我们知道经纬度的范围,又知道需要划分的次数，所以很容易就能计算出最小划分单位的经纬度。</p><h2>6.几种实现geohash方案的对比</h2><h4>6.1支持二维索引的存储数据库：mongodb</h4><p><code>mongoDB</code>支持二维空间索引,使用空间索引,<code>mongoDB</code>支持一种特殊查询,如某地图网站上可以查找离你最近的咖啡厅,银行等信息。这个使用<code>mongoDB</code>的空间索引结合特殊的查询方法很容易实现。</p><ul><li>API直接支持，很方便</li><li>支持按照距离排序，并支持分页。支持多条件筛选。</li><li>可满足实时性需求。</li><li>资源占用大，数据量达到百万级请流量在10w左右查询速度明显下降。</li></ul><h4>6.2升级Mysql至5.7，支持Geohash</h4><p><code>MySQL 5.7.5</code> 增加了对<code>GeoHash</code>的支持，提供了一系列<code>geohash</code>的函数，但是其实<code>Mysql</code>并没有提供类似<code>mogodb</code>类型<code>near</code>这样的函数，仅仅提供了一些经纬度转<code>hash</code>、<code>hash</code>取经纬度的一些函数。</p><ul><li>优点:函数直接调用，生成目标<code>hash</code>、根据<code>hash</code>获取经纬度。</li><li>缺点：不支持范围查询函数，需要自行处理周边8点的问题，需要补充<code>geo</code>的算法</li></ul><h4>6.3Redis Commands: Geography Edition</h4><p>GEO 特性在 Redis 3.2 版发布， 这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作，GEO通过如下命令来完成GEO需求.</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd</td><td>添加一个或多个经纬度地理位置</td></tr><tr><td>georadius</td><td>获取指定范围内的对象，也可以增加参数withdistance直接算出距离，也可以增加参数descending/ascending 进行距离排序</td></tr><tr><td>georadiusbymember</td><td>通过指定的对象，获取其周边对象</td></tr><tr><td>geoencode</td><td>转换为geohash，52-bit，同时返回该区域最小角的geohash,最大角的geohash，及中心点</td></tr><tr><td>geodecode</td><td>同上逆操作</td></tr></tbody></table><ul><li>优点:效率高，API丰富</li><li>缺点：3.2版本是否稳定？</li></ul><p>面试的时候，问到geohash算法以及技术选型大概也能说一说了…</p><p>本文章借鉴很多优秀文章，七拼八凑而出。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补码的前世今生</title>
      <link href="/2019/01/29/java-basic/%E8%A1%A5%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/01/29/java-basic/%E8%A1%A5%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      <content type="html"><![CDATA[<p>计算机如何来保存负数呢？其实只要达到这样的目的：正数负数都有一个唯一标识即可，但是，正如人类用+1和-1来表示可以提高效率一样，也得有一个比较适当的适合我们的计算机识别的一个方式。下面来详细讲解。</p><a id="more"></a><h2>问题的由来</h2><p>下面为了表示方便，先假设存储一个整型数字用4个bit。</p><p>举例来说，+2在计算机中表示为二进制的0010，那么-2怎么表示呢？</p><p>很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+2就是<code>0010</code>，而-8则是<code>1010</code>。</p><p>更多的例子如下：</p><p><img src="http://bloghello.oursnail.cn/javabasic5-1.png" alt="image"></p><p>这就是直接用原码的方式来存储，虽然说这种方式理论上是可行的，毕竟每个数我都唯一标识了。</p><p>但是这种方式存在问题，我们希望+1和-1相加为0，但是通过这个方式算出来的是：0001+1001=1010 (-2)。也就是说，按照正常一步头的方式得不到我们想要的结果。</p><p>为了解决了“正负相加等于0”的问题，人们发明了反码。</p><h2>反码</h2><p>“反码”表示方式是用来处理负数的，符号位置不变，其余位置相反。</p><p><img src="http://bloghello.oursnail.cn/javabasic5-2.png" alt="image"></p><p>此时，我们再来算一下+1和-1相加，变成了0001+1110=1111，刚好反码表示方式中，1111象征-0。</p><p>此时，好像是解决了这个问题，但是我们发现，0这个时候有了两种表达：0000和1111。</p><p>即在用反码表示的情况下，0竟然可以用两个值来表示，这显然不好吧。毕竟+0和-0就是同一个玩意啊。</p><p>这个时候补码闪亮登场。</p><h2>补码</h2><p>很简单，在刚才反码的基础上加1。</p><p><img src="http://bloghello.oursnail.cn/javabasic5-3.png" alt="image"></p><p>此时，我们这里假定整形只有4位。那么-0表示为1111+1=10000，显然溢出了，就需要丢弃最高位，变成0000.</p><p>此时，神奇地发现，达到了统一，+0和-0都是用0000来表示了。</p><p>此时，也满足正负数相加为0的条件。比如+2为0010，-2为1110.此时两者相加为：0010+1110=(0)0000，丢掉最高位就是0000</p><p>那么对于普通情况，比如7+(-4)呢?即0111+1100=0011，就是3。OK，大功告成。</p><h2>补码怎么求</h2><p>上面已经说的很详细啦，比如-4，就是在4(0100)的基础上取反(1011)再加一(1100).</p><p>上面也解释了为什么要用补码。即保证了对称的正负数相加为0并且0只有一种表示方式。</p><p>还有一个重要的点就是，我们注意到，7-4其实我们都是转换成7+(-4)，也就是说，在计算机中，减法都是用加法的逻辑实现的。</p><p>即：一套加法的电路实现加减法。此外，乘法和除法其实都是加法这套电路实现的。</p><h2>补码的本质</h2><p>这里假设存储一个整型用8个bit。</p><p>要将正数转成对应的负数，其实只要用0减去这个数就可以了。比如，-8其实就是0-8。</p><p>则8的二进制是00001000，-8就可以用下面的式子求出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　００００００００</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br></pre></td></tr></table></figure><p>因为00000000（被减数）小于0000100（减数），所以不够减。请回忆一下小学算术，如果被减数的某一位小于减数，我们怎么办？很简单，问上一位借1就可以了。</p><p>所以，0000000也问上一位借了1，也就是说，被减数其实是100000000，算式也就改写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">１００００００００</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１１０００</span><br></pre></td></tr></table></figure><p>进一步观察，可以发现100000000 = 11111111 + 1，所以上面的式子可以拆成两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　１１１１１１１１</span><br><span class="line">－００００１０００</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１０１１１</span><br><span class="line">＋０００００００１</span><br><span class="line">－－－－－－－－－</span><br><span class="line">　１１１１１０００</span><br></pre></td></tr></table></figure><p>通过这一步，我们就从数学上知道了为什么补码是取反加一了。</p><p>你看，求任何一个负数，都是0-正数，那么就用借位的思想来，则变成100000000。</p><p>100000000则可以分解为11111111+00000001。</p><p>此时求负数的过程就就变成11111111-X+1</p><ul><li>而先用11111111来减这个正数，这个结果就是对正数取反。</li><li>此时再加上另外一个1.</li></ul><p>这与我们求补码的过程是一样的，这也解释了为什么要这样求补码。</p><h2>证明(可不看)</h2><p>将上面的特例抽象一下，用统一表达式来证明一下。</p><p>我们要证明的是，X-Y或X+(-Y)可以用X加上Y的补码完成。</p><p>Y的补码等于(11111111-Y)+1。所以，X加上Y补码，就等于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + (11111111-Y) + 1</span><br></pre></td></tr></table></figure><p>我们假定这个算式的结果等于Z，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = X + (11111111-Y) + 1</span><br></pre></td></tr></table></figure><p>接下来，分成两种情况讨论。</p><ul><li>第一种情况，如果X小于Y，那么Z是一个负数。</li></ul><p>由Y的补码等于(11111111-Y)+1，标记为F=(11111111-Y)+1,那么如何根据F逆向求Y呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y=1111111-(F-1)</span><br></pre></td></tr></table></figure><p>OK,因为此时Z是一个负数，那么Z进行补码的逆运算就可以求出它的绝对值，即正数。再加一个符号，两者相等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = -[11111111-(Z-1)] = -[11111111-(X + (11111111-Y) + 1-1)] = X - Y</span><br></pre></td></tr></table></figure><ul><li>第二种情况，如果X大于Y</li></ul><p>这意味着Z肯定大于11111111，但是我们规定了这是8位机，最高的第9位是溢出位，必须被舍去，这相当于减去100000000。所以，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = Z - 100000000 = X + (11111111-Y) + 1 - 100000000 = X - Y</span><br></pre></td></tr></table></figure><p>这就证明了，在正常的加法规则下，可以利用2的补码得到正数与负数相加的正确结果。换言之，计算机只要部署加法电路和补码电路，就可以完成所有整数的加法。</p><p>本文整理自：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="noopener">关于2的补码</a></li><li><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="noopener">知乎第一条评论</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot使用logback实现日志按天滚动</title>
      <link href="/2019/01/28/miscellany/11SpringBoot%E4%BD%BF%E7%94%A8logback%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%8C%89%E5%A4%A9%E6%BB%9A%E5%8A%A8/"/>
      <url>/2019/01/28/miscellany/11SpringBoot%E4%BD%BF%E7%94%A8logback%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%8C%89%E5%A4%A9%E6%BB%9A%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>日志是任何一个系统都必备的东西，日志的重要程度丝毫不亚于代码。而springboot中经常使用的是logback，那么今天我们就来学习一下在springboot下如何配置logback日志。理解了这里的配置，对于任何的日志都是一样的。</p><a id="more"></a><h2>需求</h2><ul><li>日志按天滚动分割</li><li><code>info</code>和<code>error</code>日志输出到不同文件</li></ul><h2>为什么使用Logback</h2><ul><li><code>Logback</code>是<code>Log4j</code>的升级版，作者为同一个人，作者不想再去改<code>Log4j</code>，所以写了<code>Logback</code></li><li>使用日志框架的最佳实践是选择一款日志门面+一款日志实现，这里选择<code>Slf4j</code>+<code>Logback</code>,<code>Slf4j</code>作者也是<code>Logback</code>的作者</li><li><code>SpringBoot</code>从1.4版本开始，内置的日志框架就是<code>Logback</code></li></ul><h2>Logback在SpringBoot中配置方式一</h2><p>可以直接在<code>applicatin.properties</code>或者<code>application.yml</code>中配置</p><p>以在<code>application.yml</code>中配置为例</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  pattern:</span></span><br><span class="line"><span class="attr">    console:</span> <span class="string">"%d - %msg%n"</span></span><br><span class="line"><span class="attr">  file:</span> <span class="string">/var/log/tomcat/sell.log</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">com.imooc.LoggerTest:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>可以发现，这种配置方式简单，但能实现的功能也很局限，只能</p><ul><li>定制输出格式</li><li>输出文件的路径</li><li>指定某个包下的日志级别</li></ul><p>如果需要完成我们的需求，这就得用第二种配置了</p><h2>Logback在SpringBoot中配置方式二</h2><p>在<code>resource</code>目录下新建<code>logback-spring.xml</code>, 内容如下</p><?xml version="1.0" encoding="UTF-8" ?><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--打印到控制台的格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"consoleLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d - %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--除了error级别的日志文件保存格式以及滚动策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileInfoLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--过滤器，将error级别过滤掉--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/var/log/tomcat/sell/info.%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--error级别日志文件保存格式以及滚动策略--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileErrorLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--只让error级别的日志进来--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/var/log/tomcat/sell/error.%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileInfoLog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileErrorLog"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个<code>appender</code>你可以理解为一个日志处理策略。</p><p>第一个<code>appender</code>的<code>name=&quot;consoleLog&quot;</code>,</p><p>名字是自己随意取的，取这个名字，表示这个策略用于控制台的日志。</p><p>我们重点看第二个和第三个<code>appender</code>,因为要把<code>info</code>和<code>error</code>日志输入到不同文件，所以我们分别建了两个<code>appender</code>。</p><p><code>rollingPolicy</code>是滚动策略，这里我们设置按时间滚动</p><p><code>filter</code>是日志的过滤方式，我们在<code>fileInfoLog</code>里做了如下过滤</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码翻译之后：拦截<code>ERROR</code>级别的日志。如果匹配到了，则禁用处理。如果不匹配，则接受，开始处理日志。</p><p>那有的同学要问了，不能这样写吗</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样不是只拦截<code>INFO</code>日志了吗？</p><p>不对！</p><p>这就得说一下日志级别了</p><p><code>DEBUG</code> -&gt;<code>INFO</code> -&gt; <code>WARN</code> -&gt;<code>ERROR</code></p><p>如果你设置的日志级别是<code>INFO</code>，那么是会拦截<code>ERROR</code>日志的哦。也就是说，如果直接写<code>info</code>，那么大于等于<code>info</code>级别的日志都会写进去，违背了我们的需求。</p><p>整理自：</p><ul><li><a href="http://www.imooc.com/article/19005" target="_blank" rel="noopener">http://www.imooc.com/article/19005</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql面试高频理论知识</title>
      <link href="/2019/01/27/mysql/mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/01/27/mysql/mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>整理一些面试题，简单看看。</p><a id="more"></a><p>目录</p><ol><li>数据库三范式</li><li>事务</li><li>mysql数据库默认最大连接数</li><li>分页</li><li>触发器</li><li>存储过程</li><li>用jdbc怎么调用存储过程？</li><li>对jdbc的理解</li><li>写一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序</li><li>JDBC中的PreparedStatement相比Statement的好处</li><li>数据库连接池作用</li><li>选择合适的存储引擎</li><li>数据库优化-索引</li><li>数据库优化-分表</li><li>数据库优化-读写分离</li><li>数据库优化-缓存</li><li>数据库优化-sql语句优化的技巧</li><li>jdbc批量插入几百万数据怎么实现</li><li>聚簇索引和非聚簇索引</li><li>sql注入问题</li><li>mysql悲观锁和乐观锁</li></ol><h2>1. 数据库三范式</h2><h3>1.1 范式是什么</h3><p>范式就是规范，要满足第二范式必须先满足第一范式，要满足第三范式，必须要先满足第二范式。</p><ul><li>1NF(第一范式)：列数据不可分割，即一列不能有多个值</li><li>2NF(第二范式)：主键(每一行都有唯一标识)</li><li>3NF(第三范式)：外键(表中不包含已在其他表中包含的非主关键信息)</li></ul><h3>1.2 反三范式</h3><p>反三范式：有时为了效率，可以设置重复或者推导出的字段，例如：订单总价格订单项的单价，这个订单总价虽然可以由订单项计算出来，但是当订单数目庞大时，效率比较低，所以订单的总价这个字段是必要的。</p><h2>2. 事务</h2><h3>2.1 含义</h3><p>事务时并发控制的单位，是用户定义的一个操作序列，要么都做，要么都不做，是不可分割的工作单位。</p><h3>2.2 事务的四个特征(ACID特性)</h3><ul><li>原子性：表示事务内操作不可分割</li><li>一致性：要么成功，要么失败，若后面失败，前面则回滚</li><li>隔离性：一个事务开始了，不被其他事务干扰</li><li>持久性：事务开始了，就不能突然终止</li></ul><h2>3. mysql数据库默认最大连接数</h2><h3>3.1 为什么需要最大连接数</h3><p>特定服务器上的数据库只能支持一定数目同时连接，这时需要我们设置最大连接数（最多同时服务多少连接）。在数据库安装时会有一个默认的最大连接数。</p><blockquote><p><code>my.ini</code>中<code>max_connections=100</code></p></blockquote><h2>4. 分页</h2><h3>4.1 为什么需要分页？</h3><p>在很多数据时，不可能完全显示数据。进行分段显示.</p><h3>4.2 mysql如何分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String sql = </span><br><span class="line">"<span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="string">" + pageSize*(pageNumber-1) + "</span>,<span class="string">" + pageSize;</span></span><br></pre></td></tr></table></figure><h3>4.3 oracle分页</h3><p>是使用了三层嵌套查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = </span><br><span class="line"> &quot;select * from &quot; +  </span><br><span class="line"> (select *,rownum rid from (select * from students order by postime desc) where rid&lt;=&quot; + pagesize*pagenumber + &quot;) as t&quot; + </span><br><span class="line"> &quot;where t&gt;&quot; + pageSize*(pageNumber-1);</span><br></pre></td></tr></table></figure><h2>5. 触发器</h2><p>略。</p><h2>6. 存储过程</h2><h3>6.1 数据库存储过程具有如下优点：</h3><ul><li><p>1、存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。</p></li><li><p>2、通常，复杂的业务逻辑需要多条 SQL 语句。这些语句要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会大大减少，降低了网络负载。</p></li><li><p>3、存储过程创建一次便可以重复使用，从而可以减少数据库开发人员的工作量。</p></li><li><p>4、安全性高，存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，无需拥有访问底层数据库对象的显式权限。</p></li></ul><h3>6.2 定义存储过程:</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> insert_Student (_name <span class="built_in">varchar</span>(<span class="number">50</span>),_age <span class="built_in">int</span> ,<span class="keyword">out</span> _id <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">value</span>(<span class="literal">null</span>,_name,_age);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(stuId) <span class="keyword">into</span> _id <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> insert_Student(<span class="string">'wfz'</span>,<span class="number">23</span>,@<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><h2>7. 用jdbc怎么调用存储过程？</h2><blockquote><p>贾琏欲执事</p></blockquote><ul><li>加载驱动</li><li>获取连接</li><li>设置参数</li><li>执行</li><li>释放连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Connection cn = <span class="keyword">null</span>;</span><br><span class="line">CallableStatement cstmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里最好不要这么干，因为驱动名写死在程序中了</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//实际项目中，这里应用DataSource数据，如果用框架，</span></span><br><span class="line"><span class="comment">//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()</span></span><br><span class="line"><span class="comment">//cn = ds.getConnection();</span></span><br><span class="line">cn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///test"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">cstmt = cn.prepareCall(<span class="string">"&#123;call insert_Student(?,?,?)&#125;"</span>);</span><br><span class="line">cstmt.registerOutParameter(<span class="number">3</span>,Types.INTEGER);</span><br><span class="line">cstmt.setString(<span class="number">1</span>, <span class="string">"wangwu"</span>);</span><br><span class="line">cstmt.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">cstmt.execute();</span><br><span class="line"><span class="comment">//get第几个，不同的数据库不一样，建议不写</span></span><br><span class="line">System.out.println(cstmt.getString(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*try&#123;cstmt.close();&#125;catch(Exception e)&#123;&#125;</span></span><br><span class="line"><span class="comment">try&#123;cn.close();&#125;catch(Exception e)&#123;&#125;*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(cstmt != <span class="keyword">null</span>)</span><br><span class="line">cstmt.close();</span><br><span class="line"><span class="keyword">if</span>(cn != <span class="keyword">null</span>)</span><br><span class="line">cn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>8. 对jdbc的理解</h2><p><code>Java database connection</code> java数据库连接.数据库管理系统(<code>mysql</code> <code>oracle</code>等)是很多，每个数据库管理系统支持的命令是不一样的。</p><p>Java只定义接口，让数据库厂商自己实现接口，对于我们者而言。只需要导入对应厂商开发的实现即可。然后以接口方式进行调用.(<code>mysql</code> + <code>mysql</code>驱动（实现）+<code>jdbc</code>)</p><h2>9. 写一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序</h2><blockquote><p>贾琏欲执事</p></blockquote><ol><li>加载驱动(<code>com.mysql.jdbc.Driver,oracle.jdbc.driver.OracleDriver</code>)</li><li>取连接(<code>DriverManager.getConnection(url,usernam,passord)</code>)</li><li>设置参数  <code>Statement PreparedStatement</code><br><code>cstmt.setXXX(index, value);</code></li><li>执行   <code>executeQuery executeUpdate</code></li><li>释放连接(是否连接要从小到大，必须放到<code>finnaly</code>)</li></ol><h2>10. JDBC中的PreparedStatement相比Statement的好处</h2><p><strong>大多数我们都使用<code>PreparedStatement</code>代替<code>Statement</code></strong></p><ul><li>1：<code>PreparedStatement</code>是预编译的，比<code>Statement</code>速度快</li><li>2：代码的可读性和可维护性</li></ul><p>虽然用<code>PreparedStatement</code>来代替<code>Statement</code>会使代码多出几行,但这样的代码无论从可读性还是可维护性上来说.都比直接用<code>Statement</code>的代码高很多档次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stmt.executeUpdate(<span class="string">"insert into tb_name (col1,col2,col2,col4) values</span></span><br><span class="line"><span class="string">('"</span>+var1+<span class="string">"','"</span>+var2+<span class="string">"',"</span>+var3+<span class="string">",'"</span>+var4+<span class="string">"')"</span>); </span><br><span class="line"></span><br><span class="line">perstmt = con.prepareStatement(<span class="string">"insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)"</span>);</span><br><span class="line">perstmt.setString(<span class="number">1</span>,var1);</span><br><span class="line">perstmt.setString(<span class="number">2</span>,var2);</span><br><span class="line">perstmt.setString(<span class="number">3</span>,var3);</span><br><span class="line">perstmt.setString(<span class="number">4</span>,var4);</span><br><span class="line">perstmt.executeUpdate();</span><br></pre></td></tr></table></figure><ul><li>3：安全性</li></ul><p><code>PreparedStatement</code>可以防止<code>SQL</code>注入攻击，而<code>Statement</code>却不能。</p><p>比如说：</p><blockquote><p>String sql = “select * from tb_name where name= '”+varname+&quot;’ and passwd=’&quot;+varpasswd+&quot;’&quot;;</p></blockquote><p>如果我们把<code>[' or '1' = '1]</code>作为varpasswd传入进来.用户名随意,看看会成为什么?</p><blockquote><p>select * from tb_name = ‘随意’ and passwd = ‘’ or ‘1’ = ‘1’;</p></blockquote><p>因为<code>'1'='1'</code>肯定成立，所以可以任何通过验证。</p><p>更有甚者：把<code>[';drop table tb_name;]</code>作为<code>varpasswd</code>传入进来,则：</p><blockquote><p>select * from tb_name = ‘随意’ and passwd = ‘’;drop table tb_name;</p></blockquote><p>有些数据库是不会让你成功的，但也有很多数据库就可以使这些语句得到执行。</p><p>而如果你使用预编译语句你传入的任何内容就不会和原来的语句发生任何匹配的关系，只要全使用预编译语句你就用不着对传入的数据做任何过虑。而如果使用普通的<code>statement</code>,有可能要对<code>drop</code>等做费尽心机的判断和过虑。</p><h2>11. 数据库连接池作用</h2><ul><li>1、限定数据库的个数，不会导致由于数据库连接过多导致系统运行缓慢或崩溃</li><li>2、数据库连接不需要每次都去创建或销毁，节约了资源</li><li>3、数据库连接不需要每次都去创建，响应时间更快。</li></ul><h2>12. 选择合适的存储引擎</h2><p>在开发中，我们经常使用的存储引擎 <code>myisam</code> / <code>innodb</code>/ <code>memory</code></p><blockquote><p>MyISAM存储引擎</p></blockquote><p>如果表对事务要求不高，同时是以查询和添加为主的，我们考虑使用myisam存储引擎. 比如 bbs 中的 发帖表，回复表.</p><blockquote><p>INNODB存储引擎:</p></blockquote><p>对事务要求高，保存的数据都是重要数据，我们建议使用<code>INNODB</code>,比如订单表，账号表.</p><blockquote><p>Memory 存储</p></blockquote><p>我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用<code>memory</code>, 速度极快.</p><p><code>MyISAM</code> 和 <code>INNODB</code>的区别(主要)</p><ol><li>事务安全 <code>myisam</code>不支持事务而<code>innodb</code>支持</li><li>查询和添加速度 <code>myisam</code>不用支持事务就不用考虑同步锁，查找和添加和添加的速度快</li><li>支持全文索引 <code>myisam</code>支持<code>innodb</code>不支持</li><li>锁机制 <code>myisam</code>支持表锁而<code>innodb</code>支持行锁(事务)</li><li>外键 <code>MyISAM</code> 不支持外键， <code>INNODB</code>支持外键. (通常不设置外键，通常是在程序中保证数据的一致)</li></ol><hr><h1>下面是数据库的优化手段，但是只是表面，需要以后再好好探究</h1><p>在项目自验项目转测试之前，在启动<code>mysql</code>数据库时开启慢查询，并且把执行慢的语句写到日志中，在运行一定时间后。通过查看日志找到慢查询语句。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">show variables like '%slow%';   #查看MySQL慢查询是否开启</span><br><span class="line"></span><br><span class="line">set global slow_query_log=ON;   #开启MySQL慢查询功能</span><br><span class="line"></span><br><span class="line">show variables like "long_query_time";  #查看MySQL慢查询时间设置，默认10秒</span><br><span class="line"></span><br><span class="line">set global long_query_time=5;  #修改为记录5秒内的查询</span><br><span class="line"></span><br><span class="line">select sleep(6);  #测试MySQL慢查询</span><br><span class="line"></span><br><span class="line">show variables like "%slow%";  #查看MySQL慢查询日志路径</span><br><span class="line"></span><br><span class="line">show global status like '%slow%';  #查看MySQL慢查询状态</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">vi  /etc/my.cnf  #编辑，在[mysqld]段添加以下代码</span><br><span class="line"></span><br><span class="line">slow-query-log = on  #开启MySQL慢查询功能</span><br><span class="line"></span><br><span class="line">slow_query_log_file =  /var/run/mysqld/mysqld-slow.log #设置MySQL慢查询日志路径</span><br><span class="line"></span><br><span class="line">long_query_time = 5  #修改为记录5秒内的查询，默认不设置此参数为记录10秒内的查询</span><br><span class="line"></span><br><span class="line">log-queries-not-using-indexes = on  #记录未使用索引的查询</span><br><span class="line"></span><br><span class="line">:wq! #保存退出</span><br><span class="line"></span><br><span class="line">service mysqld restart #重启MySQL服务</span><br></pre></td></tr></table></figure><h2>13. 数据库优化-索引</h2><h3>13.1 索引的概念</h3><p>索引（<code>Index</code>）是帮助<code>DBMS</code>高效获取数据的数据结构。</p><h3>13.2 索引有哪些</h3><blockquote><p>分类：普通索引/唯一索引/主键索引/全文索引</p></blockquote><ul><li><p>普通索引:允许重复的值出现</p></li><li><p>唯一索引:除了不能有重复的记录外，其它和普通索引一样(用户名、用户身份证、email,tel)</p></li><li><p>主键索引：是随着设定主键而创建的，也就是把某个列设为主键的时候，数据库就会給改列创建索引。这就是主键索引.唯一且没有null值</p></li><li><p>全文索引:用来对表中的文本域(<code>char</code>，<code>varchar</code>，<code>text</code>)进行索引， 全文索引针对<code>MyIsam</code><br><code>explain select * from articles where match(title,body) against(‘database’);</code>【会使用全文索引】</p></li></ul><h3>13.3 使用索引的注意事项</h3><blockquote><p>索引弊端</p></blockquote><ol><li>占用磁盘空间。</li><li>对<code>dml</code>(插入、修改、删除)操作有影响，变慢。</li></ol><blockquote><p>使用场景：</p></blockquote><ol><li>肯定在<code>where</code>条件经常使用,如果不做查询就没有意义</li><li>该字段的内容不是唯一的几个值(sex)</li><li>字段内容不是频繁变化.</li></ol><blockquote><p>注意事项</p></blockquote><ol><li>对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> dept <span class="keyword">add</span> <span class="keyword">index</span> my_ind (dname,loc); // dname 左边的列,loc就是右边的列</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=<span class="string">'aaa'</span>\G 会使用到索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> loc=<span class="string">'aaa'</span>\G 就不会使用到索引</span><br></pre></td></tr></table></figure><ol start="2"><li>对于使用<code>like</code>的查询，查询如果是<code>%aaa</code>不会使用到索引而<code>aaa%</code>会使用到索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="keyword">like</span> <span class="string">'%aaa'</span>\G不能使用索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname <span class="keyword">like</span> <span class="string">'aaa%'</span>\G使用索引.</span><br></pre></td></tr></table></figure><p>所以在<code>like</code>查询时，‘关键字’的最前面不能使用<code>%</code> 或者 <code>_</code>这样的字符，如果一定要前面有变化的值，则考虑使用 全文索引-&gt;sphinx.</p><ol start="3"><li>索引列排序</li></ol><p><code>MySQL</code>查询只使用一个索引，因此如果<code>where</code>子句中已经使用了索引的话，那么<code>order by</code>中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</p><ol start="4"><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=’<span class="number">111</span>’;</span><br><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=<span class="number">111</span>;（数值自动转字符串）</span><br><span class="line">expain <span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> dname=qqq;报错</span><br></pre></td></tr></table></figure><p>也就是，如果列是字符串类型，无论是不是字符串数字就一定要用 ‘’ 把它包括起来.</p><ol start="5"><li><p>如果<code>mysql</code>估计使用全表扫描要比使用索引快，则不使用索引。<br>表里面只有一条记录</p></li><li><p>索引不会包含有<code>NULL</code>值的列</p></li></ol><p>只要列中包含有<code>NULL</code>值都将不会被包含在<code>MySQL</code>索引中，复合索引中只要有一列含有<code>NULL</code>值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为<code>NULL</code>。</p><ol start="7"><li>使用短索引</li></ol><p>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个<code>CHAR(255)</code>的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p><ol start="8"><li>不要在列上进行运算，不使用<code>NOT IN</code>和<code>&lt;&gt;</code>操作，不支持正则表达式。</li></ol><h2>14. 数据库优化-分表</h2><p>分表分为水平(按行)分表和垂直(按列)分表</p><p><strong>水平分表情形：</strong></p><p>根据经验，<code>Mysql</code>表数据一般达到百万级别，查询效率会很低，容易造成表锁，甚至堆积很多连接，直接挂掉；水平分表能够很大程度较少这些压力。</p><p><strong>垂直分表情形：</strong></p><p>如果一张表中某个字段值非常多(长文本、二进制等)，而且只有在很少的情况下会查询。这时候就可以把字段多个单独放到一个表，通过外键关联起来。考试详情，一般我们只关注分数，不关注详情。</p><p><strong>水平分表策略：</strong></p><blockquote><p>1.按时间分表</p></blockquote><p>这种分表方式有一定的局限性，当数据有较强的实效性，如微博发送记录、微信消息记录等，这种数据很少有用户会查询几个月前的数据，如需要就可以按月分表。</p><blockquote><p>2.按区间范围分表</p></blockquote><p>一般在有严格的自增id需求上，如按照<code>user_id</code>水平分表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table_1  user_id从1~100w  </span><br><span class="line">table_2  user_id从101~200w </span><br><span class="line">table_3  user_id从201~300w</span><br></pre></td></tr></table></figure><blockquote><p>3.hash分表</p></blockquote><p>通过一个原始目标的ID或者名称通过一定的<code>hash</code>算法计算出数据存储表的表名，然后访问相应的表。</p><h2>15. 数据库优化-读写分离</h2><p>一台数据库支持的最大并发连接数是有限的，如果用户并发访问太多。一台服务器满足不要要求是就可以集群处理。Mysql的集群处理技术最常用的就是读写分离。</p><p><strong>主从同步</strong></p><p>数据库最终会把数据持久化到磁盘，如果集群必须确保每个数据库服务器的数据是一直的。<strong>能改变数据库数据的操作都往主数据库去写，而其他的数据库从主数据库上同步数据。</strong></p><p><strong>读写分离</strong></p><p>使用负载均衡来实现写的操作都往主数据去，而读的操作往从服务器去。</p><h2>16. 数据库优化-缓存</h2><p><strong>什么是缓存</strong></p><p>在持久层(<code>dao</code>)和数据库(<code>db</code>)之间添加一个缓存层，如果用户访问的数据已经缓存起来时，在用户访问时直接从缓存中获取，不用访问数据库。而缓存是在操作内存级，访问速度快。</p><p><strong>作用</strong></p><p>减少数据库服务器压力，减少访问时间。</p><p><strong>Java中常用的缓存有</strong></p><ol><li><code>hibernate</code>的二级缓存。该缓存不能完成分布式缓存。</li><li>可以使用<code>redis</code>(<code>memcahe</code>等)来作为中央缓存。对缓存的数据进行集中处理</li></ol><h2>17. 数据库优化-sql语句优化的技巧</h2><h3>DDL优化</h3><ol><li>通过禁用索引来提供导入数据性能，这个操作主要针对现有数据库的表追加数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//去除键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test3 <span class="keyword">DISABLE</span> <span class="keyword">keys</span>;</span><br><span class="line">//批量插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test3 ***</span><br><span class="line">//恢复键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test3 <span class="keyword">ENABLE</span> <span class="keyword">keys</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>关闭唯一校验</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> unique_checks=<span class="number">0</span>  关闭</span><br><span class="line"><span class="keyword">set</span> unique_checks=<span class="number">1</span>  开启</span><br></pre></td></tr></table></figure><ol start="3"><li>修改事务提交方式(导入)（变多次提交为一次）</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>   关闭</span><br><span class="line">//批量插入</span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">1</span>   开启</span><br></pre></td></tr></table></figure><h3>DML优化（变多次提交为一次）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">//合并多条为一条</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3>DQL优化</h3><blockquote><p>Order by优化</p></blockquote><ol><li>多用索引排序</li><li>普通结果排序（非索引排序）Filesort</li></ol><blockquote><p>group by优化</p></blockquote><p>使用order by null,取消默认排序</p><p>等等等等…</p><h2>18. jdbc批量插入几百万数据怎么实现</h2><p>1、变多次提交为一次<br>2、使用批量操作<br>3、像这样的批量插入操作能不使用代码操作就不使用，可以使用存储过程来实现</p><p><img src="http://p376695fl.bkt.clouddn.com/jdbc%E6%8F%92%E5%85%A5%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96.png" alt="image"></p><h2>mysql优化手段介绍到这里。</h2><h2>19. 聚簇索引和非聚簇索引</h2><p>索引分为聚簇索引和非聚簇索引。</p><p><strong>“聚簇索引”</strong></p><p>以一本英文课本为例，要找第8课，直接翻书，若先翻到第5课，则往后翻，再翻到第10课，则又往前翻。这本书本身就是一个索引，即“聚簇索引”。</p><p><strong>“非聚簇索引”</strong></p><p>如果要找&quot;fire”这个单词，会翻到书后面的附录，这个附录是按字母排序的，找到F字母那一块，再找到&quot;fire”，对应的会是它在第几课。这个附录，为“非聚簇索引”。</p><p>由此可见，聚簇索引，索引的顺序就是数据存放的顺序，所以，很容易理解，一张数据表只能有一个聚簇索引。</p><p>聚簇索引要比非聚簇索引查询效率高很多，特别是范围查询的时候。所以，至于聚簇索引到底应该为主键，还是其他字段，这个可以再讨论。</p><h3>1、MYSQL的索引</h3><p>mysql中，不同的存储引擎对索引的实现方式不同，大致说下<code>MyISAM</code>和<code>InnoDB</code>两种存储引擎。</p><p><strong>MyISAM存储引擎的索引实现</strong></p><p><code>MyISAM</code>的<code>B+Tree</code>的叶子节点上的<code>data</code>，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。<br>MyISAM还采用压缩机制存储索引，比如，第一个索引为“her”，第二个索引为“here”，那么第二个索引会被存储为“3,e”，这样的缺点是同一个节点中的索引只能采用顺序查找。</p><p><strong>InnoDB存储引擎的索引实现</strong></p><p><code>InnoDB</code> 的数据文件本身就是索引文件，<code>B+Tree</code>的叶子节点上的<code>data</code>就是数据本身，<code>key</code>为主键，这是聚簇索引。非聚簇索引，叶子节点上的data是主键 (所以聚簇索引的<code>key</code>，不能过长)。为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证。<br>至于为什么主键通常建议使用自增id呢？</p><h3>2.聚簇索引</h3><p>聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p><p>聚簇索引不但在检索上可以大大滴提高效率，在数据读取上也一样。比如：需要查询f~t的所有单词。</p><p>一个使用<code>MyISAM</code>的主索引，一个使用<code>InnoDB</code>的聚簇索引。两种索引的<code>B+Tree</code>检索时间一样，但读取时却有了差异。</p><p><strong>因为<code>MyISAM</code>的主索引并非聚簇索引</strong>，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。</p><p><strong>不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是<code>MyISAM</code>占优势些，因为索引所占空间小，这些操作是需要在内存中完成的</strong>。</p><p>鉴于聚簇索引的范围查询效率，很多人认为使用主键作为聚簇索引太多浪费，毕竟几乎不会使用主键进行范围查询。但若再考虑到聚簇索引的存储，就不好定论了。</p><h2>20. sql注入问题</h2><h3>20.1 什么是sql注入</h3><p>sql注入大家都不陌生，是一种常见的攻击方式，攻击者在界面的表单信息或url上输入一些奇怪的sql片段，例如“or ‘1’=’1’”这样的语句，有可能入侵参数校验不足的应用程序。所以在我们的应用中需要做一些工作，来防备这样的攻击方式。在一些安全性很高的应用中，比如银行软件，经常使用将sql语句全部替换为存储过程这样的方式，来防止sql注入，这当然是一种很安全的方式，但我们平时开发中，可能不需要这种死板的方式。</p><h3>20.2 PrepareStatement解决SQL注入的问题</h3><p>在使用<code>JDBC</code>的过程中，可以使用<code>PrepareStatement</code>进行预处理，预处理的优势就是预防绝大多数的SQL注入；而且针对多次操作数据库的情况，可以极大的提高访问数据库的效率。</p><p>那为什么它这样处理就能预防SQL注入提高安全性呢？其实是因为SQL语句在程序运行前已经进行了预编译。在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库以参数化的形式进行查询。当运行时动态地把参数传给<code>PreprareStatement</code>时，即使参数里有敏感字符如 or ‘1=1’，数据库也会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令。如此，就起到了SQL注入的作用了！</p><h3>20.3 MyBatis如何防止sql注入</h3><p><code>mybatis</code>框架作为一款半自动化的持久层框架，其sql语句都要我们自己来手动编写，这个时候当然需要防止sql注入。其实<code>Mybatis</code>的sql是一个具有“输入+输出”功能，类似于函数的结构，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=“getBlogById“ resultType=“Blog“ parameterType=”int”&gt;</span><br><span class="line">       <span class="keyword">select</span> <span class="keyword">id</span>,title,author,<span class="keyword">content</span> </span><br><span class="line">　　　　<span class="keyword">from</span> blog </span><br><span class="line">　　　　<span class="keyword">where</span> <span class="keyword">id</span>=#&#123;<span class="keyword">id</span>&#125; </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>这里，<code>parameterType</code>标示了输入的参数类型，<code>resultType</code>标示了输出的参数类型。回应上文，如果我们想防止sql注入，理所当然地要在输入参数上下功夫。上面代码中“#{id}”即输入参数在sql中拼接的部分，传入参数后，打印出执行的sql语句，会看到sql是这样的：</p><blockquote><p>select id,title,author,content from blog where id = ?</p></blockquote><p>不管输入什么参数，打印出的sql都是这样的。这是因为<code>mybatis</code>启用了预编译功能，在sql执行前，会先将上面的sql发送给数据库进行编译，执行时，直接使用编译好的sql，替换占位符“？”就可以了。因为sql注入只能对编译过程起作用，所以这样的方式就很好地避免了sql注入的问题。</p><p><code>mybatis</code>是如何做到sql预编译的呢？其实在框架底层，是<code>jdbc</code>中的<code>PreparedStatement</code>类在起作用，<code>PreparedStatement</code>是我们很熟悉的<code>Statement</code>的子类，它的对象包含了编译好的sql语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行一个sql时，能够提高效率，原因是sql已编译好，再次执行时无需再编译。</p><p>补充</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=“orderBlog“ resultType=“Blog“ parameterType=”map”&gt;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">select</span> <span class="keyword">id</span>,title,author,<span class="keyword">content</span> <span class="keyword">from</span> blog <span class="keyword">order</span> <span class="keyword">by</span> $&#123;orderParam&#125;</span><br><span class="line"> </span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>仔细观察，内联参数的格式由“#{xxx}”变为了${xxx}。如果我们给参数“orderParam”赋值为”id”,将sql打印出来，是这样的：</p><blockquote><p>select id,title,author,content from blog order by id</p></blockquote><p>显然，这样是无法阻止sql注入的。在mybatis中，”${xxx}”这样格式的参数会直接参与sql编译，从而不能避免注入攻击。<strong>但涉及到动态表名和列名时，只能使用“${xxx}”这样的参数格式</strong>，所以，这样的参数需要我们在代码中手工进行处理来防止注入。</p><h2>21. mysql悲观锁和乐观锁</h2><h2>21.1 悲观锁</h2><p>悲观锁（<code>Pessimistic Lock</code>），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p><p><code>Java synchronized</code> 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p><h2>21.2 乐观锁</h2><p>乐观锁（<code>Optimistic Lock</code>），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p><p>乐观锁一般来说有以下2种方式：</p><ul><li>使用数据版本（<code>Version</code>）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 <code>version</code> 字段来实现。当读取数据时，将<code>version</code>字段的值一同读出，数据每更新一次，对此<code>version</code>值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的<code>version</code>值进行比对，如果数据库表当前版本号与第一次取出来的<code>version</code>值相等，则予以更新，否则认为是过期数据。</li><li>使用时间戳（<code>timestamp</code>）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（<code>timestamp</code>）, 和上面的<code>version</code>类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。<br><code>Java JUC</code>中的<code>atomic</code>包就是乐观锁的一种实现，<code>AtomicInteger</code> 通过<code>CAS</code>（<code>Compare And Set</code>）操作实现线程安全的自增。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复杂查询基础</title>
      <link href="/2019/01/27/mysql/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/01/27/mysql/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>这一节从group by和having两个关键语法入手，学习一下写sql的基本思路。</p><a id="more"></a><p>数据库准备：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 学生表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`student`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">varchar</span>(<span class="number">8</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`student_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">8</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- student表数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'lilei'</span>, <span class="string">'19'</span>, <span class="string">'female'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'huangmeimei'</span>, <span class="string">'18'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'pollu'</span>, <span class="string">'17'</span>, <span class="string">'female'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'tom'</span>, <span class="string">'18'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'david'</span>, <span class="string">'17'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'lucy'</span>, <span class="string">'19'</span>, <span class="string">'female'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> <span class="keyword">VALUES</span> (<span class="string">'7'</span>, <span class="string">'jacky'</span>, <span class="string">'20'</span>, <span class="string">'male'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 课程表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`course`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`course_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- course表数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'chinese'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'math'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'english'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`course`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'physics'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 分数表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`score`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`score`</span> (</span><br><span class="line">  <span class="string">`student_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`course_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- score表数据</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'78'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'2'</span>, <span class="string">'81'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'92'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'2'</span>, <span class="string">'47'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'3'</span>, <span class="string">'88'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'2'</span>, <span class="string">'88'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'3'</span>, <span class="string">'90'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'3'</span>, <span class="string">'78'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'2'</span>, <span class="string">'68'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'4'</span>, <span class="string">'67'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'52'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'2'</span>, <span class="string">'72'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`score`</span> <span class="keyword">VALUES</span> (<span class="string">'7'</span>, <span class="string">'2'</span>, <span class="string">'72'</span>);</span><br></pre></td></tr></table></figure><h2>第一个问题</h2><blockquote><p>查询所有同学的学号、选课数、总成绩</p></blockquote><p>针对sql问题，不需要一口气全部写出来，我们先分解逐个击破，最后再合体。</p><p>分析题目，他要查询的是每个学生的学号，选课数，总成绩</p><p>那么先把关键字列出来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#首先是要查询，肯定有select关键字</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">#要查询的几个关键字段</span><br><span class="line">student_id,<span class="keyword">count</span>(course_id),<span class="keyword">sum</span>(score)</span><br></pre></td></tr></table></figure><p>我们看到，有一些函数在里面，比如<code>count</code>和<code>sum</code>，那么我们会想到一般情况下是与<code>group by</code>结合使用的。</p><p>因为是查询每个学生，那么必然是根据每个学生的id进行分组了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group by student_id</span><br></pre></td></tr></table></figure><p>此时，因为涉及的<code>student_id</code>,<code>course_id</code>以及<code>score</code>只需要一张<code>score</code>表就可以解决,那么拼接起来就是：</p><p><img src="http://bloghello.oursnail.cn/mysql10-0.png" alt="image"></p><p>我们进行<code>explain</code>分析一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">SELECT</span> student_id,<span class="keyword">count</span>(course_id),<span class="keyword">sum</span>(score)</span><br><span class="line"><span class="keyword">from</span> score</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br></pre></td></tr></table></figure><p>显示：</p><p><img src="http://bloghello.oursnail.cn/mysql10-4.png" alt="image"></p><p>基本的原理就是：首先根据<code>group by</code>进行分组，分组出来的数据缓存到一张临时表中，然后再做<code>count</code>之类的计算显示。</p><p>并且，本题是针对一张表，所以有一个规则是：如果用<code>group by</code>，那么你的<code>select</code>语句中选出的列要么是<code>group by</code>里用到的列，要么就是<code>sum</code> <code>min</code>等列函数的列。所以这里<code>group by</code>和后面是<code>student_id</code>，所以<code>select</code>后面可以查询<code>student_id</code>，但是不能查询<code>course_id</code>等字段。</p><h2>第二个问题</h2><blockquote><p>查询所有同学的学号、姓名、选课数、总成绩</p></blockquote><p>注意观察，其实就是比上一个问题多一个字段<code>name</code>，但是区别比较大，因为一张<code>score</code>表已经不够用了。这个时候还需要<code>student</code>表了，即两张表联合查询。那么只要搞一个连接条件即可：</p><p><img src="http://bloghello.oursnail.cn/mysql10-1.png" alt="image"></p><h2>第三个问题</h2><blockquote><p>查询平均成绩大于60分的同学的学号和平均成绩</p></blockquote><p>我们再来分解看看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询肯定用到select</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">#要查询的两个字段</span><br><span class="line">student_id,<span class="keyword">avg</span>(score) </span><br><span class="line"></span><br><span class="line">#由于存在<span class="keyword">avg</span>，那么必然要分组</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br></pre></td></tr></table></figure><p>最后，有一个条件是：平均成绩大于60分，此时就需要对查询出来的分组进行过滤筛选了，此时<code>having</code>闪亮登场。</p><p><img src="http://bloghello.oursnail.cn/mysql10-2.png" alt="image"></p><p>测试了一下，下面两条sql都是一样的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">where</span> course_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">having</span> course_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2>第四个问题</h2><blockquote><p>查询没有学全所有课的同学的学号、姓名</p></blockquote><p>这个稍微复杂一点点，我们还是分解来看看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#查询肯定用到select</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"></span><br><span class="line">#要查询的两个字段</span><br><span class="line">student_id,<span class="keyword">name</span></span><br><span class="line"></span><br><span class="line">#由于存在<span class="keyword">avg</span>，那么必然要分组</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student_id</span><br><span class="line"></span><br><span class="line">#两张表连接，要起个别名</span><br><span class="line"><span class="keyword">where</span> sc.student_id = stu.student_id</span><br></pre></td></tr></table></figure><p>因为需要查询课程没有学满的学生，所以需要先查询所有课程的数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> course</span><br></pre></td></tr></table></figure><p>此时，我们需要利用这个查询语句作为结果再进行查询，即子查询。对于上面的分组要进行筛选</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">having count(sc.course_id) &lt; (select count(1) from course)</span><br></pre></td></tr></table></figure><p>所以最终的语句是：</p><p><img src="http://bloghello.oursnail.cn/mysql10-3.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL必知必会知识点提炼</title>
      <link href="/2019/01/27/mysql/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2019/01/27/mysql/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      <content type="html"><![CDATA[<p>这是对《mysql必知必会》的知识提炼。</p><a id="more"></a><h1>一、基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。</p><p><code>SQL</code>（<code>Structured Query Language</code>)，标准 <code>SQL</code> 由 <code>ANSI</code> 标准委员会管理，从而称为 <code>ANSI SQL</code>。各个 <code>DBMS</code> 都有自己的实现，如 <code>PL/SQL</code>、<code>Transact-SQL</code> 等。</p><p><code>SQL</code> 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 <code>DBMS</code> 以及配置。</p><p><code>SQL</code> 支持以下三种注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注释</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure><h1>二、创建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>));</span><br></pre></td></tr></table></figure><h1>三、修改表</h1><p>添加列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">col</span> <span class="built_in">CHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><h1>四、插入</h1><p>普通插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure><p>插入检索出来的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure><p>将一个表的内容插入到一个新表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1>五、更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mytable</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">col</span> = val</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1>六、删除</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>TRUNCATE TABLE</strong>  可以清空表，也就是删除所有行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure><p>使用更新和删除操作时一定要用 <code>WHERE</code> 子句，不然会把整张表的数据都破坏。可以先用 <code>SELECT</code> 语句进行测试，防止错误删除。</p><h1>七、查询</h1><h2>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>返回第 3 ~ 5 行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h1>八、排序</h1><ul><li><strong>ASC</strong> ：升序（默认）</li><li><strong>DESC</strong> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h1>九、过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>下表显示了 WHERE 子句可用的操作符</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;&gt; !=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&lt;= !&gt;</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;= !&lt;</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">BETWEEN</td><td style="text-align:center">在两个值之间</td></tr><tr><td style="text-align:center">IS NULL</td><td style="text-align:center">为 NULL 值</td></tr></tbody></table><p>应该注意到，<code>NULL</code> 与 0、空字符串都不同。</p><p><strong>AND 和 OR</strong>  用于连接多个过滤条件。优先处理 <code>AND</code>，当一个过滤表达式涉及到多个 <code>AND</code> 和 <code>OR</code> 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong>  操作符用于匹配一组值，其后也可以接一个 <code>SELECT</code> 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong>  操作符用于否定一个条件。</p><h1>十、通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><p><code>%</code>  匹配 &gt;=0 个任意字符；</p></li><li><p><code>\_</code>  匹配 ==1 个任意字符；</p></li><li><p><code>[ ]</code>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</p></li></ul><p>使用 <code>Like</code> 来进行通配符匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> <span class="keyword">LIKE</span> <span class="string">'[^AB]%'</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h1>十一、计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用  <strong>AS</strong>  来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 * col2 <span class="keyword">AS</span> <span class="keyword">alias</span></span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><p><strong>CONCAT()</strong>  用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">'('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1>十二、函数</h1><h2>汇总</h2><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center">AVG()</td><td style="text-align:center">返回某列的平均值</td></tr><tr><td style="text-align:center">COUNT()</td><td style="text-align:center">返回某列的行数</td></tr><tr><td style="text-align:center">MAX()</td><td style="text-align:center">返回某列的最大值</td></tr><tr><td style="text-align:center">MIN()</td><td style="text-align:center">返回某列的最小值</td></tr><tr><td style="text-align:center">SUM()</td><td style="text-align:center">返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 <code>NULL</code> 行。</p><p>使用 <code>DISTINCT</code> 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h2>文本处理</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">LEFT()</td><td style="text-align:center">左边的字符</td></tr><tr><td style="text-align:center">RIGHT()</td><td style="text-align:center">右边的字符</td></tr><tr><td style="text-align:center">LOWER()</td><td style="text-align:center">转换为小写字符</td></tr><tr><td style="text-align:center">UPPER()</td><td style="text-align:center">转换为大写字符</td></tr><tr><td style="text-align:center">LTRIM()</td><td style="text-align:center">去除左边的空格</td></tr><tr><td style="text-align:center">RTRIM()</td><td style="text-align:center">去除右边的空格</td></tr><tr><td style="text-align:center">LENGTH()</td><td style="text-align:center">长度</td></tr><tr><td style="text-align:center">SOUNDEX()</td><td style="text-align:center">转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong>  可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)</span><br></pre></td></tr></table></figure><h2>日期和时间处理</h2><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center">AddDate()</td><td style="text-align:center">增加一个日期（天、周等）</td></tr><tr><td style="text-align:center">AddTime()</td><td style="text-align:center">增加一个时间（时、分等）</td></tr><tr><td style="text-align:center">CurDate()</td><td style="text-align:center">返回当前日期</td></tr><tr><td style="text-align:center">CurTime()</td><td style="text-align:center">返回当前时间</td></tr><tr><td style="text-align:center">Date()</td><td style="text-align:center">返回日期时间的日期部分</td></tr><tr><td style="text-align:center">DateDiff()</td><td style="text-align:center">计算两个日期之差</td></tr><tr><td style="text-align:center">Date_Add()</td><td style="text-align:center">高度灵活的日期运算函数</td></tr><tr><td style="text-align:center">Date_Format()</td><td style="text-align:center">返回一个格式化的日期或时间串</td></tr><tr><td style="text-align:center">Day()</td><td style="text-align:center">返回一个日期的天数部分</td></tr><tr><td style="text-align:center">DayOfWeek()</td><td style="text-align:center">对于一个日期，返回对应的星期几</td></tr><tr><td style="text-align:center">Hour()</td><td style="text-align:center">返回一个时间的小时部分</td></tr><tr><td style="text-align:center">Minute()</td><td style="text-align:center">返回一个时间的分钟部分</td></tr><tr><td style="text-align:center">Month()</td><td style="text-align:center">返回一个日期的月份部分</td></tr><tr><td style="text-align:center">Now()</td><td style="text-align:center">返回当前日期和时间</td></tr><tr><td style="text-align:center">Second()</td><td style="text-align:center">返回一个时间的秒部分</td></tr><tr><td style="text-align:center">Time()</td><td style="text-align:center">返回一个日期时间的时间部分</td></tr><tr><td style="text-align:center">Year()</td><td style="text-align:center">返回一个日期的年份部分</td></tr></tbody></table><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-4-14 20:25:11</span><br></pre></td></tr></table></figure><h2>数值处理</h2><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">SIN()</td><td style="text-align:center">正弦</td></tr><tr><td style="text-align:center">COS()</td><td style="text-align:center">余弦</td></tr><tr><td style="text-align:center">TAN()</td><td style="text-align:center">正切</td></tr><tr><td style="text-align:center">ABS()</td><td style="text-align:center">绝对值</td></tr><tr><td style="text-align:center">SQRT()</td><td style="text-align:center">平方根</td></tr><tr><td style="text-align:center">MOD()</td><td style="text-align:center">余数</td></tr><tr><td style="text-align:center">EXP()</td><td style="text-align:center">指数</td></tr><tr><td style="text-align:center">PI()</td><td style="text-align:center">圆周率</td></tr><tr><td style="text-align:center">RAND()</td><td style="text-align:center">随机数</td></tr></tbody></table><h1>十三、分组</h1><p>分组就是把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span>;</span><br></pre></td></tr></table></figure><p><code>GROUP BY</code> 自动按分组字段进行排序，<code>ORDER BY</code> 也可以按汇总字段来进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p><code>WHERE</code> 过滤行，<code>HAVING</code> 过滤分组，行过滤应当先于分组过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>分组规定：</p><ul><li><code>GROUP BY</code> 子句出现在 <code>WHERE</code> 子句之后，<code>ORDER BY</code> 子句之前；</li><li>除了汇总字段外，<code>SELECT</code> 语句中的每一字段都必须在 <code>GROUP BY</code> 子句中给出；</li><li><code>NULL</code> 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 <code>GROUP BY</code> 列具有可变长度的数据类型。</li></ul><h1>十四、子查询</h1><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><h1>十五、连接</h1><p>连接用于连接多个表，使用 <code>JOIN</code> 关键字，并且条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 <code>AS</code> 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2>内连接</h2><p>内连接又称等值连接，使用 <code>INNER JOIN</code> 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>可以不明确使用 <code>INNER JOIN</code>，而使用普通查询并在 <code>WHERE</code> 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>在没有条件语句的情况下返回笛卡尔积。</p><h2>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department = (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure><p>自连接版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure><h2>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B;</span><br></pre></td></tr></table></figure><h2>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure><p>customers 表：</p><table><thead><tr><th style="text-align:center">cust_id</th><th style="text-align:center">cust_name</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">b</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td></tr></tbody></table><p>orders 表：</p><table><thead><tr><th style="text-align:center">order_id</th><th style="text-align:center">cust_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">3</td></tr></tbody></table><p>结果：</p><table><thead><tr><th style="text-align:center">cust_id</th><th style="text-align:center">cust_name</th><th style="text-align:center">order_id</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">a</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">a</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">c</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">b</td><td style="text-align:center">Null</td></tr></tbody></table><h1>十六、组合查询</h1><p>使用  <strong>UNION</strong>  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 <code>UNION ALL</code>。</p><p>只能包含一个 <code>ORDER BY</code> 子句，并且必须位于语句的最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> =<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1>十七、视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(col1, col2) <span class="keyword">AS</span> concat_col, col3*col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 = val;</span><br></pre></td></tr></table></figure><h1>十八、存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理；</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 <code>in</code>、<code>out</code> 和 <code>inout</code> 三种参数。</p><p>给变量赋值都需要用 <code>select into</code> 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="built_in">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="built_in">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y*y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> myprocedure(@ret);</span><br><span class="line"><span class="keyword">select</span> @ret;</span><br></pre></td></tr></table></figure><h1>十九、游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="built_in">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1</span><br><span class="line">        <span class="keyword">declare</span> continue <span class="keyword">handler</span> <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">'02000'</span> <span class="keyword">set</span> done = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        open mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            fetch mycursor into ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line"></span><br><span class="line">        close mycursor;</span><br><span class="line">    <span class="keyword">end</span> //</span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure><h1>二十、触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：<code>DELETE</code>、<code>INSERT</code>、<code>UPDATE</code>。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 <code>BEFORE</code> 关键字，之后执行使用 <code>AFTER</code> 关键字。<code>BEFORE</code> 用于数据验证和净化，<code>AFTER</code> 用于审计跟踪，将修改记录到另外一张表中。</p><p><code>INSERT</code> 触发器包含一个名为 <code>NEW</code> 的虚拟表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> @<span class="keyword">result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure><p><code>DELETE</code> 触发器包含一个名为 <code>OLD</code> 的虚拟表，并且是只读的。</p><p><code>UPDATE</code> 触发器包含一个名为 <code>NEW</code> 和一个名为 <code>OLD</code> 的虚拟表，其中 <code>NEW</code> 是可以被修改地，而 <code>OLD</code> 是只读的。</p><p><code>MySQL</code> 不允许在触发器中使用 <code>CALL</code> 语句，也就是不能调用存储过程。</p><h1>二十一、事务处理</h1><p>基本术语：</p><ul><li>事务（<code>transaction</code>）指一组 SQL 语句；</li><li>回退（<code>rollback</code>）指撤销指定 SQL 语句的过程；</li><li>提交（<code>commit</code>）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（<code>savepoint</code>）指事务处理中设置的临时占位符（<code>placeholder</code>），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 <code>SELECT</code> 语句，回退 <code>SELECT</code> 语句也没意义；也不能回退 <code>CREATE</code> 和 <code>DROP</code> 语句。</p><p><code>MySQL</code> 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>通过设置 <code>autocommit</code> 为 0 可以取消自动提交，直到 <code>autocommit</code> 被设置为 1 才会提交；<code>autocommit</code> 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，<code>ROLLBACK</code> 会回退到 <code>START TRANSACTION</code> 语句处；如果设置了保留点，并且在 <code>ROLLBACK</code> 中指定该保留点，则会回退到该保留点。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line">// ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure><h1>二十二、字符集</h1><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(<span class="keyword">col</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure><p>可以在排序、分组时指定校对：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">col</span> <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure><h1>二十三、权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>创建账户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypassword'</span>;</span><br></pre></td></tr></table></figure><p>新创建的账户没有任何权限。</p><p><strong>修改账户名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure><p><strong>删除账户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>查看权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>授予权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure><p>账户用 <code>username@host</code> 的形式定义，<code>username@%</code> 使用的是默认主机名。</p><p><strong>删除权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code>；</li><li>整个数据库，使用 <code>ON database.\*</code>；</li><li>特定的表，使用 <code>ON database.table</code>；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><p><strong>更改密码</strong></p><p>必须使用 <code>Password()</code> 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser = <span class="keyword">Password</span>(<span class="string">'new_password'</span>);</span><br></pre></td></tr></table></figure><p>转自：</p><ul><li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/SQL.md" target="_blank" rel="noopener">SQL</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库事务核心问题</title>
      <link href="/2019/01/27/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/27/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本文从事务引出了Mysql InnoDB RR隔离级别下是如何防止幻读的。</p><a id="more"></a><h2>1. 数据库事务的四大特性</h2><p>最重要的是ACID特性。</p><ul><li>原子性(Atomicity)：事务要么都成功要么都失败</li><li>一致性(Consistency)：关系型数据库有很多约束，事务前后都要满足这些约束(不仅仅是数据库物理约束，还包括内部逻辑上的一些假设)</li><li>隔离性(Isolation)：两个事务互相独立，不能互相干扰</li><li>持久性(Durability)：事务执行成功之后结果可以持久化，永久存储下来(redo日志)</li></ul><p>对于一致性，可能解释比较抽象，他的实际含义是：数据库的数据应满足完整性约束。拿转账业务来说，假设用户A和用户B一共有2000块钱，那么他们之间无论如何转账，总共的钱应该都是2000.</p><h2>2. 事务并发访问引起的问题</h2><ul><li>更新丢失-mysql所有事务隔离级别在数据库层面均可避免</li></ul><table><thead><tr><th>取款事务</th><th>存款事务</th></tr></thead><tbody><tr><td>开始事务</td><td>开始事务</td></tr><tr><td>查询余额为100元</td><td>无</td></tr><tr><td>无</td><td>查询余额为100元</td></tr><tr><td>无</td><td>存入20，余额变为120元</td></tr><tr><td>无</td><td>提交事务</td></tr><tr><td>取出10元，余额改为90元</td><td>无</td></tr><tr><td>回滚事务，余额恢复为100元</td><td>更新丢失</td></tr></tbody></table><ul><li>脏读问题-一个事务读到另一个事务未提交的数据</li><li>不可重复读-事务A多次读取数据，未提交数据，此时事务B提交新的数据，导致A多次读取数据期间数据不一致，不满足隔离性</li><li>幻读-事务A受到另一个事务插入新的一行或者删除一行的影响，导致幻觉</li></ul><p><strong>不可重复读的重点是修改:</strong><br>同样的条件的select, 你读取过的数据, 再次读取出来发现值不一样了</p><p><strong>幻读的重点在于新增或者删除:</strong><br>同样的条件的select, 第1次和第2次读出来的记录数不一样</p><p>具体可以自己设置不同的隔离级别进行演示。</p><h2>3. 事务的隔离级别</h2><ul><li>Read uncommitted：读到其他事务未commit的值</li><li>Read committed：解决了脏读问题，但是会读到其他事务commit的值，读两次可能会读到两个值，所以又叫不可重复读</li><li>Repeatable Read：解决了不可重复读问题，可重复读，别人commit对我没有影响，但是对于别的事务插入操作，可能会产生幻读</li><li>Serializable：串行化，当发生两个事务同时提交，结果只可能有一个，相当于串行执行后的某个结果</li></ul><p>级别越来越高，安全性也越来越高，但是但是性能越来越低。说明一下，出现幻读只是针对这种<code>Repeatable Read</code>隔离级别，但是<code>InnoDB</code>已经不存在幻读问题了，如何解决的呢？主要是用<code>next-key锁</code>来解决，下文会讲到。</p><h2>4. 当前读和快照读</h2><h5>4.1 当前读</h5><p>读取的都是当前数据的最新版本，并且在读的时候对其加锁，不允许其他事务进行修改操作。</p><p><code>select ... lock in share mode</code>（共享锁）以及<br><code>select ... for update</code>、<code>update</code>、<code>delete</code>、<code>insert</code>（排他锁）这些操作都是当前读。</p><p>为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：</p><p><img src="http://bloghello.oursnail.cn/mysql4-7.jpg" alt="image"></p><p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，发出current read 读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。</p><p>待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。</p><p>一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。</p><h5>4.2 快照读</h5><p>不加锁的非阻塞读，简单的select（前提是事务级别不是<code>serializable</code>，因为在<code>serializable</code>级别下都是串行读，普通的<code>select</code>也会退化为当前读即<code>select ... lock in share mode</code>）</p><p>快照读的实现是基于多版本并发控制（MVCC）实现，旨在提高性能。有可能读到的不是数据的最新版本。（创建快照的时机决定了读到的数据的版本，如果事务A先快照读，事务B修改，那么事务A再快照读就还是更新前的版本，事务A的当前读会读到最新的数据；而当事务B先更新，事务A再快照读，就会读到数据最新版本了）</p><h6>4.3 MVCC</h6><p>MVCC在MySQL的InnoDB中的实现 在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：</p><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号</li><li>DELETE时，保存当前事务版本号为行的删除版本号</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行</li></ul><p>通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p><p>说白了，就是乐观锁的一种实现。免去了加锁解锁的过程，对于读多写少的场景特别适用。</p><h2>5. RC，RR级别下的InnoDB非阻塞读（快照读）如何实现</h2><ul><li>通过数据行里的<code>DB_TRX_ID</code>、<code>DB_ROLL_PTR</code>、<code>DB_ROW_ID</code>这三个字段</li></ul><p><code>DB_TRX_ID</code>，最后一次修改本行事务的ID</p><p><code>DB_ROLL_PTR</code>，即回滚指针,与undo日志配合</p><p><code>DB_ROW_ID</code>，随着新行插入而单调递增的行号（innoDB中如果既没有主键索引也没有唯一索引的时候，就会自动生成一个隐藏主键，就是这个玩意）</p><p>这三个字段结合<code>undo</code>日志，这个日志里面记录的都是老版本的数据，这样，快照读就可以读出适合的一个版本的数据出来。在数据库中，日志是非常重要的东西，可以说其重要性是大于数据本身的，因为数据丢失可以通过日志找回来，但是日志丢失了，那么以后数据库出现崩溃等就麻烦了。</p><h2>6. 日志</h2><p>数据库数据存放的文件称为<code>data file</code>；日志文件称为<code>log file</code>；数据库数据是有缓存的，如果没有缓存，每次都写或者读物理disk，那性能就太低下了。数据库数据的缓存称为<code>data buffer</code>，日志（redo）缓存称为<code>log buffer</code>；既然数据库数据有缓存，就很难保证缓存数据（脏数据）与磁盘数据的一致性。比如某次数据库操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> driver_info <span class="keyword">set</span> driver_status = <span class="number">2</span> <span class="keyword">where</span> driver_id = <span class="number">10001</span>;</span><br></pre></td></tr></table></figure><p>更新<code>driver_status</code>字段的数据会存放在缓存中，等待存储引擎将<code>driver_status</code>刷新<code>data_file</code>，并返回给业务方更新成功。如果此时数据库宕机，缓存中的数据就丢失了，业务方却以为更新成功了，数据不一致，也没有持久化存储。</p><p>上面的问题就可以通过事务的ACID特性来保证。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> trans；</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> driver_info <span class="keyword">set</span> driver_status = <span class="number">2</span> <span class="keyword">where</span> driver_id = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>这样执行后，更新要么成功，要么失败。业务方的返回和数据库<code>data file</code>中的数据保持一致。要保证这样的特性这就不得不说存储引擎<code>innodb</code>的<code>redo</code>和<code>undo</code>日志。</p><h5>6.1 undo是啥</h5><p>undo日志用于存放数据修改被修改前的值，假设修改 tba 表中 id=2的行数据，把Name=‘B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name='B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p><p>对数据的变更操作，主要来自 INSERT UPDATE DELETE，而UNDO LOG中分为两种类型，一种是 <code>INSERT_UNDO</code>（INSERT操作，事务提交后可以立即丢弃），记录插入的唯一键值；一种是 <code>UPDATE_UNDO</code>（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。</p><h5>6.2 redo是啥</h5><p>存储引擎也会为<code>redo</code> <code>undo</code>日志开辟内存缓存空间，<code>log buffer</code>。磁盘上的日志文件称为<code>log file</code>，是顺序追加的，性能非常高，注：磁盘的顺序写性能比内存的写性能差不了多少。</p><p>redo日志记录事务执行后的状态，用来恢复未写入<code>data file</code>的已成功事务更新的数据。例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为&lt;T1, X, 5&gt;，Redo日志为&lt;T1, X, 15&gt;。</p><p>梳理下事务执行的各个阶段：</p><ul><li>写undo日志到log buffer；</li><li>执行事务，并写redo日志到log buffer；</li><li>如果innodb_flush_log_at_trx_commit=1，则将redo日志写到log file，并刷新落盘。</li><li>提交事务。</li></ul><p>那redo日志是写进去了，但是数据呢？</p><p><strong>在数据库的世界里，数据从来都不重要，日志才是最重要的，有了日志就有了一切。</strong></p><p>因为<code>data buffer</code>中的数据会在合适的时间 由存储引擎写入到<code>data file</code>，如果在写入之前，数据库宕机了，根据落盘的redo日志，完全可以将事务更改的数据恢复。好了，看出日志的重要性了吧。先持久化日志的策略叫做<code>Write Ahead Log</code>，即预写日志。</p><h5>6.3 Undo + Redo事务的简化过程</h5><p>假设有A、B两个数据，值分别为1,2，开始一个事务，事务的操作内容为：把1修改为3，2修改为4，那么实际的记录如下（简化）：</p><ol><li>事务开始.</li><li>记录A=1到undo log buffer.</li><li>修改A=3.</li><li>记录A=3到redo log buffer.</li><li>记录B=2到undo log buffer.</li><li>修改B=4.</li><li>记录B=4到redo log buffer.</li><li>将redo log写入磁盘。</li><li>事务提交</li></ol><p>我们可以看到，2，4，5，7，8都是新增操作，但是2，4，5，7都是缓冲到buffer区，只有8是磁盘IO操作。为了保证Redo Log有较好的IO性能，设计一般有以下特点：</p><ul><li>尽量保持<code>Redo Log</code>存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配。 以顺序追加的方式记录<code>Redo Log</code>,通过顺序IO来改善性能。</li><li>批量写入日志。日志并不是直接写入文件，而是先写入<code>redo log buffer</code>.当需要将日志刷新到磁盘时 (如事务提交),将许多日志一起写入磁盘.</li><li>并发的事务共享<code>Redo Log</code>的存储空间，它们的<code>Redo Log</code>按语句的执行顺序，依次交替的记录在一起，</li></ul><blockquote><pre><code> 以减少日志占用的空间。例如,Redo Log中的记录内容可能是这样的： 记录1: &lt;trx1, insert …&gt; 记录2: &lt;trx2, update …&gt; 记录3: &lt;trx1, delete …&gt; 记录4: &lt;trx3, update …&gt; 记录5: &lt;trx2, insert …&gt;</code></pre></blockquote><ul><li>因为上一条的原因,当一个事务将<code>Redo Log</code>写入磁盘时，也会将其他未提交的事务的日志写入磁盘</li><li><code>Redo Log</code>上只进行顺序追加的操作，当一个事务需要回滚时，它的<code>Redo Log</code>记录也不会从<code>Redo Log</code>中删除掉。</li></ul><h5>6.4 回滚</h5><p>前面说到未提交的事务和回滚了的事务也会记录<code>Redo Log</code>，因此在进行恢复时,这些事务要进行特殊的的处理。有2种不同的恢复策略：</p><ul><li>进行恢复时，只重做已经提交了的事务。</li><li>进行恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过<code>Undo Log</code>回滚那些未提交的事务。</li></ul><p>MySQL数据库InnoDB存储引擎使用了第二个策略。</p><h2>InnoDB可重复读隔离级别下如何避免幻读</h2><blockquote><p>表象原因:快照读（非阻塞读）–伪MVCC</p></blockquote><blockquote><p>内在原因：next-key锁（行锁+gap锁）</p></blockquote><h6>6.5 next-key锁</h6><p>在 RR 级别下，如果查询条件能使用上唯一索引，或者是一个唯一的查询条件，那么仅加行锁，如果是一个范围查询，那么就会给这个范围加上 <code>gap</code> 锁或者 <code>next-key</code>锁 (行锁+gap锁)。</p><p>那么gap锁啥时候出现呢？</p><p>使用主键索引或者唯一索引时：</p><ul><li>如果where条件全部命中，则不会用Gap锁，只会加记录锁</li><li>如果where条件部分命中或者全不命中，则会加Gap锁</li></ul><p>在走非唯一索引或者不走索引的当前读中，也会出现Gap锁。对于不走索引的情况，那么就会锁住整张表。</p><p>总结一下：只有对唯一索引+全部命中才不会加gap锁。</p><p>具体来个例子说明间隙锁如何工作。</p><h2>7. 例子-走唯一索引</h2><h5>7.1 准备工作</h5><p>有这样一个表test，其中name为主键，id为唯一键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> ( </span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) primary <span class="keyword">key</span>, </span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>, <span class="keyword">unique</span> <span class="keyword">KEY</span> <span class="string">`id`</span> (<span class="string">`id`</span>) ) </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span> (<span class="string">"f"</span>,<span class="number">1</span>), (<span class="string">"h"</span>,<span class="number">2</span>), (<span class="string">"b"</span>,<span class="number">3</span>), (<span class="string">"a"</span>,<span class="number">5</span>), (<span class="string">"c"</span>,<span class="number">6</span>),(<span class="string">"d"</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>id</th></tr></thead><tbody><tr><td>f</td><td>1</td></tr><tr><td>h</td><td>2</td></tr><tr><td>b</td><td>3</td></tr><tr><td>a</td><td>5</td></tr><tr><td>c</td><td>6</td></tr><tr><td>d</td><td>9</td></tr></tbody></table><p>首先验证一下使用主键索引或者唯一索引时会怎么样。</p><h5>7.2 第一种情况：唯一索引+命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>此时由于id是唯一索引，并且是命中的，所以只是对这一行加排他锁，而没有加gap锁，所以session2是可以正常执行的，不能被阻塞。</p><h5>7.3 第一种情况：唯一索引+不命中数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>此时session2会阻塞住，证明id=7周围加了gap锁。gap锁的范围遵从左开右闭的原则，这里就是(6,7）以及(7,9)都会被锁住。加上record锁组成next-key锁，所以next-key锁的范围是(6,7]以及(7,9]这个范围。</p><h5>7.4 第三种情况：唯一索引+不命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>) <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>这里是一个范围，5和9都是存在的，但是7不存在，即部分数据不存在。</p><p>session2执行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",4);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",7);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",8);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",10);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>那么对于(5,9]的范围内就阻塞住了，那么部分命中就是部分加gap锁。</p><h5>7.5 第四种情况：唯一索引+命中所有数据</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>) <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>这里全部命中，那么</p><p>session2执行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",7);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",8);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>这个时候就不会加gap锁了。</p><h2>8. 例子-不走唯一索引或者不走索引</h2><p>下面来看看不走非唯一索引的当前读是什么情况。</p><p>此时表的数据为：</p><table><thead><tr><th>name</th><th>id</th></tr></thead><tbody><tr><td>h</td><td>2</td></tr><tr><td>c</td><td>6</td></tr><tr><td>b</td><td>9</td></tr><tr><td>d</td><td>9</td></tr><tr><td>f</td><td>11</td></tr><tr><td>a</td><td>15</td></tr></tbody></table><p>把id上的唯一索引换成了普通索引。</p><h5>8.1 第五种情况：非唯一索引</h5><p>session1执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">9</span>;</span><br></pre></td></tr></table></figure><p>session2执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">name</span>,<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="string">"swg"</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>此时session2是会被block住的。gap的范围是(6,9]以及(9,11].</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values("swg",5);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",7);&lt;!--不可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values("swg",12);&lt;!--可以--&gt;</span><br></pre></td></tr></table></figure><p>上面的原理都是一样的，即只要是6和11之间的数，不包含临界值的时候，无论插入什么数据，都是会阻塞的。</p><p>但是关于临界值6和11，这里就比较特殊了，因为需要加上主键的值才能进行精准的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into test(name,id) values(&quot;bb&quot;,6);&lt;!--可以--&gt;</span><br><span class="line"></span><br><span class="line">insert into test(name,id) values(&quot;dd&quot;,6);&lt;!--不可以--&gt;</span><br></pre></td></tr></table></figure><p>这是什么原因呢？</p><p>我们将数据画成图：</p><p><img src="http://bloghello.oursnail.cn/mysql4-8.jpg" alt="image"></p><p>这里的gap区间可能是(负无穷，2],(2,6],(6,9],(9,11],(11,15],(15,正无穷)</p><p>我们可以看到，id为6的行，对应的name为c(不要忘记name是主键，主键按照顺序排序)，那么主键中就是按照字母表的顺序进行排列的（ASCII码），如果插入的name小于c，那么就不在gap的范围内(c,)，就可以插入，但是dd在gap的范围内,所以就会阻塞住。</p><h5>8.2 第五种情况：不走索引</h5><p>这个时候，所有的间隙都会加上间隙锁，那么就是锁表了。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>锁模块</title>
      <link href="/2019/01/26/mysql/%E9%94%81%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/01/26/mysql/%E9%94%81%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>本章对行锁表所、共享锁排他锁进行详细说明。这是数据库锁的核心知识。</p><a id="more"></a><h2>MySQL中几种重要的锁概念</h2><h6>共享锁（S）和 排他锁（X）</h6><p>InnoDB 实现了标准的行级锁，包括两种：共享锁（简称 s 锁）、排它锁（简称 x 锁）</p><ul><li>共享锁允许持锁事务读取一行</li><li>排它锁允许持锁事务更新或者删除一行</li></ul><p>如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：</p><ul><li>T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁</li><li>T2 请求 x 锁不能被立即允许</li></ul><p>如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才行。</p><h6>意向锁</h6><p>innodb的意向锁主要用户多粒度的锁并存的情况。比如事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞。如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响。为了解决这个问题，可以在表级上引入新的锁类型来表示其所属行的加锁情况，这就引出了“意向锁”的概念。</p><p>举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。</p><p>说白了意向锁的主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”</p><ul><li>意向排它锁（简称 IX 锁）表明一个事务意图在某个表中设置某些行的 x 锁</li><li>意向共享锁（简称 IS 锁）表明一个事务意图在某个表中设置某些行的 s 锁</li></ul><p>例如， <code>SELECT ... LOCK IN SHARE MODE</code> 设置一个 IS 锁, <code>SELECT ... FOR UPDATE</code> 设置一个 IX 锁。</p><p>意向锁的原则如下：</p><ul><li>一个事务必须先持有该表上的 IS 或者更强的锁才能持有该表中某行的 S 锁</li><li>一个事务必须先持有该表上的 IX 锁才能持有该表中某行的 X 锁</li></ul><h6>next-key锁</h6><p>InnoDB有三种行锁的算法：</p><ul><li>Record Lock：单个行记录上的锁。分为S Lock和X Lock</li><li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</li><li>Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</li></ul><p>在默认情况下，mysql的事务隔离级别是可重复读，并且<code>innodb_locks_unsafe_for_binlog</code>参数为0，这时默认采用<code>next-key locks</code>。所谓<code>Next-Key Locks</code>，就是<code>Record lock</code>和<code>gap lock</code>的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。</p><p>例子：假设一个索引包含值 10,11,13和20，索引上可能的NK 锁包括如下几个区间（注意开闭区间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure><p>Innodb使用NK 锁来进行索引搜索和扫描，阻止了幻读。</p><p>间隙锁在Innodb中是被“十足的抑制”的，也就是说，他们只阻止其他事务插入到间隙中，他们不阻止其他事物在同一个间隙上获得间隙锁。</p><p>下篇文章会详细介绍一下。</p><h2>MyISAM和InnoDB关于锁方面的区别</h2><p>结论：</p><ul><li>MyISAM默认使用的是表级锁，不支持行级锁</li><li>InnoDB默认使用的是行级锁，也支持表级锁</li></ul><p>所谓表级锁，就是锁住整张表。开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p><strong>MyISAM在执行select的时候会产生一个表共享读锁，当进行更新等操作的时候会产生表独占写锁（排他锁）</strong>。所以：</p><ul><li>myISAM表的读操作，不会阻塞其他用户对同一个表的读请求，但会阻塞对同一个表的写请求。</li><li>myISAM表的写操作，会阻塞其他用户对同一个表的读和写操作。</li><li>myISAM表的读、写操作之间、以及写操作之间是串行的。</li></ul><blockquote><p>这里的读是共享锁，也可以将其变为排他锁，语法是select … for update</p></blockquote><p>上面说完了<code>MyISAM</code>的表锁，下面要说说<code>InnoDB</code>啦。<code>InnoDB</code>支持行级锁。</p><p>所谓行级锁，就是锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发性也最高。</p><h2>SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE</h2><p>如果你在查询数据，然后在同一个事务里插入或者修改相关的数据，常规的 <code>select</code> 语句不会提供足够的保护。其他的事务可以修改或者删除你正在查询的行。<code>InnoDB</code> 支持两种可以提供安全机制的读取锁：</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code></li><li><code>SELECT ... FOR UPDATE</code></li></ul><p><code>SELECT … LOCK IN SHARE MODE</code> 在读取的行上设置一个共享锁，其他的<code>session</code>可以读这些行，但在你的事务提交之前不可以修改它们。如果这些行里有被其他的还没有提交的事务修改，你的查询会等到那个事务结束之后使用最新的值。</p><p>索引搜索遇到的记录，<code>SELECT … FOR UPDATE</code> 会锁住行及任何关联的索引条目，和你对那些行执行 <code>update</code> 语句相同。其他的事务会被阻塞在比如执行 <code>update</code> 操作，获取共享锁，或从某些事务隔离级别读取数据等操作。</p><p>使用 <code>SELECT FOR UPDATE</code> 为 <code>update</code> 操作锁定行，只适用于 <code>autocommit</code> 被禁用（当使用 <code>START TRANSACTION</code> 开始事务或者设置 <code>autocommit</code> 为0时）。如果 <code>autocommit</code> 已启用，符合规范的行不会被锁定。</p><p>以上是对官方文档的翻译解读。</p><hr><p><code>SELECT … LOCK IN SHARE MODE</code> ：<strong>共享锁</strong>(S锁, <code>share locks</code>)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。</p><p>如果事务对某行数据加上共享锁之后，可进行读写操作；其他事务可以对该数据加共享锁，但不能加排他锁，且只能读数据，不能修改数据。</p><p><code>SELECT … FOR UPDATE</code>：<strong>排他锁</strong>(X锁, <code>exclusive locks</code>)。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。</p><p>注：普通 <code>select</code> 语句默认不加锁，而<code>CUD</code>操作默认加排他锁。</p><ul><li>当前事务获取共享锁后，可以读写，其他事务是否可以进行读写操作和获取共享锁：可以读，可以获取共享锁，不可以写</li><li>两个事务同时获取共享锁后，是否可以进行update操作：不可以</li><li>当前事务获取排他锁后，其他事务是否可以进行读写操作和获取共享锁：其他事务可以读，不可以获取共享锁，不可以写</li><li>是否可对一条数据加多个排他锁：不可以</li><li>行锁和索引的关系：查询字段未加索引（主键索引、普通索引等）时，使用表锁</li></ul><blockquote><p>注：InnoDB行级锁基于索引实现。</p></blockquote><blockquote><ul><li><p>未加索引时，两种行锁情况为（使用表锁）：</p><ul><li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的共享锁，不可以获取不同行数据的排他锁</li><li>事务1获取某行数据排他锁，其他事务不可以获取不同行数据的共享锁、排他锁</li></ul></li><li><p>加索引后，两种行锁为（使用行锁）：</p><ul><li>事务1获取某行数据共享锁，其他事务可以获取不同行数据的排他锁</li><li>事务1获取某行数据排他锁，其他事务可以获取不同行数据的共享锁、排他锁</li></ul></li></ul></blockquote><ul><li>索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</li></ul><h2>总结（很重要）</h2><ul><li>MyISAM默认使用的是表级锁，不支持行级锁<ul><li>执行select的时候会产生一个表共享读锁</li><li>当进行更新等操作的时候会产生表独占写锁（排他锁）</li><li>读不会阻塞其他session的读以及获取表共享读锁</li><li>写会阻塞其他session读和写操作</li><li>写与读之间是串行的</li></ul></li><li>InnoDB默认使用的是行级锁，也支持表级锁<ul><li>InnoDB 支持两种可以提供安全机制的读取锁：SELECT … LOCK IN SHARE MODE以及SELECT … FOR UPDATE</li><li>SELECT … LOCK IN SHARE MODE 在读取的行上设置一个共享锁</li><li>SELECT … FOR UPDATE：排他锁</li><li>一个session对某一行上共享锁，其他的session可以读这行，也可以获取共享锁，但是不允许写，更不允许获取写锁。对于其他行，可以读写其他行数据也可以上读写锁。</li><li>一个session对某一行上排他锁，其他的session则不能加任何锁，包括共享锁。允许读这一行，但是不能写。允许对其他行数据进行读写以及上读写锁。</li><li>InnoDB中行级锁基于索引实现，所以在不加索引的时候，这两者上的其实都是表锁；加上索引之后，使用行锁。</li></ul></li></ul><div class="tip"><p>以上的内容都是从博客：<a href="https://blog.csdn.net/u012099869/article/details/52778728" target="_blank" rel="noopener">https://blog.csdn.net/u012099869/article/details/52778728</a> 中整理而来，具体的实验也在他的博客中进行了详细的展示。</p></div><h2>MyISAM适合场景</h2><ul><li>频繁执行全表count语句(MyISAM已经用一个表保存了行数)</li><li>对数据进行增删改的频率不高，查询非常频繁</li><li>没有事务</li></ul><h2>InnoDB适合场景</h2><ul><li>数据增删改查都相当频繁</li><li>可靠性要求比较高，要求支持事务</li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于索引失效和联合索引</title>
      <link href="/2019/01/26/mysql/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/01/26/mysql/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/</url>
      <content type="html"><![CDATA[<p>理解最左前缀原则，可以帮助我们避免索引失效。</p><a id="more"></a><h2>索引失效</h2><blockquote><p>查询条件包含or</p></blockquote><p>当<code>or</code>左右查询字段只有一个是索引，该索引失效，<code>explain</code>执行计划<code>key=null</code>；只有当or左右查询字段均为索引时，才会生效；</p><blockquote><p>组合索引，不是使用第一列索引，索引失效</p></blockquote><ul><li>如果<code>select * from key1=1 and key2= 2;</code>建立组合索引<code>（key1，key2）</code>;</li><li><code>select * from key1 = 1;</code>组合索引有效；</li><li><code>select * from key1 = 1 and key2= 2;</code>组合索引有效；</li><li><code>select * from key2 = 2;</code>组合索引失效；不符合最左前缀原则</li></ul><blockquote><p>like 以%开头</p></blockquote><p>使用<code>like</code>模糊查询，当%在前缀时，索引失效；</p><blockquote><p>如何列类型是字符串，where时一定用引号括起来，否则索引失效</p></blockquote><blockquote><p>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效</p></blockquote><h2>最左前缀原则</h2><p>建立以下sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`test_index`</span>(</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`data`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`union_index`</span> (<span class="string">`a`</span>,<span class="string">`b`</span>,<span class="string">`c`</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> ROW_FORMAT=DYNAMIC  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=<span class="built_in">binary</span>;</span><br></pre></td></tr></table></figure><p>测试的<code>mysql</code>版本是 5.7.</p><ol><li>首先以列a作为条件查询数据，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 4</code> 表示索引长度为4，也就是利用上了索引来进行查找:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>然后以列b作为条件查询数据，可以看到<code>type: ALL</code>表示全表查找, <code>key_len: NULL</code> 表示没有索引，也就说明如果只使用b作为查询条件，不能利用索引来加快查找速度.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="3"><li>接着以列c作为条件查询数据，可以看到<code>type: ALL</code>表示全表查找, <code>key_len: NULL</code> 表示没有索引，情况与用b作为条件一样，只使用c作为查询条件也不能利用索引来加快查找速度</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="4"><li>现在来测一下使用a、b作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 8</code> 表示索引长度为8，也就是说我们利用上了a、b联合索引来进行查找</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> b = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">8</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="5"><li>紧接着来测一下使用a、c作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 4</code> 表示索引长度为4，这就奇怪了，按照最左原则来说，a、c上是不会建立索引的，为什么会有索引长度呢？其实与a、b上的索引一比较我们就能发现，a、c上的索引长度只有4，而且单独的c上是没有索引的，所以4字节长度的索引只能是a上的，也就是说这种情况我们只使用了a列上的索引来进行查找</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">index</span> condition</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="6"><li>为了进一步验证上面的想法，这一次测一下使用b、c作为条件的情况，我们看到 <code>type: ALL</code> 表示全表查找, <code>key_len: NULL</code> 表示没有索引可以使用，按照最左原则来说，b列上没有索引，c列上也没有索引，同时b、c的上也不存在联合索引，所以使用b、c作为查询条件时无法利用联合索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: ALL</span><br><span class="line">possible_keys: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">key</span>: <span class="literal">NULL</span></span><br><span class="line">   key_len: <span class="literal">NULL</span></span><br><span class="line">       <span class="keyword">ref</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">716173</span></span><br><span class="line">  filtered: <span class="number">1.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="7"><li>测试完两个条件的情况，接下来测试一下使用a、b、c作为条件的情况，我们看到 <code>type: ref</code> 表示引用查找, <code>key_len: 12</code> 表示索引长度为12，这完全符合联合索引的最左原则，同时使用3个条件查询可以利用联合索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">12</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="8"><li>下面这种情况也能利用a、b上的联合索引，索引长度为8</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> b = <span class="number">1</span> <span class="keyword">and</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">8</span></span><br><span class="line">       <span class="keyword">ref</span>: const,const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">  filtered: <span class="number">100.00</span></span><br><span class="line">     Extra: <span class="literal">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ol start="9"><li>再来试试这种情况，按照最左原则，c上没有建立索引，a上有索引，c、a没有建立联合索引，所以只能使用a上的索引进行查找，结果索引长度只有4，验证了我们的想法，联合查询条件使用索引时满足“交换律”</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">data</span> <span class="keyword">from</span> test_index <span class="keyword">where</span> c = <span class="number">1</span> <span class="keyword">and</span> a = <span class="number">1</span></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">        <span class="keyword">id</span>: <span class="number">1</span></span><br><span class="line">select_type: SIMPLE</span><br><span class="line">     <span class="keyword">table</span>: test_index</span><br><span class="line"><span class="keyword">partitions</span>: <span class="literal">NULL</span></span><br><span class="line">      <span class="keyword">type</span>: <span class="keyword">ref</span></span><br><span class="line">possible_keys: union_index</span><br><span class="line">       <span class="keyword">key</span>: union_index</span><br><span class="line">   key_len: <span class="number">4</span></span><br><span class="line">       <span class="keyword">ref</span>: const</span><br><span class="line">      <span class="keyword">rows</span>: <span class="number">70</span></span><br><span class="line">  filtered: <span class="number">10.00</span></span><br><span class="line">     Extra: <span class="keyword">Using</span> <span class="keyword">index</span> condition</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2>联合索引总结</h2><ol><li>联合索引的最左原则就是建立索引<code>KEY union_index (a,b,c)</code>时，等于建立了(a)、(a,b)、(a,b,c)三个索引，从形式上看就是索引向左侧聚集，所以叫做最左原则，因此最常用的条件应该放到联合索引的组左侧。</li><li>**对于&quot;=&quot;和&quot;in&quot;可以乱序。**利用联合索引加速查询时，联合查询条件符合“交换律”，也就是<code>where a = 1 and b = 1</code> 等价于 <code>where b = 1 and a = 1</code>。这归功于mysql查询优化器，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</li><li><strong>mysql会一直向右匹配直到遇到范围查询(&lt;,&gt;,between,like)就停止匹配</strong>。比如a=3 and b=4 and c&gt;5 and d=6，如果建立(a,b,c,d)顺序的索引，d是用不到索引的。如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li></ol><h2>对于最左匹配原则的理解</h2><p><a href="https://www.zhihu.com/question/36996520" target="_blank" rel="noopener">mysql索引最左匹配原则的理解?–沈杰的回答</a></p><p>其实我觉得只要理解一点就是，只要有最左边的索引元素，那么这个索引结构一定是按照最左索引元素排序的，后序的索引元素也是依赖于最左元素之后才有可能变得有意义。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL调优</title>
      <link href="/2019/01/26/mysql/MySQL%E8%B0%83%E4%BC%98/"/>
      <url>/2019/01/26/mysql/MySQL%E8%B0%83%E4%BC%98/</url>
      <content type="html"><![CDATA[<p>本文介绍最基本的sql调优手段。</p><a id="more"></a><h2>根据慢日志定位慢查询sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这里是用模糊查询查出关于查询的一些配置项--&gt;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%query%'</span></span><br></pre></td></tr></table></figure><p>我们关注<code>slow_query_log</code>：<code>OFF</code>，表示慢查询处于关闭状态。关注<code>long_query_time</code>：超出这个时间就是慢查询，记录到<code>slow_query_log_file</code>文件中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%slow_queries%'</span></span><br></pre></td></tr></table></figure><p>这一句作用是统计慢查询的数量。</p><p>如何打开慢查询呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--打开慢查询--&gt;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log = <span class="keyword">on</span>;</span><br><span class="line">&lt;!--慢查询的标准是1秒--&gt;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>注意要重启一下客户端。或者在配置文件中设置，重启服务端就永久保留了。</p><h2>explain分析慢日志</h2><p>上一步时打开慢查询日志。下面要进行分析。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ...</span><br></pre></td></tr></table></figure><p>对这个命令进行分析。有两个关键字段：</p><p><code>type</code>：表示mysql找到数据行的方式，下面的顺序是由快到慢：</p><p><code>system</code>&gt;<code>const</code>&gt; <code>eq_ref</code>&gt;<code>ref</code>&gt;<code>fulltext</code>&gt;<code>ref_or_null</code>&gt;<code>index_merge</code>&gt;<code>unique_subquery</code>&gt;<code>index_subquery</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>all</code></p><p><strong>其中<code>index</code>和<code>all</code>为全表扫描。说明需要优化。</strong></p><p><code>extra</code>：</p><ul><li><code>using_filesort</code>：表示MySQL会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容。可能在内存或者磁盘上进行排序。MqSQL中无法利用索引完成的排序操作称为“文件排序”</li><li><code>using temporary</code>：表示MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by。</li></ul><p><strong>当<code>extra</code>中出现以上两项意味着MYSQL根本不能使用索引，效率会受到重大影响，应尽可能对此进行优化。</strong></p><h2>修改sql或者尽量让sql走索引</h2><p>上一步分析完之后，就要采取一定的措施来修正。</p><p>如果是没有加索引，可以对其加上索引。<code>extra</code>就会变成<code>using index</code>，表示走了索引。</p><h2>索引是越多越好吗</h2><ul><li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li><li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li><li>更多的索引意味着也需要更多的空间</li></ul><p>可以理解为，一个几页的宣传手册</p><ul><li>对于几页的宣传手册我们还需要建立一个目录吗？</li><li>变更这个小的宣传手册里面的章节还要修改目录不是更烦吗？</li><li>一个宣传手册内容就两页，结果你的目录就占了一页，这合理吗？</li></ul>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL索引全面解读</title>
      <link href="/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>彻底理解MySQL的存储引擎数据结构以及聚集索引。</p><a id="more"></a><h2>1.为什么需要索引</h2><p>如果不用索引，那么最简单的方案是：将数据全部或者分批次地加载到内存，因为数据是以页的形式存储的，所以我们可以轮询这些页，找出有没有我们需要的数据。</p><p>在大数据量的情况下，显然是会非常慢的。因为它要进行全表的扫描。</p><p>而索引的灵感来源于字典，我们知道，新华字典前面有按照拼音或者按偏旁部首排序的一个列表页，我们可以快速地根据这个索引目录迅速定位到某几页，然后我们到这个某几页找一下就可以找到了。不需要全表扫描。</p><h2>2.索引的数据结构</h2><h5>2.1 二叉查找树上阵</h5><p>二叉查找树的特点：</p><ul><li>二分搜索树本质上是一棵二叉树。不需要是一棵完全二叉树。</li><li>每个节点的键值大于左孩子</li><li>每个节点的键值小于右孩子</li><li>以左右孩子为根的子树仍为二分搜索树</li></ul><p>二叉查找树有点很明显，我们查询一个数据只需要O(logn)的时间。但是它存在一个致命问题：</p><p>我们有时会删除增加数据，搞的不好，会把他恶化成一个链表。</p><p><img src="http://bloghello.oursnail.cn/mysql4-1.jpg" alt="image"></p><p>但是有的同学说，我们可以利用红黑树之类的数据结构来维持住平衡二叉树的特性，这样不就好了吗？</p><p>这里还存在另一个问题，就是IO。我们知道从磁盘查询数据，影响性能的关键点是iO的次数，然后这种一个节点只有两个孩子，在海量数据里，IO的次数还是太多，影响性能。</p><p>我们这个时候就知道了方向，我们想找一个数据结构，它既包含了二叉树的优点，还要是平衡的树，还能使树的高度变矮，并且每个节点存储更多的数据。</p><h5>2.2 BTree上阵</h5><p>B数又叫平衡多路查找树。M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉</p><p><img src="http://bloghello.oursnail.cn/mysql4-2.jpg" alt="image"></p><p>有几个特点：</p><ul><li>根节点至少包含两个孩子</li><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li><strong>子节点数</strong>：树中每个节点最多包含m个孩子(m&gt;=2)；除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子</li><li><strong>关键字数</strong>：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于m-1个（<strong>分别比孩子数少一个</strong>）</li><li>所有叶子节点都位于同一层，即所有叶子节点高度都一样</li></ul><p>我们结合这个图来理解。</p><p>可以看到，我们这是一个3路B树，根节点有3个孩子，有2个关键字。根据规则，子节点数最多为m个即3个，最少为ceil(1.5)个即2个；关键字数最多为m-1个即2个，最少为于ceil(1.5)-1个即1个.</p><p>那么我们进行插入的时候，关键字这里最多为2个，所以大于2就要进行拆分。</p><p>如何拆分呢？拿个例子来：</p><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;</p><p>那么关键字最多为4个，超过4个就拆分。</p><p>先插入 3、8、31、11</p><p><img src="http://bloghello.oursnail.cn/mysql4-23jpg.jpg" alt="image"></p><p>再插入23、29</p><p><img src="http://bloghello.oursnail.cn/mysql4-3.jpg" alt="image"></p><p>再插入50、28</p><p><img src="http://bloghello.oursnail.cn/mysql4-4.jpg" alt="image"></p><p>大概就是这样的流程。总之要维护一个从左到右逐渐增大的一个特性，并且必须是平衡的。(大概忽略里面可能存在的一些小错误，理解其中意思即可)</p><p>对于删除也是如此，要满足以上的特性才行，这里就不再赘述了。</p><p>对B树总结一下：</p><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p><h5>2.3 B+树</h5><p>是B树的变体，其定义基本上与B树是差不多的。除了：</p><ul><li><strong>非叶子节点的子树指针与关键字个数相同</strong></li><li><strong>非叶子节点仅用来索引，数据都保存在叶子节点中</strong></li><li><strong>所有叶子节点均有一个链指针指向下一个叶子节点</strong></li></ul><p>这就是B+树相对于B树的改进的几个点。</p><p>由于数据存在叶子节点，优点是非叶子节点保存的关键字更多了，树的高度就会更矮。</p><p><img src="http://bloghello.oursnail.cn/mysql4-5.jpg" alt="image"></p><h5>2.4 总结</h5><p>B+树更适合用来做存储索引：</p><ul><li>B+树的磁盘读写代价更低（因为内部不存放数据，一次性读取的关键字更多，IO次数降低）</li><li>B+树的查询效率更加稳定（任何关键字的查找都要到叶子节点，导致每个查询都差不多）</li><li>B+树有利于对数据库扫描（遍历叶子节点就可以直接扫描整个表，这个适合做范围查询）</li></ul><h5>2.5 Hash索引也可以考虑一下</h5><p>Hash结构可以一次性地定位到响应位置。如果遇到碰撞的情况，只需要遍历链表即可。那么性能这么高，为什么我们不用Hash索引呢？</p><p>它也有缺点：</p><ul><li>只能做等值操作，不能使用范围查询</li><li>hash索引不是按照索引值顺序存储，无法使用于排序。</li><li>不能利用部分索引键查询（比如组合索引，hash索引是对这几个索引一起hash计算的，而我们用组合索引中的部分索引时就无法用了）</li><li>不能避免表扫描（会出现hashs冲突，必然要扫描里面具体的数据才行）</li><li>遇到大量hash值相等的时候性能不一定比B树高(同上)</li></ul><h2>3. 聚集索引</h2><h5>3.1 什么是聚集索引</h5><p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><h5>3.2 MyISAM和InnoDB索引实现</h5><p><strong>第一个不同是：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</strong></p><p><code>MyISAM</code>引擎使用<code>B+Tree</code>作为索引结构，叶节点的<code>data</code>域存放的是数据记录的地址，是没有任何顺序而言的，所以<strong>MyISAM的索引方式也叫做“非聚集”的</strong>，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><p><code>MyISAM</code>中索引检索的算法为首先按照<code>B+Tree</code>搜索算法搜索索引，如果指定的Key存在，则取出其<code>data</code>域的值，然后以<code>data</code>域的值为地址，读取相应数据记录。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9523.png" alt="image"></p><p>在<code>MyISAM</code>中，主索引和辅助索引（<code>Secondary key</code>）在结构上没有任何区别，只是主索引要求<code>key</code>是唯一的，而辅助索引的<code>key</code>可以重复。</p><p><code>InnoDB</code>也使用<code>B+Tree</code>作为索引结构。<code>InnoDB</code>的数据文件本身就是索引文件，即  <code>InnoDB</code> 表是基于聚簇索引建立的。</p><p><code>MyISAM</code>索引文件和数据文件是分离的，索引文件仅保存数据记录的地址（这一点可以通过在<code>data</code>目录下查看数据库文件验证。<code>Innodb</code>每一个数据库只有一个数据文件，而<code>Myisam</code>则有三个（数据文件、索引文件、表结构文件））。</p><p>而在<code>InnoDB</code>中，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶节点<code>data</code>域保存了完整的数据记录。这个索引的<code>key</code>是数据表的主键，因此<code>InnoDB</code>表数据文件本身就是主索引。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9524.png" alt="image"></p><p>上图是<code>InnoDB</code>主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。聚集索引的确定规则为：</p><ul><li>若一个主键被定义，该主键则作为聚集索引</li><li>若没有主键被定义，该表的第一个唯一非空索引作为聚集索引</li><li>若上述都找不到，innodb内部会生成一个隐藏主键(聚集索引)</li><li>非主键索引存储相关键位和其对应的主键值，包含两次查找</li></ul><p><strong>第二个与<code>MyISAM</code>索引的不同是<code>InnoDB</code>的辅助索引<code>data</code>域存储相应记录主键的值而不是地址。</strong></p><p>换句话说，<code>InnoDB</code>的所有辅助索引都引用主键作为<code>data</code>域。</p><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p><img src="http://bloghello.oursnail.cn/mysql4-6.jpg" alt="image"></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了<code>InnoDB</code>的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在<code>InnoDB</code>中不是个好主意，因为<code>InnoDB</code>数据文件本身是一颗<code>B+Tree</code>，非单调的主键会造成在插入新记录时数据文件为了维持<code>B+Tree</code>的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择</p><h2>4. 总结</h2><p>本文首先介绍的是为什么要索引。这个问题很简单。</p><p>然后介绍了几种数据结构：二叉搜索树、二叉平衡树、B树以及B+树。一步一步引出为什么最终是B+树。面试的时候就看解决：为什么不能用二叉搜索树、为什么不用红黑树、B树和B+树各自的数据结构特点、B+树的优点</p><p>最后介绍了聚集索引，因为这是MyISAM与InnoDB索引结构最大的不同。</p><p>之前还是不能太准确理解聚集索引，这两种存储引擎都是以B+树数据结构建立索引结构的，但是InnoDB本身这个B+树就作为了索引文件，即索引与数据是放在一起的，所以逻辑上这样排的数据，它物理上也是这么排。</p><p>而MyISAM的索引结构(B+树)与数据是分离的，虽然B+树可能是按照主键有序地组织，但是表的数据在另一个地方是随机放的，找数据是根据地址来找即可，所以这种结构就不是聚集的。</p><p>理解了这个，下面就非常好理解了，InnoDB这个B+树，我们知道，叶子节点的核心数据就是主键。所以是按照主键递增的方式进行排列。这样子，无论是按照主键排序还是范围搜索，都会非常地快。</p><p>那么如果是非主键索引的辅助索引呢？InnoDB只能通过两次查询来实现了，首先第一步是根据这个辅助索引找到存放在叶子节点中的主键值，然后根据主键再去主键索引中去查找对应的数据。</p><p>而MyISAM索引，主键索引和辅助索引就区别不大了。都是单独一个索引结构，然后根据最后叶子节点中的该条数据的地址去找。</p><p>上面说的按照主键排列，就是这里所谓的聚集索引啦。当然了，如果没有指定主键，会按照上面所说的规则去构建聚集索引。</p><p>那么，面试的时候，就可以应对InnoDB与MyISAM索引结构的各自的实现和不同点啦。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库索引入门</title>
      <link href="/2019/01/26/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/"/>
      <url>/2019/01/26/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>索引是数据库中提高性能的一大利器。本篇入门索引的基本知识。</p><a id="more"></a><h2>1. 什么是索引</h2><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><h2>2. 为什么要用索引</h2><p>索引主要就是为了提高查询速度用的。</p><h2>3. 索引的一些缺点</h2><ul><li>第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h2>4. 哪些字段适合用索引</h2><ul><li><strong>在经常需要搜索的列上</strong>，可以加快搜索的速度；</li><li><strong>在作为主键的列上</strong>，强制该列的唯一性和组织表中数据的排列结构；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</li><li><strong>在经常需要根据范围进行搜索的列上创建索引</strong>，因为索引已经排序，其指定的范围是连续的；</li><li><strong>在经常需要排序的列上创建索引</strong>，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li><strong>在经常使用在WHERE子句中的列上面创建索引</strong>，加快条件的判断速度。（这同一）</li></ul><h2>5. 不应该创建索引的的这些列具有下列特点</h2><ul><li>第一，<strong>对于那些在查询中很少使用或者参考的列不应该创建索引</strong>。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>第二，<strong>对于那些只有很少数据值的列也不应该增加索引</strong>。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>第三，<strong>对于那些定义为<code>text</code>, <code>image</code>和<code>bit</code>数据类型的列不应该增加索引</strong>。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>第四，<strong>当修改性能远远大于检索性能时，不应该创建索引</strong>。这是因为，<strong>修改性能和检索性能是互相矛盾的</strong>。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><h2>6. 索引的分类</h2><p><code>B-Tree</code> 索引， <code>Hash</code> 索引， <code>Fulltext</code> 索引和<code>R-Tree</code> 索引</p><p>最主要关心的是<code>B-Tree</code> 索引。下面再提一下聚集索引，因为这是innodb最主要的组织方式。</p><p>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。</p><p>如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p><p><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">下一节</a>会详细讲到<code>InnoDB</code>和<code>MyISAM</code>的索引实现方式，他们最大的区别就是<code>InnoDB</code>是聚集索引，而<code>MyISAM</code>不是。</p><h2>7. 局部性原理与磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此<strong>为了提高效率，要尽量减少磁盘I/O</strong>。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会<strong>预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。<strong>这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。</strong></p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（<code>page</code>）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h2>8.B树/B+树</h2><p>想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是<code>B tree</code>或者 <code>B+ tree</code>，重要的事情说三遍：“<strong>平衡树，平衡树，平衡树</strong>”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。</p><p>我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。</p><p>事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。</p><p><strong>如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引</strong>。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。</p><p><strong>这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置</strong>。</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%9521.png" alt="image"></p><p>上图就是带有主键的表（聚集索引）的结构图。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句：</p><blockquote><p>select * from table where id = 1256;</p></blockquote><p>首先根据索引定位到1256这个值所在的叶结点，然后再通过叶结点取到id等于1256的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图</p><p><img src="http://bloghello.oursnail.cn/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%9522.jpg" alt="image"></p><p>这一节先对索引入个门，关于B+树以及聚集索引下篇文章来具体分析。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何设计一个关系型数据库</title>
      <link href="/2019/01/26/mysql/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/01/26/mysql/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>这是一个比较空的面试题，这里说一下如何回答。</p><a id="more"></a><h2>如何设计一个关系型数据库</h2><p>我们考虑开发一个数据库最重要的模块是什么。首先数据存储是其核心功能。因此会有一个存储模块来存储数据。介质主要是硬盘。</p><p>可是，光有存储是不行的。我们需要有以下程序模块对数据进行组织。</p><ul><li>存储管理</li></ul><p>我们需要对数据的格式和文件的分隔进行统一的管理，通过逻辑的形式来组合和表示出来。</p><p>我们知道程序处理，需要将数据先加载到内存中去，不可能直接在硬盘上进行处理。</p><p>我们通过io读取磁盘数据，磁盘的io是非常耗时的，所以硬盘以页的形式存储数据，根据局部性原理，往往用户要查询的数据周围的数据也会被查询到，所以取数据都是以页为单位查取多个数据，提高效率。</p><ul><li>缓存机制</li></ul><p>也就是上面提到的，一次IO不会只取用户所需要的一点数据，所以会涉及到缓存，缓存可能会不够放，那就涉及一些缓存淘汰的算法，比如比较常用的是LRU算法。</p><ul><li>SQL解析</li></ul><p>将SQL进行编译执行。如何提高SQL解析效率呢？可能也用缓存，缓存好SQL解析后的结果，下次再执行一样的SQL就可以免去解析的过程。</p><ul><li>日志管理</li></ul><p>要记录SQL操作，方便主从同步、灾难恢复等。这里要了解一下binlog.</p><ul><li>权限划分</li></ul><p>就是权限。</p><ul><li>容灾机制</li></ul><p>要对异常情况做好准备，比如数据库挂了怎么办。</p><ul><li>索引管理</li></ul><p>优化数据库执行效率。</p><ul><li>锁模块</li></ul><p>使得数据库支持并发操作。</p><h2>总结</h2><p>了解了上面的内容，我们就可以对这个问题做一个简单的总结性回答了，如何设计关系型数据库呢？首先数据库有一个存储的功能，使得它能存储在比如机械硬盘或者固态硬盘上面。其次，我们需要一个存储管理模块来映射程序逻辑与物理地址，实现存储管理。还需要缓存机制，对一些数据进行缓存提高效率，并且缓存不能太大，必须配备缓存淘汰机制；然后需要一个SQL解析模块，来解析SQL；然后需要日志管理来提供主从赋值、主从同步等功能；还需要一个权限划分模块，来提供给多用户使用场景；还需要容灾机制面对异常情况；最后，为了提高数据查询效率需要有索引管理模块；为了支持并发操作需要有锁模块。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>delete和truncate以及drop区别</title>
      <link href="/2019/01/25/mysql/delete%E5%92%8Ctruncate%E4%BB%A5%E5%8F%8Adrop%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/01/25/mysql/delete%E5%92%8Ctruncate%E4%BB%A5%E5%8F%8Adrop%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>这个题目我自己也被问过，这里简单整理一下。</p><a id="more"></a><p>先来个总结：</p><ul><li><code>drop</code>直接删掉表；</li><li><code>truncate</code>删除的是表中的数据，再插入数据时自增长的数据id又重新从1开始；</li><li><code>delete</code>删除表中数据，可以在后面添加<code>where</code>字句。</li></ul><h2>日志是否记录</h2><p><code>DELETE</code>语句执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p><p><code>TRUNCATE TABLE</code> 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><h2>是否可以回滚</h2><p><code>delete</code> 这个操作会被放到 <code>rollback segment</code> 中,事务提交后才生效。<code>truncate</code>、<code>drop</code>是DLL（data define language),操作立即生效，原数据不放到 <code>rollback segment</code> 中，不能回滚.</p><p>所以在没有备份情况下，谨慎使用 <code>drop</code> 与 <code>truncate</code>。</p><h2>表和索引占的空间</h2><p>当表被 <code>TRUNCATE</code> 后，这个表和索引所占用的空间会恢复到初始大小。</p><p>而 <code>DELETE</code> 操作不会减少表或索引所占用的空间。</p><p><code>drop</code>语句将表所占用的空间全释放掉。</p><p><code>TRUNCATE</code> 和 <code>DELETE</code> 只删除数据，而 <code>DROP</code> 则删除整个表（结构和数据）</p><p>所以从干净程度，<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></p><p>ok，差不多了。</p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql最基础知识小结</title>
      <link href="/2019/01/25/mysql/mysql%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/01/25/mysql/mysql%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>本文介绍关于数据库的最最最最基本的一些语法知识，如果这些都不熟悉，建议多多练习，因为后续的文章会比较深入原理。</p><a id="more"></a><p>一、DDL语句</p><p>1、创建数据库：<code>create database dbname;</code></p><p>2、删除数据库：<code>drop database dbname;</code></p><p>3、创建表：<code>create table tname;</code></p><p>4、删除表：<code>drop table tname;</code></p><p>5、修改表：略，懒得看</p><hr><p>二、DML语句</p><ul><li>插入：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span>(字段<span class="number">1</span>，字段<span class="number">2</span>，...) <span class="keyword">values</span> (value1,value2,...) , (value3,value4,..)</span><br></pre></td></tr></table></figure><ul><li>更新：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> 字段=<span class="keyword">value</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><ul><li>删除：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><p>这里要注意下<code>delete</code>和<code>truncate</code>以及<code>drop</code>三者的区别，下篇文章详解。</p><ul><li>单表查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure><ul><li>连表查询方式1：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 别名<span class="number">1.</span>字段,别名<span class="number">2.</span>字段 <span class="keyword">from</span> table1 别名<span class="number">1</span>,table2 别名<span class="number">2</span> <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><ul><li>连表查询方式2：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 别名<span class="number">1.</span>字段,别名<span class="number">2.</span>字段 <span class="keyword">from</span> table1 别名<span class="number">1</span> <span class="keyword">join</span> table2 别名<span class="number">2</span> <span class="keyword">on</span> ...</span><br></pre></td></tr></table></figure><p>这是全连接，这里就要了解一下笛卡儿积，简单来说，最后行数是左边表的函数乘以右边表的行数。详细的可以自行google.</p><ul><li>查询不重复的记录：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span> ...</span><br></pre></td></tr></table></figure><ul><li>排序：默认是升序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ... <span class="keyword">asc</span>/<span class="keyword">desc</span></span><br></pre></td></tr></table></figure><ul><li>limit：主要用于分页</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ... <span class="keyword">asc</span>/<span class="keyword">desc</span> <span class="keyword">limit</span> 起始偏移位置，显示条数</span><br></pre></td></tr></table></figure><ul><li>聚合：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*)/<span class="keyword">avg</span>(..)/<span class="keyword">sum</span>(...)/<span class="keyword">max</span>(...)/<span class="keyword">min</span>(...) <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">group</span> <span class="keyword">by</span> ... <span class="keyword">having</span> ....</span><br></pre></td></tr></table></figure><p>注意这里的<code>having</code>和<code>where</code>的区别：<code>where</code>是对表结果进行筛选，<code>having</code> 是对查询结果进行筛选，与<code>group by</code> 合用</p><ul><li>左连接和右连接</li></ul><p>左连接意思就是左表中的记录都在，右表没有匹配项就以null显示。记录数等于左表的行数。</p><p>右连接与之同理，尽量转为左连接做。</p><ul><li>子查询：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ... <span class="keyword">in</span> (<span class="keyword">select</span> ....)</span><br></pre></td></tr></table></figure><p>所谓子查询就是根据另一个<code>select</code>的结果再进行筛选，常用的是in,not in,=,!=,exits,not exits</p><ul><li>union<br>主要用于两张表中的数据的合并：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">from</span> table1 <span class="keyword">union</span> all <span class="keyword">select</span> 字段 <span class="keyword">from</span> table2</span><br></pre></td></tr></table></figure><p>要想不重复用<code>union</code></p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些常见的面试题</title>
      <link href="/2019/01/25/network/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/01/25/network/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>对这一块整理一些常见的面试题。</p><a id="more"></a><h2>1.TCP三次握手、四次挥手</h2><p>这部分略。前面已经说的很详细，包括握手为什么不是两次、为什么不是四次，为什么挥手要等2MSL的时间。</p><h2>2.常见的HTTP状态码及其含义</h2><ul><li>200 OK：正常返回信息</li><li>400 Bad Reqest：客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized：请求未经授权，这个状态码必须与WWW-Authenticate报头域一起使用</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在</li><li>500 Internal Server Error：服务器发生不可预期的错误</li><li>503 Server Unavilable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul><h2>3.Get请求和Post请求的区别</h2><ul><li>Http报文层面：GET将请求信息放在URL，POST则放在报文体中</li><li>数据库层面：GET符合幂等性和安全性(查询不会改变数据库)，POST不符合</li><li>其他层面：GET可以被缓存、被存储为书签，而POST不行</li></ul><h2>4.Cookie和Session的区别</h2><p>对于session，字面上理解是会话，可以理解为用户与服务端一对一的交互。是一个比较抽象的概念。</p><p>但是我们常说的session其实是这里抽象概念的一种实现方式罢了，我觉得没有必要咬文嚼字，下面直接从面试角度来分析一下。</p><p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。</p><p>这个Session是保存在服务端的，有一个唯一标识，这个唯一标识对应一个用户。在服务端保存Session的方法很多，内存、数据库、文件都有。</p><p>服务端解决了用户标识问题，但是服务端怎么知道此时操作浏览器的用户是谁呢？</p><p>这个时候<code>Cookie</code>就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。</p><p>实际上大多数的应用都是用 <code>Cookie</code> 来实现<code>Session</code>跟踪的，第一次创建<code>Session</code>的时候，服务端会在HTTP协议中告诉客户端(放在响应头中返回)，需要在 <code>Cookie</code> 里面记录一个<code>Session ID</code>，以后每次请求(请求头)把这个会话ID发送到服务器，我就知道你是谁了。</p><p>有人问，如果客户端的浏览器禁用了 <code>Cookie</code> 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p><p><code>Cookie</code>其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到<code>Cookie</code>里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是<code>Cookie</code>名称的由来，给用户的一点甜头。</p><p><strong>总结：</strong></p><p><code>Session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</p><p><code>Cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现<code>Session</code>的一种方式。</p><p>下面说一下很常见的一种写法。比如在单体应用中，我此时登陆你的网站了，你可以将我的信息保存在<code>session</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User currentUserInfo = userService.getUserByUsernameAndPasswd(username,password);</span><br><span class="line">session.setAttribute(<span class="string">"currentUser"</span>,currentUserInfo);</span><br></pre></td></tr></table></figure><p>下次，我就可以在我们之间的会话中随时获取我的个人信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User currentUser = session.getAttribute(<span class="string">"currentUser"</span>);</span><br></pre></td></tr></table></figure><p>其实这些就是利用存放在<code>Cookie</code>中的<code>JSESSIONID</code>来实现的。</p><h2>5.HTTP和HRTTPS的关系</h2><p>来说一下SSL(Security Sockets Layer，安全套接层)</p><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统对外的API，SSL3.0之后更名为TLS</li><li>采用身份验证和数据加密保证网络通信的安全和数据的完整性</li></ul><p>HTTPS数据传输流程：</p><ul><li>浏览器将支持的加密算法信息发送给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器</li><li>浏览器验证证书合法性，并结合证书公钥加密信息发给服务器</li><li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器</li><li>浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据</li></ul><p>这个也就不赘述了，下面直接说说区别。</p><ul><li>HTTPS需要到CA申请证书，HTTP不需要</li><li>HTTPS密文传输，HTTP明文传输</li><li>连接方式不同，HTTPS默认使用443端口，HTTP使用80端口</li><li>HTTPS=HTTP+加密+认证+完整性保护，更安全</li></ul><p>但是仍然存在一定的风险：</p><ul><li>浏览器默认填充http://，请求需要进行跳转，有被劫持的风险</li><li>可以使用HSTS(HTTP Strict Transport Security)优化（这个还不未主流，面试问的少）</li></ul><h2>Socket简介</h2><p>我们知道，进程与进程直接的通信最基本的要求是：可以唯一确定进程。</p><p>在本地进程通信中，可以用PID来唯一标识一个进程。</p><p>但是PID只在本地唯一，网络中PID冲突的几率还是存在的。</p><p>我们知道，到IP层就可以唯一定位到一台主机了，TCP层(tcp协议+端口号)可以唯一定位一台主机中的一个进程。</p><p>这样，我们可以通过ip地址+协议+端口号可以唯一标识一台主机的一个进程。这样就可以通过socket进行网络通信了。</p><p>socket是对TCP/IP协议的抽象，是操作系统对外开放的接口。</p><p>socket起源于unix，而unix是遵从一切皆文件的哲学。Socket是一种基于从打开、读/写、关闭的模式实现的。客户端和服务器各自维护一个文件，在连接建立后，可以供对方读取或者读取对方内容。</p><h2>socket相关题目</h2><p>编写一个网络程序，有客户端和服务端，客户端向服务端发送一个字符串，服务器收到字符串之后打印到命令行上，然后向客户端返回该字符串的长度，最后，客户端输出服务端返回的该字符串的长度，分别用TCP和UDP两种方式去实现。</p><p>代码地址：<a href="https://github.com/sunweiguo/TcpAndUdp/" target="_blank" rel="noopener">https://github.com/sunweiguo/TcpAndUdp/</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA基础核心-理解类、对象、面向对象编程、面向接口编程</title>
      <link href="/2019/01/24/java-basic/JAVA%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/01/24/java-basic/JAVA%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>什么是类，什么是对象，什么是面向对象编程，什么是面向接口编程。学习面向对象思想的语言，比如java，第一关可能就是要理解这些概念。下面就来好好琢磨一下。</p><a id="more"></a><h2>类和对象的概念</h2><p>首先总结一下：<strong>类是一个模板，对象就是用这个模板创造出来的东西</strong>。</p><p>比如，男孩，他就是一个模板，男的就行，那么对象是什么呢？就是具体某个男孩，比如男孩<code>BOB</code>，男孩<code>fourColor</code>.</p><p>请看下面一张图：</p><p><img src="http://bloghello.oursnail.cn/javabasic4-1.png" alt="image"></p><p>男孩女孩是比较抽象的概念，是模板，左边一排就是其具体的一些对象。你看长的都不一样，有的黑，有的白，有的高，有的矮，国家地区也不一样。但是他们都属于男孩或者女孩。</p><p>那么同理，人就是一个类，男孩女孩就是人的<strong>子类</strong>，因为人可能不仅包括男孩女孩，还包括第三性别这个类。</p><p>这里还引出了JAVA特性中的继承。继承简单理解就是父类有的东西(访问级别不能是private)的，那都是你的。比如你老爸的房子，就是属于你的，你出入自由。</p><p>人还可以分为胖人和瘦人这个子类。所以只要是抽象的模板，就是一个类。</p><ul><li>对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li>类：类是一个模板，它描述一类对象的行为和状态。</li></ul><p>下面就拿狗这个类来说事。狗是动物这个类的子类。</p><h2>Java中创建类</h2><h5>构造器方法说明</h5><p>需要创造一个类对象出来的时候，要用到这个类的构造器方法，那么啥是构造器方法呢？<strong>构造器方法就是创造类时的初始化方法</strong>，和类同名的方法，你可以在里面写自己的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    访问权限 构造方法名称()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">   <span class="comment">//构造方法一</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"nothing to do..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造方法二</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">      <span class="comment">//这里就可以给每条new出来的对象(狗)初始化一个名字</span></span><br><span class="line">      System.out.println(<span class="string">"hi,my name is "</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>一个相对比较完整的类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    <span class="comment">//构造器方法</span></span><br><span class="line">    <span class="comment">//声明成员变量---这个变量属于这个类</span></span><br><span class="line">    <span class="comment">//声明成员方法</span></span><br><span class="line">        <span class="comment">//在方法里面定义的变量是局部变量，区别于成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"nothing to do..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">       <span class="comment">//这里就可以给每条new出来的对象(狗)初始化一个名字</span></span><br><span class="line">       System.out.println(<span class="string">"hi,my name is "</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//狗的颜色--成员属性</span></span><br><span class="line">    <span class="keyword">public</span> String color;<span class="comment">//一般是private，赋值用set方法，取值用get方法，这里只是演示</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//狗的行为，它会叫---成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(<span class="string">"我会叫：汪汪汪~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>创建对象</h2><p>语法：</p><blockquote><p>类名 对象名 = new 类名() ;</p></blockquote><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog fourcolor ;    // 先声明一个 Dog 类的对象 fourcolor</span><br><span class="line">fourcolor = new Dog(&quot;fourcolor&quot;) ;  // 用 new 关键字实例化 Dog 的对象 fourcolor,此时调用构造方法二</span><br></pre></td></tr></table></figure><p>通过<code>Dog</code>这个类可以创造出<code>fourcolor</code>对象.下面我才能操作这个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//让它的颜色为黑色</span><br><span class="line">fourcolor.color = &quot;black&quot;;</span><br><span class="line">//让它叫</span><br><span class="line">fourcolor.say();</span><br></pre></td></tr></table></figure><h2>面向对象</h2><p>在理解了什么是类，什么是对象，就可以来说说面向对象到底是什么了。</p><p>先来说说面向过程，大家都学习过C语言。C语言就是典型的面向过程的语言。</p><p>举个例子：要把大象装进冰箱里，这件事，面向过程的程序员是这样思考的：</p><ul><li>把冰箱门儿打开。</li><li>把大象装进去。</li><li>把冰箱门儿关上。</li></ul><p>上面的每一件事都用一个函数来实现。抽象为下面三个函数：</p><ul><li>openTheDoor()；</li><li>pushElephant()；</li><li>closeTheDoor()；</li></ul><p>这样不挺好的吗？为什么不用面向过程的这种思维来编程呢，还要搞出什么面向对象来。</p><p>需求又来啦：</p><ul><li>「我要把大象装微波炉里」</li><li>「我要把狮子也装冰箱里」</li><li>「我要把大象装冰箱，但是门别关，敞着就行」</li></ul><p>这个时候，面向过程的程序员就悲剧了，来一个需求我就写一个函数，我还能下班吗？</p><p>面向对象从另一个角度来解决这个问题。它抛弃了函数，把「对象」作为程序的基本单元。</p><p>面向对象的世界里，到处都是对象。即：万物皆对象。</p><p>比如人这个类，每个具体的人(对象)都要有这样的属性：身高、体重、年龄。每个人都有这样的行为：吃饭、睡觉、上厕所。</p><p>那么，这些通用的属性+方法可以构建一个模板：人这个类。因为每个具体的人（对象）都需要这些基本的东西。当然了，每个人具体什么身高、什么体重、吃什么都是不一样的，所以每个对象一般都是不一样的。但是模板是一样的。</p><p>那么，回到刚才的需求，面向对象是如何思考这件事的呢？</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>就是说，我不用亲自管开门的细节，我只要叫他开门即可。</p><div class="tip">我们创建的对象，应该是刚刚好能做完它能做的事情，不多做，不少做。多做了容易耦合，各种功能杂糅在一个对象里。比如我有一个对象叫「汽车」，可以「行驶」，可以「载人」，现在的需求是要实现「载人飞行」，就不能重用这个对象，必须新定义一个对象「飞机」来做。如果你给「汽车」插上了翅膀，赋予了它「飞行」的能力，那么新来的同学面对你的代码就会莫名其妙，无从下手。</div><p>但是不禁要问：怎么实现这种下达命令就可以自动去执行的效果呢？或者说，我怎么知道它有这个功能啊！</p><h2>面向接口编程</h2><p>现在我们把「数据」和「行为」都封装到了对象里，相当于对象成了一个黑匣子，那我们怎么知道对象具有什么样的能力呢？这个问题的关键就是接口。</p><p>因为无论是把大象装进洗衣机还是冰箱，都要求洗衣机或者冰箱有开门和关门的功能。这个时候，我们就可以抽象出来一个接口：【自动门】。这个接口里面定义两个能力：【开门】和【关门】。</p><p>让洗衣机、冰箱、微波炉这些带门的东西全部实现【自动门】接口。</p><p>这个时候，每个具体的实现可能略有不同，比如冰箱开门是往外拽，但是洗衣机开门可能是往上翻盖子。</p><p>此时，我有一个需求，把大象放进冰箱。我一看，冰箱实现了【自动门】这个接口，里面有【开门】和【关门】两个方法，ok，我知道冰箱是可以开门和关门了，那就好办了。我直接下达命令即可。还是跟上面一样的步骤.</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>此时，需要将狮子也装冰箱里。那还是一样：</p><ul><li>向冰箱下达「开门」的命令。</li><li>向狮子下达「进冰箱」的命令。</li><li>向冰箱下达「关门」的命令。</li></ul><p>此时，我要把大象装冰箱，但是门别关，敞着就行，那就：</p><ul><li>向冰箱下达「开门」的命令。</li><li>向大象下达「进冰箱」的命令。</li></ul><p>是不是很方便？冰箱也可以换，我可以换成任何东西，只要实现了这个接口，这些东西就都有这些能力，那我才不管里面到底怎么实现的呢，直接下达【开门】【关门】命令即可。</p><p>这也引入了JAVA特性中另一个特性：封装。外界不知道里面实现细节，只需要知道它的功能和入参即可。</p><p>这就是面向过程和面向对象编程的区别，也顺带地理解了什么是面向接口编程。这是学习JAVA最基础也是最核心的点。</p><p>整理自：</p><ul><li><a href="https://tryenough.com/java05" target="_blank" rel="noopener">https://tryenough.com/java05</a></li><li><a href="http://www.woshipm.com/pmd/294180.html" target="_blank" rel="noopener">http://www.woshipm.com/pmd/294180.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java字符串核心一网打尽</title>
      <link href="/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/"/>
      <url>/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/</url>
      <content type="html"><![CDATA[<p>对字符串中最核心的点：对象创建和动态加入常量池这些点进行深入分析。</p><a id="more"></a><p>比如有两个面试题：</p><p>Q1：<code>String s = new String(&quot;abc&quot;);</code> 定义了几个对象。</p><p>Q2：如何理解<code>String</code>的<code>intern</code>方法？</p><p>A1：对于通过 <code>new</code> 产生的对象，会先去常量池检查有没有 “abc”，如果没有，先在常量池创建一个 “abc” 对象，然后在堆中创建一个常量池中此 “abc” 对象的拷贝对象。所以答案是：一个或两个。如果常量池中原来没有 ”abc”, 就是两个。如果原来的常量池中存在“abc”时，就是一个。</p><p>A2：当一个<code>String</code>实例调用<code>intern()</code>方法时，JVM会查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><h2>字面量和运行时常量池</h2><p>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池。</p><p>在JVM运行时区域的方法区中，有一块区域是运行时常量池，主要用来存储编译期生成的各种字面量和符号引用。</p><p>了解过JVM就会知道，在java代码被javac编译之后，文件结构中是包含一部分<code>Constant pool</code>的。比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译后，常量池内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #2 = String             #21            // abc</span><br><span class="line">  #3 = Class              #22            // StringDemo</span><br><span class="line">  #4 = Class              #23            // java/lang/Object</span><br><span class="line">  ...</span><br><span class="line">  #16 = Utf8               s</span><br><span class="line">  ..</span><br><span class="line">  #21 = Utf8               abc</span><br><span class="line">  #22 = Utf8               StringDemo</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p>上面的Class文件中的常量池中，比较重要的几个内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#16 = Utf8               s</span><br><span class="line">#21 = Utf8               abc</span><br><span class="line">#22 = Utf8               StringDemo</span><br></pre></td></tr></table></figure><p>上面几个常量中，<code>s</code>就是前面提到的符号引用，而<code>abc</code>就是前面提到的字面量。而Class文件中的常量池部分的内容，会在运行期被运行时常量池加载进去。</p><h2>new String创建了几个对象</h2><p>下面，我们可以来分析下<code>String s = new String(&quot;abc&quot;);</code>创建对象情况了。</p><p>这段代码中，我们可以知道的是，在编译期，符号引用<code>s</code>和字面量<code>abc</code>会被加入到Class文件的常量池中。由于是<code>new</code>的方式，在类加载期间，先去常量池检查有没有 “abc”，如果没有，先在常量池创建一个 “abc” 对象。</p><p>在运行期间，在堆中创建一个常量池中此 “abc” 对象的拷贝对象。</p><h2>运行时常量池的动态扩展</h2><p>编译期生成的各种字面量和符号引用是运行时常量池中比较重要的一部分来源，但是并不是全部。那么还有一种情况，可以在运行期像运行时常量池中增加常量。那就是String的<code>intern</code>方法。</p><p>当一个String实例调用<code>intern()</code>方法时，JVM会查找常量池中是否有相同<code>Unicode</code>的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个<code>Unicode</code>等于str的字符串并返回它的引用；</p><p><code>intern()</code>有两个作用，第一个是将字符串字面量放入常量池（如果池没有的话），第二个是返回这个常量的引用。</p><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s==s1:"</span>+(s==s1));</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s==s2:"</span>+(s==s2));</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1==s2:false</span><br><span class="line">s2==s3:true</span><br></pre></td></tr></table></figure><p>你可以简单的理解为<code>String s1 = &quot;hello world&quot;;</code>和<code>String s3 = new String(&quot;hello world&quot;).intern();</code>做的事情是一样的（但实际有些区别，这里暂不展开）。都是定义一个字符串对象，然后将其字符串字面量保存在常量池中，并把这个字面量的引用返回给定义好的对象引用。</p><p>对于<code>String s3 = new String(&quot;hello world&quot;).intern();</code>，在不调<code>intern</code>情况，<code>s3</code>指向的是JVM在堆中创建的那个对象的引用的（如<code>s2</code>）。但是当执行了<code>intern</code>方法时，<code>s3</code>将指向字符串常量池中的那个字符串常量。</p><p>由于<code>s1</code>和<code>s3</code>都是字符串常量池中的字面量的引用，所以<code>s1</code>==<code>s3</code>。但是，<code>s2</code>的引用是堆中的对象，所以<code>s2!=s1</code>。</p><h2>intern的正确用法</h2><p>不知道，你有没有发现，在<code>String s3 = new String(&quot;abc&quot;).intern();</code>中，其实<code>intern</code>是多余的？</p><p>因为就算不用<code>intern</code>，“abc&quot;作为一个字面量也会被加载到Class文件的常量池”&quot;，进而加入到运行时常量池中，为啥还要多此一举呢？到底什么场景下才会用到<code>intern</code>呢?<br>在解释这个之前，我们先来看下以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = s1 + s2;</span><br><span class="line">String s4 = <span class="string">"hello"</span> + <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><p>在经过反编译后，得到代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = (<span class="keyword">new</span> StringBuilder()).append(s1).append(s2).toString();</span><br><span class="line">String s4 = <span class="string">"helloworld"</span>;</span><br></pre></td></tr></table></figure><p>这就是阿里巴巴文档里为什么规定循环拼接字符串不准使用&quot;+&quot;而必须使用<code>StringBuilder</code>，因为反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个 <code>StringBuilder</code> 对象，然后进行<code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。</p><p>不恰当的方式形如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"start"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    str = str + <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，言归正传，可以发现，同样是字符串拼接，<code>s3</code>和<code>s4</code>在经过编译器编译后的实现方式并不一样。<code>s3</code>被转化成<code>StringBuilder</code>及<code>append</code>，而<code>s4</code>被直接拼接成新的字符串。</p><p>如果你感兴趣，你还能发现，<code>String s4 = s1 + s2;</code> 经过编译之后，常量池中是有两个字符串常量的分别是 <code>hello</code>、<code>world</code>（其实<code>hello</code>和<code>world</code>是<code>String s1 = &quot;hello&quot;;</code>和<code>String s2 = &quot;world&quot;;</code>定义出来的），拼接结果<code>helloworld</code>并不在常量池中。</p><p>如果代码只有<code>String s4 = &quot;hello&quot; + &quot;world&quot;;</code>，那么常量池中将只有<code>helloworld</code>而没有<code>hello</code>和 <code>world</code>。</p><p><strong>究其原因，是因为常量池要保存的是已确定的字面量值</strong>。也就是说，对于字符串的拼接，纯字面量和字面量的拼接，会把拼接结果作为常量保存到字符串。</p><p>如果在字符串拼接中，有一个参数是非字面量，而是一个变量的话，整个拼接操作会被编译成<code>StringBuilder.append</code>，这种情况编译器是无法知道其确定值的。只有在运行期才能确定。</p><p>那么，有了这个特性了，<code>intern</code>就有用武之地了。<strong>那就是很多时候，我们在程序中用到的字符串是只有在运行期才能确定的，在编译期是无法确定的，那么也就没办法在编译期被加入到常量池中</strong>。</p><p>这时候，对于那种可能经常使用的字符串，使用<code>intern</code>进行定义，每次JVM运行到这段代码的时候，就会直接把常量池中该字面值的引用返回，这样就可以减少大量字符串对象的创建了。</p><h2>总结</h2><h6>第一种情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(str1 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><ul><li>栈中开辟一块空间存放引用str1；</li><li>String池中开辟一块空间，存放String常量&quot;abc&quot;；</li><li>引用str1指向池中String常量&quot;abc&quot;；</li><li>str1所指代的地址即常量&quot;abc&quot;所在地址，输出为true</li></ul><h6>第二种情况：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>); </span><br><span class="line">System.out.println(str2 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><ul><li>栈中开辟一块空间存放引用str2；</li><li>堆中开辟一块空间存放一个新建的String对象&quot;abc&quot;；</li><li>引用str2指向堆中的新建的String对象&quot;abc&quot;；</li><li>str2所指代的对象地址为堆中地址，而常量&quot;abc&quot;地址在池中，输出为false；</li></ul><h6>第三、四种情况</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（3）</span></span><br><span class="line">String str1 = <span class="string">"a"</span>；</span><br><span class="line">String str2 = <span class="string">"b"</span>；</span><br><span class="line">String str3 = str1 + <span class="string">"b"</span>；</span><br><span class="line"><span class="comment">//str1 和 str2 是字符串常量，所以在编译期就确定了。</span></span><br><span class="line"><span class="comment">//str3 中有个 str1 是引用，所以不会在编译期确定。</span></span><br><span class="line"><span class="comment">//又因为String是 final 类型的，所以在 str1 + "b" 的时候实际上是创建了一个新的对象，在把新对象的引用传给str3。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）</span></span><br><span class="line"><span class="keyword">final</span> String str1 = <span class="string">"a"</span>；</span><br><span class="line">String str2 = <span class="string">"b"</span>；</span><br><span class="line">String str3 = str1 + <span class="string">"b"</span>；</span><br><span class="line"><span class="comment">//这里和(3)的不同就是给 str1 加上了一个final，这样str1就变成了一个常量。</span></span><br><span class="line"><span class="comment">//这样 str3 就可以在编译期中就确定了</span></span><br></pre></td></tr></table></figure><p>这里的细节在上面已经详细说明了。</p><h6>第五种情况</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"ab"</span>；</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br><span class="line">System.out.println(str1== str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2.intern() == str1);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>整理自：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4OTA3NDQ0Nw==&amp;mid=2455545837&amp;idx=1&amp;sn=5dde0e68c22e1827cc7422d1af39a2de&amp;chksm=fb9cbb8dcceb329b88dc91fe4c6a9d6535752cdd1191092d93da665b051f16c06bc9e0e2e508&amp;mpshare=1&amp;scene=24&amp;srcid=0121duABpN7IHaUl1JxPtp66&amp;ascene=14&amp;devicetype=android-26&amp;version=2700003b&amp;nettype=WIFI&amp;abtest_cookie=BgABAAgACgALABIAEwAUAAcAnoYeACaXHgBXmR4Am5keAJ2ZHgC3mR4A0pkeAAAA&amp;lang=zh_CN&amp;pass_ticket=UZ59UG%2Bqu2i5egH9vmxuu5prus%2FoCSM%2B4QOgzET8cSVcTyIG%2BDpQQbT5Prwgm96v&amp;wx_header=1" target="_blank" rel="noopener">我终于搞清楚了和String有关的那点事儿</a></li><li><a href="https://www.jianshu.com/p/2624036c9daa" target="_blank" rel="noopener">https://www.jianshu.com/p/2624036c9daa</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java字符串</title>
      <link href="/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<p>关于java字符串不可变特性的深入理解。</p><a id="more"></a><h2>什么是不可变对象？</h2><p>众所周知， 在Java中， String类是不可变的。那么到底什么是不可变的对象呢？ 可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><h2>区分对象和对象的引用</h2><p>对于Java初学者， 对于String是不可变对象总是存有疑惑。看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);  </span><br><span class="line">  </span><br><span class="line">s = <span class="string">"123456"</span>;  </span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p>打印结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = 123456</span><br></pre></td></tr></table></figure><p>首先创建一个 String 对象 <code>s</code> ，然后让 <code>s</code> 的值为 <code>ABCabc</code> ， 然后又让 <code>s</code> 的值为 <code>123456</code> 。 从打印结果可以看出，<code>s</code> 的值确实改变了。那么怎么还说 String 对象是不可变的呢？</p><p>其实这里存在一个误区：<strong>s只是一个String对象的引用，并不是对象本身</strong>。</p><p>对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。</p><p>引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。</p><p>也就是说，<code>s</code> 只是一个引用，它指向了一个具体的对象，当 s=“123456”; 这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个新的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。内存结构如下图所示：</p><p><img src="http://xiaozhao.oursnail.cn/%E5%BC%95%E7%94%A8%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="image"></p><h2>为什么String对象是不可变的？</h2><p>要理解 String 的不可变性，首先看一下 String 类中都有哪些成员变量。 在JDK1.6中，String 的成员变量有以下几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>在JDK1.7和1.8中，String 类做了一些改动，主要是改变了<code>substring</code>方法执行时的行为，这和本文的主题不相关。JDK1.7中 String 类的主要成员变量就剩下了两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span>  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>由以上的代码可以看出， <strong>在Java中 String 类其实就是对字符数组的封装</strong>。</p><p>JDK6中， <code>value</code>是String封装的数组，<code>offset</code>是String在这个value数组中的起始位置，<code>count</code>是String所占的字符的个数。</p><p>在JDK7中，只有一个<code>value</code>变量，也就是<code>value</code>中的所有字符都是属于<code>String</code>这个对象的。这个改变不影响本文的讨论。</p><p>除此之外还有一个<code>hash</code>成员变量，是该 String 对象的哈希值的缓存，这个成员变量也和本文的讨论无关。在Java中，数组也是对象。</p><p>所以<code>value</code>也只是一个引用，它指向一个真正的数组对象。其实执行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = “ABCabc<span class="string">";</span></span><br></pre></td></tr></table></figure><p>这句代码之后，真正的内存布局应该是这样的：</p><p><img src="http://xiaozhao.oursnail.cn/String%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="image"></p><p><code>value</code>，<code>offset</code>和<code>count</code>这三个变量都是<code>private</code>的，并且没有提供<code>setValue</code>， <code>setOffset</code>和<code>setCount</code>等公共方法来修改这些值，所以在<code>String</code>类的外部无法修改<code>String</code>。也就是说一旦初始化就不能修改， 并且在<code>String</code>类的外部不能访问这三个成员。</p><p>此外，<code>value</code>，<code>offset</code>和<code>count</code>这三个变量都是<code>final</code>的， 也就是说在 String 类内部，一旦这三个值初始化了， 也不能被改变。所以可以认为 String 对象是不可变的了。</p><p>那么在 String 中，明明存在一些方法，调用他们可以得到改变后的值。这些方法包括<code>substring</code>， <code>replace</code>， <code>replaceAll</code>， <code>toLowerCase</code>等。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"ABCabc"</span>;  </span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//ABCabc</span></span><br><span class="line">a = a.replace(<span class="string">'A'</span>, <span class="string">'a'</span>);  </span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//aBCabc</span></span><br></pre></td></tr></table></figure><p>那么<code>a</code>的值看似改变了，其实也是同样的误区。再次说明， <code>a</code>只是一个引用， 不是真正的字符串对象，在调用<code>a.replace('A', 'a')</code>时， 方法内部创建了一个新的String对象，并把这个心的对象重新赋给了引用a。String中<code>replace</code>方法的源码可以说明问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);<span class="comment">//new出了新的String对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>String对象真的不可变吗？</h2><p>从上文可知String的成员变量是<code>private final</code> 的，也就是初始化之后不可改变。那么在这几个成员中， <code>value</code>比较特殊，因为他是一个引用变量，而不是真正的对象。</p><p><code>value</code>是<code>final</code>修饰的，也就是说<code>final</code>不能再指向其他数组对象，那么我能改变<code>value</code>指向的数组吗？</p><p>比如将数组中的某个位置上的字符变为下划线“_”。 至少在我们自己写的普通代码中不能够做到，因为我们根本不能够访问到这个<code>value</code>引用，更不能通过这个引用去修改数组。<br>那么用什么方式可以访问私有成员呢？</p><p>没错，用反射， 可以反射出String对象中的<code>value</code>属性， 进而改变通过获得的<code>value</code>引用改变数组的结构。下面是实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s  </span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;   </span><br><span class="line">      </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取String类中的value字段  </span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//改变value属性的访问权限  </span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值  </span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符  </span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;  </span><br><span class="line">      </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个过程中，<code>s</code>始终引用的同一个 String 对象，但是再反射前后，这个 String 对象发生了变化， 也就是说，通过反射是可以修改所谓的“不可变”对象的。但是一般我们不这么做。</p><p>这个反射的实例还可以说明一个问题：<strong>如果一个对象，他组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final 的，但是这个Wheel对象内部的状态可以改变， 那么就不能很好的保证Car对象不可变。</strong></p><p>参考：</p><ul><li><a href="https://blog.csdn.net/zhangjg_blog/article/details/18319521" target="_blank" rel="noopener">https://blog.csdn.net/zhangjg_blog/article/details/18319521</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Integer拆箱和装箱</title>
      <link href="/2019/01/23/java-basic/Integer%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1/"/>
      <url>/2019/01/23/java-basic/Integer%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1/</url>
      <content type="html"><![CDATA[<p>由于笔试经常遇到，所以这里整理一下。将Integer这一块一网打尽。</p><a id="more"></a><h2>拆箱和装箱</h2><p>这里以面试笔试经常出现的<code>Integer</code>类型为例，请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*第一组*/</span></span><br><span class="line">    Integer i = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    Integer i2 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i == i2);</span><br><span class="line"></span><br><span class="line">    Integer i3 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    Integer i4 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第二组*/</span></span><br><span class="line">    Integer i5 = <span class="number">128</span>;</span><br><span class="line">    Integer i6 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i5 == i6);</span><br><span class="line"></span><br><span class="line">    Integer i7 = <span class="number">127</span>;</span><br><span class="line">    Integer i8 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i7 == i8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第三组*/</span></span><br><span class="line">    Integer i9 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">int</span> i10 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i9 == i10);</span><br><span class="line"></span><br><span class="line">    Integer i11 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    <span class="keyword">int</span> i12 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i11== i12);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第四组*/</span></span><br><span class="line">    Integer i13 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">    Integer i14 = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">    System.out.println(i13 == i14);</span><br><span class="line"></span><br><span class="line">    Integer i15 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">    Integer i16 = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">    System.out.println(i13 == i14);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*第五组*/</span></span><br><span class="line">    Integer i17 = Integer.valueOf(<span class="number">128</span>);</span><br><span class="line">    Integer i18 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(i17 == i18);</span><br><span class="line"></span><br><span class="line">    Integer i19 = Integer.valueOf(<span class="number">127</span>);</span><br><span class="line">    Integer i20 = <span class="number">127</span>;</span><br><span class="line">    System.out.println(i19 == i20);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>翻开源码(jdk8)，我们可以看到一个私有的静态类，叫做整形缓存。顾名思义，就是缓存某些整型值，我们可以看到，它默认将-127-128之间数字封装成对象，放进一个常量池中，以后定义类似于<code>Integer a = 1</code>里面的<code>a</code>就可以直接从这个常量池中取对象即可，不需要重新<code>new</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>Integer.valueOf()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，也是先看看是不是在-127到128之间的范围，是的话就从 <code>cache</code> 中取出相应的 <code>Integer</code> 对象即可。</p><ul><li>第一组中<ul><li>第一种情况，<code>i</code> 是创建的一个<code>Integer</code>的对象，取值是128。<code>i2</code> 是进行自动装箱的实例，因为这里超出了-128到127的范围，所以是创建了新的<code>Integer</code>对象。由于<code>==</code>比较的是地址，所以两者必然不一样。</li><li>第二种情况就不一样了，<code>i4</code>是不需要自己<code>new</code>，而是可以直接从缓存中取，但是<code>i3</code>是<code>new</code>出来的，地址还是不一样。</li></ul></li><li>第二组中<ul><li>第一种情况是都超出范围了，所以都要自己分别去<code>new</code>，所以不一样</li><li>第二种情况是在范围内，都去缓存中取，实际上都指向同一个对象，所以一样</li></ul></li><li>第三组中<ul><li><code>i10</code>和<code>i12</code>都是<code>int</code>型，<code>i9</code>和<code>i11</code>与它们比较的时候都要自动拆箱，所以比较的是数值，所以都一样</li></ul></li><li>第四组中<ul><li>与第一组原理一样</li></ul></li><li>四五组中<ul><li>与第二组原理一样</li></ul></li></ul><p>所以啊，<code>new Integer()</code>是每次都直接<code>new</code>对象出来，而<code>Integer.valueOf()</code>可能会用到缓存，所以后者效率高一点。</p><h2>总结</h2><ul><li><code>int</code> 和 <code>Integer</code> 在进行比较的时候， <code>Integer</code> 会进行拆箱，转为 <code>int 值与</code>int` 进行比较。</li><li><code>Integer</code> 与 <code>Integer</code> 比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是 <code>-128&lt;= x&lt;=127</code> 的整数，将会直接缓存在 <code>IntegerCache</code> 中，那么当赋值在这个区间的时候，不会创建新的 <code>Integer</code> 对象，而是从缓存中获取已经创建好的 <code>Integer</code> 对象。二：当大于这个范围的时候，直接 <code>new Integer</code> 来创建 <code>Integer</code> 对象。</li><li><code>new Integer(1)</code> 和 <code>Integer a = 1</code> 不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从 <code>IntegerCache</code> 中获取的。那么 <code>Integer a = 128</code>, 大于该范围的话才会直接通过 <code>new Integer(128)</code>创建对象，进行装箱。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式事务解决方案思考</title>
      <link href="/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/"/>
      <url>/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>在分布式系统中，最头疼的就是分布式事务问题，处理起来一定要小心翼翼。由于没有此方面实战，本文就从理论上看看比较好的分布式事务处理方案。</p><a id="more"></a><h2>什么是分布式事务</h2><p>众所周知，数据库能实现本地事务，也就是在同一个数据库中，你可以允许一组操作要么全都正确执行，要么全都不执行。这里特别强调了<strong>本地事务</strong>，也就是目前的数据库只能支持同一个数据库中的事务。但现在的系统往往采用微服务架构，业务系统拥有独立的数据库，因此就出现了<strong>跨多个数据库的事务需求</strong>，这种事务即为“分布式事务”。那么在目前数据库不支持跨库事务的情况下，我们应该如何实现分布式事务呢？</p><p>比如用户下单过程。当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：</p><ul><li>用户通过商品系统浏览商品，他看中了某一项商品，便点击下单</li><li>此时订单系统会生成一条订单</li><li>订单创建成功后，支付系统提供支付功能</li><li>当支付完成后，由积分系统为该用户增加积分</li></ul><p>上述步骤2、3、4需要在一个事务中完成。对于传统单体应用而言，实现事务非常简单，只需将这三个步骤放在一个方法A中，再用Spring的<code>@Transactional</code>注解标识该方法即可。Spring通过数据库的事务支持，保证这些步骤要么全都执行完成，要么全都不执行。但在这个微服务架构中，这三个步骤涉及三个系统，涉及三个数据库，此时我们必须在数据库和应用系统之间，通过某项黑科技，实现分布式事务的支持。</p><h2>方案1：基于可靠消息服务的分布式事务</h2><p><img src="http://bloghello.oursnail.cn/mama11-1.png" alt="image"></p><ul><li>在系统A处理任务A前，首先向消息中间件发送一条消息</li><li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li><li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li><li>系统A收到确认应答后，则可以开始处理任务A；</li><li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。<br>但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li><li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li><li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li></ul><p>上述过程中，如果任务A处理失败，那么需要进入回滚流程:</p><ul><li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li><li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li></ul><p>上面所介绍的<code>Commit</code>和<code>Rollback</code>都属于理想情况，但在实际系统中，<code>Commit</code>和<code>Rollback</code>指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是超时询问机制。</p><p>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的<code>Commit</code>或<code>Rollback</code>指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p><ul><li>提交  若获得的状态是“提交”，则将该消息投递给系统B。</li><li>回滚  若获得的状态是“回滚”，则直接将条消息丢弃。</li><li>处理中  若获得的状态是“处理中”，则继续等待。</li></ul><p>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p><p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。</p><p>注意，这个方案需要消息队列具有事务消息的能力，阿里的<code>RocketMQ</code>可以实现这个目标。其他的MQ还不行。</p><h2>方案2：最大努力通知（定期校对）</h2><p><img src="http://bloghello.oursnail.cn/mama11-2.png" alt="image"></p><ul><li>上游系统在完成任务后，向消息中间件同步地发送一条消息，确保消息中间件成功持久化这条消息，然后上游系统可以去做别的事情了；</li><li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；</li><li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</li></ul><p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p><ul><li>消息中间件向下游系统投递消息失败</li><li>上游系统向消息中间件发送消息失败</li></ul><p>对于第一种情况，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，<strong>如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“定期校对”</strong>。</p><p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p><p>对于第二种情况，需要在上游系统中建立消息重发机制。<strong>可以在上游系统建立一张本地消息表，并将 任务处理过程 和 向本地消息表中插入消息 这两个步骤放在一个本地事务中完成</strong>。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。</p><p>如果这两步都执行成功，那么该本地事务就完成了。<strong>接下来会有一个专门的消息发送者不断地发送本地消息表中的消息</strong>，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p><p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过重试机制+定期校对实现分布式事务，但相比于第一种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p><p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。还有其他的一些解决思路，这里就暂时只描述这些。后续再学习。</p><p>参考自：<a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca" target="_blank" rel="noopener">https://juejin.im/post/5aa3c7736fb9a028bb189bca</a></p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>库存扣减问题</title>
      <link href="/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>库存扣减问题一直是秒杀中最关键的一个点。如果把控不好，扣成负数，那可就麻烦了，如么如何保证不会出现超卖还能保证性能呢？</p><a id="more"></a><h2>一、扣减库存问题分析</h2><p>在提交订单的时候，要扣减库存，对于sql，是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>首先这条sql存在超卖问题，很有可能会减成负数。可能会改成如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span> <span class="keyword">and</span> stock &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样好像解决了超卖问题。但是引入了新的问题。由于库存牵涉进货、补货等系统，所以是个独立的服务。</p><p>并且，比如我是通过MQ去通知库存进行扣减库存，但是由于网络抖动，请求扣减库存没有结果，这个时候可能需要进行重试。重试之后，可能成功了，这个时候，有可能这两次都成功了。那么，一个用户买一样东西，但是库存扣了两遍。这就是幂等。如果不做幂等处理，重试会出现上述这种致命问题。</p><p>那么如何做到幂等呢？</p><p>实际上就是追求数据一致性。那么就可以考虑锁来保证，比如我这里用乐观锁来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> stock,<span class="keyword">version</span> <span class="keyword">from</span> t_stock;</span><br><span class="line">if(stock &gt; 用户购买数量)</span><br><span class="line">    <span class="keyword">update</span> t_stcok <span class="keyword">set</span> stock = stock<span class="number">-2</span> <span class="keyword">where</span> sku_id = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span> = last_version</span><br></pre></td></tr></table></figure><p>但是，一旦出现并发，那么可能这个用户是执行update失败的，所以还需要去重试(guava retry或者spring retry都可以优雅地实现重试)，直到成功或者库存已经不足。</p><p>那么，在少量并发的情况下，可以考虑乐观锁，要不然会大量失败，此时需要用悲观锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_stock <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">下面执行<span class="keyword">update</span>操作。。。</span><br></pre></td></tr></table></figure><p>在一个事务内，第一句为<code>select for update</code>，那么这一行数据就会被本线程锁住，整个事务执行完才能允许其他线程进来。</p><p>存在的问题：一个线程锁住这行数据，那么其他线程都要等待，效率很低。</p><p>那么，如何保证数据一致性，还可以提高效率呢？</p><p>对于扣减库存，往往是先在redis中进行扣减库存。redis是单线程，是高速串行执行，不存在并发问题。</p><p>如果是单机redis，可以在同一个事务中保证一次性执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch stock</span><br><span class="line">multi</span><br><span class="line">if stock &gt; count</span><br><span class="line">    stock = stock - count;</span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/mama8-1.png" alt="image"></p><p>但是不能在集群中用（分布在不同节点上时），所以用watch不通用。</p><p>redis都是原子操作，比如自增:incrby，用这个就可以判断库存是否够。就是所谓的redis预减库存。</p><p>但是在实际中，库存表里有两个字段：库存和锁定库存。</p><p>锁定库存是表示多少用户真正下单了，但是还没有支付。锁定库存+库存=总库存，等用户真正支付之后，就可以将锁定库存减掉。那么，此时，redis中需要存库存和锁定库存这两个值，上面单一的原子操作就不行了。</p><p>解决方案：redis+lua</p><p>为什么要用lua呢？可以用lua将一系列操作封装起来执行，输入自己的参数即可。lua脚本在redis中执行是串行的、原子性的。</p><p>OK，下面就实战一波：根据skuId查询缓存中的库存值。</p><h2>二、查询库存（设置库存）</h2><p>首先，我们要明确一点，redis中的库存初始值是由后台的系统人工提前配置好的，在进行商品销售时（用户下单时），直接从redis中先进行库存的扣减。</p><p>这里呢，我们没有进行初始化，而是在程序中进行判断：如果redis已经有了这个库存值，就将他查询出来返回；否则，就去数据库查询，然后对redis进行初始化。</p><p>这里的一个问题是：如果存在并发问题，但是我们初始化两个值（库存值和库存锁定值），这里采用lua脚本，在lua脚本中完成初始化，并且对于两个用户同时进行初始化库存的问题，可以在lua中进行判断,因为redis是单线程，lua也是单线程，不用担心会同时初始化两次。</p><p>下面首先写一个接口，根据skuid查询库存(库存和锁定库存)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/query/&#123;skuId&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult&lt;Stock&gt; <span class="title">queryStock</span><span class="params">(@PathVariable <span class="keyword">long</span> skuId)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;Stock&gt;  result = <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"库存查询成功"</span>);</span><br><span class="line">    Stock stock = <span class="keyword">new</span> Stock();</span><br><span class="line">    stock.setSkuId(skuId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stockCount = stockService.queryStock(skuId);</span><br><span class="line"></span><br><span class="line">    stock.setStock(stockCount);</span><br><span class="line">    result.setData(stock);</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">queryStock</span><span class="params">(<span class="keyword">long</span> skuId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先查redis</span></span><br><span class="line">    Stock stock ;</span><br><span class="line">    String stockKey = Constants.CACHE_PRODUCT_STOCK+<span class="string">":"</span>+skuId;</span><br><span class="line">    String stockLockKey = Constants.CACHE_PRODUCT_STOCK_LOCK+<span class="string">":"</span>+skuId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只需要查询一个即可，比如我这里只查询库存就行</span></span><br><span class="line">    Object stockObj = redisTemplate.opsForValue().get(stockKey);</span><br><span class="line">    Integer stockInRedis = <span class="keyword">null</span> ;</span><br><span class="line">    <span class="keyword">if</span>(stockObj!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stockInRedis = Integer.valueOf(stockObj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有，那么我就需要将数据库中的数据初始化到redis中</span></span><br><span class="line">    <span class="keyword">if</span>(stockInRedis==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//去数据库查询 然后对redis进行初始化</span></span><br><span class="line">        stock = stockMapper.selectBySkuId(skuId);</span><br><span class="line">        <span class="comment">//两个key和两个库存值通过lua脚本塞到redis中</span></span><br><span class="line">        <span class="comment">//这里如果发生两个用户并发初始化redis，脚本中会进行判断，如果已经初始化了，脚本就会停止执行</span></span><br><span class="line">        <span class="comment">// 设置库存不应该在这配置，应该是后台管理系统进行设置，所以正常情况下，这里redis中应该是必然存在的</span></span><br><span class="line">        <span class="comment">//如果是在后台配置，就没有必要这么复杂了</span></span><br><span class="line">        redisUtils.skuStockInit(stockKey,stockLockKey,stock.getStock().toString(),stock.getLockStock().toString());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stockInRedis;<span class="comment">//缓存中有就直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存结果可能会返回设置不成功，所以还是返回数据库查询结果</span></span><br><span class="line">    <span class="keyword">return</span> stock.getStock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个工具类为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看redis是否已经初始化好库存初始值，没有就初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_CACHE_LUA =</span><br><span class="line">        <span class="string">"local stock = KEYS[1] "</span> +</span><br><span class="line">                <span class="string">"local stock_lock = KEYS[2] "</span> +</span><br><span class="line">                <span class="string">"local stock_val = tonumber(ARGV[1]) "</span> +</span><br><span class="line">                <span class="string">"local stock_lock_val = tonumber(ARGV[2]) "</span> +</span><br><span class="line">                <span class="string">"local is_exists = redis.call(\"EXISTS\", stock) "</span> +</span><br><span class="line">                <span class="string">"if is_exists == 1  then "</span> +</span><br><span class="line">                <span class="string">"   return 0 "</span> +</span><br><span class="line">                <span class="string">"else  "</span> +</span><br><span class="line">                <span class="string">"   redis.call(\"SET\", stock, stock_val) "</span> +</span><br><span class="line">                <span class="string">"   redis.call(\"SET\", stock_lock, stock_lock_val) "</span> +</span><br><span class="line">                <span class="string">"   return 1 "</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 缓存sku库存 以及锁定库存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">skuStockInit</span><span class="params">(String stockKey,String stockLockKey,String stock,String stockLock)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用jedis去执行lua脚本 输入的参数要注意顺序 都是写死的 第一组是key，第二组是stock</span></span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(STOCK_CACHE_LUA, Collections.unmodifiableList(Arrays.asList(stockKey,stockLockKey))</span><br><span class="line">                ,Collections.unmodifiableList(Arrays.asList(stock, stockLock)));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (EXCUTE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于lua脚本进行稍微的解释一下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//第一组数据是key数组；第二组数据是args数组，是与key数组对应的值，就是库存</span><br><span class="line">//我们这里第一组为[stockKey,stockLockKey],就是存在redis中的名字，这里是在service层中定义好了</span><br><span class="line">//第二组为[<span class="number">50</span>,<span class="number">0</span>]，这个值就是可以从数据库表t_stock中查询出来的</span><br><span class="line">//因为执行这段lua脚本的话，说明redis中没有缓存的数据，所以需要先查询数据库，然后将缓存设置好</span><br><span class="line">//lua中定义变量用<span class="keyword">local</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> stock = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> stock_lock = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> stock_val = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> stock_lock_val = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">//再查询一遍缓存是否存在，防止两个线程同时进来设置缓存</span><br><span class="line">//存在就不用设置缓存了，否则就设置缓存</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> is_exists = redis.call(<span class="string">"EXISTS"</span>, stock)</span><br><span class="line"><span class="keyword">if</span> is_exists == <span class="number">1</span>  <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">"SET"</span>, stock, stock_val)</span><br><span class="line">    redis.call(<span class="string">"SET"</span>, stock_lock, stock_lock_val)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>那么，启动工程<code>mama-buy-stock</code>：假如我去查询skuId=1的商品：</p><p><img src="http://bloghello.oursnail.cn/mama8-2.png" alt="image"></p><p>第一次库存不存在，那么就会去查询数据库：</p><p><img src="http://bloghello.oursnail.cn/mama8-3.png" alt="image"></p><p>我们再来看看redis中的数据：</p><p><img src="http://bloghello.oursnail.cn/mama8-4.png" alt="image"></p><h2>三、扣减库存</h2><p>下面来看看扣减库存是如何实现的。因为提交订单后，往往是不止一件商品的，往往购物车内有很多件商品，同时过来，假设有五件商品，但是其中只有一件暂时没有库存了，那么我还是希望其他的四件商品能够卖出去，只是没有库存的商品就不算钱了。所以扣减库存用一个map来装，即<code>Map&lt;skuId,count&gt;</code></p><p>controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/reduce"</span>)</span><br><span class="line"><span class="keyword">public</span> ApiResult&lt;Map&lt;Long,Integer&gt;&gt; reduceStock(<span class="meta">@RequestBody</span> List&lt;StockReduce&gt; stockReduceList)&#123;</span><br><span class="line">    ApiResult result = <span class="keyword">new</span> ApiResult(Constants.RESP_STATUS_OK,<span class="string">"库存扣减成功"</span>);</span><br><span class="line">    Map&lt;Long,Integer&gt; resultMap =  stockService.reduceStock(stockReduceList);</span><br><span class="line">    result.setData(resultMap);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Long, Integer&gt; <span class="title">reduceStock</span><span class="params">(List&lt;StockReduce&gt; stockReduceList)</span> </span>&#123;</span><br><span class="line">    Map&lt;Long, Integer&gt; resultMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历去减redis中库存，增加锁定库存</span></span><br><span class="line">    stockReduceList.stream().forEach(param -&gt; &#123;</span><br><span class="line">        String stockKey = Constants.CACHE_PRODUCT_STOCK+<span class="string">":"</span>+param.getSkuId();</span><br><span class="line">        String stockLockKey = Constants.CACHE_PRODUCT_STOCK_LOCK+<span class="string">":"</span>+param.getSkuId();</span><br><span class="line">        Object result = redisUtils.reduceStock(stockKey,</span><br><span class="line">                                               stockLockKey,</span><br><span class="line">                                               param.getReduceCount().toString(),<span class="comment">//incrby一个负数，就是减</span></span><br><span class="line">                                               String.valueOf(Math.abs(param.getReduceCount())));<span class="comment">//incrby一个正数，就是加</span></span><br><span class="line">        <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Long)&#123;</span><br><span class="line">            <span class="comment">//库存不存在或者不足 扣减失败 sku下单失败 记录下来</span></span><br><span class="line">            resultMap.put(param.getSkuId(),-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> List)&#123;</span><br><span class="line">            <span class="comment">//扣减成功 记录扣减流水</span></span><br><span class="line">            List resultList =  ((List) result);</span><br><span class="line">            <span class="keyword">int</span> stockAftChange =  ((Long)resultList.get(<span class="number">0</span>)).intValue();</span><br><span class="line">            <span class="keyword">int</span> stockLockAftChange = ((Long) resultList.get(<span class="number">1</span>)).intValue();</span><br><span class="line">            StockFlow stockFlow = <span class="keyword">new</span> StockFlow();</span><br><span class="line">            stockFlow.setOrderNo(param.getOrderNo());</span><br><span class="line">            stockFlow.setSkuId(param.getSkuId());</span><br><span class="line">            stockFlow.setLockStockAfter(stockLockAftChange);</span><br><span class="line">            stockFlow.setLockStockBefore(stockLockAftChange+param.getReduceCount());</span><br><span class="line">            stockFlow.setLockStockChange(Math.abs(param.getReduceCount()));</span><br><span class="line">            stockFlow.setStockAfter(stockAftChange);</span><br><span class="line">            stockFlow.setStockBefore(stockAftChange+Math.abs(param.getReduceCount()));</span><br><span class="line">            stockFlow.setStockChange(param.getReduceCount());</span><br><span class="line">            stockFlowMapper.insertSelective(stockFlow);</span><br><span class="line">            resultMap.put(param.getSkuId(),<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于redis的操作，基本与上一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>   扣减库存lua脚本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> 0  key不存在 错误   -1 库存不足  返回list  扣减成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STOCK_REDUCE_LUA=</span><br><span class="line">        <span class="string">"local stock = KEYS[1]\n"</span> +</span><br><span class="line">                <span class="string">"local stock_lock = KEYS[2]\n"</span> +</span><br><span class="line">                <span class="string">"local stock_change = tonumber(ARGV[1])\n"</span> +</span><br><span class="line">                <span class="string">"local stock_lock_change = tonumber(ARGV[2])\n"</span> +</span><br><span class="line">                <span class="string">"local is_exists = redis.call(\"EXISTS\", stock)\n"</span> +</span><br><span class="line">                <span class="string">"if is_exists == 1 then\n"</span> +</span><br><span class="line">                <span class="string">"    local stockAftChange = redis.call(\"INCRBY\", stock,stock_change)\n"</span> +</span><br><span class="line">                <span class="string">"    if(stockAftChange&lt;0) then\n"</span> +</span><br><span class="line">                <span class="string">"        redis.call(\"DECRBY\", stock,stock_change)\n"</span> +</span><br><span class="line">                <span class="string">"        return -1\n"</span> +</span><br><span class="line">                <span class="string">"    else \n"</span> +</span><br><span class="line">                <span class="string">"        local stockLockAftChange = redis.call(\"INCRBY\", stock_lock,stock_lock_change)\n"</span> +</span><br><span class="line">                <span class="string">"        return &#123;stockAftChange,stockLockAftChange&#125;\n"</span> +</span><br><span class="line">                <span class="string">"    end "</span> +</span><br><span class="line">                <span class="string">"else \n"</span> +</span><br><span class="line">                <span class="string">"    return 0\n"</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reduceStock</span><span class="params">(String stockKey,String stockLockKey,String stockChange,String stockLockChange)</span></span>&#123;</span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(STOCK_REDUCE_LUA, Collections.unmodifiableList(Arrays.asList(stockKey,stockLockKey))</span><br><span class="line">                ,Collections.unmodifiableList(Arrays.asList(stockChange, stockLockChange)));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，一旦数据库发生异常，那么就会回滚，但是redis中是无法回滚的。这个问题不用担心，因为数据库发生异常是及其严重的问题，是很少会发生的，一旦发生，只需要去这个流水的表中去查看情况，然后去执行脚本去初始化这个redis即可。所以是可以补救的。</p><p>但是接口的幂等性还没有做。重复尝试调用这个接口（通常是发生在MQ的失败重传机制，客户端的连续点击一般是可以避免的），可能会重复减redis库存并且重复地去插入流水记录。这个问题该如何解决呢？</p><h2>四、redis分布式锁来实现幂等性</h2><p>主流的方案，比如有用一张表来控制，比如以这个orderID为唯一主键，一旦插入成功，就可以根据这个唯一主键的存在与否判断是否为重复请求（也就是说，这里的扣减库存和插入去重表放在一个事务里，去重表中有一个字段为orderId，全局唯一不重复，用唯一索引进行约束，那么插入的时候判断这个去重表是否可以插入成功，如果不成功，那么数据库操作全部回滚）。</p><p>可以用redis分布式锁给这个订单上锁。以订单id为锁，不会影响其他线程来扣减库存，所以不影响性能。</p><p>针对这个订单，第一次肯定是可以去扣减库存的，但是第二次再接收到这个请求，那么就要返回已经成功了，不要再重复扣减。</p><p>对于<code>reduceStock()</code>这个方法最前面增加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止扣减库存时MQ正常重试时的不幂等</span></span><br><span class="line"><span class="comment">//以订单ID 加个缓存锁 防止程序短时间重试 重复扣减库存 不用解锁 自己超时</span></span><br><span class="line">Long orderNo = stockReduceList.get(<span class="number">0</span>).getOrderNo();</span><br><span class="line"><span class="keyword">boolean</span> lockResult = redisUtils.distributeLock(Constants.ORDER_RETRY_LOCK+orderNo.toString(),orderNo.toString(),<span class="number">300000</span>);</span><br><span class="line"><span class="keyword">if</span>(!lockResult)&#123;</span><br><span class="line">    <span class="comment">//锁定失败 重复提交 返回一个空map</span></span><br><span class="line">    <span class="keyword">return</span>  Collections.EMPTY_MAP;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long EXCUTE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**lua脚本  在redis中 lua脚本执行是串行的 原子的 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNLOCK_LUA=</span><br><span class="line">        <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> +</span><br><span class="line">                <span class="string">"   return redis.call('del', KEYS[1]) "</span> +</span><br><span class="line">                <span class="string">"else "</span> +</span><br><span class="line">                <span class="string">"   return 0 "</span> +</span><br><span class="line">                <span class="string">"end"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 获取分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">distributeLock</span><span class="params">(String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span></span>&#123;</span><br><span class="line">    String result = redisTemplate.execute((RedisCallback&lt;String&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        JedisCommands commands = (JedisCommands)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> commands.set(lockKey,requestId,SET_IF_NOT_EXIST,SET_WITH_EXPIRE_TIME,expireTime);<span class="comment">//一条命令实现setnx和setexpire这些操作，原子性</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 释放分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseDistributelock</span><span class="params">(String lockKey, String requestId)</span></span>&#123;</span><br><span class="line">    Object result  = redisTemplate.execute((RedisCallback&lt;Object&gt;) redisConnection -&gt; &#123;</span><br><span class="line">        Jedis jedis = (Jedis)redisConnection.getNativeConnection();</span><br><span class="line">        <span class="keyword">return</span> jedis.eval(UNLOCK_LUA, Collections.singletonList(lockKey), Collections.singletonList(requestId));<span class="comment">//lua脚本中原子性实现：get查询和delete删除这两个操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (EXCUTE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里不需要我们主动去释放分布式锁，只要设置一个大于重试时间的过期时间即可。让它自己删除。</p><p>注意redis在集群下做分布式锁，最好要用Redission。这里如果用于集群，如何lua脚本在一个事务里同时操作多个key的时候，如果要保证这个事务生效，就需要保证这几个key都要在同一个节点上。但是，比如我们这里的两个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK = <span class="string">"product:stock"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK_LOCK = <span class="string">"product:stock:lock"</span>;</span><br></pre></td></tr></table></figure><p>因为我们这里要同时对库存和锁定库存这两个key进行操作，需要放在一个事务内执行，不处理的话，一旦他们不在一个节点，那么事务就不会生效，解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK = <span class="string">"&#123;product:stock&#125;"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PRODUCT_STOCK_LOCK = <span class="string">"&#123;product:stock&#125;:lock"</span>;</span><br></pre></td></tr></table></figure><p>如果加上花括号，那么在进行计算hash值的时候，他们两就会是一样的，会被投放到同一个slot中，自然就保证了在同一个节点上。</p><h2>五、测试一下</h2><p><img src="http://bloghello.oursnail.cn/mama8-6.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mama8-5.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mama8-7.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ELK平台搭建</title>
      <link href="/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>因为要完成产品的全文搜索这个功能，所以需要准备一下ES的环境。本节安装ELK。</p><p>ELK由Elasticsearch、Logstash和Kibana三部分组件组成。</p><a id="more"></a><h2>前言</h2><p><img src="http://bloghello.oursnail.cn/mama6-2.png" alt="image"></p><p><code>Elasticsearch</code>是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，<code>restful</code>风格接口，多数据源，自动搜索负载等。<br>简单来说，他是个全文搜索引擎，可以快速地储存、搜索和分析海量数据。</p><p><code>Logstash</code>是一个完全开源的工具，它可以把分散的、多样化的日志日志，或者是其他数据源的数据信息进行收集、分析、处理，并将其存储供以后使用。</p><p><code>Kibana</code>是一个开源的分析和可视化平台，设计用于和<code>Elasticsearch</code>一起工作。</p><p>你用<code>Kibana</code>来搜索，查看，并和存储在<code>Elasticsearch</code>索引中的数据进行交互。</p><p>你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。</p><p><code>Kibana</code>使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示<code>Elasticsearch</code>查询的变化。</p><h2>一、安装ES</h2><h3>1.1 首先是安装JDK：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line"></span><br><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;</span><br><span class="line"></span><br><span class="line">tar xzf jdk-8u141-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h3>1.2 添加环境变量：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">JAVA_HOME=/opt/jdk1.8.0_141</span><br><span class="line">JAVA_JRE=$JAVA_HOME/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h3>1.3 下载6.2.4版本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.4.tar.gz</span><br><span class="line">tar -xzvf elasticsearch-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf elasticsearch-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line">mv elasticsearch-6.2.4 elasticsearch</span><br></pre></td></tr></table></figure><h3>1.4 配置sysctl.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#修改sysctl配置</span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"> </span><br><span class="line">#添加如下配置</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"> </span><br><span class="line">#让配置生效</span><br><span class="line">sysctl -p</span><br><span class="line"> </span><br><span class="line">#查看配置的数目</span><br><span class="line">sysctl -a|grep vm.max_map_count</span><br></pre></td></tr></table></figure><h3>1.5 elasticsearch从5.0版本之后不允许root账户启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#添加用户</span><br><span class="line">adduser dev</span><br><span class="line"> </span><br><span class="line">#设定密码</span><br><span class="line">passwd dev</span><br><span class="line"> </span><br><span class="line">#添加权限</span><br><span class="line">chown -R dev /opt/elasticsearch</span><br><span class="line"> </span><br><span class="line">#切换用户</span><br><span class="line">su dev</span><br><span class="line"> </span><br><span class="line">#查看当前用户</span><br><span class="line">who am i</span><br><span class="line"> </span><br><span class="line">#启动</span><br><span class="line">./elasticsearch/bin/elasticsearch</span><br><span class="line"> </span><br><span class="line">#后台启动</span><br><span class="line">./elasticsearch/bin/elasticsearch -d</span><br></pre></td></tr></table></figure><h3>1.6 配置limits.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line"> </span><br><span class="line">把</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"> </span><br><span class="line">改为</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line"> </span><br><span class="line">#切换用户</span><br><span class="line">su dev</span><br><span class="line"> </span><br><span class="line">#查看配置是否生效</span><br><span class="line">ulimit -Hn</span><br></pre></td></tr></table></figure><h3>1.7 配置所有用户访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><h3>1.8 添加一下内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><h3>1.9 重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep elastic</span><br><span class="line">kill -9 xxxx</span><br></pre></td></tr></table></figure><h3>1.10 测试：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:9200/</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;MmiaBfA&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;zjX-q5PDRLyrWMy5TiBDkw&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.2.4&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;ccec39f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2018-04-12T20:37:28.497551Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;7.2.1&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就说明成功了。</p><h2>二、安装Kibana 6.2.4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf kibana-6.2.4-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">mv kibana-6.2.4-linux-x86_64 kibana</span><br><span class="line"></span><br><span class="line">vim /opt/kibana/config/kibana.yml</span><br></pre></td></tr></table></figure><h3>2.1 添加以下内容：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br><span class="line">elasticsearch.url: &quot;http://127.0.0.1:9200&quot;</span><br></pre></td></tr></table></figure><h3>2.2 切换到bin目录下，启动即可。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#不能关闭终端</span><br><span class="line">./kibana  </span><br><span class="line"></span><br><span class="line">#可关闭终端</span><br><span class="line">nohup ./kibana &amp;</span><br></pre></td></tr></table></figure><h3>2.3 开放防火墙和安全组对应的这个端口</h3><p>浏览器访问：<a href="http://106.14.163.235:5601" target="_blank" rel="noopener">http://106.14.163.235:5601</a> 看到一个控制台页面就成功啦。</p><p><img src="http://bloghello.oursnail.cn/mama6-1.png" alt="image"></p><h3>2.4 关闭这个进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ps -ef|grep kibana</span><br><span class="line"> </span><br><span class="line">ps -ef|grep 5601</span><br><span class="line"> </span><br><span class="line">都找不到 </span><br><span class="line"> </span><br><span class="line">尝试 使用 fuser -n tcp 5601</span><br><span class="line"> </span><br><span class="line">kill -9  端口</span><br><span class="line"> </span><br><span class="line">启动即可 ./kibana</span><br><span class="line"></span><br><span class="line">或者去这个目录下的.out日志中可以看到看到它占用的pid</span><br></pre></td></tr></table></figure><h2>三、logstash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf logstash-6.2.4.tar.gz</span><br><span class="line"></span><br><span class="line"># 重命名</span><br><span class="line">mv logstash-6.2.4.tar.gz logstash</span><br><span class="line"></span><br><span class="line"># 进入</span><br><span class="line">cd logstash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个配置文件 我这里是mysqltones.conf</span><br><span class="line">input &#123;</span><br><span class="line">    stdin &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    jdbc &#123;</span><br><span class="line">      jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/mama-buy-trade&quot;</span><br><span class="line">      jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">      jdbc_password =&gt; &quot;root&quot;</span><br><span class="line"></span><br><span class="line">      jdbc_driver_library =&gt; &quot;/opt/logstash/mysql-connector-java-5.1.46-bin.jar&quot;</span><br><span class="line">      # the name of the driver class for mysql</span><br><span class="line">      jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">      jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">      jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line"></span><br><span class="line">      # mysql文件, 也可以直接写SQL语句在此处，如下：</span><br><span class="line">      statement =&gt; &quot;SELECT * from t_product&quot;</span><br><span class="line">      # statement_filepath =&gt; &quot;/opt/logstash/conf/jdbc.sql&quot;</span><br><span class="line"></span><br><span class="line">      # 这里类似crontab,可以定制定时操作，比如每10分钟执行一次同步(分 时 天 月 年)</span><br><span class="line">      schedule =&gt; &quot;*/10 * * * *&quot;</span><br><span class="line">      type =&gt; &quot;jdbc&quot;</span><br><span class="line"></span><br><span class="line">      # 是否记录上次执行结果, 如果为真,将会把上次执行到的 tracking_column 字段的值记录下来,保存到 last_run_metadata_path 指定的文件中</span><br><span class="line">      record_last_run =&gt; &quot;true&quot;</span><br><span class="line"></span><br><span class="line">      # 是否需要记录某个column 的值,如果record_last_run为真,可以自定义我们需要 track 的 column 名称，此时该参数就要为 true. 否则默认 track 的是 timestamp 的值.</span><br><span class="line">      use_column_value =&gt; &quot;true&quot;</span><br><span class="line"></span><br><span class="line">      # 如果 use_column_value 为真,需配置此参数. track 的数据库 column 名,该 column 必须是递增的. 一般是mysql主键</span><br><span class="line">      tracking_column =&gt; &quot;id&quot;</span><br><span class="line"></span><br><span class="line">      last_run_metadata_path =&gt; &quot;/opt/logstash/conf/last_id&quot;</span><br><span class="line"></span><br><span class="line">      # 是否清除 last_run_metadata_path 的记录,如果为真那么每次都相当于从头开始查询所有的数据库记录</span><br><span class="line">      clean_run =&gt; &quot;false&quot;</span><br><span class="line"></span><br><span class="line">      # 是否将 字段(column) 名称转小写</span><br><span class="line">      lowercase_column_names =&gt; &quot;false&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 此处我不做过滤处理</span><br><span class="line">filter &#123;&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    # 输出到elasticsearch的配置</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        index =&gt; &quot;jdbc&quot;</span><br><span class="line"></span><br><span class="line">        # 将&quot;_id&quot;的值设为mysql的autoid字段</span><br><span class="line">        document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">        template_overwrite =&gt; true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 这里输出调试，正式运行时可以注释掉</span><br><span class="line">    stdout &#123;</span><br><span class="line">        codec =&gt; json_lines</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">./bin/logstash -f ./mysqltones.conf</span><br></pre></td></tr></table></figure><p>看到这个就说明成功了：</p><p><img src="http://bloghello.oursnail.cn/mama6-3.png" alt="image"></p><h2>安装mysql数据库</h2><p>这一步要在执行logstash之前搞定，我的是阿里云centos7.3版本，mysql版本是5.7，安装过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 下载MySQL源安装包: </span><br><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line"></span><br><span class="line"># 安装MySQL源：</span><br><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm </span><br><span class="line"></span><br><span class="line"># 检查MySQL源安装情况： </span><br><span class="line">yum repolist enabled | grep &quot;mysql.*-community.*&quot;</span><br><span class="line"></span><br><span class="line"># 安装MySQL: </span><br><span class="line">yum install mysql-community-server</span><br><span class="line"></span><br><span class="line"># 启动MySQL: </span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"># 查看MySQL状态: </span><br><span class="line">systemctl status mysqld</span><br><span class="line"></span><br><span class="line"># 设置开机启动MySQL：</span><br><span class="line">systemctl enable mysqld </span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 查找并修改MySQL默认密码（注意密码要符合规范，否则会失败）：</span><br><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log </span><br><span class="line"></span><br><span class="line">mysql -uroot -p </span><br><span class="line"></span><br><span class="line">alter user root@localhost identified by &apos;你的新密码&apos;;</span><br><span class="line"></span><br><span class="line"># 远程连接测试添加远程账户：</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;用户&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"># 立即生效：</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># 退出MySQL：</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 最后远程将数据给导入数据库</span><br></pre></td></tr></table></figure><h2>安装分词器</h2><p><code>ik_max_word</code>是分词比较细腻的一款，我们就用它来做分词，首先需要安装一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接安装</span><br><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.4/elasticsearch-analysis-ik-6.2.4.zip</span><br><span class="line"> </span><br><span class="line"># 重新启动ES</span><br><span class="line">ps -ef | grep elastic</span><br><span class="line">kill -9 xxxx</span><br><span class="line">su dev</span><br><span class="line">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><p>对这个分词器在<code>kibana</code>中进行测试：</p><p><img src="http://bloghello.oursnail.cn/mama6-5.png" alt="image"></p><p>下面结合数据库模拟一下：</p><p><img src="http://bloghello.oursnail.cn/mama6-4.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Curator</title>
      <link href="/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<p>从技术角度出发，注册一个网站，再高并发的时候，有可能出现用户名重复这样的问题（虽然一般情况下不会出现这种问题），如何解决呢？</p><a id="more"></a><p>从数据库角度，对于单表，我可以用<code>select .. for update</code>悲观锁实现，或者用version这种乐观锁的思想。</p><p>更好的方法是将这个字段添加唯一索引，用数据库来保证不会重复。一旦插入重复，那么就会抛出异常，程序就可以捕获到。</p><p>但是，假如我们这里分表了，以上都是针对单表，第一种方案是锁表，不行，设置唯一索引是没有用。怎么办呢？</p><p>解决方案：用ZK做一个分布式锁。</p><p>首先准备一个ZK客户端，用的是<code>Curator</code>来连接我们的ZK：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">getZkClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        CuratorFrameworkFactory.Builder builder= CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(parameters.getZkHost())</span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line">        CuratorFramework framework = builder.build();</span><br><span class="line">        framework.start();</span><br><span class="line">        <span class="keyword">return</span> framework;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册用一个分布式锁来控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    InterProcessLock lock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        lock = <span class="keyword">new</span> InterProcessMutex(zkClient, Constants.USER_REGISTER_DISTRIBUTE_LOCK_PATH);</span><br><span class="line">        <span class="keyword">boolean</span> retry = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">3000</span>, TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                <span class="comment">//查询重复用户</span></span><br><span class="line">                User repeatedUser = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">                <span class="keyword">if</span>(repeatedUser!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> MamaBuyException(<span class="string">"用户邮箱重复"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line">                user.setNickname(<span class="string">"码码购用户"</span>+user.getEmail());</span><br><span class="line">                userMapper.insertSelective(user);</span><br><span class="line">                <span class="comment">//跳出循环</span></span><br><span class="line">                retry = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可以适当休息一会...也可以设置重复次数，不要无限循环</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (retry);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">"用户注册异常"</span>,e);</span><br><span class="line">        <span class="keyword">throw</span>  e;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lock != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">                log.info(user.getEmail()+Thread.currentThread().getName()+<span class="string">"释放锁"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路非常简单，就是先尝试上锁，即<code>acquire</code>，但是有可能失败，所以这里用一个超时时间，即<code>3000ms</code>之内上不了锁就失败，进入下一次循环。最后释放锁即可。</p><p>ok，这里要来说说ZK实现分布式锁了。这里用了开源客户端<code>Curator</code>，他对于实现分布式锁进行了封装，但是，我还是想了解一下它的实现原理：</p><p>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>也就是说，最小的那个节点就是Leader，进来判断是不是为那个节点，是的话就可以获取到锁，反之不行。</p><blockquote><p>为什么不能通过大家一起创建节点，如果谁成功了就算获取到了锁。 多个client创建一个同名的节点，如果节点谁创建成功那么表示获取到了锁，创建失败表示没有获取到锁。</p></blockquote><p>答：使用临时顺序节点可以保证获得锁的公平性，及谁先来谁就先得到锁，这种方式是随机获取锁，会造成无序和饥饿。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Session</title>
      <link href="/2019/01/23/miscellany/06Spring%20Session/"/>
      <url>/2019/01/23/miscellany/06Spring%20Session/</url>
      <content type="html"><![CDATA[<p>在单体应用中，我们经常用http session去管理用户信息，但是到了分布式环境下，显然是不行的，因为session对于不同的机器是隔离的，而http本身是无状态的，那么就无法判断出用户在哪一个服务器上登陆的。这个时候就需要有一个独立的地方存储用户session。spring session可以做到无代码侵入的方式实现分布式session存储。</p><a id="more"></a><p>在<code>spring boot</code>开发中，我们先注册相应<code>bean</code>并且打开相应的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span> <span class="comment">//(maxInactiveIntervalInSeconds = 604800)//session超时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Parameters parameters;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpSessionStrategy <span class="title">httpSessionStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> HeaderHttpSessionStrategy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisConnectionFactory connectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line"></span><br><span class="line">        String redisHost = parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> redisPort = Integer.valueOf(parameters.getRedisNode().split(<span class="string">":"</span>)[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        connectionFactory.setTimeout(<span class="number">2000</span>);</span><br><span class="line">        connectionFactory.setHostName(redisHost);</span><br><span class="line">        connectionFactory.setPort(redisPort);</span><br><span class="line"><span class="comment">//        connectionFactory.setPassword(parameters.getRedisAuth());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，这样子其实就配置好了，一开始我也云里雾里的，这是啥玩意？</p><p>其实官网的文档中讲的是最准确的。所以还是官网看看吧！</p><p>ok，来spring session的官网(<a href="https://spring.io/projects/spring-session" target="_blank" rel="noopener">https://spring.io/projects/spring-session</a>)来看看把，我们来看看1.3.4GA版本的文档(<a href="https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest" target="_blank" rel="noopener">https://docs.spring.io/spring-session/docs/1.3.4.RELEASE/reference/html5/#httpsession-rest</a>).</p><p>spring session可以存在很多介质中，比如我们的数据源，比如redis，甚至是mongodb等。但是我们常用的是存在redis中，结合redis的过期机制来做。</p><p>所以其实我们只要关心如何跟redis整合，以及restful接口。</p><p>我们可以看到一开始文档就告诉我们要配置一下<code>HttpSessionStrategy</code>和存储介质。从<code>HttpSessionStrategy</code>语义就能大致看出配置的是它的策略，是基于<code>header</code>的策略。这个是什么意思，下面会提到。</p><p><img src="http://bloghello.oursnail.cn/mama4-1.png" alt="image"></p><p>那么我们就来看看文档吧！</p><p><img src="http://bloghello.oursnail.cn/mama4-2.png" alt="image"></p><p>好了，我们知道了它的基本原理，下面来看看是如何在restful接口中实现用户session的管理的：</p><p><img src="http://bloghello.oursnail.cn/mama4-3.png" alt="image"></p><p>也就是说要想在restful接口应用中用这种方式，直接告诉spring session:<code>return new HeaderHttpSessionStrategy();</code>即可。进入源码我们就会知道，它默认给这个header里面放置的一条类似于token的名字是<code>private String headerName = &quot;x-auth-token&quot;;</code>。</p><p>那么在用户登陆成功之后，到底存到是什么呢，先来看看响应数据的header里面是什么：</p><p><img src="http://bloghello.oursnail.cn/mama4-4.png" alt="image"></p><p>这一串数字正好可以跟redis中对应上，我们可以先来redis中看看到底在里面存储了啥玩意：</p><p><img src="http://bloghello.oursnail.cn/mama4-5.png" alt="image"></p><p>我们已经看到了想要看到的一串字符串，这里解释一下<code>redis</code>中存储的东西：</p><ul><li><code>spring:session</code>是默认的<code>Redis HttpSession</code>前缀（<code>redis</code>中，我们常用’:’作为分割符）</li><li>每一个<code>session</code>都会有三个相关的<code>key</code>，第一个<code>key</code>(<code>spring:session:sessions:37...</code>)最为重要，它是一个<code>HASH</code>数据结构，将内存中的<code>session</code>信息序列化到了<code>redis</code>中。如本项目中用户信息,还有一些<code>meta</code>信息，如创建时间，最后访问时间等。</li><li>另外两个key，一个是<code>spring:session:expiration</code>，还有一个是<code>spring:session:sessions:expires</code>，前者是一个SET类型，后者是一个STRING类型，可能会有读者发出这样的疑问，redis自身就有过期时间的设置方式TTL，为什么要额外添加两个key来维持session过期的特性呢？redis清除过期key的行为是一个异步行为且是一个低优先级的行为，用文档中的原话来说便是，可能会导致session不被清除。于是引入了专门的expiresKey，来专门负责session的清除，包括我们自己在使用redis时也需要关注这一点。</li></ul><p>这样子，就可以用独立的<code>redis</code>来存储用户的信息，通过前端传来的<code>header</code>里面的<code>token</code>，就可以到<code>redis</code>拿出当前登陆用户的信息了。</p><p>OK，在解决了<code>spring session</code>的问题之后，下面就可以来实现登陆啦：</p><p>controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ApiResult <span class="title">login</span><span class="params">(@RequestBody @Valid User user, HttpSession session)</span></span>&#123;</span><br><span class="line">    ApiResult&lt;UserElement&gt; result = <span class="keyword">new</span> ApiResult&lt;&gt;(Constants.RESP_STATUS_OK,<span class="string">"登录成功"</span>);</span><br><span class="line"></span><br><span class="line">    UserElement ue= userService.login(user);</span><br><span class="line">    <span class="keyword">if</span>(ue != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(Constants.REQUEST_USER_SESSION) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            session.setAttribute(Constants.REQUEST_USER_SESSION,ue);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setData(ue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就跟以前一样，将session直接存进去就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserElement <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    UserElement ue = <span class="keyword">null</span>;</span><br><span class="line">    User userExist = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">    <span class="keyword">if</span>(userExist != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//对密码与数据库密码进行校验</span></span><br><span class="line">        <span class="keyword">boolean</span> result = passwordEncoder.matches(user.getPassword(),userExist.getPassword());</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"密码错误"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//校验全部通过，登陆通过</span></span><br><span class="line">            ue = <span class="keyword">new</span> UserElement();</span><br><span class="line">            ue.setUserId(userExist.getId());</span><br><span class="line">            ue.setEmail(userExist.getEmail());</span><br><span class="line">            ue.setNickname(userExist.getNickname());</span><br><span class="line">            ue.setUuid(userExist.getUuid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MamaBuyException(<span class="string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式ID生成策略</title>
      <link href="/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/"/>
      <url>/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>分布式环境下如何保证ID的不重复呢？一般我们可能会想到用UUID来实现嘛。但是UUID一般可以获取当前时间的毫秒数再加点随机数，但是在高并发下仍然可能重复。最重要的是，如果我要用这种UUID来生成分表的唯一ID的话，重复不谈，这种随机的字符串对于我们的innodb存储引擎的插入效率是很低的。所以我们生成的ID如果作为主键，最好有两种特性：分布式唯一和有序。</p><a id="more"></a><p>唯一性就不用说了，有序保证了对索引字段的插入的高效性。我们来具体看看<code>ShardingJDBC</code>的分布式ID生成策略是如何保证。</p><h3>snowflake算法</h3><p><img src="http://bloghello.oursnail.cn/mama5-10.png" alt="image"></p><p><code>sharding-jdbc</code>的分布式ID采用<code>twitter</code>开源的<code>snowflake</code>算法，不需要依赖任何第三方组件，这样其扩展性和维护性得到最大的简化；但是<code>snowflake</code>算法的缺陷（<strong>强依赖时间，如果时钟回拨，就会生成重复的ID</strong>）。</p><p>雪花算法是由<code>Twitter</code>公布的分布式主键生成算法，<strong>它能够保证不同进程主键的不重复性，以及相同进程主键的有序性</strong>。</p><p><strong>在同一个进程中</strong>，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。例如MySQL的Innodb存储引擎的主键。</p><p>使用雪花算法生成的主键，二进制表示形式包含4部分，从高位到低位分表为：1bit符号位、41bit时间戳位、10bit工作进程位以及12bit序列号位。</p><p>雪花算法主键的详细结构见下图。</p><p><img src="http://bloghello.oursnail.cn/mama5-1.png" alt="image"></p><ul><li>符号位(1bit)</li></ul><p>预留的符号位，恒为零。</p><ul><li>时间戳位(41bit)</li></ul><p>41位的时间戳可以容纳的毫秒数是2的41次幂，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。通过计算可知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);</span><br></pre></td></tr></table></figure><p>结果约等于69.73年。<code>ShardingSphere</code>的雪花算法的时间纪元从2016年11月1日零点开始，可以使用到2086年，相信能满足绝大部分系统的要求。</p><ul><li>工作进程位(10bit)</li></ul><p>该标志在Java进程内是唯一的，如果是分布式应用部署应保证每个工作进程的id是不同的。该值默认为0，可通过调用静态方法<code>DefaultKeyGenerator.setWorkerId()</code>设置。</p><ul><li>序列号位(12bit)</li></ul><p>该序列是用来在同一个毫秒内生成不同的ID。如果在这个毫秒内生成的数量超过4096(2的12次幂)，那么生成器会等待到下个毫秒继续生成。</p><h2>时钟回拨</h2><p>服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为0，可通过调用静态方法<code>DefaultKeyGenerator.setMaxTolerateTimeDifferenceMilliseconds()</code>设置。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springMVC全局异常+spring包扫描包隔离+spring事务传播</title>
      <link href="/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
      <url>/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/</url>
      <content type="html"><![CDATA[<p>在开发中，springMVC全局异常+spring包扫描包隔离+spring事务传播这三个不可能不会遇到。下面来好好说说他们吧。</p><a id="more"></a><h2>1、全局异常引入原因</h2><p>假设在我们的<code>login.do</code>的<code>controller</code>方法中第一行增加一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>重新启动服务器进行用户登录操作，那么就会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    com.swg.controller.portal.UserController.login(UserController.java:<span class="number">37</span>)</span><br><span class="line">    ...其他的堆栈信息</span><br></pre></td></tr></table></figure><p>这些信息会直接显示在网页上，如果是关于数据库的错误，同样，会详细地将数据库中的字段都显示在页面上，这对于我们的项目来说是存在很大的安全隐患的。这个时候，需要用全局异常来处理，如果发生异常，我们就对其进行拦截，并且在页面上显示我们给出的提示信息。</p><p>对于<code>SpringBoot</code>，一般全局异常是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandlerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">handleException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        log.error(e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createByErrorCodeMessage(Constants.RESP_STATUS_INTERNAL_ERROR,<span class="string">"系统异常，请稍后再试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(SnailmallException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse <span class="title">handleException</span><span class="params">(SnailmallException e)</span></span>&#123;</span><br><span class="line">        log.error(e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createByErrorCodeMessage(e.getExceptionStatus(),e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>2、引入全局异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"exception:&#123;&#125;"</span>,httpServletRequest.getRequestURI(),e);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> MappingJacksonJsonView());</span><br><span class="line">        mv.addObject(<span class="string">"status"</span>,ResponseEnum.ERROR.getCode());</span><br><span class="line">        mv.addObject(<span class="string">"msg"</span>,<span class="string">"接口异常，详情请查看日志中的异常信息"</span>);</span><br><span class="line">        mv.addObject(<span class="string">"data"</span>,e.toString());</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，再执行登陆操作之后，就不会在页面上直接显示异常信息了。有效地屏蔽了关键信息。</p><h2>3、spring和springmvc配置文件的优化</h2><h5>3.1 包隔离优化</h5><p>在编写全局异常之前，先进行了包隔离和优化，一期中的扫描包的写法是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--springmvc:--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>即<code>spring</code>和<code>springmvc</code>扫描包下面的所有的<code>bean</code>和<code>controller</code>.优化后的代码配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#spring</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将controller的扫描排除掉--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#springmvc</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.swg.controller"</span> <span class="attr">annotation-config</span>=<span class="string">"true"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--添加白名单，只扫描controller，总之要将service给排除掉即可--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做的原因是：<code>Spring</code>和<code>SpringMVC</code>是有父子容器关系的，而且正是因为这个才往往会出现包扫描的问题。</p><p><img src="http://bloghello.oursnail.cn/zaji4-1.png" alt="image"></p><p>针对包扫描只要记住以下几点即可：</p><ul><li><code>spring</code>是父容器，<code>springmvc</code>是子容器，子容器可以访问父容器的<code>bean</code>,父容器不能访问子容器的<code>bean</code>。</li><li>只有顶级容器（<code>spring</code>）才有加强的事务能力，而<code>springmvc</code>容器的<code>service</code>是没有的。</li><li>如果<code>springmvc</code>不配置包扫描的话，页面404.</li></ul><h5>3.2 事务的传播机制</h5><p>针对事务，不得不展开说明spring事务的几种传播机制了。在 <code>spring</code> 的 <code>TransactionDefinition</code> 接口中一共定义了七种事务传播属性：</p><ol><li><code>PROPAGATION_REQUIRED</code> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择（默认）。</li><li><code>PROPAGATION_SUPPORTS</code> – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li><code>PROPAGATION_MANDATORY</code> – 支持当前事务，如果当前没有事务，就抛出异常。</li><li><code>PROPAGATION_REQUIRES_NEW</code> – 新建事务，如果当前存在事务，把当前事务挂起。</li><li><code>PROPAGATION_NOT_SUPPORTED</code> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><code>PROPAGATION_NEVER</code> – 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><code>PROPAGATION_NESTED</code> – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与<code>PROPAGATION_REQUIRED</code>类似的操作。</li></ol><h2>4、补充</h2><p><code>Spring</code>默认情况下，会对运行期例外(<code>RunTimeException</code>)，即<code>uncheck</code>异常，进行事务回滚。如果遇到<code>checked</code>异常就不回滚。如何改变默认规则：</p><ul><li>让<code>checked</code>例外也回滚：在整个方法前加上 <code>@Transactional(rollbackFor=Exception.class)</code></li><li>让<code>unchecked</code>例外不回滚： <code>@Transactional(notRollbackFor=RunTimeException.class)</code></li><li>不需要事务管理的(只查询的)方法：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li></ul><h2>5、那么什么是嵌套事务呢？</h2><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫做<code>save point</code>，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点在于那个<code>save point</code>，看以下几个问题：</p><p><strong>问题1：如果子事务回滚，会发生什么？</strong></p><p>父事务会回到进入子事务前建立的<code>save point</code>，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>问题2：如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚，为什么呢？因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理/</p><p><strong>问题3：父事务先提交，然后子事务再提交；还是子事务先提交，然后父事务再提交呢？</strong></p><p>答案是第二种情况，子事务是父事务的一部分，由父事务同意提交。</p><h2>6、spring配置文件的一些理解：</h2><blockquote><p>容器</p></blockquote><p>在<code>Spring</code>整体框架的核心概念中，容器是核心思想，就是用来管理<code>Bean</code>的整个生命周期的，而在一个项目中，容器不一定只有一个，<code>Spring</code>中可以包括多个容器，而且容器有上下层关系，目前最常见的一种场景就是在一个项目中引入<code>Spring</code>和<code>SpringMVC</code>这两个框架，那么它其实就是两个容器，<code>Spring</code>是父容器，<code>SpringMVC</code>是其子容器，并且在<code>Spring</code>父容器中注册的<code>Bean</code>对于<code>SpringMV</code>C容器中是可见的，而在<code>SpringMVC</code>容器中注册的<code>Bean</code>对于<code>Spring</code>父容器中是不可见的，也就是子容器可以看见父容器中的注册的<code>Bean</code>，反之就不行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.springmvc.test"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用统一的如下注解配置来对<code>Bean</code>进行批量注册，而不需要再给每个<code>Bean</code>单独使用<code>xml</code>的方式进行配置。</p><p>从<code>Spring</code>提供的参考手册中我们得知该配置的功能是扫描配置的<code>base-package</code>包下的所有使用了<code>@Component</code>注解的类，并且将它们自动注册到容器中，同时也扫描<code>@Controller</code>，<code>@Service</code>，<code>@Respository</code>这三个注解，因为他们是继承自<code>@Component</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>其实有了上面的配置，这个是可以省略掉的，因为上面的配置会默认打开以下配置。以下配置会默认声明了<code>@Required</code>、<code>@Autowired</code>、 <code>@PostConstruct</code>、<code>@PersistenceContext</code>、<code>@Resource</code>、<code>@PreDestroy</code>等注解。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个是<code>SpringMVC</code>必须要配置的，因为它声明了<code>@RequestMapping</code>、<code>@RequestBody</code>、<code>@ResponseBody</code>等。并且，该配置默认加载很多的参数绑定方法，比如<code>json</code>转换解析器等。</p><h2>7、总结</h2><p>在实际工程中会包括很多配置，我们按照官方推荐根据不同的业务模块来划分不同容器中注册不同类型的<code>Bean</code>：<code>Spring</code>父容器负责所有其他非<code>@Controller</code>注解的<code>Bean</code>的注册，而<code>SpringMVC</code>只负责<code>@Controller</code>注解的<code>Bean</code>的注册，使得他们各负其责、明确边界。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis实现分布式锁</title>
      <link href="/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<p>为了讲解redis分布式锁，我将引入一个场景：定时关单。因为往往订单服务是一个集群，那么定时器会同时触发这些集群去取消订单，显然是浪费机器资源的，所以目的是：只让其中一台机器去执行取消订单即可。这里可以用分布式锁来实现。</p><a id="more"></a><p>项目是从练手项目中截取出来的，框架是基于<code>SSM</code>的<code>XML</code>形式构成，所以下面还涉及一点<code>XMl</code>对于定时器<code>spring schedule</code>的配置内容。</p><h2>1、引入目标</h2><p>定时自动对超过两个小时还未支付的订单对其进行取消，并且重置库存。</p><h2>2、配置</h2><p>首先是<code>spring</code>配置文件引入<code>spring-schedule</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xmlns:task="http://www.springframework.org/schema/task"</span><br><span class="line">...</span><br><span class="line">http://www.springframework.org/schema/task</span><br><span class="line">http://www.springframework.org/schema/task/spring-task.xsd</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>补充：针对<code>applicationContext-datasource.xml</code>中的<code>dataSource</code>读取配置文件的信息无法展现的问题，在<code>spring</code>的配置文件中增加一条配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:datasource.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2>3、定时调度代码</h2><p>此代码的主要功能是：定时调用取消订单服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseOrderTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍的时候执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">        <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">        orderService.closeOrder(hour);</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@Component</code>一定要加，否则<code>spring</code>扫描不到。</p></blockquote><blockquote><p><code>close.order.task.time.hour</code> 也是配置在<code>snailmall.properties</code>中的，这里配置的是默认的2，即两个小时，下订单超过两个小时仍然不支付，就取消该订单。</p></blockquote><p>对于<code>orderService</code>里面的具体方法：</p><p>这里是关单的具体逻辑，细节是行锁。这段代码只要知道他是具体关单的逻辑即可，不需要仔细了解代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">    Date closeDateTime = DateUtils.addHours(<span class="keyword">new</span> Date(),-hour);</span><br><span class="line">    <span class="comment">//找到状态为未支付并且下单时间是早于当前检测时间的两个小时的时间,就将其置为取消</span></span><br><span class="line">    <span class="comment">//SELECT &lt;include refid="Base_Column_List"/&gt; from mmall_order WHERE  status = #&#123;status&#125; &lt;![CDATA[ and create_time &lt;= #&#123;date&#125; ]]&gt; order by create_time desc</span></span><br><span class="line">    List&lt;Order&gt; orderList = orderMapper.selectOrderStatusByCreateTime(Const.OrderStatusEnum.NO_PAY.getCode(),DateTimeUtil.dateToStr(closeDateTime));</span><br><span class="line">    <span class="keyword">for</span>(Order order:orderList)&#123;</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo());</span><br><span class="line">        <span class="keyword">for</span>(OrderItem orderItem:orderItemList)&#123;</span><br><span class="line">            <span class="comment">//一定要用主键where条件，防止锁表。同时必须是支持MySQL的InnoDB.</span></span><br><span class="line">            Integer stock = productMapper.selectStockByProductId(orderItem.getProductId());</span><br><span class="line">            <span class="keyword">if</span>(stock == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新产品库存</span></span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.setId(orderItem.getProductId());</span><br><span class="line">            product.setStock(stock+orderItem.getQuantity());</span><br><span class="line">            productMapper.updateByPrimaryKeySelective(product);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭order</span></span><br><span class="line">        <span class="comment">//UPDATE mmall_order set status = 0 where id = #&#123;id&#125;</span></span><br><span class="line">        orderMapper.closeOrderByOrderId(order.getId());</span><br><span class="line">        log.info(<span class="string">"关闭订单OrderNo:&#123;&#125;"</span>,order.getOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，<code>debug</code>启动项目，一分钟后就会自动执行<code>closeOrderTaskV1</code>方法了。找一个未支付的订单，进行相应测试。</p><h2>4、存在的问题</h2><p>经过实验发现，同时部署两台<code>tomcat</code>服务器，执行定时任务的时候是两台都同时执行的，显然不符合我们集群的目标，我们只需要在同一时间只有一台服务器执行这个定时任务即可。那么解决方案就是引入<code>redis</code>分布式锁。</p><p><code>redis</code>实现分布式锁，核心命令式<code>setnx</code>命令。所以阅读下面，您需要对<code>redis</code>分布式锁的基本实现原理必须要先有一定的认识才行。</p><h2>5、第一种方案</h2><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V1.png" alt="image"></p><ul><li><p>第一步：<code>setnx</code>进去，如果成功，说明塞入<code>redis</code>成功，抢占到锁</p></li><li><p>第二步：抢到锁之后，先设置一下过期时间，即后面如果执行不到<code>delete</code>，也会将这个锁自动释放掉，防止死锁</p></li><li><p>第三步：关闭订单，删除<code>redis</code>锁</p></li><li><p>存在的问题：如果因为<code>tomcat</code>关闭或<code>tomcat</code>进程在执行<code>closeOrder()</code>方法的时候，即还没来得及设置锁的过期时间的时候，这个时候会造成死锁。需要改进。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个版本，在突然关闭tomcat的时候有可能出现死锁</span></span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="comment">//设置锁，value是用当前时间+timeout进行设置的</span></span><br><span class="line">    <span class="keyword">long</span> timeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>));</span><br><span class="line">    Long setnxResult = RedisShardPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">    <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() ==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//说明被当前的tomcat进程抢到锁，下面就可以关闭订单</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给锁一个过期时间，如果因为某个原因导致下面的锁没有被删除，造成死锁</span></span><br><span class="line">    RedisShardPoolUtil.expire(lockName,<span class="number">50</span>);</span><br><span class="line">    log.info(<span class="string">"获取&#123;&#125;，ThreadName:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>,<span class="string">"2"</span>));</span><br><span class="line">    orderService.closeOrder(hour);</span><br><span class="line">    <span class="comment">//关闭订单之后就立即删除这个锁</span></span><br><span class="line">    RedisShardPoolUtil.del(lockName);</span><br><span class="line">    log.info(<span class="string">"释放&#123;&#125;，ThreadName:&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,Thread.currentThread().getName());</span><br><span class="line">    System.out.println(<span class="string">"============================================="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>6、改进</h2><p><img src="http://bloghello.oursnail.cn/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81V2.png" alt="image"></p><p>图看不清，可以重新打开一个窗口看。具体的逻辑代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)<span class="comment">//每隔一分钟执行，一分钟的整数倍</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="comment">//设置锁，value是用当前时间+timeout进行设置的</span></span><br><span class="line">    <span class="keyword">long</span> timeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>));</span><br><span class="line">    Long setnxResult = RedisShardPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">    <span class="keyword">if</span>(setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() ==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//说明被当前的tomcat进程抢到锁，下面就可以关闭订单</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//在没有拿到锁的情况下，也要进行相应的判断，确保不死锁</span></span><br><span class="line">        String lockValueStr = RedisShardPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        <span class="comment">//如果判断锁是存在的并且现在已经超时了，那么我们这个进程就有机会去占有这把锁</span></span><br><span class="line">        <span class="keyword">if</span>(lockValueStr != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr))&#123;</span><br><span class="line">            <span class="comment">//当前进程进行get set操作，拿到老的key，再塞进新的超时时间</span></span><br><span class="line">            String getSetResult = RedisShardPoolUtil.getset(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK,String.valueOf(System.currentTimeMillis()+timeout));</span><br><span class="line">            <span class="comment">//如果拿到的是空的，说明老的锁已经释放，那么当前进程有权占有这把锁进行操作；</span></span><br><span class="line">            <span class="comment">//如果拿到的不是空的，说明老的锁仍然占有，并且这次getset拿到的key与上面查询get得到的key一样的话，说明没有被其他进程刷新，那么本进程还是有权占有这把锁进行操作</span></span><br><span class="line">            <span class="keyword">if</span>(getSetResult == <span class="keyword">null</span> || (getSetResult != <span class="keyword">null</span> &amp;&amp; StringUtils.equals(lockValueStr,getSetResult)))&#123;</span><br><span class="line">                closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125;            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"没有获取分布式锁：&#123;&#125;"</span>,Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样两次的防死锁措施，不仅可以防止死锁，还可以提高效率。</p><h2>7、扩展</h2><h6>mysql四种事务隔离机制</h6><ol><li><code>read uncommitted</code>:读取未提交内容</li></ol><p>两个线程，其中一个线程执行了更新操作，但是没有提交，另一个线程在事务内就会读到该线程未提交的数据。</p><ol start="2"><li><code>read committed</code>:读取提交内容（不可重复读）</li></ol><p>针对第一种情况，一个线程在一个事务内不会读取另一个线程未提交的数据了。但是，读到了另一个线程更新后提交的数据，也就是说重复读表的时候，数据会不一致。显然这种情况也是不合理的，所以叫不可重复读。</p><ol start="3"><li><code>repeatable read</code>:可重复读（默认）</li></ol><p>可重复读，显然解决2中的问题，即一个线程在一个事务内不会再读取到另一个线程提交的数据，保证了该线程在这个事务内的数据的一致性。</p><p>对于某些情况，这种方案会出现幻影读，他对于更新操作是没有任何问题的了，但是对于插入操作，有可能在一个事务内读到新插入的数据（但是MySQL中用多版本并发控制机制解决了这个问题），所以默认使用的就是这个机制，没有任何问题。</p><ol start="4"><li><code>serializable</code>:序列化</li></ol><p>略。</p><h6>存储引擎</h6><p><code>MySQL</code>默认使用的是<code>InnoDB</code>，支持事务。还有例如<code>MyISAM</code>,这种存储引擎不支持事务，只支持只读操作，在用到数据的修改的地方，一般都是用默认的<code>InnoDB</code>存储引擎。</p><h6>索引的一个注意点</h6><p>一般类型为<code>normal</code>和<code>unique</code>，用<code>btree</code>实现，对于联合索引(字段1和字段2)，在执行查询的时候，例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> 字段<span class="number">1</span>=<span class="string">"xxx"</span> ...</span><br></pre></td></tr></table></figure><p>是可以利用到索引的高性能查询的，但是如果是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> 字段<span class="number">2</span>=<span class="string">"xxx"</span> ...</span><br></pre></td></tr></table></figure><p>效率跟普通的查询时一样的，因为用索引进行查询，最左边的那个字段必须要有，否则无效。</p><p>扩展的内容知识顺便提一下，在数据库这一块，会详细介绍一下。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redisson实现Redis分布式锁原理</title>
      <link href="/2019/01/22/miscellany/02Redisson%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2019/01/22/miscellany/02Redisson%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<p>我们可以自己来实现一个<a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">redis分布式锁</a>，但是如何用Redisson优雅地实现呢？本文探讨一下它的原理。</p><a id="more"></a><p>用<code>Redisson</code>来实现分布式锁异常地简单，形如：</p><p><img src="http://bloghello.oursnail.cn/ziji2-1.png" alt="image"></p><p>还支持<code>redis</code>单实例、<code>redis</code>哨兵、<code>redis cluster</code>、<code>redis master-slave</code>等各种部署架构，都可以给你完美实现。</p><h2>加锁</h2><p>原理图：</p><p><img src="http://bloghello.oursnail.cn/zaji2-2.png" alt="image"></p><p>现在某个客户端要加锁。如果该客户端面对的是一个<code>redis cluster</code>集群，他首先会根据hash节点选择一台机器。紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</p><p><img src="http://bloghello.oursnail.cn/zaji2-3.png" alt="image"></p><p>为啥要用lua脚本呢？因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的<strong>原子性</strong>。</p><p>解释一下这段脚本的意思。</p><p>这里的<code>KEYS[1]</code>代表的是你加锁的那个key的名字。这个key就是我们常看到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"myLock"</span>);</span><br></pre></td></tr></table></figure><p>中的<code>myLock</code>，我就是对这个key进行加锁。</p><p>这里的<code>ARGV[1]</code>代表的就是锁key的默认生存时间，默认30秒。<code>ARGV[2]</code>代表的是加锁的客户端的ID:比如<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1</code></p><p>第一段if判断语句，就是相当于用<code>exists myLock</code>命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：<code>hset myLock</code>。</p><p>执行完<code>hest</code>之后，设置了一个hash数据结构：<code>8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</code>，这行命令执行后，会出现一个类似下面的数据结构：</p><p><img src="http://bloghello.oursnail.cn/zaji2-4.png" alt="image"></p><p>紧接着会执行<code>pexpire myLock 30000</code>命令，设置myLock这个锁key的生存时间是30秒。好了，到此为止，ok，加锁完成了。</p><h2>锁互斥</h2><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？很简单，第一个if判断会执行<code>exists myLock</code>，发现myLock这个锁key已经存在了。接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p><p>所以这个客户端2两个if都不能进入，只能执行最后的<code>pttl myLock</code>，返回值代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</p><h2>watch dog自动延期机制</h2><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个<code>watch dog</code>看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><h2>可重入加锁机制</h2><p>看一下代码，相同的客户进来，会进入第二个if，会执行<code>hincrby</code>，即增1，那么这个hash结构就会变成：</p><p><img src="http://bloghello.oursnail.cn/zaji2-5.png" alt="image"></p><h2>释放锁</h2><p>如果执行<code>lock.unlock()</code>，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：<code>del myLock</code>命令，从redis里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。</p><p>这就是所谓的分布式锁的开源Redisson框架的实现机制。</p><h2>存在的问题</h2><p>其实上面那种方案最大的问题，就是如果你对某个<code>redis master</code>实例，写入了myLock这种锁key的value，此时会异步复制给对应的<code>master slave</code>实例。</p><p>但是复制的这个过程中一旦发生<code>redis master</code>宕机，主备切换，<code>redis slave</code>变为了<code>redis master</code>。</p><p>假设客户端1在<code>redis master</code>上获得锁，然后主机宕机，<code>redis slave</code>成为新的<code>redis master</code>，但是还未同步到<code>redis slave</code>上，但是客户端1已经觉得自己获取到了锁。</p><p>此时，客户端2来尝试加锁的时候，在新的<code>redis master</code>上完成了加锁，此时就会发生多个客户端完成对一个key的加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。</p><p>所以这个就是<code>redis cluster</code>，或者是<code>redis master-slave</code>架构的主从异步复制导致的redis分布式锁的最大缺陷：在<code>redis master</code>实例宕机的时候，可能导致多个客户端同时完成加锁。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring事务的传播行为</title>
      <link href="/2019/01/22/miscellany/01%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/"/>
      <url>/2019/01/22/miscellany/01%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</url>
      <content type="html"><![CDATA[<p>经常听到别人说事务传播行为，那到底什么是事务的传播行为呢？</p><a id="more"></a><h2>1.什么是事务？</h2><p>在数据库系统中，一个事务是指：由一系列数据库操作组成的一个完整的逻辑过程。例如银行转帐，从原账户扣除金额，以及向目标账户添加金额，这两个数据库操作的总和，构成一个完整的逻辑过程，不可拆分。这个过程被称为一个事务，具有ACID特性。</p><p>这里注意，其实事务就是数据库才能保证的，所以抛开数据库层面来谈事务本身就是不存在的，所以事务的概念就是数据库一系列操作的一个完整单元。</p><h2>2.什么是ACID？</h2><p>ACID是指数据库管理系统在写入或更新资料的过程中，为保证事务是正确可靠的，所必须具备的四个特性：原子性、一致性、隔离性、持久性。</p><ul><li><p><code>Atomicity</code>：一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><code>Consistency</code>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p></li><li><p><code>Isolation</code>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔<br>离分为不同级别，包括读未提交(<code>Read uncommitted</code>)、读提交(<code>read committed</code>)、可重复读(<code>repeatable read</code>)和串行化(<code>Serializable</code>)。</p></li><li><p><code>Durability</code>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><h2>3.spring事务传播行为</h2><p>在我们用SSM开发项目的时候，我们一般都是将事务设置在<code>Service</code>层 那么当我们调用<code>Service</code>层的一个方法的时候它能够保证我们的这个方法中执行的所有的对数据库的更新操作保持在一个事务中，在事务层里面调用的这些方法要么全部成功，要么全部失败。那么事务的传播特性也是从这里说起的。</p><div class="tip"><重点1> 如果你在你的`Service`层的这个方法中，除了调用了`Dao`层的方法之外，还调用了本类的其他的`Service`方法，那么在调用其他的`Service`方法的时候，这个事务是怎么规定的呢，我必须保证我在我方法里调用的这个方法与我本身的方法处在同一个事务中，否则如果保证事物的一致性。事务的传播特性就是解决这个问题的.</重点1></div><p>在Spring中有针对传播特性的多种配置我们大多数情况下只用其中的一种:<code>PROPGATION_REQUIRED</code>：这个配置项的意思是说当我调用<code>service</code>层的方法的时候开启一个事务(具体调用那一层的方法开始创建事务，要看你的aop的配置),那么在调用这个<code>service</code>层里面的其他的方法的时候,如果当前方法产生了事务就用当前方法产生的事务，否则就创建一个新的事务。这个工作使由Spring来帮助我们完成的。</p><div class="tip"><重点2> 默认情况下当发生`RuntimeException`的情况下，事务才会回滚，所以要注意一下：如果你在程序发生错误的情况下，有自己的异常处理机制定义自己的`Exception`，必须从`RuntimeException`类继承，这样事务才会回滚！</重点2></div><h2>4.事务隔离级别</h2><ul><li>1、<code>Serializable</code>：最严格的级别，事务串行执行，资源消耗最大；</li><li>2、<code>REPEATABLE READ</code>：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。</li><li>3、<code>READ COMMITTED</code>:大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。</li><li>4、<code>Read Uncommitted</code>：保证了读取过程中不会读取到非法数据。</li></ul><h2>5.总结</h2><p>本文的重点是在于理解事务的传播行为这个概念，从事务的概念，到事务的ACID介绍，引出事务传播传播行为和隔离级别这两个概念加以理解。</p>]]></content>
      
      
        <tags>
            
            <tag> miscellany </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2019/01/22/java-collection/12.ConcurrentHashMap/"/>
      <url>/2019/01/22/java-collection/12.ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<p>对于并发场景下，推荐使用线程安全的 concurrentHashMap ，而不是 HashMap 或者是 HashTable .concurrentHashMap在JDK7和JDK8中的实现原理是不一样的。本文分别对其核心思想和方法进行阐述。</p><a id="more"></a><h2>一、JDK7实现</h2><p><code>ConcurrentHashMap</code> 的内部细分了若干个小的 <code>HashMap</code> ，称之为段（ <code>SEGMENT</code> ）。 <code>ConcurrentHashMap</code> 是一个 <code>Segment</code> 数组，<code>Segment</code> 通过继承 <code>ReentrantLock</code> 来进行加锁，所以每次需要加锁的操作锁住的是一个 <code>segment</code> ，这样只要保证每个 <code>Segment</code> 是线程安全的，也就实现了全局的线程安全。</p><p><img src="http://bloghello.oursnail.cn/ConcurrentHashMap7.png" alt="image"></p><p>如图所示，是由 <code>Segment</code> 数组、<code>HashEntry</code> 数组组成，和 <code>HashMap</code> 一样，仍然是数组加链表组成。</p><p><code>ConcurrentHashMap</code> 采用了分段锁技术，其中 <code>Segment</code> 继承于 <code>ReentrantLock</code>。不会像 <code>HashTable</code> 那样不管是 <code>put</code> 还是 <code>get</code> 操作都需要做同步处理，理论上 <code>ConcurrentHashMap</code> 支持 <code>CurrencyLevel</code> ( <code>Segment</code> 数组数量)的线程并发。每当一个线程占用锁访问一个 <code>Segment</code> 时，不会影响到其他的 <code>Segment</code>。</p><h5>1.1 get方法</h5><p><code>ConcurrentHashMap</code> 的 <code>get</code> 方法是非常高效的，因为<strong>整个过程都不需要加锁</strong>。</p><p>只需要将 <code>Key</code> 通过 <code>Hash</code> 之后定位到具体的 <code>Segment</code> ，再通过一次 <code>Hash</code> 定位到具体的元素上。由于 <code>HashEntry</code> 中的 <code>value</code> 属性是用 <code>volatile</code> 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值.</p><p>内部 <code>HashEntry</code> 类 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    HashEntry(<span class="keyword">int</span> hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>1.2 put方法</h5><p>虽然 <code>HashEntry</code> 中的 <code>value</code> 是用 <code>volatile</code> 关键词修饰的，但是并不能保证并发的原子性，所以 <code>put</code> 操作时仍然<strong>需要加锁处理</strong>。</p><p>首先也是通过 <code>Key</code> 的 <code>Hash</code> 定位到具体的 <code>Segment</code>，在 <code>put</code> 之前会进行一次扩容校验。这里比 <code>HashMap</code> 要好的一点是：<code>HashMap</code> 是插入元素之后再看是否需要扩容，有可能扩容之后后续就没有插入就浪费了本次扩容(扩容非常消耗性能)。</p><p><strong>而 <code>ConcurrentHashMap</code> 不一样，它是在将数据插入之前检查是否需要扩容，之后再做插入操作。</strong></p><h5>1.3 size方法</h5><p>每个 <code>Segment</code> 都有一个 <code>volatile</code> 修饰的全局变量 <code>count</code> ,求整个 <code>ConcurrentHashMap</code> 的 size 时很明显就是将所有的 <code>count</code> 累加即可。但是 <code>volatile</code> 修饰的变量却不能保证多线程的原子性，所有直接累加很容易出现并发问题。</p><p>但如果每次调用 <code>size</code> 方法将其余的修改操作加锁效率也很低。所以做法是先尝试两次将 <code>count</code> 累加，如果容器的 <code>count</code> 发生了变化再加锁来统计 <code>size</code>。</p><p>在 <code>JDK7</code> 中，<strong>第一种方案</strong>他会使用不加锁的模式去尝试多次计算 <code>ConcurrentHashMap</code> 的 <code>size</code>，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。</p><p><strong>第二种方案</strong>是如果第一种方案不符合，他就会给每个 <code>Segment</code> 加上锁，然后计算 <code>ConcurrentHashMap</code> 的 <code>size</code> 返回。其源码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line"> <span class="keyword">int</span> size;</span><br><span class="line"> <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line"> <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line"> <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line"> <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0L</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    overflow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sum += seg.modCount;</span><br><span class="line">            <span class="keyword">int</span> c = seg.count;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">            overflow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == last)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        last = sum; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁之前重试次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2>二、JDK8实现</h2><p><img src="http://bloghello.oursnail.cn/ConcurrentHashMap8.png" alt="image"></p><p><code>jdk8</code> 中的 <code>ConcurrentHashMap</code> 数据结构和实现与 <code>jdk7</code> 还是有着明显的差异。</p><p>其中抛弃了原有的 <code>Segment</code> 分段锁，而采用了 <code>CAS</code> + <code>synchronized</code> 来保证并发安全性。</p><p>也将 <code>jdk7</code> 中存放数据的 <code>HashEntry</code> 改为 <code>Node</code>，但作用都是相同的。</p><p><img src="http://bloghello.oursnail.cn/collection12-2.jpg" alt="image"></p><p>其中的 <code>val</code> <code>next</code> 都用了 <code>volatile</code> 修饰，保证了可见性。</p><h2>2.1 put方法</h2><p>重点来看看 <code>put</code> 函数：</p><p><img src="http://bloghello.oursnail.cn/collection12-3.jpg" alt="image"></p><ul><li>根据 <code>key</code> 计算出 <code>hashcode</code> 。</li><li>判断是否需要进行初始化。</li><li><code>f</code> 即为当前 <code>key</code> 定位出的 <code>Node</code>，<strong>如果为空表示当前位置可以写入数据，利用 <code>CAS</code> 尝试写入</strong>，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足(不需要初始化、Node不为空、不需要扩容)，则<strong>利用 <code>synchronized</code> 锁写入数据</strong>。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li></ul><h2>2.2 get方法</h2><ul><li>根据计算出来的 <code>hashcode</code> 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>都不满足那就按照链表的方式遍历获取值。</li></ul><h2>2.3 size方法</h2><p><code>JDK8</code> 实现相比 <code>JDK7</code> 简单很多，只有一种方案，我们直接看 <code>size()</code> 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">                (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (<span class="keyword">int</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CounterCell[] as = counterCells; </span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="comment">//获取baseCount值</span></span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="comment">//遍历CounterCell数组全部加到baseCount上，它们的和就是size</span></span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可能你会有所疑问，<code>ConcurrentHashMap</code> 中的 <code>baseCount</code> 属性不就是记录的所有键值对的总数吗？直接返回它不就行了吗？</p><p>之所以没有这么做，是因为我们的 <code>addCount</code> 方法用于 <code>CAS</code> 更新 <code>baseCount</code>，但很有可能在高并发的情况下，更新失败，那么这些节点虽然已经被添加到哈希表中了，但是数量却没有被统计。</p><p><strong>还好，<code>addCount</code> 方法在更新 <code>baseCount</code> 失败的时候，会调用 <code>fullAddCount</code> 将这些失败的结点包装成一个 <code>CounterCell</code> 对象，保存在 <code>CounterCell</code> 数组中。那么整张表实际的 <code>size</code> 其实是 <code>baseCount</code> 加上 <code>CounterCell</code>数组中元素的个数。</strong></p><h2>三、总结</h2><ul><li>并发情况下请使用<code>concurrentHashMap</code></li><li>在<code>jdk7</code>中，用的是分段锁，默认是12段，那么并发量最多也就12.<ul><li><code>get</code>不加锁，第一次<code>hash</code>定位到<code>segment</code>，第二次<code>hash</code>定位到元素，元素值是用<code>volatile</code>保证内存可见性</li><li><code>put</code>需要加锁，<code>hash</code>定位到<code>segment</code>后，先检查是否需要扩容再插入。</li><li><code>size</code>先使用不加锁的模式去尝试多次计算<code>size</code>，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入；如果不一致，给每个 <code>Segment</code> 加上锁再依次去计算个数</li></ul></li><li>在<code>jdk8</code>中，采用了 <code>CAS</code> + <code>synchronized</code> 来保证并发安全性<ul><li><code>put</code>的过程比较复杂，简单来说是：先计算<code>hash</code>定位到<code>node</code>—》判断是否初始化—》如果<code>node</code>为空则表示可以插入，用<code>cas</code>插入—》判断是否需要扩容—》如果不需要初始化、<code>Node</code>不为空、不需要扩容，则利用 <code>synchronized</code> 锁写入数据—》判断是否需要转换为红黑树</li><li><code>get</code>就比较简单，直接根据<code>hash</code>定位到<code>node</code>，然后以链表或者红黑树的方式拿到</li><li><code>size</code>方法就一种方案：<code>baseCount</code>+<code>CounterCell[]中所有元素</code></li></ul></li></ul><p>整理自：</p><ul><li><a href="https://crossoverjie.top/JCSprout/#/thread/ConcurrentHashMap?id=size-%e6%96%b9%e6%b3%95" target="_blank" rel="noopener">https://crossoverjie.top/JCSprout/#/thread/ConcurrentHashMap?id=size-方法</a></li><li><a href="https://www.jianshu.com/p/e99e3fcface4" target="_blank" rel="noopener">https://www.jianshu.com/p/e99e3fcface4</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap死循环问题</title>
      <link href="/2019/01/21/java-collection/11.HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/21/java-collection/11.HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>JDK1.7或者更老的版本中在多线程情况下是会存在死循环问题，究其原因是put过程中的resize方法在调用transfer方法的时候导致的死锁。这次我们来看看到底是哪里出了问题！</p><a id="more"></a><h2>核心源码</h2><p>在JDK8中，内部已经调整，解决了死循环问题，是如何解决的呢？将JDK7中头插入法改为末端插入。就是这么简单。关于这个，可以查看jdk8源码中的<code>resize</code>方法。</p><p>上面提到是由于<code>put</code>时出现问题，那么先来到<code>put()</code>中看看：</p><p><img src="http://bloghello.oursnail.cn/collection11-1.png" alt="image"></p><p>我们看到，put一个不存在的新元素，必然增加一个节点，我们进入这个增加节点的方法：</p><p><img src="http://bloghello.oursnail.cn/collection11-2.png" alt="image"></p><p>检查是否需要扩容，需要的话就<code>resize</code>:</p><p><img src="http://bloghello.oursnail.cn/collection11-3.png" alt="image"></p><p>下面就是对链表数据进行迁移：</p><p><img src="http://bloghello.oursnail.cn/collection11-4.png" alt="image"></p><p>核心的代码就是这么多，首先要强调一下：<strong>两个线程进来，是分别建立了两个独立的扩容后的数组</strong>，比如这里是两个长度为4的数组。老的数组为2个数就是唯一的。所以在第一步，线程2运行结束时，老的数组元素已经空了。</p><p>下面先演示一下正常的<code>rehash</code>过程。</p><h2>正常情况</h2><p><img src="http://bloghello.oursnail.cn/collection11-5.png" alt="image"></p><ul><li>假设了我们的<code>hash</code>算法就是简单的用 key mod 一下数组(hash表)的大小</li><li>最上面的是<code>old hash</code> 表，其中的<code>Hash</code>表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在<code>table[1]</code>这里了。</li><li>接下来的三个步骤是<code>Hash</code>表 <code>resize</code> 成4，然后所有的 <code>&lt;key,value&gt;</code> 重新 <code>rehash</code> 的过程</li></ul><p>注意到，在JDK7中，是按照头插入法依次插入的。所以7插到了3前面。</p><h2>并发情况</h2><h5>1.初始情况</h5><p>假设我们有两个线程。我用红色和浅蓝色标注了一下。</p><p>对于第一个线程先执行完这一行，然后挂起，此时 <code>e</code> 和 <code>next</code> 都附好值了：</p><p><img src="http://bloghello.oursnail.cn/collection11-6.png" alt="image"></p><p>而让线程二执行完成。于是我们有下面的这个样子：</p><p><img src="http://bloghello.oursnail.cn/collection11-7.png" alt="image"></p><p>因为<code>Thread1</code>的 <code>e</code> 指向了 <code>key(3)</code> ，而 <code>next</code> 指向了 <code>key(7)</code> ，其在 <code>Thread2</code>  <code>rehash</code>后，指向了 <code>Thread2</code> 重组后的链表。</p><h5>2.Thread1被调度回来执行</h5><ul><li>先是执行 <code>newTalbe[i] = e</code> ：此时线程1的第三个位置就是指向元素3;</li><li>然后是 <code>e = next</code>，导致了 <code>e</code> 指向了 <code>key(7)</code> ;</li><li>而下一次循环的 <code>next = e.next</code> 导致了 <code>next</code> 指向了 <code>key(3)</code> ;</li></ul><p><img src="http://bloghello.oursnail.cn/collection11-8.png" alt="image"></p><h2>3.一切安好</h2><p>线程一接着工作。把 <code>key(7)</code> 摘下来，放到 <code>newTable[i]</code> 的第一个，然后把 <code>e</code> 和 <code>next</code> 往下移。</p><p><img src="http://bloghello.oursnail.cn/collection11-9.png" alt="image"></p><h5>4.环形链接出现</h5><p><code>e.next = newTable[i]</code> 导致  <code>key(3).next</code> 指向了 <code>key(7)</code></p><p>注意：此时的 <code>key(7).next</code> 已经指向了 <code>key(3)</code>， 环形链表就这样出现了。</p><p><img src="http://bloghello.oursnail.cn/collection11-10.png" alt="image"></p><h2>自己的简单整理</h2><p>这里还是比较绕的，理解的最好方式左边放源码，右边放图，中间用草稿纸画一画。</p><p>那么，这里我在对其过程尽可能地讲明白一点。我们先确定7和3会全部落到扩容后的下标为3的位置(3%4=3,7%4=3)。</p><p>规定线程1开辟的数组为 <code>arr1</code> ，线程2开辟的数组为 <code>arr2</code>;</p><h5>1. 初始状态</h5><ul><li>线程一： e -&gt; key3 , next -&gt; key7</li><li>线程二： 数组3号位置 arr2[3] -&gt; key7 -&gt; key3</li></ul><p>注意此时 <code>key7</code> 指向 <code>key3</code> .</p><p>我们要明确一下，发生死循环，是指在<code>put</code>操作完毕之后，最终生成的数组中有死循环引用才行，千万不要一开始看线程一种key3指向key7，然后线程二种key7指向key3就是死循环了。。。</p><h5>2. 线程一继续执行</h5><p><img src="http://bloghello.oursnail.cn/collection11-6.png" alt="image"></p><ul><li>i = 3</li><li>e.next = key7,此时 e=key3 ,所以是 key3.next = key7（这是线程1的初始状态决定的）</li><li>arr1[3] 指向 key3</li><li>e 为 key7</li></ul><h5>3.由于e不为空，所以还会循环：</h5><ul><li>上一步 e 为 key7，所以 next = key7.next ，到线程2中一看是 key3 ，所以 next = key3（线程2中key7.next就是key3）</li><li>i = 3</li><li>e.next = key3------<strong>注意，这里就是Key7指向了key3,key7的next引用下面没有变过，所以这里做一下记录，即key7指向key3</strong></li><li>newTable[3] = key7</li><li>e = key3</li></ul><h5>4.由于e不为空，所以还会循环：</h5><ul><li>上一步 e=key3 , next=null</li><li>i=3</li><li>key3.next = key7，注意,由于key7已经指向了key3，<strong>此时key3又指向key7</strong>,发生死循环</li><li>newTable[3] = key3</li><li>e = null</li></ul><h5>5.e为null，跳出循环。</h5><p>此时发现key3又指向了key7。发生死循环。</p><p>整理自:<a href="https://coolshell.cn/articles/9606.html/comment-page-2#comments" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html/comment-page-2#comments</a></p>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux重要的一些命令</title>
      <link href="/2019/01/21/linux%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/01/21/linux%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>很多命令之所以重要，是因为用它们会大幅提高工作效率。所以，熟悉它们是我们必须要做的一件事情。下面着重提取了find、grep、管道、wc、awk以及sed等几个命令来看看如何使用。</p><a id="more"></a><h2>一、Linux体系结构</h2><div align="center">    <img src="http://bloghello.oursnail.cn/linux1-1.png" style="width:300px;"></div><p>对这幅图进行详细说明一下。</p><ul><li>体系结构主要分为<strong>用户态</strong>(用户上层活动)和<strong>内核态</strong></li><li><strong>内核：本质是一段管理计算机硬件设备的程序</strong>，这个程序直接管理硬件：包括CPU、内存空间、硬盘接口、网络接口等。所有的计算机操作都要通过内核来操作。</li><li>系统调用：内核的访问接口，<strong>是一种不能再简化的操作</strong>(可以认为系统调用已经是最小的原子操作，上层完成一个功能要依托于若干系统调用才能完成)</li><li>由于系统调用比较基础，要完成一个功能需要很多系统调用组合才能实现，对于程序员来说比较复杂。这个时候怎么办呢？<strong>我们可以调用公共函数库：系统调用的组合拳。简化程序员操作</strong>。</li><li><code>Shell</code>也是一种特殊的应用程序，是一个命令解释器，可以编程。</li><li><code>Shell</code>下通系统调用，上通各种应用，是上层和下层之间粘合的胶水，让不同程序可以偕同工作。</li><li>在没有图形界面之前，用户通过<code>shell</code>命令行或者可编程的<code>shell</code>脚本可以完成很多事情。</li></ul><h2>二、如何根据文件名检索文件</h2><ul><li>find</li><li>在指定目录下查找文件</li></ul><blockquote><p>语法 find path [options] params</p></blockquote><h3>2.1 精确查找文件</h3><p>比如我在当前目录(可能在子目录下)下找一个文件叫做<code>test.java</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name "test.java"</span><br></pre></td></tr></table></figure><p>这个指令就可以在本目录以及子目录下递归查找这个文件了。</p><p>实例：精确查询名字叫<code>snailmall-api-gateway-8080.jar</code>这个文件：</p><p><img src="http://bloghello.oursnail.cn/linux1-4.png" alt="image"></p><h3>2.2 全局搜索</h3><p>如果是全局查找，也很简单，无非是从根目录开始递归查找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name "test.java"</span><br></pre></td></tr></table></figure><p>实例：我对这台服务器全局查找文件名以<code>snailmall</code>开头的所有文件：</p><p><img src="http://bloghello.oursnail.cn/linux1-3.png" alt="image"></p><h3>2.3 模糊查询</h3><p>如果找以test打头的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name "test*"</span><br></pre></td></tr></table></figure><p>即用 <code>*</code> 通配符就可以模糊查询到以 <code>test</code> 打头的文件。</p><p>实例，我的这台服务器上部署了几个关于商城的服务，这个目录下我放了jar包和相应的启动信息文件。我对其进行模糊查询：</p><p><img src="http://bloghello.oursnail.cn/linux1-2.png" alt="image"></p><h3>2.4 忽略大小写</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -iname "test*"</span><br></pre></td></tr></table></figure><h2>三、如何根据文件内的内容进行检索</h2><h3>3.1 grep命令</h3><ul><li>grep</li><li>查找文件里符合条件的字符串</li></ul><blockquote><p>语法：grep [options] pattern file</p></blockquote><p>比如 <code>test.java</code> 中有一句话是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"i love java"</span>);</span><br></pre></td></tr></table></figure><p>那么如何查找 <code>test.java</code> 中的 <code>java</code> 呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "java" test*</span><br></pre></td></tr></table></figure><p>这句话意思就是查找以 <code>test</code> 打头的文件中的包含 <code>java</code> 字符串所在的行。</p><p>直接输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep "hello"</span><br></pre></td></tr></table></figure><p>会等待用户输入文本。然后再对输入的内容进行检索。</p><h3>3.2 管道操作符 |</h3><blockquote><p>可将指令连接起来，前一个指令的输出作为后一个指令的输入。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / | grep "test"</span><br></pre></td></tr></table></figure><p>作用同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name "test"</span><br></pre></td></tr></table></figure><div class="tip"><p>注意：</p><p>只有前一个指令正确才会再处理。</p><p>管道右边命令必须能接收标准输入流，否则传递过程中数据会被抛弃</p></div><h3>3.3 grep结合管道</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'xxx' hello.info</span><br></pre></td></tr></table></figure><p>可以将 <code>xxx</code> 所在的行全部筛选出来，但是还是特别多，我比如关心这每一行中某个字段的信息，比如是 <code>param[xx12]</code>这种信息。如何实现筛选呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'xxx' hello.info | grep -o 'param\[[0-9a-z]*\]'</span><br></pre></td></tr></table></figure><p>这样就只把类似于 <code>param[xx12]</code> 这样的信息清晰地展现出来。</p><p>如何过滤掉不要的信息呢？可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v</span><br></pre></td></tr></table></figure><p>比如我们查询 <code>tomcat</code> 进程信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br></pre></td></tr></table></figure><p>我们会发现，不仅 <code>tomcat</code> 的信息展现出来了，执行 <code>grep</code> 命令本身的进程信息也展示出来了。我们要将这个 <code>grep</code> 命令过滤掉，只展现 <code>tomcat</code> 进程信息，可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat | grep -v "grep"</span><br></pre></td></tr></table></figure><p>这样就把 <code>grep</code> 进程信息过滤掉了。</p><h2>四、如何对文件内容做统计</h2><ul><li>awk</li><li>一次读取一行文本，按输入分隔符进行切片，切成多个组成部分</li><li>将切片直接保存再内建的变量中，$1$2…($0表示行的全部)</li><li>支持对单个切片的判断，支持循环判断，<strong>默认分隔符为空格</strong></li></ul><blockquote><p>语法：awk [options] ‘cmd’ file</p></blockquote><p>有这样一个文件text1.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proto   Recv-Q   Send-Q    Local Address     Foreign Address      state</span><br><span class="line">tcp     0        48        111.34.134.2:ssh  124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     0        48        localhost:mysql   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     0        48        111.34.13.2:s0    124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     0        48        localhost:mysql   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     1        48        localhots:webcac  124.213.2.12:12565   ESTABLISHED</span><br><span class="line">tcp     1        48        111.34.134.2:s1   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     1        48        111.34.134.2:s2   124.213.2.12:12565   ESTABLISHED</span><br><span class="line">udp     0        48        111.34.134.2:s3   124.213.2.12:12565   ESTABLISHED</span><br></pre></td></tr></table></figure><p>列出切分出来的第一列和第二列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1,$2&#125;' test1.txt</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://bloghello.oursnail.cn/linux1-7.png" alt="image"></p><p>筛选出第一列为<code>tcp</code>和第二列为<code>1</code>的所在行，将这些行数据全部打印出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '$1="tcp" &amp;&amp; $2==1&#123;print $0&#125;' test1.txt</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://bloghello.oursnail.cn/linux1-8.png" alt="image"></p><p>打印带有表头的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '($1="tcp" &amp;&amp; $2==1) || NR==1 &#123;print $0&#125;' test1.txt</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-9.png" alt="image"></p><p>默认是以空格分隔，那么以逗号或者其他符号可以吗？答案当然是可以。对于这样的文件text2.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adas,123</span><br><span class="line">wqe,544</span><br><span class="line">12321,dddf</span><br><span class="line">sdaasd,1235</span><br><span class="line">465547,fjigj</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F "," '&#123;print $2&#125;' text2.txt</span><br></pre></td></tr></table></figure><h2>五、WC统计</h2><p>有一个文件test2.txt，里面的内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swg123eh shwf</span><br><span class="line">shsfswg7 121 32n dswg17328 123swg1 2h1jhw</span><br><span class="line">jqbsjwqbsh ddddh wg ehdedhd  dhsjh</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-10.png" alt="image"></p><h2>六、sed命令</h2><p>sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作</p><blockquote><p>sed [-n/e/f/r/i] ‘command’ 输入文本</p></blockquote><p>常用选项：</p><ul><li>-n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</li><li>-e∶直接在指令列模式上进行 sed 的动作编辑；</li><li>-f∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；</li><li>-r∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)</li><li>-i∶<strong>直接修改读取的档案内容，而不是由萤幕输出</strong>。</li></ul><p>常用命令：</p><ul><li>a   ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c   ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d   ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i   ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p  ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～</li><li>s  ∶<strong>取代</strong>，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><p>这里我就主要看一下批量替换这个功能。</p><p>如果只是给一个文件中的若干字符串批量替换，只需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i "s/oldstring/newstring/g" filename</span><br></pre></td></tr></table></figure><p><img src="http://bloghello.oursnail.cn/linux1-12.png" alt="image"></p><p>如果是对某一路径下很多的文件批量替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/oldstring/newstring/g&quot; `grep oldstring -rl path`</span><br></pre></td></tr></table></figure><p>其中，<code>oldstring</code>是待被替换的字符串，<code>newstring</code>是待替换<code>oldstring</code>的新字符串，<code>grep</code>操作主要是按照所给的路径查找<code>oldstring</code>，<code>path</code>是所替换文件的路径；</p><ul><li><strong>-i选项是直接在文件中替换，不在终端输出</strong>；</li><li><strong>-r选项是所给的path中的目录递归查找</strong>；</li><li><strong>-l选项是输出所有匹配到oldstring的文件</strong>；</li></ul><p>这里只是模拟一下，将目录下的所有文件进行批量修改：</p><p><img src="http://bloghello.oursnail.cn/linux1-13.png" alt="image"></p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>站点文章汇总</title>
      <link href="/2019/01/21/%E7%AB%99%E7%82%B9%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"/>
      <url>/2019/01/21/%E7%AB%99%E7%82%B9%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>请先移步这里☝️☝️☝️🔝🔝🔝本文为置顶文章，为了方便管理和查阅，在这里详细展示目录索引，看完索引，你就知道本站的大体内容啦！我相信一定会给小伙伴们一些收获！</p><a id="more"></a><h2>计算机网络🐭🐭🐭</h2><p>这一部分主要是关于<code>HTTP</code>和<code>TCP</code>的必备知识。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">《计算机网络相关系列》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/1.%E4%BB%8E%E4%B8%8B%E5%88%B0%E4%B8%8A%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">《从下到上看五层模型》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/2.%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">《从上到下看五层模型》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/17/network/3.http%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" target="_blank" rel="noopener">《HTTP的前世今生》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/4.TCP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">《TCP协议入门》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/5.TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" target="_blank" rel="noopener">《TCP三次握手和四次挥手》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/6.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8F%90%E7%82%BC/" target="_blank" rel="noopener">《HTTP基础知识提炼》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/18/network/7.%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3HTTPS/" target="_blank" rel="noopener">《一步一步理解HTTPS》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/25/network/8.%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener">《一些常见的面试题》</a></li></ul></li></ul><h2>JAVA容器🐱🐱🐱</h2><p>这一部分是<code>JAVA</code>容器一系列文章，主要讲了常用<code>JAVA</code>容器的源码和一些特性，面试必问点。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/java%E5%AE%B9%E5%99%A8/" target="_blank" rel="noopener">《JAVA容器》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/1.ArrayList%E5%92%8CVector/" target="_blank" rel="noopener">《ArrayList/Vector》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/2.LinkedList/" target="_blank" rel="noopener">《LinkedList》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/3.CopyOnWriteArrayList/" target="_blank" rel="noopener">《CopyOnWriteArrayList》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/4.hashcode%E5%92%8Cequals/" target="_blank" rel="noopener">《HashCode/Equals》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/5.HashMap/" target="_blank" rel="noopener">《HashMap》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/6.HashSet/" target="_blank" rel="noopener">《HashSet》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/7.LinkedHashMap/" target="_blank" rel="noopener">《LinkedHashMap》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">《HashMap和LinkedHashMap遍历机制》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/9.HashTable/" target="_blank" rel="noopener">《HashTable》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/20/java-collection/10.LinkedHashSet/" target="_blank" rel="noopener">《LinkedHashSet》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/21/java-collection/11.HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《JDK7中HashMap死循环原因剖析》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/java-collection/12.ConcurrentHashMap/" target="_blank" rel="noopener">《ConcurrentHashMap》</a></li></ul></li></ul><h2>Linux&amp;操作系统🐶🐶🐶</h2><p>一些必备的<code>Liunx</code>相关的知识点整理。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/Linux/" target="_blank" rel="noopener">《Linux》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/21/linux%E9%87%8D%E8%A6%81%E7%9A%84%E5%91%BD%E4%BB%A4/" target="_blank" rel="noopener">《Linux面试重要命令》</a></li></ul></li><li><a href="http://fourcolor.oursnail.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">《操作系统相关》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">《面试-进程与线程》</a></li></ul></li><li><a href="http://fourcolor.oursnail.cn/tags/Socket/" target="_blank" rel="noopener">《Socket》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/02/20/Socket%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">《Socket基础》</a>：</li></ul></li></ul><h2>JAVA虚拟机相关🐹🐹🐹</h2><p>主要是介绍JVM相关知识。轻松应付面试。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/JVM/" target="_blank" rel="noopener">《JVM》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/02/03/JVM/Java%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">《Java如何执行一个最简单的程序》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/%E6%B5%85%E8%B0%88ClassLoader/" target="_blank" rel="noopener">《浅谈ClassLoader》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">《双亲委派模型》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/%E7%BB%86%E8%B0%88loadClass/" target="_blank" rel="noopener">《细谈loadClass》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/" target="_blank" rel="noopener">《JAVA内存模型-线程私有》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB/" target="_blank" rel="noopener">《JAVA内存模型-线程共享》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/08/JVM/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%B8%B8%E9%97%AE%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener">《JAVA内存模型常问面试题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/GC%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">《GC相关》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《垃圾收集器介绍》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">《内存分配和回收策略》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">《类的初始化过程》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE/" target="_blank" rel="noopener">《静态分派和动态分派》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">《实例说明类加载过程》</a></li><li><font color="purple">以下是扩展阅读部分，主要是对Class文件的结构进行详细的解读</font></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB-Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">《补充阅读1-Class类文件结构》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB2-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/" target="_blank" rel="noopener">《补充阅读2-Class文件中的常量池》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB3-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E3%80%81%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">《补充阅读3-Class文件中的访问标志、类索引、父类索引、接口索引集合》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB4-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88--field%E5%AD%97%E6%AE%B5%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/" target="_blank" rel="noopener">《补充阅读4-Class文件中的字段表集合–field字段在class文件中是怎样组织的》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/09/JVM/%E8%A1%A5%E5%85%85%E9%98%85%E8%AF%BB5-Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88--method%E6%96%B9%E6%B3%95%E5%9C%A8class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E7%9A%84/" target="_blank" rel="noopener">《补充阅读5-Class文件中的方法表集合–method方法在class文件中是怎样组织的》</a></li></ul></li></ul><h2>JAVA核心基础知识🐺🐺🐺</h2><p>主要是介绍比较核心的JAVA基础知识，属于JAVA基础进阶。</p><ul><li><a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/Integer%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1/" target="_blank" rel="noopener">《Integer拆箱和装箱》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2/" target="_blank" rel="noopener">《String为什么不可变》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/java-basic/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%B8%E5%BF%83%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD/" target="_blank" rel="noopener">《java字符串核心一网打尽》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/24/java-basic/JAVA%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E3%80%81%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener">《JAVA基础核心-理解类、对象、面向对象编程、面向接口编程》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/29/java-basic/%E8%A1%A5%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/" target="_blank" rel="noopener">《补码的前世今生》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/31/miscellany/14%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《数值计算精度丢失问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/04/java-basic/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3java%E5%8F%8D%E5%B0%84/" target="_blank" rel="noopener">《彻底理解java反射机制》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/17/java-basic/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%86%B0%E5%B7%9D%E8%A1%A8%E9%9D%A2/" target="_blank" rel="noopener">《java基础之冰川表面》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%A8%E8%A7%A3/" target="_blank" rel="noopener">《java基础之注解》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/17/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">《java基础之JDK动态代理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%82%E5%B8%B8/" target="_blank" rel="noopener">《java基础之异常》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%85%8B%E9%9A%86/" target="_blank" rel="noopener">《java基础之克隆》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8A/" target="_blank" rel="noopener">《java基础之泛型上》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/19/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B3%9B%E5%9E%8B%E4%B8%8B/" target="_blank" rel="noopener">《java基础之泛型下》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/20/java-basic/java%E5%9F%BA%E7%A1%80%E4%B9%8BNIO/" target="_blank" rel="noopener">《java基础之NIO》</a></li></ul><h2>JAVA多线程🐸🐸🐸</h2><p>多线程这一块比较棘手，且学且保重。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">《JAVA多线程和并发》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" target="_blank" rel="noopener">《线程基本知识梳理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/10/thread/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BC%A0%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">《java多线程之传参和返回值处理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/" target="_blank" rel="noopener">《线程的状态》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/10/thread/%E7%BA%BF%E7%A8%8B%E9%87%8D%E8%A6%81%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">《线程重要的相关方法》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/10/thread/%E4%BB%8E%E5%8D%96%E7%A5%A8%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5%E7%9C%8Bsynchronized%E7%9A%84%E7%89%B9%E6%80%A7/" target="_blank" rel="noopener">《从卖票程序初步看synchronized的特性》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/11/thread/%E4%BB%8E%E5%BA%95%E5%B1%82%E7%90%86%E8%A7%A3synchronized/" target="_blank" rel="noopener">《从底层理解synchronized》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/11/thread/volatile%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">《volatile详解》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/11/thread/%E4%BB%8EReentrantLock%E5%BC%95%E5%87%BAAQS%E7%9A%84%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">《从ReentrantLock引出AQS的原理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/12/thread/AQS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/" target="_blank" rel="noopener">《AQS实现的一些并发工具类》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/11/thread/%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/" target="_blank" rel="noopener">《读写锁ReentrantReadWriteLock》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/12/thread/%E4%BB%8ECAS%E5%88%B0Atomic%E5%8C%85%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">《从CAS到Atomic包原理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/12/thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">《线程池原理详解》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-ForkJoin%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">《JUC组件拓展-ForkJoin简介》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/12/thread/JUC%E7%BB%84%E4%BB%B6%E6%8B%93%E5%B1%95-BlockingQueue/" target="_blank" rel="noopener">《JUC组件拓展-BlockingQueue》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/13/thread/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">《线程间通信方式总结》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/13/thread/%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">《实现生产者消费者模式》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/15/thread/Condition%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">《Condition详解》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/18/thread/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">《自己实现一个简单的web服务器》</a></li></ul></li></ul><h2>Redis🐯🐯🐯</h2><p>系统学习redis的笔记整理。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/redis/" target="_blank" rel="noopener">《Redis》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/29/redis/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86Redis/" target="_blank" rel="noopener">《初步认识Redis》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/29/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener">《Redis基本数据结构和操作》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/29/redis/Redis%E5%85%B6%E4%BB%96%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《Redis其他的功能介绍》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/30/redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB/" target="_blank" rel="noopener">《Redis为什么快》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/31/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/" target="_blank" rel="noopener">《Redis持久化》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/31/redis/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" target="_blank" rel="noopener">《Redis主从复制》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Sentinel%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/" target="_blank" rel="noopener">《Redis-Sentinel实现高可用读写分离》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/01/redis/Redis-Cluster%E7%90%86%E8%AE%BA%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">《Redis-Cluster理论详解》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/01/redis/%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">《Redis缓存设计与优化》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/02/redis/Redis%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《Redis缓存更新问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/02/redis/Redis%E4%BA%8B%E5%8A%A1/" target="_blank" rel="noopener">《Redis事务》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/02/redis/%E5%87%A0%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">《几种主流缓存框架介绍》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/02/redis/%E5%85%B3%E4%BA%8ERedis%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E9%9D%A2%E8%AF%95%E7%82%B9/" target="_blank" rel="noopener">《关于Redis一些重要的面试点》</a></li></ul></li></ul><h2>MySQL数据库🐨🐨🐨</h2><p>作为必备技能，用法和原理都要会。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/mysql/" target="_blank" rel="noopener">《MySQL》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/25/mysql/mysql%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">《mysql最基础知识小结》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/27/mysql/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" target="_blank" rel="noopener">《SQL必知必会知识点提炼》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/27/mysql/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">《复杂查询基础》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/05/mysql/%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5/" target="_blank" rel="noopener">《内连接和外连接》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/25/mysql/delete%E5%92%8Ctruncate%E4%BB%A5%E5%8F%8Adrop%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">《delete和truncate以及drop区别》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" target="_blank" rel="noopener">《如何设计一个关系型数据库》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">《数据库索引入门》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/MySQL%E7%B4%A2%E5%BC%95%E5%85%A8%E9%9D%A2%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">《MySQL索引全面解读》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/MySQL%E8%B0%83%E4%BC%98/" target="_blank" rel="noopener">《MySQL调优》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/" target="_blank" rel="noopener">《关于索引失效和联合索引》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/26/mysql/%E9%94%81%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">《锁模块》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/27/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《数据库事务核心问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/27/mysql/mysql%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" target="_blank" rel="noopener">《mysql面试高频理论知识》</a></li></ul></li></ul><h2>算法🐻🐻🐻</h2><p>算法这一块也是面试痛点和难点，头发越来越少了呢！</p><h2>Spring🐷🐷🐷</h2><p>大厂必问啊啊啊啊，源码终究还是要读的~</p><h2>Spring Cloud相关🐮🐮🐮</h2><p>这一块就比较偏实践了。分布式。。。路漫漫。。。</p><h2>Zookeeper🐗🐗🐗</h2><p>作为当今分布式协调中心，核心的Paxos算法你不想了解一下吗？</p><h2>杂记🐵🐵🐵</h2><p>在这个板块，不划分类别，文章尽可能地简短，也可谓之记忆碎片。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/miscellany/" target="_blank" rel="noopener">《技术短文杂记》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/01%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/" target="_blank" rel="noopener">《spring事务的传播行为》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/02Redisson%E5%AE%9E%E7%8E%B0Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《Redisson实现Redis分布式锁原理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/03redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《redis实现分布式锁》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/22/miscellany/04springMVC%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8+spring%E5%8C%85%E6%89%AB%E6%8F%8F%E5%8C%85%E9%9A%94%E7%A6%BB+spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/" target="_blank" rel="noopener">《springMVC全局异常+spring包扫描包隔离+spring事务传播》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/05%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">《分布式ID生成策略》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/06Spring%20Session/" target="_blank" rel="noopener">《Spring Session》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/07Curator%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" target="_blank" rel="noopener">《Curator》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/08ELK%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">《ELK平台搭建》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/09%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">《库存扣减问题》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/23/miscellany/10%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%80%83/" target="_blank" rel="noopener">《分布式事务解决方案思考》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/28/miscellany/11SpringBoot%E4%BD%BF%E7%94%A8logback%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E6%8C%89%E5%A4%A9%E6%BB%9A%E5%8A%A8/" target="_blank" rel="noopener">《SpringBoot使用logback实现日志按天滚动》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/29/miscellany/12%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E9%99%84%E8%BF%91%E6%9F%A5%E8%AF%A2%E7%9A%84GEOHASH%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" target="_blank" rel="noopener">《地理位置附近查询的GEOHASH解决方案》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/01/30/miscellany/13%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Nginx%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">《深入探究Nginx原理》</a></li><li><a href="http://fourcolor.oursnail.cn/2019/02/01/miscellany/15%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">《简明理解一致性hash算法》</a></li></ul></li></ul><h2>随笔🐖🐖🐖</h2><ul><li><a href="http://fourcolor.oursnail.cn/tags/%E9%9A%8F%E7%AC%94/" target="_blank" rel="noopener">《随笔》</a>：<ul><li><a href="http://fourcolor.oursnail.cn/2019/02/05/suibi/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/" target="_blank" rel="noopener">《2019年展望》</a></li></ul></li></ul><h2>实战作品🐰🐰🐰</h2><p>记录一些实战作品，代码主要存放在<code>github</code>上。</p><ul><li><a href="http://fourcolor.oursnail.cn/tags/%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">《我的实战》</a>：<ul><li><a href="https://github.com/sunweiguo/MMall" target="_blank" rel="noopener">《快乐蜗牛商城代码》</a></li><li><a href="https://github.com/sunweiguo/mama-buy" target="_blank" rel="noopener">《码码购分布式电商实战代码》</a></li></ul></li></ul><hr><img src="http://bloghello.oursnail.cn/mypay.png" width="500">]]></content>
      
      
        <tags>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedHashSet</title>
      <link href="/2019/01/20/java-collection/10.LinkedHashSet/"/>
      <url>/2019/01/20/java-collection/10.LinkedHashSet/</url>
      <content type="html"><![CDATA[<p>HashSet 和 LinkedHashSet 的关系类似于 HashMap 和 LinkedHashMap 的关系，即后者维护双向链表，实现迭代顺序可为插入顺序或是访问顺序。所以也就轻松加愉快快速了解一下即可。</p><a id="more"></a><p>从源码中可以看到其空的构造函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>super</code>即父类是<code>HashSet</code>，从它的继承关系就可以显然看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>那么<code>HashSet</code>内部的数据结构就是一个 <code>HashMap</code>，其方法的内部几乎就是在调用 <code>HashMap</code> 的方法。</p><p><code>LinkedHashSet</code> 首先我们需要知道的是它是一个 <code>Set</code> 的实现，所以它其中存的肯定不是键值对，而是值。此实现与 <code>HashSet</code> 的不同之处在于，<code>LinkedHashSet</code> 维护着一个运行于所有条目的双向循环链表。</p><p>这一切都与<code>LinkedHashMap</code>类似。</p><p><code>LinkedHashSet</code> 内部有个属性 <code>accessOrder</code> 控制着遍历次序。默认情况下该值为 <code>false</code> ,即按插入排序访问。如果将该值设置为 <code>true</code> 的话，则按访问次序排序(即最近最少使用算法，最近最少使用的放在链表头部，最近访问的则在链表尾部)。</p><h2>一、 示例</h2><h4>HashSet的遍历：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">linkedHashSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"eee"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = linkedHashSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>输出结果是：</h4><blockquote><p>aaa<br>ccc<br>bbb<br>eee</p></blockquote><h4>LinkedHashSet的遍历：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">linkedHashSet.add(<span class="string">"aaa"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"eee"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"ccc"</span>);</span><br><span class="line">linkedHashSet.add(<span class="string">"bbb"</span>);</span><br><span class="line">linkedHashSet.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = linkedHashSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>输出结果是：</h4><blockquote><p>aaa<br>eee<br>ccc<br>bbb<br>null</p></blockquote><p>可以看到与输入顺序是一致的。</p>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hashtable</title>
      <link href="/2019/01/20/java-collection/9.HashTable/"/>
      <url>/2019/01/20/java-collection/9.HashTable/</url>
      <content type="html"><![CDATA[<p>Hashtable 是个过时的集合类，不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。但这并不是我们不去了解它的理由。最起码 Hashtable 和 HashMap 的面试题在面试中经常被问到。</p><a id="more"></a><h2>一、前言</h2><p><code>Hashtable</code>和<code>HashMap</code>，从存储结构和实现来讲基本上都是相同的。</p><p>它和<code>HashMap</code>的最大的不同是它是线程安全的，另外它不允许<code>key</code>和<code>value</code>为<code>null</code>。</p><p>为了能在哈希表中成功地保存和取出对象，用作<code>key</code>的对象必须实现<code>hashCode</code>方法和<code>equals</code>方法。</p><h2>二、fail-fast机制</h2><p><code>iterator</code>方法返回的迭代器是<code>fail-fast</code>的。如果在迭代器被创建后<code>hashtable</code>被结构型地修改了，除了迭代器自己的<code>remove</code>方法，迭代器会抛出一个<code>ConcurrentModificationException</code>异常。</p><p><strong>因此，面对在并发的修改，迭代器干脆利落的失败，而不是冒险的继续。</strong></p><p>关于这个的理解，其实在上一章讲<code>LinkedHashMap</code>中的第八点提到：</p><div class="tip"><p><strong>值得注意的是，<code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</strong></p><p>简单说，就是两个线程同时分别进行修改和遍历时，会抛出这个异常。</p></div><p><strong>面试题：集合在遍历过程中是否可以删除元素，为什么迭代器就可以安全删除元素？</strong></p><p>集合在使用 <code>for</code> 循环迭代的过程中不允许使用，集合本身的 <code>remove</code> 方法删除元素，如果进行错误操作将会导致 <code>ConcurrentModificationException</code> 异常的发生</p><p><code>Iterator</code> 可以删除访问的当前元素(<code>current</code>)，一旦删除的元素是<code>Iterator</code> 对象中 <code>next</code> 所正在引用的，在 <code>Iterator</code> 删除元素通过 修改 <code>modCount</code> 与 <code>expectedModCount</code> 的值，可以使下次在调用 <code>remove</code> 的方法时候两者仍然相同因此不会有异常产生。</p><p>迭代器的<code>fail-fast</code>机制并不能得到保证，它不能够保证一定出现该错误。一般来说，<code>fail-fast</code>会尽最大努力抛出<code>ConcurrentModificationException</code>异常。因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：<code>ConcurrentModificationException</code> 应该仅用于检测 bug。</p><p><code>Hashtable</code>是线程安全的。如果不需要线程安全的实现是不需要的，推荐使用<code>HashMap</code>代替<code>Hashtable</code>。如果需要线程安全的实现，推荐使用<code>java.util.concurrent.ConcurrentHashMap</code>代替<code>Hashtable</code>。</p><h2>二、继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>extends Dictionary&lt;K,V&gt;</code>：<code>Dictionary</code>类是一个抽象类，用来存储键/值对，作用和Map类相似。</li><li><code>implements Map&lt;K,V&gt;</code>：实现了<code>Map</code>，实现了<code>Map</code>中声明的操作和<code>default</code>方法。</li></ul><p><code>hashMap</code>以及<code>TreeMap</code>的源码，都没有继承于这个类。不过当我看到注释中的解释也就明白了，其 <code>Dictionary</code> 源码注释是这样的：<code>NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class.</code> 该话指出 <code>Dictionary</code> 这个类过时了，新的实现类应该实现<code>Map</code>接口。</p><h2>三、属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hashtable被结构型修改的次数。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>HashTable</code>并没有像<code>HashMap</code>那样定义了很多的常量，而是直接写死在了方法里。</p><p><code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。</p><h2>四、构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认初始化容量（11）和默认负载因子（0.75）来构造一个空的hashtable.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里可以看到，Hashtable默认初始化容量为16，而HashMap的默认初始化容量为11。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以获取到这些信息：<code>HashTable</code>默认的初始化容量为11（与<code>HashMap</code>不同），负载因子默认为0.75（与<code>HashMap</code>相同）。而正因为默认初始化容量的不同，同时也没有对容量做调整的策略，所以可以先推断出，<code>HashTable</code>使用的哈希函数跟<code>HashMap</code>是不一样的（事实也确实如此）。</p><h2>五、重要方法</h2><h4>5.1 get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//通过哈希函数，计算出key对应的桶的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">//遍历该桶的所有元素，寻找该key</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，<code>Hashtable</code>和<code>HashMap</code>确认<code>key</code>在数组中的索引的方法不同。</p><ul><li><code>Hashtable</code>通过<code>index = (hash &amp; 0x7FFFFFFF) % tab.length;</code>来确认</li><li><code>HashMap</code>通过<code>i = (n - 1) &amp; hash;</code>来确认</li></ul><p>跟<code>HashMap</code>相比，<code>HashTable</code>的<code>get</code>方法非常简单。我们首先可以看见<code>get</code>方法使用了<code>synchronized</code>来修饰，所以它能保证线程安全。并且它是通过链表的方式来处理冲突的。另外，我们还可以看见<code>HashTable</code>并没有像<code>HashMap</code>那样封装一个哈希函数，而是直接把哈希函数写在了方法中。而哈希函数也是比较简单的，<strong>它仅对哈希表的长度进行了取模</strong>。</p><h4>5.2 put方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确认value不为null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//找到key在table中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">//获取key所在索引的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//遍历entry，判断key是否已经存在</span></span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">//如果key已经存在</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="comment">//保存旧的value</span></span><br><span class="line">            V old = entry.value;</span><br><span class="line">            <span class="comment">//替换value</span></span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">//返回旧的value</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果key在hashtable不是已经存在，就直接将键值对添加到table中，返回null</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//哈希表的键值对个数达到了阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="comment">//把新节点插入桶中（头插法）</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以总结出<code>Hashtable</code>的<code>put</code>方法的总体思路：</p><ul><li>确认<code>value</code>不为<code>null</code>。如果为<code>null</code>，则抛出异常</li><li>找到<code>key</code>在<code>table</code>中的索引，获取<code>key</code>所在位置的<code>entry</code></li><li>遍历<code>entry</code>，判断<code>key</code>是否已经存在</li><li>如果<code>key</code>已经存在，替换<code>value</code>，返回旧的<code>value</code></li><li>如果<code>key</code>在<code>hashtable</code>不是已经存在，就直接添加，否则直接将键值对添加到<code>table</code>中，返回<code>null</code></li></ul><p>在方法中可以看到，在遍历桶中元素时，是按照链表的方式遍历的。可以印证，<code>HashMap</code>的桶中可能为链表或者树。但<code>Hashtable</code>的桶中只可能是链表。</p><h4>5.3 remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//计算key在hashtable中的索引</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">//遍历entry，如果entry中存在key为参数key的键值对，就删除键值对，并返回键值对的value</span></span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不存在key为参数key的键值对，返回value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以总结出<code>Hashtable</code>的<code>remove</code>方法的总体思路：</p><ul><li>找到<code>key</code>在<code>table</code>中的索引，获取<code>key</code>所在位置的<code>entry</code></li><li>遍历<code>entry</code>，判断<code>key</code>是否已经存在</li><li>如果<code>key</code>存在，删除<code>key</code>映射的键值对，返回旧的<code>value</code></li><li>如果<code>key</code>在<code>hashtable</code>不存在，返回<code>null</code></li></ul><h4>5.4 rehash方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加hashtable的容量，为了更有效地存放和找到它的entry。</span></span><br><span class="line"><span class="comment"> * 当键值对的数量超过了临界值（capacity*load factor）这个方法自动调用</span></span><br><span class="line"><span class="comment"> * 长度变为原来的2倍+1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    <span class="comment">//记录旧桶的数组</span></span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//新的容量为旧的容量的2倍+1</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果新的容量大于容量的最大值MAX_ARRAY_SIZE </span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧容量为MAX_ARRAY_SIZE，容量不变，中断方法的执行</span></span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果旧容量不为MAX_ARRAY_SIZE，新容量变为MAX_ARRAY_SIZE</span></span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建新的数组，容量为新容量</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">    <span class="comment">//结构性修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//计算扩容的临界值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line">    <span class="comment">//将旧的数组中的键值对转移到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完代码，我们可以总结出<code>rehash</code>的总体思路为：</p><ul><li>新建变量新的容量，值为旧的容量的2倍+1</li><li>如果新的容量大于容量的最大值<code>MAX_ARRAY_SIZE</code><ul><li>如果旧容量为<code>MAX_ARRAY_SIZE</code>，容量不变，中断方法的执行</li><li>如果旧容量不为<code>MAX_ARRAY_SIZE</code>，新容量变为<code>MAX_ARRAY_SIZE</code></li></ul></li><li>创建新的数组，容量为新容量</li><li>将旧的数组中的键值对转移到新数组中</li></ul><p>这里可以看到，一般情况下，<code>HashMap</code>扩容后容量变为原来的两倍，而<code>Hashtable</code>扩容后容量变为原来的两倍加一。</p><p><strong><code>HashTable</code>的<code>rehash</code>方法相当于<code>HashMap</code>的<code>resize</code>方法。跟<code>HashMap</code>那种巧妙的<code>rehash</code>方式相比，<code>HashTable</code>的<code>rehash</code>过程需要对每个键值对都重新计算哈希值，而比起异或和与操作，取模是一个非常耗时的操作，所以这也是导致效率较低的原因之一。</strong></p><h2>六、遍历</h2><p>可以使用与<code>HashMap</code>一样的遍历方式，但是由于历史原因，多了<code>Enumeration</code>的方式。</p><h5>针对Enumeration，这里与iterator进行对比一下。</h5><h6>相同点</h6><ul><li><code>Iterator</code>和<code>Enumeration</code>都可以对某些容器进行遍历。</li><li><code>Iterator</code>和<code>Enumeration</code>都是接口。</li></ul><h6>不同点</h6><ul><li><code>Iterator</code>有对容器进行修改的方法。而<code>Enumeration</code>只能遍历。</li><li><code>Iterator</code>支持<code>fail-fast</code>，而<code>Enumeration</code>不支持。</li><li><code>Iterator</code>比<code>Enumeration</code>覆盖范围广，基本所有容器中都有<code>Iterator</code>迭代器，而只有<code>Vector</code>、<code>Hashtable</code>有<code>Enumeration</code>。</li><li><code>Enumeration</code>在JDK 1.0就已经存在了，而<code>Iterator</code>是JDK2.0新加的接口。</li></ul><h2>七、Hashtable与HashMap对比</h2><p><code>HashTable</code>的应用非常广泛，<code>HashMap</code>是新框架中用来代替<code>HashTable</code>的类，也就是说建议使用<code>HashMap</code>。</p><h4>下面着重比较一下二者的区别：</h4><h5>1.继承不同</h5><p><code>Hashtable</code>是基于陈旧的<code>Dictionary</code>类的，<code>HashMap</code>是java1.2引进的Map接口的一个实现。</p><h5>2.同步</h5><p><code>Hashtable</code> 中的方法是同步的，保证了<code>Hashtable</code>中的对象是线程安全的。</p><p><code>HashMap</code>中的方法在缺省情况下是非同步的,<code>HashMap</code>中的对象并不是线程安全的。在多线程并发的环境下，可以直接使用<code>Hashtable</code>，但是要使用<code>HashMap</code>的话就要自己增加同步处理了。</p><h5>3.效率</h5><p>单线程中, <code>HashMap</code>的效率大于<code>Hashtable</code>。因为同步的要求会影响执行的效率，所以如果你不需要线程安全的集合，<code>HashMap</code>是<code>Hashtable</code>的轻量级实现，这样可以避免由于同步带来的不必要的性能开销，从而提高效率。</p><h5>4.null值</h5><p><code>Hashtable</code>中，<code>key</code>和<code>value</code>都不允许出现<code>null</code>值，否则出现<code>NullPointerException</code>。</p><p>在<code>HashMap</code>中，<code>null</code>可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为<code>nul</code>l。当<code>get()</code>方法返回<code>null</code>值时，即可以表示 <code>HashMap</code>中没有该键，也可以表示该键所对应的值为<code>null</code>。因此，<strong>在<code>HashMap</code>中不能由<code>get()</code>方法来判断<code>HashMap</code>中是否存在某个键，而应该用<code>containsKey()</code>方法来判断</strong>。</p><h5>5.遍历方式</h5><p><code>Hashtable</code>、<code>HashMap</code>都使用了 <code>Iterator</code>。而由于历史原因，<code>Hashtable</code>可以使用<code>Enumeration</code>的方式。</p><h5>6.容量</h5><p><code>Hashtable</code>和<code>HashMap</code>它们两个内部实现方式的数组的初始大小和扩容的方式。</p><p><code>HashTable</code>中<code>hash</code>数组默认大小是11，增加的方式是 <code>old*2+1</code>。</p><p><code>HashMap</code>中<code>hash</code>数组的默认大小是16，而且一定是2的指数。</p><h2>八、总结</h2><p>无论什么时候有多个线程访问相同实例的可能时，就应该使用<code>Hashtable</code>，反之使用<code>HashMap</code>。非线程安全的数据结构能带来更好的性能。</p><p>如果在将来有一种可能—你需要按顺序获得键值对的方案时，<code>HashMap</code>是一个很好的选择，因为有<code>HashMap</code>的一个子类 <code>LinkedHashMap</code>。</p><p>所以如果你想可预测的按顺序迭代（默认按插入的顺序），你可以很方便用<code>LinkedHashMap</code>替换<code>HashMap</code>。反观要是使用的<code>Hashtable</code>就没那么简单了。</p><p>如果有多个线程访问<code>HashMap</code>，<code>Collections.synchronizedMap（）</code>可以代替，总的来说<code>HashMap</code>更灵活，或者直接用并发容器<code>ConcurrentHashMap</code>。</p><p>整理自：</p><ul><li><a href="http://blog.csdn.net/panweiwei1994/article/details/77428710" target="_blank" rel="noopener">http://blog.csdn.net/panweiwei1994/article/details/77428710</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52655042" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52655042</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap和LinkedHashMap遍历机制</title>
      <link href="/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/01/20/java-collection/8.HashMap%E5%92%8CLinkedHashMap%E9%81%8D%E5%8E%86%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>本篇单独讲一下HashMap和LinkedHashMap遍历方式。</p><a id="more"></a><h2>一、对HashMap和LinkedHashMap遍历的几种方法</h2><p>这里以<code>HashMap</code>为例，<code>LinkedHashMap</code>一样的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entryIterator = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; next = entryIterator.next();</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + next.getKey() + <span class="string">" value="</span> + next.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String key = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"key="</span> + key + <span class="string">" value="</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>强烈建议使用第一种 <code>EntrySet</code> 进行遍历。</strong></p><p>第一种可以把 <code>key value</code> 同时取出，第二种还得需要通过 <code>key</code> 取一次 <code>value</code>，效率较低, 第三种需要 <code>JDK1.8</code> 以上，通过外层遍历 <code>table</code>，内层遍历链表或红黑树。</p><p>我们知道，<code>HashMap</code>的输出顺序与元素的输入顺序无关，<code>LinkedHashMap</code>可以按照输入顺序输出，也可以根据读取元素的顺序输出。这一现象，已经在上一篇中展示出来了。</p><h2>二、HashMap的遍历机制</h2><p><code>HashMap</code> 提供了两个遍历访问其内部元素<code>Entry&lt;k,v&gt;</code>的接口：</p><ol><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>-------&gt;返回此映射所包含的映射关系的 Set 视图。</li><li><code>Set&lt;K&gt; keySet()</code>--------&gt;返回此映射中所包含的键的 Set 视图。</li></ol><blockquote><p>实际上，第二个接口表示的<code>Key</code>的顺序，和第一个接口返回的<code>Entry</code>顺序是对应的，也就是说：这两种接口对<code>HashMap</code>的元素遍历的顺序相相同的。  那么，<code>HashMap</code>遍历内部<code>Entry&lt;K,V&gt;</code> 的顺序是什么呢？ 搞清楚这个问题，先要知道其内部结构是怎样的。</p></blockquote><p><code>HashMap</code>在存储<code>Entry</code>对象的时候，是根据<code>Key</code>的<code>hash</code>值判定存储到<code>Entry[] table</code>数组的哪一个索引值表示的链表上。</p><p>对<code>HashMap</code>遍历<code>Entry</code>对象的顺序和<code>Entry</code>对象的存储顺序之间没有任何关系。</p><p><strong><code>HashMap</code>散列图、<code>Hashtable</code>散列表是按“有利于随机查找的散列(hash)的顺序”。并非按输入顺序。遍历时只能全部输出，而没有顺序</strong>。甚至可以<code>rehash()</code>重新散列，来获得更利于随机存取的内部顺序。</p><p>所以对<code>HashMap</code>的遍历，由内部的机制决定的，这个机制是只考虑利于快速存取，不考虑输入等顺序。</p><h2>三、LinkedHashMap 的遍历机制</h2><p><code>LinkedHashMap</code> 是<code>HashMap</code>的子类，它可以实现对容器内Entry的存储顺序和对Entry的遍历顺序保持一致。</p><p>为了实现这个功能，<strong><code>LinkedHashMap</code>内部使用了一个<code>Entry</code>类型的双向链表，用这个双向链表记录<code>Entry</code>的存储顺序</strong>。当需要对该<code>Map</code>进行遍历的时候，实际上是遍历的是这个双向链表。</p><p><code>LinkedHashMap</code>内部使用的<code>LinkedHashMap.Entry</code>类继承自<code>Map.Entry</code>类，在其基础上增加了<code>LinkedHashMap.Entry</code>类型的两个字段，用来引用该<code>Entry</code>在双向链表中的前面的<code>Entry</code>对象和后面的<code>Entry</code>对象。</p><p>它的内部会在<code>Map.Entry</code>类的基础上，增加两个<code>Entry</code>类型的引用：<code>before</code>，<code>after</code>。<code>LinkedHashMap</code>使用一个双向连表，将其内部所有的<code>Entry</code>串起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap linkedHashMap = <span class="keyword">new</span> LinkedHashMap();  </span><br><span class="line">linkedHashMap.put(<span class="string">"name"</span>,<span class="string">"louis"</span>);  </span><br><span class="line">linkedHashMap.put(<span class="string">"age"</span>,<span class="string">"24"</span>);  </span><br><span class="line">linkedHashMap.put(<span class="string">"sex"</span>,<span class="string">"male"</span>);</span><br></pre></td></tr></table></figure><p>对<code>LinkedHashMap</code>进行遍历的策略：</p><p><strong>从 <code>header.after</code> 指向的<code>Entry</code>对象开始，然后一直沿着此链表遍历下去，直到某个<code>entry.after == header</code> 为止，完成遍历。</strong></p><p>根据<code>Entry&lt;K,V&gt;</code>插入<code>LinkedHashMap</code>的顺序进行遍历的方式叫做：按插入顺序遍历。</p><p>另外，<code>LinkedHashMap</code>还支持一种遍历顺序，叫做：Get读取顺序。</p><p>如果<code>LinkedHashMap</code>的这个<code>Get</code>读取遍历顺序开启，那么，当我们在<code>LinkedHashMap</code>上调用<code>get(key)</code> 方法时，会导致内部<code>key</code>对应的<code>Entry</code>在双向链表中的位置移动到双向链表的最后。</p><h2>四、遍历机制的总结</h2><ol><li><p><code>HashMap</code>对元素的遍历顺序跟<code>Entry</code>插入的顺序无关，而<code>LinkedHashMap</code>对元素的遍历顺序可以跟<code>Entry&lt;K,V&gt;</code>插入的顺序保持一致：从双向。</p></li><li><p>当<code>LinkedHashMap</code>处于<code>Get</code>获取顺序遍历模式下，当执行<code>get()</code> 操作时，会将对应的<code>Entry&lt;k,v&gt;</code>移到遍历的最后位置。</p></li><li><p><code>LinkedHashMap</code>处于按插入顺序遍历的模式下，如果新插入的<code>&lt;key,value&gt;</code> 对应的<code>key</code>已经存在，对应的<code>Entry</code>在遍历顺序中的位置并不会改变。</p></li><li><p>除了遍历顺序外，其他特性<code>HashMap</code>和<code>LinkedHashMap</code>基本相同。</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedHashMap</title>
      <link href="/2019/01/20/java-collection/7.LinkedHashMap/"/>
      <url>/2019/01/20/java-collection/7.LinkedHashMap/</url>
      <content type="html"><![CDATA[<p>大多数情况下，只要不涉及线程安全问题， Map 基本都可以使用 HashMap ，不过 HashMap 有一个问题，就是迭代 HashMap 的顺序并不是 HashMap 放置的顺序，也就是无序。 HashMap 的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的 Map。</p><a id="more"></a><div class="tip">篇幅有点长，但是在理解了HashMap之后就比较简单了。</div><p>这个时候，<code>LinkedHashMap</code>就闪亮登场了，它虽然增加了时间和空间上的开销，但是可以解决有排序需求的场景。</p><p>它的底层是继承于 <code>HashMap</code> 实现的，由一个<strong>双向循环链表</strong>所构成。</p><p><code>LinkedHashMap</code> 的排序方式有两种：</p><ul><li>根据写入顺序排序。</li><li>根据访问顺序排序。</li></ul><p>其中根据访问顺序排序时，每次 <code>get</code> 都会将访问的值移动到链表末尾，这样重复操作就能得到一个按照访问顺序排序的链表。</p><h2>一、LinkedHashMap数据结构</h2><p><img src="http://bloghello.oursnail.cn/collection7-1.jpg" alt="image"></p><p><code>LinkedHashMap</code>是通过哈希表和双向循环链表实现的，它通过维护一个双向循环链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。</p><p>我们可以看出，遍历所有元素只需要从header开始遍历即可，一直遍历到下一个元素是header结束。</p><p>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说，假设你插入的键的顺序为1、2、3、4，后来再次插入2，迭代时的顺序还是1、2、3、4，而不会因为后来插入的2变成1、3、4、2。（但其实我们可以改变它的规则，使它变成1、3、4、2）</p><p><code>LinkedHashMap</code>的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希表部分继承了<code>HashMap</code>，拥有了<code>HashMap</code>那一套高效的操作，所以我们要看的就是<code>LinkedHashMap</code>中链表的部分，了解它是如何来维护有序性的。</p><h2>二、demo示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap插入数据，遍历输出无序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------HashMap插入数据--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iter = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap插入数据，遍历，默认以插入顺序为序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------LinkedHashMap插入数据,按照插入顺序进行排序--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    linkedHashMap.put(<span class="string">"apple"</span>, <span class="string">"a"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"watermelon"</span>, <span class="string">"b"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"banana"</span>, <span class="string">"c"</span>);</span><br><span class="line">    linkedHashMap.put(<span class="string">"peach"</span>, <span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = linkedHashMap.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap插入数据，设置accessOrder=true实现使得其遍历顺序按照访问的顺序输出，这里先用get方法来演示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"----------LinkedHashMap插入数据,accessOrder=true:按照访问顺序进行排序--------"</span>);</span><br><span class="line">    Map&lt;String, String&gt; linkedHashMap2 = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"apple"</span>, <span class="string">"aa"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"banana"</span>, <span class="string">"cc"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"peach"</span>, <span class="string">"dd"</span>);</span><br><span class="line"></span><br><span class="line">    linkedHashMap2.get(<span class="string">"banana"</span>);<span class="comment">//banana移动到了内部的链表末尾</span></span><br><span class="line">    linkedHashMap2.get(<span class="string">"apple"</span>);<span class="comment">//apple移动到了内部的链表末尾</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    Iterator iter2 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter2.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter2.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LinkedHashMap的put方法在accessOrder=true的情况下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">    linkedHashMap2.put(<span class="string">"watermelon"</span>, <span class="string">"bb"</span>);<span class="comment">//watermelon移动到了内部的链表末尾</span></span><br><span class="line">    linkedHashMap2.put(<span class="string">"stawbarrey"</span>, <span class="string">"ee"</span>);<span class="comment">//末尾插入新元素stawbarrey</span></span><br><span class="line">    linkedHashMap2.put(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//插入新的节点 null</span></span><br><span class="line">    Iterator iter3 = linkedHashMap2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter3.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter3.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----------HashMap插入数据--------</span><br><span class="line">banana=c</span><br><span class="line">apple=a</span><br><span class="line">peach=d</span><br><span class="line">watermelon=b</span><br><span class="line">----------LinkedHashMap插入数据,按照插入顺序进行排序--------</span><br><span class="line">apple=a</span><br><span class="line">watermelon=b</span><br><span class="line">banana=c</span><br><span class="line">peach=d</span><br><span class="line">----------LinkedHashMap插入数据,按照访问顺序进行排序--------</span><br><span class="line">watermelon=bb</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc<span class="comment">//banana到了末尾</span></span><br><span class="line">apple=aa<span class="comment">//apple到了末尾</span></span><br><span class="line">-----------</span><br><span class="line">peach=dd</span><br><span class="line">banana=cc</span><br><span class="line">apple=aa</span><br><span class="line">watermelon=bb<span class="comment">//watermelon到了链表末尾</span></span><br><span class="line">stawbarrey=ee<span class="comment">//新插入的放在末尾</span></span><br><span class="line"><span class="keyword">null</span>=<span class="keyword">null</span><span class="comment">//新插入的放在末尾</span></span><br></pre></td></tr></table></figure><h2>三、属性</h2><p><code>LinkedHashMap</code>可以认为是<code>HashMap+LinkedList</code>，即它既使用<code>HashMap</code>操作数据结构，又使用<code>LinkedList</code>维护插入元素的先后顺序</p><h5>3.1 继承关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，自然<code>LinkedHashMap</code>也就继承了<code>HashMap</code>中所有非private的方法。所以它已经从 <code>HashMap</code> 那里继承了与哈希表相关的操作了，那么在<code>LinkedHashMap</code>中，它可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p><h5>3.2 属性介绍</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap的链表节点继承了HashMap的节点，而且每个节点都包含了前指针和后指针，所以这里可以看出它是一个双向链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认为false。当为true时，表示链表中键值对的顺序与每个键的插入顺序一致，也就是说重复插入键，也会更新顺序</span></span><br><span class="line"><span class="comment">//简单来说，为false时，就是上面所指的1、2、3、4的情况；为true时，就是1、3、4、2的情况</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h2>五、构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是调用的 <code>HashMap</code> 的构造方法:</p><p><code>HashMap</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    <span class="comment">//HashMap 只是定义了改方法，具体实现交给了 LinkedHashMap</span></span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面有一个空的 <code>init()</code>，具体是由 <code>LinkedHashMap</code> 来实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也就是对 <code>header</code> 进行了初始化。</p><h2>六、添加元素</h2><p><img src="http://bloghello.oursnail.cn/collection7-2.jpg" alt="image"></p><p><code>LinkedHashMap</code>并没有重写任何<code>put</code>方法。但是其重写了构建新节点的<code>newNode()</code>方法.</p><p><code>newNode()</code> 会在<code>HashMap</code>的<code>putVal()</code> 方法里被调用，<code>putVal()</code> 方法会在批量插入数据<code>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</code> 或者插入单个数据<code>public V put(K key, V value)</code>时被调用。</p><p><code>LinkedHashMap</code>重写<code>了newNode()</code>,在每次构建新节点时，通过<code>linkNodeLast(p);</code>将新节点链接在内部双向链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在构建新节点时，构建的是`LinkedHashMap.Entry` 不再是`Node`.</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将新增的节点，连接在链表的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">//集合之前是空的</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//将新节点连接在链表的尾部</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及<code>HashMap</code>专门预留给<code>LinkedHashMap</code>的<code>afterNodeAccess()</code> 、<code>afterNodeInsertion()</code> 、<code>afterNodeRemoval()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>如果你没有注意到注释的解释的话，你可能会很奇怪为什么会有三个空方法，而且有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点之后，进行一些处理，它们在<code>LinkedHashMap</code>有各自的实现。<code>LinkedHashMap</code>正是通过重写这三个方法来保证链表的插入、删除的有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数，新节点插入之后回调,判断是否需要删除最老插入的节点。</span></span><br><span class="line"><span class="comment">//如果实现LruCache会用到这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">//LinkedHashMap 默认返回false 则不删除节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap 默认返回false 则不删除节点。 </span></span><br><span class="line"><span class="comment">//返回true 代表要删除最早的节点。</span></span><br><span class="line"><span class="comment">//通常构建一个LruCache会在达到Cache的上限是返回true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void afterNodeInsertion(boolean evict)</code>以及<code>boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code> 是构建LruCache需要的回调，在这可以忽略它们。</p><h2>七、删除元素</h2><p><code>LinkedHashMap</code>也没有重写<code>remove()</code> 方法，因为它的删除逻辑和<code>HashMap</code>并无区别。<br>但它重写了<code>afterNodeRemoval()</code> 这个回调方法。该方法会在<code>Node&lt;K,V&gt; removeNode(int hash, Object key</code>, <code>Object value</code>,<br><code>boolean matchValue, boolean movable)</code> 方法中回调，<code>removeNode()</code> 会在所有涉及到删除节点的方法中被调用，上文分析过，是删除节点操作的真正执行者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在删除节点e时，同步将e从双向链表上删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">//待删除节点 p 的前置后置节点都置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果前置节点是null，则现在的头结点应该是后置节点a</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则将前置节点b的后置节点指向a</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">//同理如果后置节点时null ，则尾节点应是b</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则更新后置节点a的前置节点为b</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>八、查询元素</h2><p><code>LinkedHashMap</code>重写了<code>get()</code>和<code>getOrDefault()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> defaultValue;</span><br><span class="line">   <span class="keyword">if</span> (accessOrder)</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">   <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>HashMap</code>中的实现,<code>LinkedHashMap</code>只是增加了在成员变量(构造函数时赋值)<code>accessOrder</code>为true的情况下，要去回调<code>void afterNodeAccess(Node&lt;K,V&gt; e)</code> 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>afterNodeAccess()</code> 函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;<span class="comment">//原尾节点</span></span><br><span class="line">    <span class="comment">//如果accessOrder 是true ，且原尾节点不等于e</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">//节点e强转成双向链表节点p</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        <span class="comment">//p现在是尾节点， 后置节点一定是null</span></span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果p的前置节点是null，则p以前是头结点，所以更新现在的头结点是p的后置节点a</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则更新p的前直接点b的后置节点为 a</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="comment">//如果p的后置节点不是null，则更新后置节点a的前置节点为b</span></span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果原本p的后置节点是null，则p就是尾节点。 此时 更新last的引用为 p的前置节点b</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>) <span class="comment">//原本尾节点是null  则，链表中就一个节点</span></span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则 更新 当前节点p的前置节点为 原尾节点last， last的后置节点是p</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点的引用赋值成p</span></span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="comment">//修改modCount。</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示(注意这个图，1和6也应该是连在一起的，因为是双向循环链表，所以视为一个小错误)：</p><p><img src="http://hashmap.oursnail.cn/afterNodeAccess.png" alt="image"></p><p>说明：从图中可以看到，结点3链接到了尾结点后面。</p><p><strong>值得注意的是，<code>afterNodeAccess()</code> 函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</strong></p><h2>九、判断元素是否存在</h2><p>它重写了该方法，相比<code>HashMap</code>的实现，更为高效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历一遍链表，去比较有没有value相等的节点，并返回</span></span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>HashMap</code>，是用两个<code>for</code>循环遍历，相对低效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>十、替换某个元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用dst替换src</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferLinks</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; src,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LinkedHashMap.Entry&lt;K,V&gt; dst)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = dst;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = dst;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://hashmap.oursnail.cn/transferLinks.png" alt="image"></p><h2>十二、总结</h2><p><code>LinkedHashMap</code>相对于<code>HashMap</code>的源码比，是很简单的。因为大树底下好乘凉。它继承了<code>HashMap</code>，仅重写了几个方法，以改变它迭代遍历时的顺序。这也是其与<code>HashMap</code>相比最大的不同。<br>在每次插入数据，或者访问、修改数据时，会增加节点、或调整链表的节点顺序。以决定迭代时输出的顺序。</p><ul><li><p><code>accessOrder</code>默认是<code>false</code>，则迭代时输出的顺序是插入节点的顺序。若为<code>true</code>，则输出的顺序是按照访问节点的顺序。为<code>true</code>时，可以在这基础之上构建一个<code>LruCache</code>.</p></li><li><p><code>LinkedHashMap</code>并没有重写任何put方法。但是其重写了构建新节点的<code>newNode()</code>方法.在每次构建新节点时，将新节点链接在内部双向链表的尾部</p></li><li><p><code>accessOrder=true</code>的模式下,在<code>afterNodeAccess()</code>函数中，会将当前被访问到的节点e，移动至内部的双向链表的尾部。值得注意的是，<code>afterNodeAccess()</code>函数中，会修改<code>modCount</code>,因此当你正在<code>accessOrder=true</code>的模式下,迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，也会导致fail-fast，因为迭代的顺序已经改变。</p></li><li><p><code>nextNode()</code> 就是迭代器里的<code>next()</code>方法 。该方法的实现可以看出，迭代<code>LinkedHashMap</code>，就是从内部维护的双链表的表头开始循环输出。</p></li><li><p>而双链表节点的顺序在<code>LinkedHashMap</code>的增、删、改、查时都会更新。以满足按照插入顺序输出，还是访问顺序输出。</p></li><li><p>它与<code>HashMap</code>比，还有一个小小的优化，重写了<code>containsValue()</code>方法，直接遍历内部链表去比对<code>value</code>值是否相等。</p></li></ul><p>整理自：</p><ul><li><a href="http://blog.csdn.net/zxt0601/article/details/77429150" target="_blank" rel="noopener">http://blog.csdn.net/zxt0601/article/details/77429150</a></li><li><a href="http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52659741" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52659741</a></li><li><a href="http://www.cnblogs.com/leesf456/p/5248868.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/5248868.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashSet</title>
      <link href="/2019/01/20/java-collection/6.HashSet/"/>
      <url>/2019/01/20/java-collection/6.HashSet/</url>
      <content type="html"><![CDATA[<p>HashSet 是一个不允许存储重复元素的集合，它是基于 HashMap 实现的， HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet  的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成。所以只要理解了 HashMap，HashSet 就水到渠成了。</p><a id="more"></a><h2>成员变量</h2><p>首先了解下<code>HashSet</code>的成员变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>发现主要就两个变量:</p><ul><li><code>map</code> ：用于存放最终数据的。</li><li><code>PRESENT</code> ：是所有写入<code>map</code>的<code>value</code>值。</li></ul><h2>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数很简单，利用了<code>HashMap</code>初始化了<code>map</code>。</p><h2>add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的就是这个 <code>add()</code> 方法。 可以看出它是将存放的对象当做了 <code>HashMap</code> 的健，<code>value</code> 都是相同的 <code>PRESENT</code> 。由于 <code>HashMap</code> 的 <code>key</code> 是不能重复的，所以每当有重复的值写入到 <code>HashSet</code> 时，<code>value</code> 会被覆盖，但 <code>key</code> 不会受到影响，这样就保证了 <code>HashSet</code> 中只能存放不重复的元素。</p><p>该方法如果添加的是在 <code>HashSet</code> 中不存在的，则返回 <code>true</code>；如果添加的元素已经存在，返回 <code>false</code>。其原因在于我们之前提到的关于 <code>HashMap</code> 的 <code>put</code> 方法。该方法在添加 <code>key</code> 不重复的键值对的时候，会返回 <code>null</code>。</p><h2>总结</h2><p><code>HashSet</code> 的原理比较简单，几乎全部借助于 <code>HashMap</code> 来实现的。</p><p>所以 <code>HashMap</code> 会出现的问题 <code>HashSet</code> 依然不能避免。</p><p>对于 <code>HashSet</code> 中保存的对象，请注意正确重写其 <code>equals</code> 和 <code>hashCode</code> 方法，以保证放入的对象的唯一性。这两个方法是比较重要的。</p>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap</title>
      <link href="/2019/01/20/java-collection/5.HashMap/"/>
      <url>/2019/01/20/java-collection/5.HashMap/</url>
      <content type="html"><![CDATA[<p>HashMap基本是面试必问的点，因为这个数据结构用的太频繁了，jdk1.8中的优化也是比较巧妙。有必要去深入探讨一下。但是涉及的内容比较多，这里只先探讨jdk8中HashMap的实现，至于jdk7中HashMap的死循环问题、红黑树的原理等都不会在本篇文章扩展到。其他的文章将会再去探讨整理。</p><a id="more"></a><p>本篇文章较长，高能预警。</p><h2>一、前言</h2><p>之前的<code>List</code>，讲了<code>ArrayList</code>、<code>LinkedList</code>，最后讲到了<code>CopyOnWriteArrayList</code>，就前两者而言，反映的是两种思想：</p><p>（1）<code>ArrayList</code>以数组形式实现，顺序插入、查找快，插入、删除较慢</p><p>（2）<code>LinkedList</code>以链表形式实现，顺序插入、查找较慢，插入、删除方便</p><p>那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是<code>HashMap</code>。</p><p><code>HashMap</code>是一种非常常见、方便和有用的集合，是一种键值对（K-V）形式的存储结构，在有了<code>HashCode</code>的基础后，下面将还是用图示的方式解读<code>HashMap</code>的实现原理。</p><p>Java为数据结构中的映射定义了一个接口<code>java.util.Map</code>，此接口主要有四个常用的实现类，分别是<code>HashMap</code>、<code>Hashtable</code>、<code>LinkedHashMap</code>和<code>TreeMap</code>，类继承关系如下图所示：</p><p><img src="http://hashmap.oursnail.cn/map%E6%8E%A5%E5%8F%A3.png" alt="image"></p><p>(1) <code>HashMap</code>：它根据键的<code>hashCode</code>值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 <code>HashMap</code>最多只允许一条记录的键为<code>null</code>，允许多条记录的值为<code>null</code>。<code>HashMap</code>非线程安全，即任一时刻可以有多个线程同时写<code>HashMap</code>，可能会导致数据的不一致。如果需要满足线程安全，可以用 <code>Collections</code>的<code>synchronizedMap</code>方法使<code>HashMap</code>具有线程安全的能力，或者使用<code>ConcurrentHashMap</code>。</p><p>(2) <code>Hashtable</code>：<code>Hashtable</code>是遗留类，很多映射的常用功能与<code>HashMap</code>类似，不同的是它承自<code>Dictionary</code>类，并且是线程安全的，任一时间只有一个线程能写<code>Hashtable</code>，并发性不如<code>ConcurrentHashMap</code>，因为<code>ConcurrentHashMap</code>引入了分段锁。<code>Hashtable</code>不建议在新代码中使用，不需要线程安全的场合可以用<code>HashMap</code>替换，需要线程安全的场合可以用<code>ConcurrentHashMap</code>替换。</p><p>(3) <code>LinkedHashMap</code>：<code>LinkedHashMap</code>是<code>HashMap</code>的一个子类，保存了记录的插入顺序，在用<code>Iterator</code>遍历<code>LinkedHashMap</code>时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>(4) <code>TreeMap</code>：<code>TreeMap</code>实现<code>SortedMap</code>接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用<code>Iterator</code>遍历<code>TreeMap</code>时，得到的记录是排过序的。如果使用排序的映射，建议使用<code>TreeMap</code>。在使用<code>TreeMap</code>时，key必须实现<code>Comparable</code>接口或者在构造<code>TreeMap</code>传入自定义的<code>Comparator</code>，否则会在运行时抛出<code>java.lang.ClassCastException</code>类型的异常。</p><p>对于上述四种<code>Map</code>类型的类，要求映射中的<code>key</code>是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，<code>Map</code>对象很可能就定位不到映射的位置了。</p><h2>二、HashMap的结构</h2><p>其中哈希表是一个数组，<strong>我们经常把数组中的每一个节点称为一个桶</strong>，哈希表中的每个节点都用来存储一个键值对。</p><p>在插入元素时，如果发生冲突（即多个键值对映射到同一个桶上）的话，就会通过链表的形式来解决冲突。</p><p>因为<strong>一个桶上可能存在多个键值对</strong>，所以在查找的时候，会先通过<code>key</code>的哈希值先定位到桶，再遍历桶上的所有键值对，找出<code>key</code>相等的键值对，从而来获取<code>value</code>。</p><p><img src="http://bloghello.oursnail.cn/HashMap%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image"></p><p>如图所示，<code>HashMap</code> 底层是基于数组和链表实现的。其中有两个重要的参数：</p><ul><li>容量</li><li>负载因子</li></ul><p>容量的默认大小是 16，负载因子是 0.75，当 <code>HashMap</code> 的 size &gt; 16*0.75 时就会发生扩容(容量和负载因子都可以自由调整)。</p><h2>三、继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p><code>HashMap</code>继承自<code>AbstractMap</code>，<code>AbstractMap</code>是<code>Map</code>接口的骨干实现，<code>AbstractMap</code>中实现了<code>Map</code>中最重要最常用和方法，这样<code>HashMap</code>继承<code>AbstractMap</code>就不需要实现<code>Map</code>的所有方法，让<code>HashMap</code>减少了大量的工作。</p></blockquote><h2>四、属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的初始容量为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//最大的容量上限为2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认的负载因子为0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//变成树型结构的临界值为8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//恢复链式结构的临界值为6</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表的最小树形化容量</span></span><br><span class="line"><span class="comment"> * 当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span></span><br><span class="line"><span class="comment"> * 否则桶内元素太多时会扩容，而不是树形化</span></span><br><span class="line"><span class="comment"> * 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//哈希表中键值对的个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//哈希表被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">//它是通过capacity*load factor计算出来的，当size到达这个值时，就会进行扩容操作</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h5>4.1 几个属性的详细说明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>首先，<code>Node[] table</code>的初始化长度<code>length</code>(<strong>默认值是16</strong>)，<code>Load factor</code>为负载因子(<strong>默认值是0.75</strong>)，<code>threshold</code>是<code>HashMap</code>所能容纳的最大数据量的<code>Node</code>(键值对)个数。<code>threshold = length * Load factor</code>。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>结合负载因子的定义公式可知，<code>threshold</code>就是在此<code>Load factor</code>和<code>length</code>(数组长度)对应下允许的最大元素数目，超过这个数目就重新<code>resize</code>(扩容)，<strong>扩容后的<code>HashMap</code>容量是之前容量的两倍（为什么是两倍下文会说明）</strong>。</p><div class="tip">默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子`Load factor`的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子`loadFactor`的值，这个值可以大于1。</div><p><code>size</code>这个字段其实很好理解，就是<code>HashMap</code>中<strong>实际存在的键值对数量</strong>。<strong>注意<code>size</code>和<code>table</code>的长度<code>length</code>、容纳最大键值对数量<code>threshold</code>的区别</strong>。</p><p>而<code>modCount</code>字段主要用来记录<code>HashMap</code>内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，<strong>内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个<code>key</code>对应的<code>value</code>值被覆盖不属于结构变化。</strong></p><p><strong>在<code>HashMap</code>中，哈希桶数组<code>table</code>的长度<code>length</code>大小必须为2的n次方(一定是合数)</strong>，这是一种非常规的设计，因为常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考 <a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a> ，<code>Hashtable</code>初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。<strong><code>HashMap</code>采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，<code>HashMap</code>定位哈希桶索引位置时，也加入了高位参与运算的过程。下文会说明。</strong></p><p>这里存在一个问题，即使负载因子和<code>Hash</code>算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响<code>HashMap</code>的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。<strong>而当链表长度太长（默认超过8）时，并且链表的长度超过64时，链表就转换为红黑树</strong>，利用红黑树快速增删改查的特点提高<code>HashMap</code>的性能，其中会用到红黑树的插入、删除、查找等算法。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E7%BB%93%E6%9E%84.png" alt="image"></p><p>这里着重提一下<code>MIN_TREEIFY_CAPACITY</code>字段，容易与<code>TREEIFY_THRESHOLD</code>打架，<code>TREEIFY_THRESHOLD</code>是指桶中元素达到8个，就将其本来的链表结构改为红黑树，提高查询的效率。<code>MIN_TREEIFY_CAPACITY</code>是指最小树化的哈希表元素个数，也就是说，小于这个值，就算你(数组)桶里的元素数量大于8了，还是要用链表存储，只有同时满足：表中数据容量已经扩容到<code>MIN_TREEIFY_CAPACITY</code>这个长度，并且桶里的数据个数达到8个的时候，才会将该桶里的结构进行树化。注意扩容是数组的复制。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E7%BB%93%E6%9E%842.png" alt="image"></p><h5>4.2 Node结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Node</code>是<code>HashMap</code>的一个内部类，实现了<code>Map.Entry</code>接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个<code>Node</code>对象。</p><p>例如程序执行下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</span><br></pre></td></tr></table></figure><p>系统将调用&quot;美团&quot;这个<code>key</code>的<code>hashCode()</code>方法得到其<code>hashCode</code>值（该方法适用于每个<code>Java</code>对象）。</p><p>然后再通过<code>Hash</code>算法来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了<code>Hash</code>碰撞。</p><p>当然<code>Hash</code>算法计算结果越分散均匀，<code>Hash</code>碰撞的概率就越小，<code>map</code>的存取效率就会越高。</p><p>如果哈希桶数组很大，即使较差的<code>Hash</code>算法也会比较分散，如果哈希桶数组数组很小，即使好的<code>Hash</code>算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少<code>Hash</code>碰撞。</p><p><strong>那么通过什么方式来控制<code>map</code>使得<code>Hash</code>碰撞的概率又小，哈希桶数组（<code>Node[] table</code>）占用空间又少呢？答案就是好的<code>Hash</code>算法(5.4节)和扩容机制(5.5节)。下文会讲到。</strong></p><h2>五、方法</h2><h5>5.1 get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get方法主要调用的是getNode方法，所以重点要看getNode方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空 &amp;&amp; key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//是否直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//判断是否有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前的桶是采用红黑树处理冲突，则调用红黑树的get方法去获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该key</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现步骤大致如下：</p><ul><li>通过<code>hash</code>值获取该key映射到的桶。</li><li>桶上的<code>key</code>就是要查找的<code>key</code>，则直接命中。</li><li>桶上的<code>key</code>不是要查找的<code>key</code>，则查看后续节点：</li><li>如果后续节点是树节点，通过调用树的方法查找该<code>key</code>。</li><li>如果后续节点是链式节点，则通过循环遍历链查找该<code>key</code>。</li></ul><h5>5.2 put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法的具体实现也是在putVal方法中，所以我们重点看下面的putVal方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果哈希表为空，则先创建一个哈希表</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果当前桶没有碰撞冲突，则直接把键值对插入，完事</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果桶上节点的key与当前key重复，那你就是我要找的节点了</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果是采用红黑树的方式处理冲突，则通过红黑树的putTreeVal方法去插入这个键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//否则就是传统的链式结构</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//采用循环遍历的方式，判断链中是否有重复的key</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//到了链尾还没找到重复的key，则说明HashMap没有包含该键</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                    <span class="comment">//创建一个新节点插入到尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果链的长度大于TREEIFY_THRESHOLD这个临界值，则把链变为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//找到了重复的key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里表示在上面的操作中找到了重复的键，所以这里把该键的值替换为新值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断是否需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code>方法比较复杂，实现步骤大致如下：</p><ul><li>先通过<code>hash</code>值计算出<code>key</code>映射到哪个桶。</li><li>如果桶上没有碰撞冲突，则直接插入。</li><li>如果出现碰撞冲突了，则需要处理冲突：<ul><li>如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。</li><li>否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红黑树。</li></ul></li><li>如果桶中存在重复的键，则为该键替换新值。</li><li>如果<code>size</code>大于阈值，则进行扩容。</li></ul><p><img src="http://hashmap.oursnail.cn/hashmap%E6%89%A9%E5%AE%B9.jpg" alt="image"></p><h5>5.3 remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove方法的具体实现在removeNode方法中，所以我们重点看下面的removeNode方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//如果当前key映射到的桶不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//如果桶上的节点就是要找的key，则直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是以红黑树处理冲突，则构建一个树节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//如果是以链式的方式处理冲突，则通过遍历链表来寻找节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比对找到的key的value跟要删除的是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//通过调用红黑树的方法来删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//使用链表的操作来删除节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>5.4 hash方法(确定哈希桶数组索引位置)</h5><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过<code>HashMap</code>的数据结构是数组和链表的结合，所以我们当然希望这个<code>HashMap</code>里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用<code>hash</code>算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。<code>HashMap</code>定位数组索引位置，直接决定了<code>hash</code>方法的离散性能。</p><p>注意<code>get</code>方法和<code>put</code>方法源码中都需要先计算<code>key</code>映射到哪个桶上，然后才进行之后的操作，计算的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>上面代码中的n指的是哈希表的大小，<code>hash</code>指的是<code>key</code>的哈希值，<code>hash</code>是通过下面这个方法计算出来的，采用了二次哈希的方式，其中<code>key的hashCode</code>方法是一个<code>native</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于任意给定的对象，只要它的<code>hashCode()</code>返回值相同，那么程序调用方法一所计算得到的<code>Hash</code>码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在<code>HashMap</code>中是这样做的：调用方法二来计算该对象应该保存在<code>table</code>数组的哪个索引处。</p><p>这个方法非常巧妙，它通过<code>h &amp; (table.length -1)</code>来得到该对象的保存位，而<code>HashMap</code>底层数组的长度总是2的n次方，这是<code>HashMap</code>在速度上的优化。当<code>length</code>总是2的n次方时，<code>h&amp; (length-1)</code>运算等价于对<code>length</code>取模，也就是<code>h%length</code>，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在数组<code>table</code>的<code>length</code>比较小的时候，也能保证考虑到高低<code>Bit</code>都参与到<code>Hash</code>的计算中，同时不会有太大的开销。</p><p><img src="http://hashmap.oursnail.cn/hashmap%E6%89%A9%E5%AE%B92.jpg" alt="image"></p><blockquote><p>总结就是：由于在计算中位运算比取模运算效率高的多，所以 HashMap 规定数组的长度为 2^n 。这样用 2^n - 1 做位运算与取模效果一致，并且效率还要高出许多。这样回答了上文中：好的Hash算法到底是什么。</p></blockquote><h5>5.5 resize方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前容量超过最大容量，则无法进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没超过最大值则扩为原来的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的resize阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历旧哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果桶上只有一个键值对，则直接插入</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是通过红黑树来处理冲突的，则调用相关方法把树分离开</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果采用链式处理冲突</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//通过上面讲的方法来计算节点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashMap</code>在进行扩容时，使用的<code>rehash</code>方式非常巧妙，因为每次扩容都是翻倍，与原来计算<code>（n-1）&amp;hash</code>的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</p><p>例如，原来的容量为32，那么应该拿<code>hash</code>跟31（0x11111）做与操作；在扩容扩到了64的容量之后，应该拿<code>hash</code>跟63（0x111111）做与操作。新容量跟原来相比只是多了一个bit位，假设原来的位置在23，那么当新增的那个bit位的计算结果为0时，那么该节点还是在23；相反，计算结果为1时，则该节点会被分配到23+31的桶上。</p><p><strong>这样做的好处：正是因为这样巧妙的<code>rehash</code>方式，保证了<code>rehash</code>之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了<code>rehash</code>之后不会出现更严重的冲突。回答了上文中好的扩容机制。</strong></p><h2>六、总结</h2><ul><li><code>HashMap</code>的结构底层是一个数组，每个数组元素是一个桶，后面可能会连着一串因为碰撞而聚在一起的(key,value)节点，以链表的形式或者树的形式挂着</li><li>按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表的效率降低至O（n），而通过红黑树的方式，可以把效率改进至<code>O（logn）</code>。相比链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。</li><li><code>threshold</code>是数组长度扩容的临界值</li><li><code>modCount</code>字段主要用来记录HashMap内部结构发生变化的次数，这里结构变化必须是新的值塞进来或者某个值删除这种类型，而不是仅仅是覆盖</li><li>只有同时满足：表中数据容量已经扩容到<code>MIN_TREEIFY_CAPACITY</code>这个长度，并且桶里的数据个数达到8个的时候，才会将该桶里的结构进行树化。</li><li><strong>好的hash算法</strong>：由于在计算中位运算比取模运算效率高的多，所以<code>HashMap</code>规定数组的长度为 2^n 。这样用 <code>2^n - 1</code> 与 <code>hash</code> 做位运算与取模效果一致，并且效率还要高出许多。</li><li><strong>好的扩容机制</strong>：因为每次扩容都是翻倍，与原来计算<code>（n-1）&amp;hash</code>的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。这样做的好处：正是因为这样巧妙的rehash方式，保证了rehash之后每个桶上的节点数必定小于等于原来桶上的节点数，即保证了rehash之后不会出现更严重的冲突。</li><li>还有就是要记住<code>put</code>的过程。</li></ul><p>整理自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></li><li><a href="http://blog.csdn.net/u013124587/article/details/52649867" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52649867</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hashcode/Equals</title>
      <link href="/2019/01/20/java-collection/4.hashcode%E5%92%8Cequals/"/>
      <url>/2019/01/20/java-collection/4.hashcode%E5%92%8Cequals/</url>
      <content type="html"><![CDATA[<p>hashcode涉及到集合HashMap等集合，此篇侧重于了解hashcode和equals方法的作用的原理。有助于下一篇HashMap的理解。</p><a id="more"></a><h2>一、Hash是什么</h2><p><code>Hash</code>是散列的意思，就是把任意长度的输入，通过散列算法变换成固定长度的输出，该输出就是散列值。这个玩意还可以做加密。</p><ul><li>不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞。</li><li>如果两个<code>Hash</code>值不同（前提是同一<code>Hash</code>算法），那么这两个<code>Hash</code>值对应的原始输入必定不同</li></ul><h2>二、什么是hashcode</h2><p><code>HashCode</code>的存在主要是为了查找的快捷性，<code>HashCode</code>是用来在散列存储结构中确定对象的存储地址的。</p><p>如果两个对象的<code>HashCode</code>相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置。</p><p>如果对象的<code>equals</code>方法被重写，那么对象的<code>HashCode</code>方法也尽量重写。为什么呢？下文会说。</p><h2>三、HashCode有什么用</h2><p>比方说<code>Set</code>里面已经有1000个元素了，那么第1001个元素进来的时候，最多可能调用1000次<code>equals</code>方法，如果<code>equals</code>方法写得复杂，对比的东西特别多，那么效率会大大降低。</p><p>使用<code>HashCode</code>就不一样了，比方说<code>HashSet</code>，底层是基于<code>HashMap</code>实现的，先通过<code>HashCode</code>取一个模，这样一下子就固定到某个位置了，如果这个位置上没有元素，那么就可以肯定<code>HashSet</code>中必定没有和新添加的元素<code>equals</code>的元素，就可以直接存放了，都不需要比较；</p><p>如果这个位置上有元素了，逐一比较，比较的时候先比较<code>HashCode</code>，<code>HashCode</code>都不同接下去都不用比了，肯定不一样，<code>HashCode</code>相等，再<code>equals</code>比较，没有相同的元素就存，有相同的元素就不存。</p><p>如果原来的<code>Set</code>里面有相同的元素，只要<code>HashCode</code>的生成方式定义得好（不重复），不管<code>Set</code>里面原来有多少元素，只需要执行一次的<code>equals</code>就可以了。这样一来，实际调用<code>equals</code>方法的次数大大降低，提高了效率。</p><div class="tip">当俩个对象的`hashCode`值相同的时候，`Hashset`会将对象保存在同一个位置，但是他们`equals`返回`false`，所以实际上这个位置采用链式结构来保存多个对象。 </div><p><img src="http://bloghello.oursnail.cn/%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%85%A5%E6%95%A3%E5%88%97%E9%9B%86%E5%90%88%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="image"></p><h2>四、为什么重写Object的equals()方法尽量要重写Object的hashCode()方法</h2><p>面临问题：若两个对象<code>equals</code>相等，但由于不在一个区间，因为<code>hashCode</code>的值在重写之前是对内存地址计算得出，所以根本没有机会进行比较，会被认为是不同的对象(这就是为什么还要重写<code>hashcode</code>方法了)。所以<code>Java</code>对于<code>eqauls</code>方法和<code>hashCode</code>方法是这样规定的：</p><blockquote><p>1 如果两个对象相同(<code>equals</code>为<code>true</code>)，那么它们的<code>hashCode</code>值一定要相同。也告诉我们重写<code>equals</code>方法，一定要重写<code>hashCode</code>方法，也就是说<code>hashCode</code>值要和类中的成员变量挂上钩，对象相同–&gt;成员变量相同—-&gt;<code>hashCode</code>值一定相同。</p></blockquote><blockquote><p>2 如果两个对象的<code>hashCode</code>相同(只是映射到同一个位置而已)，它们并不一定相同，这里的对象相同指的是用<code>eqauls</code>方法比较。</p></blockquote><p>简单来说，如果只重写<code>equals</code>方法而不重写<code>hashcode</code>方法，会导致重复元素的产生。具体通过下面的例子进行说明。</p><h2>五、举例</h2><h5>6.1 Student类</h5><p>很简单，定义了<code>id</code>和<code>name</code>两个字段，无参和有参构造函数，<code>toString</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">get(),set()略...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5>6.2 main方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"hh"</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"hh"</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">"gg"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashSet&lt;Student&gt; set = <span class="keyword">new</span> HashSet&lt;Student&gt;(); </span><br><span class="line">set.add(student1);</span><br><span class="line">set.add(student2);</span><br><span class="line">set.add(student3);</span><br><span class="line">set.add(student1);<span class="comment">//重复添加了student1</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"set集合容量为:  "</span>+set.size());</span><br><span class="line"></span><br><span class="line">Iterator&lt;Student&gt; iterator = set.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        Student student = iterator.next();  </span><br><span class="line">        System.out.println(student+<span class="string">"---"</span>+student.hashCode());  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  3</span><br><span class="line">Student [id=1, name=hh]---1735600054</span><br><span class="line">Student [id=1, name=hh]---356573597</span><br><span class="line">Student [id=2, name=gg]---21685669</span><br></pre></td></tr></table></figure><p>我们可以看到，只要是new的对象，他们的<code>hashcode</code>是不一样的。所以，就会认为他们是不一样的对象。所以，集合里面数量为3.</p><h5>6.3 只重写equals()方法，而不重写HashCode()方法</h5><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  <span class="number">3</span></span><br><span class="line">Student [id=<span class="number">2</span>, name=gg]---<span class="number">2018699554</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">366712642</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">1829164700</span></span><br></pre></td></tr></table></figure><p>结论：覆盖<code>equals</code>（<code>Object obj</code>）但不覆盖<code>hashCode()</code>,导致数据不唯一性。</p><p>在这里，其实我们可以看到，<code>student1</code>和<code>student2</code>其实是一个对象，但是由于都是new并且没有重写<code>hashcode</code>导致他们变成了两个不一样的对象。</p><p>分析：</p><blockquote><p>（1）当执行<code>set.add(student1)</code>时，集合为空，直接存入集合；</p></blockquote><blockquote><p>（2）当执行<code>set.add(student2)</code>时，首先判断该对象（<code>student2</code>）的<code>hashCode</code>值所在的存储区域是否有相同的<code>hashCode</code>，因为没有覆盖<code>hashCode</code>方法，所以jdk使用默认<code>Object</code>的<code>hashCode</code>方法，返回内存地址转换后的整数，因为不同对象的地址值不同，所以这里不存在与<code>student2</code>相同<code>hashCode</code>值的对象，因此<code>jdk</code>默认不同<code>hashCode</code>值，<code>equals</code>一定返回<code>false</code>，所以直接存入集合。</p></blockquote><blockquote><p>（3）当执行<code>set.add(student3)</code>时,与2同理。</p></blockquote><blockquote><p>（4）当最后执行<code>set.add(student1)</code>时，因为<code>student1</code>已经存入集合，同一对象返回的<code>hashCode</code>值是一样的，继续判断<code>equals</code>是否返回true，因为是同一对象所以返回<code>true</code>。此时jdk认为该对象已经存在于集合中，所以舍弃。</p></blockquote><h5>6.4 只重写HashCode()方法，equals()方法直接返回false</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  <span class="number">3</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">4320</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">4320</span></span><br><span class="line">Student [id=<span class="number">2</span>, name=gg]---<span class="number">4319</span></span><br></pre></td></tr></table></figure><p>按照上面的分析，可能会觉得里面应该装4个，因为两次add的student1，虽然他们的<code>hashcode</code>一样，但是<code>equals</code>直接返回<code>false</code>，那么应该判定为两个不同的对象。但是结果确跟我们预想的不一样。</p><p>分析：</p><blockquote><p>首先<code>student1</code>和<code>student2</code>的对象比较<code>hashCode</code>，因为重写了<code>HashCode</code>方法，所以<code>hashcode</code>相等,然后比较他们两的<code>equals</code>方法，因为<code>equals</code>方法始终返回<code>false</code>,所以<code>student1</code>和<code>student2</code>也是不相等的，所以<code>student2</code>也被放进了<code>set</code></p></blockquote><blockquote><p>首先<code>student1(student2)</code>和<code>student3</code>的对象比较<code>hashCode</code>，不相等，所以<code>student3</code>放进<code>set</code>中</p></blockquote><blockquote><p>最后再看最后重复添加的<code>student1</code>,与第一个<code>student1</code>的<code>hashCode</code>是相等的，在比较<code>equals</code>方法，因为<code>equals</code>返回<code>false</code>,所以<code>student1</code>和<code>student4</code>不相等;同样，<code>student2</code>和<code>student4</code>也是不相等的;<code>student3</code>和<code>student4</code>的<code>hashcode</code>都不相等，所以肯定不相等的，所以最后一个重复的<code>student1</code>应该可以放到<code>set</code>集合中，那么结果应该是<code>size:4</code>,那为什么会是3呢？</p></blockquote><p>这时候我们就需要查看<code>HashSet</code>的源码了，下面是<code>HashSet</code>中的<code>add</code>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到其实<code>HashSet</code>是基于<code>HashMap</code>实现的，我们在点击<code>HashMap</code>的<code>put</code>方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是判断<code>hashCode</code>是否相等，不相等的话，直接跳过，相等的话，<strong>然后再来比较这两个对象是否相等或者这两个对象的<code>equals</code>方法，因为是进行的或操作，所以只要有一个成立即可</strong>，那这里我们就可以解释了，其实上面的那个集合的大小是3,因为最后的一个r1没有放进去，以为r1==r1返回true的，所以没有放进去了。所以集合的大小是3，如果我们将<code>hashCode</code>方法设置成始终返回false的话，这个集合就是4了。</p><h5>6.5 同时重写</h5><p>我的写法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    result = result * <span class="number">31</span> + name.hashCode();</span><br><span class="line">    result = result * <span class="number">31</span> + id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Student o = (Student)obj;</span><br><span class="line">    <span class="keyword">return</span> o.name.equals(name) &amp;&amp; o.id == id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  2</span><br><span class="line">Student [id=2, name=gg]---118515</span><br><span class="line">Student [id=1, name=hh]---119506</span><br></pre></td></tr></table></figure><p>达到我们预期的效果。</p><h2>六、内存泄露</h2><p>我们上面实验了重写<code>equals</code>和<code>hashcode</code>方法，执行<code>main</code>，执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  <span class="number">2</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">4320</span></span><br><span class="line">Student [id=<span class="number">2</span>, name=gg]---<span class="number">4319</span></span><br></pre></td></tr></table></figure><p>将<code>main</code>方法改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"hh"</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"hh"</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">"gg"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashSet&lt;Student&gt; set = <span class="keyword">new</span> HashSet&lt;Student&gt;(); </span><br><span class="line">set.add(student1);</span><br><span class="line">set.add(student2);</span><br><span class="line">set.add(student3);</span><br><span class="line">set.add(student1);<span class="comment">//重复添加了student1</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"set集合容量为:  "</span>+set.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//------新增的开始-------</span></span><br><span class="line">student3.setId(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">set.remove(student3);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"set集合容量为:  "</span>+set.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//------新增的结束-------</span></span><br><span class="line"></span><br><span class="line">Iterator&lt;Student&gt; iterator = set.iterator();  </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;  </span><br><span class="line">        Student student = iterator.next();  </span><br><span class="line">        System.out.println(student+<span class="string">"---"</span>+student.hashCode());  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set集合容量为:  <span class="number">2</span></span><br><span class="line">set集合容量为:  <span class="number">2</span></span><br><span class="line">Student [id=<span class="number">1</span>, name=hh]---<span class="number">4320</span></span><br><span class="line">Student [id=<span class="number">11</span>, name=gg]---<span class="number">4598</span></span><br></pre></td></tr></table></figure><p>我们调用了<code>remove</code>删除<code>student3</code>对象，以为删除了<code>student3</code>,但事实上并没有删除，这就叫做内存泄露，就是不用的对象但是他还在内存中。所以我们多次这样操作之后，内存就爆了。</p><p>原因：</p><p><strong>在调用<code>remove</code>方法的时候，会先使用对象的<code>hashCode</code>值去找到这个对象，然后进行删除，这种问题就是因为我们在修改了对象<code>student3</code>的<code>id</code>属性的值，又因为<code>RectObject</code>对象的<code>hashCode</code>方法中有<code>id</code>值参与运算,所以<code>student3</code>对象的<code>hashCode</code>就发生改变了，所以<code>remove</code>方法中并没有找到student3了，所以删除失败</strong>。即<code>student3</code>的<code>hashCode</code>变了，但是他存储的位置没有更新，仍然在原来的位置上，所以当我们用他的新的<code>hashCode</code>去找肯定是找不到了。</p><p>总结：</p><p>上面的这个内存泄露告诉我一个信息：<strong>如果我们将对象的属性值参与了<code>hashCode</code>的运算中，在进行删除的时候，就不能对其属性值进行修改，否则会出现严重的问题</strong>。</p><h2>七、总结</h2><ul><li><code>hashCode</code>是为了提高在散列结构存储中查找的效率，在线性表中没有作用。</li><li><code>equals</code>和<code>hashCode</code>需要同时覆盖。</li><li>若两个对象<code>equals</code>返回true，则<code>hashCode</code>有必要也返回相同的int数。</li><li>若两个对象<code>equals</code>返回false，则<code>hashCode</code>不一定返回不同的int数,但为不相等的对象生成不同<code>hashCode</code>值可以提高哈希表的性能。</li><li>若两个对象<code>hashCode</code>返回相同int数，则<code>equals</code>不一定返回true。</li><li>同一对象在执行期间若已经存储在集合中，则不能修改影响<code>hashCode</code>值的相关信息，否则会导致内存泄露问题。</li></ul><p>整理自：</p><ul><li><a href="http://blog.csdn.net/haobaworenle/article/details/53819838" target="_blank" rel="noopener">http://blog.csdn.net/haobaworenle/article/details/53819838</a></li><li><a href="http://www.cnblogs.com/xrq730/p/4842028.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4842028.html</a></li><li><a href="http://blog.csdn.net/qq_21688757/article/details/53067814" target="_blank" rel="noopener">http://blog.csdn.net/qq_21688757/article/details/53067814</a></li><li><a href="http://blog.csdn.net/fyxxq/article/details/42066843" target="_blank" rel="noopener">http://blog.csdn.net/fyxxq/article/details/42066843</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CopyOnWriteArrayList</title>
      <link href="/2019/01/20/java-collection/3.CopyOnWriteArrayList/"/>
      <url>/2019/01/20/java-collection/3.CopyOnWriteArrayList/</url>
      <content type="html"><![CDATA[<p>CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p><a id="more"></a><p><code>CopyOnWriteArrayList</code>是一个写时复制的容器，采用了读写分离的思想。通俗点来讲，在对容器进行写操作时，不直接修改当前容器，而是先对当前容器进行拷贝得到一个副本，然后对副本进行写操作，最后再将原容器的引用指向拷贝出来的副本。这样做的好处就是可以对容器进行并发读而不用进行加锁。</p><h2>一、类的继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>含义不需要再赘述了。</p><h2>二、类的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 用于在对数组产生写操作的方法加锁. */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 底层的存储结构. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 反射机制. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** lock域的内存偏移量.是通过反射拿到的 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> lockOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = CopyOnWriteArrayList.class;</span><br><span class="line">        lockOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"lock"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、数组末尾添加一个元素</h2><p><img src="http://bloghello.oursnail.cn/CopyOnWriteArrayList%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 元素数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将要添加的元素放到副本数组的末尾去</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本原理很简单，就是对当前数组加锁，内部复制一个新数组，处理完毕，修改引用即可，达到最终一致的效果。</p><h2>四、如果没有这个元素则添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）。<strong>如何可以保证多线程环境下不会重复添加元素</strong>？</p><p>答案：<strong>通过快照数组和当前数组进行对比来确定是否一致，确保添加元素的线程安全</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数组</span></span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123; <span class="comment">// 快照不等于当前数组，对数组进行了修改</span></span><br><span class="line">            <span class="comment">// 取较小者</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++) <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) <span class="comment">// 当前数组的元素与快照的元素不相等并且e与当前元素相等</span></span><br><span class="line">                    <span class="comment">// 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在</span></span><br><span class="line">                    <span class="comment">// 返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>) <span class="comment">// 在当前数组中找到e元素</span></span><br><span class="line">                    <span class="comment">// 返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对数组len索引的元素赋值为e</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 设置数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的流程如下：</p><ol><li>获取锁，获取当前数组为<code>current</code>，<code>current</code>长度为<code>len</code>，判断数组之前的快照<code>snapshot</code>是否等于当前数组<code>current</code>，若不相等，则进入步骤2；否则，进入步骤3</li><li>不相等，表示在<code>snapshot</code>与<code>current</code>之间，对数组进行了修改，直接返回<code>false</code>结束;</li><li>说明当前数组等于快照数组，说明数组没有被改变。在当前数组中索引指定元素，若能够找到，说明已经存在此元素，直接返回<code>false</code>结束；否则进入4</li><li>说明没有当前要插入的元素，通过数组复制的方式添加到末尾</li><li>无论如何，都要释放锁</li></ol><h2>五、获取指定索引的元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过写时复制的方式，<code>CopyOnWriteArrayList</code> 的 <code>get</code> 方法不用加锁也可以保证线程安全，所以 <code>CopyOnWriteArrayList</code> 并发读的效率是非常高的，它是直接通过数组下标获取元素的。</p></blockquote><h2>六、总结</h2><h5>简单而言要记住它的三个特点：</h5><ul><li><code>CopyOnWriteArrayList</code> 是一个并发的数组容器，它的底层实现是数组。</li><li><code>CopyOnWriteArrayList</code> 采用写时复制的方式来保证线程安全。</li><li>通过写时复制的方式，可以高效的进行并发读，但是对于写操作，每次都要进行加锁以及拷贝副本，效率非常低，所以 <code>CopyOnWriteArrayList</code> 仅适合<strong>读多写少</strong>的场景。</li></ul><blockquote><p><code>Vector</code>虽然是线程安全的，但是只是一种相对的线程安全而不是绝对的线程安全，它只能够保证增、删、改、查的单个操作一定是原子的，不会被打断，但是如果组合起来用，并不能保证线程安全性。</p></blockquote><blockquote><p><code>CopyOnWriteArrayList</code>在并发下不会产生任何的线程安全问题，也就是<strong>绝对的线程安全</strong></p></blockquote><h5>另外，有两点必须讲一下。</h5><p>我认为<code>CopyOnWriteArrayList</code>这个并发组件，其实反映的是两个十分重要的分布式理念：</p><p>（1）读写分离</p><blockquote><p>我们读取<code>CopyOnWriteArrayList</code>的时候读取的是<code>CopyOnWriteArrayList</code>中的<code>Object[] array</code>，但是修改的时候，操作的是一个新的<code>Object[] array</code>，读和写操作的不是同一个对象，这就是读写分离。这种技术数据库用的非常多，在高并发下为了缓解数据库的压力，即使做了缓存也要对数据库做读写分离，读的时候使用读库，写的时候使用写库，然后读库、写库之间进行一定的同步，这样就避免同一个库上读、写的IO操作太多</p></blockquote><p>（2）最终一致</p><blockquote><p>对<code>CopyOnWriteArrayList</code>来说，线程1读取集合里面的数据，未必是最新的数据。因为线程2、线程3、线程4四个线程都修改了<code>CopyOnWriteArrayList</code>里面的数据，但是线程1拿到的还是最老的那个<code>Object[] array</code>，新添加进去的数据并没有，所以线程1读取的内容未必准确。不过这些数据虽然对于线程1是不一致的，但是对于之后的线程一定是一致的，它们拿到的<code>Object[] array</code>一定是三个线程都操作完毕之后的<code>Object array[]</code>，这就是最终一致。最终一致对于分布式系统也非常重要，它通过容忍一定时间的数据不一致，提升整个分布式系统的可用性与分区容错性。当然，最终一致并不是任何场景都适用的，像火车站售票这种系统用户对于数据的实时性要求非常非常高，就必须做成强一致性的。</p></blockquote><blockquote><p>最后总结一点，随着<code>CopyOnWriteArrayList</code>中元素的增加，<code>CopyOnWriteArrayList</code>的修改代价将越来越昂贵，因此，<code>CopyOnWriteArrayList</code>适用于读操作远多于修改操作的并发场景中。</p></blockquote><h2>感谢</h2><blockquote><p><a href="http://www.cnblogs.com/xrq730/p/5020760.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/5020760.html</a></p></blockquote><blockquote><p><a href="http://blog.csdn.net/u013124587/article/details/52863533" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52863533</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/leesf456/p/5547853.html" target="_blank" rel="noopener">https://www.cnblogs.com/leesf456/p/5547853.html</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedList</title>
      <link href="/2019/01/20/java-collection/2.LinkedList/"/>
      <url>/2019/01/20/java-collection/2.LinkedList/</url>
      <content type="html"><![CDATA[<p>提到ArrayList，就会比较与LinkedList的区别。本文来看看LinkedList的核心原理。</p><a id="more"></a><p><img src="http://bloghello.oursnail.cn/collection2-1.jpg" alt="image"></p><p>如图所示 LinkedList 底层是基于双向链表实现的，也是实现了 List 接口，所以也拥有 List 的一些特点(JDK1.7/8 之后取消了循环，修改为双向链表)。</p><h2>一、LinkedList属性</h2><p><img src="http://bloghello.oursnail.cn/LinkedList%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%83%85%E5%86%B5.png" alt="LinkedList为空的情况图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的节点个数.</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Pointer to first node.</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="comment">//Pointer to last node.</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h2>二、Node的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//后置指针</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//前置指针</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>三、添加元素</h2><h3>3.1 LinkedList表头添加一个元素</h3><p><img src="http://bloghello.oursnail.cn/LinkedList%E8%A1%A8%E5%A4%B4%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" alt="LinkedList表头添加元素图"></p><blockquote><p>当向表头插入一个节点时，很显然当前节点的前驱一定为 null，而后继结点是 first 指针指向的节点，当然还要修改 first 指针指向新的头节点。除此之外，原来的头节点变成了第二个节点，所以还要修改原来头节点的前驱指针，使它指向表头节点，源码的实现如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//新节点前置指针指向空，后置指针指向first节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//新节点作为新的first节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;<span class="comment">//初始就是个空LinkedList的话，last指向当前新节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;<span class="comment">//初始值不为空，将其前置指针指向新节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>3.2 LinkedList表尾添加一个元素</h3><p><img src="http://bloghello.oursnail.cn/LinkedList%E8%A1%A8%E5%B0%BE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" alt="表尾添加元素图"></p><blockquote><p>当向表尾插入一个节点时，很显然当前节点的后继一定为 null，而前驱结点是 last 指针指向的节点，然后还要修改 last 指针指向新的尾节点。此外，还要修改原来尾节点的后继指针，使它指向新的尾节点，源码的实现如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//新节点前置指针指向空，后置指针指向first节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//新节点作为新的last节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果原来有尾节点，则更新原来节点的后继指针，否则更新头指针</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>3.3 LinkedList在指定节点前添加一个元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断数组是否越界</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);<span class="comment">//直接插在最后一个</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));<span class="comment">//在index节点之前插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">//找到索引位置的前面一个元素pred</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//新节点，前置指针指向pred,后置指针指向索引处元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//修改索引出元素的前置指针为新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;<span class="comment">//说明是插在表头</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;<span class="comment">//说明是插在非表头位置，修改pred后置指针为新指针</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见每次插入都是移动指针，和 <code>ArrayList</code> 的拷贝数组来说效率要高上不少。</p><h2>四、删除元素</h2><p><img src="http://bloghello.oursnail.cn/LinkList%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0.png" alt="删除元素图"></p><p>删除操作与添加操作大同小异，例如删除指定节点的过程如下图所示，需要把当前节点的前驱节点的后继修改为当前节点的后继，以及当前节点的后继结点的前驱修改为当前节点的前驱。</p><p>就不赘述了。</p><h2>五、获取元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取指定索引对应的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找元素的方向是根据index在表中的位置决定的</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;<span class="comment">//索引小于表长的一半，从表头开始往后找</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//索引大于表长的一半，从表尾往前开始找</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，利用了双向链表的特性，如果<code>index</code>离链表头比较近，就从节点头部遍历。否则就从节点尾部开始遍历。使用空间（双向链表）来换取时间。</p><ul><li><code>node()</code>会以<code>O(n/2)</code>的性能去获取一个结点<ul><li>如果索引值大于链表大小的一半，那么将从尾结点开始遍历</li></ul></li></ul><p>这样的效率是非常低的，特别是当 <code>index</code> 越接近 <code>size</code> 的中间值时。</p><h2>总结</h2><blockquote><p>1、理论上无容量限制，只受虚拟机自身限制影响，所以没有扩容方法。</p></blockquote><blockquote><p>2、和<code>ArrayList</code>一样，<code>LinkedList</code>也是是未同步的，多线程并发读写时需要外部同步，如果不外部同步，那么可以使用<code>Collections.synchronizedList</code>方法对<code>LinkedList</code>的实例进行一次封装。</p></blockquote><blockquote><p>3、和<code>ArrayList</code>一样，<code>LinkedList</code>也对存储的元素无限制，允许<code>null</code>元素。</p></blockquote><blockquote><p>4、<strong>顺序插入</strong>速度<code>ArrayList</code>会比较快，因为<code>ArrayList</code>是基于数组实现的，数组是事先new好的，只要往指定位置塞一个数据就好了；<code>LinkedList</code>则不同，每次顺序插入的时候<code>LinkedList</code>将new一个对象出来，如果对象比较大，那么new的时间势必会长一点，再加上一些引用赋值的操作，所以顺序插入<code>LinkedList</code>必然慢于<code>ArrayList</code></p></blockquote><blockquote><p>5、基于上一点，因为<code>LinkedList</code>里面不仅维护了待插入的元素，还维护了<code>Entry</code>的前置<code>Entry</code>和后继<code>Entry</code>，如果一个<code>LinkedList</code>中的<code>Entry</code>非常多，那么<code>LinkedList</code>将比<code>ArrayList</code>更耗费一些内存</p></blockquote><blockquote><p>6、数据遍历的速度，看最后一部分，这里就不细讲了，结论是：使用各自遍历效率最高的方式，<code>ArrayList</code>的遍历效率会比<code>LinkedList</code>的遍历效率高一些</p></blockquote><blockquote><p>7、有些说法认为<code>LinkedList</code>做插入和删除更快，这种说法其实是不准确的：</p></blockquote><ul><li><code>LinkedList</code>做插入、删除的时候，慢在寻址，快在只需要改变前后<code>Entry</code>的引用地址</li><li><code>ArrayList</code>做插入、删除的时候，慢在数组元素的批量<code>copy</code>，快在寻址</li></ul><blockquote><p>所以，如果待插入、删除的元素是在数据结构的前半段尤其是非常靠前的位置的时候，<code>LinkedList</code>的效率将大大快过<code>ArrayList</code>，因为<code>ArrayList</code>将批量<code>copy</code>大量的元素；越往后，对于<code>LinkedList</code>来说，因为它是双向链表，所以在第2个元素后面插入一个数据和在倒数第2个元素后面插入一个元素在效率上基本没有差别，但是<code>ArrayList</code>由于要批量<code>copy</code>的元素越来越少，操作速度必然追上乃至超过<code>LinkedList</code>。</p></blockquote><blockquote><p>从这个分析看出，如果你十分确定你插入、删除的元素是在前半段，那么就使用<code>LinkedList</code>；如果你十分确定你删除、删除的元素在比较靠后的位置，那么可以考虑使用<code>ArrayList</code>。如果你不能确定你要做的插入、删除是在哪儿呢？那还是建议你使用<code>LinkedList</code>吧，因为一来<code>LinkedList</code>整体插入、删除的执行效率比较稳定，没有<code>ArrayList</code>这种越往后越快的情况；二来插入元素的时候，弄得不好<code>ArrayList</code>就要进行一次扩容，记住，<code>ArrayList</code>底层数组扩容是一个既消耗时间又消耗空间的操作.</p></blockquote><blockquote><p>8、<code>ArrayList</code>使用最普通的<code>for</code>循环遍历，<code>LinkedList</code>使用<code>foreach</code>循环比较快.注意到<code>ArrayList</code>是实现了<code>RandomAccess</code>接口而<code>LinkedList</code>则没有实现这个接口.关于<code>RandomAccess</code>这个接口的作用，看一下JDK API上的说法：</p></blockquote><p><img src="http://bloghello.oursnail.cn/RandomAccess%E6%8E%A5%E5%8F%A3%E4%BD%9C%E7%94%A8.png" alt="image"></p><blockquote><p>9、如果使用普通<code>for</code>循环遍历<code>LinkedList</code>，在大数据量的情况下，其遍历速度将慢得令人发指</p></blockquote><p>整理自：</p><ul><li>1、<a href="http://www.cnblogs.com/xrq730/p/5005347.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/5005347.html</a></li><li>2、<a href="http://blog.csdn.net/u013124587/article/details/52837848" target="_blank" rel="noopener">http://blog.csdn.net/u013124587/article/details/52837848</a></li><li>3、<a href="http://blog.csdn.net/u011392897/article/details/57115818" target="_blank" rel="noopener">http://blog.csdn.net/u011392897/article/details/57115818</a></li><li>4、<a href="http://blog.csdn.net/fighterandknight/article/details/61476335" target="_blank" rel="noopener">http://blog.csdn.net/fighterandknight/article/details/61476335</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayList/Vector</title>
      <link href="/2019/01/20/java-collection/1.ArrayList%E5%92%8CVector/"/>
      <url>/2019/01/20/java-collection/1.ArrayList%E5%92%8CVector/</url>
      <content type="html"><![CDATA[<p>面试中，关于java的一些容器，ArrayList是最简单也是最常问的，尤其是里面的扩容机制。</p><a id="more"></a><h2>ArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 实现于 <code>List</code>、<code>RandomAccess</code> 接口。可以插入空数据，也支持随机访问。</p><p>构造函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用初始容量作为参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//初始容量大于0，实例化数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//初始容量等于0，赋予空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中我们可以看见，默认情况下，<code>elementData</code>是一个大小为0的空数组，当我们指定了初始大小的时候，<code>elementData</code>的初始大小就变成了我们所指定的初始大小了。</p><p><code>ArrayList</code>相当于动态数据，其中最重要的两个属性分别是: <code>elementData</code> 数组，以及 <code>size</code> 大小。 在调用 <code>add()</code> 方法的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先进行扩容校验。</li><li>将插入的值放到尾部，并将 size + 1 。</li></ul><p>如果是调用 <code>add(index,e)</code> 在指定位置添加的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//复制，向后移动</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也是首先扩容校验。</li><li>接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</li></ul><p>其实扩容最终调用的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是一个数组复制的过程，<code>ArrayList</code>每次扩容都是扩1.5倍，然后调用<code>Arrays</code>类的<code>copyOf</code>方法，把元素重新拷贝到一个新的数组中去。</p><p>由此可见 <code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。</p><h2>序列化</h2><p>由于 <code>ArrayList</code> 是基于动态数组实现的，所以并不是所有的空间都被使用。因此使用了 <code>transient</code> 修饰，可以防止被自动序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure><p>因此 <code>ArrayList</code> 自定义了序列化与反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="comment">//只序列化了被使用的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当对象中自定义了 writeObject 和 readObject 方法时，JVM 会调用这两个自定义方法来实现序列化与反序列化。</p></blockquote><p>从实现中可以看出 <code>ArrayList</code> 只序列化了被使用的数据。</p><h2>Vector</h2><p><code>Vector</code> 也是实现于 <code>List</code> 接口，底层数据结构和 <code>ArrayList</code> 类似,也是一个动态数组存放数据。不过是在 <code>add()</code> 方法的时候使用 <code>synchronized</code> 进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p><p><code>Vector</code>比<code>ArrayList</code>多了一个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure><p>这个属性是在扩容的时候用到的，它表示每次扩容只扩<code>capacityIncrement</code>个空间就足够了。该属性可以通过构造方法给它赋值。先来看一下构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中，我们可以看出<code>Vector</code>的默认大小也是10，而且它在初始化的时候就已经创建了数组了，这点跟<code>ArrayList</code>不一样。再来看一下<code>grow</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ? capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>grow</code>方法中我们可以发现，<code>newCapacity</code>默认情况下是两倍的<code>oldCapacity</code>，而当指定了<code>capacityIncrement</code>的值之后，<code>newCapacity</code>变成了<code>oldCapacity+capacityIncrement</code>。</p><p>以下是 <code>add()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及指定位置插入数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> java容器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年的最后一天，对商城项目的架构做个改造</title>
      <link href="/2019/01/20/2018%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%EF%BC%8C%E5%AF%B9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%B6%E6%9E%84%E5%81%9A%E4%B8%AA%E6%94%B9%E9%80%A0/"/>
      <url>/2019/01/20/2018%E5%B9%B4%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%EF%BC%8C%E5%AF%B9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%B6%E6%9E%84%E5%81%9A%E4%B8%AA%E6%94%B9%E9%80%A0/</url>
      <content type="html"><![CDATA[<p>一直以来都是学习慕课的实战视频，虽然也跟着做出了一些东西，但是思路都是别人提供好的，脱离了老师，我一直在问自己一个问题：能不能独立地按照自己的思路做出一些东西来？</p><a id="more"></a><p>前方图片高能…更有几十兆gif演示动画，图片全部存放于七牛云上。</p><p><img src="http://bloghello.oursnail.cn/wallpaper.jpg" alt="image"></p><p>在去年，即2017年年底，我在慕课上学习了这两门课程：</p><p><img src="http://bloghello.oursnail.cn/scfs1-1.png" alt="https://coding.imooc.com/class/96.html"></p><p><img src="http://bloghello.oursnail.cn/scfs1-2.png" alt="https://coding.imooc.com/class/96.html"></p><p>第一期项目实现了比较简单的电商业务，整合SSM，并且部署到云端。</p><p>第二期实现了tomcat集群，配合redis实现分布式session，还有一些定时任务、redis分布式锁、maven环境隔离的一些东西，还涉及很多spring和springmvc的有用的机巧。</p><p>整体感觉是：一期实现业务，二期对于一期的提高不是太大，跟分布式无太大关系，仅仅实现了单点登陆和分布式session存储而已。</p><p>个人感觉下一期的课程应该是springCloud的分布式改造，进行服务拆分和治理。所以，在整合这两个课程的基础上用springCloud进行微服务治理。</p><h2>项目详细描述</h2><p>项目源码地址：<a href="https://github.com/sunweiguo/MMall" target="_blank" rel="noopener">https://github.com/sunweiguo/MMall</a></p><p>整体效果演示：</p><p><img src="http://bloghello.oursnail.cn/jdfw.gif" alt="image"></p><p>下面贴个小一点的gif:</p><p><img src="http://bloghello.oursnail.cn/jdfw-small.gif" alt="image"></p><p>部分页面截图：</p><p><img src="http://bloghello.oursnail.cn/mall-index.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-list.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-detail.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-cart.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-comfirm.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/mall-pay.png" alt="image"></p><blockquote><p>经过一遍遍测试，商城还是存在一些无伤大雅的bug，但是主要还是锻炼自己的能力嘛！</p><p>下订单的时候，报错：商品不存在或库存不足，是因为我模拟的秒杀，所以商品的库存要提前预置于redis中，后端管理系统的商品管理页面有预置库存的按钮。</p><p>新增商品的时候，对于上传图片，需要耐心等待一会，需要等待FTP服务器上传完毕，给一个返回信息(Map，是图片的文件名)才能真正显示（对于富文本中的图片上传，在上传之后需要等待一会，时间与小图上传差不多，否则直接保存不报错，但是前端看不到图，因为还没上传完毕,url还没回传回来）</p><p>普通注册的账号，没有管理员权限，所以不能登陆后台管理系统。</p><p>后来做了eureka集群，但是配置文件还是只指向其中一个eureka</p></blockquote><p>在学习的视频中，一期只是实现业务功能，单体架构，一个tomcat。二期对其做了集群，并且解决了集群模式下session存储问题，实现了比较简单的单点登陆功能。架构如下：</p><p><img src="http://bloghello.oursnail.cn/snailmall-1.png" alt="image"></p><p>对于上面的架构来说，只是做了一些集群进行优化，随着业务的发展，用户越来越多，用户服务等其他服务必然要拆分出来独立成为一个服务，这样做的好处是，一方面一个团队负责一个服务可以提高开发效率，另外，对于扩展性也是非常有利的，但是也是有缺点的，会带来很多的复杂性，尤其是引入了分布式事务，所以不能为了分布式而分布式，而是针对不同的业务场景而采用合适的架构。</p><p>微服务的实现，主要有两种，国内是阿里系的以dubbo+zookeeper为核心的一套服务治理和发现生态。另一个则是大名鼎鼎的spring cloud栈。</p><p>spring cloud并不是像spring是一个框架，他是解决微服务的一种方案，是由各种优秀开源组件共同配合而实现的微服务治理架构。下面的图是我构思的项目结构图：</p><p><img src="http://bloghello.oursnail.cn/%E5%95%86%E5%9F%8E%E6%9E%B6%E6%9E%84-2.png" alt="image"></p><p>最前面是<code>Nginx</code>，这里就作为一个静态资源映射和负载均衡，<code>nginx</code>中有几个配置文件，分别为<code>www.oursnail.cn.conf</code>，这个主要是对<code>zuul</code>网关地址做一个负载均衡，指向网关所在的服务器，并且找到前台页面所在位置对页面进行渲染。<code>admin.oursnail.cn.conf</code>，这个主要是配置后端以及后端的页面文件；<code>img.oursnail.cn.conf</code>是对图片服务器地址进行映射。</p><p>然后是<code>zuul</code>网关，这里主要是用来限流、鉴权以及路由转发。</p><p>再后面就是我们的应用服务器啦。对服务器进行了服务追踪(<code>sleuth</code>)，实现了动态刷新配置(<code>spring cloud config</code>+<code>bus</code>)等功能。以<code>http restful</code>的方式进行通信(<code>openFeign</code>),构建起以<code>eureka</code>为注册中心的分布式架构。</p><p>每个服务都是基于<code>springboot</code>打造，结合<code>mybatis</code>持久层操作的框架，完成基本的业务需求。<code>springboot</code>基于<code>spring</code>，特点是快速启动、内置<code>tomcat</code>以及无<code>xml</code>配置。将很多东西封装起来，引入pom就可以直接使用，比如<code>springMVC</code>就基本上引入<code>starter-web</code>即可。</p><p>由于资源的原因，只有三台最低配的服务器，所以本来想做的基于ES的全文检索服务没有做，也没有分库分表。</p><p>至于定时任务以及Hystrix服务熔断和降级，比较简单，就不做了。</p><ul><li>项目的接口文档详见wiki：<a href="https://github.com/sunweiguo/spring-cloud-for-snailmall/wiki" target="_blank" rel="noopener">https://github.com/sunweiguo/spring-cloud-for-snailmall/wiki</a></li><li>项目的数据库表设计：snailmall.sql</li></ul><p>下面详细介绍每个模块实现的大体思路（仅供参考，毕竟应届生，真实项目没做过）：</p><ul><li>用户模块</li></ul><p>关于用户模块，核心的功能是登陆。再核心是如何验证以及如何存储用户信息。这里采取的方案为：</p><p><img src="http://bloghello.oursnail.cn/user.png" alt="image"></p><p>对于用户注册，我这里就是用户名（昵称），那么如何保证不重复呢（高并发）？这里还是用了分布式锁来保证的。</p><p>对于未登陆章台下用户修改密码，逻辑为：</p><p><img src="http://bloghello.oursnail.cn/user-2.png" alt="image"></p><ul><li>购物车模块</li></ul><p><img src="http://bloghello.oursnail.cn/cart.png" alt="image"></p><ul><li>订单模块</li></ul><p><img src="http://bloghello.oursnail.cn/order.png" alt="image"></p><p>针对这些问题，我想说一下我的思路。</p><p>对于幂等性，这里产生幂等性的主要原因在于MQ的重传机制，可能第一个消息久久没有发出去，然后重新发送一条，结果第一条消息突然又好了，那么就会重复发两跳，对于用户来说，只下一次单，但是服务器下了多次订单。网上解决这个问题的思路是创建一张表，如果是重复的订单号，就不可能创建多次了。还有一种可能方案是用分布式锁对该订单号锁住一段时间，由于只是锁住订单号，所以不影响性能，在这一段时间内是不可以再放同一个订单号的请求进来。</p><p>对于MQ消息不丢失，只能是订阅模式了。消息发出去之后，消费端给MQ回复一个接收到的信息，MQ本次消费成功，给订阅者一个回复。</p><p>对于全局唯一ID生成，这里用的是雪花算法，具体介绍可以看<a href="https://github.com/sunweiguo/swgBook/blob/master/mamabuy/05-%E4%BA%A4%E6%98%93%E5%B7%A5%E7%A8%8B(%E4%B8%8A).md" target="_blank" rel="noopener">我的笔记</a></p><p>对于分布式事务，比较复杂，这里其实并没有真正处理，对于数据库扣减库存和数据库插入订单，他们在不同的数据库，廖师兄比较倾向的方式是：</p><p><img src="http://bloghello.oursnail.cn/order-2.png" alt="image"></p><p><img src="http://bloghello.oursnail.cn/order-3.png" alt="image"></p><p>这一切的基础还是需要有一个可靠的消息服务，确保消息要能送达。</p><p>针对redis预减库存存在的并发问题，这里的思路是用lua+redis，在预减之前判断库存是否够，这两个操作要在一个原子操作里面才行，lua恰好可以实现原子性、顺序性地操作。</p><ul><li>支付模块</li></ul><p>这里对接的是支付宝-扫码支付，用到是支付宝沙箱环境。支付的扫码支付详细流程在这里聊一聊哈。</p><p>商户前台将商品参数发送至商户后台，商户后台生成<strong>内部订单号</strong>并用于请求支付平台创建<strong>预下单</strong>，支付平台创建完预订单后将订单二维码信息返还给商户，此时用户即可扫取二维码进行付款操作。</p><p>内部订单号：这是相对于支付宝平台而言的，这个订单号是我们商城自己生成的，对于我们商城来说是内部订单号，但是对于支付宝来说是外部订单号。</p><p>将一系列的数据按照支付宝的要求发送给支付宝平台，包括商品信息，生成的验签sign，公钥；支付宝去将sign解密，进行商品的各种信息校验。校验通过，<strong>同步</strong>返回二维码串。</p><p>支付业务流程图：</p><p><img src="http://bloghello.oursnail.cn/pay-1.png" alt="image"></p><p>在获取支付的二维码串之后，用工具包将其转换未二维码展示给用户扫码。</p><p>用户扫码后，会收到第一次支付宝的回调，展示要支付的金额，商品信息等。</p><p>用户输入密码成功后，正常情况会收到支付宝的第二次回调，即支付成功信息。</p><p>但是也可能会由于网络等原因，迟迟收不到支付宝的回调，这个时候就需要主动发起轮询去查看支付状态。</p><p>在支付成功之后，接收回调的接口要记得返回<code>success</code>告诉支付宝我已经收到你的回调了，不要再重复发给我了。接收回调的接口也要做好去除重复消息的逻辑。</p><p><img src="http://bloghello.oursnail.cn/pay-2.png" alt="image"></p><p>这个流程是多么地简单而理所当然！</p><p>对应于代码层面，其实就是两个接口，一个是用户点击去支付按钮，此时发起预下单，展示付款二维码，另一个是接收支付宝回调：</p><p>预下单：</p><p><img src="http://bloghello.oursnail.cn/pay-3.png" alt="image"><br><img src="http://bloghello.oursnail.cn/pay-4.png" alt="image"><br><img src="http://bloghello.oursnail.cn/pay-5.png" alt="image"></p><p>接收支付宝支付状态回调：</p><p><img src="http://bloghello.oursnail.cn/pay-6.png" alt="image"></p><h2>项目进展</h2><ul><li>[x] 2018/12/31 完成了聚合工程的创建、Eureka服务注册中心、spring cloud config+gitHub+spring cloud bus（rabbitMQ）实现配置自动刷新–v1.0</li><li>[x] 2018/12/31 将Eureka注册中心(单机)和配置中心部署到服务器上，这比较固定，所以先部署上去，以后本地就直接用这两个即可，对配置进行了一点点修改</li><li>[ ] 2018/12/31 关于配置的自动刷新，用postman发送post请求是可以的，但是用github webhook不行，不知道是不是这个版本的问题</li><li>[x] 2018/12/31 用户模块的逻辑实现,首先增加了一些pom文件的支持，整合mybatis，测试数据库都通过，下面就可以真正去实现业务代码了</li><li>[x] 2019/1/1 完成用户注册、登陆、校验用户名邮箱有效性、查看登陆用户信息、根据用户名去拿到对应的问题、校验答案是否正确、重置密码这个几个接口，在注册这个接口，增加一个ZK分布式锁来防止在高并发场景下出现用户名或邮箱重复问题</li><li>[x] 2019/1/2 上午完成门户用户模块所有接口–v2.0</li><li>[x] 2019/1/2 下午完成品类管理模块，关于繁琐的获取用户并且鉴权工作，这里先放每个接口里面处理，后面放到网关中去实现–v3.0</li><li>[x] 2019/1/3 上午引入网关服务，将后台重复的权限校验统一放到网关中去做，并且加了限流，解决了一下跨域问题。–v4.0</li><li>[x] 2019/1/3 下午和晚上完成门户和后台的商品管理模块所有的接口功能，除了上传文件的两个接口没有测试以外，其他接口都进行了简单的测试，其中还用Feign去调用了品类服务接口–v5.0</li><li>[x] 2019/1/3 初步把购物车模块和模块引入，通过基础测试，后面在此基础上直接开发代码即可，明天下午看《大黄蜂》，晚上师门聚餐吃火锅，明天早上赶一赶吧，今天任务结束！</li><li>[x] 2019/1/4 整理了接口文档，并且画了一下购物车模块的流程图以及订单服务的流程图，针对订单服务中，记录了需要一些注意的问题，尽可能地完善，提高可用性和性能。并且完成购物车模块的controller层。</li><li>[x] 2019/1/5 完成购物车模块，并且进行了简单的测试，这里进行了两处改造，一个是判断了一下是否需要判断库存；另一个是商品信息从redis中取，取不出来则调用商品服务初始化值</li><li>[x] 2019/1/5 收货地址管理模块，这个模块就是个增删改查，没啥东西写，这里就不加缓存了。</li><li>[x] 2019/1/6 完成了后台订单管理模块并且进行了测试，调用收货地址服务时，发现收货地址服务无法读取到cookie，通过这个方法(<a href="https://blog.csdn.net/WYA1993/article/details/84304243" target="_blank" rel="noopener">https://blog.csdn.net/WYA1993/article/details/84304243</a>) 暂时解决了问题</li><li>[x] 2019/1/6 预置所有商品库存到redis中；预置所有商品到redis中；大概确定好订单服务思路：预减库存（redis判断库存）—对userID增加分布式锁防止用户重复提交订单–MQ异步下订单</li><li>[x] 2019/1/6 新增全局唯一ID生成服务，雪花算法实现</li><li>[x] 2019/1/7 完善订单服务-这一块涉及跨库操作，并且不停地调用其他服务，脑子都快晕了，这里采取的策略是：用到购物车的时候，去调用购物车服务获取；产品详情从redis中获取。首先将商品以及商品库存全部缓存到redis中，然后用户下单，先从redis中判断库存，够则减，判断<br>和扣减放在lua脚本中原子执行，然后MQ异步出去生成订单（生成订单主表和订单详情表放在一个本地事务中），这两步操作成功之后，再用MQ去异步删除购物车。MQ消费不成功则重试。<br>对于扣减库存这一步，想法是用定时任务，定时与redis中进行同步。这里是模拟了秒杀场景，预减库存+MQ异步，提交订单–&gt;redis判断并且减库存–&gt;调用cart-service获取购物车–&gt;MQ异步(userId,shippingId)生成订单主表和详情表–&gt;上面都成功，则MQ异步(userId)<br>去清除购物车，库存用定时任务去同步(未做)，理想的做法是：MQ异步扣减库存，订单服务订阅扣减库存消息，一旦库存扣减成功，则进行订单生成。</li><li>[x] 2019/1/8 继续完善订单接口，完成支付服务，就直接放在订单服务里面了，因为与订单逻辑紧密，就放在一起了。</li><li>[x] 2019/1/8 使用了一下swagger，发现代码侵入比较强，每一个接口上面都要手动打上响应的注解</li><li>[x] 2019/1/8 关于hystrix熔断与降级，可以引入hystrix的依赖，用@HystrixCommand注解来控制超时时间、服务降级以及服务熔断。也可以直接再@FeignClient接口中指定服务降级的类，这里不演示了，因为设置比如超时时间，我还要重新测试，写起来很简单，测起来有点儿麻烦</li><li>[x] 2019/1/9 服务跟踪，服务端是直接用的线程的，只需要下载：wget -O zipkin.jar  ‘<a href="https://search.maven.org/remote_content?g=io.zipkin.java&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec" target="_blank" rel="noopener">https://search.maven.org/remote_content?g=io.zipkin.java&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec</a>’，然后nohup java -jar zipkin.jar &gt; zipkin.server.out &amp; ，开放9411端口，打开浏览器http://ip:9411看到页面即可。<br>客户端只需要添加相应依赖和配置文件即可。用客户端测试，发现死活不出现我的请求，经过搜索，发现需要增加spring.zipkin.sender.type= web这个配置项才行.</li><li>[x] 2019/1/10 初步把项目部署到服务器上，进行测试，bug多多，修改中…</li><li>[x] 2019/1/10 改了一天的bug，其中网关的超时时间以及feign的超时时间都要改大一点，否则会超时报错。最终成功，花了三台服务器，部署了11个服务。后面把部署过程写一下。</li><li>[x] 2019/1/11 将注册中心做成集群，因为早上一起来，注册中心挂了？？？</li><li>[ ] 2019/1/11 docker部署(商城第四期的改造目标:容器化+容器编排)，本期改造结束。</li><li>[x] 2019/1/11 完善readme文档</li><li>[x] 2019/1/12 两次发现redis数据被莫名其妙清空，我确定不是缓存到期，为了安全起见，设置了redis的密码，明天看缓存数据还在不在。</li><li>[x] 2019/1/14 redis数据没有再丢失，修复用户更新信息的bug</li></ul><h2>项目启动</h2><p>安装redis、zookeeper、mysql、jdk、nginx以及rabbitMQ。</p><p>对代码进行maven-package操作。打包成jar包。将其放到服务器上：</p><p><img src="http://bloghello.oursnail.cn/start.png" alt="image"></p><p>执行<code>nohup java -jar snailmall-user-service.8081 &gt; user-service.out &amp;</code>后台启动即可。</p><blockquote><p>补充：针对配置刷新，修改了github信息，用<code>postman</code>请求<code>http://xxxxx:8079/actuator/bus-refresh</code> 触发更新。</p><p>本改造是基于<a href="https://coding.imooc.com/class/96.html" target="_blank" rel="noopener">快乐慕商城一期</a>和<a href="https://coding.imooc.com/class/162.html" target="_blank" rel="noopener">快乐慕商城二期</a>的基础上进行改造。所以需要在其业务基础上改造会比较顺手。关于微服务，尤其是电商中的一些处理手段，很多思路都是学习于<a href="http://coder520.com/" target="_blank" rel="noopener">码吗在线</a>中分布式电商项目。再加上慕课网廖师兄的<a href="https://coding.imooc.com/class/187.html" target="_blank" rel="noopener">spring cloud微服务实践</a>。</p></blockquote><h2>前台项目</h2><p>只要阅读<code>readme</code>文档即可。代码仓库为：<a href="https://github.com/sunweiguo/snailmall-front" target="_blank" rel="noopener">https://github.com/sunweiguo/snailmall-front</a></p><p>学习不仅要有输入，更要有自己的输出，实践是提升的捷径！</p>]]></content>
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试-进程与线程</title>
      <link href="/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/01/19/%E9%9D%A2%E8%AF%95-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>都是操作系统管理的对象，比较容易混淆，但是又是两样完全不同的东西，因此区别很多。从他们区别也可以发散出很多关于操作系统比较重要的知识。所以面试比较常问。</p><a id="more"></a><h2>1. 进程到底是什么？</h2><p>翻了一下书：《操作系统概念》第三章中提及了进程的概念。他是这样说的：</p><blockquote><p>进程是执行中的程序，这是一种非正式说法。进程不只是程序代码（代码块），进程还包含了当前活动，通过程序计数器的值和处理器寄存器的内容来表示。此外，进程还包含进程堆栈段（包括临时数据，如函数参数、返回地址和局部变量）和数据段（包括全局变量）。进程还可能包含堆，是在进程运行期间动态分配的内存。</p><p>程序本身不是进程。程序只是被动实体，如存储在磁盘上包含一系列指令的文件内容。而进程是活动实体，它有一个程序计数器来表示下一个要执行的命令和相关资源集合。当一个可执行文件被装入内存时，一个程序才能成为进程。</p></blockquote><p>总结一下进程是什么，是我个人理解：<strong>它是一个活动实体，运行在内存上。然后它占用很多独立的资源，比如：内存资源、程序运行肯定涉及CPU计算、占用的端口资源（公共的）、文件资源（公共的）、网络资源（公共的）等等等。要想执行这个进程，首先要有一个可执行文件，有了这个可执行文件，还要有相应的执行需要的资源。所以将可执行文件、当前进程的上下文、内存等资源结合起来，才是一个真正的进程。</strong></p><p><strong>那么，我们就可以理解一句话：进程是资源分配的基本单位。</strong></p><p>进程中的内存空间（虽然空间大小都一样，下文会说明）是独立的，否则就会出现一种情况：修改自己程序中的某个指针就可以指向其他程序中的地址，然后拿到里面的数据，岂不是很恐怖的场景？</p><p><img src="http://bloghello.oursnail.cn/operator1-1.png" alt="image"></p><p>如上图，进程中包含了线程。操作系统可能会运行几百个进程，进程中也可能有几个到几百个线程在运行。</p><p>文件和网络句柄是所有进程共享的，多个进程可以去打开同一个文件，去抢占同一个网络端口。</p><p>图中还有个内存。这个内存不是我们经常说的内存条，即物理内存，而是虚拟内存，是进程独立的，大小与实际物理内存无关。</p><h2>2. 寻址空间</h2><p>比如8086只有20根地址线，那么它的寻址空间就是1MB，我们就说8086能支持1MB的物理内存，及时我们安装了128M的内存条在板子上，我们也只能说8086拥有1MB的物理内存空间。</p><p>以前叫卖的32位的机子，32位是指寻址空间为2的32次方。32位的386以上CPU就可以支持最大4GB的物理内存空间了。</p><h2>3. 为什么会有虚拟内存和物理内存的区别</h2><p>正在运行的一个进程，他所需的内存是有可能大于内存条容量之和的，比如你的内存条是256M，你的程序却要创建一个2G的数据区，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，在通过调度进入物理内存。</p><p>所以，<strong>虚拟内存是进程运行时所有内存空间的总和</strong>，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。</p><p>关键的是不要把虚拟内存跟真实的插在主板上的内存条相挂钩，虚拟内存它是“虚拟的”不存在，假的啦，它只是内存管理的一种抽象！</p><h2>4. 虚拟内存地址和物理内存地址是如何映射呢</h2><p>假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0 ~ 0xFFFFFFFF（4G）的地址空间，但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？回答这个问题前，先说明计算机的<strong>内存分页机制</strong>。</p><p><img src="http://bloghello.oursnail.cn/operator1-4.png" alt="image"></p><p><strong>计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（page frame），这个页和页帧的大小是一样大的，所以呢，在这里，虚拟内存页的个数势必要大于物理内存页帧的个数。</strong></p><p>在计算机上有一个<strong>页表</strong>（page table），就是<strong>映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射</strong>，而且是一对一的映射。但是问题来了，虚拟内存页的个数 &gt; 物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？</p><p>不是的，操作系统是这样处理的。操作系统有个<strong>页面失效</strong>（page fault）功能。<strong>操作系统找到一个最少使用的页帧，让他失效，并把它写入磁盘，随后从磁盘中把把需要访问的数据所在的页放到最少使用的页帧中，并修改页表中的映射（即修改页号指向当前页帧），这样就保证所有的页都有被调度的可能了。这就是处理虚拟内存地址到物理内存的步骤。</strong></p><p>至于里面如何实现的细节，我没有过多去探究。</p><h2>5. 什么是虚拟内存地址和物理内存地址</h2><p>虚拟内存地址由页号和偏移量组成。页号就是上面所说的。偏移量就是我上面说的页（或者页帧）的大小，即这个页（或者页帧）到底能存多少数据。</p><p><strong>举个例子，有一个虚拟地址它的页号是4，偏移量是20，那么他的寻址过程是这样的：首先到页表中找到页号4对应的页帧号（比如为8），如果找不到对应的页桢，则用失效机制调入页。如果存在，把页帧号和偏移量传给MMU（CPU的内存管理单元）组成一个物理上真正存在的地址，接着就是访问物理内存中的数据了。</strong></p><h2>6. 线程里面有什么</h2><p>写到这里，好像还与本标题无关，即进程和线程到底是什么关系和区别等。但是我们要知道，面试或者学习一个知识点，不是为了学习这个区别而学习， 我们应该学习为什么有进程和线程，有了进程还需要线程吗？有了线程还要进程吗？你说进程是资源分配的单位，分配的是什么资源呢？进程中的内存是咋管理的呢？虚拟内存和物理内存是什么？什么是虚拟内存地址和物理内存地址？等等等，所以面试是千变万化的，重要的是我们尽可能地多问自己几个为什么，然后从为什么开始去逐个击破，形成一个体系。</p><p><img src="http://bloghello.oursnail.cn/operator1-2.png" alt="image"></p><p>说说这个栈，我们知道，执行程序从主程序入口进入开始，可能会调用很多的函数，那么这些函数的参数和返回地址都会被压入栈中，包括这些函数中定义的临时局部变量都会压入栈中，随着函数的执行完毕，再逐层地弹出栈，回到主函数运行的地方，再继续执行。</p><p>PC(program counter)，就是程序计数器，指向的下一条指令执行的地址。</p><p><strong>由此可见，操作系统运行的其实是一个一个的线程，而进程只是一个隔离资源的容器。</strong></p><p>上面说到，PC是指向下一条指令执行的地址。而这些指令是放在内存中的。</p><p>我们的计算机大多数是存储程序型的。就是说数据和程序是同时存储在同一片内存里的。</p><p>所以我们经常会听到一个漏洞叫做“<strong>缓冲区溢出</strong>”：比如有一个地方让用户输入用户名，但是黑客输入很长很长的字符串进去，那么很有可能就会超出存放这个用户名的一片缓冲区，而直接侵入到存放程序的地方，那么黑客就可以植入程序去执行。解决方案就是限制输入的用户名长度，不要超过缓冲区大小。</p><p>还有一块是<strong>TLS(thread local storage)</strong>，我们知道进程有自己独立的内存，那么我们的线程能不能也有一小块属于自己的内存区域呢？</p><p>这个东西，其实很简单，就是说，比如new一个对象，往往是在堆中开辟空间的，但是现在的情况是：在一个函数内，new出来一个对象，这个对象不引用外部对象，也不会被外部引用，是纯粹属于这个函数段，可以理解为这个对象是属于这个函数的局部临时变量。</p><p>此时，new这个对象就不需要再去堆中开辟空间了，因为一方面不需要共享，另一方面是在堆中开辟是比较慢的，并且可能有很多函数，这种局部对象零零总总加起来还是很多的，在堆中开辟会浪费空间。</p><p>所以，能不能在栈中就可以new出这个对象，反正用完就扔。TLS可以是现在这个。栈中直接new多方便多快，因为不需要走垃圾回收机制，还避免了线程安全问题。可以去搜索：<strong>栈上分配和逃逸分析</strong></p><h2>7. 线程VS进程</h2><p>到这里，就清晰了很多。我们也可以多多少少理解他们的区别。</p><p>可以做个简单的比喻，便于记忆：进程=火车，线程=车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li><li>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－“互斥锁”</li><li>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</li></ul><p>再补充几句。</p><ul><li>线程是调度的基本单位，进程是资源分配的基本单位</li><li>进程间没有共享内存，所以交互要通过TCP/IP端口的等方式来实现。线程间由于有共享内存，所以交互比较方便。</li><li>线程占用很多资源，而线程只需要分配栈和PC即可。</li></ul><h2>8. 针对虚拟内存和物理内存的总结</h2><ul><li>每个进程都有自己独立的4G(32位系统下)内存空间，各个进程的内存空间具有类似的结构</li><li>一个新进程建立的时候，将会建立起自己的内存空间，此进程的数据，代码等从磁盘拷贝到自己的进程空间（建立一个进程，就要把磁盘上的程序文件拷贝到进程对应的内存中去，对于一个程序对应的多个进程这种情况，浪费内存！），哪些数据在哪里，都由进程控制表中的task_struct记录</li><li>每个进程的4G内存空间只是虚拟内存空间，每次访问内存空间的某个地址，都需要把地址翻译为实际物理内存地址</li><li>所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</li><li>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）</li><li>当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则缺页异常</li><li>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘</li></ul><h2>9. 关于进程和线程更深的认识</h2><p>关于为什么要分进程和线程，先抛出结论：</p><ul><li>进程process：进程就是时间总和=执行环境切换时间+程序执行时间------&gt;<strong>CPU加载执行环境-&gt;CPU执行程序-&gt;CPU保存执行环境</strong></li><li>线程thread：线程也是时间总和=执行环境切换时间（共享进程的）+程序模块执行时间------&gt;<strong>CPU加载执行环境（共享进程的）-&gt;CPU执行程序摸块-&gt;CPU保存执行环境（共享进程的）</strong></li><li>进程和线程都是描述CPU工作的时间段，线程是更细小的时间段。</li></ul><p>那么，如果CPU时间片临幸本进程，那么这个进程在恢复执行环境之后，执行里面的若干线程就不需要再不停地切换执行环境了，所以说，线程相比于进程是比较轻量的。</p><p>在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。</p><p>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文</p><p>线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。</p><p>这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境、更为细小的CPU时间段。</p><p><strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</strong></p><p>整理自：</p><ul><li><a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384</a></li><li><a href="https://blog.csdn.net/moshenglv/article/details/52242153" target="_blank" rel="noopener">https://blog.csdn.net/moshenglv/article/details/52242153</a></li><li><a href="https://blog.csdn.net/u012861978/article/details/53048077" target="_blank" rel="noopener">https://blog.csdn.net/u012861978/article/details/53048077</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 操作系统相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一步一步理解HTTPS</title>
      <link href="/2019/01/18/network/7.%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3HTTPS/"/>
      <url>/2019/01/18/network/7.%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3HTTPS/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第七篇文章。HTTPS（SSL/TLS）的加密机制是前端后端ios安卓等都应了解的基本问题。也是面试经常问的点。</p><a id="more"></a><h2>一、为什么需要加密？</h2><p>小时候看谍战片，情报发过来了之后，用一个小本本进行翻译，然后解密出情报。加密就是防止明文被别人看到甚至篡改嘛！</p><p>回到互联网，因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了，他还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。最简单容易理解的就是对称加密 。</p><h2>二、什么是对称加密？</h2><p><img src="http://bloghello.oursnail.cn/http7-1.png" alt="image"></p><p>小明写个求爱信给小红，小明担心小红的妈妈看到这封信的内容，他灵机一动，对信加个密，并确定好我用这个密钥加密的，小红收到之后也用这个密钥解密才行。</p><p>但是呢，这里有个麻烦的地方就是，小明和小红不在一个学校，这个钥匙呢，不方便直接送到手里。所以呢，小明得想办法把这个钥匙寄一个送给小红，好吧，就用最贵的顺丰吧！</p><p>就是有一个密钥，它可以对一段内容加密，加密后只能用它才能解密看到原本的内容，和我们日常生活中用的钥匙作用差不多。</p><h2>三、用对称加密可行吗？</h2><p>顺丰快递到了，结果小红不在家，小红的妈妈收到了，一看是个男同学寄的，怎么能忍住，赶紧打开，以看是一把钥匙，作为程序猿，妈妈得意一笑：哼哼，还能逃过我的眼睛？我赶紧复制一把藏着，我倒要看看他后面要寄啥来，还要加密？！</p><p>果然小红的妈妈等到了来自小明寄过来的情书，解密一看，实锤早恋。</p><p>同样地，小明这边也非常危险，快递员刚出发，就被小明的妈妈拦截了，拿到了这个钥匙，那小明还没寄出的信已经被妈妈看光了。</p><p><strong>所以问题的根本就是，这把钥匙要传输，传输就可能被截取。</strong></p><p><img src="http://bloghello.oursnail.cn/http7-2.png" alt="image"></p><p>回到互联网，如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。</p><p>然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。</p><p><strong>如果由服务器生成一个密钥并传输给浏览器，那这个传输过程中密钥被别人劫持弄到手了怎么办？</strong></p><p>换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行啦！这么做显然不现实。</p><p>怎么办？所以我们就需要神奇的非对称加密。</p><h2>四、什么是非对称加密？</h2><p>有两把密钥，通常一把叫做公钥、一把叫做私钥。</p><p>用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。</p><h2>五、用非对称加密可行吗？</h2><p><img src="http://bloghello.oursnail.cn/http7-4.png" alt="image"></p><p>公钥呢，还是要通过快递员送给小红的。OK，假设小红要回信，写好了用公钥加密，小红的妈妈因为拿不到私钥，看不到信的内容。</p><p>OK，但是反过来呢？小明用私钥加密传给小红，那么小红的妈妈可就能解密了（因为公钥可能会被小红的妈妈拿到）。</p><p>回到互联网，服务器先把公钥直接明文传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！因为只有服务器有相应的私钥能解开这条数据。</p><p>然而由服务器到浏览器的这条路怎么保障安全？</p><p>如果服务器用它的的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而<strong>这个公钥是一开始通过明文传输给浏览器的，这个公钥被谁劫持到的话，他也能用该公钥解密服务器传来的信息了。</strong></p><p>所以目前似乎只能保证由浏览器向服务器传输数据时的安全性（其实仍有漏洞，下文会说）。</p><h2>六、改良的非对称加密方案，似乎可以？</h2><p>小明和小红年纪不大，但是很聪明，针对这个情况，还是迅速升级加密方法。他们想到既然一组公钥私钥不够，那两组呢？</p><p><img src="http://bloghello.oursnail.cn/http7-5.png" alt="image"></p><p>OK，小明和小红各造了一对。下面就是互相交换公钥。那么就变成：</p><p><img src="http://bloghello.oursnail.cn/http7-6.png" alt="image"></p><p><strong>下面就好办啦，小明写信用公钥B加密，那么信的内容只有小红能破解，因为小红是随身携带私钥B。相反，小红用公钥A对信加密，这样只有小明能破解，因为小明也是随身携带私钥A</strong>。好像很安全啦！除了下面提到的漏洞，唯一的缺点可能是：小红得花半天时间才能解密完这封信，有点受不了。</p><p>回到互联网。请看下面的过程：</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥A；浏览器拥有用于非对称加密的公钥B、私钥B。</li><li>浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li>浏览器把公钥B明文传输给服务器。</li><li>之后浏览器向服务器传输的所有东西都用公钥A加密，服务器收到后用私钥A解密。由于只有服务器拥有这个私钥A可以解密，所以能保证这条数据的安全。</li><li>服务器向浏览器传输的所有东西都用公钥B加密，浏览器收到后用私钥B解密。同上也可以保证这条数据的安全。</li></ol><p>的确可以！抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。</p><h2>七、非对称加密+对称加密？</h2><p>小明也知道，这个信很长，用非对称加密，太慢！办法也有，没有必要对那么长的信加密，我只要保证这个真正解密的钥匙不被别人拿到就行，那么他灵机一动想到这个方法：</p><p><img src="http://bloghello.oursnail.cn/http7-7.png" alt="image"></p><p>小明和小红利用非对称加密对钥匙加密，姑且认为是这个钥匙被放在了一个盒子里，这个盒子也被锁起来了，只有小红或者小明才能打开盒子，再用钥匙去解密。</p><p>这个真正用于对称加密解密的钥匙别人就拿不到啦！</p><p>自从用了这个方案，感觉又安全，解密又快，感情又深温了呢！</p><p>回到互联网，步骤如下：</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥A。</li><li>浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li><strong>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器</strong>。</li><li><strong>服务器拿到后用私钥A解密得到密钥X</strong>。</li><li><strong>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密</strong>。</li></ol><p>HTTPS的基本思想就是基于这个。但是这个方案也存在上面一直在说的漏洞。</p><h2>八、中间人攻击</h2><p>像妈妈这样级别的程序猿可能是那他们两没办法啦，但是呢，校区有个看门的大爷，以前是个黑客，也不知道咋回事，明明才50岁，但是看起来像80岁，头上光溜溜的，冬天冷呢。整天在那胡言乱语：<code>docker</code>牛逼啊，<code>spring cloud</code>牛逼啊，这个开源软件XXX写的真好，跟周围的老大爷老大妈根本谈不到一起去。</p><p>他也是闲的蛋疼，非要掺和，因为据说他以前单身30年，苦逼敲代码，不知道谈恋爱是啥滋味，姑且认为他好奇心重吧。</p><p><strong>在小明第一次寄公钥A的时候，大爷出手了，截取下来。换成自己做的公钥B</strong>。然后送给小红。</p><p><strong>小红哪里会知道这公钥被掉包了呢</strong>，所以直接就用了，按照正常步骤，小红想了一个随机字符串，这次就叫<code>xiaomingwoxuanni</code>吧，OK，用这个公钥B对这个字符串加个密，这个字符串就被锁进了用大爷公钥B锁的盒子里。</p><p>老大爷在门口守着呢，一看到小红寄东西了，又偷偷地截取下来，<strong>用自己的私钥B来解密这个盒子</strong>。轻易地拿到了里面的字符串，OK，怕小明察觉，再用小明寄来的公钥A加密传给小明，这样双方都不知道他们的钥匙已经被大爷给获取了。</p><p>小明和小红之间的信就用<code>xiaomingwoxuanni</code>这个钥匙进行对称加密和对称解密，完全不知道有个大爷就天天拿着这个字符串去解密信件，看的不亦乐乎，甚至还偷偷改几个字呢。</p><p>回到互联网。中间人的确无法得到浏览器生成的密钥B，这个密钥本身被公钥A加密了，只有服务器才有私钥A解开拿到它呀！然而中间人却完全不需要拿到密钥A就能干坏事了。请看：</p><ol><li>某网站拥有用于非对称加密的公钥A、私钥A。</li><li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li><li>中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B）。</li><li>浏览器随机生成一个用于对称加密的密钥X，用公钥B（浏览器不知道公钥被替换了）加密后传给服务器。</li><li>中间人劫持后用私钥B解密得到密钥X，再用公钥A加密后传给服务器。</li><li>服务器拿到后用私钥A解密得到密钥X。</li></ol><p>这样在双方都不会发现异常的情况下，中间人得到了密钥B。<strong>根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。只要解决了这个公钥一定是这个网站发来的，那么基本就OK了</strong></p><h2>九、如何证明浏览器收到的公钥一定是该网站的公钥？</h2><p>现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中能不能搞这么个公信机构呢？给网站颁发一个“身份证”？</p><h2>十、数字证书</h2><p>网站在使用HTTPS前，需要向“CA机构”申请颁发一份数字证书，即SSL证书，数字证书里有证书持有者、证书持有者的公钥等信息，<strong>服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”</strong>。然而这里又有一个显而易见的问题了，<strong>证书本身的传输过程中，如何防止被篡改</strong>？即如何证明证书本身的真实性？身份证有一些防伪技术，数字证书怎么防伪呢？解决这个问题我们就基本接近胜利了！</p><p>SSL证书内容：</p><ol><li>证书的发布机构CA</li><li>证书的有效期</li><li>公钥</li><li>证书所有者</li><li>签名</li></ol><h2>十一、如何放防止数字证书被篡改？</h2><p>我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名。</p><p>提到数字签名，其实原理很简单啦，就是比如我要传输一句话叫：“你给我转100块钱，我的账号是123456，转完了告诉我一声。”，如果不做任何处理，被刚才的老大爷截取了，他偷偷地改一下内容“你给我转200块钱，我的账号是654321，不要告诉任何人，尤其是你嫂子。”</p><p>是不是太坏了，弄不好被抓，大爷可不敢做大的，只敢骗个喝酒钱。</p><p>那么怎么防止大爷这种猥琐技术又高的人篡改呢？数字签名排上用场啦！</p><p>以后再传消息就是“你给我转100块钱，我的账号是123456，转完了告诉我一声。”+“！……@&amp;@%#……！￥@￥！@%……#￥！%……”,后面那一串东西就是数字签名，简单来说，就是想办法对前面的内容进行非对称加密（<strong>这样别人根本不知道你加密的私钥是什么，也就伪装不了签名了</strong>）。传过去之后，我要对其进行解密，与传过来的明文一一对比参数，看有没有被改动过。一旦发现哪里不对应，说明已经被篡改了。</p><p>“CA机构”制作签名的过程：</p><ol><li><strong>CA拥有非对称加密的私钥和公钥</strong>。</li><li><strong>CA对证书明文信息进行hash</strong>。</li><li><strong>对hash后的值用私钥加密，得到数字签名</strong>。</li></ol><p><strong>明文和数字签名共同组成了数字证书</strong>，这样一份数字证书就可以颁发给网站了。网站把这个数字证书传给浏览器。</p><p>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p><p>浏览器验证过程：</p><ol><li>拿到证书，得到明文T，数字签名S。</li><li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li><li>用证书里说明的hash算法对明文T进行hash得到T’。</li><li>比较S’是否等于T’，等于则表明证书可信。</li></ol><p>为什么这样可以证明证书可信呢？我们来仔细想一下。</p><h2>十二、中间人有可能篡改该证书吗？</h2><p>老大爷就算有天大的能耐，也拿不到加密的私钥，那么只是单纯地篡改明文，只会造成校验不通过。</p><p>回到互联网，假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。</p><p>浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p><h2>十三、中间人有可能把证书掉包吗？</h2><p>假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。</p><p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p><p>总结：因为一个网站域名对应一个证书，你的证书根其他人的证书肯定是不一样的，那么你就算拿到了其他人的证书再掉包成自己的，也没用，毕竟浏览器那边只要看一下是不是我要查看的域名。</p><h2>十四、为什么制作数字签名时需要hash一次？</h2><p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。</p><h2>十五、怎么证明CA机构的公钥是可信的？</h2><p>让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站/机构等”，那这个CA机构的公钥是不是也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。</p><p>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链，也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。</p><p>另外，不知你们是否遇到过网站访问不了、提示要安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么没有该机构的根证书，你就得手动下载安装（风险自己承担XD）。安装该机构的根证书后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</p><p>也就是说，公钥是从证书中获取的。证书是网站从机构那边申请来的，证书+签名传给浏览器。只要校验通过，那么公钥必然没有被篡改过，并且一定是这个网站传来的，那么解决了我们最核心的问题：确定公钥是我们指定的网站传来的。</p><p>既然公钥是正确的，那么小红就会用正确的公钥对随机字符串加密，中间不会出现篡改。</p><h2>十六、HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？</h2><p>这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就行。</p><p>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p><h2>十七、HTTPS原理</h2><p>下面再来看看HTTPS原理就特别简单啦！</p><p>HTTPS 协议（<code>HyperText Transfer Protocol over Secure Socket Layer</code>）：可以理解为<code>HTTP</code>+<code>SSL/TLS</code>， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP</span><br><span class="line">SSL/TLS</span><br><span class="line">TCP</span><br><span class="line">IP</span><br></pre></td></tr></table></figure><p>我们只要知道，在SSL层里面可以完成校验和密钥的传输。</p><p><img src="http://bloghello.oursnail.cn/http7-8.png" alt="image"></p><p>理解了上面，这个图也就没啥好解释的了。</p><p>整理自：<a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43789231</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP基础知识提炼</title>
      <link href="/2019/01/18/network/6.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8F%90%E7%82%BC/"/>
      <url>/2019/01/18/network/6.HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%8F%90%E7%82%BC/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第六篇文章。这里简单记录一些关于HTTP的基本概念，比较基础。下面的内容是对《图解HTTP》提炼的再提炼，主要原因是很多重要的东西前面已经详细说过了，还有一些东西知道即可，用到再去查，作为一个后端攻城狮，也没有必要了解那么琐碎。</p><a id="more"></a><h2>HTTP是不保存状态的协议</h2><p>HTTP是无状态协议。自身不对请求和响应之间通信状态进行保存（即不做持久化处理）。 HTTP之所以设计得如此简单，是为了更快地处理大量事物，确保协议的可伸缩性。 HTTP/1.1 随时<strong>无状态协议</strong>，但可通过 Cookie 技术保存状态。</p><h2>告知服务器意图的HTTP方法</h2><ul><li>GET：获取资源</li><li>POST：传输实体主体</li><li>PUT：传输文件</li><li>HEAD：获得报文首部，与GET方法一样，只是不返回报文主体内容。用于确认URI的有效性及资源更新的日期时间等。</li><li>DELETE：删除文件，与PUT相反（响应返回204 No Content）。</li><li>OPTIONS：询问支持的方法，查询针对请求URI指定的资源支持的方法（Allow:GET、POST、HEAD、OPTIONS）。</li><li>TRACE：追踪路径</li><li>CONNECT：要求用隧道协议连接代理（主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输）。</li></ul><h2>URI、URL</h2><p>官方解释都是什么乱起八糟的东西。各种博客也是跟着抄，这两者到底是什么关系和意义？</p><p>统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。</p><p>对应于实际例子就是：每个人都有身份证，这个身份证号码就对应这个人。比如张三的身份证号码为123456，那么我只要知道123456就可以找到这个人。</p><p>那什么是URL呢？从名字看是：统一资源定位器。</p><p>如果做类比，URL就是：动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人</p><p>我们通过这个详细的地址也可以找到张三这个人。</p><p>那么他们俩到底是什么关系呢？</p><p>URI是以某种规则唯一地标识资源，手段不限，比如身份证号。当然了，地址可以唯一标识，那么也属于URI的一种手段。<strong>所以说URL是URI的子集</strong>。</p><p>回到Web上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。</p><p>而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。</p><p>对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息，如果有一天网址通过号码来标识变成了http://741236985.html，那感觉叫成URI更为合适。</p><h2>HTTP请求报文</h2><p><img src="http://bloghello.oursnail.cn/http6-1.png" alt="image"></p><h2>返回结果的HTTP状态码</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。 状态码如200 OK，以3为数字和原因短语组成。 数字中的第一位定义了响应类别，后两位无分类。响应类别有以下五种：</p><table><thead><tr><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息性状态码)</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td></tr></tbody></table><h3>⭐2XX 成功</h3><ul><li><strong>200 OK：请求被正常处理</strong></li><li>204 No Content：一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li><li>206 Partial Content：客户端进行范围请求</li></ul><h3>⭐3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong>：<strong>永久重定向</strong>。表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。 也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</li><li><strong>302 Found</strong>：<strong>临时性重定向</strong>。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI（在Chrome中，还是会保存为重定向后的URI，不解）。</li><li>303 See Other：表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。这与302类似，但303明确表示客户端应当采用GET方法获取资源。</li><li>304 Not Modified：该状态码表示客户端发送附带条件的请求（指采用GET方法的请求报文中包含If-Match,If-Modified-Since，If-None-March，If-Range，If-Unmodified-Since中任一首部。）时，服务器端允许请求访问资源，但因发生请求为满足条件的情况后，直接返回304（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。<br>304虽被划分在3XX类别，但是和重定向没有关系。</li><li>307 Temporary Redirect：临时重定向。与302有相同含义。307遵守浏览器标准，不会从POST变成GET。</li></ul><h3>⭐4XX 客户端错误</h3><p>4XX的响应结果表明客户端是发生错误的原因所在。</p><ul><li><strong>400 Bad Request</strong>：表示请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong>：表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。</li><li><strong>403 Forbidden</strong>：表明对请求资源的访问被服务器拒绝了。服务器端可在实体的主体部分对原因进行描述（可选）</li><li><strong>404 Not Found</strong>：表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时时用。</li></ul><h3>⭐5XX 服务器错误</h3><p>5XX的响应结果表明服务器本身发生错误。</p><ul><li><strong>500 Interval Server Error</strong>：表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</li><li><strong>503 Service Unavailable</strong>：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</li></ul><h2>HTTP的瓶颈</h2><ul><li><strong>一条连接上只可发送一个请求</strong>（前面讲到，持久化可保持TCP连接状态，但仍完成一次请求/响应后才能进行下一次请求/响应，而管线化方式可让一个TCP连接并行发送多个请求。）</li><li><strong>请求只能从客户端开始</strong>。客户端不可以接收除响应以外的指令</li><li><strong>请求/响应首部未经压缩就发送</strong>。首部信息越多延迟越大</li><li><strong>发送冗长(重复)的首部</strong>。每次互相发送相同的首部造成的浪费较多</li></ul><p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。</p><p>使用 SPDY后，HTTP协议额外获得以下功能。</p><ul><li><strong>多路复用流</strong>：通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。</li><li><strong>赋予请求优先级</strong>：SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li><li><strong>压缩HTTP首部</strong>：压缩HTTP请求和响应的首部。</li><li><strong>推送功能</strong>：支持服务器主动向客户端推送数据的功能。</li><li><strong>服务器提示功能</strong>：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</li></ul><h2>WebSocket</h2><p>利用<code>Ajax</code>和<code>Comet</code>技术进行通信可以提升<code>Web</code>的浏览速度。但问题在于通信若使用<code>HTTP</code>协议，就无法彻底解决瓶颈问题。</p><p><code>WebSocket</code>技术主要是为了解决<code>Ajax</code>和<code>Comet</code>里<code>XMLHttpRequst</code>附带的缺陷所引起的问题。</p><p>一旦Web服务器与客户端之间建立起<code>WebSocket</code>协议的通信连接，<strong>之后所有的通信都依靠这个专用协议进行</strong>。通信过程中可互相发送<code>JSON</code>、<code>XML</code>、<code>HTML</code>或图片等任意格式的数据。</p><p><code>WebSocket</code>的主要特点：</p><ul><li><strong>推送功能</strong>：支持由服务器向客户端推送数据。</li><li><strong>减少通信量</strong>：和<code>HTTP</code>相比，<strong>不但每次连接时的总开销减少</strong>，而且由于<code>WebSocket</code>的<strong>首部信息很小，通信量也相应较少</strong>。</li></ul><p>为了实现<code>WebSocket</code>通信，在HTTP连接建立之后，需要完成一次“握手”的步骤。</p><ul><li><strong>握手·请求</strong>：为了实现<code>WebSocket</code>通信，需要用到HTTP的<code>Upgrade</code>首部字段，告知服务器通信协议发生改变，以达到握手的目的。</li><li><strong>握手·响应</strong>：对于之前的请求，返回状态码<code>101 Switching Protocols</code> 的响应。<br>成功握手确立<code>WebSocket</code>连接后，通信时不再使用HTTP的数据帧，而采用<code>WebSocket</code>独立的数据帧。</li></ul><p>由于是建立在<code>HTTP</code>基础上的协议，因此连接的发起方仍是客户端，而一旦确立<code>WebSocket</code>通信连接，不论服务器端还是客户端，任意一方都可直接向对方发送报文。</p><p>整理自：<a href="https://github.com/JChehe/blog/blob/master/posts/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md" target="_blank" rel="noopener">https://github.com/JChehe/blog/blob/master/posts/《图解HTTP》读书笔记.md</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP三次握手和四次挥手</title>
      <link href="/2019/01/18/network/5.TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/01/18/network/5.TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第五篇文章。面试讲到TCP，那么基本都会问三次握手和四次挥手的过程，以及比如对于握手，为什么是三次，而不是两次或者四次，本章详细探讨其中的门道。</p><a id="more"></a><h2>1.复习</h2><p>首先针对http协议，我们有必要复习一下最重要的东西。</p><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p><p>在HTTP 1.0以0.9版本中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p><p>在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p><p>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。</p><p>通常的做法是即使不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道 客户端“在线”。</p><p>若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p><h2>2.SOCKET原理</h2><h3>2.1 套接字（socket）概念</h3><p>初次接触这个名词：“套接字”，说实话，心里是蒙蔽的，这是啥玩意，但是可以去搜索一下什么是套接管：</p><p><img src="http://bloghello.oursnail.cn/http5-1.jpg" alt="image"></p><p>我们可以看出来，两个管子可能直接连的话连不起来，那么可以通过中间一个东西连接起来。</p><p>那么，现在就好理解了，两个程序要通信，需要知道对方的一些信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p><img src="http://bloghello.oursnail.cn/http5-2.jpg" alt="image"></p><p>它是什么呢？它是网络通信过程中端点的抽象表示，这个抽象里面就包含了网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>那为什么一定要用它呢？</p><blockquote><p>在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的进程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。</p></blockquote><p>因为我们电脑上可能会跑很多的应用程序，TCP协议端口需要为这些同时运行的程序提供并发服务，或者说，传输层需要为应用层的多个进程提供通信服务，每个进程起一个TCP连接，那么这多个TCP连接可能是通过同一个 TCP协议端口传输数据。</p><p>如何区别哪个进程对应哪个TCP连接呢？</p><p>许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><h3>2.2 建立socket连接</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为<code>ClientSocket</code> ，另一个运行于服务器端，称为<code>ServerSocket</code> 。</p><p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><p><strong>服务器监听</strong>：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p><p><strong>客户端请求</strong>：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p><p><strong>连接确认</strong>：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p><h3>2.3 SOCKET连接与TCP连接</h3><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p><h2>3.TCP基本字段</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>针对协议中的字段，我们只需要了解一下：ACK、SYN、序号这三个部分。</p><ul><li><p><strong>ACK</strong> : 确认</p><ul><li>TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1</li></ul></li><li><p><strong>SYN</strong> ： 在连接建立时用来同步序号。</p><ul><li>当SYN=1而ACK=0时，表明这是一个连接请求报文。</li><li>对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1.</li><li>因此, SYN置1就表示这是一个连接请求或连接接受报文。</li></ul></li><li><p><strong>FIN</strong> 即终结的意思， 用来释放一个连接。</p><ul><li>当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li></ul></li></ul><h2>4.三次握手(重要，细读)</h2><p><img src="http://bloghello.oursnail.cn/http5-3.jpg" alt="image"></p><p>首先，TCP作为一种可靠传输控制协议，其核心思想：<strong>既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！</strong></p><p>然后，要明确TCP连接握手，握的是啥？</p><p>答案：<strong>通信双方数据原点的序列号</strong>！</p><p>我们在上面一篇文章知道，消息的完整是靠给每个消息包搞一个编号，依次地ACK确认。确认机制是累计的，意味着 X 序列号之前(不包括 X) 包都是被确认接收到的。</p><p>TCP可靠传输的精髓：TCP连接的一方A，由<strong>操作系统动态随机选取一个32位长的序列号（Initial Sequence Number）</strong>。</p><p><strong>假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B。</strong></p><p><strong>让B有一个思想准备</strong>，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。</p><p>如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p><p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p><p>好了，在理解了握手的本质之后，下面就可以总结上面图的握手过程了。</p><p>对于A与B的握手过程，可以总结为：</p><ol><li>A 发送同步信号<code>SYN</code> + <code>A's Initial sequence number</code>（丢失会A会重传）</li><li>B 确认收到A的同步信号，并记录 <code>A's ISN</code> 到本地，命名 <code>B's ACK sequence number</code></li><li>B发送同步信号<code>SYN</code> + <code>B's Initial sequence number</code> （丢失B会周期性超时重传，直到收到A的确认）</li><li>A确认收到B的同步信号，并记录 <code>B's ISN</code> 到本地，命名 <code>A's ACK sequence number</code></li></ol><p><strong>很显然2和3 这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率</strong>。</p><p>这里就会引出一个问题，两次不行吗？</p><ol><li>A 发送同步信号SYN + A’s Initial sequence number</li><li>B发送同步信号SYN + B’s Initial sequence number + B’s ACK sequence number</li></ol><p><strong>这里有一个问题，A与B就A的初始序列号达成了一致，但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。</strong></p><p>所以A必须再给B一个确认，以确认A已经接收到B的同步信号。</p><blockquote><p>如果A发给B的确认丢了，该如何？</p></blockquote><p><strong>A会超时重传这个ACK吗？不会！TCP不会为没有数据的ACK超时重传。</strong></p><p><strong>那该如何是好？B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</strong></p><p>写到这里，其实我们已经明白了，握手其实就是各自确认对方的序列号。因为后面的数据编号就会以此为基础，从而保证后续数据的可靠性。</p><blockquote><p>谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：<strong>client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了</strong>，以致延误到连接释放以后的某个时间才到达server。<strong>本来这是一个早已失效的报文段</strong>。但server收到此失效的连接请求报文段后，就<strong>误认为是client再次发出的一个新的连接请求</strong>。于是就向client发出确认报文段，同意建立连接。<strong>假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了</strong>。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。<strong>但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了</strong>。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。<strong>server由于收不到确认，就知道client并没有要求建立连接</strong>。”</p></blockquote><p>但是有的人指出，其实这只是表象，或者说并不是三次握手的设计初衷，我表示认同，这个防止已失效的连接请求报文段应该只是附加的一些好处，而不应该是解释为什么是三次握手的原因。</p><p><strong>TCP初始阶段为什么是三次握手，原因总结如下：</strong></p><blockquote><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。</p><p>三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤，如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p></blockquote><h2>5.四次挥手</h2><p><img src="http://bloghello.oursnail.cn/http5-4.jpg" alt="image"></p><p>当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；</p><p>但是，这个时候主机1还是可以接受来自主机2的数据；</p><p>当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；</p><p>当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了；</p><p>主机1告诉主机2知道了，主机2收到这个确认之后就立马关闭自己。</p><p>主机1等待2MSL之后也关闭了自己。</p><p>针对最后一条消息，即主机1发送ack后，主机2接收到此消息，即认为双方达成了同步：双方都知道连接可以释放了，此时B可以安全地释放此TCP连接所占用的内存资源、端口号。</p><p><strong>所以被动关闭的B无需任何wait time，直接释放资源。</strong></p><p><strong>但是主机1并不知道主机2是否接到自己的ACK，主机1是这么想的</strong>：</p><ul><li>如果主机2没有收到自己的ACK，主机2会超时重传FiN，那么主机1再次接到重传的FIN，会再次发送ACK</li><li>如果主机2收到自己的ACK，也不会再发任何消息，包括ACK</li></ul><p>无论是情况1还是2，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：</p><p>主机2没有收到主机1的ACK，那么超时之后主机2会重传FIN，也就是说，要浪费一个<strong>主机1发出ACK的最大存活时间(MSL)+FIN消息的最大存活时间(MSL)</strong></p><p>不可能时间再多了，这个已经针对最糟糕的状况。</p><p>等待2MSL时间，A就可以放心地释放TCP占用的资源、端口号，此时可以使用该端口号连接任何服务器。</p><p>在等待的时间内，主机2可以重试多次，因为2MSL时间为240秒，超时重传只有0.5秒，1秒，2秒，，16秒。</p><p>当主机2重试次数达到上限，主机2会reset连接。</p><p>那么为什么是2MSL我们已经了解了，但是为什么要等这个时间呢？</p><p>如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部死翘翘，2MSL时间可以满足这个需求。</p><p>整理自：</p><ul><li><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633</a></li><li><a href="https://www.zhihu.com/question/67013338" target="_blank" rel="noopener">https://www.zhihu.com/question/67013338</a></li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/14</a></li><li><a href="https://www.jianshu.com/p/9968b16b607e" target="_blank" rel="noopener">https://www.jianshu.com/p/9968b16b607e</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP协议入门</title>
      <link href="/2019/01/18/network/4.TCP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
      <url>/2019/01/18/network/4.TCP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第四篇文章。首先要明确：信道本身不可靠（丢包、重复包、出错、乱序），不安全。所以引出了七层或五层模型来保证。因此，任何一个东西的提出都是为了解决某个问题的。学习计算机，从他的历史出发，理解为什么会有不断低迭代，因为是为了解决某个痛点问题。比如HTTP的发展，为什么在HTTP1.0基础上还要提出HTTP1.1，为什么还要提出HTTP2.0，我们学习了他的发展历史之后就会明白了。同样，下面再说一说为什么要有TCP协议，TCP到底解决了什么问题。</p><a id="more"></a><h2>一、回顾</h2><p>首先简单回顾一下。</p><h3>1.1 物理层</h3><p>物理层是相当于物理连接，将0101以电信号的形式传输出去。</p><h3>1.2 数据链路层</h3><p>数据链路层，有一个叫做以太网协议，规定了电子信号是如何组成数据包的，这个协议的头里面，包含了自身的网卡信息，还有目的地的网卡信息（一般我们可以知道对方的IP，IP可以通过DNS解析到，然后根据ARP协议将IP转换为MAC地址）。那么，如果在同一个局域网内，我们就可以通过广播的方式找到对应MAC地址的主机。—即以太网协议解决了子网内部的点对点通信。</p><h3>1.3 网络层</h3><p>但是呢，以太网协议不能解决多个局域网通信，每个局域网之间不是互通的，那么以太网这种广播的方式不可用，就算可用，网络那么大，通过广播进行找，是一个可怕的场景。那么，IP协议可以连接多个局域网，简单来说，IP 协议定义了一套自己的地址规则，称为 IP 地址。物理器件，比如说路由器，就是基于IP协议，里面保存一套地址指路牌，想去哪个局域网，可以通过这个牌子来找，然后逐步路由到目标局域网，最后就可以找到那台主机了。IP层就是对应了网络层。</p><h3>1.4 传输层</h3><p>那么，此时解决了多个局域网路由问题，也解决了局域网内寻址问题，即我这台主机已经可以找到那台主机了，下面还有什么事情需要做呢？显然，找到主机还不行啊，比如我用微信发一条消息，我发到你主机了，但是你主机上的微信不知道这条消息发给他了，这里说的就是端口，信息要发到这个端口上，监听这个端口的程序才会收到消息。</p><h3>1.5 应用层</h3><p>OK，最上层的应用层，就是最贴近用户的，他的一系列协议只是为了让两台主机会互相都理解而已。</p><h2>二、问题和解决</h2><h3>2.1 存在的问题</h3><p>在明白了计算机网络为什么要这几层模型之后，我们再回到一开始，如何保证安全、可靠、完整地传输信息呢？</p><p>很显然，上面提到的，只是保证信息能找到对方主机和端口，但是这个信息中途被拦截了、甚至被篡改了、信息延迟了（几分钟或者几个小时，或者几个世纪）、网络不通或者挂了，信息自己可不会告诉你他挂了或者要迟到一会，如果没有一个协议来保障可靠性，那么我这条消息发出去，能不能到、能不能及时到、能不能完整到、能不能不被篡改到等这些问题将会造成灾难，网络传输也就没有了意义。</p><p>计算机的前辈们，为我们提供了一系列的措施来尽可能保证信息能正确送达。</p><h3>2.2 数据校验</h3><p>首先在数据链路层，可以通过各种校验，比如奇偶校验等手段来判断数据包传的是否正确。</p><h3>2.3 数据可靠性</h3><p>好了，解决了数据是否正确之后，但是还不能保证线路是可靠的，加入某个包没发出去或者发错了，应该有一个出错重传机制，保证信息传输的可靠性。这就引出了TCP协议。</p><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>下面来看看TCP是如何解决丢包、重复包、出错、乱序等不可靠的一些问题的。</p><h2>三、滑动窗口协议的提出</h2><p>这就引出了TCP中最终的一个东西：滑动窗口协议。</p><h3>3.1 朴素的方法来确保可靠性</h3><p>先从简单的角度出发，自己想一下，如何保证不丢包、不乱序。</p><p><img src="http://bloghello.oursnail.cn/http3-1.png" alt="image"></p><p>按照顺序，发送一个确认一个，显然，吞吐量非常低。那么，一次性发几个包，然后一起确认呢？</p><h3>3.2 改进方案</h3><p><img src="http://bloghello.oursnail.cn/http3-2.png" alt="image"></p><p>那么就引出第二个问题，我一次性发几个包合适呢？就这引出了滑动窗口。</p><h2>四、数据包编号和重传机制</h2><h3>4.1 数据包编号</h3><p>在说明滑动窗口原理之前，必须要说一下TCP数据包的编号SEQ。</p><p>我们知道，由于以太网数据包大小限制，所以每个包承载的数据是有限的，如果发一个很大的包，必然是要拆分的。</p><p>发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。</p><p>第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。</p><h3>4.2 数据重传机制</h3><p>TCP协议就是根据这些编号来重新还原文件的。并且接收端保证顺序性返回ACK确认，比如有两个包发过去，为1号和2号，2号接收成功，但是发现1号包还没接收到，所以2号的ACK是不会发回去的，这个时候，如果在重传时间内收到1号了，那么就把这两个包的ACK都返回回去，如果超时了，就重传1号包。知道1号包接收成功，后续的才会返回ACK。</p><p>具体是如何做到的呢？</p><p>前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。</p><p>举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。</p><p>如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</p><p><img src="http://bloghello.oursnail.cn/http3-5.png" alt="image"></p><p>（图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。）</p><h2>五、慢启动</h2><p>下面再来说说慢启动。</p><p>服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。</p><p>最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。</p><p>TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。</p><p>Linux 内核里面设定了（常量<code>TCP_INIT_CWND</code>），刚开始通信的时候，发送方一次性发送10个数据包，即&quot;发送窗口&quot;的大小为10。然后停下来，等待接收方的确认，再继续发送。</p><p>默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。&quot;确认&quot;的英语是 <code>acknowledgement</code>，所以这个确认消息就简称 ACK。</p><p>ACK 携带两个信息：</p><ul><li>期待要收到下一个数据包的编号</li><li>接收方的接收窗口的剩余容量</li></ul><p>发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为&quot;发送窗口&quot;，这个窗口的大小是可变的。</p><p>我们可以知道，发送发和接收方都维护了一个缓冲区，可以理解为窗口。根据接收速度可以调整发送速度，逐渐达到这条线路最高的传输速率。</p><p>ok，下面就可以研究一下滑动窗口了。</p><h2>六、滑动窗口原理</h2><p>正常情况下：</p><p><img src="http://bloghello.oursnail.cn/http3-6.png" alt="image"></p><p>（如图，123表示已经正常发送并且收到了ACK确认。4567属于已发送但是还没有收到ACK。8910表示待发送。这个窗口当前长度为7.正常情况下，4号包收到ACK，那么窗口就会右移一格。）</p><p>但是往往会出现一些问题，比如5号包迟迟收不到ACK，在接收端可能是没有收到5号包，但是可能会收到6号包甚至是7、8号包，那么此时只能等待5号包，如果5号包顺利到达了，那么就把5678号包的ACK都发给发送端，那么发送端滑动窗口向右右移四格。如果迟迟收不到5号包，只能重传。</p><p><img src="http://bloghello.oursnail.cn/http3-3.png" alt="image"></p><p>以上就是关于TCP中比较重要的出错重传、编号、慢启动以及滑动窗口。这些保证了数据传输的可靠性。</p><p>整理自：<a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>http的前世今生</title>
      <link href="/2019/01/17/network/3.http%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/01/17/network/3.http%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第三篇文章。作为一个后端攻城狮，每天打交道最多的就是HTTP协议，在如今火热的微服务实现方案中，除了阿里的dubbo，就是spring cloud，而spring cloud目前适用的服务间通信方式也就是基于HTTP 的 restful接口来实现。并且作为浏览器上用的最多的协议，无论是前端、后端还是测试都应该去熟悉它，软件的发展是循序渐进的，每次的迭代升级都是为了解决上一版本的痛点，HTTP协议的发展也是如此，本章着重讲解HTTP的前世今生，让我们更加了解HTTP。</p><a id="more"></a><p>HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p><h2>一、HTTP/0.9</h2><h3>1.1 简介</h3><p>这是第一个定稿的HTTP协议。</p><ul><li>内容非常简单，只有一个命令GET</li><li>没有HEADER等描述数据的信息</li><li>服务器发送完毕，就关闭TCP连接（一个HTTP请求在一个TCP连接中完成）</li></ul><h3>1.2 请求格式</h3><p>比如发起一个GET请求：</p><blockquote><p>GET /index.html</p></blockquote><p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。</p><h3>1.3 响应格式</h3><p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务器发送完毕，就关闭TCP连接。</p><h2>二、HTTP/1.0</h2><h3>2.1 简介</h3><p>跟现在比较普遍适用的1.1版本已经相差不多。</p><ul><li>增加很多命令，比如POST、HEAD等命令</li><li>增加status code 和 header</li><li>多字符集支持、多部分发送、权限、缓存等</li></ul><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><h3>2.2 请求格式</h3><p>下面是一个1.0版的HTTP请求的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>可以看到，这个格式与0.9版有很大变化。<br>第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。</p><p>客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。上面代码中，客户端声明自己可以接受任何格式的数据。</p><h3>2.3 响应格式</h3><p>服务器的回应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK </span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>回应的格式是&quot;头信息 + 一个空行（\r\n） + 数据&quot;。其中，第一行是&quot;协议版本 + 状态码（status code） + 状态描述&quot;。</p><h3>2.4 Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。</p><h3>2.5 缺点</h3><p>每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。</p><blockquote><p>Connection: keep-alive</p></blockquote><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p><blockquote><p>Connection: keep-alive</p></blockquote><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h2>三、HTTP/1.1</h2><h3>3.1 持久连接和管道机制</h3><ul><li>持久连接（以前的版本中，一个HTTP请求就创建一个TCP连接，请求返回之后就关闭TCP连接，然而建立一次TCP连接的过程是比较耗时的，效率会比较低，现在建立一个TCP连接后，后面的HTTP请求都可以复用这个TCP连接，即允许了在同一个连接里面发送多个请求，会提高效率）</li><li>pipeline（解决了同一个TCP连接中客户端可以发送多个HTTP请求，但是对于服务端来说，对于进来的请求要按照顺序进行内容的返回，如果前一个请求处理时间长，而后一个请求处理时间端，即便后面一个请求已经处理完毕了，也要等待前一个请求处理完毕返回他才可以返回结果，这种串行的方式比较慢）</li></ul><p>在1.1版本以前，每次HTTP请求，都会重新建立一次TCP连接，服务器响应后，就立刻关闭。众所周知，建立TCP连接的新建成本很高，因为需要三次握手，并且有着慢启动的特性导致发送速度较慢。而1.1版本添加的持久连接功能可以让一次TCP连接中发送多条HTTP请求，<strong>值得一提的是默认是，控制持久连接的Connection字段默认值是keep-alive，也就是说是默认打开持久连接，如果想要关闭，只需将该字段的值改为close。</strong></p><blockquote><p>Connection: close</p></blockquote><p>而管道化则赋予了客户端在一个TCP连接中连续发送多个请求的能力，而不需要等到前一个请求响应，这大大提高了效率。值得一提的是，虽然客户端可以连续发送多个请求，但是服务器返回依然是按照发送的顺序返回。（强调的是request不需要等待上一个request的response，其实发送的request还是有顺序的，服务端按照这个顺序接收，依次返回响应）</p><p>HTTP/1.1允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。（me：所有请求保持一个FIFO的队列，一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出；同时，服务器端返回这些请求的响应时也是按照FIFO的顺序）。管道化的表现可以大大提高页面加载的速度，尤其是在高延迟连接中。</p><h3>3.2 Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。</p><blockquote><p>Content-Length: 3495</p></blockquote><p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p><p>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p><h3>3.3 分块传输编码</h3><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用&quot;流模式&quot;（stream）取代&quot;缓存模式&quot;（buffer）。</p><p>因此，1.1版规定可以不使用Content-Length字段，而使用&quot;分块传输编码&quot;（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。</p><blockquote><p>Transfer-Encoding: chunked</p></blockquote><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1C</span><br><span class="line">and this is the second one</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">con</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">sequence</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3>3.3 其他功能</h3><p>1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p><p>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</p><blockquote><p>Host: <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></p></blockquote><p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p><h3>3.4 缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为&quot;队头堵塞&quot;（Head-of-line blocking）。</p><h2>四、SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p><p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p><h2>五、HTTP/2</h2><h3>5.1 二进制协议</h3><p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。</p><p>HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><h3>5.2 多工</h3><p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了&quot;队头堵塞&quot;。</p><p><strong>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</strong></p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><h3>5.3 数据流</h3><p><strong>因为 HTTP/2 的数据包是不按顺序发送的</strong>，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><h3>5.4 头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><h3>5.5 服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><p>整理自：<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从上到下看五层模型</title>
      <link href="/2019/01/17/network/2.%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/01/17/network/2.%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第二篇文章。经过上一篇文章的详细介绍，我们了解了一个数据是如何从物理层一步一步到达应用层的，那么本章从上而下的角度来看看一条请求时如何从浏览器传递到服务器并且返回的。</p><a id="more"></a><p>这个过程看的就是用户从浏览器输入一条url之后，是如何发送过去的。</p><h2>1.上一篇文章的小结</h2><p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：</p><p><img src="http://bloghello.oursnail.cn/http1-7.png" alt="image"></p><p>发送这个包，需要知道两个地址：</p><ul><li>对方的MAC地址</li><li>对方的IP地址</li></ul><p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p><p><img src="http://bloghello.oursnail.cn/http2-1.png" alt="image"></p><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。</p><p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。</p><p>有了一台新电脑之后，要想上网，一种方式是自己配置静态IP：</p><p><img src="http://bloghello.oursnail.cn/http2-2.png" alt="image"></p><p>很多人都没有进行过这个配置，因为一般情况下我们根本不需要这样。但是有的时候也会用到，比如我在电信实习的时候，他们每一个网口旁边都贴着这四个参数，你联网必须要适用他提供的一系列地址才行。其实经过上面的学习，我们已经知道，通信的时候，需要知道对方的IP（ARP知道对方的MAC地址）、子网掩码（确定所在的子网）、默认网关（不在一个子网，要通过网关取转发、路由）、DNS服务器（解析域名为IP地址）。</p><p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用&quot;动态IP地址上网&quot;。</p><h2>2.DHCP协议</h2><p>所谓&quot;动态IP地址&quot;，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。</p><p><strong>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址</strong>，它叫做&quot;DHCP服务器&quot;。新的计算机加入网络，必须向&quot;DHCP服务器&quot;发送一个&quot;DHCP请求&quot;数据包，申请IP地址和相关的网络参数。</p><p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，<strong>新加入的计算机不知道DHCP服务器的两个地址，怎么发送数据包呢</strong>？</p><p>DHCP协议做了一些巧妙的规定。</p><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p><p><img src="http://bloghello.oursnail.cn/http2-3.png" alt="image"></p><p>（1）最前面的&quot;以太网标头&quot;，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p>（2）后面的&quot;IP标头&quot;，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p>（3）最后的&quot;UDP标头&quot;，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。</p><p>因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。</p><p>当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道&quot;这个包是发给我的&quot;，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个&quot;DHCP响应&quot;数据包。</p><p>这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><p>动态拿到最核心的四个参数：自己的IP地址、子网掩码、网关地址、DNS服务器，就可以联网了。</p><h2>3.访问google的过程</h2><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p><ul><li>本机的IP地址：192.168.1.100</li><li>子网掩码：255.255.255.0</li><li>网关的IP地址：192.168.1.1</li><li>DNS的IP地址：8.8.8.8</li></ul><p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>。</p><p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><h3>3.1 DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，<a href="http://xn--www-ot9d81uoqfzzwl33bu7n883b.google.com" target="_blank" rel="noopener">我们只知道网址www.google.com</a>，不知道它的IP地址。</p><p>DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p><p><img src="http://bloghello.oursnail.cn/http2-4.png" alt="image"></p><p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><h3>3.2 子网掩码</h3><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p><h3>3.3 应用层协议</h3><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p><p><img src="http://bloghello.oursnail.cn/http2-5.png" alt="image"></p><p>HTTP部分的内容，类似于下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　GET / HTTP/1.1</span><br><span class="line">　　Host: www.google.com</span><br><span class="line">　　Connection: keep-alive</span><br><span class="line">　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ......</span><br><span class="line">　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">　　Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">　　Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3</span><br><span class="line">　　Cookie: ... ...</span><br></pre></td></tr></table></figure><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><h3>3.4 TCP协议</h3><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p><h3>3.5 IP协议</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p><h3>3.6 以太网协议</h3><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><h3>3.7 服务器响应</h3><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的&quot;HTTP请求&quot;，接着做出&quot;HTTP响应&quot;，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p><p>整理自：<a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从下到上看五层模型</title>
      <link href="/2019/01/17/network/1.%E4%BB%8E%E4%B8%8B%E5%88%B0%E4%B8%8A%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/01/17/network/1.%E4%BB%8E%E4%B8%8B%E5%88%B0%E4%B8%8A%E7%9C%8B%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>这是计算机网络相关的第一篇文章。要想了解HTTP协议，必然要从最基本的计算机网络知识开始入手。本篇文章从下到上具体介绍五层经典模型，极速入门计算机网络。</p><a id="more"></a><h2>经典五层模型</h2><p><img src="http://bloghello.oursnail.cn/http1-6.png" alt="image"></p><p>下面我们先来了解一下各层做的事情！</p><h2>1.物理层</h2><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p><p>这就叫做&quot;物理层&quot;，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p><h2>2.数据链路层</h2><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p><p>这就是&quot;链接层&quot;的功能，它在&quot;实体层&quot;的上方，确定了0和1的分组方式。</p><h3>2.1 以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做&quot;以太网&quot;（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做&quot;帧&quot;（Frame）。每一帧分成两个部分：<strong>标头</strong>（Head）和<strong>数据</strong>（Data）。</p><p><img src="http://bloghello.oursnail.cn/http1-2.png" alt="image"></p><p>&quot;标头&quot;包含数据包的一些说明项，比如发送者、接受者、数据类型等等；&quot;数据&quot;则是数据包的具体内容。</p><p>&quot;标头&quot;的长度，固定为18字节。&quot;数据&quot;的长度，最短为46字节，最长为1500字节。因此，整个&quot;帧&quot;最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><h3>2.2 MAC地址</h3><p>上面提到，以太网数据包的&quot;标头&quot;，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p><p>以太网规定，连入网络的所有设备，都必须具有&quot;网卡&quot;接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h3>2.3 广播</h3><p>定义地址只是第一步，后面还有更多的步骤。</p><p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p><p>回答是有一种ARP协议，可以解决这个问题。下面介绍ARP。</p><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？</p><p>回答是以太网采用了一种很&quot;原始&quot;的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><p><img src="http://bloghello.oursnail.cn/http1-1.png" alt="image"></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的&quot;标头&quot;，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做&quot;广播&quot;（broadcasting）。</p><p>有了数据包的定义、网卡的MAC地址、广播的发送方式，&quot;链接层&quot;就可以在多台计算机之间传送数据了。</p><h2>3.网络层</h2><p>以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一&quot;包&quot;，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用&quot;路由&quot;方式发送。（&quot;路由&quot;的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了&quot;网络层&quot;的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做&quot;网络地址&quot;，简称&quot;网址&quot;。</p><p>于是，&quot;网络层&quot;出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><h3>3.1 IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数&quot;子网掩码&quot;（subnet mask）。</p><p>所谓&quot;子网掩码&quot;，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道&quot;子网掩码&quot;，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><h3>3.2 IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p><p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p><p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的&quot;数据&quot;部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p><p>具体来说，IP数据包也分为&quot;标头&quot;和&quot;数据&quot;两个部分。&quot;标头&quot;部分主要包括版本、长度、IP地址等信息，&quot;数据&quot;部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p><p><img src="http://bloghello.oursnail.cn/http1-3.png" alt="image"></p><p>IP数据包的&quot;标头&quot;部分的长度为20个字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的&quot;数据&quot;部分，最长为65,515字节。前面说过，以太网数据包的&quot;数据&quot;部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><h3>3.3 ARP协议</h3><p>关于&quot;网络层&quot;，还有最后一点需要说明。</p><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的，但是我们不知道它的MAC地址。</p><p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的&quot;网关&quot;（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个&quot;广播&quot;地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h2>4. 传输层</h2><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p><p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做&quot;端口&quot;（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>&quot;端口&quot;是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>&quot;传输层&quot;的功能，就是建立&quot;端口到端口&quot;的通信。相比之下，“网络层&quot;的功能是建立&quot;主机到主机&quot;的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做&quot;套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p><h3>4.1 UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由&quot;标头&quot;和&quot;数据&quot;两部分组成。</p><p><img src="http://bloghello.oursnail.cn/http1-2.png" alt="image"></p><p>&quot;标头&quot;部分主要定义了发出端口和接收端口，&quot;数据&quot;部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的&quot;数据&quot;部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p><p><img src="http://bloghello.oursnail.cn/http1-4.png" alt="image"></p><p>UDP数据包非常简单，&quot;标头&quot;部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h3>4.2 TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的&quot;数据&quot;部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><p>关于TCP细节以后再探讨。</p><h2>5. 应用层</h2><p>应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p><p>&quot;应用层&quot;的作用，就是规定应用程序的数据格式。</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&quot;数据&quot;部分。因此，现在的以太网的数据包就变成下面这样。</p><p><img src="http://bloghello.oursnail.cn/http1-7.png" alt="image"></p><blockquote><p>*注：UDP头为8个字节，TCP头为20个字节</p></blockquote><p>整理于：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p>]]></content>
      
      
        <tags>
            
            <tag> 计算机网络相关 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
